(* ::Package:: *)

(* ::Text:: *)
(*\[Copyright] 2011-2023 Emerald Cloud Lab, Inc.*)


(* ::Section:: *)
(*Source Code*)


(* ::Subsection::Closed:: *)
(*DefineOptions*)


DefineOptions[AnalyzeComposition,
	Options :> {
		{
			OptionName -> PreferredConcentrationType,
			Default -> MolarConcentration,
			Description -> "The preferred units of concentration that will be returned in the analysis. This can be overridden by the StandardConcentrations option.",
			AllowNull -> False,
			Category -> "Method",
			Widget -> Widget[Type->Enumeration,Pattern:>MassConcentration|MolarConcentration|MassPercent|VolumePercent]
		},
		{
			OptionName -> StandardData,
			Default -> Automatic,
			Description -> "The data objects to use as standards for the composition analysis.",
			ResolutionDescription -> "Automatic defaults to all objects in the StandardData field of input protocol for which Peaks have been assigned.",
			AllowNull -> False,
			Category -> "Standards",
			Widget -> Adder[
				Widget[Type->Object,Pattern:>ObjectP[Object[Data]]]
			]
		},
		{
			OptionName -> StandardConcentrations,
			Default -> Automatic,
			Description -> "For each StandardData object, the concentration of each analyte in the corresponding Standard (in any units). Empty list {} indices that no standards have been identified.",
			ResolutionDescription -> "Automatic computes concentration based on the Composition fields of StandardData objects based on analytes that have been identified in Peaks analyses.",
			AllowNull -> False,
			Category -> "Standards",
			Widget -> Adder[Alternatives[
				Adder[
					{
						"Analyte"->Widget[Type->Object,Pattern:>ObjectP[Model[Molecule]]],
						"Concentration"->Widget[Type->Expression,Pattern:>UnitsP[],Size->Word]
					}
				],
				Widget[Type->Enumeration,Pattern:>Alternatives[{}]]
			]]
		},
		{
			OptionName -> ExcludeStandard,
			Default -> Automatic,
			Description -> "Indices of standards that should be excluded from the analysis. Corresponds to the indices of objects in the Standards field of the input Object[Protocol,HPLC].",
			AllowNull -> False,
			Category -> "Standards",
			Widget -> Alternatives[
				"Exclude Indices"->Adder[Widget[Type->Number,Pattern:>GreaterP[0,1]]],
				"No Exclusions"->Widget[Type->Expression,Pattern:>{},Size->Word]
			]
		},
		{
			OptionName -> Name,
			Default -> Null,
			Description -> "Name to be used as the name of Object[Analysis, Composition] generated by the analysis.",
			AllowNull -> True,
			Category -> "Upload",
			Widget -> Widget[Type->Expression,Pattern:>_String,Size->Line]
		},
		{
			OptionName -> UpdateSampleComposition,
			Default -> False,
			Description -> "Indicate whether the Composition of the SamplesIn of input protocol should be updated with the results of this calculation.",
			AllowNull -> False,
			Category -> "Upload",
			Widget -> Widget[Type->Enumeration, Pattern:>Alternatives[True,False]]
		},
		OutputOption,
		UploadOption
	}
];


(* ::Subsection::Closed:: *)
(*AnalyzeComposition*)


AnalyzeComposition[myProtocol:ObjectP[Object[Protocol,HPLC]],myOptions:OptionsPattern[AnalyzeComposition]]:=Module[
	{
		listedOptions,outputSpecification,output,gatherTests,safeOptions,safeOptionTests,validLengths,validLengthTests,
		suppliedCache,downloadedPackets,cache,updatedOptions,unresolvedOptions,combinedOptions,expandedOptions,resolvedOptionsResult,
		resolvedOptionTests,resolvedOptionsTestResult,resolvedOptions,resolvedOptionsTests,previewRule,packets,compositionPacket,
		resolvedStandardConcentrations,updatePackets,allPackets,optionsRule,testsRule,resultRule
	},

	(* Make sure we're working with a list of options *)
	listedOptions=ToList[myOptions];

	(* Determine the requested return value from the function *)
	outputSpecification=Lookup[listedOptions,Output,Result];
	output=ToList[outputSpecification];

	(* Determine if we should keep a running list of tests *)
	gatherTests=MemberQ[output,Tests];

	(* Call SafeOptions to make sure all options match pattern *)
	{safeOptions,safeOptionTests}=If[gatherTests,
		SafeOptions[AnalyzeComposition,listedOptions,Output->{Result,Tests},AutoCorrect->False],
		{SafeOptions[AnalyzeComposition,listedOptions,AutoCorrect->False],Null}
	];

	(* If the specified options don't match their patterns return $Failed (or the tests up to this point)  *)
	If[MatchQ[safeOptions,$Failed],
		Return[outputSpecification/.{
			Result -> $Failed,
			Tests -> safeOptionTests,
			Options -> $Failed,
			Preview -> Null
		}]
	];

	(* Call ValidInputLengthsQ to make sure all options are the right length *)
	{validLengths,validLengthTests}=If[gatherTests,
		ValidInputLengthsQ[AnalyzeComposition,{myProtocol},listedOptions,Output->{Result,Tests}],
		{ValidInputLengthsQ[AnalyzeComposition,{myProtocol},listedOptions],Null}
	];

	(* If option lengths are invalid return $Failed (or the tests up to this point) *)
	If[!validLengths,
		Return[outputSpecification/.{
			Result -> $Failed,
			Tests -> Join[safeOptionTests,validLengthTests],
			Options -> $Failed,
			Preview -> Null
		}]
	];

	(* --- Download explicit cache to get information needed by resolveAnalyzeCompositionOptions --- *)
	suppliedCache=Lookup[listedOptions,Cache,{}];
	downloadedPackets=Quiet[Flatten[Download[
		{myProtocol},
		{
			(* Information about the HPLC protocol. *)
			(* Note: AliquotVolumes and AssayVolumes are legacy but we support them because of old protocols that should be analyzed. *)
			Packet[SamplesIn,AliquotSamples,AliquotVolumes,AssayVolumes,AliquotSamplePreparation,Standards,StandardData,Data,DateStarted],
			(* First level standards information (in case there is no recursion). *)
			Packet[Standards[{Model,PreparedAmounts,VolumeLog,TransfersIn,TransfersOut,Composition,Mass,Volume}]],
			(* Recursive download about information from the PreparedAmounts field. *)
			Packet[Standards[Model][Repeated[PreparedAmounts[[All,1]]]][{Model,PreparedAmounts,VolumeLog,TransfersIn,TransfersOut}]],
			Packet[Standards[Model][{TotalVolume,Formula}]],
			(* Recursive download about information from the Formula field. *)
			Packet[Standards[Model][Repeated[Formula[[All,2]]]][{Formula,TotalVolume}]],
			(* Information about peak analyses from the data. *)
			Packet[StandardData[AbsorbancePeaksAnalyses][{PeakAssignment,Position,Area,Height,TailingFactor,PeakLabel,AdjacentResolution}]],
			Packet[Data[AbsorbancePeaksAnalyses][{PeakAssignment,Position,Area,Height,TailingFactor,PeakLabel,AdjacentResolution}]]
		},
		Cache->suppliedCache
	]]]/.$Failed->Null;

	cache=Join[suppliedCache,Flatten[downloadedPackets]];

	(* Call resolve<Function>Options *)
	(* Build the resolved options *)
	resolvedOptionsResult=If[gatherTests,
		(* We are gathering tests. This silences any messages being thrown. *)
		{resolvedOptions,resolvedOptionsTests}=resolveAnalyzeCompositionOptions[myProtocol,safeOptions,Cache->cache,Output->{Result,Tests}];

		(* Therefore, we have to run the tests to see if we encountered a failure. *)
		If[RunUnitTest[<|"Tests"->resolvedOptionsTests|>,OutputFormat->SingleBoolean,Verbose->False],
			{resolvedOptions,resolvedOptionsTests},
			$Failed
		],

		(* We are not gathering tests. Simply check for Error::InvalidInput and Error::InvalidOption. *)
		Check[
			{resolvedOptions,resolvedOptionsTests}={resolveAnalyzeCompositionOptions[myProtocol,safeOptions,Cache->cache],{}},
			$Failed,
			{Error::InvalidInput,Error::InvalidOption}
		]
	];

	(* If option resolution failed, return early. *)
	If[MatchQ[resolvedOptionsResult,$Failed],
		Return[outputSpecification/.{
			Result -> $Failed,
			Tests->Join[safeOptionTests,validLengthTests,resolvedOptionsTests],
			Options->safeOptions,
			Preview->Null
		}]
	];

	(* We can now safely perform our analysis. The last packet returned will be the packet for our Object[Analysis,Composition]. *)
	(* Note: No tests are collected in this packet function since all tests are generated beforehand in the option resolver. *)
	packets=analyzeCompositionPackets[myProtocol,listedOptions,resolvedOptions,Cache->cache];
	compositionPacket=Last[packets];

	(* Resolve the StandardConcentrations option, since this depends on results of the analysis *)
	resolvedStandardConcentrations=resolveConcentrationOption[compositionPacket,resolvedOptions];

	(* If requested, generated update packets for the sample compositions *)
	updatePackets=If[Lookup[resolvedOptions,UpdateSampleComposition],
		generateUpdatePackets[compositionPacket,Cache->cache],
		{}
	];

	(* Join the packets together *)
	allPackets=Join[updatePackets,packets];

	(* --- Generate rules for each possible Output value ---  *)

	(* Prepare the Options result if we were asked to do so *)
	optionsRule=Options->If[MemberQ[output,Options],
		ReplaceRule[resolvedOptions,
			StandardConcentrations->resolvedStandardConcentrations
		],
		Null
	];

	(* Prepare the Preview result if we were asked to do so *)
	previewRule=Preview->If[MemberQ[output,Preview],
		Quiet@Check[TabView[
			{
				"Assay (Samples)"->Framed[#,FrameStyle->White]&@Pane[
					PlotTable[
						Transpose@Lookup[
							stripAppendReplaceKeyHeads@compositionPacket,
							{AssaySamples,DilutionFactors,AssayData,AssayModels,AssayAreas,AssayCompositions}
						]/.{obj:ObjectP[]:>If[MatchQ[obj[Name],_String],Append[obj[Type],obj[Name]],obj[Object]]},
						TableHeadings->{None,{"Sample","Dilution Factor","Data","Analyte","Peak Area","Concentration"}},
						Alignment->{Center,Center}
					],
					Alignment->{Center,Automatic},
					ImageSize->If[MatchQ[$ECLApplication,CommandCenter],{800,400},Automatic],
					ImageSizeAction->"Scrollable"
				],
				"Standards"->Framed[#,FrameStyle->White]&@Pane[
					PlotTable[
						Transpose@Lookup[
							stripAppendReplaceKeyHeads@compositionPacket,
							{StandardSamples,StandardData,StandardModels,StandardAreas,StandardCompositions}
						],
						TableHeadings->{None,{"Standard","StandardData","Analyte","Peak Area","Concentration"}},
						Alignment->{Center,Center}
					]/.{obj:ObjectP[]:>If[MatchQ[obj[Name],_String],Append[obj[Type],obj[Name]],obj[Object]]},
					Alignment->{Center,Automatic},
					ImageSize->If[MatchQ[$ECLApplication,CommandCenter],{800,400},Automatic],
					ImageSizeAction->"Scrollable"
				]
			},
			Alignment->{Center,Top},
			ImageSize->Automatic
		],"Preview Failed"],
		Null
	];


	(* Prepare the Test result if we were asked to do so *)
	testsRule=Tests->If[MemberQ[output,Tests],
		(* Join all exisiting tests generated by helper funcctions with any additional tests *)
		Join[safeOptionTests,validLengthTests,resolvedOptionsTests],
		Null
	];

	(* Prepare the standard result if we were asked for it and we can safely do so *)
	resultRule=Result->If[MemberQ[output,Result],
		If[TrueQ[Lookup[safeOptions,Upload]]&&MemberQ[output,Result],
			Last[Upload[allPackets]],
			Reverse@allPackets
		],
		Null
	];

	(* Return our requested output. *)
	outputSpecification/.{previewRule,optionsRule,testsRule,resultRule}
];


(* ::Subsection::Closed:: *)
(*resolveAnalyzeCompositionOptions*)


DefineOptions[resolveAnalyzeCompositionOptions,
	Options:>{
		HelperOutputOption,
		CacheOption
	}
];

Error::InvalidExcludeStandardsOption="The indices `1` specified in option ExcludeStandard exceed the number of standards in this protocol, `2`. Please remove these indices from the ExcludeStandard option.";
Error::NoStandardsFound="Input protocol `1` is either missing Standards, or has not had its StandardData peak-picked yet. Please make sure the Standards field is populated, and that AnalyzePeaks[] has been used to assign peaks to StandardData.";
Error::NoStandardsForSamples="The following analyte model(s), `1`, were resolved from the SamplesIn of the input protocol, but could not be found in the Composition of included Standards. Please make sure that the correct sample model(s) have been assigned to the sample peak(s) or assign these analyte model(s) to peaks in the Standards.";
Warning::AnalytesNotFound="The analytes `1` at indices `2` in StandardConcentrations could not be matched to any picked peaks in their corresponding StandardData objects. Missing analyte concentrations in these standards will not be used in the analysis.";
Warning::InvalidCompositionUpdate="The Composition fields of SamplesIn could not be updated because computed concentrations have units of `1`, which do not match CompositionP. UpdateSampleComposition does not support non-standard concentration units; if updating is desired, please ensure that each entry in StandardConcentrations matches one of the supported units in CompositionP.";
Warning::InvalidStandardConcentrationLength="The length of the StandardConcentrations option (`1`) does not match the length of the Standards field of the input protocol (`2`). The StandardConcentration option will be ignored, and standard concentrations will be computed from the Composition fields of Standards in the input protocol.";
Warning::InvalidStandardDataLength="The length of the StandardData option (`1`) does not match the length of the Standards field of the input protocol (`2`). StandardData will be defaulted to the StandardData field from the input protocol, and the StandardData option will be ignored.";
Warning::InvalidStandardDataReferences="One or more of the SamplesIn fields of objects in the StandardData option do not match the Standards field of the input protocol. StandardData will be defaulted to information from the input protocol, and the StandardData option will be ignored.";
Warning::InvalidStandardsNoPeaks="The standard(s) at indices, `1`, do not have molecules assigned to their peaks in their latest peaks analysis object, and will be ignored in composition analysis. Please add these indices to the ExcludeStandards option, or let the ExcludeStandards option resolve automatically.";
Warning::StandardConcentrationIncompatibleUnits="Two or more of the units in the option StandardConcentrations `1` are incompatible. Please specify compatible units for all standards. The StandardConcentration option will be ignored, and standard concentrations will be computed from the Composition fields of Standards in the input protocol.";

resolveAnalyzeCompositionOptions[myProtocol:ObjectP[Object[Protocol,HPLC]],myOptions_List,myResolutionOptions:OptionsPattern[resolveAnalyzeCompositionOptions]]:=Module[
	{
		safeOptions,outputSpecification,cache,gatherTestsQ,standards,standardData,standardAnalysisModels,samplesInAnalysisModels,
		validNameQ,nameInvalidOptions,validNameTest,excludeStandardsRaw,standardDataRaw,invalidIndices,indicesToExclude,
		indicesToInclude,invalidExcludeStandardOptions,excludeStandardsTest,allValidStandardModels,mostRecentStandardModels,
		validStandardModels,sampleInModels,invalidInputs,standardsForAllSamplesTest,latestStandardPeakModels,
		standardsWithoutMoleculePeaks,invalidStandardPeakOptions,invalidStandardPeakTest,
		resolvedStandardData,resolvedExcludeStandards,matchedStandardLengthsQ,matchedStandardReferencesQ,standardDataLengthTest,standardDataReferenceTest
	},

	(* Get our safe options. *)
	safeOptions=SafeOptions[resolveAnalyzeCompositionOptions,ToList[myResolutionOptions]];

	(* Lookup our options. *)
	{outputSpecification,cache}=Lookup[safeOptions,{Output,Cache}];

	(* Should we gather tests? *)
	gatherTestsQ=MemberQ[ToList[outputSpecification],Tests];

	(* Download our necessary information. *)
	{standards,standardData,standardAnalysisModels,samplesInAnalysisModels}=Download[
		myProtocol,
		{
			Standards,
			StandardData,
			StandardData[AbsorbancePeaksAnalyses][PeakAssignment],
			Data[AbsorbancePeaksAnalyses][PeakAssignment]
		},
		Cache->cache
	];

	(*-- INVALID INPUT AND OPTION CHECKS --*)
	(*-- If the specified Name is not in the database, it is valid --*)
	validNameQ=If[MatchQ[Lookup[safeOptions,Name],_String],
		Not[DatabaseMemberQ[Object[Analysis,Composition,Lookup[safeOptions, Name]]]],
		True
	];

	(* if validNameQ is False AND we are throwing messages (or, equivalently, not gathering tests), then throw the message and make nameInvalidOptions = {Name}; otherwise, {} is fine *)
	nameInvalidOptions=If[Not[validNameQ]&&!gatherTestsQ,
		(
			Message[Error::DuplicateName, "Composition Analysis"];
			{Name}
		),
		{}
	];

	(* Generate Test for Name check *)
	validNameTest=If[gatherTestsQ&&MatchQ[Lookup[safeOptions,Name],_String],
		Test["If specified, Name is not already taken for the Object[Analysis,Composition]:",
			validNameQ,
			True
		],
		Null
	];

	(* Populate the standard data option. Automatic defaults to the StandardData field in the input protocol *)
	standardDataRaw=Lookup[myOptions,StandardData];

	(* Check that the standard data option is the same length as the Standards option *)
	matchedStandardLengthsQ=If[MatchQ[standardDataRaw,Automatic]||Length[standardDataRaw]==Length[standards],
		True,
		Message[Warning::InvalidStandardDataLength,Length[standardDataRaw],Length[standards]];
		False
	];

	(* Check that each standard data object is correctly index-matched to on of the Standard objects *)
	matchedStandardReferencesQ=If[MatchQ[standardDataRaw,Automatic]||Download[standardDataRaw,SamplesIn[[-1]][Object]]===standards[Object],
		True,
		If[matchedStandardLengthsQ,Message[Warning::InvalidStandardDataReferences]];
		False
	];

	(* Create a test to check standard data length *)
	standardDataLengthTest=If[gatherTestsQ,
		If[matchedStandardLengthsQ,
			Test["The StandardData option has length equal to the Standards field of the input protocol:",True,True],
			Test["The StandardData option has length equal to the Standards field of the input protocol:",False,True]
		],
		Null
	];

	(* Create a test to check the standard data references *)
	standardDataReferenceTest=If[gatherTestsQ,
		If[matchedStandardReferencesQ,
			Test["Each data object in the StandardData object references objects in the Standards field of the input protocol:",True,True],
			Test["Each data object in the StandardData object references objects in the Standards field of the input protocol:",False,True]
		],
		Null
	];

	(* Use the StandardData field of the input protocol if StandardData->Automatic. Otherwise, use the user-specified one if it is valid *)
	resolvedStandardData=If[!MatchQ[standardDataRaw,Automatic]&&matchedStandardReferencesQ&&matchedStandardLengthsQ,
		standardAnalysisModels=Download[standardDataRaw,AbsorbancePeaksAnalyses[PeakAssignment],Cache->cache];
		standardDataRaw,
		standardData/.{o:ObjectP[]:>o[Object]}
	];

	(*-- ExcludeStandards is a list of indices of the Standards that we should exclude. --*)
	(*-- Make sure that there aren't indices specified in the list that exceed the number of standards that we have. --*)

	(* Lookup our options. *)
	excludeStandardsRaw=Lookup[myOptions,ExcludeStandard];

	(*-- Make sure that no invalid indices are given. --*)
	(* Do we have an invalid index? If our option is Automatic, pretend it is {}. *)
	invalidIndices=Cases[excludeStandardsRaw/.{Automatic->{}},GreaterP[Length[standards]]];

	(* For future use, store the valid indices to exclude. *)
	indicesToExclude=Complement[excludeStandardsRaw/.{Automatic->{}},invalidIndices];
	indicesToInclude=Complement[Range[Length[standards]],indicesToExclude];

	(* Keep track of invalid options. *)
	invalidExcludeStandardOptions=If[Length[invalidIndices]>0&&!MatchQ[excludeStandardsRaw,Automatic],
		Message[Error::InvalidExcludeStandardsOption,invalidIndices,Length[standards]];
		{ExcludeStandard},
		{}
	];

	(* Create a test if asked to do so. *)
	excludeStandardsTest=If[gatherTestsQ,
		If[Length[invalidIndices]>0&&!MatchQ[excludeStandardsRaw,Automatic],
			Test["The indices specified (if any) in the ExcludeStandard option do not exceed the number of Standard samples in the HPLC protocol:",False,True],
			Test["The indices specified (if any) in the ExcludeStandard option do not exceed the number of Standard samples in the HPLC protocol:",True,True]
		],
		Null
	];

	(*-- Make sure that no standards are asked to be analyzed that don't have picked analysis peaks with molecules. --*)
	(* Get the latest peak models for each standard's analysis. *)
	latestStandardPeakModels=(LastOrDefault[#,{}]&)/@standardAnalysisModels;

	(* Get the standards whose latest peak analysis doesn't have molecule assigned peaks. *)
	standardsWithoutMoleculePeaks=Flatten[Position[latestStandardPeakModels,{}]];

	(* Make sure that these standards are not included for analysis. *)
	invalidStandardPeakOptions=If[!ContainsAll[indicesToExclude,standardsWithoutMoleculePeaks]&&!MatchQ[excludeStandardsRaw,Automatic],
		Message[Warning::InvalidStandardsNoPeaks,standardsWithoutMoleculePeaks];
		{ExcludeStandard},
		{}
	];

	(* Create a test if asked to. *)
	invalidStandardPeakTest=If[gatherTestsQ,
		If[!ContainsAll[excludeStandardsRaw,standardsWithoutMoleculePeaks]&&!MatchQ[excludeStandardsRaw,Automatic],
			Test["No Standards are asked to be analyzed that either aren't analyzed or don't have peaks with molecules assigned to them:",False,True],
			Test["No Standards are asked to be analyzed that either aren't analyzed or don't have peaks with molecules assigned to them:",True,True]
		],
		Null
	];

	(*-- Make sure that there are standards for each of the samples. --*)
	(* Get the models for all of the analyses performed for each valid standard (that we are not excluding). *)
	allValidStandardModels=standardAnalysisModels[[indicesToInclude]];

	(* We only want the most recent analysis performed on each standard. *)
	mostRecentStandardModels=Flatten[(LastOrDefault[#,{}]&)/@allValidStandardModels];

	(* Get the models of the valid standards that we can use from the named multiple field and covert to object reference notation. *)
	(* Note: Some of the peaks may not have molecular identities assigned (Name\[Rule]Null). *)
	validStandardModels=Download[mostRecentStandardModels,Object]/.{Null->Nothing};

	(* Get the models of the peaks of the samples in. *)
	(* Note: Some of the peaks may not have molecular identities assigned (Name\[Rule]Null). *)
	sampleInModels=Download[Flatten[(LastOrDefault[#,{}]&)/@samplesInAnalysisModels],Object]/.{Null->Nothing};

	(* Make sure that all sample model peaks have a peak in the standard model. *)
	invalidInputs=If[(MatchQ[{validStandardModels,sampleInModels},{}|{{}}|{{},{}}]||!ContainsAll[validStandardModels,sampleInModels])&&!gatherTestsQ,
		If[MatchQ[{validStandardModels,sampleInModels},{}|{{}}|{{},{}}],
			Message[Error::NoStandardsFound,myProtocol],
			Message[Error::NoStandardsForSamples,Complement[ToList[sampleInModels],ToList[validStandardModels]]]
		];

		{myProtocol},
		{}
	];

	(* Create a test if asked to do so. *)
	standardsForAllSamplesTest=If[gatherTestsQ,
		If[Length[invalidIndices]>0,
			Test["Reference peaks in the standards exist for all peaks requested to be analyzed in the samples:",False,True],
			Test["Reference peaks in the standards exist for all peaks requested to be analyzed in the samples:",True,True]
		],
		Null
	];

	(* Throw InvalidInput/InvalidOption. *)
	If[Length[invalidInputs]>0,
		Message[Error::InvalidInput,invalidInputs];
	];

	If[Length[invalidExcludeStandardOptions]>0,
		Message[Error::InvalidOption,invalidExcludeStandardOptions]
	];

	(*-- OPTIONS RESOLUTION --*)
	(* Do we have to resolve the ExcludeStandards option? *)
	resolvedExcludeStandards=If[MatchQ[excludeStandardsRaw,Automatic],
		standardsWithoutMoleculePeaks,
		excludeStandardsRaw
	];

	(* Return our result. *)
	outputSpecification/.{
		Result->ReplaceRule[myOptions,
			{
				ExcludeStandard->resolvedExcludeStandards,
				StandardData->resolvedStandardData
			}
		],
		Tests->{
			standardDataLengthTest,
			standardDataReferenceTest,
			excludeStandardsTest,
			standardsForAllSamplesTest,
			invalidStandardPeakTest
		}
	}
];


(* ::Subsubsection::Closed:: *)
(*findConcentration*)


(* Given a target Model[Molecule] analyte, a list of sample properties, and a requested concentration type, compute concentration *)
findConcentration[
	targetAnalyte_,
	{analyteMolWeight_,analyteDensity_},
	sampleProperties:{_Rule..},
	preferredUnits:MassConcentration|MolarConcentration|MassPercent|VolumePercent
]:=Module[
	{analyteConc,totalVolume,totalMass,massAnalyte,molesAnalyte},

	(* Get the analyte concentration in whatever units it was stored as *)
	analyteConc=Lookup[sampleProperties,targetAnalyte,0.0];

	(* Total volume of the standard sample *)
	totalVolume=Lookup[sampleProperties,Volume,Null];
	totalMass=Lookup[sampleProperties,Mass,Null];

	(* Return the analyte concentration if we don't have the total volume, since further calculations are not possible *)
	If[MatchQ[Unitless[totalVolume],Null|0|0.0],Return[analyteConc]];

	(* First, try to compute the mass of analyte, defaulting to Null if this isn't possible *)
	massAnalyte=Switch[analyteConc,
		(* If the density of the sample is available, then get the mass through the volume percent *)
		VolumePercentP,
			If[MatchQ[analyteDensity,Null],
				Null,
				(totalVolume*Unitless[analyteConc]/100.0)*analyteDensity
			],

		(* If the mass is available, then take the mass of the analyte *)
		MassPercentP,
			If[MatchQ[totalMass,Null],
				Null,
				(totalMass*Unitless[analyteConc]/100.0)
			],

		(* Multiply mass concentration by volume *)
		MassConcentrationP,
			totalVolume*analyteConc,

		(* Multiply molar concentration by volume *)
		ConcentrationP,
			If[MatchQ[analyteMolWeight,Null],
				Null,
				totalVolume*UnitConvert[analyteConc,Mole/Liter]*analyteMolWeight
			],

		(* Default is Null *)
		_,Null
	];

	(* Moles of analyte, defaulting to Null if it cannot be determined *)
	molesAnalyte=Switch[analyteConc,
		(* We know moles if concentration was molar *)
		ConcentrationP,
			totalVolume*analyteConc,

		(* Default is to use resolve mass of analyte *)
		_,
			If[MatchQ[analyteMolWeight,Null]||MatchQ[massAnalyte,Null]||Unitless[analyteMolWeight]<0.5,
				Null,
				massAnalyte/analyteMolWeight
			]
	];

	(* Return the resolved concentration according to spec, defaulting to provided units if cannot be resolved *)
	Switch[preferredUnits,
		MassConcentration,
			If[MatchQ[massAnalyte,Null],
				analyteConc,
				massAnalyte/totalVolume
			],
		MolarConcentration,
			If[MatchQ[molesAnalyte,Null],
				analyteConc,
				UnitConvert[molesAnalyte/totalVolume,Molar]
			],
		MassPercent,
			If[MatchQ[massAnalyte,Null]||MatchQ[totalMass,Null]||Unitless[totalMass]<=0.0,
				analyteConc,
				N[massAnalyte/totalMass]*(100 MassPercent)
			],
		VolumePercent,
			If[MatchQ[massAnalyte,Null]||MatchQ[analyteDensity,Null]||Unitless[analyteDensity]<=0.0,
				analyteConc,
				N[(massAnalyte/analyteDensity)/totalVolume]*(100 VolumePercent)
			],
		_,analyteConc
	]
];


(* ::Subsubsection::Closed:: *)
(*fetchPacketFromCache *)


(*  No pattern matching to make the function blazing fast. *)
fetchPacketFromCache[Null,_]:=Null;
fetchPacketFromCache[myObject_,myCachedPackets_]:=Module[
	{myObjectNoLink,naiveLookup,type,name},

	(* If given $Failed, return an empty packet. *)
	If[MatchQ[myObject,$Failed],
		Return[<||>];
	];

	(* Make sure that myObject isn't a link. *)
	myObjectNoLink=myObject/.{link_Link:>Download[link, Object]};

	(* First try to find the packet from the cache using Object->myObject *)
	naiveLookup=FirstCase[myCachedPackets,KeyValuePattern[{Object->myObjectNoLink}],<||>];

	(* Were we able to find a packet? *)
	If[!MatchQ[naiveLookup,<||>],
		(* Yes. *)
		naiveLookup,
		(* No. *)
		(* We may have been given a name. *)
		(* Get the type and name from the object. *)
		type=Most[myObjectNoLink];
		name=Last[myObjectNoLink];

		(* Lookup via the name and type. *)
		FirstCase[myCachedPackets,KeyValuePattern[{Type->type,Name->name}],<||>]
	]
];


(* ::Subsubsection::Closed:: *)
(*analyzeCompositionPackets*)


DefineOptions[analyzeCompositionPackets,
	Options:>{
		CacheOption
	}
];
Warning::NoAnalytesFoundInStandards="The analyte `1` could not be matched to a nonzero concentration in the Composition of any of the Standards from the input protocol. Please include a standard which contains a non-zero amount of this analyte.";

analyzeCompositionPackets[myProtocol:ObjectP[Object[Protocol,HPLC]],origOptions_List,myOptions_List,myResolutionOptions:OptionsPattern[analyzeCompositionPackets]]:=Module[
	{
		cache,excludeStandards,name,samplesIn,aliquotSamples,standards,protocolStartDate,samplesInAliquotSamplePreparation,standardAnalysisModels,standardPositions,standardAreas,
		samplesInAnalysisModels,samplesInPositions,samplesInAreas,standardHeights,samplesInHeights,includedStandardIndices,filteredStandards,filteredStandardAnalysisModels,
		filteredStandardModels,filteredStandardAreas,standardInformation,samplesInModels,uniqueSamplesInModels,fitObjects,
		concentrationsAndAreas,concentrationUnit,transposedData,analysisRules,samplesInAliquotInformation,samplePeakInformation,predictedConcentration,
		aliquotRatio,sampleData,standardData,resolvedAliquotSamples,analysisPacket,packet,filteredExpandedStandards,aliquotVolumes,assayVolumes,standardTailings,
		standardLabels,samplesInTailings,samplesInLabels,standardAdjacentResolutions,samplesInAdjacentResolutions,preferredConcentrationType,
		filteredStandardModelPackets,standardCompositions,standardCompositionMapping,standardCompositionLookup,standardMasses,standardVolumes,
		standardConcentrations,standardInformationRaw,filteredStandardData,filteredExpandedStandardData
	},

	(* Lookup our cache. *)
	cache=Lookup[ToList[myResolutionOptions],Cache,{}];

	(* Lookup from our resolved options. *)
	{
		standardData,
		standardConcentrations,
		excludeStandards,
		name,
		preferredConcentrationType
	}=Lookup[myOptions,{
		StandardData,
		StandardConcentrations,
		ExcludeStandard,
		Name,
		PreferredConcentrationType
	}];

	(* Download necessary information for the standards *)
	{
		standardAnalysisModels,
		standardPositions,
		standardAreas,
		standardHeights,
		standardTailings,
		standardLabels,
		standardAdjacentResolutions
	}=Transpose@Quiet[Download[
		standardData,
		{
			(* Information about the Standard peak assignments and their position/area on the Chromatograph. *)
			AbsorbancePeaksAnalyses[[-1]][PeakAssignment],
			AbsorbancePeaksAnalyses[[-1]][Position],
			AbsorbancePeaksAnalyses[[-1]][Area],
			AbsorbancePeaksAnalyses[[-1]][Height],
			AbsorbancePeaksAnalyses[[-1]][TailingFactor],
			AbsorbancePeaksAnalyses[[-1]][PeakLabel],
			AbsorbancePeaksAnalyses[[-1]][AdjacentResolution]
		},
		Cache->cache
	]];

	(* Download necessary information from the protocol *)
	{
		samplesIn,
		aliquotSamples,
		aliquotVolumes,
		assayVolumes,
		standards,
		standardCompositions,
		standardMasses,
		standardVolumes,
		protocolStartDate,
		samplesInAliquotSamplePreparation,
		sampleData,
		samplesInAnalysisModels,
		samplesInPositions,
		samplesInAreas,
		samplesInHeights,
		samplesInTailings,
		samplesInLabels,
		samplesInAdjacentResolutions
	}=Download[
		myProtocol,
		{
			(* Information about the protocol. *)
			SamplesIn,
			AliquotSamples,
			AliquotVolumes,
			AssayVolumes,
			Standards,
			Standards[Composition],
			Standards[Mass],
			Standards[Volume],
			DateStarted,
			AliquotSamplePreparation,

			(* Information about the SamplesIn peak assignments and their position/area on the Chromatograph. *)
			Data,
			Data[AbsorbancePeaksAnalyses][[-1]][PeakAssignment],
			Data[AbsorbancePeaksAnalyses][[-1]][Position],
			Data[AbsorbancePeaksAnalyses][[-1]][Area],
			Data[AbsorbancePeaksAnalyses][[-1]][Height],
			Data[AbsorbancePeaksAnalyses][[-1]][TailingFactor],
			Data[AbsorbancePeaksAnalyses][[-1]][PeakLabel],
			Data[AbsorbancePeaksAnalyses][[-1]][AdjacentResolution]
		},
		Cache->cache
	];

	(* Given linked objects in the Standard field of the protocol, map the object references to their compositions *)
	standardCompositionMapping=DeleteDuplicates@MapThread[
		(#1->{#2,Mass->#3,Volume->#4})&,
		{
			Download[standards,Object],
			standardCompositions/.{object:ObjectP[]:>Download[object,Object]},
			standardMasses,
			standardVolumes
		}
	];

	(* Convert each right hand side to *)
	standardCompositionLookup=Map[
		Function[{rule},
			First[rule]->Join[
				Map[(Last[#]->First[#])&,First@Last[rule]],
				Rest[Last[rule]]
			]
		],
		standardCompositionMapping
	];

	(* Get the indices of the standards to include. *)
	includedStandardIndices=Complement[Range[Length[standards]],excludeStandards];

	(* Exclude our standards and our standard peak models that we don't want (according to the ExcludeStandard option). *)
	(* We are guaranteed by the option resolver that these indices are valid and that all included standards will have a corresponding Peaks analysis object. *)
	filteredStandards=Download[standards[[includedStandardIndices]],Object];
	filteredStandardAnalysisModels=standardAnalysisModels[[includedStandardIndices]];

	(* We may have multiple models per standard. Expand our standards. *)
	filteredExpandedStandards=MapThread[
		Function[{standard,models},
			Sequence@@ConstantArray[standard,Length[models]]
		],
		{filteredStandards,filteredStandardAnalysisModels}
	];

	(* For each standard, get all of the models that were peak-picked *)
	(* Note: This is still index-matched to filteredStandards. *)
	(* KH: Updated 4/12/21 since post-Samplefest information is available up front in the Model[Sample] that analysis points to *)
	filteredStandardModelPackets=Download[
		Flatten[filteredStandardAnalysisModels]/.{Null->Nothing},
		Packet[Density, MolecularWeight]
	];

	(* Just the object references from the standard models. *)
	filteredStandardModels=Lookup[filteredStandardModelPackets, Object];

	(* Peak areas corresponding to each standard model *)
	filteredStandardAreas=Flatten[standardAreas[[includedStandardIndices]]];

	(* Standard data corresponding to each standard model, expanded for multiple models *)
	filteredStandardData=standardData[[includedStandardIndices]];
	filteredExpandedStandardData=MapThread[
		Function[{sData,models},
			Sequence@@ConstantArray[sData,Length[models]]
		],
		{filteredStandardData,filteredStandardAnalysisModels}
	];

	(* Resolve the StandardConcentrations option*)
	standardInformationRaw=getStandardConcentrationOption[
		standardConcentrations,
		standards,
		standardData,
		standardAnalysisModels,
		standardAreas
	];

	(* Use the StandardConcentrations option if it was supplied, otherwise calculate the default one *)
	(* Find the concentration of the analytes in our standards. For each standard, {{sample, targetModel, concentration, areas}} *)
	standardInformation=If[MatchQ[standardInformationRaw,Null|Automatic],
		Join@@Map[
			Function[{analyteModel},
				Map[
					{
						#,
						analyteModel,
						(* Compute concentration from the provided fields *)
						findConcentration[
							analyteModel,
							Lookup[fetchPacketFromCache[analyteModel,filteredStandardModelPackets],{MolecularWeight,Density},Null],
							Lookup[standardCompositionLookup,#,Null],
							preferredConcentrationType
						],
						(* From a list of {sample,molecule,peak area} tuples, select all tuples corresponding to the current sample and analyte *)
						Cases[Transpose[{filteredExpandedStandards,filteredStandardModels,filteredStandardAreas}],{#,analyteModel,area_}:>area],
						Cases[Transpose[{filteredExpandedStandards,filteredStandardModels,filteredExpandedStandardData}],{#,analyteModel,data_}:>data]
					}&,
					(* List of all unique Object[Sample] associated with the Standards field of the protocol, filtered for exclusions and duplicates *)
					DeleteDuplicates[filteredExpandedStandards]
				]
			],
			(* List of all unique Model[Molecule] objects corresponding to picked peaks  *)
			DeleteDuplicates[filteredStandardModels]
		],
		standardInformationRaw
	];

	(* Lookup the molecular identity. Peaks may not have a molecular identity assigned (the Name index) so filter out Nulls. *)
	(* This is index-matched to SamplesIn. Samples without a peak analysis with labeled peaks with molecular identities will be empty lists. *)
	samplesInModels=samplesInAnalysisModels/.{object:ObjectP[]:>Download[object,Object]};

	(* Get the unique molecules that we need to make calibration curves for. *)
	uniqueSamplesInModels=DeleteDuplicates[Flatten[samplesInModels]];

	(* We are guaranteed in the options resolver that all of the models in our samples in will be in the picked peaks in the Standards. *)
	(* For the sample models that we care about (the ones in samplesInModels), create calibration curves for them. *)
	fitObjects=Function[{targetModel},
		(* Get the target models from our processed standard information. *)
		(* standardInformation is in the form {{standardSample, targetSampleModel, concentration}..}. *)
		(* Get all the instances that this analyte shows up in a standard and the concentration we find for it. *)
		concentrationsAndAreas=Cases[standardInformation,{_,targetModel,concentration_?(!PossibleZeroQ[#]&),areas_,_}:>{areas,ConstantArray[concentration,Length[areas]]}];

		(* If there are no standards where this molecule is found, throw a warning. *)
		If[Length[concentrationsAndAreas]==0,
			(* Only throw an error if the peak has a model. *)
			If[!MatchQ[targetModel,Null],
				Message[Warning::NoAnalytesFoundInStandards,targetModel];
			];

			Null,
			(* Get the unit of our domain concentration. *)
			concentrationUnit=Units[concentrationsAndAreas[[1]][[2]][[1]]];

			(* Get our concentrations and areas into the correct format. *)
			transposedData=DeleteCases[
				Transpose[Flatten/@Transpose[concentrationsAndAreas]],
				{Null,UnitsP[]}
			];

			(* Create our linear fit packet. *)
			packet=AnalyzeFit[Prepend[transposedData,{0,0*concentrationUnit}],Linear,Upload->False];

			(* Give our packet an ID. *)
			Append[packet,Object->CreateID[Object[Analysis,Fit]]]
		]
	]/@uniqueSamplesInModels;

	(* Create a set of rules for easier lookup from molecule to analysis object packet. *)
	analysisRules=MapThread[Rule,{uniqueSamplesInModels,fitObjects}];

	(* If there was no aliquotting occurring at all, then AliquotSamplePreparation will be Null. If this is the case, create a dummy replacement so we can maintain index-matching. *)
	samplesInAliquotInformation=If[MatchQ[samplesInAliquotSamplePreparation,Null|{}],
		(* We may be dealing with a legacy protocol. Check to see if that's the case. *)
		If[MatchQ[{aliquotVolumes,assayVolumes},{Except[Null|{}],Except[Null|{}]}],
			(* Legacy protocol. Get it into the right format. *)
			MapThread[
				Function[{aliquot,assay},
					<|Aliquot->True,AliquotAmount->aliquot,AssayVolume->assay|>
				],
				{aliquotVolumes,assayVolumes}
			],
			(* Note legacy. No aliquot occurred. *)
			ConstantArray[<|Aliquot->False|>,Length[samplesIn]]
		],
		samplesInAliquotSamplePreparation
	];

	(* If there was no aliquotting, there won't be aliquot samples. *)
	resolvedAliquotSamples=If[MatchQ[aliquotSamples,Null|{}],
		ConstantArray[Null,Length[samplesIn]],
		Download[aliquotSamples,Object]
	];

	(* Based on the analysis objects that we've created, figure out the concentration of each molecule in each sample. *)
	(* Returned information is in the form {sample,aliquotSample,data,targetModel,peakArea,assayConcentration,dilutionRatio}. *)
	samplePeakInformation=MapThread[
		Function[{sampleIn,aliquotSample,data,sampleInPeakModels,sampleInPeakArea,sampleInAliquotInformation},
			(* Did this SampleIn have any peak models? *)
			If[Length[sampleInPeakModels]==0||MatchQ[sampleInPeakModels,{Null}],
				(* No peak molecule models to analyze. *)
				Nothing,

				(* We have molecule models. *)
				(* Use the calibration curves we created to get the concentration of this sample. *)
				Sequence@@MapThread[
					Function[{model,area},
						(* Based on the area of the peak, get the predicted concentration of the aliquotted sample (if there was an aliquot). *)
						predictedConcentration=If[MatchQ[Lookup[analysisRules,model,Null],Null],
							Null,
							Lookup[Lookup[analysisRules,model],BestFitFunction][area]
						];
						(* Did we have an aliquot occur for this sample? *)
						If[Lookup[sampleInAliquotInformation,Aliquot,False],
							(* We aliquotted our sample. Multiply by the inverse of our dilution factor (we care about the concentration of our SampleIn, not of our aliquotted sample. *)
							(* Note: If aliquotting a solid (which shouldn't be possible for HPLC) AssayVolume will be Null. In this case, the dilution ratio is 1. *)
							aliquotRatio=If[MatchQ[Lookup[sampleInAliquotInformation,AssayVolume],Null]||MatchQ[Lookup[analysisRules,model,Null],Null],
								1,
								N[Lookup[sampleInAliquotInformation,AliquotAmount]/Lookup[sampleInAliquotInformation,AssayVolume]]
							];

							{sampleIn,aliquotSample,data,model,area,N[predictedConcentration/aliquotRatio],aliquotRatio},
							(* No aliquot occurred. *)
							{sampleIn,aliquotSample,data,model,area,predictedConcentration,1}
						]
					],
					{Download[sampleInPeakModels,Object],sampleInPeakArea}
				]
			]
		],
		{Download[samplesIn,Object],resolvedAliquotSamples,Download[sampleData,Object],samplesInModels,samplesInAreas,samplesInAliquotInformation}
	];

	(*
	Note: The following is the CORRECT way to make a packet that is not absolutely garbage.

	However, we are going to be uploading in the old format since Elmo needs backwards compatability temporarily due to some functions they wrote.

	(* Format our computed information into the correct packet format. *)
	analysisPacket=<|
		Type->Object[Analysis,Composition],
		Replace[SamplesIn]->Link/@samplePeakInformation[[All,1]],
		Replace[AliquotSamples]->Link/@samplePeakInformation[[All,2]],
		Replace[Data]->(Link[#,ChromatogramCompositionAnalyses]&)/@samplePeakInformation[[All,3]],
		Replace[SampleModels]->Link/@samplePeakInformation[[All,4]],
		Replace[SampleAreas]->samplePeakInformation[[All,5]],
		Replace[AliquotDilutionRatio]->samplePeakInformation[[All,7]],
		Replace[SampleConcentrations]->samplePeakInformation[[All,6]],
		Replace[Standards]->Link/@filteredExpandedStandards,
		Replace[StandardData]->(Link[#,ChromatogramCompositionAnalyses]&)/@Download[standardData[[includedStandardIndices]],Object],
		Replace[StandardModels]->Link/@filteredStandardModels,
		Replace[StandardAreas]->filteredStandardAreas,
		Replace[StandardConcentrations]->MapThread[
			Function[{standard,targetModel},
				(* Lookup the concentration from standardInformation *)
				FirstCase[standardInformation,{standard,targetModel,concentration_,_}:>concentration]
			],
			{filteredExpandedStandards,filteredStandardModels}
		],
		Replace[AnalyteCalibrationCurves]->MapThread[
			Function[{analyte,curve},
				If[MatchQ[analyte,Null],
					Nothing,
					<|
						Analyte->Link[analyte],
						CalibrationCurve->Link[Lookup[curve,Object]]
					|>
				]
			],
			{uniqueSamplesInModels,fitObjects}
		],
		If[!MatchQ[Lookup[myOptions,Name],Null],
			Name->Lookup[myOptions,Name],
			Nothing
		]
	|>;
	*)

	(* Get the concentrations in the right format. *)
	(* {sample,aliquotSample,data,targetModel,peakArea,assayConcentration,dilutionRatio} *)

	formattedStandardModels=filteredStandardAnalysisModels;

	formattedAliquotRatios=FirstCase[samplePeakInformation,{ObjectP[#],_,_,_,_,_,ratio_}:>ratio,Null]&/@Download[samplesIn,Object];

	formattedStandardCompositions=MapThread[
		Function[{standard,standardModels,standardData},
			FirstCase[
				(* standardInformation is in the form {{standardSample, targetSampleModel, concentration, areas}..}. *)
				standardInformation/.{obj:ObjectP[]:>obj[Object]},
				{
					ObjectP[standard],
					ObjectP[#],
					concentration_,
					_,
					_?(Function[{x},MemberQ[x,standardData]])
				}:>concentration,
				"Not found"
			]&/@standardModels
		],
		{filteredStandards,formattedStandardModels,Download[standardData[[includedStandardIndices]],Object]}
	];

	formattedSampleCompositions=MapThread[
		Function[{sample,sampleModels,data},
			FirstCase[
				(* samplePeakInformation is in the form {{sample,aliquotSample,data,targetModel,peakArea,assayConcentration,dilutionRatio}..}. *)
				samplePeakInformation,
				{
					ObjectP[sample],
					_,
					ObjectP[data],
					ObjectP[#],
					_,
					concentration:Except[Null],
					_
				}:>concentration,
				"Not found"
			]&/@sampleModels
		],
		{Download[samplesIn,Object],samplesInModels,Download[sampleData,Object]}
	];

	formattedAliquotCompositions=MapThread[
		Function[{sample,sampleModels,data},
			FirstCase[
				(* samplePeakInformation is in the form {{sample,aliquotSample,data,targetModel,peakArea,assayConcentration,dilutionRatio}..}. *)
				samplePeakInformation,
				{
					ObjectP[sample],
					_,
					ObjectP[data],
					ObjectP[#],
					_,
					concentration:Except[Null],
					dilutionRatio_
				}:>concentration*dilutionRatio,
				"Not found"
			]&/@sampleModels
		],
		{Download[samplesIn,Object],samplesInModels,Download[sampleData,Object]}
	];

	(* Massage things into the old format. *)
	(* The old format just has everything as a GOD DAMN EXPRESSION. *)
	analysisPacket=<|
		Author->Link[$PersonID],
		UnresolvedOptions->origOptions,
		ResolvedOptions->myOptions,
		Name->Lookup[myOptions,Name,Null],
		Type->Object[Analysis,Composition],
		Replace[StandardSamples]->Link/@filteredStandards,
		Replace[StandardData]->(Link[#,ChromatogramCompositionAnalyses]&)/@Download[standardData[[includedStandardIndices]],Object],
		Replace[StandardModels]->Map[Link,formattedStandardModels,2],
		Replace[StandardPositions]->standardPositions[[includedStandardIndices]],
		Replace[StandardHeights]->standardHeights[[includedStandardIndices]],
		Replace[StandardAreas]->standardAreas[[includedStandardIndices]],
		Replace[StandardAdjacentResolutions]->standardAdjacentResolutions[[includedStandardIndices]],
		Replace[StandardTailing]->standardTailings[[includedStandardIndices]],
		Replace[StandardLabels]->standardLabels[[includedStandardIndices]],
		Replace[AssaySamples]->Link/@Download[samplesIn,Object],
		Replace[AssayData]->(Link[#,ChromatogramCompositionAnalyses]&)/@Download[sampleData,Object],
		Replace[AssayPositions]->samplesInPositions,
		Replace[AssayHeights]->samplesInHeights,
		Replace[AssayAreas]->samplesInAreas,
		Replace[AssayAdjacentResolutions]->samplesInAdjacentResolutions,
		Replace[AssayTailing]->samplesInTailings,
		Replace[AssayLabels]->samplesInLabels,
		Replace[AssayModels]->Map[Link,samplesInModels,2],
		Replace[StandardCurveFitAnalyses]->(
			If[MatchQ[#,Null],
				Nothing,
				myObject=Lookup[#,Object];

				Link[myObject,Reference]
			]
		&)/@fitObjects,
		Replace[StandardCurveFitFunctions]->(
			If[MatchQ[#,Null],
				Nothing,
				Lookup[#,BestFitFunction]
			]
		&)/@fitObjects,
		Replace[DilutionFactors]->formattedAliquotRatios,
		StandardCompositions->formattedStandardCompositions,
		AliquotCompositions->formattedAliquotCompositions,
		AssayCompositions->formattedSampleCompositions
	|>;

	(* Return our analysis and curve fitting packets. Make sure the main packet is last. *)
	Append[Cases[fitObjects,Except[Null]],analysisPacket]
];



(* ::Subsubsection::Closed:: *)
(*generateUpdatePackets*)

(* Add the cache option *)
DefineOptions[generateUpdatePackets,Options:>{CacheOption}];

(* Generate packet updates to update the composition in the *)
generateUpdatePackets[compPacket:PacketP[Object[Analysis,Composition]],updateOps:OptionsPattern[generateUpdatePackets]]:=Module[
	{
		cache,assayResults,samples,dilutions,sampleData,analytesPerSample,resultsLookup,trimmedResultsLookup,
		groupedResults,newCompositions,oldCompositions,validUploadUnits,invalidIndices,invalidObjects
	},

	(* Lookup our cache. *)
	cache=Lookup[ToList[updateOps],Cache,{}];

	(* Extract composition results for the Assay, i.e. the SamplesIn *)
	{samples,analytesPerSample,newCompositions}=Lookup[
		stripAppendReplaceKeyHeads@compPacket,
		{AssaySamples,AssayModels,AssayCompositions}
	];

	(* Format a mapping of sample to analytes and compositions *)
	resultsLookup=MapThread[
		Function[{obj,analytes,analyteComps},
			obj->Thread[analytes->analyteComps]
		],
		{samples,analytesPerSample,newCompositions}
	]/.{o:ObjectP[]:>o[Object]};

	(* Remove empty values, e.g. compositions that were not found, or samplesIn without labeled peaks *)
	trimmedResultsLookup=resultsLookup/.{
		Rule[Null,"Not found"]->Nothing,
		Rule[ObjectP[Object[Sample]],{}]->Nothing
	};

	(* Group results by samplesIn, in case replicates were specified *)
	groupedResults=GroupBy[trimmedResultsLookup,First->Last,
		Normal@GroupBy[Flatten[#],First->Last,Mean]&
	];

	(* Download the old assay compositions using the cache, and remove {Null,Null} entries *)
	oldCompositions=Download[
		DeleteDuplicates[samples[Object]],
		Packet[Composition],
		Cache->cache
	]/.{{Null,Null}->Nothing};

	(* New composition packets *)
	newCompositions=Map[
		Module[{obj,comp,analyteConcs,untrackedComps,appendedComps,newComps},
			(* Pull the object and composition out of the old composition packets *)
			{obj,comp}=Lookup[#,{Object,Composition}];

			(* Check the results we extracted from the composition packet to see if we have analyte concentrations *)
			analyteConcs=Lookup[groupedResults,obj,{}];

			(* Objects that a composition was computed for which are not present in Composition already *)
			untrackedComps=Complement[
				First/@analyteConcs,
				Part[comp,All,-1][Object]
			];

			(* Append any compositions to the field which were not already there *)
			appendedComps=Join[
				comp,
				{Null,#}&/@untrackedComps
			]/.{l:_Link:>l[Object]};

			(* Update the compositions *)
			newComps=Map[
				Function[{compPair},
					If[MatchQ[Lookup[analyteConcs,Last[compPair],Null],Except[Null]],
						(* Update with the new value *)
						{Lookup[analyteConcs,Last[compPair],Null],Link@Last[compPair]},
						(* Return unchanged if not found *)
						{First[compPair],Link@Last[compPair]}
					]
				],
				appendedComps
			];

			(* Return the whole packet with updates *)
			Association[
				ReplaceRule[Normal[#],Composition->newComps]/.{Rule[Composition,comps_]->Rule[Replace[Composition],comps]}
			]
		]&,
		oldCompositions
	];

	(* Check if the upload is valid *)
	validUploadUnits=Map[
		MatchQ[Part[Lookup[#,Replace[Composition]],All,1],{(Null|CompositionP)..}]&,
		newCompositions
	];

	(* Object IDs of invalid uploads *)
	invalidIndices=Flatten@Position[validUploadUnits,False];
	invalidObjects=Units@Cases[
		Flatten[Lookup[#,Replace[Composition]]&/@Part[newCompositions,invalidIndices]],
		UnitsP[]
	];

	(* Return the update packets if composition units are valid, otherwise return an empty list *)
	If[And@@validUploadUnits,
		newCompositions,
		Message[Warning::InvalidCompositionUpdate,DeleteCases[DeleteDuplicates@invalidObjects,CompositionP]];
		{}
	]
];



(* ::Subsubsection::Closed:: *)
(*getStandardConcentrationOption*)

(* Output Null for Automatic resolution *)
getStandardConcentrationOption[Automatic,_,_,_,_]:=Null;

(* Convert the StandardConcentrations option into the internal representation needed for analysis, plus error checking *)
getStandardConcentrationOption[concs_,standards_,sdata_,analytes_,areas_]:=Module[
	{
		concObjs,standardObjs,dataObjs,analyteObjs,concentrationsOnly,uniqueUnits,standardLookup,
		tmpRule,updatedLookup,missingAnalytes,missingAnalyteIndices,groupedLookup,updatedStandardInfo
	},

	(* Replace all links in inputs with objects *)
	concObjs=concs/.{o:ObjectP[]:>o[Object],None->Nothing};
	standardObjs=standards/.{o:ObjectP[]:>o[Object]};
	dataObjs=sdata/.{o:ObjectP[]:>o[Object]};
	analyteObjs=analytes/.{o:ObjectP[]:>o[Object]};

	(* Check that all concentrations are given in the same units *)
	concentrationsOnly=Flatten@Map[Last,concObjs,{2}];
	uniqueUnits=DeleteDuplicates@Units[concentrationsOnly];

	(* Return a warning message if one or more units is not compatible *)
	If[!(CompatibleUnitQ@@uniqueUnits),
		Message[Warning::StandardConcentrationIncompatibleUnits,uniqueUnits];
		Return[Null];
	];

	(* Check length of concs matches the length of standards. Return Null (default concentrations) if this is not satisfied *)
	If[Length[concObjs]!=Length[standardObjs],
		Message[Warning::InvalidStandardConcentrationLength,Length[concObjs],Length[standardObjs]];
		Return[Null];
	];

	(* Generate a mapping of {Standard->{analyte->area}} rules *)
	standardLookup=MapThread[
		Function[{obj,analyteList,areaList,standardData},
			(* Filter out invalid entries (e.g. missing peaks, etc.) *)
			obj->Cases[
				Thread[analyteList->({#,standardData}&/@areaList)],
				tmpRule:(ObjectP[Model[Molecule]]->{NumericP,ObjectP[]}):>tmpRule
			]
		],
		(* These are all downloaded from the same original list, and are guaranteed to have the same length *)
		{standardObjs,analyteObjs,areas,dataObjs}
	];

	(* Substitute in the specified concentrations *)
	updatedLookup=MapThread[
		Function[{myConc,standardInfo},
			First[standardInfo]->Map[
				Rule[First[#],{Last[#],Sequence@@Lookup[Last[standardInfo],First[#],{Null,Null}]}]&,
				myConc
			]
		],
		{concObjs,standardLookup}
	];

	(* Check for analytes which could not be found *)
	missingAnalytes=Map[
		Function[{rule},
			(First/@Select[Last[rule],MemberQ[Last[#],Null]&])/.{{}->Nothing}
		],
		updatedLookup
	];

	(* Indices of concentrations missing analte *)
	missingAnalyteIndices=Flatten@Position[
		updatedLookup,
		_?(!FreeQ[#,Null]&),
		{1}
	];

	(* Warn the user about any analytes specified in the option that weren't matched *)
	If[Length[DeleteDuplicates@missingAnalytes]>0,
		Message[Warning::AnalytesNotFound,missingAnalytes/.{obj:ObjectP[]:>If[MatchQ[obj[Name],_String],Append[obj[Type],obj[Name]],obj[Object]]},missingAnalyteIndices];
	];

	(* Group by standards, analytes, and concentrations *)
	groupedLookup=Normal@GroupBy[updatedLookup,First->Last,
		Normal@GroupBy[Flatten[#],First->Last]&
	];

	(* Convert the grouped lookup into standard info *)
	updatedStandardInfo=Map[
		Function[{objRule},
			Sequence@@Map[
				{First[objRule],Sequence@@#}&,
				Last[objRule]
			]
		],
		groupedLookup
	];

	(* Group entries by identical concentrations *)
	Map[
		Function[{infoTuple},
			Sequence@@Map[
				{Sequence@@Most[infoTuple],First[#],Sequence@@Transpose[Last[#]]}&,
				Normal@GroupBy[Last[infoTuple],First->Rest]
			]
		],
		updatedStandardInfo
	]
];



(* ::Subsubsection::Closed:: *)
(*resolveConcentrationOption*)

(* Resolve the StandardConcentrations option. This is separate because it depends on results of the analysis *)
resolveConcentrationOption[compPacket:PacketP[Object[Analysis,Composition]],resolvedOps:{(_Rule|_RuleDelayed)..}]:=Module[
	{excludeIndices,analytesPerStandard,namedAnalytes,concentrationsPerStandard,includedStandardConcs},

	(* Indices of standards which were excluded and resolved Standard Data option *)
	excludeIndices=Sort@Lookup[resolvedOps,ExcludeStandard];

	(* Extract composition results for the Standards, i.e. the SamplesIn *)
	{analytesPerStandard,concentrationsPerStandard}=Lookup[
		stripAppendReplaceKeyHeads@compPacket,
		{StandardModels,StandardCompositions}
	];

	(* Use the object names when possible *)
	namedAnalytes=analytesPerStandard/.{
		obj:ObjectP[]:>If[MatchQ[obj[Name],_String],Append[obj[Type],obj[Name]],obj[Object]]
	};

	(* For each included standard, a list of {{analyte,concentration} mappings }*)
	includedStandardConcs=MapThread[
		Function[{analytes,concs},
			Thread[{analytes,concs}]
		],
		{namedAnalytes,concentrationsPerStandard}
	];

	(* Insert a {None} for each of the excluded standards *)
	Fold[Insert[#1,{},#2]&,includedStandardConcs,excludeIndices]
];



(* ::Section:: *)
(*AnalyzeCompositionOptions*)

(* Options shared with parent function, with additional OutputFormat option *)
DefineOptions[AnalyzeCompositionOptions,
	Options:>{
		{
			OptionName->OutputFormat,
			Default->Table,
			AllowNull->False,
			Widget->Widget[Type->Enumeration,Pattern:>Alternatives[Table,List]],
			Description->"Indicates whether the function returns a table or a list of the resolved options."
		}
	},
	SharedOptions:>{
		AnalyzeComposition
	}
];

(* Call parent function with Output->Options and format output *)
AnalyzeCompositionOptions[
	myInputs:ObjectP[Object[Protocol,HPLC]],
	myOptions:OptionsPattern[AnalyzeCompositionOptions]
]:=Module[
	{listedOptions,preparedOptions,resolvedOptions},

	(* Get the options as a list *)
	listedOptions=ToList[myOptions];

	(* Send in the correct Output option and remove the OutputFormat option *)
	preparedOptions=Normal@KeyDrop[
		ReplaceRule[listedOptions,Output->Options],
		{OutputFormat}
	];

	(* Get the resolved options from AnalyzeComposition *)
	resolvedOptions=DeleteCases[AnalyzeComposition[myInputs,preparedOptions],(Output->_)];

	(* Return the options as a list or table, depending on the option format *)
	If[MatchQ[OptionDefault[OptionValue[OutputFormat]],Table]&&MatchQ[resolvedOptions,{(_Rule|_RuleDelayed)..}],
		LegacySLL`Private`optionsToTable[resolvedOptions,AnalyzeComposition],
		resolvedOptions
	]
];



(* ::Section:: *)
(*AnalyzeCompositionPreview*)

(* Options shared with parent function *)
DefineOptions[AnalyzeCompositionPreview,
	SharedOptions:>{
		AnalyzeComposition
	}
];

(* Call parent function with Output->Preview *)
AnalyzeCompositionPreview[
	myInputs:ObjectP[Object[Protocol,HPLC]],
	myOptions:OptionsPattern[AnalyzeCompositionPreview]
]:=Module[{listedOptions},

	(* Get the options as a list *)
	listedOptions=ToList[myOptions];

	(* Call the parent function with Output->Preview *)
	AnalyzeComposition[myInputs,ReplaceRule[listedOptions,Output->Preview]]
];



(* ::Section:: *)
(*ValidAnalyzeCompositionQ*)

(* Options shared with parent function, plus additional Verbose and OutputFormat options *)
DefineOptions[ValidAnalyzeCompositionQ,
	Options:>{
		VerboseOption,
		OutputFormatOption
	},
	SharedOptions:>{
		AnalyzeComposition
	}
];

(* Use OutputFormat->Tests to determine if parent function call is valid, +format the output *)
ValidAnalyzeCompositionQ[
	myInputs:ObjectP[Object[Protocol,HPLC]],
	myOptions:OptionsPattern[ValidAnalyzeCompositionQ]
]:=Module[
	{
		listedOptions,preparedOptions,analyzeCompositionTests,
		initialTestDescription,allTests,verbose,outputFormat
	},

	(* Ensure that options are provided as a list *)
	listedOptions=ToList[myOptions];

	(* Remove the Output, Verbose, and OutputFormat options from provided options *)
	preparedOptions=DeleteCases[listedOptions,(Output|Verbose|OutputFormat)->_];

	(* Call AnalyzeComposition with Output->Tests to get a list of EmeraldTest objects *)
	analyzeCompositionTests=AnalyzeComposition[myInputs,Append[preparedOptions,Output->Tests]];

	(* Define general test description *)
	initialTestDescription="All provided inputs and options match their provided patterns (no further testing is possible if this test fails):";

	(* Make a list of all tests, including the blanket correctness check *)
	allTests=If[MatchQ[analyzeCompositionTests,$Failed],
		(* Generic test that always fails if the Output->Tests output failed *)
		{Test[initialTestDescription,False,True]},
		(* Generate a list of tests, including valid object and VOQ checks *)
		Module[{validObjectBooleans,voqWarnings},
			(* Check for invalid objects *)
			validObjectBooleans=ValidObjectQ[Cases[Flatten[{myInputs}],ObjectP[]],OutputFormat->Boolean];

			(* Return warnings for any invalid objects *)
			voqWarnings=MapThread[
				Warning[StringJoin[ToString[#1,InputForm]," is valid (run ValidObjectQ for more detailed information):"],
					#2,
					True
				]&,
				{Cases[Flatten[{myInputs}],ObjectP[]],validObjectBooleans}
			];

			(* Gather all tests and warnings *)
			Cases[Flatten[{analyzeCompositionTests,voqWarnings}],_EmeraldTest]
		]
	];

	(* Look up options exclusive to running tests in the validQ function *)
	{verbose,outputFormat}=Quiet[OptionDefault[OptionValue[{Verbose,OutputFormat}]],OptionValue::nodef];

	(* Run the tests as requested *)
	Lookup[
		RunUnitTest[<|"ValidAnalyzeCompositionQ"->allTests|>,Verbose->verbose,OutputFormat->outputFormat],
		"ValidAnalyzeCompositionQ"
	]
];
