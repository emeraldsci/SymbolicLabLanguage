(* ::Package:: *)

(* ::Text:: *)
(*\[Copyright] 2011-2023 Emerald Cloud Lab, Inc.*)


(* ::Section:: *)
(*Source Code*)


(* ::Subsection:: *)
(*AnalyzeEpitopeBinning*)


(* ::Subsubsection:: *)
(*AnalyzeEpitopeBinning*)


DefineOptions[AnalyzeEpitopeBinning,
  Options :> {


    (* -- How to do the fitting -- *)
    {
      OptionName -> FitDomain,
      Default -> 10 Percent,
      AllowNull -> False,
      Description -> "Specifies the domain which should be averaged to determine the maximum binding response of each interaction. A value of 10 Second indicates that the last 10 Second of data in each competition step will be used to determine the response, and 20 Percent will indicate that the final 20% of the data should be used.",
      Widget->Alternatives[
        "Time" -> Widget[Type -> Quantity, Pattern:>GreaterP[0 Second], Units -> Second],
        "Percent" -> Widget[Type -> Quantity, Pattern:>RangeP[1 Percent, 99 Percent, 1 Percent], Units -> Percent]
        ]
    },


    (* -- batched data processing -- *)

    {
      OptionName -> Threshold,
      Default -> Automatic,
      Description -> "Specifies a response value for all binding steps below which the binding antibody is considered to be blocking the competing antibody. Antibody paris which fall below the threshold will be placed in the same bin. If normalization is requested, use  the Normalized Value input form.",
      ResolutionDescription -> "Resolves to a Normalized Value of 0.5 or an absolute value of 0.5 Nanometer based on if normalization is being performed.",
      AllowNull -> True,
      Category -> "Data Processing",
      Widget -> Alternatives[
        "Raw Response" -> Widget[Type -> Quantity, Pattern:>GreaterP[0 Nanometer], Units -> Nanometer],
        "Normalized Value" -> Widget[Type -> Number, Pattern:>RangeP[0, 1]]
      ]
    },
    {
      OptionName -> SlowBindingThreshold,
      Default -> Automatic,
      AllowNull -> True,
      Description -> "Specifies a lower threshold to be used when analyzing data in which the competing antibody has slow binding kinetics which prevent it from attaining the Threshold value. This value is applied to all members of SlowBindingSpecies. If normalization is requested, use  the Normalized Value input form.",
      ResolutionDescription -> "Resolves to a Normalized Value of 0.1 or an absolute value of 0.2 Nanometer based on if normalization is being performed.",
      Category -> "Data Processing",
      Widget -> Alternatives[
        "Raw Response" -> Widget[Type -> Quantity, Pattern:>GreaterP[0 Nanometer], Units -> Nanometer],
        "Normalized Value" -> Widget[Type -> Number, Pattern:>RangeP[0, 1]]
      ]
    },
    (*TODO: this can be upgraded in the future to take Model[Molecule] and Model[Sample] as well*)
    {
      OptionName -> SlowBindingSpecies,
      Default -> Null,
      AllowNull -> True,
      Description -> "Specifies input object which contain analytes with slow binding kinetics with respect to the given antigen.",
      Category -> "Data Processing",
      Widget -> Adder[Widget[Type -> Expression, Pattern:>ObjectP[{Object[Sample]}], Size -> Word]]
    },
    {
      OptionName -> BaselineType,
      Default -> SelfBlocking,
      Description -> "Specifies the type of baseline required for the given assay format. Parallel: Uses a well that is measured in parallel with the competition step that does not contain any of the tested antibodies. PreviousWell: Uses a linear function generated by fitting the previous well. SelfBlocking (Default): Uses the data from the self-blocking interaction as a baseline for the other competition wells.",
      AllowNull -> False,
      Category -> "Data Processing",
      Widget -> Widget[Type -> Enumeration, Pattern:>Alternatives[None, Parallel, PreviousWell, SelfBlocking]]
    },
    {
      OptionName -> NormalizationMethod,
      Default -> None,
      Description -> "Specifies what data should be used to normalize the response. The normalized value will be used in the binning analysis, and may improve upon raw response values in cases where the antibody-antigen interaction varies widely between the tested species. None: Raw response will be used to perform binning analysis. IsolatedAntibody: When the data is available, competition step can be normalized by division of the competing antibody only signal to the competition data measured in that step. This yields a ratio of observed to maximum response - this method is only available for Tandem assays where one probe is treated with antigen but not antibody prior to the competition step. LoadingCapacity: Uses the change in response observed in initial probe loading to estimate the maximum theoretical change in response for each given antibody. The observed response will be divided by this value to provide a normalized value.",
      AllowNull -> False,
      Category -> "Data Processing",
      Widget -> Widget[Type -> Enumeration, Pattern:>Alternatives[None, IsolatedAntibody, LoadingCapacity]]
    },

    OutputOption,
    UploadOption,
    AnalysisTemplateOption
  }
];



(* ::Subsection:: *)
(*AnalyzeEpitopeBinning Messages*)

(* -------------------- *)
(* -- ERROR MESSAGES -- *)
(* -------------------- *)

(* bad input errors *)
Error::NoEpitopeBinningDataObjects = "The input protocol does not contain any data objects.";
Error::NoBinningData = "The protocol does not contain any data objects with epitope binning data.";
Error::EpitopeBinningMixedInputType = "The input Data Objects `1` have types `2`. All data objects must be of the same type for this analysis function.";
Error::EpitopeBinningMissingData = "The following input data objects do not have the CompetitionData field populated, `1`.";
Error::EpitopeBinningIncompleteDataSet = "The following input set is incomplete - the number of unique data sets must match the number of input solutions. Check for duplicate inputs.";

(*verified warnings*)
Error::EpitopeBinningMissingNormalizationData =  "The NormalizationMethod, `1` ,requires data that could not be found in all input objects. Check that the normalization scheme is appropriate for the given BinningType.";
Error::EpitopeBinningMissingBaselineData =  "The data object does not include the requested type of baseline well `1`. Please select a different BaselineType.";
Warning::EpitopeBinningLargeFitDomain = "The FitDomain value `1` exceeds 20% of the length of the average competition data set. This may impact the validity of the results.";
Error::EpitopeBinningIncompatibleThresholdFormat = "The format of the following options is inconsistent with the NormalizationMethod, `1`. If the NormalizationMethod is none, specify a thickness in nm, otherwise specify between 1 and 100 or Automatic.";
Error::EpitopeBinningMissingSlowBindingSpecies = "If `1` si specified, the option for SlowBindingSpecies should also be populated. If there are no known species with slow association, set this parameter to Null.";
Error::EpitopeBinningSwappedThresholds = "The value of SlowBindingThreshold (`2`) exceeds that of Threshold (`1`). Verify that this is the desired input as the SlowBindingSpecies will have lower response that the other measured species and therefore require a lower threshold.";


(* unverified or in progress warnings *)
Warning::EpitopeBinningIncompleteDataSet = "The data objects do not test every possible pairing. The binning analysis cannot be conducted, only the raw response value for each pairing will be given in the output.";
Warning::EpitopeBinningSpeciesNotFound = "The following objects used as slow binding species were not found in the inputs or the composition or models of the inputs: `1`.";




(* ::Subsection:: *)
(*AnalyzeEpitopeBinning Overloads*)

(* ------------------------------- *)
(* -- EPITOPE BINNING OVERLOADS -- *)
(* ------------------------------- *)

(* -- overload for protocol objects -- *)
AnalyzeEpitopeBinning[
  protocol:ObjectP[{Object[Protocol, BioLayerInterferometry]}],
  ops:OptionsPattern[]
]:=Module[{dataObjs},

  (* extract the data objects, if there are non, return failed *)
  dataObjs = Download[protocol, Data, Date->Now];

  (*TODO: update to something safer*)
  (* return failed and NoEpitopeBinningDataObjects error *)
  If[MatchQ[dataObjs, ({}|Null)],
    Message[Error::NoEpitopeBinningDataObjects];
    Message[Error::InvalidInput, dataObjs];
    Return[outputSpecification /. {
      Result -> $Failed,
      Tests -> safeOptionTests,
      Options -> $Failed,
      Preview -> Null
    }]
  ];

  (* strip the link and send it to the next overload *)
  AnalyzeEpitopeBinning[
    ToList[Download[dataObjs, Object]],
    ops
  ]
];

(* ::Subsection:: *)
(*AnalyzeEpitopeBinning Core Function*)

(* -------------------- *)
(* -- CORE FUNCTION  -- *)
(* -------------------- *)


AnalyzeEpitopeBinning[
  dataObjects:{ObjectP[{Object[Data, BioLayerInterferometry]}]..},
  ops:OptionsPattern[]
]:= Module[{
  (* general/framework variables *)
  optionsCache, fieldsToDownload, listedOptions, outputSpecification, output, standardFieldsStart, gatherTests, messages, notInEngine, safeOptions, safeOptionTests,
  unresolvedOptions, templateTests, combinedOptions, cacheBall, allTests, resolvedOptionsTests, resolvedOptionsResult, collapsedResolvedOptions,
  analysisObjects, upload,
  (* download and resolution *)
  resolvedOptions,
  (* downloaded fields *)
  competitionData, competingSolutions, wellInformation, wellData, measuredWells, samplesIn, binningType,
  (* resolved options *)
  fitDomain, threshold, slowBindingThreshold,
  slowBindingSpecies, baselineType, normalizationMethod,
  (* processed data and data processing variables *)
  baselines, baselinedData, alignedData, alignedNormalizationData, normalizationDataValues, normalizationData, dataValues,
  preMixAdjustment, safeSamplesIn,responsePackets, crossBlockingPackets, composedGraph, graphVertices,
  graphVerticesLabels, unformattedGraph, slowBinderColorFunction, colorFunction, edgeStyle, composedVertexLabels,
  bins, binHighlightedGraph, groupedData, referenceObjects,
  (*cleanup for output*)
  indexedBins, dataTable, analysisObjectFieldPacket,
  (* output variables *)
  optionsRule, resultRule, testsRule, previewRule
},

  (* --------------- *)
  (* -- FRAMEWORK -- *)
  (* --------------- *)

  (* Make sure we're working with a list of options *)
  listedOptions = ToList[ops];

  (* Determine the requested return value from the function *)
  outputSpecification = OptionValue[Output];
  output = ToList[outputSpecification];

  (* fixed starting fields *)
  standardFieldsStart = analysisPacketStandardFieldsStart[{ops}];

  (* Determine if we should keep a running list of tests *)
  gatherTests = MemberQ[output, Tests];
  messages=!gatherTests;

  (* Determine if we are in Engine or not, in Engine we silence warnings *)
  notInEngine=Not[MatchQ[$ECLApplication,Engine]];

  (* Call SafeOptions to make sure all options match pattern *)
  {safeOptions, safeOptionTests} = If[gatherTests,
    SafeOptions[AnalyzeEpitopeBinning, listedOptions, AutoCorrect -> False, Output -> {Result, Tests}],
    {SafeOptions[AnalyzeEpitopeBinning, listedOptions, AutoCorrect -> False], Null}
  ];

  (* If the specified options don't match their patterns return $Failed *)
  If[MatchQ[safeOptions, $Failed],
    Return[outputSpecification /. {
      Result -> $Failed,
      Tests -> safeOptionTests,
      Options -> $Failed,
      Preview -> Null
    }]
  ];

  (* Use any template options to get values for options not specified in myOptions *)
  {unresolvedOptions, templateTests} = If[gatherTests,
    ApplyTemplateOptions[AnalyzeEpitopeBinning, dataObjects, listedOptions, Output -> {Result, Tests}],
    {ApplyTemplateOptions[AnalyzeEpitopeBinning, dataObjects, listedOptions], Null}
  ];

  (* combine the options *)
  combinedOptions = ReplaceRule[safeOptions, unresolvedOptions];

  (* -------------- *)
  (* -- DOWNLOAD -- *)
  (* -------------- *)

  (* fields to download are for BLI objects only. This will need to change for SPR. Note that we download a couple fields we wont use to match the previous download so we can clean up the cache*)
  fieldsToDownload = Packet[
    DataType,
    SamplesIn,
    CompetingSolutions,
    CompetitionData,
    WellInformation,
    WellData,
    MeasuredWellPositions,
    BinningType
  ];

  (* download the things *)
  optionsCache=Quiet[
    Download[
      dataObjects,
      fieldsToDownload
    ],
    Download::FieldDoesntExist
  ];

  (* pass the object packets through the cache - important to look it up from listed options because everything else has it removed *)
  cacheBall = Cases[Experiment`Private`FlattenCachePackets[{optionsCache}], PacketP[]];

  (* ------------------------ *)
  (* -- OPTIONS RESOLUTION -- *)
  (* ------------------------ *)

  (*--Build the resolved options--*)
  resolvedOptionsResult=If[gatherTests,
    (*We are gathering tests. This silences any messages being thrown*)
    {resolvedOptions,resolvedOptionsTests}=resolveAnalyzeEpitopeBinningOptions[dataObjects,combinedOptions,Cache->cacheBall,Output->{Result,Tests}];

    (*Therefore, we have to run the tests to see if we encountered a failure*)
    If[RunUnitTest[<|"Tests"->resolvedOptionsTests|>,OutputFormat->SingleBoolean,Verbose->False],
      {resolvedOptions,resolvedOptionsTests},
      $Failed
    ],

    (*We are not gathering tests. Simply check for Error::InvalidInput and Error::InvalidOption*)
    Check[
      {resolvedOptions,resolvedOptionsTests}={resolveAnalyzeEpitopeBinningOptions[dataObjects,combinedOptions,Cache->cacheBall],{}},
      $Failed,
      {Error::InvalidInput,Error::InvalidOption}
    ]
  ];

  (*Collapse the resolved options*)
  collapsedResolvedOptions=CollapseIndexMatchedOptions[
    AnalyzeEpitopeBinning,
    resolvedOptions,
    Ignore->listedOptions,
    Messages->False
  ];

  (* collect tests *)
  allTests=Cases[Flatten[{safeOptionTests,resolvedOptionsTests}],_EmeraldTest];

  (*If option resolution failed, return early*)
  If[MatchQ[resolvedOptionsResult,$Failed],
    Return[outputSpecification/.{
      Result->$Failed,
      Tests->allTests,
      Options->RemoveHiddenOptions[AnalyzeEpitopeBinning, collapsedResolvedOptions],
      Preview->Null
    }]
  ];


  (* ------------------------ *)
  (* -- MAIN ANALYSIS BODY -- *)
  (* ------------------------ *)


  (* -- Extract Options -- *)
  {
    fitDomain,
    threshold,
    slowBindingThreshold,
    slowBindingSpecies,
    baselineType,
    normalizationMethod,
    upload
  }=Lookup[resolvedOptions,
    {
      FitDomain,
      Threshold,
      SlowBindingThreshold,
      SlowBindingSpecies,
      BaselineType,
      NormalizationMethod,
      Upload
    }];

  (* -- Lookup Fields -- *)
  (* download everything we need from the cache *)
  {
    competitionData,
    competingSolutions,
    wellInformation,
    wellData,
    measuredWells,
    samplesIn,
    binningType
  } = Transpose[
    Download[dataObjects,
      {
        CompetitionData,
        CompetingSolutions,
        WellInformation,
        WellData,
        MeasuredWellPositions,
        SamplesIn,
        BinningType
      },
      Cache -> cacheBall
    ]
  ];


  (* --------------------- *)
  (* -- DATA PROCESSING -- *)
  (* --------------------- *)

  (*
  In this section we:
   (1) extract the baseline and normalization (Helper: findBinningBaseline, findBinningNormalizationData)
   (2) use the specified baselines to adjust the data (Helper: BaselineBLIData)
   (3) use align all of the data so it starts at 0 (Helper: alignBLIData)
   (4) return the baselines/aligned data, which starts at (0,0)

   Note that steps (1) and (2) are necessary becasue (1) accounts for drift, while (2) allow us to easily calculate the change in response rather than absolute reponse.
   This will also help with generating plots.
  *)

  (* -- BASELINE DATA -- *)

  (* find the baselines *)
  baselines = findBinningBaseline[Download[dataObjects, Object], baselineType, First[Flatten[binningType]], cacheBall];


  (* do the baseline subtraction mapthreading the helper at level 2. this will retain the format/ordering*)
  baselinedData = If[MatchQ[baselines, Null|{Null..}|{{}..}],
    competitionData,
    (* this baseline helper single input overload feeds the listable form so we need to Flatten by 1 *)
    MapThread[First[Analysis`Private`baselineBLIQuantitationData[#1, #2, False]]&, {competitionData, baselines}, 2]
  ];

  (* -- ALIGN DATA -- *)
  (* also align the data so that they all start at 0. The baseline has taken care of drift but may not have moved this to 0 response. The input form is now {{QA x 7} x 7} *)
  (* this helper set is a little weird in that it the times shoudl be index matched to the data. also outputs list so needs to be flattened*)
  alignedData = Map[Flatten[Analysis`Private`alignBLIData[#, 0 Nanometer,  0 Second],1]&, baselinedData, {2}];

  (* ------------------ *)
  (* -- DATA FITTING -- *)
  (* ------------------ *)
  (*
  In this section we:
    (1) obtain average values for each of the competition steps and keep them stored with the bound and interacting species
    (2) obtain the average values for any of the wells used for normalization
    (3) apply the normalization scheme to produce value in the form of percentages rather than raw thickness in nm
  *)


  (* use the appropriate time domain to calculate the average response from the baselines and aligned data *)
  dataValues = Map[
    Module[{unitlessData, timeToNormalize, dataToNormalize, maxTime, normalizationFactor, dataLength},
      (* by mapping at level 2, we are dealing with a QA here so no need to worry abotu lists *)
      unitlessData = Unitless[#];
      maxTime = unitlessData[[-1,1]];
      dataLength = Length[unitlessData];
      (* if we have a percent, we need to get the closest part *)
      timeToNormalize = If[MatchQ[Units[fitDomain], TimeP],

        (* if its a time, just subtract from teh max time *)
        maxTime - Unitless[UnitConvert[fitDomain, Second]],

        (* if its a percent, get the closest part *)
        Module[{requestedPart},

          (* its the last 10 Percent *)
          requestedPart = Round[(100-Unitless[fitDomain])*dataLength/100, 1];

          (* look up the time at that part *)
          First[Part[unitlessData, requestedPart]]
        ]
      ];
      dataToNormalize = Cases[unitlessData, {GreaterP[timeToNormalize], _}];

      (* determine the response by averaging over the specified data *)
      normalizationFactor = Mean[dataToNormalize[[All,2]]]
    ]&,
    alignedData,
    {2}
  ];

  (* -- PREPARE NORMALIZATION -- *)

  (* there is a normalization element for every element of the data if normalization scheme is valid (checked in options) *)
  normalizationData = findBinningNormalizationData[dataObjects, normalizationMethod, First[Flatten[binningType]], cacheBall];


  (* pass it through the align fucntion to start the curve at (0,0) *)
  alignedNormalizationData = If[MatchQ[normalizationData, Null|{{}..}|{Null..}],
    Null,
    Map[Flatten[Analysis`Private`alignBLIData[#, 0 Nanometer,  0 Second],1]&, normalizationData, {2}]
  ];

  (* get the normalization factors *)
  normalizationDataValues = If[MatchQ[alignedNormalizationData, Null],

    (* if we arent normalizing then return Null *)
    Null,

    (* do the averaging over the specified data region *)
    Map[
      Module[{unitlessData, timeToNormalize, dataToNormalize, maxTime, normalizationFactor, dataLength},
        (* by mapping at level 2, we are dealing with a QA here so no need to worry abotu lists *)
        unitlessData = Unitless[#];
        maxTime = unitlessData[[-1,1]];
        dataLength = Length[unitlessData];
        (* if we have a percent, we need to get the closest part *)
        timeToNormalize = If[MatchQ[Units[fitDomain], TimeP],

          (* if its a time, just subtract from teh max time *)
          maxTime - Unitless[UnitConvert[fitDomain, Second]],

          (* if its a percent, get the closest part *)
          Module[{requestedPart},

            (* its the last 10 Percent *)
            requestedPart = Round[(100-Unitless[fitDomain])*dataLength/100, 1];

            (* look up the time at that part *)
            First[Part[unitlessData, requestedPart]]
          ]
        ];
        dataToNormalize = Cases[unitlessData, {GreaterP[timeToNormalize], _}];

        (* determine the response by averaging over the specified data *)
        normalizationFactor = Mean[dataToNormalize[[All,2]]]
      ]&,
      alignedNormalizationData,
      {2}
    ]
  ];

  (* ------------------ *)
  (* -- PACKAGE DATA -- *)
  (* ------------------ *)

  (* as is, everythign is formatted as a list of lists of either values od quantity arrays *)
  (* the desired format is: <|Bound -> Object, Competing -> Object, Raw -> Value, Normalizer -> Value, NormalizedValue -> Value|> *)

  (* we have a little helper for PreMix to jsut switch Bound and Competing *)
  preMixAdjustment = If[MatchQ[binningType, PreMix],
    {Bound -> Competing, Competing -> Bound},
    {}
  ];

  (* match the dimensions of samples in so we can flatten and do an easy MapThread - its a square experiment so each sample in will interact with every other sample *)
  safeSamplesIn = ConstantArray[#,Length[samplesIn]]&/@samplesIn;

  (* output the packets with the normalization data *)
  responsePackets = If[MatchQ[alignedNormalizationData, Null],

    (* if no normaliztion was done, set that factor to one such that normalized response is just the raw response *)
    (* note that negative values are repalced with 0 both for normalization and for data elements *)
    MapThread[
      Function[
        {boundSample, competingSample, dataValue},
        <|
          (Bound/.preMixAdjustment) ->boundSample[Object],
          (Competing/.preMixAdjustment) -> competingSample[Object],
          RawResponse -> dataValue/.x:LessP[0]->0,
          NormalizationFactor -> 1,
          NormalizedResponse -> dataValue
        |>
      ],
      {Flatten[safeSamplesIn], Flatten[competingSolutions], Flatten[dataValues]}
    ],

    (* if there is normalization data, use that *)
    MapThread[
      Function[
        {boundSample, competingSample, dataValue, normFactor},
        <|
          (Bound/.preMixAdjustment) ->boundSample[Object],
          (Competing/.preMixAdjustment) -> competingSample[Object],
          RawResponse -> dataValue/.x:LessP[0]->0,
          NormalizationFactor -> normFactor/.x:LessP[0]->0,
          NormalizedResponse -> dataValue/normFactor
        |>
      ],
      {Flatten[safeSamplesIn], Flatten[competingSolutions], Flatten[dataValues], Flatten[normalizationDataValues]}
    ]
  ];


  (* ---------------------- *)
  (* -- BINNING ANALYSIS -- *)
  (* ---------------------- *)

  (* find any steps that are cross blocking *)
  crossBlockingPackets = Select[
    responsePackets,
    Or[
      MatchQ[Lookup[#, NormalizedResponse], LessP[Unitless[threshold]]]&&MatchQ[Lookup[#,Competing], Except[Alternatives@@Download[slowBindingSpecies, Object]]],
      MatchQ[Lookup[#, NormalizedResponse], LessP[Unitless[slowBindingThreshold/.Null -> 0]]]&&MatchQ[Lookup[#,Competing], Alternatives@@Download[slowBindingSpecies, Object]]
    ]&
  ];


  (*
  In this section we:
    (1) use the threshold to identify pairs of objects that go together using the Threshold or SlowBinderThreshold
    (2) check if the pairs also interact the same with other objects
    (3) group into bins and throw warnings if there are inconsistancies such as a pair that are blockign but dont block behave the same when competing with other antibodies
  *)

  (* create a graph to visualize the bins *)
  (* note that the fomatting is put into each graph element, not index matched *)

  (* ----------------------------- *)
  (* -- CREATE AND FORMAT GRAPH -- *)
  (* ----------------------------- *)

  (* make a color function to show how strong the binding is *)
  colorFunction = {
    x:GreaterP[Unitless[threshold]*0.75] -> Red,
    x:RangeP[Unitless[threshold]*0.5, Unitless[threshold]*0.75]->Orange,
    x:RangeP[Unitless[threshold]*0.25, Unitless[threshold]*0.5]->Yellow,
    x:LessP[Unitless[threshold]*0.25]->Green
  };

  (* make a color function for the slow binders also *)
  slowBinderColorFunction = If[MatchQ[slowBindingThreshold, Null],
    {},
    {
      x:GreaterP[Unitless[slowBindingThreshold]*0.75] -> Red,
      x:RangeP[Unitless[slowBindingThreshold]*0.5, Unitless[slowBindingThreshold]*0.75]->Orange,
      x:RangeP[Unitless[slowBindingThreshold]*0.25, Unitless[slowBindingThreshold]*0.5]->Yellow,
      x:LessP[Unitless[slowBindingThreshold]*0.25]->Green
    }
  ];

  (* make the graph input with formatting *)
  unformattedGraph =
    Map[
      Module[{bound, competing, response},
        {bound, competing, response} = Lookup[#, {Bound, Competing, NormalizedResponse}];

        (* make the color function graph *)
        bound<->competing
      ]&,
      crossBlockingPackets
  ];

  (* make the edges color scheme based on how good the blocking is *)
  edgeStyle = MapThread[Module[{colorRule, color},
    colorRule = If[MemberQ[Download[slowBindingSpecies, Object],#1[[2]]],
      slowBinderColorFunction,
      colorFunction
    ];

    color = Lookup[#2, NormalizedResponse]/.colorRule;
    #1 -> color
  ]&,
    {unformattedGraph, crossBlockingPackets}
  ];

  (* graph the vertices also so we can label them *)
  graphVertices = Lookup[crossBlockingPackets, Bound];
  graphVerticesLabels = Download[graphVertices, ID];
  composedVertexLabels = MapThread[(#1->#2)&, {graphVertices, graphVerticesLabels}];

  composedGraph = Graph[
    unformattedGraph,
    VertexLabels -> composedVertexLabels,
    EdgeStyle -> edgeStyle,
    ImageSize -> Medium,
    VertexStyle -> Blue,
    VertexSize -> Small,
    VertexShapeFunction -> "Hexagon"
  ];

  (* check for any true bins, ie those where every element blocks every other element *)
  bins = ConnectedComponents[composedGraph];

  (* index the bins for output to avoid a multiple multiple *)
  indexedBins = Join@@MapIndexed[Transpose[{#1, ConstantArray[First[#2], Length[#1]]}]&, bins];

  (* also visualize as bins on the graph *)
  binHighlightedGraph = HighlightGraph[composedGraph, bins];

  (*output the boring old table too*)
  dataTable = Map[Lookup[#,{Bound, Competing, NormalizedResponse}]&,responsePackets];

  (* format the data in groups for PlotTable - use style here to get the conditional formatting*)
  groupedData = Map[
    Function[sample,
      Module[{relevantSteps, responses, styledResponses},
        (*find the steps and response values*)
        relevantSteps = Select[responsePackets, MatchQ[Lookup[#,Bound], sample]&];
        responses = Lookup[relevantSteps, NormalizedResponse];

        (* style them accordingly *)
        styledResponses = MapThread[
          If[MemberQ[Download[slowBindingSpecies, Object], Lookup[#1, Competing]],
            (* for the slow binders *)
            If[MatchQ[#2, LessP[Unitless[slowBindingThreshold]]],
              Style[#2, Green],
              #2
            ],
            If[MatchQ[#2, LessP[Unitless[threshold]]],
              Style[#2, Green],
              #2
            ]
          ]&,
          {relevantSteps, responses}
        ]
      ]
    ],
    Flatten[Download[samplesIn, Object]]
  ];

  (* ----------------------------- *)
  (* -- PREPARE ANALYSIS OBJECT -- *)
  (* ----------------------------- *)

  (* get the links for the reference objects *)
  referenceObjects = Link[#, BinningAnalysis]&/@dataObjects;

  (* Create the Analysis Object packet *)
  analysisObjectFieldPacket = Association@@{
    Type -> Object[Analysis, EpitopeBinning],
    Append[Reference] -> referenceObjects,
    Replace[SamplesIn] -> Link/@ Flatten[Download[samplesIn, Object]],
    ResolvedOptions -> resolvedOptions,
    UnresolvedOptions -> listedOptions,
    Threshold -> threshold,
    SlowBindingThreshold -> slowBindingThreshold,
    Replace[SlowBindingSpecies] -> Link/@(slowBindingSpecies /. Null -> {}),
    Replace[CompetitionData] -> dataTable,
    Replace[BinnedInputs] -> indexedBins
  };


  (* -------------------------- *)
  (* -- GENERATE THE PREVIEW -- *)
  (* -------------------------- *)

  previewRule = If[MemberQ[output, Preview],
    Preview -> TabView[
      {
        "Binned Data Graph"-> Zoomable[binHighlightedGraph],
        "Competition Data"->Zoomable[
          PlotTable[
            groupedData,
            TableHeadings -> ConstantArray[Download[First[competingSolutions],ID],2],
            SecondaryTableHeadings -> {{"Bound Antibody"}, {"Competing Antibody"}},
            Caption -> "Normalized response during competition with a second antibody: Green cells exhibit blocking behavior based on the set threshold."
          ]
        ],
        "Binned Antibodies" -> Zoomable[
          PlotTable[
            indexedBins,
            TableHeadings -> {None, {"Antibody", "Bin"}},
            Caption -> "Antibodies are grouped into bins based on their blocking behavior during a competition step."
          ]
        ]
      },
      Alignment -> Center
    ],
    Preview -> Nothing
  ];


  (* ------------------ *)
  (* -- Options Rule -- *)
  (* ------------------ *)

  optionsRule=Options->If[MemberQ[output,Options],
    RemoveHiddenOptions[AnalyzeEpitopeBinning,resolvedOptions],
    Null
  ];

  (* ---------------- *)
  (* -- Tests Rule -- *)
  (* ---------------- *)

  (* gather all the tests *)
  allTests=Cases[
    Flatten[
      {
        safeOptionTests,
        resolvedOptionsTests
      }
    ],
    _EmeraldTest
  ];

  (* Next, define the Tests Rule *)
  testsRule=Tests->If[MemberQ[output,Tests],
    allTests,
    Null
  ];

  (* ----------------- *)
  (* -- Result Rule -- *)
  (* ----------------- *)

  (* First, upload the analysis object packet if upload is True *)
  analysisObjects=If[upload&&MemberQ[output,Result],
    Upload[analysisObjectFieldPacket],
    analysisObjectFieldPacket
  ];

  resultRule=Result->If[MemberQ[output,Result],
    Which[
      (* In the case where upload is True, return the uploaded analysis object *)
      upload,
      analysisObjects,
      (* Otherwise, (Upload is false just return the analysis object packet *)
      True,
      ToList[analysisObjects]
    ],
    Null
  ];

  outputSpecification/.{
    optionsRule,
    resultRule,
    testsRule,
    previewRule
  }
];








(* ::Subsection:: *)
(* resolveAnalyzeEpitopeBinningOptions*)


(* ========================= *)
(* == RESOLVE ABQ OPTIONS == *)
(* ========================= *)

DefineOptions[resolveAnalyzeEpitopeBinningOptions,
  Options:>{
    CacheOption,
    HelperOutputOption
  }
];

resolveAnalyzeEpitopeBinningOptions[
  dataObjects:{ObjectP[Object[Data, BioLayerInterferometry]]..},
  myOptions:{_Rule..},
  ops:OptionsPattern[resolveAnalyzeEpitopeBinningOptions]
]:= Module[
  {
    outputSpecification, output, gatherTests, messages, allInvalidAEBOptions, allAEBTests, aebOptionsAssociation, cache,
    (* original options *)
    fitDomain, threshold, slowBindingThreshold, slowBindingSpecies, baselineType, normalizationMethod,
    (* automatic resolved options *)
    resolvedThreshold, resolvedSlowBindingThreshold,
    (*things we download and other variables*)
    fullAverageTime, competitionData, competingSolutions, wellInformation, wellData, measuredWells, samplesIn, binningType,
    requestedNormalizationData,requestedBaselineData, missingNormalizationData, missingBaselineData,  allCompetingSpecies,
    safeCompetingSpecies, unrecognizedSpecies,
    (*invalid options*)
    incompatibleThresholdFormatOptions, missingSlowBindingSpeciesOption, swappedThresholdOptions, mixedInputObjects, objectsWithoutData,
    invalidNormalizationOptions, missingBaselineOptions, incompleteDataSetObjects,
    (* invalid option tests *)
    incompatibleThresholdFormatTest, missingSlowBindingSpeciesTest, swappedThresholdTest, mixedInputTest, objectsWithoutDataTest,
    invalidNormalizationOptionsTest, missingBaselineOptionsTest, incompleteDataSetTest,
    (* clean up *)
    invalidInputs, resolvedOps, resultRule,testsRule
  },


  (* -- set up cache -- *)
  cache = Lookup[ToList[ops], Cache];

  (* Determine the requested output format of this function. *)
  outputSpecification=OptionValue[Output];
  output=ToList[outputSpecification];

  (* Determine if we should keep a running list of tests to return to the user. *)
  gatherTests = MemberQ[output,Tests];
  messages = !gatherTests;

  (* make an association *)
  aebOptionsAssociation = Association[myOptions];

  (* lookup the options *)
  {
    fitDomain,
    threshold,
    slowBindingThreshold,
    slowBindingSpecies,
    baselineType,
    normalizationMethod
  }=Lookup[aebOptionsAssociation,
    {
      FitDomain,
      Threshold,
      SlowBindingThreshold,
      SlowBindingSpecies,
      BaselineType,
      NormalizationMethod
    }
  ];

  (* download everything we need from the cache *)
  {
    competitionData,
    competingSolutions,
    wellInformation,
    wellData,
    measuredWells,
    samplesIn,
    binningType
  } = Transpose[
    Download[dataObjects,
      {
        CompetitionData,
        CompetingSolutions,
        WellInformation,
        WellData,
        MeasuredWellPositions,
        SamplesIn,
        BinningType
      },
      Cache -> cache
    ]
  ];

  (* ------------------------- *)
  (* -- INVALID INPUT CHECK -- *)
  (* ------------------------- *)

  (* make sure all object are of the same type *)
  mixedInputObjects = If[MatchQ[Length[DeleteDuplicates[binningType]], GreaterP[1]],
    dataObjects,
    {}
  ];

  (* throw an error  *)
  If[!MatchQ[mixedInputObjects, {}]&&messages,
    Message[Error::EpitopeBinningMixedInputType, dataObjects, binningType]
  ];

  (* make the test for meaningless filter width*)
  mixedInputTest = If[gatherTests,
    Test["All Data Object inputs or Data Objects associated with teh Protocol inputs are of the same BinningType:",
      MatchQ[mixedInputObjects, {}],
      True
    ],
    Null
  ];

  (* make sure all objects have data *)
  objectsWithoutData = PickList[dataObjects, competitionData, (Null|{})];

  (* throw an error  *)
  If[!MatchQ[objectsWithoutData, {}]&&messages,
    Message[Error::EpitopeBinningMissingData, objectsWithoutData]
  ];

  (* make the test for meaningless filter width*)
  objectsWithoutDataTest = If[gatherTests,
    Test["All Data Object inputs or Data Objects associated with the Protocol inputs contain CompetitionData:",
      MatchQ[objectsWithoutData, {}],
      True
    ],
    Null
  ];

  (* incomplete data set *)
  incompleteDataSetObjects = Module[{numberOfObjects, numberOfSolutions, squareAssayBool},
    numberOfObjects = Length[DeleteDuplicates[dataObjects]];
    numberOfSolutions = Length/@competingSolutions;

    (* if the lengths dont match, its not a viable experiment *)
    squareAssayBool = And@@Map[If[MatchQ[#, numberOfObjects], True, False]&, numberOfSolutions];

    (* if the assay is bad, return all the objects *)
    If[squareAssayBool, {}, dataObjects]
  ];

  (* throw an error  *)
  If[!MatchQ[incompleteDataSetObjects, {}]&&messages,
    Message[Error::EpitopeBinningIncompleteDataSet, incompleteDataSetObjects]
  ];

  (* make the test for meaningless filter width*)
  incompleteDataSetTest = If[gatherTests,
    Test["The input data includes a full set blocking interactions:",
      MatchQ[incompleteDataSetObjects, {}],
      True
    ],
    Null
  ];

  (* ------------------------------- *)
  (* -- CONFLICTING OPTIONS CHECK -- *)
  (* ------------------------------- *)

  (* -- FitDomain length -- *)

  (* this is a check to make sure that the user is not trying to use an unreasonably large region of the data for averaging max response *)
  fullAverageTime = Module[{flatCompetitionData, minTimes,maxTimes},

    (* ge ta flat list of quantity arrays and strip units *)
    flatCompetitionData = Unitless[Flatten[competitionData,1]];

    (* pull out all the last values *)
    {minTimes,maxTimes} = {flatCompetitionData[[All,1,1]], flatCompetitionData[[All,-1,1]]};

    (* get the average time for a step *)
    Mean[Subtract[maxTimes, minTimes]]
  ];

  (* throw a warning for very large fit domains either specified by time or by percent *)
  If[
    Or[
    MatchQ[Units[fitDomain], TimeP]&&MatchQ[Unitless[fitDomain], GreaterP[fullAverageTime*0.2]],
    MatchQ[Unitless[fitDomain], GreaterP[20]]
  ],
    Message[Warning::EpitopeBinningLargeFitDomain, fitDomain]
  ];


  (* -- Threshold/NormalizationMethod conflict -- *)

  (* gather the bad option - if there is a normalization then we shoudl not have Quantity *)
  (* note that the normalization method is not automatic and defaults to None *)
  incompatibleThresholdFormatOptions = Which[

    MatchQ[normalizationMethod, None],
    PickList[{Threshold, SlowBindingThreshold},{threshold, slowBindingThreshold}, Except[(_?QuantityQ|Automatic)]],

    MatchQ[normalizationMethod, Except[None]],
    PickList[{Threshold, SlowBindingThreshold},{threshold, slowBindingThreshold}, _?QuantityQ],

    True,
    {}
  ];

  (* throw the error *)
  If[!MatchQ[incompatibleThresholdFormatOptions, {}]&&messages,
    Message[Error::EpitopeBinningIncompatibleThresholdFormat, incompatibleThresholdFormatOptions]
  ];

  (* make the test for meaningless filter width*)
  incompatibleThresholdFormatTest = If[gatherTests,
    Test["If thresholds are specified they are consistent with the NormalizationMethod:",
      MatchQ[incompatibleThresholdFormatOptions, {}],
      True
    ],
    Null
  ];


  (* -- SlowBindingSpecies are informed if needed -- *)

  (* gather the bad option - if there is a slow binding threhsold there should also be a species *)
  missingSlowBindingSpeciesOption = If[MatchQ[slowBindingThreshold, Except[(Null|Automatic)]]&&MatchQ[slowBindingSpecies,(Null|{})],
    {SlowBindingSpecies},
    {}
  ];

  (* throw the error *)
  If[!MatchQ[missingSlowBindingSpeciesOption, {}]&&messages&&Not[MatchQ[$ECLApplication, Engine]],
    Message[Error::EpitopeBinningMissingSlowBindingSpecies, missingSlowBindingSpeciesOption]
  ];

  (* make the test for meaningless filter width*)
  missingSlowBindingSpeciesTest = If[gatherTests,
    Test["If SlowBindingThreshold is specified, the SlowBindingSpecies are also specified:",
      MatchQ[missingSlowBindingSpeciesOption, {}],
      True
    ],
    Null
  ];


  (* -- SlowBindingThreshold is lower than Threshold -- *)

  (* gather the bad option - the slowbindingThreshold should be lower *)
  swappedThresholdOptions = If[MatchQ[slowBindingThreshold, Except[Automatic]]&&MatchQ[threshold,Except[Automatic]],
    If[MatchQ[slowBindingThreshold, GreaterEqualP[threshold]],
      {Threshold, SlowBindingThreshold},
      {}
    ],
    {}
  ];

  (* throw the error *)
  If[!MatchQ[swappedThresholdOptions, {}]&&messages&&Not[MatchQ[$ECLApplication, Engine]],
    Message[Error::EpitopeBinningSwappedThresholds, threshold, slowBindingThreshold]
  ];

  (* make the test for meaningless filter width*)
  swappedThresholdTest = If[gatherTests,
    Test["If SlowBindingThreshold is specified it is lower than Threshold:",
      MatchQ[swappedThresholdOptions, {}],
      True
    ],
    Null
  ];


  (* -- SlowBindingSpecies -- *)

  (* gather all of the competing species - note that we should expand this at some point to encompass Model[Molecule] as well and maybe Model[Sample] *)
  allCompetingSpecies = Download[dataObjects, CompetingSolutions, Cache -> cache];
  safeCompetingSpecies = Flatten[Download[allCompetingSpecies, Object]];

  (*if any of the listed species are not elements of the competing solutions list then they are not recognized and we should throw a warning *)
  unrecognizedSpecies = Flatten[
    Map[
      If[!MemberQ[ToList[safeCompetingSpecies], Download[#, Object]],
        #,
        {}
      ]&,
      slowBindingSpecies/.Null->{}
    ]
  ];

  (* throw a warning if there are species here that aren't used in the assay *)
  If[!MatchQ[unrecognizedSpecies, {}]&&messages&&Not[MatchQ[$ECLApplication, Engine]],
    Message[Warning::EpitopeBinningSpeciesNotFound, unrecognizedSpecies]
  ];


  (* ------------------------- *)
  (* -- RESOLVE THE OPTIONS -- *)
  (* ------------------------- *)

  (* -- Threshold -- *)
  resolvedThreshold = If[MatchQ[normalizationMethod, None],
    threshold/.Automatic -> 0.4 Nanometer,
    threshold/.Automatic -> 0.2
  ];

  (* -- SlowBindingThreshold -- *)
  (*Note: if there is normalization, the binding threshold should be set to match the resolvedThreshold because, well, they're normalized*)
  resolvedSlowBindingThreshold = If[MatchQ[slowBindingSpecies, Null],

    (* if theres no slow binders then this should be nulled *)
    slowBindingThreshold/.Automatic -> Null,

    (* set appropriately based on normalization *)
    If[MatchQ[normalizationMethod, None],
      slowBindingThreshold/.Automatic -> 0.2 Nanometer,
      slowBindingThreshold/.Automatic -> resolvedThreshold
    ]
  ];

  (* -------------------------- *)
  (* -- BASELINE ERROR CHECK -- *)
  (* -------------------------- *)

  (* use helper to check that the baselines that were requested actually exist *)
  (* note that the output is a list of lists of baselines. Each individual baseline could possibly return Null, and the entire set could return {}. *)
  requestedBaselineData = findBinningBaseline[Download[dataObjects, Object], baselineType, First[binningType], cache];

  (* find any missing elements in the baseline list *)
  missingBaselineData = Cases[requestedBaselineData, (Null|{}), Infinity];

  (* check that the user specified baseline actually exists using the helper function *)
  missingBaselineOptions = If[
    !MatchQ[missingBaselineData,{}]&&MatchQ[baselineType, Except[None]],
    {BaselineType},
    {}
  ];

  (* throw the error *)
  If[!MatchQ[missingBaselineOptions, {}]&&messages,
    Message[Error::EpitopeBinningMissingBaselineData, baselineType]
  ];

  (* make the test for meaningless filter width*)
  missingBaselineOptionsTest = If[gatherTests,
    Test["The data which is required for the given BaselineType is present in all data objects:",
      MatchQ[missingBaselineOptions, {}],
      True
    ],
    Null
  ];

  (* ------------------------------- *)
  (* -- NORMALIZATION ERROR CHECK -- *)
  (* ------------------------------- *)

  (* use helper to check that the normalization type actually exists *)
  requestedNormalizationData = findBinningNormalizationData[dataObjects, normalizationMethod, First[binningType], cache];

  (* becasue of hte output form, we need to serach for empty lists and Nulls at all levels *)
  missingNormalizationData = Cases[requestedNormalizationData, (Null|{}), Infinity];

  (* if the function cant find it, it will return {} or elements with {} or Null. Dont throw the error if they didnt ask for normalization  *)
  invalidNormalizationOptions = If[
    !MatchQ[missingNormalizationData, {}]&&MatchQ[normalizationMethod, Except[None]],
    {NormalizationMethod},
    {}
  ];

  (* throw the error *)
  If[!MatchQ[invalidNormalizationOptions, {}]&&messages,
    Message[Error::EpitopeBinningMissingNormalizationData, normalizationMethod]
  ];

  (* make the test for meaningless filter width*)
  invalidNormalizationOptionsTest = If[gatherTests,
    Test["The data which is required for the given NormalizationMethod is present in all data objects:",
      MatchQ[invalidNormalizationOptions, {}],
      True
    ],
    Null
  ];

  (* ------------------ *)
  (* -- GATHER TESTS -- *)
  (* ------------------ *)

  allAEBTests = Cases[
    Flatten[
      {
        incompatibleThresholdFormatTest,
        missingSlowBindingSpeciesTest,
        swappedThresholdTest,
        mixedInputTest,
        objectsWithoutDataTest,
        invalidNormalizationOptionsTest,
        missingBaselineOptionsTest,
        incompleteDataSetTest
      }
    ],
    _EmeraldTest
  ];

  (* ---------------------------- *)
  (* -- GATHER INVALID OPTIONS -- *)
  (* ---------------------------- *)

  (* gather all the invalid or conflicting options which have caused an error *)
  allInvalidAEBOptions = DeleteDuplicates[
    Flatten[
      {
        incompatibleThresholdFormatOptions,
        missingSlowBindingSpeciesOption,
        swappedThresholdOptions,
        invalidNormalizationOptions,
        missingBaselineOptions
      }
    ]
  ];

    (* Define the Invalid Options *)
    invalidInputs=DeleteDuplicates[
      Flatten[
        {
          mixedInputObjects,
          objectsWithoutData,
          incompleteDataSetObjects
        }
      ]
    ];

  (*Throw Error::InvalidInput if there are invalid options*)
  If[Length[invalidInputs]>0&&messages,
    Message[Error::InvalidInput,invalidInputs]
  ];


  (*Throw Error::InvalidOption if there are invalid options*)
  If[Length[allInvalidAEBOptions]>0&&messages,
    Message[Error::InvalidOption, allInvalidAEBOptions]
  ];

  (* --------------------------------- *)
  (* -- RETURN THE RESOLVED OPTIONS -- *)
  (* --------------------------------- *)

  resolvedOps = ReplaceRule[myOptions,
    {
      Threshold -> resolvedThreshold,
      SlowBindingThreshold -> resolvedSlowBindingThreshold
    }
  ];

  (*Generate the result output rule: if not returning result, result rule is just Null*)
  resultRule=Result->If[MemberQ[output,Result],
    resolvedOps,
    Null
  ];

  (*Generate the tests output rule*)
  testsRule=Tests->If[gatherTests,
    allAEBTests,
    Null
  ];


  (*Return the output as we desire it*)
  outputSpecification/.{resultRule,testsRule}
];




(* ::Subsection:: *)
(* ValidAnalyzeEpitopeBinningQ*)

(* --------------------------------- *)
(* -- ValidAnalyzeEpitopeBinningQ -- *)
(* --------------------------------- *)


DefineOptions[ValidAnalyzeEpitopeBinningQ,
  Options:>
      {
        VerboseOption,
        OutputFormatOption
      },
  SharedOptions:>{AnalyzeEpitopeBinning}
];

ValidAnalyzeEpitopeBinningQ[
  myData:ObjectP[Object[Protocol,BioLayerInterferometry]]|{ObjectP[Object[Data,BioLayerInterferometry]]..},
  myOptions:OptionsPattern[]
]:=Module[
  {listedOptions,preparedOptions,epitopeBinningTests,initialTestDescription,allTests,verbose,outputFormat},

  (* Get the options as a list *)
  listedOptions=ToList[myOptions];

  (* Remove the output option before passing to the core function because it doesn't make sense here *)
  preparedOptions=DeleteCases[listedOptions,(Output|Verbose|OutputFormat)->_];

  (* Return only the tests for AnalyzeEpitopeBinning *)
  epitopeBinningTests=AnalyzeEpitopeBinning[myData,Append[preparedOptions,Output->Tests]];

  (* Define the general test description *)
  initialTestDescription="All provided options and inputs match their provided patterns (no further testing can proceed if this test fails):";

  (* Make a list of all of the tests, including the blanket test *)
  allTests=If[MatchQ[epitopeBinningTests,$Failed],
    {Test[initialTestDescription,False,True]},
    Module[
      {initialTest,validObjectBooleans,voqWarnings},

      (* Generate the initial test, which we know will pass if we got this far (hopefully) *)
      initialTest=Test[initialTestDescription,True,True];

      (* Create warnings for invalid objects *)
      validObjectBooleans=ValidObjectQ[DeleteCases[ToList[myData],_String],OutputFormat->Boolean];

      voqWarnings=MapThread[
        Warning[StringJoin[ToString[#1,InputForm]," is valid (run ValidObjectQ for more detailed information):"],
          #2,
          True
        ]&,
        {DeleteCases[ToList[myData],_String],validObjectBooleans}
      ];

      (* Get all the tests/warnings *)
      Flatten[{initialTest,epitopeBinningTests,voqWarnings}]
    ]
  ];

  (* Determine the Verbose and OutputFormat options; quiet the OptionValue::nodef message in case someone just passed nonsense *)
  {verbose,outputFormat}=Quiet[OptionDefault[OptionValue[{Verbose,OutputFormat}]],OptionValue::nodef];

  (* Run all the tests as requested *)
  Lookup[
    RunUnitTest[
      <|"ValidAnalyzeEpitopeBinningQ"->allTests|>,
      OutputFormat->outputFormat,
      Verbose->verbose
    ],
    "ValidAnalyzeEpitopeBinningQ"
  ]
];






(* ::Subsection:: *)
(* AnalyzeEpitopeBinningOptions*)

(* ---------------------------------- *)
(* -- AnalyzeEpitopeBinningOptions -- *)
(* ---------------------------------- *)

DefineOptions[AnalyzeEpitopeBinningOptions,
  SharedOptions :> {AnalyzeEpitopeBinning},
  {
    OptionName -> OutputFormat,
    Default -> Table,
    AllowNull -> False,
    Widget -> Widget[Type -> Enumeration, Pattern :> Alternatives[Table, List]],
    Description -> "Determines whether the function returns a table or a list of the options."
  }
];

AnalyzeEpitopeBinningOptions[
  myData:ObjectP[Object[Protocol,BioLayerInterferometry]]|{ObjectP[Object[Data,BioLayerInterferometry]]..},
  myOptions:OptionsPattern[]
]:= Module[
  {listedOptions,noOutputOptions,options},

  (* get the options as a list *)
  listedOptions=ToList[myOptions];

  (* Remove the Output and OutputFormat option before passing to the core function because it doesn't make sense here *)
  noOutputOptions=DeleteCases[listedOptions,Alternatives[Output->_,OutputFormat->_]];

  (* Get only the options for EpitopeBinning *)
  options=AnalyzeEpitopeBinning[myData,Append[noOutputOptions,Output->Options]];

  (* Return the option as a list or table *)
  If[MatchQ[Lookup[listedOptions,OutputFormat,Table],Table],
    LegacySLL`Private`optionsToTable[options,AnalyzeEpitopeBinning],
    options
  ]
];




(* ::Subsection:: *)
(* AnalyzeEpitopeBinningPreview*)


(* ---------------------------------- *)
(* -- AnalyzeEpitopeBinningPreview -- *)
(* ---------------------------------- *)

DefineOptions[AnalyzeEpitopeBinningPreview,
  SharedOptions :> {AnalyzeEpitopeBinning}
];


AnalyzeEpitopeBinningPreview[input:(ObjectP[Object[Protocol, BioLayerInterferometry]]|{ObjectP[Object[Data, BioLayerInterferometry]]}),ops:OptionsPattern[]]:=Module[
  {preview},

  preview = AnalyzeEpitopeBinning[input,Append[ToList[ops],Output->Preview]];

  If[MatchQ[preview, $Failed|Null],
    Null,
    preview
  ]
];


(* ::Subsection:: *)
(* EpitopeBinning Helper Functions *)

(* -------------------------- *)
(* -- findBinningBaselines -- *)
(* -------------------------- *)

(*
INPUTS:
  (1) the Data Object
  (2) the type of baseline we are looking for
  (3) the binning type
  (4) the cache to look up well info etc
*)

(*
METHOD:
- The baseline will differ based on teh BaselineType and the BinningType
- there is a lookup table for the pattern that we are looking for in well data
-
 *)

(* OUTPUT: a baseline for each measurment step in the data object *)

(* -- OVERLOAD --*)
findBinningBaseline[
  dataObjects:{ObjectP[Object[Data, BioLayerInterferometry]]..},
  baselineType:(Parallel|SelfBlocking|PreviousWell|None),
  binningType:(Tandem|PreMix|Sandwich),
  cache_
]:=Map[findBinningBaseline[#,baselineType, binningType, cache]&,dataObjects];

(* no baseline overload *)
findBinningBaseline[
  dataObject:ObjectP[Object[Data, BioLayerInterferometry]],
  None,
  binningType:(Tandem|PreMix|Sandwich),
  cache_
]:={};

(* -- CORE -- *)
findBinningBaseline[
  dataObject:ObjectP[Object[Data, BioLayerInterferometry]],
  baselineType:(Parallel|SelfBlocking|PreviousWell),
  binningType:(Tandem|PreMix|Sandwich),
  cache_
]:=Module[
  {
    dataPacket, measuredWellPositions, competitionData, competingSolutions, sampleIn, wellData, wellInformation, safeWellInformation,
    (* break out the measuredWellInfo *)
    assays, assaySteps, probeSets, channels, stepTypes, solutions, safeSolutions,
    (*determien other steps *)
    antibodyLoadingStep, antibodyLoadingBlank, antigenLoadingStep,
    requestedBaselinePattern, requestedBaselineIndex, rawBaselineData, refinedBaselineData
  },

  dataPacket = FirstCase[cache, KeyValuePattern[Object -> dataObject]];


  (* find the sample that is being competed against *)
  sampleIn = First[ToList[Lookup[dataPacket, SamplesIn]]][Object];
  {wellData, wellInformation, competitionData, measuredWellPositions} = Lookup[dataPacket, {WellData, WellInformation, CompetitionData, MeasuredWellPositions}];
  competingSolutions = Lookup[dataPacket, CompetingSolutions];

  (* look up the columns, assaysteps, assay, and channels of the measured positions {"Assay", "Assay Step", "Probe Set", "Channel", "Step Type", "Solution"}*)
  {assays, assaySteps, probeSets, channels, stepTypes, solutions} = Transpose[measuredWellPositions];
  safeSolutions = Download[solutions, Object];
  safeWellInformation = wellInformation/.{x:LinkP[]->Download[x,Object]};

  (* determine the loading step that is loading the sampleIn. This happens in all types. *)
  (* note that this step will appear several times. We only need to look at one *)
  antibodyLoadingStep = First[
    Select[
      wellInformation,
      And[
        MatchQ[#[[5]], LoadSurface],
        MatchQ[Last[#][Object], sampleIn]
      ]&
    ]
  ];

  (*TODO: Note if we dont return a valid baseline, this is because the user has messed up and the resolver will error when this guy returns Null*)
(* TODO: why is the a map thread? aren't we looking for a very specific value? *)
(* generate a pattern for the elements of WelInformation that are requested as baselines *)
  requestedBaselinePattern =
    Which[

      (* parallel is in the same assay/assayStep as the measurement but there should not be a sample there. The step type must be MeasureAssociation. *)
      MatchQ[baselineType, Parallel],
      MapThread[{#1, #2, _, _, MeasureAssociation, Except[Alternatives@@safeSolutions]}&,{assays, assaySteps}],

      (* previous well is always the assaystep prior to the one in which the sample is measured - it needs to be the correct channel. Note that all the channels are the same so first is ok *)
      MatchQ[baselineType, PreviousWell],
      MapThread[{#1,Subtract[#2,1],_,#3, MeasureBaseline, _}&, {assays, assaySteps, channels}],

      (* self blocking wells always have the same channel and assay number, as they do assay number since binning is done in a square setup. They will aslo have step type MA and the correct solution *)
      MatchQ[baselineType, SelfBlocking],
      MapThread[{#1,_,_,#1,MeasureAssociation, #2}&, {assays, safeSolutions}]
  ];

  (* the baselines are: either a parallel blank *)
  requestedBaselineIndex = Map[Position[safeWellInformation, #]&,requestedBaselinePattern];

  (* grab the requested elements from the wellData *)
  rawBaselineData = Map[Last[Part[wellData, Flatten[#]]/.{}->{Null}]&,requestedBaselineIndex];

  (* refine baseline data  - either smooth it out to reduce noise or transform it if it was not in parallel (time is different) *)
  refinedBaselineData = If[MatchQ[rawBaselineData, {Null..}],

    (* if we didnt find a baseline return Null *)
    Null,

    (* if we did, refine it to be useful *)
    Which[

      MatchQ[baselineType, (Parallel|SelfBlocking)],
      Module[{yvals, xvals, updatedyvals},
        yvals = Unitless[rawBaselineData[[All,All,2]]];
        xvals = Unitless[rawBaselineData[[All,All,1]]];

        (*apply pretty agressive smoothing to prevent making data extra noisy - MeanFilter is listable btw*)
        updatedyvals = MeanFilter[yvals, 20];

        (* reconstruct the QA *)
        MapThread[QuantityArray[Transpose[{#1,#2}], {Second, Nanometer}]&, {xvals, updatedyvals}]
      ],

      MatchQ[baselineType, PreviousWell],
      Module[{linearFits, minTimes, maxTimes, unitlessData},

        (* get linear fits for the baselines to compensate drift *)
        linearFits = Map[LinearModelFit[Unitless[#], x, x]&, rawBaselineData];

        (* look up the min and max times of each step so we can create our baseline *)
        {minTimes, maxTimes} = {Unitless[competitionData][[All,1,1]], Unitless[competitionData][[All,-1,1]]};

        (* generate the new baselines *)
        unitlessData = MapThread[Table[{time, #1[time]}, {time, #2, #3}]&, {linearFits, minTimes, maxTimes}];

        (* output the quantity arrays *)
        QuantityArray[#, {Second, Nanometer}]&/@unitlessData
      ],

      MatchQ[baselineType, Null],
      Null
    ]
  ]
];


(* ---------------------------------- *)
(* -- findBinningNormalizationData -- *)
(* ---------------------------------- *)

(* TODO: a helper to identify the requested normalization element *)

(* -- OVERLOAD --*)
findBinningNormalizationData[
  dataObjects:{ObjectP[Object[Data, BioLayerInterferometry]]..},
  normalizationMethod:(None|IsolatedAntibody|LoadingCapacity),
  binningType:(Tandem|PreMix|Sandwich),
  cache_
]:=Map[findBinningNormalizationData[#,normalizationMethod, binningType, cache]&, dataObjects];

(* no normalization overload *)
findBinningNormalizationData[
  dataObject:ObjectP[Object[Data, BioLayerInterferometry]],
  None,
  binningType:(Tandem|PreMix|Sandwich),
  cache_
]:={};

(* -- CORE -- *)
findBinningNormalizationData[
  dataObject:ObjectP[Object[Data, BioLayerInterferometry]],
  normalizationMethod:(IsolatedAntibody|LoadingCapacity),
  binningType:(Tandem|PreMix|Sandwich),
  cache_
]:=Module[
  {
    measuredWellPositions, competitionData, competingSolutions, sampleIn, wellData, wellInformation, safeWellInformation,
    (* break out the measuredWellInfo *)
    assays, assaySteps, probeSets, channels, stepTypes, solutions, safeSolutions,
    (*determine other steps *)
    patternToMatch, potentialNormalizationIndices, rawNormalizationData
  },

  (* find the sample that is being competed against *)
  sampleIn = First[ToList[Download[dataObject, SamplesIn, Cache -> cache]]][Object];

  (*download the other fiesld we are going ot use *)
  {
    wellData,
    wellInformation,
    competitionData,
    measuredWellPositions,
    competingSolutions
  } = Download[dataObject,
    {
      WellData,
      WellInformation,
      CompetitionData,
      MeasuredWellPositions,
      CompetingSolutions
    },
    Cache -> cache,
    Date->Now
  ];

  (* look up the columns, assaysteps, assay, and channels of the measured positions {"Assay", "Assay Step", "Probe Set", "Channel", "Step Type", "Solution"}*)
  {assays, assaySteps, probeSets, channels, stepTypes, solutions} = Transpose[measuredWellPositions];
  (* remove links where needed *)
  safeSolutions = Download[solutions, Object];
  safeWellInformation = wellInformation/.{x:LinkP[]->Download[x,Object]};

  (* generate a pattern to match based on the normalizationMethod *)
  patternToMatch = If[MatchQ[normalizationMethod, IsolatedAntibody],

    (* we are looking for a parallel well that did not get loaded with antibody earlier - it will need to be on a channel higher than the number of solutions being tested *)
    MapThread[{_, #1, _, GreaterP[Length[safeSolutions]], MeasureAssociation, #2}&,{assaySteps, safeSolutions}],

    (* for LoadingCapacity we just need to pull the loading step. If we search alternatives they will come out ordered by channel, which is the same ordering as the assay *)
    (* note that we are just going to take the first loading step since there will be many of these. *)
    {1,_,_,_,LoadSurface,#}&/@safeSolutions
  ];

  (* get teh positions out  *)
  potentialNormalizationIndices = Position[safeWellInformation, #]&/@patternToMatch;

  (* for each step, lookup the data element by index. Part always returns a list, take the last element. Note that if every sensor is loaded with antigen, the list will be empty but we would like it to return Null*)
  rawNormalizationData = Map[
    Last[Part[wellData, Flatten[#]]/.{}->{Null}]&,
    potentialNormalizationIndices
  ]
];
