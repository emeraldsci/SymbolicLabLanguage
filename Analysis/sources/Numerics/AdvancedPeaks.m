(* ::Package:: *)

(* ::Text:: *)
(*\[Copyright] 2011-2023 Emerald Cloud Lab, Inc.*)


(* ::Section:: *)
(*Source Code*)


(* ::Subsection:: *)
(*AdvancedAnalyzePeaks*)


(* ::Subsubsection:: *)
(*Options*)


Error::InvalidManualPeaks = "Option value `1` for ManualPeaks contains overlapping spans. Please ensure that none of the ranges in this option specification overlap.";

(* ---------------------- *)
(* --- DEFINE OPTIONS --- *)
(* ---------------------- *)



DefineOptions[AdvancedAnalyzePeaks,
	Options :> {
			{
				OptionName -> ReferenceField,
				Default -> Automatic,
				Description -> "Specify which field in data object will be analyzed for peaks.",
				AllowNull -> True,
				Category -> "General",
				Widget -> With[
					{
						referenceFieldP=Alternatives[
							(* 2D Fields *)
							AbsorbanceSpectrum,Chromatogram,SecondaryChromatogram,
							Absorbance,SecondaryAbsorbance,Conductance,Scattering,
							Fluorescence,SecondaryFluorescence,TertiaryFluorescence,QuaternaryFluorescence,
							Conductance,ConductivityFlowCellTemperature,pH,pHFlowCellTemperature,
							MultiAngleLightScattering22Degree,MultiAngleLightScattering28Degree,MultiAngleLightScattering32Degree,MultiAngleLightScattering38Degree,
							MultiAngleLightScattering44Degree,MultiAngleLightScattering50Degree,MultiAngleLightScattering57Degree,MultiAngleLightScattering64Degree,
							MultiAngleLightScattering72Degree,MultiAngleLightScattering81Degree,MultiAngleLightScattering90Degree,MultiAngleLightScattering99Degree,
							MultiAngleLightScattering108Degree,MultiAngleLightScattering117Degree,MultiAngleLightScattering126Degree,MultiAngleLightScattering134Degree,
							MultiAngleLightScattering141Degree,MultiAngleLightScattering147Degree,
							DynamicLightScattering,RefractiveIndex,ExcitationSpectrum,EmissionSpectrum,
							Intensity,MassSpectrum,NMRSpectrum,OptimalLaneImage,OptimalLaneIntensity,
							LowExposureLaneIntensity,MediumLowExposureLaneIntensity,MediumHighExposureLaneIntensity,HighExposureLaneIntensity,
							LowExposureLadderIntensity,MediumLowExposureLadderIntensity,MediumHighExposureLadderIntensity,HighExposureLadderIntensity,
							LowExposureGelImage,MediumLowExposureGelImage,MediumHighExposureGelImage,HighExposureGelImage,
							LowExposureGelImageFile,MediumLowExposureGelImageFile,MediumHighExposureGelImageFile,HighExposureGelImageFile,
							LaneImage,BlankedDiffractionPattern,SampleElectropherogram,MarkerElectropherogram,
							PostSelectionElectropherogram,HeatingCurves,MolarHeatingCurves,FIDResponse,Charge,
							InitialIntensityDistribution,InitialMassDistribution,FinalIntensityDistribution,FinalMassDistribution,
							AbsorbanceSpectrum,AbsorbanceDifferenceSpectrum,CircularDichroismAbsorbanceSpectrum,CircularDichroismSpectrum,
							UnblankedAbsorbanceSpectrum,UnblankedAbsorbanceDifferenceSpectrum,UnblankedCircularDichroismAbsorbanceSpectrum,
							IntensityDistribution,MassDistribution,IonAbundance,ProcessedUVAbsorbanceData,RelativeMigrationData,
							(* 3D Fields *)
							Absorbance3D,Chromatogram3D,IonAbundance3D
						]
					},
					Alternatives[
						Widget[Type->Enumeration,Pattern:>referenceFieldP],
						Adder[Widget[Type->Enumeration,Pattern:>referenceFieldP]]
					]
				]
			},
			{
				OptionName -> DataSetTransformationFunction,
				Default -> Null,
				Description -> "A pure function or quantity function which will be mapped over the resolved raw input data prior to peak-picking.",
				AllowNull -> True,
				Category -> "General",
				Widget -> Alternatives[
					"Scale"->Widget[Type->Enumeration,Pattern:>LogLinear|LinearLog|LogLog],
					"f[{x,y}]"->Widget[Type->Expression,Pattern:>_Function|_QuantityFunction,Size->Line,PatternTooltip->"A pure function of the form f[{x,y}]->{x2,y2}."],
					"f[x],g[y]"->{
						"X transform"->Alternatives[
							"Function"->Widget[Type->Expression,Pattern:>_Function|_QuantityFunction,Size->Line,PatternTooltip->"A pure function of the form f[x]->x2."],
							Widget[Type->Enumeration,Pattern:>Alternatives[None]]
						],
						"Y transform"->Alternatives[
							"Function"->Widget[Type->Expression,Pattern:>_Function|_QuantityFunction,Size->Line,PatternTooltip->"A pure function of the form f[y]->y2."],
							Widget[Type->Enumeration,Pattern:>Alternatives[None]]
						]
					}
				]
			},
			{
				OptionName -> Wavelength,
				Default -> Automatic,
				Description -> "Specify which slice of data to look at when working with 3D Chromatography data. Automatic will default to the minimum wavelength.",
				AllowNull -> True,
				Category -> "Data Slicing",
				Widget -> Widget[Type -> Quantity, Pattern :> GreaterEqualP[0 Nanometer, Nanometer], Units -> Alternatives[Nanometer]]
			},
			{
				OptionName -> Name,
				Default -> Null,
				Description -> "Name to be used for the Object[Analysis, Peaks] generated by this analysis.",
				AllowNull -> True,
				Category -> "General",
				Widget -> Widget[Type->String,Pattern:>_String, Size -> Line]
			},
		
			{
				OptionName -> DataSliceDimension,
				Default -> Automatic,
				Description -> "Specify which dimension(s) of 3+ dimensional input data should be held constant to produce two-dimensional slice(s) for peak-picking.",
				ResolutionDescription -> "Given 3+ dimensional input data, the default slice dimension(s) will be determined based on the input data type and the ReferenceField option. For 2D input data, this option defaults to Null.",
				AllowNull -> True,
				Category -> "Data Slicing",

				Widget -> Alternatives[
					Adder[Alternatives[Widget[Type->Enumeration, Pattern:>Alternatives[ElutionTime,MassToChargeRatio,Wavelength]],
						"Index"->Widget[Type->Number,Pattern:>GreaterP[0,1]]]],
					Widget[Type->Enumeration,	Pattern:>Alternatives[ElutionTime,MassToChargeRatio,Wavelength]],
					"Index"->Widget[Type->Number,Pattern:>GreaterP[0,1]]]

			},
			{
				OptionName -> DataSlice,
				Default -> Automatic,
				Description -> "For each member of DataSliceDimension, a single value or range of values over which the input data should be sliced to produce two-dimensional {x,y} data for peak picking.",
				ResolutionDescription -> "Given 3+ dimensional input data, the default slice will be determined based on the input data type and the ReferenceField option. For 2D input data, this option defaults to Null.",
				AllowNull -> True,
				Category -> "Data Slicing",
				Widget->Alternatives[
					"Single Value"->Widget[Type->Expression, Pattern:>UnitsP[], Size->Word],
					"Range"->Widget[Type -> Expression, Pattern :> Alternatives[UnitsP[];;UnitsP[], {UnitsP[];;UnitsP[]..}], Size -> Line]
				]
			},
			{
				OptionName -> SliceReductionFunction,
				Default -> Automatic,
				Description -> "For each member of DataSliceDimension, determines how the DataSlice should be flattened along that dimension if data is sliced over a range of values.",
				ResolutionDescription->"Given 3+ dimensional input data, defaults to Mean. For 2D input data, this option defaults to Null.",
				AllowNull -> True,
				Category -> "Data Slicing",
				Widget ->
					Alternatives[
						Widget[Type->Enumeration, Pattern:>Alternatives[Total,Mean,Max,Min]],
						Adder[Widget[Type->Enumeration, Pattern:>Alternatives[Total,Mean,Max,Min]]]
					]
			},
			{
				OptionName -> SliceReferencePeaks,
				Default -> Automatic,
				Description -> "A peaks analysis object which will be used as reference for slicing 3+ dimensional data. Peak positions will be used to set the default values for the DataSliceDimension and DataSlice options.",
				ResolutionDescription -> "Given 3+ dimensional input data, defaults to None. For 2D input data, this option defaults to Null.",
				AllowNull->True,
				Category -> "Data Slicing",
				Widget -> Alternatives[
					Widget[Type->Enumeration, Pattern:>Alternatives[None]],
					Widget[Type->Object, Pattern:>ObjectP[Object[Analysis,Peaks]]]
				]
			},
			
			{
				OptionName -> PeakThresholds,
				Default -> {},
				Description -> "Specify threshold regions for peak searching, in the form of { {xL, xR}, y}. ",
				AllowNull -> True,
				Category -> "Method",
				Widget -> Alternatives[
					Adder[{
						"Domain" -> Widget[Type->Expression, Size->Line, Pattern:>{_?NumericQ,_?NumericQ}],
						"Height" -> Widget[Type->Number, Pattern:>RangeP[-Infinity, Infinity]]
					}],
					Widget[Type -> Enumeration, Pattern :> Alternatives[{}]]
				]
			},
			{
				OptionName -> UnknownPeakThresholds,
				Default -> {},
				Description -> "Specify threshold regions for peak searching, in the form of { {xL, xR}, y}. ",
				AllowNull -> True,
				Category -> "Method",
				Widget -> Alternatives[
					Adder[{
						"Domain" -> Widget[Type->Expression, Size->Line, Pattern:>{_?NumericQ,_?NumericQ}],
						"Height" -> Widget[Type->Number, Pattern:>RangeP[-Infinity, Infinity]]
					}],
					Widget[Type -> Enumeration, Pattern :> Alternatives[{}]]
				]
			},
			{
				OptionName -> ManualPeaks,
				Default -> {},
				Description -> "Specify the exact location of peaks, in the form of { {xL,yL}, {xR,yR} }.",
				AllowNull -> True,
				Category -> "Method",
				Widget -> Alternatives[
					Adder[{
						"Left" -> Widget[Type->Expression, Size->Line, Pattern:>{_?NumericQ,_?NumericQ}],
						"Right" -> Widget[Type->Expression, Size->Line, Pattern:>{_?NumericQ,_?NumericQ}]
					}],
					Widget[Type -> Enumeration, Pattern :> Alternatives[{}]]
				]
			},
			{
				(* TODO: add Assignment into here *)
				OptionName -> ExpectedPeaks,
				Default -> {},
				Description -> "Specify the name and location of expected peaks.",
				AllowNull -> True,
				Category -> "Method",
				Widget -> Alternatives[
					Adder[{
						"Name" -> Widget[Type->String, Size->Word, Pattern:>_String],
						"ApexPosition" -> Widget[Type->Number, Pattern:>RangeP[-Infinity,Infinity]],
						"ApexDomain" -> Widget[Type->Expression, Size->Word, Pattern:>{_?NumericQ,_?NumericQ}]
					}],
					Widget[Type -> Enumeration, Pattern :> Alternatives[{}]]
				]
			},
		AnalysisPreviewSymbolOption,
		AnalysisTemplateOption,
		OutputOption,
		UploadOption,
		{OptionName -> PeakLabels,Default -> Null,AllowNull->True,Description -> "", Category->"Hidden", Pattern -> _},
		{OptionName -> PeakAssignments,Default -> Null,AllowNull->True,Description -> "",Category->"Hidden",Pattern -> 	_ },
		{OptionName -> ParentPeaks,Default -> Null, AllowNull->True,Description -> "",Category->"Hidden",Pattern -> _}
	}
];

(* ::Subsubsection::Closed:: *)

(* -------------------------- *)
(* --- PROTOCOL OVERLOAD  --- *)
(* -------------------------- *)
AdvancedAnalyzePeaks[in:ObjectP[peakProtocolTypes],ops:OptionsPattern[AdvancedAnalyzePeaks]]:=Module[
	{listedInputs},

	(* Protocol input resolution returns a list of peaks data objects taken from the protocol *)
	listedInputs=resolveAnalyzePeaksListInput[in];

	(* Conduct peak-picking analysis on each input data object *)
	AdvancedAnalyzePeaks[listedInputs, ops]
];


(* -------------------------- *)
(* --- MAIN FUNCTION BODY --- *)
(* -------------------------- *)
AdvancedAnalyzePeaks[in:ListableP[inputAnalyzePeaksP],ops:OptionsPattern[AdvancedAnalyzePeaks]]:=Module[
	{
		listedData,objListedData,listedOptions,rulesRequiringUnnecessaryList,analysisPacketStart,outputSpecification,output,gatherTests,
		safeOptions,safeOptionTests,rawTemplateOptions,templateTests,templateOptions,combinedOptions,
		resolvedInputsResult,validLengths,validLengthTests, dataTypes,
		refField,xyUnits,rawData,wavelength,slicingOps,image,inputWLTests,samples,
		mostlyResolvedOptionsResult,mostlyResolvedOptions,mostlyResolvedOptionsTests,templateAlignmentRules,
		rawDataExpanded,listedDataExpanded,samplesExpanded,imagesExpanded,xyUnitsExpanded,
		findPeaksResult,peakFieldList,baselineFunctionList,
		resolvedOptions,resolvedOptionsTests, baselineRangesList,
		peakPackets,previewRule,optionsRule,testsRule,resultRule, opsIn,
		thresholds, dids, pippy, manualPeaks, thresholdsUnknown, expectedPeaks
	},

	(* Ensure that inputs are in a list. If "in" is a singular list-like input, such as CoordinatesP, manually wrap it in a list. *)
	listedData=If[MatchQ[in,peakRawDataTypes],
		{in},
		ToList[in]
	];

	(* Replace list-like raw inputs with dummy objects, because list-like inputs will cause ValidInputLengthsQ and ApplyTemplateOptions to error *)
	objListedData=Replace[listedData,peakRawDataTypes->Object[Data,Chromatography,""],1];

	(* Ensure that options are in a list *)
	opsIn=ToList[ops];

	(* Gentle warning if DataSlice is in deprecated form *)
	listedOptions=If[MatchQ[Lookup[opsIn,DataSlice],{{_,_}..}],
		Message[Warning::DeprecatedDataSlicePattern,Lookup[opsIn,DataSlice]];
		(* Automatically convert it into span *)
		opsIn/.Lookup[opsIn,DataSlice]:>(Lookup[opsIn,DataSlice]/.{{a_,b_}}:>a;;b),
		opsIn
	];

	(*
		As part of removing unnecessarily listedness, we now restore the missing outer List that
		the internals of AdvancedAnalyzePeaks is expecting for these options.
	*)
	(*  1. These user-supplied options require an outer pair of { } for internals of Analyze Peaks to work *)
	rulesRequiringUnnecessaryList=FilterRules[listedOptions,
		{DataSliceDimension, DataSlice, SliceReductionFunction}
	];
	(*  2.
		MapAt: Apply ECL`ToList to each OptionValue supplied (restoring the outer '{ }' if needed)
		Join, DeleteDuplicatesBy:  Then merge them in with the remaining user-supplied options
	*)
	listedOptions=DeleteDuplicatesBy[
		Join[
			If[rulesRequiringUnnecessaryList=!={}
				,MapAt[ToList,rulesRequiringUnnecessaryList,{All,2}]
				,{}]
			,listedOptions]
		,First];

	(* Create an analysis packet with Author, DateCreated, and UnresolvedOptions populated *)
	analysisPacketStart=analysisPacketStandardFieldsStart[listedOptions];

	(* Throw a warning message if the inputs or options contain any temporal links *)
	checkTemporalLinks[listedData,listedOptions];

	(* Determine the requested return value from the function *)
	outputSpecification=OptionValue[Output];
	output=ToList[OptionValue[Output]];

	(* Determine if we should keep a running list of tests *)
	gatherTests=MemberQ[output,Tests];

	(* Call SafeOptions to make sure all options match pattern *)
	{safeOptions,safeOptionTests}=If[gatherTests,
		SafeOptions[AdvancedAnalyzePeaks,listedOptions,AutoCorrect->False,Output->{Result,Tests}],
		{SafeOptions[AdvancedAnalyzePeaks,listedOptions,AutoCorrect->False],Null}
	];

	(* If the specified options don't match their patterns return $Failed *)
	If[MatchQ[safeOptions,$Failed],
		Return[outputSpecification/.{
			Result->$Failed,
			Tests->safeOptionTests,
			Options->$Failed,
			Preview->Null
		}]
	];

	(* Use any template options to get values for options not specified in myOptions *)
	{rawTemplateOptions,templateTests}=If[gatherTests,
		ApplyTemplateOptions[AdvancedAnalyzePeaks,{objListedData},listedOptions,Output->{Result,Tests}],
		{ApplyTemplateOptions[AdvancedAnalyzePeaks,{objListedData},listedOptions],Null}
	];

	(* Replace template PeakLabels option with user-supplied PeakLabels option, because we don't want to copy the template directly *)
	templateOptions=ReplaceRule[rawTemplateOptions,ExtractRule[safeOptions,PeakLabels]];

	(* Combine safe options with templated options, preserving the original PeakLabels options *)
	combinedOptions=ReplaceRule[safeOptions,templateOptions];

	(* Resolve inputs, storing reference field, physical units, raw xy data, and other fields *)
	resolvedInputsResult=Check[
		{refField,xyUnits,rawData,samples,wavelength,slicingOps,image,inputWLTests}=resolveAnalyzePeaksInputs[listedData,combinedOptions,gatherTests],
		$Failed,
		{Error::InvalidInput,Error::InvalidOption}
	];

	(* Hard fail if the inputs could not be resolved *)
	If[MatchQ[resolvedInputsResult,$Failed],
		Return[outputSpecification/.{
			Result->$Failed,
			Tests->Join[safeOptionTests,inputWLTests],
			Options->combinedOptions,
			Preview->Null
		}]
	];

	(* Ensure all options are the correct length. Silence missing option errors. *)
	{validLengths,validLengthTests}=Quiet[
		If[gatherTests,
			ValidInputLengthsQ[AdvancedAnalyzePeaks,{objListedData},DeleteCases[listedOptions,Alternatives[DataSlice->_]],Output->{Result,Tests}],
			{ValidInputLengthsQ[AdvancedAnalyzePeaks,{objListedData},DeleteCases[listedOptions,Alternatives[DataSlice->_]]],Null}
		],
		Warning::IndexMatchingOptionMissing
	];

	(* If option lengths are invalid, return $Failed *)
	If[!validLengths,
		Return[outputSpecification/.{
			Result -> $Failed,
			Tests -> Join[safeOptionTests,validLengthTests],
			Options -> $Failed,
			Preview -> Null
		}]
	];

	(* Resolve all options which do not require identification of peaks, checking for invalid inputs and options *)
	mostlyResolvedOptionsResult=Check[
		{mostlyResolvedOptions,mostlyResolvedOptionsTests}=If[gatherTests,
			resolveAdvancedAnalyzePeaksOptions[rawData,listedData,xyUnits,refField,wavelength,slicingOps,combinedOptions,safeOptions,Output->{Result,Tests}],
			{resolveAdvancedAnalyzePeaksOptions[rawData,listedData,xyUnits,refField,wavelength,slicingOps,combinedOptions,safeOptions],Null}
		],
		$Failed,
		{Error::InvalidInput,Error::InvalidOption}
	];

	(* If the specified options don't match their patterns or if option lengths are invalid return $Failed *)
	If[MatchQ[mostlyResolvedOptionsResult,$Failed],
		Return[outputSpecification/.{
			Result->$Failed,
			Tests->Join[safeOptionTests,validLengthTests,mostlyResolvedOptionsTests],
			Options->combinedOptions,
			Preview->Null
		}]
	];



	
	(* Expand fields to account for multiple reference fields for a single object *)
	{rawDataExpanded,listedDataExpanded,samplesExpanded,imagesExpanded,xyUnitsExpanded}=Transpose@MapThread[
		If[MatchQ[#1,{CoordinatesP..}],
			Sequence@@Transpose[{#1,Repeat[#2,Length[#1]],#3,Repeat[#4,Length[#1]],#5}],
			{#1,#2,#3,#4,#5}
		]&,
		{rawData,listedData,samples,image,xyUnits}
	];

	(* set up pippy session -- even if not using the preview app *)
	pippy = Pippy`Private`PeakPicking[];
	$Pippy = pippy;
	
	dids = Pippy`Private`AddDataset[pippy, rawDataExpanded];

	thresholds = Lookup[combinedOptions, PeakThresholds];
	Map[Pippy`Private`DefineMethod[pippy, <|"Method"->"Threshold","ThresholdDomain" -> #[[1]], "ThresholdHeight" -> #[[2]]|>]&, thresholds];

	manualPeaks = Lookup[combinedOptions, ManualPeaks];
	Map[Pippy`Private`DefineMethod[pippy, <|"Method"->"Manual","Boundary" -> {#[[1,1]],#[[2,1]]}, "Baseline" -> {#[[1,2]],#[[2,2]]}|>]&, manualPeaks];

	thresholdsUnknown = Lookup[combinedOptions, UnknownPeakThresholds];
	Map[Pippy`Private`DefineMethod[pippy, <|"Method"->"Unknown","ThresholdDomain" -> First[#], "ThresholdHeight" -> Last[#]|>]&, thresholdsUnknown];

	expectedPeaks = Lookup[combinedOptions, ExpectedPeaks];
	Map[	
		With[
			{labObj = If[MatchQ[#[[1]],ObjectP[]], {Download[#[[1]],Name],#[[1]]}, {#[[1]],Null}]},
			Pippy`Private`DefineLabelingRule[pippy, <|"Label" -> labObj[[1]], "Assignment" -> labObj[[2]], "ApexPosition"-> #[[2]], "ApexDomain" -> #[[3]], "SourcePeakID" -> Null|>]
		]&, 
		expectedPeaks
	];
	

	(* Compute peak fields (position, height, area, etc.) and baseline functions for each input *)
	findPeaksResult=Check[
		{peakFieldList,baselineFunctionList, baselineRangesList}=Transpose@MapThread[
			findPeaksAdvanced[#1,#2, #3, pippy]&,
			{rawDataExpanded,mostlyResolvedOptions, dids}
		],
		$Failed,
		{Error::InvalidInput,Error::InvalidOption}
	];
	

	(* Resolve the options which depend on peaks identified by findPeaks *)
	{resolvedOptions,resolvedOptionsTests}=Transpose@MapThread[
		resolveRemainingOptionsSingle[#1,#2,#3,combinedOptions]&,
		{mostlyResolvedOptions,peakFieldList,baselineFunctionList}
	];

	(* Construct peaks packets from the computed peak fields and options *)
	peakPackets=If[MatchQ[mostlyResolvedOptionsResult,$Failed]||MatchQ[findPeaksResult,$Failed],
		$Failed,
		MapThread[
			formatPeakPacketAdvanced[#1,#2,#3,analysisPacketStart,#4,#5,#6, #7]&,
			{listedDataExpanded,peakFieldList,baselineFunctionList,resolvedOptions,samplesExpanded,Range[Length[listedDataExpanded]], rawDataExpanded}
		]
	];

	resolvedOptions = Lookup[peakPackets,ResolvedOptions];

	(*
	  PeakAssignment field looks like this:
	     {{}, Link[Model[Molecule,id:vXl9j57PmP5D]],{}}
	  But this does not satisfy storage pattern.

	  So now we turn it into
	     {Null, Link[Model[Molecule,id:vXl9j57PmP5D]],Null}
	  which does
	*)
	peakPackets = MapThread[
		<|#1, Replace[PeakAssignment] -> #2|>&,
		{peakPackets, Lookup[peakPackets, Replace[PeakAssignment]] /. Rule[{}, Null]}
	];


	(* Prepare the Preview result if we were asked to do so *)
	previewRule=Preview->If[MemberQ[output,Preview]&&!MatchQ[peakPackets,$Failed],

		dataTypes = If[MatchQ[#,ObjectP[]],#[Type], Null]& /@ listedDataExpanded;

		If[newInteractivePreviewSupported[dataTypes],

			(*New Preview graphic*)
			Module[{xyDataSets, compositionList, unitBlock, rOps},
				xyDataSets = Sort /@ rawDataExpanded;
				compositionList = getModelMoleculesForFEFromData[First[listedDataExpanded]];
				unitBlock = Replace[First[xyUnitsExpanded], Quantity[_, unitBlock_] :> unitBlock, {1}];
				rOps = First[resolvedOptions];
				makeNewAdvancedPeaksPreview[pippy, rOps, xyDataSets, unitBlock, compositionList]
			],
			
			Message["Should redirect to AnalyzePeaks before this point"];
		],
		Null
	];

	(* Prepare the Options result if we were asked to do so *)
	optionsRule=Options->If[MemberQ[output,Options],
		RemoveHiddenOptions[AdvancedAnalyzePeaks,
			Map[
				(* Use ToExpression to convert strings into symbols *)
				collapsePeaksOption[ToExpression[#],ToExpression[#]/.resolvedOptions]&,
				(* List of all options, as strings, without their values *)
				First/@Options[AdvancedAnalyzePeaks]
			]
		],
		Null
	];

	(* Prepare the Tests result if we were asked to do so *)
	testsRule=Tests->If[MemberQ[output,Tests],
		Join[
			safeOptionTests,
			templateTests,
			mostlyResolvedOptionsTests,
			Flatten[resolvedOptionsTests],
			Flatten[validLengthTests],
			Flatten[inputWLTests]
		],
		Null
	];

	(* Prepare standard output if we were asked to do so *)
	resultRule=Result->Which[
		(* If Result was not requested in Output option, set Result->Null *)
		Not[MemberQ[output,Result]],
		Null,

		(* Result was requested but peak-picking analysis failed *)
		MatchQ[mostlyResolvedOptionsResult,$Failed]||MatchQ[findPeaksResult,$Failed],
		$Failed,

		(* Format the output based on options *)
		MemberQ[output,Result],
		With[
			(* Check the Upload option for each input to determine if it should be uploaded *)
			{
				output=MapThread[analyzePeaksResult[#1,#2,#3,#4,#5]&,
					{
						PadRight[listedData,Length[peakPackets]],
						PadRight[rawData,Length[peakPackets]],
						PadRight[xyUnits,Length[peakPackets]],
						peakPackets,
						resolvedOptions
					}
				]
			},

			(* If a single dataset was provided, de-list the output *)
			If[MatchQ[in,inputAnalyzePeaksP]&&Length[output]==1,First[output],output]
		]
	];

	(* Return the specified outputs *)
	outputSpecification/.{previewRule,optionsRule,testsRule,resultRule}
];



(* Identify peaks, compute peak fields, and then compute derived quantities using peak fields. *)
findPeaksAdvanced[xy_, resolvedOps_, dataID_, pippy_] := Module[
	{
		peakCoreFields,baselineFunction,peakCoreNoDuplicates,correctedPeakCoreFields,peakAllFields, baselineRanges
	},

	(* Fit a baseline, then identify peaks. For each peak, compute fields like position, height, area, width ranges, tangents, etc... *)
	{peakCoreFields,baselineFunction, baselineRanges}=computePeaksFieldsAdvanced[pippy, dataID];

	(* Delete any peaks which have been doubly specified, i.e., have overlapping ranges *)
	peakCoreNoDuplicates=deletePeakDuplicates[peakCoreFields];

	(* If tangents have not been calculated, ensure that tangent fields are populated with empty lists *)
	correctedPeakCoreFields=If[MemberQ[Lookup[peakCoreNoDuplicates,TangentWidth],Null],
		ReplaceRule[peakCoreNoDuplicates,{TangentWidth->{},TangentWidthLines->{},TangentWidthLineRanges->{}}],
		peakCoreNoDuplicates
	];

	peakAllFields=correctedPeakCoreFields;

	{peakAllFields,baselineFunction, baselineRanges}
];

newInteractivePreviewSupported[{
	Repeated[Null]
		| Repeated[Object[Data, Chromatography]]
		| Repeated[Object[Data, AbsorbanceSpectroscopy]]
		| Repeated[Object[Data, CapillaryIsoelectricFocusing]]
		| Repeated[Object[Data, MassSpectrometry]]
		| Repeated[Object[Data, CapillaryGelElectrophoresisSDS]]
		| Repeated[Object[Data, IRSpectroscopy]]
		| Repeated[Object[Data, DynamicLightScattering]]
		| Repeated[Object[Data, ChromatographyMassSpectra]]
		| Repeated[Object[Data, MeltingCurve]]
		| Repeated[Object[Data, XRayDiffraction]]
		| Repeated[Object[Data, PAGE]]
}] := True;
newInteractivePreviewSupported[_] := False;

makeNewAdvancedPeaksPreview[pippy_, rOps_, xyDataSets_, unitBlock_, compositionList_] := Module[{},
	analyzePeaks$dvar=SetupPreviewSymbol[
		AdvancedAnalyzePeaks,
		Null,
		FilterRules[rOps,{
			ManualPeaks, PeakThresholds, UnknownPeakThresholds,	ExpectedPeaks
		}],
		PreviewSymbol->Null
	];

	analyzePeaks$dvar["FEOptionsPacket"] = Unique["feOptionsPacket"];

	With[
		{dv=analyzePeaks$dvar},
		{symb = dv["FEOptionsPacket"]},
		symb = optsToFEPacket[pippy];

		DynamicModule[{SciCompFramework`Private`advancedPeaksToolbar$$, Analysis`Private`advancedPeakTable$$},
			Grid[{{Dynamic[RawBoxes[SciCompFramework`Private`advancedPeaksToolbar$$]], SpanFromLeft},{
				Deploy[SciCompFramework`Private`InteractivePlot[
					(*Data packets*)
					<|
						"PrimaryData" -> {
							SciCompFramework`Private`ListLineData[xyDataSets,
								SciCompFramework`Private`PeaksAppLayer[
									Function[syncPeakWidgets[pippy, dv]],
									pippy,
									compositionList
								]
							]}
					|>,

					(*InteractivePlot options*)
					FrameLabel -> {None, None},
					"Units" -> unitBlock,
					(*Todo: Ask brad how to set a good zoom limit in y-direction*)
					"MinPlotRange" -> {Automatic, Scaled[0.0001]},
					ContentSize -> {Full, 300},
					BaselinePosition -> Bottom
				]],

				(*PeaksTable*)
				Dynamic[RawBoxes[Analysis`Private`advancedPeakTable$$]]
			}},
				ItemSize -> {{Scaled[0.5], Scaled[0.5]}, Automatic},
				Alignment -> {Left, Baseline}
			]
		]
	]
];


(* ::Subsection::Closed:: *)
(*AdvancedAnalyzePeaksOptions*)


DefineOptions[AdvancedAnalyzePeaksOptions,
	SharedOptions :> {AdvancedAnalyzePeaks},
	{
		OptionName -> OutputFormat,
		Default -> Table,
		AllowNull -> False,
		Widget -> Widget[Type->Enumeration, Pattern:>Alternatives[Table, List]],
		Description -> "Determines whether the function returns a table or a list of the options."
	}
];


AdvancedAnalyzePeaksOptions[in: ObjectP[peakProtocolTypes], ops: OptionsPattern[AdvancedAnalyzePeaksOptions]] := Module[
	{inList},
	inList = resolveAnalyzePeaksListInput[in];
	AdvancedAnalyzePeaksOptions[inList, ops]
];


AdvancedAnalyzePeaksOptions[in: ListableP[inputAnalyzePeaksP], ops: OptionsPattern[AdvancedAnalyzePeaksOptions]] := Module[
	{listedOptions, noOutputOptions, options},

	listedOptions = ToList[ops];

	(* remove the OutputFormat option before passing to the core function because it doesn't make sense here *)
	noOutputOptions = DeleteCases[listedOptions, Rule[OutputFormat,_]];

	(* return options from main function body *)
	options=AdvancedAnalyzePeaks[in,ReplaceRule[noOutputOptions,{Output->Options}]];

	(* Return the option as a list or table *)
	If[MatchQ[Lookup[listedOptions,OutputFormat,Table],Table] && !MatchQ[options, ListableP[$Failed]],
		LegacySLL`Private`optionsToTable[options,AdvancedAnalyzePeaks],
		options
	]
];


(* ::Subsection:: *)
(*AdvancedAnalyzePeaksPreview*)


DefineOptions[AdvancedAnalyzePeaksPreview,
	SharedOptions :> {AdvancedAnalyzePeaks}
];


AdvancedAnalyzePeaksPreview[in: ObjectP[peakProtocolTypes], ops: OptionsPattern[AdvancedAnalyzePeaksPreview]] := Module[
	{inList},
	inList = resolveAnalyzePeaksListInput[in];
	AdvancedAnalyzePeaksPreview[inList, ops]
];


AdvancedAnalyzePeaksPreview[in: ListableP[inputAnalyzePeaksP], ops: OptionsPattern[AdvancedAnalyzePeaksPreview]] :=
	AdvancedAnalyzePeaks[in, ReplaceRule[ToList[ops],{Output->Preview}]];


(* ::Subsection::Closed:: *)
(*ValidAdvancedAnalyzePeaksQ*)


DefineOptions[ValidAdvancedAnalyzePeaksQ,
	Options:>{
		VerboseOption,
		OutputFormatOption
	},
	SharedOptions :> {AdvancedAnalyzePeaks}
];


ValidAdvancedAnalyzePeaksQ[in: ObjectP[peakProtocolTypes], ops: OptionsPattern[ValidAdvancedAnalyzePeaksQ]] := Module[
	{inList},
	inList = resolveAnalyzePeaksListInput[in];
	ValidAdvancedAnalyzePeaksQ[inList, ops]
];


ValidAdvancedAnalyzePeaksQ[in: ListableP[inputAnalyzePeaksP], ops: OptionsPattern[ValidAdvancedAnalyzePeaksQ]] := Module[
	{preparedOptions,functionTests,initialTestDescription,allTests, verbose, outputFormat},

	(* Remove the Verbose option and add Output->Tests to get the options ready for <Function> *)
	preparedOptions=Normal@KeyDrop[Append[ToList[ops],Output->Tests],{Verbose,OutputFormat}];

	(* Call the function to get a list of tests *)
	functionTests=AdvancedAnalyzePeaks[in,preparedOptions];

	initialTestDescription="All provided options and inputs match their provided patterns (no further testing can proceed if this test fails):";

	allTests=If[MatchQ[functionTests,$Failed],
		{Test[initialTestDescription,False,True]},
		Module[{initialTest,validObjectBooleans,voqWarnings,testResults},
			initialTest=Test[initialTestDescription,True,True];

			(* Create warnings for invalid objects *)
			If[MatchQ[in, ListableP[ObjectP[]]],
				validObjectBooleans=ECL`ValidObjectQ[ToList[in],OutputFormat->Boolean];
				voqWarnings=MapThread[
					Warning[ToString[#1,InputForm]<>" is valid (run ValidObjectQ for more detailed information):",
						#2,
						True
					]&,
					{ToList[in],validObjectBooleans}
				],
				voqWarnings = {}
			];

			(* Get all the tests/warnings *)
			Join[functionTests,voqWarnings]
		]
	];

	(* determine the Verbose and OutputFormat options; quiet the OptionValue::nodef message in case someone just passed nonsense *)
	{verbose, outputFormat} = OptionDefault[OptionValue[ValidAdvancedAnalyzePeaksQ, {ops}, {Verbose, OutputFormat}]];

	(* Run all the tests as requested *)
	Lookup[RunUnitTest[<|"ValidAdvancedAnalyzePeaksQ" -> allTests|>, OutputFormat -> outputFormat, Verbose -> verbose], "ValidAdvancedAnalyzePeaksQ"]
];



computePeaksFieldsAdvanced[pippy:Pippy[pv_Symbol], dataID_Integer] := Module[
	{
		 domains, peakFieldsByMethod, mergedPeaks, baselineFunctions,
		mergedBLF,  baselineRanges,	methodIDs, xy, methods
	},

	xy = Lookup[First[Pippy`Private`PippySelect[pippy, "Datasets",#DatasetID===dataID&],<||>],"Coordinates",$Failed];
	If[ xy === $Failed, Return[$Failed]];

	(* all methods, but order is important.  
		1) Manual
		2) Threshold
		3) Unknown
	*)
	methods = Flatten[Lookup[
		GroupBy[Values[pv["Methods"]],Function[#Method]],
		{"Manual","Threshold","Unknown"},
		{}
	]];
	methodIDs = Lookup[methods, "MethodID",{}];

	domains = If[methodIDs === {},
		{{xy[[1,1]],xy[[-1,1]]}},
		Map[Lookup[#,"MethodDomain"]&,methods]
	];

	peakFieldsByMethod = If[methodIDs === {},
		{getAdvancedPeakParameters[]},
		Map[getAdvancedPeakParameters[pippy, dataID,#]&, methodIDs]
	];

	(*Pull out values that will not go into the merged peaks field*)
	baselineFunctions = Lookup[peakFieldsByMethod,BaselineFunction,Function[0]];
	baselineRanges = Lookup[peakFieldsByMethod, BaselinePeakRanges,Null];

	(*Remove the fields that will not go into the mergedpeaks field*)
	mergedPeaks = mergePeakParameters[DeleteCases[peakFieldsByMethod,Rule[BaselineFunction,_]|Rule[BaselinePeakRanges, _],{2}]];

	mergedBLF = If[baselineFunctions===Null, Null,With[
		{fspec = Quiet[Simplify[Piecewise[MapThread[Function[{domain,ff},{ff[x],domain[[1]]<=x<=domain[[2]]}],{domains,baselineFunctions}],Indeterminate]]/.x->Slot[1],{Reduce::ratnz}]},
		Function[fspec]
	]];

	{
		mergedPeaks,
		mergedBLF,
		baselineRanges
	}
];




(* Get parameters from peaks *)
getAdvancedPeakParameters[]:={
		Position->{},
		Height->{},
		HalfHeightWidth->{},
		Area->{},
		PeakRangeStart->{},
		PeakRangeEnd->{},
		WidthRangeStart->{},
		WidthRangeEnd->{},
		BaselineIntercept->{},
		BaselineSlope->{},
		AsymmetryFactor->{},
		TailingFactor->{},
		TangentWidth -> {},
		TangentWidthLines -> {},
		TangentWidthLineRanges -> {},
		BaselinePeakRanges->{},
		PeakAssignment->{}
	};
getAdvancedPeakParameters[pippy_, dataID_Integer, methodID_Integer]:=Module[
	{
		pks, boundaryInds, baselinePoints,
		heights,centers,widths,areas,maxes,peakRanges,widthRanges,return,baselineRules,
		alphas, asymmetryFactorRanges, asymmetryFactors, tailingFactorRanges, tailingFactors,
		tgStuff, baselineFunction, missingPeaks
	},

	pkIDs = Pippy`Private`ApplyMethod[pippy, methodID -> dataID];
	pks = Lookup[pippy[[1]]["Peaks"],pkIDs];
	missingPeaks = Pippy`Private`MissingPeaks[pippy, dataID];
	
	If[pks==={}, 
		Return[getAdvancedPeakParameters[]]
	];

	dataPts = Lookup[First[Pippy`Private`PippySelect[pippy, "Datasets", #DatasetID===dataID&],<||>],"Coordinates"];

	boundaryInds = Lookup[pks, "BoundaryIndices"];
	dataSplit = Map[Take[dataPts, #]&, boundaryInds];
	peakRanges = Lookup[pks, "BoundaryPoints"][[;;,;;,1]];
	baselinePoints = Lookup[pks, "BaselinePoints"];
	baselineRules = calculateBaselineSpecAdvanced[baselinePoints];
	baselineFunction = Lookup[baselineRules, BaselineFunction];

	{centers, maxes} = Transpose[Lookup[pks, "ApexPoint"]];
	
	widthRanges = MapThread[getPeakWidthRanges[#1, #2] &, {dataSplit, centers}];

	areas = Lookup[pks,"Area"];

	widths=Map[#.{-1,1}&,widthRanges];

	heights=With[{bf=baselineFunction},
		MapThread[#1-bf[#2]&,{maxes,centers}]
	];

	tgStuff=Array[Null&,{Length[centers],3}];

	(* For each split of data corresponding to a peak, get the average spacing between data points *)
	(* This will be the minimum peak distance measurement, and prevents division by zero for the asymmetry and tailing factor calculations *)
	alphas = Map[Mean[Differences[#[[;;,1]]]]&, dataSplit];

	(* Tailing factor calculation at 5% of max peak height *)
	tailingFactorRanges=MapThread[getPeakWidthRanges[#1,#2,0.05]&, {dataSplit, centers}];
	tailingFactors=MapThread[
		If[#2!=First[#1],
			(* AB / 2AC, where A is left bound, B is the right bound, and C is the center *)
			#1.{-1,1} / (2*(#2-First[#1])),
			(* If center is at zero (AC = 0) smooth expression using (AB + dx)/2*(0 + dx) *)
			(#1.{-1,1}+#3) / (2*#3)
		]&,
		{tailingFactorRanges, centers, alphas}
	];

	(* Asymmetry factor calculation at 10% of max peak height *)
	asymmetryFactorRanges=MapThread[getPeakWidthRanges[#1,#2,0.10]&, {dataSplit, centers}];
	asymmetryFactors=MapThread[
		If[#2!=First[#1],
			(* BC / AC, where A is left bound, B is the right bound, and C is the center *)
			(Last[#1] - #2) / (#2-First[#1]),
			(* If center is at zero (AC = 0) smooth expression using (BC + dx)/(0 + dx) *)
			(Last[#1] - #2 + #3) / #3
		]&,
		{asymmetryFactorRanges, centers, alphas}
	];

	return = {
		Position->centers,
		Height->heights,
		HalfHeightWidth->widths,
		Area->areas,
		PeakRangeStart->peakRanges[[;;,1]],
		PeakRangeEnd->peakRanges[[;;,2]],
		WidthRangeStart->widthRanges[[;;,1]],
		WidthRangeEnd->widthRanges[[;;,2]],
		BaselineIntercept->Lookup[baselineRules,BaselineIntercept],
		BaselineSlope->Lookup[baselineRules,BaselineSlope],
		BaselineFunction->Lookup[baselineRules,BaselineFunction],
		AsymmetryFactor->asymmetryFactors,
		TailingFactor->tailingFactors,
		TangentWidth -> tgStuff[[;;, 1]],
		TangentWidthLines -> tgStuff[[;;, 2]],
		TangentWidthLineRanges -> tgStuff[[;;, 3]],
		BaselinePeakRanges->peakRanges,
		PeakLabel -> Lookup[pks, "Label"],
		(* MissingPeaks -> Lookup[missingPeaks,"Label"], *)
		PeakAssignment -> Lookup[pks, "Assignment"],
		RelativeArea -> Lookup[pks,"RelativeArea",Null],
		ParentPeak -> Lookup[pks, ParekPeaks,Null]
	};

	return

];


(*
getModelMoleculesForFEFromData returns a list of the form:
    {
        {"Water", Model[Molecule,"id:vXl9j57PmP5D"]},
        {"Glycine-Tyrosine", Model[Molecule,Oligomer,"id:1ZA60vL51z9w"]},
        {"Valine-Tyrosine-Valine", Model[Molecule,Oligomer,"id:Z1lqpMzRZrnz"]},
        ...
    }
*)
getModelMoleculesForFEFromData[listedDataExpanded_] := Module[{dataObjects, composition},
	dataObjects = Quiet[
		Check[Cases[listedDataExpanded, ObjectP[Object[Data]], {0, 1}], {}],
		{Download::ObjectDoesNotExist,Download::MismatchedType}
	];

	If[Length[dataObjects] == 0, Return[{}, Module]];

	Quiet[
		Check[
			DeleteDuplicates[
				DeleteCases[Flatten[
					Download[dataObjects,SamplesIn[Composition][[All, 2]][{Name, Object}]],
					2
				],Null]
			],
			{}
		],
		{Download::ObjectDoesNotExist,Download::MismatchedType}
	]
];


optsToFEPacket[pippy_] := Module[{manualPeaks},
	(* 
		pippy has already loaded the manual peaks
		and handled the labeling and assignments, 
		so pull straight from pippy
	*)
	manualPeaks = Pippy`Private`PippySelect[pippy, "Peaks", #Method === "Manual" &];
	
	Map[
		<|
			"XFirst" -> #BoundaryPoints[[1,1]],
			"XLast" -> #BoundaryPoints[[-1,1]],
			"YFirst" -> #BaselinePoints[[1,2]],
			"YLast" -> #BaselinePoints[[-1,2]],
			"Label" -> #Label,
			"Assignment" -> #Assignment
		|> &,
		manualPeaks
	]
];



syncPeakWidgets[pippy_, dv_] := Module[{thresholds, bogeyThresholds, manualPeaks, expectedPeaks},

	thresholds = Pippy`Private`PippySelect[pippy, "Methods", #Method==="Threshold"&];
	bogeyThresholds = Pippy`Private`PippySelect[pippy, "Methods", #Method==="Unknown"&];
	
	manualPeaks = Pippy`Private`PippySelect[pippy, "Peaks", #Method==="Manual"&];

	expectedPeaks = Lookup[
		Pippy`Private`PippyLookup[pippy,"Peaks"],
		Lookup[Values@Pippy`Private`PippyLookup[pippy,"Library"],"SourcePeakID",{}]
	];
	
	LogPreviewChanges[dv,{
		ManualPeaks -> Map[pippyPeakToManualPeakOption, manualPeaks],
		ExpectedPeaks -> Map[pippyPeakToExpectedPeakOption, expectedPeaks],
		PeakThresholds -> Map[pippyThresholdToPeakThresholdsOption, thresholds],
		UnknownPeakThresholds -> Map[pippyThresholdToPeakThresholdsOption, bogeyThresholds]
	}]
];

pippyPeakToManualPeakOption[KeyValuePattern[{
		"BoundaryPoints"->{{xL_,_},{xR_,_}}, 
		"BaselinePoints" ->{{_,yL_},{_,yR_}}
	 }]] := {{xL,yL},{xR,yR}};

(* TODO: fill in assignment *)
pippyPeakToExpectedPeakOption[KeyValuePattern[{
		"BoundaryPoints"->{{xL_,_},{xR_,_}}, 
		"ApexPoint" -> {xA_,_},
		"Label" -> label_,
		"Assignment" -> assignment_
	 }]] := {label,  xA, {xL,xR}};

pippyThresholdToPeakThresholdsOption[KeyValuePattern[{
		"ThresholdDomain"->{xL_,xR_}, 
		"ThresholdHeight" -> yTh_
	 }]] := {{xL,xR}, yTh};



calculateBaselineSpecAdvanced[ baselinePoints_]:=Module[{baselineIntercept,baselineSlope,blf,x, edgePoints},
	baselineIntercept=Map[((#[[1, 1]] * #[[-1, 2]] - #[[-1, 1]] * #[[1, 2]]) / (#[[1, 1]] - #[[-1, 1]])) &, baselinePoints];
	baselineSlope=Map[(#[[-1,2]]-#[[1,2]])/(#[[-1,1]]-#[[1,1]])&,baselinePoints];
	blf = With[
		{fspec = Quiet[Simplify[Piecewise[MapThread[{#1+#2*x,#3<=x<=#4}&,{baselineIntercept,baselineSlope,baselinePoints[[;;,1,1]],baselinePoints[[;;,2,1]]}],Indeterminate]]/.x->Slot[1],{Reduce::ratnz}]},
		Function[fspec]
	];
	{
		BaselineIntercept->baselineIntercept,
		BaselineSlope->baselineSlope,
		BaselineFunction->blf
	}
];


peakReplaceFields = {Position,Height,Area,HalfHeightWidth,
	PeakRangeStart, PeakRangeEnd, PeakLabel,ParentPeak,
	WidthRangeStart, WidthRangeEnd, RelativeArea, 
	PeakAssignment,BaselineIntercept,BaselineSlope,AsymmetryFactor,TailingFactor,
	RelativePosition,PeakAssignmentLibrary,HalfHeightResolution,
	AdjacentResolution,HalfHeightNumberOfPlates, 	NMRFunctionalGroup
};

formatPeakPacketAdvanced[in_, peakParameters0_, baselineFunction_, standardFieldsStart_, resolvedOps_, samples_, cntForName_, xy_] := Module[
	{
		dataRef,peakParameters,mergedParameters,purity, finalResolvedOps,numPeaks,
		globalBaseline, dataNotInPeaks, x
	},

	If[Or[MatchQ[resolvedOps,Null],MatchQ[peakParameters0,Null]],
		Return[Null]
	];
	
	numPeaks=Length[Lookup[peakParameters0,Position]];


	peakParameters = MapAt[If[StringQ[#],Symbol[#],#]&, peakParameters0, {;;,1}];
	peakParameters = DeleteDuplicatesBy[peakParameters, First];

	mergedParameters = Map[
		Which[
			MemberQ[peakReplaceFields,#[[1]] ],
				Replace[#[[1]]] -> If[MatchQ[#[[2]],Null|{}], Table[Null, numPeaks], #[[2]]],
			MemberQ[{TangentNumberOfPlates, TangentWidth,TangentResolution,TangentWidthLineRanges, TangentWidthLines}, #[[1]]],
				Replace[#[[1]]]->#[[2]],
			True,
				#
		]&,
		peakParameters
	];
	
	dataNotInPeaks=Fold[Analysis`Private`selectInclusiveMatrixPointsOutsideRangeC[#1,Sequence @@ #2]&,xy,Transpose[Lookup[mergedParameters,Replace/@{PeakRangeStart,PeakRangeEnd}]]];

	globalBaseline=LinearModelFit[dataNotInPeaks,x,x]["Function"];


	purity = computePurity[Lookup[mergedParameters,Replace@Area],xy,globalBaseline,Lookup[mergedParameters,Replace@PeakLabel]];
	
	(* Data reference resolution *)
	dataRef = If[MatchQ[in, ObjectP[]], in[Object], Null];


	finalResolvedOps=resolvedOps;


	Association[Join[
		{Type -> Object[Analysis, Peaks]},
		{Name -> If[MatchQ[Lookup[resolvedOps, Name], Null],
					Null,
					If[cntForName==1,
						Lookup[resolvedOps, Name],
						Lookup[resolvedOps, Name] <> " " <> ToString[cntForName]
					]
				]},

		standardFieldsStart,
		mergedParameters,
		{
			BaselineFunction -> baselineFunction,
			(* Replace[RelativeRetentionTime] -> Lookup[mergedParameters, Replace[RelativePosition]], *)
			Replace[Reference] -> If[MatchQ[dataRef, Null],
				{},
				{Link[dataRef, LegacySLL`Private`peaksFieldToPeaksSourceField[dataRef[Type], Lookup[resolvedOps, ReferenceField]]]}
			],
			ReferenceField -> Lookup[resolvedOps, ReferenceField],
			ResolvedOptions -> Replace[finalResolvedOps, {
				(DataType -> Automatic) -> (DataType -> Null),
				Rule[PeakLabels,_]  -> Rule[PeakLabels , Lookup[mergedParameters,Replace[PeakLabel]]],
				Rule[PeakAssignments,_] -> Rule[PeakAssignments, Lookup[mergedParameters, Replace[PeakAssignment]] ],
				Rule[ParentPeaks,_] -> Rule[ParentPeaks, Lookup[mergedParameters, Replace[ParentPeak]] ]
			},{1}]/. _Missing -> Null ,
			Replace[PeakSamples] -> Map[Link,samples],
			Purity -> purity
		}
	]]

];


(* Resolve all options which do not require identification of peaks *)
resolveAdvancedAnalyzePeaksOptions[rawData_, listedData_, xyUnits_, refField_, wavelength_, sliceOps_, combinedOptions_, safeOptions_, ops: OptionsPattern[resolveAnalyzePeaksOptions]] := Module[
	{output, listedOutput, collectTestsBoolean, messagesBoolean, resolvedOptions, tests},

	(* From resolveTacoPreparationOptions's options, get Output value *)
	output = OptionDefault[OptionValue[Output]];
	listedOutput = ToList[output];
	collectTestsBoolean = MemberQ[listedOutput, Tests];
	messagesBoolean = !collectTestsBoolean;

	{resolvedOptions,tests}=Transpose@MapThread[
		resolveAdvancedAnalyzePeaksOptionsSingle[#1,#2,#3,#4,#5,#6,combinedOptions,safeOptions,collectTestsBoolean,#7]&,
		{rawData,listedData,xyUnits,refField,wavelength,sliceOps,Range[Length[wavelength]]}
	];

	output /. {Tests -> Flatten[tests], Result -> resolvedOptions}
];

(* Handle the case where a single data object resolves multiple reference fields *)
resolveAdvancedAnalyzePeaksOptionsSingle[xySets:{CoordinatesP..}, in_, xyUnits_, refFields:{_Symbol..}, wavelengths_, sliceOps_, combinedOps_, safeOps_, collectTestsBoolean_, index_] := Module[
	{resolvedOps,tests,updatedOps},

	(* Split up the input when there are multiple reference fields for a single input *)
	{resolvedOps,tests}=Transpose@MapThread[
		resolveAdvancedAnalyzePeaksOptionsSingle[#1,in,#2,#3,#4,#5,combinedOps,safeOps,collectTestsBoolean,index]&,
		{xySets,xyUnits,refFields,wavelengths,sliceOps}
	];

	(* Return the paired options and tests as a sequence *)
	Sequence@@MapThread[
		{#1,#2}&,
		{resolvedOps,tests}
	]
];

(* Single overload *)
resolveAdvancedAnalyzePeaksOptionsSingle[xy: CoordinatesP, in_, {xUnit_, yUnit_}, refField_, wavelength_, sliceOps_, combinedOptions_, safeOptions_, collectTestsBoolean_, index_] := Module[
	{
		name, nameTestDescription, nameTest,
		dataQuality,  dataType, manualOverlapQ,	mostlyResolvedOptions,resolvedPeakType,slicingOptions, manualPeaks
	},

	(* Resolve the data type of the input *)
	dataType=If[ObjectQ[in],in[Type], Null];
	dataQuality=Null;

	
	(* --- Check if Name existed in DB --- *)
	name = Lookup[combinedOptions, Name];
	nameTestDescription="Check if the given Name already existed in the database:";
	nameTest = peaksTestOrNull[Name, collectTestsBoolean, nameTestDescription,
		NullQ[name] || Length[Search[Object[Analysis, Peaks], Name=name]] == 0];


	(* Pre-resolved values of the manual range and position options *)
	manualPeaks = Lookup[combinedOptions, ManualPeaks];
	manualRanges = Map[{#[[1,1]],#[[-1,1]]}&,manaulPeaks];

	
	(* If manual ranges were provided, check if any of them overlap *)
	manualOverlapQ = If[MatchQ[resolvedPeakType,Manual]&&MatchQ[manualRanges,{_Span...}]&&Length[manualRanges]>1,
		And@@Map[
			overlappingRangesQ[#[[1]],#[[2]]]&,
			(* Map over adjacent pairs of sorted intervals *)
			Partition[List@@@SortBy[manualRanges,First], 2, 1]
		],
		False
	];

	(* Hard error if manual ranges were specified and overlapping *)
	If[manualOverlapQ,
		Message[Error::InvalidManualPeaks,manualRanges];
		Message[Error::InvalidOption, ManualPeaks];
		Return[{$Failed,{}}];
	];



	(* Options from slicing 3D data/input resolution *)
	slicingOptions=If[MatchQ[sliceOps,{}],
		(* Input was 2D/did not use slicing *)
		{
			DataSliceDimension->Null,
			DataSlice->Null,
			SliceReductionFunction->Null,
			SliceReferencePeaks->Null
		},
		sliceOps
	];



	(* This is the set of options we can resolve prior to identifying peaks *)
	mostlyResolvedOptions = ReplaceRule[
		combinedOptions,
		Join[
			slicingOptions,
      	{
				ReferenceField -> refField,
				Wavelength -> wavelength
		}
		]
	];

	(* Return the mostly resolved options *)
	{mostlyResolvedOptions, Cases[{}, Except[Null]]}

];
