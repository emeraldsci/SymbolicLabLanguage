(* ::Package:: *)

(*options for AnalyzeThermodynamics*)
DefineOptions[AnalyzeThermodynamics,
	Options :> {
			{
				OptionName -> Name,
				Default -> Null,
				Description -> "Name to be used as the name of Object[Analysis, Thermodynamics] generated by the analysis.",
				AllowNull -> True,
				Category -> "General",
				Widget -> Widget[Type->Expression,Pattern:>_String, Size -> Line]
			},
		OutputOption,
		UploadOption
	}
];

Error::BadEquilibrium="EquilibriumType must be the same for all data sets.";
Error::TooFewPoints="Fitting requires melting point analyses for at least 2 different concentrations.";
Error::MissingConcentration="Cannot find concentration for samples `1`";

analyzeThermodynamicsInputPatternP = Alternatives[
	ObjectP[{Object[Protocol,UVMelting], Object[Protocol, FluorescenceThermodynamics]}],
	{ObjectP[{Object[Analysis, MeltingPoint], Object[Data, MeltingCurve], Object[Data, FluorescenceThermodynamics]}]..}
];

DefineAnalyzeFunction[
	AnalyzeThermodynamics,
	<|
		ThermoData -> analyzeThermodynamicsInputPatternP
	|>,
	{
		Batch[resolveInputsAnalyzeThermodynamics],
		resolveEquilibriumType,
		computeFit,
		previewAnalyzeThermodynamics
	}
];

resolveInputsAnalyzeThermodynamics[KeyValuePattern[{
	UnresolvedInputs -> KeyValuePattern[{
		ThermoData -> mixedInputObj_
	}]
}]
]:=Module[{
	resolvedInputObj,
	inputTypes, protocolDownloadFields, dataDownloadFields, analysisDownloadFields,
	mixedDownloadFields, mixedDownloads, packetsInTotal
},
	(*add additional brackets to Protocol object if it is mixed with other lists of Data/Analysis Objects*)
	resolvedInputObj = resolveDownloadInputObject[mixedInputObj];

	inputTypes = Download[#, Type]&/@mixedInputObj;

	protocolDownloadFields = {
		Type, Data, NestedIndexMatchingSamplesIn, WorkingSamples, WorkingSamples[Composition],
		Data[Object], Data[SamplesIn], Data[MeltingAnalyses],
		Data[MeltingAnalyses][MeanMeltingTemperature], Data[MeltingAnalyses][Object]
	};
	analysisDownloadFields = {
		MeanMeltingTemperature, Object,
		Reference[Object], Reference[SamplesIn], Reference[MeltingAnalyses],
		Reference[Protocol][Type],Reference[Protocol][Data],Reference[Protocol][NestedIndexMatchingSamplesIn],Reference[Protocol][WorkingSamples],Reference[Protocol][WorkingSamples][Composition]
	};
	dataDownloadFields = {
		Protocol[Type], Protocol[Data], Protocol[NestedIndexMatchingSamplesIn], Protocol[WorkingSamples], Protocol[WorkingSamples][Composition],
		Object, SamplesIn, MeltingAnalyses,
		MeltingAnalyses[MeanMeltingTemperature], MeltingAnalyses[Object]
	};
	replaceRules = {
		TypeP[Object[Protocol]] :> protocolDownloadFields,
		{TypeP[Object[Analysis]]..} :> analysisDownloadFields,
		{TypeP[Object[Data]]..} :> dataDownloadFields
	};

	(*replace fields to be downloaded based on input data types*)
	mixedDownloadFields = ReplaceAll[inputTypes, replaceRules];
	(*If there is an error during download, suppress the error here for more specific error messages*)
	mixedDownloads = Quiet[Download[resolvedInputObj, mixedDownloadFields]];
	packetsInTotal = MapThread[convertBulkDownloadToPackets, {mixedDownloads, inputTypes}];

	{packetList, dataList, analList} = Transpose[packetsInTotal];

	<|
		ResolvedInputs -> <|
			ProtocolPacketInput -> packetList,
			DataPacketInput -> dataList,
			AnalysisPacketInput -> analList
		|>,
		Batch -> True
	|>

];

(*
  This function is to add a pair of brackets on ObjectP[Object[Protocol]], because Download will not work in the mixed input data case.
  e.g. Download[{Object[Protocol, UVMelting, "id:pZx9jonGXrJp"], {Object[Data, MeltingCurve, "id:8qZ1VWNmdAVP"], Object[Data, MeltingCurve, "id:kEJ9mqaVPxl3"]}},
                {{protocolField}, {dataField}}]
  will not work. It will work on
  Download[{{Object[Protocol, UVMelting, "id:pZx9jonGXrJp"]}, {Object[Data, MeltingCurve, "id:8qZ1VWNmdAVP"], Object[Data, MeltingCurve, "id:kEJ9mqaVPxl3"]}},
                {{protocolField}, {dataField}}]
  However in the protocol only cases, this is not necessary.
*)
resolveDownloadInputObject[inputList_]:=Module[{
	inputTypes,isProtocol, isData, isAnal, position, protocolName, protocolNameBracket
},
	(*Download[lst_List, Type] will not work properly, if lst is a list like {Obj1, {Obj2, Obj3}}. *)
	inputTypes = Download[#, Type]&/@inputList;
	isProtocol = MemberQ[inputTypes, TypeP[Object[Protocol]]];
	isData = MemberQ[inputTypes, {TypeP[Object[Data]]..}];
	isAnal = MemberQ[inputTypes, {TypeP[Object[Analysis]]..}];

	(*only add brackets when Protocol and one of Data/Analysis Objects both exist*)
	newInputList = If[(isProtocol && isData) || (isProtocol && isAnal),

		(*find the position of Object[Protocol]*)
		position = Position[inputList, ObjectP[Object[Protocol]]];
		protocolName = Extract[inputList, position];
		(*replace Object[Protocol] by {Object[Protocol]}*)
		protocolNameBracket = {#}&/@protocolName;
		newInputList = ReplacePart[inputList, MapThread[Rule, {position, protocolNameBracket}]],

		inputList
	];
	newInputList
];


convertBulkDownloadToPackets[bulkDownload_, TypeP[Object[Protocol]]]:=Module[{
	protType, protData, protNestedIndex, protWorkingSamples,protWorkingSamplesComposition,
	protDataObject, protDataSamplesIn, protDataMeltingAnalyses,
	protDataMeltingAnalysesMeanMeltingTemp, protDataMeltingAnalysesObject,
	dataPosition, extractFunc,
	packetProtType, packetProtData, packetProtNestedIndex, packetProtWorkingSamples, packetProtWorkingSamplesComp,
	packetDataObject, packetDataSamplesIn, packetDataMeltingAnal,
	packetAnalMeltingTemp, packetAnalMeltingObj
},
	(*If input data has extra brackets due to mixed input object types, it will remove it to singleton case.*)
	{
		protType, protData, protNestedIndex, protWorkingSamples,protWorkingSamplesComposition,
		protDataObject, protDataSamplesIn, protDataMeltingAnalyses,
		protDataMeltingAnalysesMeanMeltingTemp, protDataMeltingAnalysesObject
	} = If[Length[bulkDownload]===1,
		Flatten[bulkDownload, 1],
		bulkDownload
	];

	dataPosition = Position[protData, ObjectP[Object[Data, MeltingCurve]], 1];
	(*this is singleton case. If Length[dataPosition]=2, it will map {a, b, c} to
  {{a, a}, {b, b}, {c, c}}
  *)

	{packetProtType, packetProtData, packetProtNestedIndex, packetProtWorkingSamples, packetProtWorkingSamplesComp} = Map[
		ConstantArray[#, Length[dataPosition]]&,
		{protType, protData, protNestedIndex, protWorkingSamples, protWorkingSamplesComposition}
	];

	listProt = createAssociationList[
		{Type, Data, NestedIndexMatchingSamplesIn, WorkingSamples, Composition},
		{packetProtType, packetProtData, packetProtNestedIndex, packetProtWorkingSamples, packetProtWorkingSamplesComp}
	];

	(*extract data by given data positions*)
	extractFunc = Function[x, Extract[x, #]&/@dataPosition];

	{packetDataObject, packetDataSamplesIn, packetDataMeltingAnal} = Map[extractFunc, {protDataObject, protDataSamplesIn, protDataMeltingAnalyses}];
	listData = createAssociationList[{Object, SamplesIn, MeltingAnalyses}, {packetDataObject, packetDataSamplesIn, packetDataMeltingAnal}];

	{packetAnalMeltingTemp, packetAnalMeltingObj} = Map[extractFunc, {protDataMeltingAnalysesMeanMeltingTemp, protDataMeltingAnalysesObject}];
	listAnal = createAssociationList[{MeanMeltingTemperature, Object}, {packetAnalMeltingTemp, packetAnalMeltingObj}];

	{listProt, listData, listAnal}
];


convertBulkDownloadToPackets[bulkDownload_, {TypeP[Object[Analysis]]..}]:=Module[{
	analMeanMeltingTemp, analObject,
	protRefObject, protRefSamplesIn, protRefMeltingAnalyses,
	dataRefProtType, dataRefProtData, dataRefProtNested, dataRefProtWorkingS, dataRefProtWorkingSComp,
	dataToUse,protToUse
},
	(*reform three lists of packets for future analysis.*)
	{
		analMeanMeltingTemp, analObject,
		protRefObject, protRefSamplesIn, protRefMeltingAnalyses,
		dataRefProtType, dataRefProtData, dataRefProtNested, dataRefProtWorkingS, dataRefProtWorkingSComp
	} = Transpose[bulkDownload];

	protToUse = First[Transpose[#]]&/@{dataRefProtType, dataRefProtData, dataRefProtNested, dataRefProtWorkingS, dataRefProtWorkingSComp};
	dataToUse = Last[Transpose[#]]&/@{protRefObject, protRefSamplesIn, protRefMeltingAnalyses};

	listProt = createAssociationList[{Type, Data, NestedIndexMatchingSamplesIn, WorkingSamples, Composition}, protToUse];

	listData = createAssociationList[{Object, SamplesIn, MeltingAnalyses}, dataToUse];

	listAnal = createAssociationList[{MeanMeltingTemperature, Object}, {analMeanMeltingTemp, analObject}];

	{listProt, listData, listAnal}
];

convertBulkDownloadToPackets[bulkDownload_, {TypeP[Object[Data]]..}]:=Module[{
	packetProtType, packetProtData, packetProtNestedIndex, packetProtWorkingSamples, packetProtWorkingSamplesComp,
	packetDataObject, packetDataSamplesIn, packetDataMeltingAnal,
	packetAnalMeltingTemp, packetAnalMeltingObj
},
	(*reform three lists of packets for future analysis*)
	{
		packetProtType, packetProtData, packetProtNestedIndex, packetProtWorkingSamples, packetProtWorkingSamplesComp,
		packetDataObject, packetDataSamplesIn, packetDataMeltingAnal,
		packetAnalMeltingTemp, packetAnalMeltingObj
	} = Transpose[bulkDownload];

	listProt = createAssociationList[{Type, Data, NestedIndexMatchingSamplesIn, WorkingSamples, Composition},
		{packetProtType, packetProtData, packetProtNestedIndex, packetProtWorkingSamples, packetProtWorkingSamplesComp}];

	listData = createAssociationList[{Object, SamplesIn, MeltingAnalyses}, {packetDataObject, packetDataSamplesIn, packetDataMeltingAnal}];

	listAnal = createAssociationList[{MeanMeltingTemperature, Object}, {packetAnalMeltingTemp, packetAnalMeltingObj}];

	{listProt, listData, listAnal}
];


(*
  define a helper function that can generate a list of associations. e.g. value1={v1, v2, v3}, value2={v4, v5. v6}, this function will generate
  {<|key1->v1, key2->v4|>, <|key1->v2, key2->v5|>, <|key1->v3, key2->v6|>}
  requirement: Length[keyList]===Length[valuesNestedList[[1]]]
*)
createAssociationList[keyList_, valuesNestedList_]:=Map[AssociationThread[keyList, #]&, Transpose[valuesNestedList]];


(*
  This function will take the ProtocolPackets and DataPackets from ResolvedInputs, and return the equilibrium type.
  The equilibrium type will be used in computeFit function.
*)
resolveEquilibriumType[KeyValuePattern[{
	ResolvedInputs -> KeyValuePattern[{
		ProtocolPacketInput -> prots_,
		DataPacketInput -> datas_
	}]
}]
]:=Module[{eqTypes, sampleGroupings},
	(*return a sublist of samples that is from prots[NestedIndexMatchingSamplesIn], for which those samples prots[Data] contains valid Data objects.*)
	sampleGroupings = protocolFilter[prots,NestedIndexMatchingSamplesIn,Data,Lookup[datas,Object]];
	eqTypes = Map[
		resolveMeltingPointEquilibriumTypeFromSamples[#]&,
		sampleGroupings
	];
	If[Not[SameQ@@eqTypes],
		Message[Error::BadEquilibrium];
		Return[Null]
	];
	<|
		ResolvedInputs -> <|
			ThermodynamicsEquilibriumType -> First[eqTypes]
		|>
	|>
];

(*Return a sublist of elements in listA, which is protPacket[fieldA], that protPacket[fieldB] matches the pattern of dataPattern.*)
protocolFilter[protPacket_, targetField_Symbol, compareField_Symbol, dataPattern_]:= Module[{listA,listB},
	listA = Lookup[protPacket,targetField];
	listB = Cases[Lookup[protPacket,compareField],ObjectP[dataPattern[Type]]];

	If[Or[MatchQ[listA,Null],MatchQ[listB,Null]],
		Return[Null]
	];

	If[UnsameQ[Length[listA],Length[listB]],
		Return[$Failed];
	];
	(*Since protPacket is a repeated list, only return the first element (which is a list of samples). *)
	First[PickList[listA,listB,ObjectP[dataPattern]]]
];


(* MapThread over multiple protocols and patterns. protPackets is {ObjectP[]..}*)
protocolFilter[protPackets_, targetField_Symbol, compareField_Symbol, dataPatterns_List
]:=MapThread[
	protocolFilter[#1,targetField,compareField,#2]&,
	{protPackets,dataPatterns}
];


(*
  If samples are the same or a single sample, it returns BiomolecularHomogenous.
  If both samples are null or not the same, it returns BiomolecularHeterogenous.
 *)
resolveMeltingPointEquilibriumTypeFromSamples[{sample_, sample_}] := BimolecularHomogenous;
resolveMeltingPointEquilibriumTypeFromSamples[{sample_}] := BimolecularHomogenous;
resolveMeltingPointEquilibriumTypeFromSamples[{sampleA_, sampleB_}] := BimolecularHeterogenous;
resolveMeltingPointEquilibriumTypeFromSamples[_] := BimolecularHeterogenous;


(*
  Compute fitted results. The output will be put into the Packet(s).
  In the middle step, the AnalyzeFit is ultimately called, but the upload is suppressed, and returns a packet.
  The packet will be eventually uploaded and linked to the thermodynamics object at the final upload stage.
  In order to separate the logic, it will upload Object[Analysis, Fit] and make final modification in the next step.
*)
computeFit[KeyValuePattern[{
	ResolvedInputs -> KeyValuePattern[{
		ProtocolPacketInput -> prots_,
		DataPacketInput -> datas_,
		AnalysisPacketInput -> anals_,
		ThermodynamicsEquilibriumType -> etype_
	}],
	ResolvedOptions -> KeyValuePattern[{
		Name -> name_,
		Upload -> uploadOption_
	}]
}]
]:=Module[{affinityConstants, fitPacket, thermoFields, mpLinks},

	(*Calculate affinity constants*)
	affinityConstants = computeAffinityConstants[prots, datas, anals, etype];

	(*Calculate fitting results by calling AnalyzeFit[].*)
	fitPacket = computeThermodynamicsFit[affinityConstants, name];

	(*Formatting fitted resluts and prepare for Packet.*)
	thermoFields = calculateAnalyzeThermodynamicsThermoFields[fitPacket];

	(*return early if calculation is $Failed due to error*)
	If[MatchQ[thermoFields, $Failed],
		Return[$Failed];
	];

	(*Create links for the Packet.*)
	mpLinks = Map[
		Link[#[Object],Thermodynamics]&,
		anals,
		{1}
	];

	(*single case, do not upload here until Upload is True*)
	If[TrueQ[uploadOption],
	  Upload[Join[<|Object->Lookup[fitPacket, Object]|>, fitPacket]]
	];
	(*list case*)
	(*  packetToUpload = Join[<|Object->Lookup[#, Object]|>, #]&/@fitPacket;*)
	(*  Upload[packetToUpload];*)

	<|
		Packet -> Join[
			<|
				Type -> Object[Analysis, Thermodynamics],
				Name -> name,
				AffinityConstants -> affinityConstants,
				EquilibriumType -> etype,
				Fit -> Link[Lookup[fitPacket, Object], Reference],
				Append[Reference] -> Flatten[mpLinks]
			|>,
			thermoFields
		],
		Intermediate -> <|
			FitPacket -> fitPacket
		|>
	|>
];

(* calculate affinity constants (Ka or Keq) for each point in the transition region*)
computeAffinityConstants[protocolPackets_,dataPackets_, mpPackets_,eqType_]:=Module[{
	rUnitless,initConc,meltingTemp,resolvedPoints,cleanPoints,meltingTempRaw, initConcRaw
},

	rUnitless = Unitless[MolarGasConstant,CaloriePerMoleKelvin];

	initConcRaw = resolveAnalyzeThermodynamicsConcentrations[protocolPackets,dataPackets];

	If[MatchQ[initConcRaw,$Failed] || MemberQ[initConcRaw,$Failed],
		Return[$Failed]
	];

	If[Length[DeleteDuplicates[initConcRaw]]<2,
		Message[Error::TooFewPoints];
		Return[$Failed]
	];

	meltingTempRaw = Lookup[mpPackets,MeanMeltingTemperature];

	initConc=N@Unitless[initConcRaw,Molar];
	meltingTemp=N@Unitless[meltingTempRaw,Kelvin];

	resolvedPoints = resolveMeltingConcentrationPoints[meltingTemp,initConc,All];

	If[
		MemberQ[resolvedPoints,{_,Null|_?PossibleZeroQ}],
		Message[AnalyzeThermodynamics::BadPoints]
	];

	cleanPoints = DeleteCases[resolvedPoints,{_,Null|_?PossibleZeroQ},{1}];

	(* Using kinetic relations, calculate affinity constants (Ka or Keq) for each point in the transition region - this is dependent on the reaction type *)
	Switch[eqType,
		BimolecularHomogenous,
			MapThread[{1./#1,-Log[#2]}&,Transpose[cleanPoints]],
		BimolecularHeterogenous,
			MapThread[{1./#1,-Log[#2/2]}&,Transpose[cleanPoints]],
		_,
		cleanPoints
	]

];


(*return raw concentration values to calculate affinity constants*)
resolveAnalyzeThermodynamicsConcentrations[prots_,datas_]:=Module[{
	samples,sampleComposition,analyteConcentration,assoc
},

	(*a subset of samples that contains available data object*)
	samples = protocolFilter[prots,WorkingSamples,Data,Lookup[datas,Object]];

	(*create a mapping between samples to their composition, then the chosen samples get their Composition by Map*)
	assoc = AssociationThread[First[Lookup[prots, WorkingSamples]], First[Lookup[prots, Composition]]];
	sampleComposition = Map[assoc[#]&, samples];

	(* resolve the QuantificationAnalyte option *)
	analyteConcentration = FirstCase[#,{___,ObjectP[Model[Molecule,Oligomer]]},{Null,Null}][[1]]&/@sampleComposition;

	If[MemberQ[analyteConcentration,Null],
		Message[Error::MissingConcentration,
			Pick[Lookup[datas, SamplesIn],analyteConcentration,Null]
		];
		Return[$Failed]
	];

	(* when more than one sample, take min, because that's limiting concentration for pairing product *)
	Min/@analyteConcentration

];

(*return processed or un-processed concentration values*)
resolveMeltingConcentrationPoints[mps:{NumberP...},concs:{(NumberP|Null)...},All]:=Transpose[{mps,concs}];
resolveMeltingConcentrationPoints[mps:{{NumberP..}..},concs:{(NumberP|Null)...},All]:=Flatten[MapThread[Thread[{#1,#2}]&,{mps,concs}],1];
resolveMeltingConcentrationPoints[mps:{{NumberP..}..},concs:{(NumberP|Null)...},Mean]:=MapThread[{Mean[#1],#2}&,{mps,concs}];


(*Use the van't Hoff relationship to calculate Entropy and Enthalpy (of binding)*)
computeThermodynamicsFit[in:(Null|$Failed),resolvedOps_]:=in;
computeThermodynamicsFit[_,resolvedOps:$Failed]:=resolvedOps;
computeThermodynamicsFit[affinityConstants_,resolvedOps_]:=Module[{
	initConc,meltingTemp,submethod,dataPoints, fitID,
	thermoExpression, vHFit, fitPacket, rUnitless
},


	(* Use the van't Hoff relationship to calculate Entropy and Enthalpy (of binding) *)

	(*
    Majority of computations are done unitless because some of mathematica's fitting and stats stuff can't handle units.
    Then we add them back when going into the packet
  *)


	(*
    \[CapitalDelta]G\[Equal]\[CapitalDelta]H-T \[CapitalDelta]S
    \[CapitalDelta]G\[Equal]-R T Log[Keq]
    -R T Log[Keq]==\[CapitalDelta]H-T \[CapitalDelta]S
    Log[Keq]==\[CapitalDelta]H/(R*T)- \[CapitalDelta]S/R
    Log[Keq] == (\[CapitalDelta]H/R)*(1/T) - (\[CapitalDelta]S/R)
    y = -(\[CapitalDelta]H/R)*x + (\[CapitalDelta]S/R)
    y - Log[Keq]
    x - 1/T
    Minus sign appears because Log[Keq] is Log[1/conc] = -Log[conc]
    Multiple dH by 1000 b/c dS*T comes out in Cal/Mole, while dH comes out in kCal/Mole
  *)
	rUnitless = Unitless[MolarGasConstant,CaloriePerMoleKelvin];
	thermoExpression = -(dH/R*1000)*#+(dS/R)&/.{R->rUnitless};
	(*
    Need the packet here.  If using App, user can override, so need to handle those cases
  *)
	fitPacket = AnalyzeFit[affinityConstants,thermoExpression,Upload->False,ReferenceField->MeltingPoint];
	fitID = CreateID[Object[Analysis,Fit]];

	Prepend[
		KeyDrop[fitPacket,{Reference,Append[Reference],Replace[Reference]}],
		Object->fitID
	]

];

(*calculate all necessary thermo field values in the output.*)
calculateAnalyzeThermodynamicsThermoFields[in:(Null|$Failed)]:=in;
calculateAnalyzeThermodynamicsThermoFields[fitPacket_]:=Module[
	{
		safeNormalDistribution, addUnits, dHUnit, dSUnit, dGUnit,
		entropy,entropyStdDev,entropyDist,enthalpy,enthalpyStdDev,enthalpyDist,
		feExpr,feStats, fe, feStdDev, feDist
	},

	safeNormalDistribution[Null,_]:=Null;
	safeNormalDistribution[_,Null]:=Null;
	safeNormalDistribution[m_,s_]:=NormalDistribution[m,s];

	addUnits[Null,_]:=Null;
	addUnits[d_?DistributionParameterQ,un_]:=QuantityDistribution[d,un];
	addUnits[val_,un_]:=Quantity[val,un];

	(* Entropy: fit parameter dS *)
	(*packetLookup[] is a function from Utilities.m*)
	{entropy,entropyStdDev} = Rest[Last[Sort[packetLookup[fitPacket,BestFitParameters]]]];

	entropyDist = safeNormalDistribution[entropy,entropyStdDev];

	(* Enthalpy: fit parameter dH *)
	{enthalpy,enthalpyStdDev} = Rest[First[Sort[packetLookup[fitPacket,BestFitParameters]]]];
	enthalpyDist = safeNormalDistribution[enthalpy,enthalpyStdDev];

	(* FreeEnergy: \[CapitalDelta]G\[Equal]\[CapitalDelta]H-T \[CapitalDelta]S, evaluated at T=37Celsius *)
	feExpr = ((\[CapitalDelta]H*1000)-T \[CapitalDelta]S)/1000; (* scaling is b/c units. cal vs kcal *)
	feStats = If[Or[MatchQ[entropyDist,Null],MatchQ[enthalpyDist,Null]],
		{Mean -> ReplaceAll[feExpr, { \[CapitalDelta]S -> entropy, \[CapitalDelta]H -> enthalpy, T -> Unitless[37Celsius,Kelvin] }], StandardDeviation->Null,Distribution->Null},
		PropagateUncertainty[ feExpr, { \[CapitalDelta]S \[Distributed] entropyDist, \[CapitalDelta]H \[Distributed] enthalpyDist, T -> Unitless[37Celsius,Kelvin] }, Output->All]
	];

	{fe,feStdDev,feDist} = Lookup[feStats,{Mean,StandardDeviation,Distribution}];

	(* base thermo units *)
	dHUnit = KilocaloriePerMole;
	dSUnit = CaloriePerMoleKelvin;
	dGUnit = KilocaloriePerMole;

	<|
		Entropy -> addUnits[entropy, dSUnit],
		EntropyStandardDeviation -> addUnits[entropyStdDev, dSUnit],
		EntropyDistribution -> addUnits[entropyDist,dSUnit],
		Enthalpy -> addUnits[enthalpy, dHUnit],
		EnthalpyStandardDeviation -> addUnits[enthalpyStdDev, dHUnit],
		EnthalpyDistribution -> addUnits[enthalpyDist,dHUnit],
		FreeEnergy -> addUnits[fe, dGUnit],
		FreeEnergyStandardDeviation -> addUnits[feStdDev, dGUnit],
		FreeEnergyDistribution -> addUnits[feDist,dGUnit]
	|>
];

(*generate a plot for preview*)
previewAnalyzeThermodynamics[KeyValuePattern[{
	Intermediate -> KeyValuePattern[{
		FitPacket -> fitPacket_
	}],
	OutputList -> outputList_,
	Packet -> thermodynamicPacket_
}]]:=Module[{fig, plotPacket},
	If[Not[MemberQ[outputList, Preview]], Return[<||>]];
	(*It will replace Fit by packet instead of link to object Fit to avoid the case when Fit object is not uploaded yet*)
	plotPacket = Join[thermodynamicPacket, <|Fit->fitPacket|>];
	fig = Zoomable@PlotThermodynamics[plotPacket];
	<|
		Preview -> fig
	|>

];
