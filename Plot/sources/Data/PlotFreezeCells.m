(* ::Package:: *)

(* ::Text:: *)
(*\[Copyright] 2011-2024 Emerald Cloud Lab, Inc.*)


(* ::Subsection:: *)
(*PlotFreezeCells*)
DefineOptions[PlotFreezeCells,
	Options :> {
		IndexMatching[
			{
				OptionName -> FreezingStrategy,
				Default -> Automatic,
				Description -> "Indicates which FreezingStrategy the data is associated with.",
				ResolutionDescription -> "Automatically set to InsulatedCooler if the Freezer or the DevicesMonitored is a static freezer, or ControlledRateFreezer if the Freezer or the DevicesMonitered is a controlled rate freezer.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Enumeration,
					Pattern :> FreezeCellMethodP
				],
				Category -> "Hidden"
			},
			{
				OptionName -> ExpectedTemperatureData,
				Default -> Automatic,
				Description -> "The desired programmed temperature profile or static temperature of the cooling block as a function of time.",
				AllowNull -> True,
				Widget -> Alternatives[
					"Static Temperature" -> Widget[
						Type -> Quantity,
						Pattern :> RangeP[-86 Celsius, -15 Celsius],
						Units -> Alternatives[Celsius]
					],
					"TemperatureProfile" -> Widget[
						Type -> Expression,
						Pattern :> (ListableP[UnitCoordinatesP[], 2]|ListableP[QuantityArrayP[], 2]),
						Size -> Paragraph
					]
				],
				Category -> "Hidden"
			},
			IndexMatchingInput -> "dataObject"
		],
		{
			OptionName -> TimeDisplayStyle,
			Default -> Absolute,
			Description -> "The format in which the data is displayed. When set to Absolute, the real date information is displayed. Otherwise, the relative time course is displayed.",
			AllowNull -> False,
			Widget -> Widget[
				Type -> Enumeration,
				Pattern :> Alternatives[Absolute, Relative]
			],
			Category -> "Plot Style"
		},
		ModifyOptions[
			EmeraldDateListPlot,
			{OptionName -> ImageSize, Default -> 500}
		],
		(* Inherit options without modification *)
		OutputOption
	}
];

Error::PlotFreezeCellsObjectNotFound = "The specified object `1` cannot be found in the database. Please check the objects' IDs or names.";
Error::PlotFreezeCellsIncompatibleData = "The specified object `1` is not associated with a valid cell freezing protocol. Please check whether this data object was generated by a completed FreezeCells protocol.";
Error::PlotFreezeCellsNoAssociatedDataObject = "The input protocol `1` has no associated data. Please check whether this protocol object has been completed.";

(* Protocol overload *)
PlotFreezeCells[myInput: ObjectP[Object[Protocol, FreezeCells]], myOptions: OptionsPattern[PlotFreezeCells]] := Module[
	{
		objectExistsQ, safeOps, freezerEnvironmentalData, freezers, temperatureProfile, defaultTemperatures, controlledRateFreezerQ,
		numberOfData, resolvedFreezingStrategy, resolvedExpectedTemperatureData
	},

	(* Check if the input exists in the database *)
	objectExistsQ = DatabaseMemberQ[myInput];
	(* If object doesn't exist, return $Failed with an error *)
	If[!objectExistsQ,
		Module[{},
			Message[Error::PlotFreezeCellsObjectNotFound, Experiment`Private`samplesForMessages[{myInput}]];
			Return[$Failed]
		]
	];

	(* Check safe options *)
	safeOps = SafeOptions[PlotFreezeCells, ToList[myOptions]];

	(* Download what we need from the input. *)
	{
		freezerEnvironmentalData,
		freezers,
		temperatureProfile,
		defaultTemperatures
	} = Quiet[
		Download[
			myInput,
			{
				FreezerEnvironmentalData,
				Freezers,
				TemperatureProfile,
				Freezers[Model][DefaultTemperature]
			}]
	];

	(* If the input is no associated data, throw an error. *)
	If[!MemberQ[freezerEnvironmentalData, ObjectP[Object[Data, Temperature]]],
		Message[Error::PlotFreezeCellsNoAssociatedDataObject, Experiment`Private`samplesForMessages[{myInput}]];
		Return[$Failed]
	];

	numberOfData = Length@Cases[freezerEnvironmentalData, ObjectP[Object[Data, Temperature]]];
	(* Use the Freezers field to check whether this a ControlledRateFreezer protocol. The protocol should have the same FreezingStrategy across different inputs. *)
	controlledRateFreezerQ = MemberQ[ToList[freezers], ObjectP[{Object[Instrument, ControlledRateFreezer], Model[Instrument, ControlledRateFreezer]}]];
	resolvedFreezingStrategy = If[TrueQ[controlledRateFreezerQ],
		ControlledRateFreezer,
		InsulatedCooler
	];

	resolvedExpectedTemperatureData = Which[
		TrueQ[controlledRateFreezerQ], Reverse /@ temperatureProfile,
		MatchQ[defaultTemperatures, {TemperatureP..}] && SameQ @@ defaultTemperatures, defaultTemperatures[[1]],
		(* If the default temperatures are a mix of -20C, -80C, decide index-matching temperature in the core overload later *)
		True, Automatic
	];

	If[Length[freezerEnvironmentalData] == 1,
		PlotFreezeCells[
			Download[freezerEnvironmentalData[[1]], Object],
			Sequence@ReplaceRule[
				ToList@myOptions,
				{
					FreezingStrategy -> resolvedFreezingStrategy,
					ExpectedTemperatureData -> resolvedExpectedTemperatureData
				}
			]
		],
		(* Call the data overload *)
		PlotFreezeCells[
			Download[freezerEnvironmentalData, Object],
			Sequence@ReplaceRule[
				ToList@myOptions,
				{
					FreezingStrategy -> resolvedFreezingStrategy,
					ExpectedTemperatureData -> resolvedExpectedTemperatureData
				}
			]
		]
	]
];

(* List overload *)
PlotFreezeCells[myInputs: {ObjectP[Object[Data, Temperature]]..}, myOptions: OptionsPattern[PlotFreezeCells]] := Module[
	{safeOps, output, expandedSafeOps, objectExistsQ, allPlots, finalPlot},

	(* Check safe options *)
	safeOps = SafeOptions[PlotFreezeCells, ToList[myOptions]];
	output = Lookup[safeOps, Output];
	expandedSafeOps = ExpandIndexMatchedInputs[PlotFreezeCells, {myInputs}, safeOps][[2]];

	(* Check if the input exists in the database *)
	objectExistsQ = DatabaseMemberQ[myInputs];

	(* If object doesn't exist, return $Failed with an error *)
	If[!objectExistsQ,
		Module[{},
			Message[Error::PlotFreezeCellsObjectNotFound, Experiment`Private`samplesForMessages[ToList@myInputs]];
			Return[$Failed]
		]
	];

	(* Call the core function *)
	(* remove the Output and OutputFormat option before passing to the core function because it doesn't make sense here *)
	allPlots = If[MemberQ[ToList@output, Result|Preview],
		Check[
			MapThread[
				PlotFreezeCells[
					#1,
					Sequence@ReplaceRule[
						ToList@myOptions,
						{
							FreezingStrategy -> #2,
							ExpectedTemperatureData -> #3,
							Output -> Result
						}
					]
				]&,
				{myInputs, Lookup[expandedSafeOps, FreezingStrategy], Lookup[expandedSafeOps, ExpectedTemperatureData]}
			],
			$Failed,
			{Error::PlotFreezeCellsObjectNotFound, Error::PlotFreezeCellsIncompatibleData}
		],
		Null
	];
	If[MatchQ[allPlots, $Failed], Return[$Failed], Nothing];

	(* Return the tab view *)
	finalPlot = If[MemberQ[ToList@output, Result|Preview],
		TabView[MapThread[(ToString[#1] -> #2)&, {myInputs, allPlots}]],
		Null
	];

	(* Return specified output *)
	output /.{
		Result -> finalPlot,
		Preview -> finalPlot/. If[MemberQ[ToList@myOptions, ImageSize -> _], {}, {Rule[ImageSize, _] :> Rule[ImageSize, Full]}],
		Tests -> {},
		Options -> {
			TimeDisplayStyle -> Lookup[safeOps, TimeDisplayStyle],
			ImageSize -> Lookup[safeOps, ImageSize],
			Output -> output
		}
	}
];

$TemperaturePlotRange = {-90, 35};
(* Core Overload *)
PlotFreezeCells[myInput: ObjectP[Object[Data, Temperature]], myOptions: OptionsPattern[PlotFreezeCells]] := Module[
	{
		objectExistsQ, safeOps, freezingStrategy, expectedTemperatureData, timeDisplayStyle, output, freezer, measuredTemperatureData,
		temperatureProfile, protocol, defaultTemperature, insulatedCoolerFreezingTime, timeStart, timeStop, resolvedFreezingStrategy,
		resolvedExpectedTemperatureData, trimmedMeasuredTemperatureData, sensorPlotRange, plot, imageSize
	},

	(* Check if the input exists in the database *)
	objectExistsQ = DatabaseMemberQ[myInput];

	(* If object doesn't exist, return $Failed with an error *)
	If[!objectExistsQ,
		Module[{},
			Message[Error::PlotFreezeCellsObjectNotFound, Experiment`Private`samplesForMessages[ToList@myInput]];
			Return[$Failed]
		]
	];

	(* Check safe options and pull out options *)
	safeOps = SafeOptions[PlotFreezeCells, ToList[myOptions]];
	{
		freezingStrategy,
		expectedTemperatureData,
		timeDisplayStyle,
		imageSize,
		output
	} = Lookup[
		safeOps,
		{
			FreezingStrategy,
			ExpectedTemperatureData,
			TimeDisplayStyle,
			ImageSize,
			Output
		}
	];

	(* Download what we need from the input. *)
	{
		freezer,
		measuredTemperatureData,
		protocol,
		temperatureProfile,
		defaultTemperature,
		insulatedCoolerFreezingTime,
		timeStart,
		timeStop
	} = Quiet @ Download[
		myInput,
		{
			Sensor[DevicesMonitored],
			TemperatureLog,
			Protocol,
			Protocol[TemperatureProfile],
			Sensor[DevicesMonitored][Model][DefaultTemperature],
			Protocol[InsulatedCoolerFreezingTime],
			FirstDataPoint,
			LastDataPoint
		}
	];

	(* Use the Freezers field to check whether this a ControlledRateFreezer protocol. *)
	resolvedFreezingStrategy = Which[
		MatchQ[freezingStrategy, FreezeCellMethodP], freezingStrategy,
		MatchQ[freezer, {ObjectP[{Object[Instrument, ControlledRateFreezer], Model[Instrument, ControlledRateFreezer]}]..}], ControlledRateFreezer,
		MatchQ[freezer, {ObjectP[{Object[Instrument, Freezer], Model[Instrument, Freezer]}]..}], InsulatedCooler,
		True, Null
	];

	resolvedExpectedTemperatureData = Which[
		MatchQ[resolvedFreezingStrategy, ControlledRateFreezer] && MatchQ[timeStart, _?DateObjectQ],
			Module[{originalReversedTemperatureProfile, expandedTemperatureProfile},
				originalReversedTemperatureProfile = If[MatchQ[expectedTemperatureData, {{TimeP, TemperatureP}..}],
					expectedTemperatureData,
					Reverse /@ temperatureProfile
				];
				(* Add {0Min,25C} to it*)
				expandedTemperatureProfile = If[MatchQ[originalReversedTemperatureProfile[[1]], {EqualP[0Minute], EqualP[25Celsius]}],
					originalReversedTemperatureProfile,
					Join[{{0Minute, 25 Celsius}}, originalReversedTemperatureProfile]
				];
				If[MatchQ[timeDisplayStyle, Relative],
					expandedTemperatureProfile,
					{#[[1]]+timeStart, #[[2]]}&/@expandedTemperatureProfile
				]
			],
		MatchQ[resolvedFreezingStrategy, InsulatedCooler] && MatchQ[timeStart, _?DateObjectQ] && MatchQ[timeStop, _?DateObjectQ],
			Module[{originalDefaultTemperature},
				originalDefaultTemperature = If[MatchQ[expectedTemperatureData, TemperatureP],
					expectedTemperatureData,
					defaultTemperature[[1]]
				];
				If[MatchQ[timeDisplayStyle, Relative],
					({#, originalDefaultTemperature}&/@Range[0 Minute, Max[timeStop -timeStart, 1Minute], 1Minute]),
					({#, originalDefaultTemperature}&/@Range[timeStart, timeStop, 1Minute])
				]
			],
		(* If the default temperatures are a mix of -20C, -80C, decide index-matching temperature in the core overload later *)
		True,
			Null
	];

	(* Check the associated data or protocol object and throw errors if needed. *)
	If[Or[
		!MatchQ[protocol, ObjectP[Object[Protocol, FreezeCells]]],
		!MatchQ[timeStart, _?DateObjectQ],
		!MatchQ[timeStop, _?DateObjectQ],
		!MatchQ[freezer, {ObjectP[{Object[Instrument, Freezer], Object[Instrument, ControlledRateFreezer]}]..}],
		!MatchQ[measuredTemperatureData, _QuantityArray],
		NullQ[resolvedFreezingStrategy],
		NullQ[resolvedExpectedTemperatureData]
		],
		Message[Error::PlotFreezeCellsIncompatibleData, Experiment`Private`samplesForMessages[{myInput}]];
		Return[$Failed]
	];

	trimmedMeasuredTemperatureData = If[MatchQ[timeDisplayStyle, Relative],
		{DateDifference[timeStart, QuantityMagnitude[#[[1]]], "Minute"], #[[2]]} & /@ measuredTemperatureData,
		measuredTemperatureData
	];

	sensorPlotRange = If[MatchQ[timeDisplayStyle, Relative],
		{{0 Minute, If[MatchQ[resolvedFreezingStrategy, InsulatedCooler], insulatedCoolerFreezingTime, FirstCase[Last@temperatureProfile, TimeP]]}, $TemperaturePlotRange},
		{Automatic, $TemperaturePlotRange}
	];

	(* Plot the data for controlled rate freezer batches, and print a message if the user attempts to plot an insulated cooler protocol *)
	(* and somehow gets past the error checks above when doing so. *)
	plot = If[MatchQ[timeDisplayStyle, Relative],
		EmeraldListLinePlot[
			{resolvedExpectedTemperatureData, trimmedMeasuredTemperatureData},
			Legend -> {"Expected Temperature", "Measured Temperature"},
			PlotRange -> sensorPlotRange,
			ImageSize -> imageSize,
			Zoomable -> True,
			LabelStyle -> Directive[Bold, GrayLevel[0.3]]
		],
		EmeraldDateListPlot[
			{resolvedExpectedTemperatureData, measuredTemperatureData},
			Legend -> {"Expected Temperature", "Measured Temperature"},
			PlotRange -> sensorPlotRange,
			ImageSize -> imageSize,
			Zoomable -> True,
			DateTicksFormat -> {"MonthShort", "/", "DayShort","/","YearShort" ,"-" ,"Hour24",":","Minute"},
			LabelStyle -> Directive[Bold, GrayLevel[0.3]]
		]
	];

	(* Return specified output *)
	output /.{
		Result -> plot,
		Preview -> plot/. If[MemberQ[ToList@myOptions, ImageSize -> _], {}, {Rule[ImageSize, _] :> Rule[ImageSize, Full]}],
		Tests -> {},
		Options -> {
			TimeDisplayStyle -> timeDisplayStyle,
			ImageSize -> imageSize,
			Output -> output
		}
	}

];