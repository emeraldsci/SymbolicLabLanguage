(* ::Package:: *)

(* ::Text:: *)
(*\[Copyright] 2011-2024 Emerald Cloud Lab, Inc.*)


(* ::Subsection:: *)
(*PlotFreezeCells*)


Error::PlotFreezeCellsObjectNotFound = "Specified object `1` cannot be found in the database. Please check the objects' IDs or names.";
Error::PlotFreezeCellsIncompatibleFreezingStrategy = "Specified object `1` is not associated with a cell freezing protocol which used a ControlledRateFreezer freezing strategy. PlotFreezeCells is not compatible with data from insulated cooler protocols, which occur in static temperature freezers. Please check whether this data object was generated by a FreezeCells protocol with the Freezers field accurately informed.";
Error::PlotFreezeCellsNoAssociatedDataObject = "Specified input `1` is not associated with a data object. Please associate `1` with a data object or run PlotFreezeCells on the intended data object directly.";

(* List overload *)
PlotFreezeCells[myInputs:{ObjectP[{Object[Protocol,FreezeCells],Object[Data,FreezeCells]}]..},myOptions:OptionsPattern[PlotFreezeCells]] := TabView[ToString[#] -> PlotFreezeCells[#,myOptions]&/@myInputs];

(* Core Overload *)
PlotFreezeCells[myInput:ObjectP[{Object[Protocol,FreezeCells],Object[Data,FreezeCells]}],myOptions:OptionsPattern[PlotFreezeCells]]:=Module[
	{
		objectExistsQ, expectedTempDataField, measuredTempDataField, freezersField, freezers,
		expectedTemperatureDataFromDownload, measuredTemperatureDataFromDownload, expectedTemperatureData, measuredTemperatureData,
		associatedDataObject, associatedProtocolObject, controlledRateFreezerQ
	},

	(* Check if the input exists in the database *)
	objectExistsQ = DatabaseMemberQ[myInput];

	(* If object doesn't exist, return $Failed with an error *)
	If[
		!objectExistsQ,
		Module[{},
			Message[Error::PlotFreezeCellsObjectNotFound, myInput];
			Return[$Failed]
		]
	];

	(* The fields to download depend on whether the input is a protocol or data object. *)
	{expectedTempDataField, measuredTempDataField, freezersField} = If[
		MatchQ[myInput, ObjectP[Object[Protocol, FreezeCells]]],
		{Data[ExpectedTemperatureData], Data[MeasuredTemperatureData], Freezers},
		{ExpectedTemperatureData, MeasuredTemperatureData, Protocol[Freezers]}
	];

	(* Download what we need from the input. *)
	{
		freezers,
		expectedTemperatureDataFromDownload,
		measuredTemperatureDataFromDownload,
		associatedDataObject,
		associatedProtocolObject
	} = Quiet @ Download[myInput,
		{
			freezersField,
			expectedTempDataField,
			measuredTempDataField,
			Data,
			Protocol
		}
	];

	(* The Data has an extra level of listed-ness if the input is a protocol, so Flatten at level 1 if we have to. *)
	{expectedTemperatureData, measuredTemperatureData} = If[
		MatchQ[myInput, ObjectP[Object[Protocol, FreezeCells]]],
		Flatten[#, 1] & /@ {expectedTemperatureDataFromDownload, measuredTemperatureDataFromDownload},
		{expectedTemperatureDataFromDownload, measuredTemperatureDataFromDownload}
	];

	(* Use the Freezers field to check whether this a ControlledRateFreezer protocol. *)
	controlledRateFreezerQ = MemberQ[ToList[freezers], ObjectP[{Object[Instrument, ControlledRateFreezer], Model[Instrument, ControlledRateFreezer]}]];

	(* Check the associated data or protocol object and throw errors if needed. *)
	Which[

		(* If the relevant Object[Protocol, FreezeCells] did not use a ControlledRateFreezer strategy, throw an error. *)
		!controlledRateFreezerQ,
			Module[{},
				Message[Error::PlotFreezeCellsIncompatibleFreezingStrategy, myInput];
				Return[$Failed]
			],

		(* If the input is a controlled rate freezer protocol without associated data, throw an error. *)
		And[
			controlledRateFreezerQ,
			MatchQ[myInput, ObjectP[Object[Protocol, FreezeCells]]],
			!MemberQ[ToList[associatedDataObject], ObjectP[Object[Data, FreezeCells]]]
		],
		Module[{},
			Message[Error::PlotFreezeCellsNoAssociatedDataObject, myInput];
			Return[$Failed]
		],

		(* Otherwise, just continue without throwing errors. *)
		True,
			Nothing
	];
	
	(* Plot the data for controlled rate freezer batches, and print a message if the user attempts to plot an insulated cooler protocol *)
	(* and somehow gets past the error checks above when doing so. *)
	If[
		controlledRateFreezerQ,
		EmeraldListLinePlot[
			{expectedTemperatureData, measuredTemperatureData},
			Legend -> {"Expected Temperature", "Measured Temperature"},
			Zoomable -> True,
			LabelStyle -> Directive[Bold, GrayLevel[0.3]]
		],
		"No data is generated for protocols using the InsulatedCooler freezing strategy."
	]

];