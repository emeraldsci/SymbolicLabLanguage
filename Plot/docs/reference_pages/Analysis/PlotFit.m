(* ::Package:: *)

(* ::Text:: *)
(*\[Copyright] 2011-2023 Emerald Cloud Lab, Inc.*)


(* ::Subsubsection::Closed:: *)
(*PlotFit*)


DefineUsage[PlotFit,
{
	BasicDefinitions -> {
		{
			Definition -> {"PlotFit[xy, f]", "plot"},
			Description -> "overlays the fitted function 'f'[x] on the data points 'xy'.",
			Inputs :> {
				{
					InputName -> "xy",
					Description -> "List of raw data points that were fit to.",
					Widget->Alternatives[
						"Data Points"->Adder[{
							"x"->Widget[Type->Expression,Pattern:>UnitsP[],Size->Word,PatternTooltip->"Input must match UnitsP[]"],
							"y"->Widget[Type->Expression,Pattern:>UnitsP[],Size->Word,PatternTooltip->"Input must match UnitsP[]"]
						}],
						"Other"->Widget[Type->Expression, Pattern:>(MatrixP[UnitsP[] | _?DistributionParameterQ | ObjectReferenceP[] | FieldReferenceP[]] | _?QuantityMatrixQ | {({UnitsP[]..} | {ObjectP[]..} | {FieldReferenceP[]..} | ObjectReferenceP[] | FieldReferenceP[])..}),Size->Paragraph,PatternTooltip->"Any valid input to AnalyzeFit."]
					]
				},
				{
					InputName -> "f",
					Description -> "The fitted function.",
					Widget -> Widget[Type-> Expression, Pattern:>FunctionP, Size->Line, PatternTooltip->"A Function[] mapping single input x to y."]
				}
			},
			Outputs :> {
				{
					OutputName -> "plot",
					Description -> "A plot of the fitted function overlaid on the data (possibly with error bars).",
					Pattern :> _Graphics
				}
			}
		},
		{
			Definition -> {"PlotFit[fit]", "plot"},
			Description -> "overlays the fitted function from the 'fit' object onto the data points used to construct the fit.",
			Inputs :> {
				{
					InputName -> "fit",
					Description -> "A fit object or packet generated by AnalyzeFit[].",
					Widget->Widget[Type->Object,Pattern:>ObjectP[Object[Analysis,Fit]]]
				}
			},
			Outputs :> {
				{
					OutputName -> "plot",
					Description -> "A plot of the fitted function overlaid on the data (possibly with error bars).",
					Pattern :> _Graphics
				}
			}
		}
	},
	SeeAlso -> {
		"AnalyzeFit",
		"AnalyzeQuantificationCycle",
		"PlotPrediction"
	},
	Author->{"dirk.schild", "kevin.hou", "brad"},
	Preview->True
}];


(* ::Subsubsection::Closed:: *)
(*PlotFitOptions*)


DefineUsage[PlotFitOptions,
{
	BasicDefinitions -> {
		{
			Definition -> {"PlotFitOptions[xy, f]", "options"},
			Description -> "returns the resolved 'options' for PlotFit['xy', 'f'].",
			Inputs :> {
				{
					InputName -> "xy",
					Description -> "List of raw data points that were fit to.",
					Widget -> Alternatives[
						"Data Points"->Adder[{
							"x"->Widget[Type->Expression,Pattern:>UnitsP[],Size->Word,PatternTooltip->"Input must match UnitsP[]"],
							"y"->Widget[Type->Expression,Pattern:>UnitsP[],Size->Word,PatternTooltip->"Input must match UnitsP[]"]
						}],
						"Other"->Widget[Type->Expression, Pattern:>(MatrixP[UnitsP[] | _?DistributionParameterQ | ObjectReferenceP[] | FieldReferenceP[]] | _?QuantityMatrixQ | {({UnitsP[]..} | {ObjectP[]..} | {FieldReferenceP[]..} | ObjectReferenceP[] | FieldReferenceP[])..}),Size->Paragraph,PatternTooltip->"Any valid input to AnalyzeFit."]
					]
				},
				{
					InputName -> "f",
					Description -> "The fitted function.",
					Widget -> Widget[Type-> Expression, Pattern:>FunctionP, Size->Line, PatternTooltip->"A Function[] mapping single input x to y."]
				}
			},
			Outputs :> {
				{
					OutputName -> "options",
					Description -> "The resolved options in the PlotFit call.",
					Pattern :> {Rule[_Symbol,Except[Automatic|$Failed]]|RuleDelayed[_Symbol,Except[Automatic|$Failed]]..}
				}
			}
		},
		{
			Definition -> {"PlotFitOptions[fit]", "options"},
			Description -> "returns the resolved 'options' for PlotFit['fit'].",
			Inputs :> {
				{
					InputName -> "fit",
					Description -> "A fit object or packet generated by AnalyzeFit[].",
					Widget->Widget[Type->Object,Pattern:>ObjectP[Object[Analysis,Fit]]]
				}
			},
			Outputs :> {
				{
					OutputName -> "options",
					Description -> "The resolved options in the PlotFit call.",
					Pattern :> {Rule[_Symbol,Except[Automatic|$Failed]]|RuleDelayed[_Symbol,Except[Automatic|$Failed]]..}
				}
			}
		}
	},
	SeeAlso -> {
		"AnalyzeFit",
		"AnalyzeFitOptions"
	},
	Author -> {"scicomp", "brad"}
}];


(* ::Subsubsection::Closed:: *)
(*PlotFitPreview*)


DefineUsage[PlotFitPreview,
{
	BasicDefinitions -> {
		{
			Definition -> {"PlotFitPreview[xy, f]", "preview"},
			Description -> "returns a graphical display representing the output of PlotFit['xy', 'f'].",
			Inputs :> {
				{
					InputName -> "xy",
					Description -> "List of raw data points that were fit to.",
					Widget -> Alternatives[
						"Data Points"->Adder[{
							"x"->Widget[Type->Expression,Pattern:>UnitsP[],Size->Word,PatternTooltip->"Input must match UnitsP[]"],
							"y"->Widget[Type->Expression,Pattern:>UnitsP[],Size->Word,PatternTooltip->"Input must match UnitsP[]"]
						}],
						"Other"->Widget[Type->Expression, Pattern:>(MatrixP[UnitsP[] | _?DistributionParameterQ | ObjectReferenceP[] | FieldReferenceP[]] | _?QuantityMatrixQ | {({UnitsP[]..} | {ObjectP[]..} | {FieldReferenceP[]..} | ObjectReferenceP[] | FieldReferenceP[])..}),Size->Paragraph,PatternTooltip->"Any valid input to AnalyzeFit."]
					]
				},
				{
					InputName -> "f",
					Description -> "The fitted function.",
					Widget -> Widget[Type-> Expression, Pattern:>FunctionP, Size->Line, PatternTooltip->"A Function[] mapping single input x to y."]
				}
			},
			Outputs :> {
				{
					OutputName -> "preview",
					Description -> "The graphical display representing the PlotFit call output.",
					Pattern :> (ValidGraphicsP[] | Null)
				}
			}
		},
		{
			Definition -> {"PlotFitPreview[fit]", "preview"},
			Description -> "returns a graphical display representing the output of PlotFit['fit'].",
			Inputs :> {
				{
					InputName -> "fit",
					Description -> "A fit object or packet generated by AnalyzeFit[].",
					Widget->Widget[Type->Object,Pattern:>ObjectP[Object[Analysis,Fit]]]
				}
			},
			Outputs :> {
				{
					OutputName -> "preview",
					Description -> "The graphical display representing the PlotFit call output.",
					Pattern :> (ValidGraphicsP[] | Null)
				}
			}
		}
	},
	SeeAlso -> {
		"AnalyzeFit",
		"AnalyzeFitPreview"
	},
	Author -> {"scicomp", "brad"}
}];


(* ::Subsubsection::Closed:: *)
(*ValidPlotFitQ*)


DefineUsage[ValidPlotFitQ,
{
	BasicDefinitions -> {
		{
			Definition -> {"ValidPlotFitQ[xy, f]", "testSummary"},
			Description -> "returns an EmeraldTestSummary which contains the test results of PlotFit['xy', 'f'] for all the gathered tests/warnings, or a single Boolean indicating validity.",
			Inputs :> {
				{
					InputName -> "xy",
					Description -> "List of raw data points that were fit to.",
					Widget -> Alternatives[
						"Data Points"->Adder[{
							"x"->Widget[Type->Expression,Pattern:>UnitsP[],Size->Word,PatternTooltip->"Input must match UnitsP[]"],
							"y"->Widget[Type->Expression,Pattern:>UnitsP[],Size->Word,PatternTooltip->"Input must match UnitsP[]"]
						}],
						"Other"->Widget[Type->Expression, Pattern:>(MatrixP[UnitsP[] | _?DistributionParameterQ | ObjectReferenceP[] | FieldReferenceP[]] | _?QuantityMatrixQ | {({UnitsP[]..} | {ObjectP[]..} | {FieldReferenceP[]..} | ObjectReferenceP[] | FieldReferenceP[])..}),Size->Paragraph,PatternTooltip->"Any valid input to AnalyzeFit."]
					]
				},
				{
					InputName -> "f",
					Description -> "The fitted function.",
					Widget -> Widget[Type-> Expression, Pattern:>FunctionP, Size->Line, PatternTooltip->"A Function[] mapping single input x to y."]
				}
			},
			Outputs :> {
				{
					OutputName -> "testSummary",
					Description -> "The EmeraldTestSummary of PlotFit['xy', 'f'].",
					Pattern :> (EmeraldTestSummary| Boolean)
				}
			}
		},
		{
			Definition -> {"ValidPlotFitQ[fit]", "testSummary"},
			Description -> "returns an EmeraldTestSummary which contains the test results of PlotFit['fit'] for all the gathered tests/warnings, or a single Boolean indicating validity.",
			Inputs :> {
				{
					InputName -> "fit",
					Description -> "A fit object or packet generated by AnalyzeFit[].",
					Widget->Widget[Type->Object,Pattern:>ObjectP[Object[Analysis,Fit]]]
				}
			},
			Outputs :> {
				{
					OutputName -> "testSummary",
					Description -> "The EmeraldTestSummary of PlotFit['fit'].",
					Pattern :> (EmeraldTestSummary| Boolean)
				}
			}
		}
	},
	SeeAlso -> {
		"AnalyzeFit",
		"ValidAnalyzeFitQ"
	},
	Author -> {"scicomp", "brad"}
}];