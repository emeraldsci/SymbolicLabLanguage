(* ::Package:: *)

(* ::Text:: *)
(*\[Copyright] 2011-2023 Emerald Cloud Lab, Inc.*)


(* ::Subsubsection::Closed:: *)
(* ExperimentCapillaryELISA Options *)


DefineOptions[ExperimentCapillaryELISA,
    Options:>{
        {
            OptionName->Instrument,
            Default->Model[Instrument, CapillaryELISA, "id:XnlV5jKM7zPM"], (* Model[Instrument,CapillaryELISA,"Ella"] *)
            Description->"The detection and quantification capillary ELISA device on which the protocol is to be run. The instrument accepts the cartridge loaded with samples and buffers, loads the samples into the capillaries, performs the ELISA experiment and detects the signals to quantify certain analytes.",
            AllowNull->False,
            Widget->Widget[
                Type->Object,
              	Pattern:>ObjectP[{Model[Instrument,CapillaryELISA],Object[Instrument,CapillaryELISA]}]
            ],
            Category->"General"
        },
		{
			OptionName->CartridgeType,
			Default->Automatic,
			Description->"The type of capillary ELISA cartridge (SinglePlex72X1, MultiAnalyte32X4, MultiAnalyte16X4, MultiPlex32X8 or Customizable) that is used in the capillary ELISA experiment. For pre-loaded cartridge types, different cartridge types provide different numbers of capacity and throughput (Figure 3.1 in ExperimentCapillaryELISA help file).",
			ResolutionDescription->"CartridgeType is automatically selected based on the total number of samples (with standard samples and dilutions considered) and the Cartridge option. When the total number of samples is below or equal to 48 and Cartridge option is not Null, CartridgeType is set to Customizable. Otherwise it is set to SinglePlex72X1.",
			AllowNull->False,
			Widget->Widget[
				Type->Enumeration,
				Pattern:>ELISACartridgeTypeP
			],
			Category->"General"
		},
        {
            OptionName->Cartridge,
            Default->Automatic,
            Description->"The single-use capillary ELISA cartridge plate that is used in the instrument to provide the entire workflow of a sandwich ELISA assay and quantify the analytes (such as peptides, proteins, antibodies and hormones) in the samples. A customizable capillary ELISA cartridge Model[Container,Plate,Irregular,CapillaryELISA,\"Human 48-Digoxigenin Cartridge\"] uses an anti-digoxigenin antibody coating in GNR to serve as the foundation. Digoxigenin-modified capture antibody sample and biotinylated detection antibody sample are prepared prior to the experiment and loaded into the Cartridge for sandwich ELISA experiment of up to 48 samples. For pre-loaded cartridge types (all types except Customizable), the cartridge is loaded with capture antibody and detection antibody reagents, meaning that Cartridge option also determines the ELISA assay to be run and the analytes to be detected in the experiment. For the current list of available capillary ELISA cartridges, please perform Search[Model[Container,Plate,Irregular,CapillaryELISA]] with the desired CartridgeType, AnalyteMolecules or other conditions. If a new model of pre-loaded cartridge is required for the experiment, please set Cartridge option to Null and input more information in CartridgeType, Species and Analytes options. The new model is created and the cartridge is fulfilled accordingly. For a complete list of available analytes on pre-loaded cartridges and their ordering information, please refer to Object[Report,Literature,\"Simple Plex Assay Menu\"] and Object[ManufacturingSpecification,CapillaryELISACartridge] of different analytes for more details.",
            ResolutionDescription->"Cartridge option is automatically set to an in-stock pre-loaded cartridge object that matches the analytes presented in the samples. If no in-stock cartridge is available for the specified options and the total number of samples is below 48, Cartridge option is automatically resolved to the customizable capillary ELISA cartridge to eliminate material waiting time. Otherwise, a pre-loaded capillary ELISA cartridge model is selected or created, with an estimated lead time of 14 days after protocol confirmation.",
            AllowNull->True,
            Widget->Widget[
                Type->Object,
                Pattern:>ObjectP[{Model[Container,Plate,Irregular,CapillaryELISA],Object[Container,Plate,Irregular,CapillaryELISA]}],
                PreparedSample->False,
                PreparedContainer->False
            ],
            Category->"General"
        },
      	{
            OptionName->Species,
            Default->Human,
            Description->"The organism (human, mouse or rat) that the samples (containing analytes of interest) are derived from. This option is used to determine the available analytes for pre-loaded capillary ELISA cartridges.",
            AllowNull->False,
            Widget->Widget[
                Type->Enumeration,
                Pattern:>ELISASpeciesP
            ],
            Category->"General"
        },

		IndexMatching[
			IndexMatchingInput->"experiment samples",
			{
				OptionName->Analytes,
				Default->Automatic,
				Description->"The target(s) (e.g., peptides, proteins, antibodies, hormones) detected and quantified in each experiment sample. For customizable cartridge, only 1 analyte can be detected per sample. A pre-loaded cartridge is loaded with complete assay materials (capture antibody, detection antibody and fluorescent labelling reagent) for the selected analytes and all the samples are subject to the same analytes. For a complete list of available analytes of pre-loaded cartridges, please refer to Object[Report,Literature,\"Simple Plex Assay Menu\"]. To create a capillary ELISA cartridge with combination of multiple targets, please refer to Object[ManufacturingSpecification,CapillaryELISACartridge] of different analytes for more details about compatibility rules and ordering information. For SinglePlex72X1 cartridge type, only 1 analyte can be selected. For MultiAnalyte32X4 and MultiAnalyte16X4 cartridge types, up to 4 distinct analytes can be selected. For MultiPlex32X8 cartridge type, up to 8 analytes can be selected in Pro-Inflammation and Oncology panel only.",
				ResolutionDescription->"If a customizable cartridge is used, Analytes option is automatically set based on the presented analyte in the Analytes field or Composition field of each input sample. If Cartridge option is set to an existing model or object of pre-loaded capillary ELISA cartridge plate, Analytes option is automatically set to the Analytes of Cartridge option. If Cartridge option is set to Null, a new pre-loaded model of capillary ELISA cartridge is requested. In this case, Analytes option is set based on the selected CartridgeType, Species and presented analytes of the input sample objects (in Analytes field or Composition field).",
				AllowNull->True,
				Widget->Alternatives[
					"Single Analyte"->Alternatives[
						Widget[
							Type->Object,
							Pattern:>ObjectP[{Model[Molecule]}]
						],
						Widget[
							Type->Enumeration,
							Pattern:>CapillaryELISAAnalyteP
						]
					],
					"Multiplex"->Alternatives[
						Adder[
							Widget[
								Type->Object,
								Pattern:>ObjectP[{Model[Molecule]}]
							]
						],
						Adder[
							Widget[
								Type->Enumeration,
								Pattern:>CapillaryELISAAnalyteP
							]
						]
					]
				],
				Category->"General"
			}
		],

		IndexMatching[
			IndexMatchingInput->"experiment samples",
			{
				OptionName->SampleVolume,
				Default->Automatic,
				Description->"The initial sample amount aliquoted from the source of the input sample. If a SpikeSample is specified, this it the volume of the input sample to mix with SpikeVolume of SpikeSample before further dilution is performed.",
				ResolutionDescription->"SampleVolume is automatically set to 30 Microliter when SpikeSample is not Null.",
				AllowNull->True,
				Widget->Widget[
					Type->Quantity,
					Pattern:>GreaterP[1Microliter],
					Units->Alternatives[Microliter]
				],
				Category->"Sample Preparation"
			},
			{
				OptionName->SpikeSample,
				Default->Null,
				Description->"For each experiment sample, the sample with known concentration(s) of analyte(s) mixed with the input sample to increase the analytical response of the unknown sample, for evaluation of sample matrices in a new ELISA assay.",
				AllowNull->True,
				Widget->Widget[
					Type->Object,
					Pattern:>ObjectP[{Model[Sample],Object[Sample]}],
					PreparedContainer->False
				],
				Category->"Sample Preparation"
			},
			{
				OptionName->SpikeVolume,
				Default->Automatic,
				Description->"The volume of the SpikeSample mixed with the SampleVolume of the input sample before further dilution is performed.",
				ResolutionDescription->"SpikeVolume is automatically set to SampleVolume when SpikeSample is not Null.",
				AllowNull->True,
				Widget->Widget[
					Type->Quantity,
					Pattern:>GreaterP[1Microliter],
					Units->Alternatives[Microliter]
				],
				Category->"Sample Preparation"
			},
			{
				OptionName->SpikeSampleStorageCondition,
				Default->Null,
				Description->"For each SpikeSample, the non-default conditions under which it should be stored after the protocol is completed. If left unset, the SpikeSample will be stored according to their current StorageCondition.",
				AllowNull->True,
				Widget->Widget[
					Type->Enumeration,
					Pattern:>SampleStorageTypeP|Disposal
				],
				Category->"Post Experiment"
			},
			{
				OptionName->DilutionCurve,
				Default->Automatic,
				Description->"The collection of dilutions performed on each input sample (plus SpikeSample, if applicable). Dilution is required on all the loading samples for the best performance of microfluidics and the ELISA experiment is performed on all the diluted samples. For FixedDilutionVolume dilutions, the SampleAmount is the volume of the sample that is mixed with the DiluentVolume of the Diluent. For FixedDilutionFactor dilutions, the AssayVolume is the volume of the sample that is created after being diluted by the specified DilutionFactor. For a pre-loaded capillary ELISA cartridge, please refer to Object[ManufacturingSpecification,CapillaryELISACartridge] of the analytes for their recommended minimum dilution factors. For a customizable cartridge, a minimum dilution factor of 0.5 is suggested.",
				(*
				Description->"The collection of dilutions preformed on the input sample (plus SpikeSample, if applicable). The ELISA experiment is performed on all the diluted samples. For FixedDilutionVolume dilutions, the SampleAmount is the volume of the sample that is mixed with the DiluentVolume of the Diluent. For FixedDilutionFactor dilutions, the AssayVolume is the volume of the sample that is created after being diluted by the specified DilutionFactor. For DynamicDilutions, the AssayVolume is the preparation volume of each diluted sample. For LinearDilutions defined with volumes, the first diluted sample uses the specified StartingSampleAmount. Then for each diluted sample in the dilution series, the amount of the input sample increases by the SampleAmountIncrement until the desired NumberOfDilutions is reached. For LinearDilutions defined with dilution factors, the first diluted sample holds the specified StartingDilutionFactor. Then the dilution factor increases by DilutionFactorIncrement until the desired NumberOfDilutions is reached. For example, when AssayVolume is set to 60 Microliter, a StartingSampleAmount of 12 Microliter, a SampleAmountIncrement of 6 Microliter and a NumberOfDilution of 3 leads to 3 diluted samples with dilution factors of 0.2, 0.3, 0.4. The same diluted samples are prepared when StartingDilutionFactor is set to 0.2 with a DilutionFactorIncrement of 0.1. For a pre-loaded capillary ELISA cartridge, please refer to Object[ManufacturingSpecification,CapillaryELISACartridge] of the analytes for their recommended minimum dilution factors. For a customizable cartridge, a minimum dilution factor of 0.5 is suggested.",
				*)
				ResolutionDescription->"If SerialDilutionCurve is not uploaded, DilutionCurve option is automatically set to 1 dilution with DilutionFactor of the minimum required dilution factor to generate a AssayVolume of 60 Microliter.",
				AllowNull->True,
				Widget->Alternatives[
					"Fixed Dilution Volume"->Adder[
						List[
							"Sample Amount"->Widget[
								Type->Quantity,
								Pattern:>GreaterEqualP[0Microliter],
								Units->Alternatives[Microliter]
							],
							"Diluent Volume"->Widget[
								Type->Quantity,
								Pattern:>GreaterEqualP[0Microliter],
								Units->Alternatives[Microliter]
							]
						]
					],
					"Fixed Dilution Factor"->Adder[
						List[
							"Assay Volume"->Widget[
								Type->Quantity,
								Pattern:>GreaterEqualP[30Microliter],
								Units->Alternatives[Microliter]
							],
							"Dilution Factors"->Widget[
								Type->Number,
								Pattern:>RangeP[0,1]
							]
						]
					]
					(*
					"Dynamic Dilutions"->List[
						"Assay Volume"->Widget[
							Type->Quantity,
							Pattern:>GreaterEqualP[30Microliter],
							Units->Alternatives[Microliter]
						],
						"Linear Dilutions"->Alternatives[
							List[
								"Starting Sample Amount"->Widget[
									Type->Quantity,
									Pattern:>GreaterEqualP[0Microliter],
									Units->Alternatives[Microliter]
								],
								"Sample Amount Increment"->Widget[
									Type->Quantity,
									Pattern:>GreaterEqualP[0Microliter],
									Units->Alternatives[Microliter]
								]
							],
							List[
								"Starting Dilution Factor"->Widget[
									Type->Number,
									Pattern:>RangeP[0,1]
								],
								"Dilution Factor Increment"->Widget[
									Type->Number,
									Pattern:>RangeP[0,1]
								]
							]
						],
						"Number Of Dilutions"->Widget[
							Type->Number,
							Pattern:>GreaterP[1,1]
						]
					]
					*)
				],
				Category->"Sample Preparation"
			},
			{
				OptionName->SerialDilutionCurve,
				Default->Automatic,
				Description->"The collection of stepwise dilutions performed on each input sample (plus SpikeSample, if applicable). Dilution is required on all the loading samples for the best performance of microfluidics and the ELISA assay is performed on all the diluted samples. To use non-diluted input sample, the first dilution can be set to a dilution factor of 1. For SerialDilutionVolumes, the TransferVolume is taken out of the sample and added to a second well with the DiluentVolume of the Diluent. After thorough mixing, the TransferVolume is taken out of that well and added to a third well. This is repeated to make NumberofDilutions diluted samples. For SerialDilutionFactors, the sample is diluted by the dilution factor at each transfer step. For a pre-loaded capillary ELISA cartridge, please refer to Object[ManufacturingSpecification,CapillaryELISACartridge] of the analytes for their recommended minimum dilution factors. For a customizable cartridge, a minimum dilution factor of 0.5 is suggested.",
				ResolutionDescription->"If DilutionCurve option is Null, SerialDilutionCurve option is automatically set to 1 NumberOfDilutions with ConstantDilutionFactor of the recommended minimum dilution factor to generate a AssayVolume of 60 Microliter.",
				AllowNull->True,
				Widget->Alternatives[
					"Serial Dilution Volumes"->List[
						"Transfer Volume"->Widget[
							Type->Quantity,
							Pattern:>GreaterP[0Microliter],
							Units->Alternatives[Microliter]
						],
						"Diluent Volume"->Widget[
							Type->Quantity,
							Pattern:>GreaterEqualP[30Microliter],
							Units->Alternatives[Microliter]
						],
						"Number Of Dilutions"->Widget[
							Type->Number,
							Pattern:>GreaterP[1,1]
						]
					],
					"Serial Dilution Factor"->List[
						"Assay Volume"->Widget[
							Type->Quantity,
							Pattern:>GreaterEqualP[30Microliter],
							Units->Alternatives[Microliter]
						],
						"Dilution Factors"->Alternatives[
							"Constant"->List[
								"Constant Dilution Factor"->Widget[
									Type->Number,
									Pattern:>RangeP[0,1]
								],
								"Number Of Dilutions"->Widget[
									Type->Number,
									Pattern:>GreaterP[1,1]
								]
							],
							"Variable"->Adder[
								Widget[
									Type->Number,
									Pattern:>RangeP[0,1]
								]
							]
						]
					]
				],
				Category->"Sample Preparation"
			},
			{
				OptionName->Diluent,
				Default->Automatic,
				Description->"For each experiment sample, the diluent buffer used to mix with the input sample (plus SpikeSample, if applicable) to reduce its concentration in order to make DilutionCurve or SerialDilutionCurve. Dilution with the recommended diluent is required on all the loading samples for the best performance of microfluidics.",
				ResolutionDescription->"If a pre-loaded cartridge is used for the experiment, Diluent option is automatically set to the recommended diluent provided by the assay developer for the specified Analytes or Cartridge. For a customizable cartridge, Diluent option is set to Model[Sample,\"Simple Plex Sample Diluent 13\"].",
				AllowNull->False,
				Widget->Widget[
					Type->Object,
					Pattern:>ObjectP[{Model[Sample],Object[Sample]}]
				],
				Category->"Sample Preparation"
			},
			{
				OptionName->DilutionMixVolume,
				Default->Automatic,
				Description->"The volume that is pipetted up and down in the diluted input sample to mix each sample thoroughly with Diluent to make DilutionCurve or SerialDilutionCurve.",
				ResolutionDescription->"DilutionMixVolume option is automatically set to half of the minimum prepared volume of the diluted sample ",
				AllowNull->False,
				Widget->Widget[
					Type->Quantity,
					Pattern:>GreaterEqualP[0Microliter],
					Units->Alternatives[Microliter]
				],
				Category->"Sample Preparation"
			},
			{
				OptionName->DilutionNumberOfMixes,
				Default->5,
				Description->"The number of pipette up and down cycles that is used to mix each input sample thoroughly with Diluent to make DilutionCurve or SerialDilutionCurve.",
				AllowNull->False,
				Widget->Widget[
					Type->Number,
					Pattern:>RangeP[0,20,1]
				],
				Category->"Sample Preparation"
			},
			{
				OptionName->DilutionMixRate,
				Default->100Microliter/Second,
				Description->"The speed at which the DilutionMixVolume is pipetted up and down in the diluted input sample to mix each sample thoroughly with Diluent to make DilutionCurve or SerialDilutionCurve.",
				AllowNull->False,
				Widget->Widget[
					Type->Quantity,
					Pattern:>RangeP[0.4Microliter/Second,250Microliter/Second],
					Units->Alternatives[
						CompoundUnit[
							{1,{Microliter,{Microliter}}},
							{-1,{Second,{Second}}}
						]
					]
				],
				Category -> "Sample Preparation"
			},

			{
				OptionName->CustomCaptureAntibody,
				Default->Automatic,
				Description->"For each experiment sample, the capture antibody sample used in the sandwich ELISA experiment to bind with the present analytes through specific antigen-antibody interaction. The capture antibody must be labeled with digoxigenin, purified and diluted to preferably 3.5 Microgram/Milliliter before loading into the capillary ELISA cartridge. During the experiment, digoxigenin-labeled capture antibody sample first flows in the fluidic circuit to allow its binding to the immobilized anti-digoxigenin monoclonal antibody in the capillaries. Then the diluted input samples are applied to allow the binding to capture antibody for immobilization. The provided CustomCaptureAntibody can be resuspended into solution, bioconjugated with digoxigenin and diluted as desired using the related options. Please note that if the same capture antibody preparation options are specified for multiple samples (standard samples and/or input samples), the preparation of digoxigenin-labeled capture antibody is performed together. Please consider using ExperimentSampleManipulation for more customized capture antibody preparation.",
				ResolutionDescription->"If a customizable cartridge is used, CustomCaptureAntibody is automatically set based on the Analytes option. The Antibodies or SecondaryAntibodies field in Model[Molecule] of Analytes is inspected. If available, the DefaultSampleModel of a digoxigenin-labeled antibody is automatically selected as CustomCaptureAntibody. If no digoxigenin-labeled antibody is available, the DefaultSampleModel of an antibody with different epitopes with CustomDetectionAntibody (if uploaded) is automatically selected as CustomCaptureAntibody. If neither CustomCaptureAntibody or CustomDetectionAntibody has been specified and two antibodies with different epitopes are available for the analyte, the DefaultSampleModel of a polyclonal antibody is preferably selected for CustomCaptureAntibody.",
				AllowNull->True,
				Widget->Widget[
					Type->Object,
					Pattern:>ObjectP[{Model[Sample],Object[Sample]}]
				],
				Category->"Capture Antibody Preparation"
			},
			{
				OptionName->CaptureAntibodyResuspension,
				Default->Automatic,
				Description->"Indicates if the CustomCaptureAntibody should be reconstituted with CaptureAntibodyResuspensionDiluent. If set to True, the original container of the CustomCaptureAntibody sample is centrifuged at 3000 RPM for 1 Minute to eliminate sample loss upon cap opening. Then the CaptureAntibodyResuspensionDiluent is delivered into the CustomCaptureAntibody's container and thorough mixing is achieved by inversion for 30 times.",
				ResolutionDescription->"CaptureAntibodyResuspension is automatically set to True for a solid state CustomCaptureAntibody sample in a Customizable capillary ELISA cartridge.",
				AllowNull->True,
				Widget->Widget[
					Type->Enumeration,
					Pattern:>BooleanP
				],
				Category->"Capture Antibody Preparation"
			},
			{
				OptionName->CaptureAntibodyResuspensionConcentration,
				Default->Automatic,
				Description->"The target final concentration of the resuspended CustomCaptureAntibody sample.",
				ResolutionDescription->"CaptureAntibodyResuspensionConcentration option is automatically set to 1 Milligram/Milliliter if CaptureAntibodyResuspension is True and a customizable cartridge is used.",
				AllowNull->True,
				Widget->Widget[
					Type->Quantity,
					Pattern:>GreaterP[0Molar]|GreaterP[0Gram/Liter],
					Units->Alternatives[
						{1,{Micromolar,{Micromolar,Millimolar,Molar}}},
						CompoundUnit[
							{1,{Milligram,{Milligram,Picogram,Microgram,Gram}}},
							{-1,{Milliliter,{Milliliter,Microliter,Liter}}}
						]
					]
				],
				Category->"Capture Antibody Preparation"
			},
			{
				OptionName->CaptureAntibodyResuspensionDiluent,
				Default->Automatic,
				Description->"The resuspension buffer mixed with the solid state CustomCaptureAntibody sample to dissolve the sample into solution.",
				ResolutionDescription->"CaptureAntibodyResuspensionDiluent option is automatically set to Model[Sample, StockSolution, \"Filtered PBS, Sterile\"] if CaptureAntibodyResuspension is True and a customizable cartridge is used. The amount of the solid state CustomCaptureAntibody sample is used to calculate the amount of CaptureAntibodyResuspensionDiluent needed.",
				AllowNull->True,
				Widget->Widget[
					Type->Object,
					Pattern:>ObjectP[{Model[Sample],Object[Sample]}]
				],
				Category->"Capture Antibody Preparation"
			},
			{
				OptionName->CaptureAntibodyStorageCondition,
				Default->Automatic,
				Description->"Indicates the condition under which the unused portion of liquid state CustomCaptureAntibody sample inside its original container is stored after the protocol is completed.",
				ResolutionDescription->"CaptureAntibodyStorageCondition option is automatically set to Freezer if CaptureAntibodyResuspension is True and a customizable cartridge is used.",
				AllowNull->True,
				Widget->Widget[
					Type->Enumeration,
					Pattern:>Alternatives[SampleStorageTypeP,Disposal]
				],
				Category->"Post Experiment"
			},

			{
				OptionName->CaptureAntibodyConjugation,
				Default->Automatic,
				Description->"Indicates if bioconjugation reaction between digoxigenin NHS-ester and primary amines of the CustomCaptureAntibody is required to be performed to prepare digoxigenin-labeled capture antibody sample for capillary ELISA experiment. If set to True, the conjugation mixture is vortexed at 1900 RPM for 1 Minute to allow thorough mixing and then incubated on a heat block at CaptureAntibodyConjugationTemperature for CaptureAntibodyConjugationTime to allow complete reaction.",
				ResolutionDescription->"CaptureAntibodyConjugation is automatically set to True if the antibody composition of the CustomCaptureAntibody in the Customizable capillary ELISA cartridge does not show Model[Molecule,Protein,Antibody,\"Anti-Digoxigenin Antibody\"] as its SecondaryAntibodies.",
				AllowNull->True,
				Widget->Widget[
					Type->Enumeration,
					Pattern:>BooleanP
				],
				Category->"Capture Antibody Preparation"
			},
			{
				OptionName->CaptureAntibodyVolume,
				Default->Automatic,
				Description->"The volume of the unconjugated CustomCaptureAntibody sample used to react with DigoxigeninReagent to prepare digoxigenin-labeled capture antibody sample through bioconjugation synthesis.",
				ResolutionDescription->"CaptureAntibodyVolume option is automatically set to 100 Microliter if CaptureAntibodyConjugation is True and a customizable cartridge is used.",
				AllowNull->True,
				Widget->Widget[
					Type->Quantity,
					Pattern:>GreaterP[0Microliter],
					Units->Alternatives[Microliter]
				],
				Category->"Capture Antibody Preparation"
			},
			{
				OptionName->DigoxigeninReagent,
				Default->Automatic,
				Description->"The digoxigenin NHS-ester reagent used to react with the primary amines of the unconjugated CustomCaptureAntibody sample to prepare digoxigenin-labeled capture antibody sample through bioconjugation synthesis.",
				ResolutionDescription->"DigoxigeninReagent option is automatically set to Model[Sample,StockSolution,\"Digoxigenin-NHS, 0.67 mg/mL in DMF\"] if CaptureAntibodyConjugation is True and a customizable cartridge is used.",
				AllowNull->True,
				Widget->Widget[
					Type->Object,
					Pattern:>ObjectP[{Model[Sample],Object[Sample]}]
				],
				Category->"Capture Antibody Preparation"
			},
			{
				OptionName->DigoxigeninReagentVolume,
				Default->Automatic,
				Description->"The volume of DigoxigeninReagent used to react with CaptureAntibodyVolume of the unconjugated CustomCaptureAntibody sample to prepare digoxigenin-labeled capture antibody sample through bioconjugation synthesis.",
				ResolutionDescription->"When a customizable cartridge is used, DigoxigeninReagentVolume option is automatically set using the concentration of DigoxigeninReagent and the antibody concentration to achieve a 5:1 molar ratio between DigoxigeninReagent and the unconjugated CustomCaptureAntibody.",
				AllowNull->True,
				Widget->Widget[
					Type->Quantity,
					Pattern:>GreaterP[0Microliter],
					Units->Alternatives[Microliter]
				],
				Category->"Capture Antibody Preparation"
			},
			{
				OptionName->CaptureAntibodyConjugationBuffer,
				Default->Automatic,
				Description->"The buffer solution in which the reaction between the unconjugated CustomCaptureAntibody sample and DigoxigeninReagent happens to prepare digoxigenin-labeled capture antibody sample through bioconjugation synthesis.",
				ResolutionDescription->"CaptureAntibodyConjugationBuffer option is automatically set to Model[Sample,StockSolution,\"Sodium bicarbonate working stock 75 mg/mL\"] if CaptureAntibodyConjugation is True and a customizable cartridge is used.",
				AllowNull->True,
				Widget->Widget[
					Type->Object,
					Pattern:>ObjectP[{Model[Sample],Object[Sample]}]
				],
				Category->"Capture Antibody Preparation"
			},
			{
				OptionName->CaptureAntibodyConjugationBufferVolume,
				Default->Automatic,
				Description->"The volume of CaptureAntibodyConjugationBuffer used to mix with the unconjugated CustomCaptureAntibody sample and DigoxigeninReagent to provide a buffered environment for the bioconjugation reaction.",
				ResolutionDescription->"When a customizable cartridge is used, CaptureAntibodyConjugationBufferVolume option is automatically set to 1/9 of total volume of CaptureAntibodyVolume and DigoxigeninReagentVolume.",
				AllowNull->True,
				Widget->Widget[
					Type->Quantity,
					Pattern:>GreaterEqualP[0Microliter],
					Units->Alternatives[Microliter]
				],
				Category->"Capture Antibody Preparation"
			},
			{
				OptionName->CaptureAntibodyConjugationContainer,
				Default->Automatic,
				Description->"The container in which the unconjugated CustomCaptureAntibody sample, DigoxigeninReagent and CaptureAntibodyConjugationBuffer react to allow bioconjugation synthesis.",
				ResolutionDescription->"CaptureAntibodyConjugationContainer option is automatically selected base on the total conjugation reaction volume if CaptureAntibodyConjugation is True and a customizable cartridge is used.",
				AllowNull->True,
				Widget->Widget[
					Type->Object,
					Pattern:>ObjectP[{Model[Container],Object[Container]}]
				],
				Category->"Capture Antibody Preparation"
			},
			{
				OptionName->CaptureAntibodyConjugationTime,
				Default->Automatic,
				Description->"The amount of reaction time that the CustomCaptureAntibody and DigoxigeninReagent are allowed to react before purification happens.",
				ResolutionDescription->"CaptureAntibodyConjugationTime option is automatically set to 1 Hour if CaptureAntibodyConjugation is True and a customizable cartridge is used.",
				AllowNull->True,
				Widget->Widget[
					Type->Quantity,
					Pattern:>RangeP[0Minute,$MaxExperimentTime],
					Units->{1,{Hour,{Second,Minute,Hour}}}
				],
				Category->"Capture Antibody Preparation"
			},
			{
				OptionName->CaptureAntibodyConjugationTemperature,
				Default->Automatic,
				Description->"The temperature at which the reaction between the unconjugated CustomCaptureAntibody and DigoxigeninReagent is conducted.",
				ResolutionDescription->"CaptureAntibodyConjugationTemperature option is automatically set to Ambient if CaptureAntibodyConjugation is True and a customizable cartridge is used.",
				AllowNull->True,
				Widget->Alternatives[
					Widget[
						Type->Enumeration,
						Pattern:>Alternatives[Ambient]
					],
					Widget[
						Type->Quantity,
						Pattern:>RangeP[-20Celsius,150Celsius],
						Units->Alternatives[Celsius,Fahrenheit]
					]
				],
				Category->"Capture Antibody Preparation"
			},
			{
				OptionName->CaptureAntibodyPurificationColumn,
				Default->Automatic,
				Description->"The desalting spin column used to adsorb the molecules that are smaller than its molecular weight cut-off (MWCO) on its resin bed to remove the free digoxigenin NHS-ester molecules in order to purify the synthesis product of the CustomCaptureAntibody bioconjugation reaction. The spin column is operated following the manufacturer's instruction (Figure 3.4 in ExperimentCapillaryELISA help file).",
				ResolutionDescription->"CaptureAntibodyPurificationColumn is automatically set to a 40K molecular weight cut-off Zeba desalting spin column depending on the total volume of the synthesis reaction, if CaptureAntibodyConjugation is True and a customizable cartridge is used.",
				AllowNull->True,
				Widget->Widget[
					Type->Object,
					Pattern:>ObjectP[{Model[Container,Vessel,Filter],Object[Container,Vessel,Filter]}],
					PreparedSample->False,
					PreparedContainer->False
				],
				Category->"Capture Antibody Preparation"
			},
			{
				OptionName->CaptureAntibodyColumnWashBuffer,
				Default->Automatic,
				Description->"The buffer solution loaded into the CaptureAntibodyPurificationColumn after its storage buffer is removed and before the sample is loaded. The CaptureAntibodyColumnWashBuffer flushed through CaptureAntibodyPurificationColumn to remove any residues from the spin column storage solution. The washing process is repeated 3 times to equilibrate the resin bed before sample loading.",
				ResolutionDescription->"CaptureAntibodyColumnWashBuffer option is automatically set to Model[Sample, StockSolution, \"Filtered PBS, Sterile\"] if CaptureAntibodyConjugation is True and a customizable cartridge is used.",
				AllowNull->True,
				Widget->Widget[
					Type->Object,
					Pattern:>ObjectP[{Model[Sample],Object[Sample]}]
				],
				Category->"Capture Antibody Preparation"
			},
			{
				OptionName->CaptureAntibodyConjugationStorageCondition,
				Default->Automatic,
				Description->"Indicates the condition under which the unused portion of the synthesized and purified digoxigenin-labeled capture antibody sample is stored after the protocol is completed.",
				ResolutionDescription->"CaptureAntibodyConjugationStorageCondition option is automatically set to Refrigerator if CaptureAntibodyConjugation is True and a customizable cartridge is used.",
				AllowNull->True,
				Widget->Widget[
					Type->Enumeration,
					Pattern:>Alternatives[SampleStorageTypeP, Disposal]
				],
				Category->"Capture Antibody Preparation"
			},

			{
				OptionName->CaptureAntibodyDilution,
				Default->Automatic,
				Description->"Indicates if digoxigenin-labeled capture antibody dilution is required before loading into capillary ELISA cartridge.",
				ResolutionDescription->"When a Customizable capillary ELISA cartridge is used, CaptureAntibodyDilution is automatically set to True if CaptureAntibodyResuspension and/or CaptureAntibodyConjugation is True.",
				AllowNull->True,
				Widget->Widget[
					Type->Enumeration,
					Pattern:>BooleanP
				],
				Category->"Capture Antibody Preparation"
			},
			{
				OptionName->CaptureAntibodyTargetConcentration,
				Default->Automatic,
				Description->"The desired concentration of digoxigenin-labeled capture antibody after dilution. The initial mass concentration of digoxigenin-labeled capture antibody sample is acquired from the composition of the liquid state CustomCaptureAntibody sample or the CaptureAntibdoyResuspension of the solid state CustomCaptureAntibody sample. A 50% concentration loss is factored in if conjugation is performed in the experiment.",
				(*
				Description->"The desired concentration of the digoxigenin-labeled capture antibody after dilution. The initial mass concentration of digoxigenin-labeled capture antibody sample is calculated by its absorbance at 280 nm and the average antibody absorbance coefficient - 1.35 (mL/mg)/cm.",
				*)
				ResolutionDescription->"CaptureAntibodyTargetConcentration is automatically set to 3.5 Microgram/Milliliter if CaptureAntibodyDilution is True and a customizable cartridge is used.",
				AllowNull->True,
				Widget->Widget[
					Type->Quantity,
					Pattern:>GreaterP[0Molar]|GreaterP[0Gram/Liter],
					Units->Alternatives[
						{1,{Micromolar,{Micromolar,Millimolar,Molar}}},
						CompoundUnit[
							{1,{Picogram,{Picogram,Microgram,Milligram,Gram}}},
							{-1,{Milliliter,{Milliliter,Microliter,Liter}}}
						]
					]
				],
				Category->"Capture Antibody Preparation"
			},
			{
				OptionName->CaptureAntibodyDiluent,
				Default->Automatic,
				Description->"The buffer solution used to mix with the concentrated digoxigenin-labeled capture antibody sample to achieve the desired CaptureAntibodyTargetConcentration for cartridge loading.",
				ResolutionDescription->"CaptureAntibodyDiluent option is automatically set to Model[Sample, \"Simple Plex Reagent Diluent\"] if CaptureAntibodyDilution is True and a customizable cartridge is used.",
				AllowNull->True,
				Widget->Widget[
					Type->Object,
					Pattern:>ObjectP[{Model[Sample],Object[Sample]}]
				],
				Category->"Capture Antibody Preparation"
			},

			{
				OptionName->CustomDetectionAntibody,
				Default->Automatic,
				Description->"The detection antibody sample used in the sandwich ELISA experiment. After immobilization of the analytes in the microfluidic channels, the detection antibodies bind to analyte epitopes distinct from the capture antibodies through antigen-antibody interaction. Then the streptavidin-conjugated fluorescent dyes can be attached through biotin-streptavidin interaction for data acquiring. The detection antibody must be modified with biotin, purified and diluted to preferably 3.5 Microgram/Milliliter before loading into the capillary ELISA cartridge. The provided CustomDetectionAntibody can be resuspended into solution, bioconjugated with biotin and diluted as desired using the related options. Please note that if the same detection antibody preparation options are specified for multiple samples (standard samples and/or input samples), the preparation of biotinylated detection antibody is performed together. Please consider using ExperimentSampleManipulation for more customized detection antibody preparation.",
				ResolutionDescription->"If a customizable cartridge is used, CustomDetectionAntibody is automatically set based on the Analytes option. The Antibodies or SecondaryAntibodies field in Model[Molecule] of Analytes is inspected. If available, the DefaultSampleModel of a biotinylated antibody is automatically selected as CustomDetectionAntibody. If no biotinylated antibody is available, the DefaultSampleModel of an antibody with different epitopes with CustomCaptureAntibody (if specified) is automatically selected as CustomDetectionAntibody. If neither CustomCaptureAntibody or CustomDetectionAntibody has been specified and two antibodies with different epitopes are available for the analyte, the DefaultSampleModel of a monoclonal antibody is preferably selected for CustomDetectionAntibody.",
				AllowNull->True,
				Widget->Widget[
					Type->Object,
					Pattern:>ObjectP[{Model[Sample],Object[Sample]}]
				],
				Category->"Detection Antibody Preparation"
			},
			{
				OptionName->DetectionAntibodyResuspension,
				Default->Automatic,
				Description->"Indicates if the CustomDetectionAntibody should be reconstituted with DetectionAntibodyResuspensionDiluent. If set to True, the original container of the CustomDetectionAntibody sample is centrifuged at 3000 RPM for 1 Minute to eliminate sample loss upon cap opening. Then the DetectionAntibodyResuspensionDiluent is delivered into the CustomDetectionAntibody's container and thorough mixing is achieved by inversion for 30 times.",
				ResolutionDescription->"DetectionAntibodyResuspension is automatically set to True for a solid state CustomDetectionAntibody sample in a Customizable capillary ELISA cartridge.",
				AllowNull->True,
				Widget->Widget[
					Type->Enumeration,
					Pattern:>BooleanP
				],
				Category->"Detection Antibody Preparation"
			},
			{
				OptionName->DetectionAntibodyResuspensionConcentration,
				Default->Automatic,
				Description->"The target final concentration of the resuspended CustomDetectionAntibody sample.",
				ResolutionDescription->"DetectionAntibodyResuspensionConcentration option is automatically set to 1 Milligram/Milliliter if DetectionAntibodyResuspension is True and a customizable cartridge is used.",
				AllowNull->True,
				Widget->Widget[
					Type->Quantity,
					Pattern:>GreaterP[0Molar]|GreaterP[0Gram/Liter],
					Units->Alternatives[
						{1,{Micromolar,{Micromolar,Millimolar,Molar}}},
						CompoundUnit[
							{1,{Milligram,{Milligram,Picogram,Microgram,Gram}}},
							{-1,{Milliliter,{Milliliter,Microliter,Liter}}}
						]
					]
				],
				Category->"Detection Antibody Preparation"
			},
			{
				OptionName->DetectionAntibodyResuspensionDiluent,
				Default->Automatic,
				Description->"The resuspension buffer mixed with the solid state CustomDetectionAntibody sample to dissolve the sample into solution.",
				ResolutionDescription->"DetectionAntibodyResuspensionDiluent option is automatically set to Model[Sample, StockSolution, \"Filtered PBS, Sterile\"] if DetectionAntibodyResuspension is True and a customizable cartridge is used. The amount of the solid state CustomDetectionAntibody sample is used to calculate the amount of DetectionAntibodyResuspensionDiluent needed.",
				AllowNull->True,
				Widget->Widget[
					Type->Object,
					Pattern:>ObjectP[{Model[Sample],Object[Sample]}]
				],
				Category->"Detection Antibody Preparation"
			},
			{
				OptionName->DetectionAntibodyStorageCondition,
				Default->Automatic,
				Description->"Indicates the condition under which the unused portion of liquid state CustomDetectionAntibody sample inside its original container is stored after the protocol is completed.",
				ResolutionDescription->"DetectionAntibodyStorageCondition option is automatically set to Freezer if DetectionAntibodyResuspension is True and a customizable cartridge is used.",
				AllowNull->True,
				Widget->Widget[
					Type->Enumeration,
					Pattern:>Alternatives[SampleStorageTypeP,Disposal]
				],
				Category->"Post Experiment"
			},
			{
				OptionName->DetectionAntibodyConjugation,
				Default->Automatic,
				Description->"Indicates if bioconjugation reaction between Biotin-XX-SE (6-((6-((Biotinoyl)Amino)Hexanoyl)Amino)Hexanoic Acid, Succinimidyl Ester) and primary amines of the CustomDetectionAntibody is required to be performed to prepare biotinylated detection antibody sample for capillary ELISA experiment. If set to True, the conjugation mixture is vortexed at 1900 RPM for 1 Minute to allow thorough mixing and then incubated on a heat block at DetectionAntibodyConjugationTemperature for DetectionAntibodyConjugationTime to allow complete reaction.",
				ResolutionDescription->"DetectionAntibodyConjugation is automatically set to True if the antibody composition of the CustomDetectionAntibody in the Customizable capillary ELISA cartridge does not show Model[Molecule,Protein,\"Streptavidin\"] as its Targets.",
				AllowNull->True,
				Widget->Widget[
					Type->Enumeration,
					Pattern:>BooleanP
				],
				Category->"Detection Antibody Preparation"
			},
			{
				OptionName->DetectionAntibodyVolume,
				Default->Automatic,
				Description->"The volume of the unconjugated CustomDetectionAntibody sample used to react with BiotinReagent to prepare biotinylated detection antibody sample through bioconjugation synthesis.",
				ResolutionDescription->"DetectionAntibodyVolume option is automatically set to 100 Microliter if DetectionAntibodyConjugation is True and a customizable cartridge is used.",
				AllowNull->True,
				Widget->Widget[
					Type->Quantity,
					Pattern:>GreaterP[0Microliter],
					Units->Alternatives[Microliter]
				],
				Category->"Detection Antibody Preparation"
			},
			{
				OptionName->BiotinReagent,
				Default->Automatic,
				Description->"The Biotin-XX-SE (6-((6-((Biotinoyl)Amino)Hexanoyl)Amino)Hexanoic Acid, Succinimidyl Ester) or other biotinylation reagent used to mix with the unconjugated CustomDetectionAntibody sample to prepare biotinylated detection antibody sample through bioconjugation synthesis.",
				ResolutionDescription->"BiotinReagent option is automatically set to Model[Sample,StockSolution,\"Biotin-XX, 1 mg/mL in DMSO\"] if DetectionAntibodyConjugation is True and a customizable cartridge is used.",
				AllowNull->True,
				Widget->Widget[
					Type->Object,
					Pattern:>ObjectP[{Model[Sample],Object[Sample]}]
				],
				Category->"Detection Antibody Preparation"
			},
			{
				OptionName->BiotinReagentVolume,
				Default->Automatic,
				Description->"The volume of BiotinReagent used to react with DetectionAntibodyVolume of the unconjugated CustomDetectionAntibody sample to prepare biotinylated detection antibody sample through bioconjugation synthesis.",
				ResolutionDescription->"When a customizable cartridge is used, BiotinReagentVolume option is automatically set using the concentration of BiotinReagent and the antibody concentration to achieve a 10:1 molar ratio between BiotinReagent and the unconjugated CustomDetectionAntibody.",
				AllowNull->True,
				Widget->Widget[
					Type->Quantity,
					Pattern:>GreaterP[0Microliter],
					Units->Alternatives[Microliter]
				],
				Category->"Detection Antibody Preparation"
			},
			{
				OptionName->DetectionAntibodyConjugationBuffer,
				Default->Automatic,
				Description->"The buffer solution in which the reaction between the unconjugated CustomDetectionAntibody sample and BiotinReagent happens to prepare biotinylated detection antibody sample through bioconjugation synthesis.",
				ResolutionDescription->"DetectionAntibodyConjugationBuffer option is automatically set to Model[Sample,StockSolution,\"Sodium bicarbonate working stock 75 mg/mL\"] if DetectionAntibodyConjugation is True and a customizable cartridge is used.",
				AllowNull->True,
				Widget->Widget[
					Type->Object,
					Pattern:>ObjectP[{Model[Sample],Object[Sample]}]
				],
				Category->"Detection Antibody Preparation"
			},
			{
				OptionName->DetectionAntibodyConjugationBufferVolume,
				Default->Automatic,
				Description->"The volume of DetectionAntibodyConjugationBuffer used to mix with the unconjugated CustomDetectionAntibody sample and BiotinReagent to provide a buffered environment for the bioconjugation reaction.",
				ResolutionDescription->"When a customizable cartridge is used, DetectionAntibodyConjugationBufferVolume option is automatically set to 1/9 of total volume of DetectionAntibodyVolume and BiotinReagentVolume.",
				AllowNull->True,
				Widget->Widget[
					Type->Quantity,
					Pattern:>GreaterEqualP[0Microliter],
					Units->Alternatives[Microliter]
				],
				Category->"Detection Antibody Preparation"
			},
			{
				OptionName->DetectionAntibodyConjugationContainer,
				Default->Automatic,
				Description->"The container in which the unconjugated CustomDetectionAntibody sample, BiotinReagent and DetectionAntibodyConjugationBuffer react to allow bioconjugation synthesis.",
				ResolutionDescription->"DetectionAntibodyConjugationContainer option is automatically selected base on the total conjugation reaction volume if DetectionAntibodyConjugation is True and a customizable cartridge is used.",
				AllowNull->True,
				Widget->Widget[
					Type->Object,
					Pattern:>ObjectP[{Model[Container],Object[Container]}]
				],
				Category->"Detection Antibody Preparation"
			},
			{
				OptionName->DetectionAntibodyConjugationTime,
				Default->Automatic,
				Description->"The amount of reaction time that the CustomDetectionAntibody and BiotinReagent are allowed to react before purification happens.",
				ResolutionDescription->"DetectionAntibodyConjugationTime option is automatically set to 1 Hour if DetectionAntibodyConjugation is True and a customizable cartridge is used.",
				AllowNull->True,
				Widget->Widget[
					Type->Quantity,
					Pattern:>RangeP[0Minute,$MaxExperimentTime],
					Units->{1,{Hour,{Second,Minute,Hour}}}
				],
				Category->"Detection Antibody Preparation"
			},
			{
				OptionName->DetectionAntibodyConjugationTemperature,
				Default->Automatic,
				Description->"The temperature at which the reaction between the unconjugated CustomDetectionAntibody and BiotinReagent is conducted.",
				ResolutionDescription->"DetectionAntibodyConjugationTemperature option is automatically set to Ambient if DetectionAntibodyConjugation is True and a customizable cartridge is used.",
				AllowNull->True,
				Widget->Alternatives[
					Widget[
						Type->Enumeration,
						Pattern:>Alternatives[Ambient]
					],
					Widget[
						Type->Quantity,
						Pattern:>RangeP[-20Celsius,150Celsius],
						Units->Alternatives[Celsius,Fahrenheit]
					]
				],
				Category->"Detection Antibody Preparation"
			},
			{
				OptionName->DetectionAntibodyPurificationColumn,
				Default->Automatic,
				Description->"The desalting spin column used to adsorb the molecules that are smaller than its molecular weight cut-off (MWCO) on its resin bed to remove the free biotinylation reagent molecules in order to purify the synthesis product of the CustomDetectionAntibody bioconjugation reaction. The spin column is operated following the manufacturer's instruction (Figure 3.5 in ExperimentCapillaryELISA help file).",
				ResolutionDescription->"DetectionAntibodyPurificationColumn is automatically set to a 40K molecular weight cut-off Zeba desalting spin column depending on the total volume of the synthesis reaction, if DetectionAntibodyConjugation is True and a customizable cartridge is used.",
				AllowNull->True,
				Widget->Widget[
					Type->Object,
					Pattern:>ObjectP[{Model[Container,Vessel,Filter],Object[Container,Vessel,Filter]}],
					PreparedSample->False,
					PreparedContainer->False
				],
				Category->"Detection Antibody Preparation"
			},
			{
				OptionName->DetectionAntibodyColumnWashBuffer,
				Default->Automatic,
				Description->"The buffer solution loaded into the DetectionAntibodyPurificationColumn after its storage buffer is removed and before the sample is loaded. The DetectionAntibodyColumnWashBuffer flushed through DetectionAntibodyPurificationColumn to remove any residues from the spin column storage solution. The washing process is repeated 3 times to equilibrate the resin bed before sample loading.",
				ResolutionDescription->"DetectionAntibodyColumnWashBuffer option is automatically set to Model[Sample, StockSolution, \"Filtered PBS, Sterile\"] if DetectionAntibodyConjugation is True and a customizable cartridge is used.",
				AllowNull->True,
				Widget->Widget[
					Type->Object,
					Pattern:>ObjectP[{Model[Sample],Object[Sample]}]
				],
				Category->"Detection Antibody Preparation"
			},
			{
				OptionName->DetectionAntibodyConjugationStorageCondition,
				Default->Automatic,
				Description->"Indicates the condition under which the unused portion of the synthesized and purified biotinylated detection antibody sample is stored after the protocol is completed.",
				ResolutionDescription->"DetectionAntibodyConjugationStorageCondition option is automatically set to Refrigerator if DetectionAntibodyConjugation is True and a customizable cartridge is used.",
				AllowNull->True,
				Widget->Widget[
					Type->Enumeration,
					Pattern:>Alternatives[SampleStorageTypeP, Disposal]
				],
				Category->"Detection Antibody Preparation"
			},

			{
				OptionName->DetectionAntibodyDilution,
				Default->Automatic,
				Description->"Indicates if biotinylated detection antibody dilution is required before loading into capillary ELISA cartridge.",
				ResolutionDescription->"When a Customizable capillary ELISA cartridge is used, DetectionAntibodyDilution is automatically set to True if DetectionAntibodyResuspension and/or DetectionAntibodyConjugation is True.",
				AllowNull->True,
				Widget->Widget[
					Type->Enumeration,
					Pattern:>BooleanP
				],
				Category->"Detection Antibody Preparation"
			},
			{
				OptionName->DetectionAntibodyTargetConcentration,
				Default->Automatic,
				Description->"The desired concentration of biotinylated detection antibody after dilution. The initial mass concentration of biotinylated detection antibody sample is acquired from the composition of the liquid state CustomDetectionAntibody sample or the DetectionAntibdoyResuspension of the solid state CustomDetectionAntibody sample. A 50% concentration loss is factored in if conjugation is performed in the experiment.",
				(*
				Description->"The desired concentration of biotinylated detection antibody after dilution. The initial mass concentration of biotinylated detection antibody sample is calculated by its absorbance at 280 nm and the average antibody absorbance coefficient - 1.35 (mL/mg)/cm.",
				*)
				ResolutionDescription->"DetectionAntibodyTargetConcentration is automatically set to 3.5 Microgram/Milliliter if DetectionAntibodyDilution is True and a customizable cartridge is used.",
				AllowNull->True,
				Widget->Widget[
					Type->Quantity,
					Pattern:>GreaterP[0Molar]|GreaterP[0Gram/Liter],
					Units->Alternatives[
						{1,{Micromolar,{Micromolar,Millimolar,Molar}}},
						CompoundUnit[
							{1,{Picogram,{Picogram,Microgram,Milligram,Gram}}},
							{-1,{Milliliter,{Milliliter,Microliter,Liter}}}
						]
					]
				],
				Category->"Detection Antibody Preparation"
			},
			{
				OptionName->DetectionAntibodyDiluent,
				Default->Automatic,
				Description->"The buffer solution used to mix with the concentrated biotinylated detection antibody sample to achieve the desired DetectionAntibodyTargetConcentration for cartridge loading.",
				ResolutionDescription->"DetectionAntibodyDiluent option is automatically set to Model[Sample, \"Simple Plex Reagent Diluent\"] if DetectionAntibodyDilution is True and a customizable cartridge is used.",
				AllowNull->True,
				Widget->Widget[
					Type->Object,
					Pattern:>ObjectP[{Model[Sample],Object[Sample]}]
				],
				Category->"Detection Antibody Preparation"
			}
		],


        IndexMatching[
            IndexMatchingParent->Standard,
            {
                OptionName->Standard,
                Default->Automatic,
                Description->"The standard samples with known concentration(s) of the analyte(s) that are used to make a dilution series and create a standard curve in the capillary ELISA experiment.",
                ResolutionDescription->"If a customizable cartridge is used, Standard option is automatically set to the DefaultSampleModel of the Analytes.",
                AllowNull->True,
                Widget->Widget[
                    Type->Object,
                    Pattern:>ObjectP[{Model[Sample],Object[Sample]}]
                ],
                Category->"Standard Curve"
            },
            {
                OptionName->StandardResuspension,
                Default->Automatic,
                Description->"Indicates if resuspension is required to be performed on the solid state Standard sample to turn the sample into solution. If set to True, the original container of the Standard sample is centrifuged at 3000 RPM for 1 Minute to eliminate sample loss upon cap opening. Then the StandardResuspensionDiluent is delivered into the Standard's container and thorough mixing is achieved by inversion for 30 times.",
                ResolutionDescription->"StandardResuspension is automatically set to True for a solid state Standard sample.",
                AllowNull->True,
                Widget->Widget[
                    Type->Enumeration,
                    Pattern:>BooleanP
                ],
				Category->"Standard Preparation"
            },
            {
                OptionName->StandardResuspensionConcentration,
                Default->Automatic,
                Description->"The target concentration of the Standard sample in the solution after resuspension. The amount of the solid state Standard is used to calculate the volume of StandardResuspensionDiluent needed.",
                ResolutionDescription->"If a pre-loaded cartridge is used in this protocol and the standard sample is for one of its analytes, StandardResuspensionConcentration is automatically set to 10 times of the analyte's upper limit of quantitation (ULOQ) provided by the assay developer. This information can be found in the corresponding Object[ManufacturingSpecification,CapillaryELISACartridge] of the analyte. Otherwise, StandardResuspension is automatically set to 100 Microgram/Milliliter if StandardResuspension is True.",
                AllowNull->True,
                Widget->Widget[
					Type->Quantity,
					Pattern:>GreaterP[0Molar]|GreaterP[0Gram/Liter],
					Units->Alternatives[
						{1,{Micromolar,{Micromolar,Millimolar,Molar}}},
						CompoundUnit[
							{1,{Milligram,{Milligram,Picogram,Microgram,Gram}}},
							{-1,{Milliliter,{Milliliter,Microliter,Liter}}}
						]
					]
                ],
				Category->"Standard Preparation"
            },
            {
                OptionName->StandardResuspensionDiluent,
                Default->Automatic,
                Description->"The resuspension buffer mixed with the solid state Standard sample to dissolve the sample into solution.",
                ResolutionDescription->"If a pre-loaded cartridge is used in this protocol and the standard sample is for one of its analytes, StandardResuspensionDiluent is automatically set to the recommended diluent for this analyte suggested by the assay developer. This information can be found in the corresponding Object[ManufacturingSpecification,CapillaryELISACartridge] of the analyte. Otherwise it is automatically set to Model[Sample,\"Simple Plex Sample Diluent 13\"] if StandardResuspension is True.",
                AllowNull->True,
                Widget->Widget[
                    Type->Object,
                    Pattern:>ObjectP[{Model[Sample],Object[Sample]}]
                ],
				Category->"Standard Preparation"
            },
            {
                OptionName->StandardStorageCondition,
                Default->Automatic,
                Description->"Indicates the condition under which the unused portion of liquid state Standard inside its original container is stored after the protocol is completed.",
                ResolutionDescription->"StandardStorageCondition option is automatically set to Freezer if StandardResuspension is True.",
                AllowNull->True,
                Widget->Widget[
                    Type->Enumeration,
                    Pattern:>Alternatives[SampleStorageTypeP,Disposal]
                ],
				Category->"Post Experiment"
            },
            {
                OptionName->StandardDilutionCurve,
                Default->Automatic,
				Description->"The collection of dilutions performed on the liquid-phase Standard sample. Dilution is required on all the loading samples for the best performance of microfluidics and the ELISA experiment is performed on all the diluted samples. Data from all measurements of all dilutions from a standard sample are used for the preparation of standard curve. For FixedDilutionVolume dilutions, the SampleAmount is the volume of the standard sample that is mixed with the DiluentVolume of the StandardDiluent. For FixedDilutionFactor dilutions, the AssayVolume is the volume of the sample that is created after being diluted by the specified DilutionFactor. For a pre-loaded capillary ELISA cartridge, please refer to Object[ManufacturingSpecification,CapillaryELISACartridge] of the analytes for their recommended minimum dilution factors. For a customizable cartridge, a minimum dilution factor of 0.5 is suggested.",
				(*
				Description->"The collection of dilutions preformed on the liquid-phase Standard sample. The ELISA experiment is performed on all the diluted samples. Data from all measurements of all dilutions from a standard sample are used for the preparation of standard curve. For FixedDilutionVolume dilutions, the SampleAmount is the volume of the standard sample that is mixed with the DiluentVolume of the StandardDiluent. For FixedDilutionFactor dilutions, the AssayVolume is the volume of the sample that is created after being diluted by the specified DilutionFactor. For DynamicDilutions, the AssayVolume is the preparation volume of each diluted sample. For LinearDilutions defined with volumes, the first diluted sample uses the specified StartingSampleAmount. Then for each diluted sample in the dilution series, the amount of the input sample increases by the SampleAmountIncrement until the desired NumberOfDilutions is reached. For LinearDilutions defined with dilution factors, the first diluted sample holds the specified StartingDilutionFactor. Then the dilution factor increases by DilutionFactorIncrement until the desired NumberOfDilutions is reached. For example, when AssayVolume is set to 60 Microliter, a StartingSampleAmount of 12 Microliter, a SampleAmountIncrement of 6 Microliter and a NumberOfDilution of 3 leads to 3 diluted samples with dilution factors of 0.2, 0.3, 0.4. The same diluted samples are prepared when StartingDilutionFactor is set to 0.2 with a DilutionFactorIncrement of 0.1. For a pre-loaded capillary ELISA cartridge, please refer to Object[ManufacturingSpecification,CapillaryELISACartridge] of the analytes for their recommended minimum dilution factors. For a customizable cartridge, a minimum dilution factor of 0.5 is suggested.",
				*)
                ResolutionDescription->"If Standard option is not Null and StandardSerialDilutionCurve is Null, StandardDilutionCurve is automatically set to {{60 Microliter,0.1},{60 Microliter,0.01},{60 Microliter,0.001},{60 Microliter,0.0001},{60 Microliter,0.00001}} to prepare a 60 Microliter dilution series of 5 orders.",
                AllowNull->True,
				Widget->Alternatives[
					"Fixed Dilution Volume"->Adder[
						List[
							"Sample Amount"->Widget[
								Type->Quantity,
								Pattern:>GreaterEqualP[0Microliter],
								Units->Alternatives[Microliter]
							],
							"Diluent Volume"->Widget[
								Type->Quantity,
								Pattern:>GreaterEqualP[0Microliter],
								Units->Alternatives[Microliter]
							]
						]
					],
					"Fixed Dilution Factor"->Adder[
						List[
							"Assay Volume"->Widget[
								Type->Quantity,
								Pattern:>GreaterEqualP[30Microliter],
								Units->Alternatives[Microliter]
							],
							"Dilution Factors"->Widget[
								Type->Number,
								Pattern:>RangeP[0,1]
							]
						]
					]
					(*
					"Dynamic Dilutions"->List[
						"Assay Volume"->Widget[
							Type->Quantity,
							Pattern:>GreaterEqualP[30Microliter],
							Units->Alternatives[Microliter]
						],
						"Linear Dilutions"->Alternatives[
							List[
								"Starting Sample Amount"->Widget[
									Type->Quantity,
									Pattern:>GreaterEqualP[0Microliter],
									Units->Alternatives[Microliter]
								],
								"Sample Amount Increment"->Widget[
									Type->Quantity,
									Pattern:>GreaterEqualP[0Microliter],
									Units->Alternatives[Microliter]
								]
							],
							List[
								"Starting Dilution Factor"->Widget[
									Type->Number,
									Pattern:>RangeP[0,1]
								],
								"Dilution Factor Increment"->Widget[
									Type->Number,
									Pattern:>RangeP[0,1]
								]
							]
						],
						"Number Of Dilutions"->Widget[
							Type->Number,
							Pattern:>GreaterP[1,1]
						]
					]
					*)
				],
				Category->"Standard Preparation"
            },
            {
                OptionName->StandardSerialDilutionCurve,
                Default->Automatic,
                Description->"The collection of stepwise dilutions performed on the liquid-phase Standard sample. Dilution is required on all the loading samples for the best performance of microfluidics and the ELISA experiment is performed on all the diluted samples. Data from all measurements of all dilutions from a standard sample are used for the preparation of standard curve. To use non-diluted input sample, the first dilution can be set to a dilution factor of 1. For SerialDilutionVolumes, the TransferVolume is taken out of the sample and added to a second well with the DiluentVolume of the Diluent. After thorough mixing, the TransferVolume is taken out of that well and added to a third well. This is repeated to make NumberofDilutions diluted samples. For SerialDilutionFactors, the sample is diluted by the dilution factor at each transfer step. For a pre-loaded capillary ELISA cartridge, please refer to Object[ManufacturingSpecification,CapillaryELISACartridge] of the analytes for their recommended minimum dilution factors. For a customizable cartridge, a minimum dilution factor of 0.5 is suggested.",
                ResolutionDescription->"If Standard option is uploaded and StandardDilutionCurve is uploaded, StandardSerialDilutionCurve option is automatically set to 5 NumberOfDilutions with ConstantDilutionFactor of 0.1 to generate a AssayVolume of 60 Microliter.",
                AllowNull->True,
                Widget->Alternatives[
                    "Serial Dilution Volumes"->List[
                        "Transfer Volume"->Widget[
                            Type->Quantity,
                            Pattern:>GreaterP[0Microliter],
                            Units->Alternatives[Microliter]
                        ],
                        "Diluent Volume"->Widget[
                            Type->Quantity,
                            Pattern:>GreaterEqualP[30Microliter],
                            Units->Alternatives[Microliter]
                        ],
                        "Number Of Dilutions"->Widget[
                            Type->Number,
                            Pattern:>GreaterP[1,1]
                        ]
                    ],
                    "Serial Dilution Factor"->List[
                        "Assay Volume"->Widget[
                            Type->Quantity,
                            Pattern:>GreaterEqualP[30Microliter],
                            Units->Alternatives[Microliter]
                        ],
                        "Dilution Factors"->Alternatives[
                            "Constant"->List[
                                "Constant Dilution Factor"->Widget[
                                    Type->Number,
                                    Pattern:>RangeP[0,1]
                                ],
                                "Number Of Dilutions"->Widget[
                                    Type->Number,
                                    Pattern:>GreaterP[1,1]
                                ]
                            ],
                            "Variable"->Adder[
                                Widget[
                                    Type->Number,
                                    Pattern:>RangeP[0,1]
                                ]
                            ]
                        ]
                    ]
                ],
				Category->"Standard Preparation"
            },
            {
                OptionName->StandardDiluent,
                Default->Automatic,
                Description->"The diluent buffer used to mixed with the Standard sample in order to make StandardDilutionCurve or StandardSerialDilutionCurve. Dilution with the recommended diluent is required on all the loading samples for the best performance of microfluidics.",
                ResolutionDescription->"If a pre-loaded cartridge is used for the experiment, StandardDiluent option is automatically set to the recommended diluent provided by the assay developer for the specified Analytes or Cartridge. For a customizable cartridge, StandardDiluent option is set to Model[Sample,\"Simple Plex Sample Diluent 13\"].",
                AllowNull->True,
                Widget->Widget[
                    Type->Object,
                    Pattern:>ObjectP[{Model[Sample],Object[Sample]}]
                ],
				Category->"Standard Preparation"
            },
            {
                OptionName->StandardDilutionMixVolume,
                Default->Automatic,
                Description->"The volume that is pipetted up and down in the diluted standard sample to mix each sample thoroughly with StandardDiluent to make StandardDilutionCurve or StandardSerialDilutionCurve.",
                ResolutionDescription->"StandardDilutionMixVolume is automatically set to 20 Microliter if Standard is not Null.",
                AllowNull->True,
                Widget->Widget[
                    Type->Quantity,
                    Pattern:>GreaterEqualP[0Microliter],
                    Units->Alternatives[Microliter]
                ],
				Category->"Standard Preparation"
            },
            {
                OptionName->StandardDilutionNumberOfMixes,
                Default->Automatic,
                Description->"The number of pipette up and down cycles that is used to mix each standard sample thoroughly with StandardDiluent to make StandardDilutionCurve or StandardSerialDilutionCurve.",
                ResolutionDescription->"StandardDilutionNumberOfMixes option is automatically set to 5 if Standard is not Null.",
                AllowNull->True,
                Widget->Widget[
                    Type->Number,
                    Pattern:>RangeP[0,20,1]
                ],
				Category->"Standard Preparation"
            },
            {
                OptionName->StandardDilutionMixRate,
                Default->Automatic,
                Description->"The speed at which the StandardDilutionMixVolume is pipetted up and down in the diluted standard sample to mix each sample thoroughly with StandardDiluent to make StandardDilutionCurve or StandardSerialDilutionCurve.",
                ResolutionDescription->"StandardDilutionMixRate option is automatically set to 100 Microliter/Second if Standard is not Null.",
                AllowNull->True,
                Widget->Widget[
                    Type->Quantity,
                    Pattern:>RangeP[0.4Microliter/Second,250Microliter/Second],
					Units->Alternatives[
						CompoundUnit[
							{1,{Microliter,{Microliter}}},
							{-1,{Second,{Second}}}
						]
					]
                ],
				Category->"Standard Preparation"
            },

            {
                OptionName->StandardCaptureAntibody,
                Default->Automatic,
				Description->"The standard capture antibody sample used in the sandwich ELISA experiment to bind with analytes in the standard sample through specific antigen-antibody interaction. The standard capture antibody must be labeled with digoxigenin, purified and diluted to preferably 3.5 Microgram/Milliliter before loading into the capillary ELISA cartridge. During the experiment, digoxigenin-labeled standard capture antibody sample first flows in the fluidic circuit to allow its binding to the immobilized anti-digoxigenin monoclonal antibody in the capillaries. Then the diluted standard samples are applied to allow the binding to standard capture antibody for immobilization. The provided StandardCaptureAntibody can be resuspended into solution, bioconjugated with digoxigenin and diluted as desired using the related options. Please note that if the same capture antibody preparation options are specified for multiple samples (standard samples and/or input samples), the preparation of digoxigenin-labeled capture antibody is performed together. Please consider using ExperimentSampleManipulation for more customized standard capture antibody preparation.",
				ResolutionDescription->"If a customizable cartridge is used, StandardCaptureAntibody is automatically set based on the presented analyte (from Analytes option) in the standard sample. The Antibodies or SecondaryAntibodies field in Model[Molecule] of the analyte is inspected. If available, the DefaultSampleModel of a digoxigenin-labeled antibody is automatically selected as StandardCaptureAntibody. If no digoxigenin-labeled antibody is available, the DefaultSampleModel of an antibody with different epitopes with StandardDetectionAntibody (if uploaded) is automatically selected as StandardCaptureAntibody. If neither StandardCaptureAntibody or StandardDetectionAntibody has been specified and two antibodies with different epitopes are available for the analyte, the DefaultSampleModel of a polyclonal antibody is preferably selected for StandardCaptureAntibody.",
                AllowNull->True,
                Widget->Widget[
                    Type->Object,
                    Pattern:>ObjectP[{Model[Sample],Object[Sample]}]
                ],
				Category->"Standard Capture Antibody Preparation"
            },
            {
                OptionName->StandardCaptureAntibodyResuspension,
                Default->Automatic,
				Description->"Indicates if the StandardCaptureAntibody should be reconstituted with StandardCaptureAntibodyResuspensionDiluent. If set to True, the original container of the StandardCaptureAntibody sample is centrifuged at 3000 RPM for 1 Minute to eliminate sample loss upon cap opening. Then the StandardCaptureAntibodyResuspensionDiluent is delivered into the StandardCaptureAntibody's container and thorough mixing is achieved by inversion for 30 times.",
				ResolutionDescription->"StandardCaptureAntibodyResuspension is automatically set to True for a solid state StandardCaptureAntibody sample in a customizable cartridge.",
                AllowNull->True,
                Widget->Widget[
                    Type->Enumeration,
                    Pattern:>BooleanP
                ],
				Category->"Standard Capture Antibody Preparation"
            },
            {
                OptionName->StandardCaptureAntibodyResuspensionConcentration,
                Default->Automatic,
                Description->"The target final concentration of the resuspended StandardCaptureAntibody sample.",
                ResolutionDescription->"StandardCaptureAntibodyResuspensionConcentration option is automatically set to 1 Milligram/Milliliter if StandardCaptureAntibodyResuspension is True and a customizable cartridge is used.",
                AllowNull->True,
				Widget->Widget[
					Type->Quantity,
					Pattern:>GreaterP[0Molar]|GreaterP[0Gram/Liter],
					Units->Alternatives[
						{1,{Micromolar,{Micromolar,Millimolar,Molar}}},
						CompoundUnit[
							{1,{Milligram,{Milligram,Picogram,Microgram,Gram}}},
							{-1,{Milliliter,{Milliliter,Microliter,Liter}}}
						]
					]
				],
				Category->"Standard Capture Antibody Preparation"
            },
            {
                OptionName->StandardCaptureAntibodyResuspensionDiluent,
                Default->Automatic,
                Description->"The resuspension buffer mixed with the solid state StandardCaptureAntibody sample to dissolve the sample into solution.",
                ResolutionDescription->"StandardCaptureAntibodyResuspensionDiluent option is automatically set to Model[Sample, StockSolution, \"Filtered PBS, Sterile\"] if StandardCaptureAntibodyResuspension is True and a customizable cartridge is used. The amount of the solid state StandardCaptureAntibody sample is used to calculate the amount of StandardCaptureAntibodyResuspensionDiluent needed.",
                AllowNull->True,
                Widget->Widget[
                    Type->Object,
                    Pattern:>ObjectP[{Model[Sample],Object[Sample]}]
                ],
				Category->"Standard Capture Antibody Preparation"
            },
            {
                OptionName->StandardCaptureAntibodyStorageCondition,
                Default->Automatic,
                Description->"Indicates the condition under which the unused portion of liquid state StandardCaptureAntibody sample inside its original container is stored after the protocol is completed.",
                ResolutionDescription->"StandardCaptureAntibodyStorageCondition option is automatically set to Freezer if StandardCaptureAntibodyResuspension is True and a customizable cartridge is used.",
                AllowNull->True,
                Widget->Widget[
                    Type->Enumeration,
                    Pattern:>Alternatives[SampleStorageTypeP,Disposal]
                ],
				Category->"Post Experiment"
            },

            {
                OptionName->StandardCaptureAntibodyConjugation,
                Default->Automatic,
                Description->"Indicates if bioconjugation reaction between digoxigenin NHS-ester and primary amines of the StandardCaptureAntibody is required to be performed to prepare digoxigenin-labeled standard capture antibody sample for capillary ELISA experiment. If set to True, the conjugation mixture is vortexed at 1900 RPM for 1 Minute to allow thorough mixing and then incubated on a heat block at StandardCaptureAntibodyConjugationTemperature for StandardCaptureAntibodyConjugationTime to allow complete reaction.",
                ResolutionDescription->"StandardCaptureAntibodyConjugation is automatically set to True if the antibody composition of the StandardCaptureAntibody in the Customizable capillary ELISA cartridge does not show Model[Molecule,Protein,Antibody,\"Anti-Digoxigenin Antibody\"] as its SecondaryAntibodies.",
                AllowNull->True,
                Widget->Widget[
                    Type->Enumeration,
                    Pattern:>BooleanP
                ],
				Category->"Standard Capture Antibody Preparation"
            },
            {
                OptionName->StandardCaptureAntibodyVolume,
                Default->Automatic,
                Description->"The volume of the unconjugated StandardCaptureAntibody sample used to react with StandardDigoxigeninReagent to prepare digoxigenin-labeled standard capture antibody sample through bioconjugation synthesis.",
                ResolutionDescription->"StandardCaptureAntibodyVolume option is automatically set to 100 Microliter if StandardCaptureAntibodyConjugation is True and a customizable cartridge is used.",
                AllowNull->True,
                Widget->Widget[
                    Type->Quantity,
                    Pattern:>GreaterP[0Microliter],
                    Units->Alternatives[Microliter]
                ],
				Category->"Standard Capture Antibody Preparation"
            },
            {
                OptionName->StandardDigoxigeninReagent,
                Default->Automatic,
				Description->"The digoxigenin NHS-ester reagent used to react with the primary amines of the unconjugated StandardCaptureAntibody sample to prepare digoxigenin-labeled standard capture antibody sample through bioconjugation synthesis.",
                ResolutionDescription->"StandardDigoxigeninReagent option is automatically set to Model[Sample,StockSolution,\"Digoxigenin-NHS, 0.67 mg/mL in DMF\"] if StandardCaptureAntibodyConjugation is True and a customizable cartridge is used.",
                AllowNull->True,
                Widget->Widget[
                    Type->Object,
                    Pattern:>ObjectP[{Model[Sample],Object[Sample]}]
                ],
				Category->"Standard Capture Antibody Preparation"
            },
            {
                OptionName->StandardDigoxigeninReagentVolume,
                Default->Automatic,
                Description->"The volume of StandardDigoxigeninReagent used to react with StandardCaptureAntibodyVolume of the unconjugated StandardCaptureAntibody sample to prepare digoxigenin-labeled capture antibody sample through bioconjugation synthesis.",
				ResolutionDescription->"When a customizable cartridge is used, StandardDigoxigeninReagentVolume option is automatically set using the concentration of StandardDigoxigeninReagent and the antibody concentration to achieve a 5:1 molar ratio between StandardDigoxigeninReagent and the unconjugated StandardCaptureAntibody.",
                AllowNull->True,
                Widget->Widget[
                    Type->Quantity,
                    Pattern:>GreaterP[0Microliter],
                    Units->Alternatives[Microliter]
                ],
				Category->"Standard Capture Antibody Preparation"
            },
            {
                OptionName->StandardCaptureAntibodyConjugationBuffer,
                Default->Automatic,
				Description->"The buffer solution in which the reaction between the unconjugated StandardCaptureAntibody sample and StandardDigoxigeninReagent happens to prepare digoxigenin-labeled capture antibody sample through bioconjugation synthesis.",
                ResolutionDescription->"StandardCaptureAntibodyConjugationBuffer option is automatically set to Model[Sample,StockSolution,\"Sodium bicarbonate working stock 75 mg/mL\"] if StandardCaptureAntibodyConjugation is True and a customizable cartridge is used.",
                AllowNull->True,
                Widget->Widget[
                    Type->Object,
                    Pattern:>ObjectP[{Model[Sample],Object[Sample]}]
                ],
				Category->"Standard Capture Antibody Preparation"
            },
            {
                OptionName->StandardCaptureAntibodyConjugationBufferVolume,
                Default->Automatic,
                Description->"The volume of StandardCaptureAntibodyConjugationBuffer used to mix with the unconjugated StandardCaptureAntibody sample and StandardDigoxigeninReagent to provide a buffered environment for the bioconjugation reaction.",
                ResolutionDescription->"When a customizable cartridge is used, StandardCaptureAntibodyConjugationBufferVolume option is automatically set to 1/9 of total volume of StandardCaptureAntibodyVolume and StandardDigoxigeninReagentVolume.",
                AllowNull->True,
                Widget->Widget[
                    Type->Quantity,
                    Pattern:>GreaterEqualP[0Microliter],
                    Units->Alternatives[Microliter]
                ],
				Category->"Standard Capture Antibody Preparation"
            },
            {
                OptionName->StandardCaptureAntibodyConjugationContainer,
                Default->Automatic,
                Description->"The container in which the unconjugated StandardCaptureAntibody sample, StandardDigoxigeninReagent and StandardCaptureAntibodyConjugationBuffer react to allow bioconjugation synthesis.",
                ResolutionDescription->"StandardCaptureAntibodyConjugationContainer option is automatically selected base on the total conjugation reaction volume if StandardCaptureAntibodyConjugation is True and a customizable cartridge is used.",
                AllowNull->True,
                Widget->Widget[
                    Type->Object,
                    Pattern:>ObjectP[{Model[Container],Object[Container]}]
                ],
				Category->"Standard Capture Antibody Preparation"
            },
            {
                OptionName->StandardCaptureAntibodyConjugationTime,
                Default->Automatic,
				Description->"The amount of reaction time that the StandardCaptureAntibody and StandardDigoxigeninReagent are allowed to react before purification happens.",
                ResolutionDescription->"StandardCaptureAntibodyConjugationTime option is automatically set to 1 Hour if StandardCaptureAntibodyConjugation is True and a customizable cartridge is used.",
                AllowNull->True,
                Widget->Widget[
                    Type->Quantity,
					Pattern:>RangeP[0Minute,$MaxExperimentTime],
					Units->{1,{Hour,{Second,Minute,Hour}}}
                ],
				Category->"Standard Capture Antibody Preparation"
            },
            {
                OptionName->StandardCaptureAntibodyConjugationTemperature,
                Default->Automatic,
                Description->"The temperature at which the reaction between the unconjugated StandardCaptureAntibody and StandardDigoxigeninReagent is conducted.",
                ResolutionDescription->"StandardCaptureAntibodyConjugationTemperature option is automatically set to Ambient if StandardCaptureAntibodyConjugation is True and a customizable cartridge is used.",
                AllowNull->True,
                Widget->Alternatives[
                    Widget[
                        Type->Enumeration,
                        Pattern:>Alternatives[Ambient]
                    ],
                    Widget[
                        Type->Quantity,
						Pattern:>RangeP[-20Celsius,150Celsius],
                        Units->Alternatives[Celsius,Fahrenheit]
                    ]
                ],
				Category->"Standard Capture Antibody Preparation"
            },
            {
                OptionName->StandardCaptureAntibodyPurificationColumn,
                Default->Automatic,
				Description->"The desalting spin column used to adsorb the molecules that are smaller than its molecular weight cut-off (MWCO) on its resin bed to remove the free digoxigenin NHS-ester molecules in order to purify the synthesis product of the StandardCaptureAntibody bioconjugation reaction. The spin column is operated following the manufacturer's instruction (Figure 3.6 in ExperimentCapillaryELISA help file).",
				ResolutionDescription->"StandardCaptureAntibodyPurificationColumn is automatically set to a 40K molecular weight cut-off Zeba desalting spin column depending on the total volume of the synthesis reaction, if StandardCaptureAntibodyConjugation is True and a customizable cartridge is used.",
                AllowNull->True,
                Widget->Widget[
                    Type->Object,
					Pattern:>ObjectP[{Model[Container,Vessel,Filter],Object[Container,Vessel,Filter]}],
					PreparedSample->False,
					PreparedContainer->False
                ],
				Category->"Standard Capture Antibody Preparation"
            },
            {
                OptionName->StandardCaptureAntibodyColumnWashBuffer,
                Default->Automatic,
				Description->"The buffer solution loaded into the StandardCaptureAntibodyPurificationColumn after its storage buffer is removed and before the sample is loaded. The StandardCaptureAntibodyColumnWashBuffer flushed through StandardCaptureAntibodyPurificationColumn to remove any residues from the spin column storage solution. The washing process is repeated 3 times to equilibrate the resin bed before sample loading.",
                ResolutionDescription->"StandardCaptureAntibodyColumnWashBuffer option is automatically set to Model[Sample, StockSolution, \"Filtered PBS, Sterile\"] if StandardCaptureAntibodyConjugation is True and a customizable cartridge is used.",
                AllowNull->True,
                Widget->Widget[
                    Type->Object,
                    Pattern:>ObjectP[{Model[Sample],Object[Sample]}]
                ],
				Category->"Standard Capture Antibody Preparation"
            },
            {
                OptionName->StandardCaptureAntibodyConjugationStorageCondition,
                Default->Automatic,
                Description->"Indicates the condition under which the unused portion of the synthesized and purified digoxigenin-labeled standard capture antibody sample is stored after the protocol is completed.",
                ResolutionDescription->"StandardCaptureAntibodyConjugationStorageCondition option is automatically set to Refrigerator if StandardCaptureAntibodyConjugation is True and a customizable cartridge is used.",
                AllowNull->True,
                Widget->Widget[
                    Type->Enumeration,
                    Pattern:>Alternatives[SampleStorageTypeP, Disposal]
                ],
				Category->"Standard Capture Antibody Preparation"
            },

			{
				OptionName->StandardCaptureAntibodyDilution,
				Default->Automatic,
				Description->"Indicates if digoxigenin-labeled standard capture antibody dilution is required before loading into capillary ELISA cartridge.",
				ResolutionDescription->"When a Customizable capillary ELISA cartridge is used, StandardCaptureAntibodyDilution is automatically set to True if StandardCaptureAntibodyResuspension and/or StandardCaptureAntibodyConjugation is True.",
				AllowNull->True,
				Widget->Widget[
					Type->Enumeration,
					Pattern:>BooleanP
				],
				Category->"Standard Capture Antibody Preparation"
			},
			{
				OptionName->StandardCaptureAntibodyTargetConcentration,
				Default->Automatic,
				Description->"The desired concentration of digoxigenin-labeled standard capture antibody after dilution. The initial mass concentration of digoxigenin-labeled standard capture antibody sample is acquired from the composition of the liquid state StandardCaptureAntibody sample or the StandardCaptureAntibdoyResuspension of the solid state StandardCaptureAntibody sample. A 50% concentration loss is factored in if conjugation is performed in the experiment.",
				(*
				Description->"The desired concentration of digoxigenin-labeled standard capture antibody after dilution. The initial mass concentration of digoxigenin-labeled standard capture antibody sample is calculated by its absorbance at 280 nm and the average antibody absorbance coefficient - 1.35 (mL/mg)/cm.",
				*)
				ResolutionDescription->"StandardCaptureAntibodyTargetConcentration is automatically set to 3.5 Microgram/Milliliter if StandardCaptureAntibodyDilution is True and a customizable cartridge is used.",
				AllowNull->True,
				Widget->Widget[
					Type->Quantity,
					Pattern:>GreaterP[0Molar]|GreaterP[0Gram/Liter],
					Units->Alternatives[
						{1,{Micromolar,{Micromolar,Millimolar,Molar}}},
						CompoundUnit[
							{1,{Picogram,{Picogram,Microgram,Milligram,Gram}}},
							{-1,{Milliliter,{Milliliter,Microliter,Liter}}}
						]
					]
				],
				Category->"Standard Capture Antibody Preparation"
			},
            {
                OptionName->StandardCaptureAntibodyDiluent,
                Default->Automatic,
                Description->"The buffer solution used to mix with the concentrated digoxigenin-labeled standard capture antibody sample to achieve the desired StandardCaptureAntibodyTargetConcentration for cartridge loading.",
                ResolutionDescription->"StandardCaptureAntibodyDiluent option is automatically set to Model[Sample, \"Simple Plex Reagent Diluent\"] if StandardCaptureAntibodyDilution is True and a customizable cartridge is used.",
                AllowNull->True,
                Widget->Widget[
                    Type->Object,
                    Pattern:>ObjectP[{Model[Sample],Object[Sample]}]
                ],
				Category->"Standard Capture Antibody Preparation"
            },

            {
                OptionName->StandardDetectionAntibody,
                Default->Automatic,
				Description->"The standard detection antibody sample used in the sandwich ELISA experiment. After immobilization of the analytes in the microfluidic channels, the standard detection antibodies bind to analyte epitopes distinct from the standard capture antibodies through antigen-antibody interaction. Then the streptavidin-conjugated fluorescent dyes can be attached through biotin-streptavidin interaction for data acquiring. The standard detection antibody must be modified with biotin, purified and diluted to preferably 3.5 Microgram/Milliliter before loading into the capillary ELISA cartridge. The provided StandardDetectionAntibody can be resuspended into solution, bioconjugated with biotin and diluted as desired using the related options. Please note that if the same detection antibody preparation options are specified for multiple samples (standard samples and/or input samples), the preparation of biotinylated detection antibody is performed together. Please consider using ExperimentSampleManipulation for more customized standard detection antibody preparation.",
				ResolutionDescription->"If a customizable cartridge is used, StandardDetectionAntibody is automatically set based on the presented analyte (from Analytes option) in the standard sample. The Antibodies or SecondaryAntibodies field in Model[Molecule] of the main analyte is inspected. If available, the DefaultSampleModel of a biotinylated antibody is automatically selected as StandardDetectionAntibody. If no biotinylated antibody is available, the DefaultSampleModel of an antibody with different epitopes with StandardCaptureAntibody (if specified) is automatically selected as CustomDetectionAntibody. If neither StandardCaptureAntibody or StandardDetectionAntibody has been specified and two antibodies with different epitopes are available for the analyte, the DefaultSampleModel of a monoclonal antibody is preferably selected for StandardDetectionAntibody.",
                AllowNull->True,
                Widget->Widget[
                    Type->Object,
                    Pattern:>ObjectP[{Model[Sample],Object[Sample]}]
                ],
				Category->"Standard Detection Antibody Preparation"
            },
            {
                OptionName->StandardDetectionAntibodyResuspension,
                Default->Automatic,
                Description->"Indicates if the StandardCaptureAntibody should be reconstituted with StandardCaptureAntibodyResuspensionDiluent. If set to True, the original container of the StandardDetectionAntibody sample is centrifuged at 3000 RPM for 1 Minute to eliminate sample loss upon cap opening. Then the StandardDetectionAntibodyResuspensionDiluent is delivered into the StandardDetectionAntibody's container and thorough mixing is achieved by inversion for 30 times.",
                ResolutionDescription->"StandardDetectionAntibodyResuspension is automatically set to True for a solid state StandardDetectionAntibody sample in a Customizable capillary ELISA cartridge.",
                AllowNull->True,
                Widget->Widget[
                    Type->Enumeration,
                    Pattern:>BooleanP
                ],
				Category->"Standard Detection Antibody Preparation"
            },
            {
                OptionName->StandardDetectionAntibodyResuspensionConcentration,
                Default->Automatic,
                Description->"The target final concentration of the resuspended StandardDetectionAntibody sample.",
                ResolutionDescription->"StandardDetectionAntibodyResuspensionConcentration option is automatically set to 1 Milligram/Milliliter if StandardDetectionAntibodyResuspension is True and a customizable cartridge is used.",
                AllowNull->True,
				Widget->Widget[
					Type->Quantity,
					Pattern:>GreaterP[0Molar]|GreaterP[0Gram/Liter],
					Units->Alternatives[
						{1,{Micromolar,{Micromolar,Millimolar,Molar}}},
						CompoundUnit[
							{1,{Milligram,{Milligram,Picogram,Microgram,Gram}}},
							{-1,{Milliliter,{Milliliter,Microliter,Liter}}}
						]
					]
				],
				Category->"Standard Detection Antibody Preparation"
            },
            {
                OptionName->StandardDetectionAntibodyResuspensionDiluent,
                Default->Automatic,
                Description->"The resuspension buffer mixed with the solid state StandardDetectionAntibody sample to dissolve the sample into solution.",
                ResolutionDescription->"StandardDetectionAntibodyResuspensionDiluent option is automatically set to Model[Sample, StockSolution, \"Filtered PBS, Sterile\"] if StandardDetectionAntibodyResuspension is True and a customizable cartridge is used. The amount of the solid state StandardDetectionAntibody sample is used to calculate the amount of StandardDetectionAntibodyResuspensionDiluent needed.",
                AllowNull->True,
                Widget->Widget[
                    Type->Object,
                    Pattern:>ObjectP[{Model[Sample],Object[Sample]}]
                ],
				Category->"Standard Detection Antibody Preparation"
            },
            {
                OptionName->StandardDetectionAntibodyStorageCondition,
                Default->Automatic,
                Description->"Indicates the condition under which the unused portion of liquid state StandardDetectionAntibody sample inside its original container is stored after the protocol is completed.",
                ResolutionDescription->"StandardDetectionAntibodyStorageCondition option is automatically set to Freezer if StandardDetectionAntibodyResuspension is True and a customizable cartridge is used.",
                AllowNull->True,
                Widget->Widget[
                    Type->Enumeration,
                    Pattern:>Alternatives[SampleStorageTypeP,Disposal]
                ],
				Category->"Post Experiment"
            },
            {
                OptionName->StandardDetectionAntibodyConjugation,
                Default->Automatic,
				Description->"Indicates if bioconjugation reaction between Biotin-XX-SE (6-((6-((Biotinoyl)Amino)Hexanoyl)Amino)Hexanoic Acid, Succinimidyl Ester) and primary amines of the StandardDetectionAntibody is required to be performed to prepare biotinylated detection antibody sample for capillary ELISA experiment. If set to True, the conjugation mixture is vortexed at 1900 RPM for 1 Minute to allow thorough mixing and then incubated on a heat block at StandardDetectionAntibodyConjugationTemperature for StandardDetectionAntibodyConjugationTime to allow complete reaction.",
				ResolutionDescription->"StandardDetectionAntibodyConjugation is automatically set to True if the antibody composition of the StandardDetectionAntibody in the Customizable capillary ELISA cartridge does not show Model[Molecule,Protein,\"Streptavidin\"] as its Targets.",
                AllowNull->True,
                Widget->Widget[
                    Type->Enumeration,
                    Pattern:>BooleanP
                ],
				Category->"Standard Detection Antibody Preparation"
            },
            {
                OptionName->StandardDetectionAntibodyVolume,
                Default->Automatic,
				Description->"The volume of the unconjugated standard detection antibody sample used to react with StandardBiotinReagent to prepare biotinylated standard detection antibody sample through bioconjugation synthesis.",
                ResolutionDescription->"StandardDetectionAntibodyVolume option is automatically set to 100 Microliter if StandardDetectionAntibodyConjugation is True and a customizable cartridge is used.",
                AllowNull->True,
                Widget->Widget[
                    Type->Quantity,
                    Pattern:>GreaterP[0Microliter],
                    Units->Alternatives[Microliter]
                ],
				Category->"Standard Detection Antibody Preparation"
            },
            {
                OptionName->StandardBiotinReagent,
                Default->Automatic,
				Description->"The Biotin-XX-SE (6-((6-((Biotinoyl)Amino)Hexanoyl)Amino)Hexanoic Acid, Succinimidyl Ester) or other biotinylation reagent used to mix with the unconjugated StandardDetectionAntibody sample to prepare biotinylated standard detection antibody sample through bioconjugation synthesis.",
                ResolutionDescription->"StandardBiotinReagent option is automatically set to Model[Sample,StockSolution,\"Biotin-XX, 1 mg/mL in DMSO\"] if StandardDetectionAntibodyConjugation is True and a customizable cartridge is used.",
                AllowNull->True,
                Widget->Widget[
                    Type->Object,
                    Pattern:>ObjectP[{Model[Sample],Object[Sample]}]
                ],
				Category->"Standard Detection Antibody Preparation"
            },
            {
                OptionName->StandardBiotinReagentVolume,
                Default->Automatic,
                Description->"The volume of StandardBiotinReagent used to react with StandardDetectionAntibodyVolume of the unconjugated StandardDetectionAntibody sample to prepare biotinylated detection antibody sample through bioconjugation synthesis.",
				ResolutionDescription->"When a customizable cartridge is used, StandardBiotinReagentVolume option is automatically set using the concentration of StandardBiotinReagent and the antibody concentration to achieve a 10:1 molar ratio between StandardBiotinReagent and the unconjugated StandardDetectionAntibody.",
                AllowNull->True,
                Widget->Widget[
                    Type->Quantity,
                    Pattern:>GreaterP[0Microliter],
                    Units->Alternatives[Microliter]
                ],
				Category->"Standard Detection Antibody Preparation"
            },
            {
                OptionName->StandardDetectionAntibodyConjugationBuffer,
                Default->Automatic,
                Description->"The buffer solution in which the reaction between the unconjugated StandardDetectionAntibody sample and StandardBiotinReagent happens to prepare biotinylated standard detection antibody sample through bioconjugation synthesis.",
                ResolutionDescription->"StandardDetectionAntibodyConjugationBuffer option is automatically set to Model[Sample,StockSolution,\"Sodium bicarbonate working stock 75 mg/mL\"] if StandardDetectionAntibodyConjugation is True and a customizable cartridge is used.",
                AllowNull->True,
                Widget->Widget[
                    Type->Object,
                    Pattern:>ObjectP[{Model[Sample],Object[Sample]}]
                ],
				Category->"Standard Detection Antibody Preparation"
            },
            {
                OptionName->StandardDetectionAntibodyConjugationBufferVolume,
                Default->Automatic,
                Description->"The volume of StandardDetectionAntibodyConjugationBuffer used to mix with the unconjugated StandardDetectionAntibody sample and StandardBiotinReagent to provide a buffered environment for the bioconjugation reaction.",
                ResolutionDescription->"When a customizable cartridge is used, StandardDetectionAntibodyConjugationBufferVolume option is automatically set to 1/9 of total volume of StandardDetectionAntibodyVolume and StandardBiotinReagentVolume if both are uploaded.",
                AllowNull->True,
                Widget->Widget[
                    Type->Quantity,
                    Pattern:>GreaterP[0Microliter],
                    Units->Alternatives[Microliter]
                ],
				Category->"Standard Detection Antibody Preparation"
            },
            {
                OptionName->StandardDetectionAntibodyConjugationContainer,
                Default->Automatic,
                Description->"The container in which the unconjugated StandardDetectionAntibody sample, StandardBiotinReagent and StandardDetectionAntibodyConjugationBuffer react to allow bioconjugation synthesis.",
                ResolutionDescription->"StandardDetectionAntibodyConjugationContainer option is automatically selected base on the total conjugation reaction volume if StandardDetectionAntibodyConjugation is True and a customizable cartridge is used.",
                AllowNull->True,
                Widget->Widget[
                    Type->Object,
                    Pattern:>ObjectP[{Model[Container],Object[Container]}]
                ],
				Category->"Standard Detection Antibody Preparation"
            },
            {
                OptionName->StandardDetectionAntibodyConjugationTime,
                Default->Automatic,
				Description->"The amount of reaction time that the StandardDetectionAntibody and StandardBiotinReagent are allowed to react before purification happens.",
                ResolutionDescription->"StandardDetectionAntibodyConjugationTime option is automatically set to 1 Hour if StandardDetectionAntibodyConjugation is True and a customizable cartridge is used.",
                AllowNull->True,
                Widget->Widget[
                    Type->Quantity,
					Pattern:>RangeP[0Minute,$MaxExperimentTime],
					Units->{1,{Hour,{Second,Minute,Hour}}}
                ],
				Category->"Standard Detection Antibody Preparation"
            },
            {
                OptionName->StandardDetectionAntibodyConjugationTemperature,
                Default->Automatic,
                Description->"The temperature at which the reaction between the unconjugated StandardDetectionAntibody and StandardBiotinReagent is conducted.",
                ResolutionDescription->"StandardDetectionAntibodyConjugationTemperature option is automatically set to Ambient if StandardDetectionAntibodyConjugation is True and a customizable cartridge is used.",
                AllowNull->True,
                Widget->Alternatives[
                    Widget[
                        Type->Enumeration,
                        Pattern:>Alternatives[Ambient]
                    ],
                    Widget[
                        Type->Quantity,
						Pattern:>RangeP[-20Celsius,150Celsius],
						Units->Alternatives[Celsius,Fahrenheit]
                    ]
                ],
				Category->"Standard Detection Antibody Preparation"
            },
            {
                OptionName->StandardDetectionAntibodyPurificationColumn,
                Default->Automatic,
				Description->"The desalting spin column used to adsorb the molecules that are smaller than its molecular weight cut-off (MWCO) on its resin bed to remove the free biotinylation reagent molecules in order to purify the synthesis product of the StandardDetectionAntibody bioconjugation reaction. The spin column is operated following the manufacturer's instruction (Figure 3.7 in ExperimentCapillaryELISA help file).",
				ResolutionDescription->"StandardDetectionAntibodyPurificationColumn is automatically set to a 40K molecular weight cut-off Zeba desalting spin column depending on the total volume of the synthesis reaction, if StandardDetectionAntibodyConjugation is True and a customizable cartridge is used.",
                AllowNull->True,
                Widget->Widget[
                    Type->Object,
					Pattern:>ObjectP[{Model[Container,Vessel,Filter],Object[Container,Vessel,Filter]}],
					PreparedSample->False,
					PreparedContainer->False
				],
				Category->"Standard Detection Antibody Preparation"
            },
            {
                OptionName->StandardDetectionAntibodyColumnWashBuffer,
                Default->Automatic,
				Description->"The buffer solution loaded into the StandardDetectionAntibodyPurificationColumn after its storage buffer is removed and before the sample is loaded. The StandardDetectionAntibodyColumnWashBuffer flushed through DetectionAntibodyPurificationColumn to remove any residues from the spin column storage solution. The washing process is repeated 3 times to equilibrate the resin bed before sample loading.",
                ResolutionDescription->"StandardDetectionAntibodyColumnWashBuffer option is automatically set to Model[Sample, StockSolution, \"Filtered PBS, Sterile\"] if StandardDetectionAntibodyConjugation is True and a customizable cartridge is used.",
                AllowNull->True,
                Widget->Widget[
                    Type->Object,
                    Pattern:>ObjectP[{Model[Sample],Object[Sample]}]
                ],
				Category->"Standard Detection Antibody Preparation"
            },
            {
                OptionName->StandardDetectionAntibodyConjugationStorageCondition,
                Default->Automatic,
                Description->"Indicates the condition under which the unused portion of the synthesized and purified biotinylated detection antibody sample is stored after the protocol is completed.",
                ResolutionDescription->"StandardDetectionAntibodyConjugationStorageCondition option is automatically set to Refrigerator if StandardDetectionAntibodyConjugation is True and a customizable cartridge is used.",
                AllowNull->True,
                Widget->Widget[
                    Type->Enumeration,
                    Pattern:>Alternatives[SampleStorageTypeP, Disposal]
                ],
				Category->"Standard Detection Antibody Preparation"
            },

			{
				OptionName->StandardDetectionAntibodyDilution,
				Default->Automatic,
				Description->"Indicates if biotinylated standard detection antibody dilution is required before loading into capillary ELISA cartridge.",
				ResolutionDescription->"When a Customizable capillary ELISA cartridge is used, StandardDetectionAntibodyDilution is automatically set to True if StandardDetectionAntibodyResuspension and/or StandardDetectionAntibodyConjugation is True.",
				AllowNull->True,
				Widget->Widget[
					Type->Enumeration,
					Pattern:>BooleanP
				],
				Category->"Standard Detection Antibody Preparation"
			},
			{
				OptionName->StandardDetectionAntibodyTargetConcentration,
				Default->Automatic,
				Description->"The desired concentration of biotinylated standard detection antibody after dilution. The initial mass concentration of biotinylated standard detection antibody sample is acquired from the composition of the liquid state StandardDetectionAntibody sample or the StandardDetectionAntibdoyResuspension of the solid state StandardDetectionAntibody sample. A 50% concentration loss is factored in if conjugation is performed in the experiment.",
				(*
				Description->"The desired concentration of biotinylated standard detection antibody after dilution. The initial mass concentration of biotinylated standard detection antibody sample is calculated by its absorbance at 280 nm and the average antibody absorbance coefficient - 1.35 (mL/mg)/cm.",
				*)
				ResolutionDescription->"StandardDetectionAntibodyTargetConcentration is automatically set to 3.5 Microgram/Milliliter if StandardDetectionAntibodyDilution is True and a customizable cartridge is used.",
				AllowNull->True,
				Widget->Widget[
					Type->Quantity,
					Pattern:>GreaterP[0Molar]|GreaterP[0Gram/Liter],
					Units->Alternatives[
						{1,{Micromolar,{Micromolar,Millimolar,Molar}}},
						CompoundUnit[
							{1,{Picogram,{Picogram,Microgram,Milligram,Gram}}},
							{-1,{Milliliter,{Milliliter,Microliter,Liter}}}
						]
					]
				],
				Category->"Standard Detection Antibody Preparation"
			},
            {
                OptionName->StandardDetectionAntibodyDiluent,
                Default->Automatic,
                Description->"The buffer solution used to mix with the concentrated biotinylated detection antibody sample to achieve the specified StandardDetectionAntibodyTargetConcentration for cartridge loading.",
                ResolutionDescription->"StandardDetectionAntibodyDiluent option is automatically set to Model[Sample, \"Simple Plex Reagent Diluent\"] if StandardDetectionAntibodyDilution is True and a customizable cartridge is used.",
                AllowNull->True,
                Widget->Widget[
                    Type->Object,
                    Pattern:>ObjectP[{Model[Sample],Object[Sample]}]
                ],
				Category->"Standard Detection Antibody Preparation"
            }
        ],

		{
			OptionName->WashBuffer,
			Default->Model[Sample, "id:4pO6dM50p9kw"], (* Model[Sample,"Simple Plex Wash Buffer"] *)
			Description->"The buffer that is used to remove excess reagents between the antibody binding steps.",
			AllowNull->False,
			Widget->Widget[
				Type->Object,
				Pattern:>ObjectP[{Model[Sample],Object[Sample]}]
			],
			Category->"Washing"
		},

		IndexMatching[
			IndexMatchingInput->"experiment samples",
			{
				OptionName->LoadingVolume,
				Default->50Microliter,
				Description->"The volume of each prepared input sample loaded into the capillary ELISA cartridge.",
				AllowNull->False,
				Widget->Widget[
					Type->Quantity,
					Pattern:>RangeP[25Microliter,90Microliter],
					Units->Alternatives[Microliter]
				],
				Category->"Cartridge Loading"
			},
			{
				OptionName->CaptureAntibodyLoadingVolume,
				Default->Automatic,
				Description->"The volume of the digoxigenin-labeled capture antibody sample loaded into the capture antibody well of the customizable capillaryELISA cartridge plate.",
				ResolutionDescription->"CaptureAntibodyLoadingVolume option is automatically set to 50 Microliter if a customizable cartridge is used.",
				AllowNull->True,
				Widget->Widget[
					Type->Quantity,
					Pattern:>RangeP[25Microliter,50Microliter],
					Units->Alternatives[Microliter]
				],
				Category->"Cartridge Loading"
			},
			{
				OptionName->DetectionAntibodyLoadingVolume,
				Default->Automatic,
				Description->"The volume of the biotinylated detection antibody sample to be loaded into the detection antibody well of the customizable capillaryELISA cartridge plate.",
				ResolutionDescription->"DetectionAntibodyLoadingVolume option is automatically set to 50 Microliter iif a customizable cartridge is used.",
				AllowNull->True,
				Widget->Widget[
					Type->Quantity,
					Pattern:>RangeP[25Microliter,50Microliter],
					Units->Alternatives[Microliter]
				],
				Category->"Cartridge Loading"
			}
		],

		IndexMatching[
			IndexMatchingParent->Standard,
			{
				OptionName->StandardLoadingVolume,
				Default->Automatic,
				Description->"The volume of each prepared standard sample loaded into the capillary ELISA cartridge.",
				ResolutionDescription->"StandardLoadingVolume option is automatically set to 50 Microliter if Standard option is not Null.",
				AllowNull->True,
				Widget->Widget[
					Type->Quantity,
					Pattern:>RangeP[25Microliter,90Microliter],
					Units->Alternatives[Microliter]
				],
				Category->"Cartridge Loading"
			},
			{
				OptionName->StandardCaptureAntibodyLoadingVolume,
				Default->Automatic,
				Description->"The volume of the digoxigenin-labeled standard capture antibody sample to be loaded into the capture antibody well of the customizable capillaryELISA cartridge plate.",
				ResolutionDescription->"StandardCaptureAntibodyLoadingVolume option is automatically set to 50 Microliter if a customizable cartridge is used.",
				AllowNull->True,
				Widget->Widget[
					Type->Quantity,
					Pattern:>RangeP[25Microliter,50Microliter],
					Units->Alternatives[Microliter]
				],
				Category->"Cartridge Loading"
			},
			{
				OptionName->StandardDetectionAntibodyLoadingVolume,
				Default->Automatic,
				Description->"The volume of the biotinylated standard detection antibody sample to be loaded into the detection antibody well of the customizable capillaryELISA cartridge plate.",
				ResolutionDescription->"StandardDetectionAntibodyLoadingVolume option is automatically set to 50 Microliter if a customizable cartridge is used.",
				AllowNull->True,
				Widget->Widget[
					Type->Quantity,
					Pattern:>RangeP[25Microliter,50Microliter],
					Units->Alternatives[Microliter]
				],
				Category->"Cartridge Loading"
			}
		],

		IndexMatching[
			IndexMatchingParent->Standard,
			{
				OptionName->StandardComposition,
				Default->Automatic,
				Description->"The known concentration(s) of presented analyte(s) in the Standard sample before dilution. This information can be used to generate standard curve.",
				ResolutionDescription->"KnownConcentration is automatically set to StandardResuspensionConcentration if the resuspension is performed within this protocol. Otherwise it is automatically set using the information from the Composition field of the Standard sample.",
				AllowNull->True,
				Widget->Adder[
					List[
						"Concentration"->Widget[
							Type->Quantity,
							Pattern:>GreaterP[0Molar]|GreaterP[0Gram/Liter],
							Units->Alternatives[
								{1,{Micromolar,{Micromolar,Millimolar,Molar}}},
								CompoundUnit[
									{1,{Picogram,{Picogram,Microgram,Milligram,Gram}}},
									{-1,{Milliliter,{Milliliter,Microliter,Liter}}}
								]
							]
						],
						"Analyte"->Widget[
							Type->Object,
							Pattern:>ObjectP[{Model[Molecule]}]
						]
					]
				],
				Category->"Data Processing"
			}
		],

		IndexMatching[
			IndexMatchingInput->"experiment samples",
			{
				OptionName->SpikeConcentration,
				Default->Automatic,
				Description->"The known concentration(s) of the analyte(s) in SpikeSample. This information is used for calculation of the analyte concentration(s) in unknown sample if a standard curve is available. For a pre-loaded cartridge with more than 1 analyte, concentrations of different analytes can be provided for the SpikeSample.",
				ResolutionDescription->"SpikeConcentration is automatically set using the information from the Composition field of the SpikeSample.",
				AllowNull->True,
				Widget->Adder[
					List[
						"Concentration"->Widget[
							Type->Quantity,
							Pattern:>GreaterP[0Molar]|GreaterP[0Gram/Liter],
							Units->Alternatives[
								{1,{Micromolar,{Micromolar,Millimolar,Molar}}},
								CompoundUnit[
									{1,{Picogram,{Picogram,Microgram,Milligram,Gram}}},
									{-1,{Milliliter,{Milliliter,Microliter,Liter}}}
								]
							]
						],
						"Analyte"->Widget[
							Type->Object,
							Pattern:>ObjectP[{Model[Molecule]}]
						]
					]
				],
				Category->"Data Processing"
			}
        ],

        FuntopiaSharedOptions,
		AnalyticalNumberOfReplicatesOption,
        SamplesInStorageOptions
        (*No SampleOut*)
    }

];



(* ::Subsubsection::Closed:: *)
(* ExperimentCapillaryELISA Error Messages *)

Error::TooManyCapillaryELISAInputSamples="The maximum number of input samples for one CapillaryELISA protocol is 72. Please enter fewer input samples, delete number of replciates, or queue an additional experiment for the excess input samples.";
Error::RetiredCapillaryELISAInstrument="The specified capillary ELISA instrument `1` cannot be retired. Please specify a capillary ELISA instrument that is not retired.";
Error::DeprecatedCapillaryELISAInstrumentModel="The model of the specified capillary ELISA instrument `1` cannot be deprecated. Please specify a capillary ELISA instrument model that is not deprecated.";
Error::DiscardedCapillaryELISACartridge="The specified capillary ELISA cartridge `1` cannot be discarded. The capillary ELISA cartridges are single use and are marked as discarded after one capillary ELISA protocol. Please specify a capillary ELISA cartridge that is not discarded.";
Error::TooManyLoadingSamplesForCapillaryELISA="The total number of loading samples (considering number of replicates, all dilutions and the standard samples) must be equal to or fewer than 72. Please select fewer input samples, do fewer dilutions or delete some standard samples.";
Error::ExceedCapillaryELISACartridgeCapacity="The total number of loading samples (considering number of replicates, all dilutions and the standard samples) must be equal to or fewer than the capacity of cartridge specified in `1` option. Please change `1` option to higher capacity, select fewer input samples, doing fewer dilutions or deleting some standard samples.";
Error::CannotCreateNewCustomizableCartridge="If Cartridge is set to Null, CartridgeType cannot be set to Customizable as the customizable cartridge model already exists in the database. To use a Customizable cartridge, please make sure the total number of samples is below 48 and set Cartridge to Model[Container,Plate,Irregular,CapillaryELISA,\"Human 48-Digoxigenin Cartridge\"].";
Error::ConflictCartridgeAndCartridgeType="The specified CartridgeType must be the same as the CartridgeType of the specified Cartridge option. Please match the two options or set CartridgeType option to Default to continue.";
Error::ConflictCartridgeAndAnalytes="The specified Analytes must be the same as the Analytes of the specified Cartridge option. Please match the two options or set Analytes option to Default to continue.";
Error::ConflictPreLoadedAnalytes="All samples must be subject to the same analyates in a capillary ELISA experiment using a pre-loaded capillary ELISA cartridge. Please make sure the same Analytes are selected.";
Error::ExceedLengthAnalytesForCustomizableCartridge="In a customizable cartridge, only 1 analyte can be tested for a single sample in a capillary ELISA cartridge. Please choose only 1 analyte for the samples `1` or use a pre-loaded multi-analyte cartridge.";
Error::CannotUseMultiPlex32X8CartridgeForNonHuman="MultiPlex32X8 cartridge is for Pro-Inflammation and Oncology panel only and cannot be used for non-human species. Please correct CartridgeType option or Species option to continue.";
Error::DuplicatedAnalytes="The specified Analytes option for a pre-loaded capillary ELISA cartridge should not have duplicated members `1`.";
Error::TooManyAnalytes="The total number of the analytes in the specified Analytes option should be smaller than or equal to the capacity `1` of `2`. `3`";
Error::TooManyAnalytesForSampleNumber="The total number of the samples must be less than or equal to 48 for a customizable cartridge or 32 for a pre-loaded multi-analyte cartridge. To select more than 1 analyte, please select fewer input samples, do fewer dilutions, delete some standard samples or remove number of replicates.";
Error::UnsupportedAnalytes="The specified Analytes `1` are not supported by pre-loaded cartridges in CapillaryELISA experiment. Please check documentation of ExperimentCapillaryELISA and search available objects in type Object[ManufacturingSpecification,CapillaryELISACartridge] for information about current supported analytes.";
Error::AnalytesSpeciesUnavailable="The specified Analytes `1` are not available for the specified Species. Please check to make sure both options are correct.";
Error::AnalytesIncompatibleWithCartridgeType="The specified Analytes `1` is not available for MultiPlex32X8 assays - the only pre-loaded cartridge type to test more than 4 analytes in a single sample. Please check documentation of ExperimentCapillaryELISA and search Object[ManufacturingSpecification,CapillaryELISACartridge] with condition CartridgeType==MultiPlex32X8 for a list of current supported analytes.";
Error::NoCommonDiluentForAnalytes="The specified analytes must be able to share the same recommended diluent to be used together in a single capillary ELISA cartridge. Please check Object[ManufacturingSpecification,CapillaryELISACartridge] objects (`1`) of the specified analytes for their minimum dilution factors and delete members of analytes to continue.";
Error::NoCommonMinDilutionFactorForAnalytes="The specified analytes must be able to share the same recommended minimum dilution factor to be used together in a single capillary ELISA cartridge. Please check Object[ManufacturingSpecification,CapillaryELISACartridge] objects (`1`) of the specified analytes for their minimum dilution factors and delete members of analytes to continue.";
Error::IncompatibleAnalytes="The specified Analytes are not compatible with each other and cannot be used together in a single capillary ELISA cartridge. Please check Object[ManufacturingSpecification,CapillaryELISACartridge] objects (`1`) of the specified analytes for their incompatible analytes and delete the incompatible members of analytes to continue.";
Error::CannotSpecifySpikeOptions="SpikeSample related options `2` cannot be specified for the samples `1` with SpikeSample set to Null.";
Error::NonLiquidSpike="The SpikeSample `1` (to be mixed with input samples `2`) do not have a Liquid state and cannot be processed into capillary ELISA experiment. Please select a different SpikeSample or use preparatory primitives to dissolve the sample before proceeding.";
Error::MustSpecifySpikeOptions="SpikeSample related options `3` must be specified for the SpikeSample `2` and the input samples `1` so that the mixing of the two samples can be achieved.";
Error::IncosistentAnalyteAndSpikeConcentration="The SpikeConcentration should show the concentration of at least one analyte for the SpikeSample `1` (to be mixed with samples `2`). Please provide the correct concentration values to continue.";
Error::NotEnoughSampleVolumeAndSpikeVolume="The given SampleVolume (plus SpikeVolume, if applicable) is smaller than the required volume used to make the specified dilution curves for the samples `1`. Please select larger SampleVolume and/or SpikeVolume to continue.";
Error::ConflictDilutionCurve="Only one of DilutionCurve and SerialDilutionCurve can be specified or Null for samples `1`. Please change one of the two options. Dilution is required on all the loading samples for the best performance of microfluidics. To directly use the sample without dilution, please consider setting DilutionCurve to FixedDilutionVolume with DiluentVolume of 0 Microliter.";
Warning::CapillaryELISASampleDilution="Dilution is required on all the loading samples for the best performance of microfluidics. While `1` is set to Null for the samples `3`, dilution is automatically selected using `2`. To directly use the sample without dilution, please consider setting DilutionCurve to FixedDilutionVolume with DiluentVolume of 0 Microliter.";
Warning::NonOptimalLoadingVolume="The loading volume of samples `1` should be larger than 50 Microliter for optimized results.";
Error::NotEnoughDilutionPreparationVolume="The prepared volume of each diluted sample `1` must be larger than the loading volume `2` plus 5 Microliter. Please change the dilution options DilutionCurve and SerialDilutionCurve to prepare larger volume of the samples.";
Error::TooLargeDilutionMixVolumeForCapillaryELISASample="The specified DilutionMixVolume of the sample `1` should be smaller than the prepared volume of each diluted sample. Please change the dilution options DilutionCurve and SerialDilutionCurve to prepare larger volumes of the samples or use smaller DilutionMixVolume.";
Error::CannotSpecifyAntibodyOptions="The CustomCaptureAntibody and CustomDetectionAntibody related options `2` cannot be specified for samples `1` when the cartridge is not customizable.";
Error::InvalidCaptureAntibodyResuspensionForSolid="CaptureAntibodyResuspension option must be True for solid state capture antibody samples `1`, used for ELISA assay for samples `2`.";
Error::InvalidCaptureAntibodyResuspensionForLiquid="CaptureAntibodyResuspension option cannot be True for liquid state capture antibody samples `1`, used for ELISA assay for samples `2`.";
Error::CannotSpecifyCaptureAntibodyResuspensionOptions="CaptureAntibodyResuspension related options `2` cannot be specified for capture antibody samples `1` (used for ELISA assay for samples `3`) with a liquid state or with CaptureAntibodyResuspension option set to False or Null. Please correct the conflicting options to continue.";
Error::MustSpecifyCaptureAntibodyResuspensionOptions="CaptureAntibodyResuspension related options `2` cannot be Null for capture antibody samples `1` (used for ELISA assay for samples `3`) with a solid state or with CaptureAntibodyResuspension set to True. Please correct the conflicting options to continue.";
Error::CannotSpecifyCaptureAntibodyConjugationOptions="CaptureAntibodyConjugation related options `2` cannot be specified for capture antibody samples `1` (used for ELISA assay for samples `3`) with CaptureAntibodyConjugation option set to False or Null.";
Error::MustSpecifyCaptureAntibodyConjugationOptions="CaptureAntibodyConjugation related options `2` cannot be Null for capture antibody samples `1` (used for ELISA assay for samples `3`) with CaptureAntibodyConjugation set to True.";
Error::ConflictCaptureAntibodyConjugationOptions="CaptureAntibodyConjugation related options should be all Null or not Null for capture antibody samples `1` (used for ELISA assay for samples `2`) so the value of CaptureAntibodyConjugation option can be selected. Please check all the option values.";
Error::UnsupportedCaptureAntibodyPurificationColumn="The specified CaptureAntibodyPurificationColumn should be a supported Zeba spin column (preferably 40K MWCO) for the purification of capture antibody samples `1`, used for ELISA assay of the samples `2`. Please select one of `3` to continue.";
Warning::NonOptimalCaptureAntibodyPurificationColumn="The specified CaptureAntibodyPurificationColumn should be a Zeba 40K MWCO spin column for the purification of capture antibody samples `1`, used for ELISA assay of the samples `2` for the best purification results. Please consider selecting `3`.";
Error::CannotSpecifyCaptureAntibodyDilutionOptions="CaptureAntibodyDilution related options `2` cannot be specified for capture antibody samples `1` (used for ELISA assay for samples `3`) with CaptureAntibodyDilution set to False or Null.";
Warning::CaptureAntibodyDilutionRecommended="CaptureAntibodyDilution is recommended (not Null) for capture antibody samples `1` (used for ELISA assay for samples `2`), because resupension and/or conjugation of the antibody is performed in this protocol and the concentration of the antibody may be too high for capillary ELISA experiment.";
Error::MustSpecifyCaptureAntibodyDilutionOptions="CaptureAntibodyDilution related options `2` cannot be Null for capture antibody samples `1` (used for ELISA assay for samples `3`) with CaptureAntibodyDilution set to True. Please check all the option values.";
Error::ConflictCaptureAntibodyDilutionOptions="CaptureAntibodyTargetConcentration and CaptureAntibodyDiluent options should be both Null or not Null for capture antibody samples `1` (used for ELISA assay for samples `2`) so the value of CaptureAntibodyDilution option can be selected: ";
Warning::NonOptimalCaptureAntibodyDiluent="The CaptureAntibodyDiluent option should be kept as Model[Sample,\"Simple Plex Reagent Diluent\"] or a sample object with this model for the capture antibody samples `1` for optimized dilution and ELISA results. These capture antibody samples are used for ELISA assays of `2`.";
Error::MustSpecifyCaptureAntibodyLoadingVolume="When a customizable cartridge is used, the CaptureAntibodyLoadingVolume option is not Null for the capture antibody samples `1`, used for ELISA assay of `2`.";
Error::InvalidDetectionAntibodyResuspensionForSolid="DetectionAntibodyResuspension option must be True for solid state detection antibody samples `1`, used for ELISA assay for samples `2`.";
Error::InvalidDetectionAntibodyResuspensionForLiquid="DetectionAntibodyResuspension option cannot be True for liquid state detection antibody samples `1`, used for ELISA assay for samples `2`.";
Error::CannotSpecifyDetectionAntibodyResuspensionOptions="DetectionAntibodyResuspension related options `2` cannot be specified for detection antibody samples `1` (used for ELISA assay for samples `3`) with a liquid state or with DetectionAntibodyResuspension option set to False or Null. Please correct the conflicting options to continue.";
Error::MustSpecifyDetectionAntibodyResuspensionOptions="DetectionAntibodyResuspension related options `2` cannot be Null for detection antibody samples `1` (used for ELISA assay for samples `3`) with a solid state or with DetectionAntibodyResuspension option set to False or Null.";
Error::CannotSpecifyDetectionAntibodyConjugationOptions="DetectionAntibodyConjugation related options `2` cannot be specified for detection antibody samples `1` (used for ELISA assay for samples `3`) with DetectionAntibodyConjugation option set to False or Null.";
Error::MustSpecifyDetectionAntibodyConjugationOptions="DetectionAntibodyConjugation related options `2` cannot be Null for detection antibody samples `1` (used for ELISA assay for samples `3`) with DetectionAntibodyConjugation set to True.";
Error::ConflictDetectionAntibodyConjugationOptions="DetectionAntibodyConjugation related options should be all Null or not Null for detection antibody samples `1` (used for ELISA assay for samples `2`) so the value of DetectionAntibodyConjugation option can be selected. Please check all the option values.";
Error::UnsupportedDetectionAntibodyPurificationColumn="The specified DetectionAntibodyPurificationColumn should be a supported Zeba spin column (preferably 40K MWCO) for the purification of detection antibody samples `1`, used for ELISA assay of the samples `2`. Please select one of `3` to continue.";
Warning::NonOptimalDetectionAntibodyPurificationColumn="The specified DetectionAntibodyPurificationColumn should be a Zeba 40K MWCO spin column for the purification of detection antibody samples `1`, used for ELISA assay of the samples `2` for the best purification results. Please consider selecting `3`.";
Error::CannotSpecifyDetectionAntibodyDilutionOptions="DetectionAntibodyDilution related options `2` cannot be specified for detection antibody samples `1` (used for ELISA assay for samples `3`) with DetectionAntibodyDilution set to False or Null.";
Warning::DetectionAntibodyDilutionRecommended="DetectionAntibodyDilution is recommended (not Null) for detection antibody samples `1` (used for ELISA assay for samples `2`), because resupension and/or conjugation of the antibody is performed in this protocol and the concentration of the antibody may be too high for capillary ELISA experiment.";
Error::MustSpecifyDetectionAntibodyDilutionOptions="DetectionAntibodyDilution related options `2` cannot be Null for detection antibody samples `1` (used for ELISA assay for samples `3`) with DetectionAntibodyDilution set to True. Please check all the option values.";
Error::ConflictDetectionAntibodyDilutionOptions="DetectionAntibodyTargetConcentration and DetectionAntibodyDiluent options should be both Null or not Null for detection antibody samples `1` (used for ELISA assay for samples `2`) so the value of DetectionAntibodyDilution option can be selected: ";
Warning::NonOptimalDetectionAntibodyDiluent="The DetectionAntibodyDiluent option should be kept as Model[Sample,\"Simple Plex Reagent Diluent\"] or a sample object with this model for the detection antibody samples `1` for optimized dilution and ELISA results.  These detection antibody samples are used for ELISA assays of `2`.";
Error::MustSpecifyDetectionAntibodyLoadingVolume="When a customizable cartridge is used, the DetectionAntibodyLoadingVolume option is not Null for the detection antibody samples `1`, used for ELISA assay of `2`.";
Error::CannotSpecifyNullStandard="The specified Standard option should not have Null member.";
Error::CannotSpecifyStandardOptions="When Standard is set to Null, Standard related options `1` should also be set to Null.";
Error::InvalidStandardResuspensionForSolid="StandardResuspension option must be True for solid state standard samples `1`.";
Error::InvalidStandardResuspensionForLiquid="StandardResuspension option cannot be True for liquid state standard samples `1`.";
Error::CannotSpecifyStandardResuspensionOptions="StandardResuspension related options `2` cannot be specified for standard samples `1` with a liquid state or with StandardResuspension option set to False or Null. Please correct the conflicting options to continue.";
Error::MustSpecifyStandardResuspensionOptions="StandardResuspension related options `2` must be specified for standard samples `1` with a solid state or with StandardResuspension option set to True.";
Error::MustSpecifyStandardOptions="When Standard is not Null, Standard related options `1` should not be Null for the standard samples `2`.";
Error::ConflictStandardDilutionCurve="Only one of StandardDilutionCurve and StandardSerialDilutionCurve can be specified or Null for standard samples `1`. Please change one of the two options. Dilution is required on all the loading samples for the best performance of microfluidics. To directly use the standard sample without dilution, please consider setting StandardDilutionCurve to FixedDilutionVolume with DiluentVolume of 0 Microliter.";
Warning::CapillaryELISAStandardDilution="Dilution is required on all the loading samples for the best performance of microfluidics. While `1` is set to Null for the standard samples `3`, dilution is automatically selected using `2`. To directly use the standard sample without dilution, please consider setting StandardDilutionCurve to FixedDilutionVolume with DiluentVolume of 0 Microliter.";
Warning::NonOptimalStandardDilutionCurve="The total number of dilutions for standard samples `1` should be larger than 5 to generate a valid standard curve.";
Warning::NonOptimalStandardLoadingVolume="The loading volume of standard samples `1` should be larger than 50 Microliter for optimized results.";
Error::NotEnoughStandardDilutionPreparationVolume="The prepared volume of each diluted standard sample `1` must be larger than the standard loading volume `2` plus 5 Microliter. The default standard loading volume is 50 Microliter for each standard sample. Please change the dilution options StandardDilutionCurve and StandardSerialDilutionCurve to prepare larger volume of the samples.";
Error::InvalidCapillaryELISASampleStandardDilutionCurve="The provided linear StandardDilutionCurve for standard samples `1` should not yield a diluted sample with dilution factor larger than 1. Please correct the StandardDilutionCurve option to continue.";
Error::TooLargeDilutionMixVolumeForCapillaryELISAStandard="The specified StandardDilutionMixVolume of the standard sample `1` should be smaller than the prepared volume of each diluted standard sample. Please change the standard dilution options StandardDilutionCurve and StandardSerialDilutionCurve to prepare larger volumes of the samples or use smaller StandardDilutionMixVolume.";
Warning::ConflictCapillaryELISAStandardComposition="StandardComposition concentration of standard samples `1` should be the same as StandardResuspensionConcentration when resuspension of solid sample is performed in this protocol.";
Error::ExceedStandardComposition="If the cartridge is customizable, only one concentration can be provided in StandardComposition standard samples `1` because only one analyte can be analyzed in this protocol. Please provide only one concentration for data analysis.";
Error::AnalyteUnavailableInStandardComposition="The StandardComposition should show the concentration of at least one analyte for the standard samples `1`. Please provide the correct concentration values to continue.";
Error::CannotSpecifyStandardAntibodyOptions="The StandardCaptureAntibody and StandardDetectionAntibody related options `2` cannot be specified for standard samples `1` when the cartridge is not customizable.";
Error::InvalidStandardCaptureAntibodyResuspensionForSolid="StandardCaptureAntibodyResuspension option must be True for solid state standard capture antibody samples `1`, used for ELISA assay for standard samples `2`.";
Error::InvalidStandardCaptureAntibodyResuspensionForLiquid="StandardCaptureAntibodyResuspension option cannot be True for liquid state standard capture antibody samples `1`, used for ELISA assay for standard samples `2`.";
Error::CannotSpecifyStandardCaptureAntibodyResuspensionOptions="StandardCaptureAntibodyResuspension related options `2` cannot be specified for standard capture antibody samples `1` (used for ELISA assay for standard samples `3`) with StandardCaptureAntibodyResuspension set to False or Null.";
Error::MustSpecifyStandardCaptureAntibodyResuspensionOptions="StandardCaptureAntibodyResuspension related options `2` cannot be Null for standard capture antibody samples `1` (used for ELISA assay for standard samples `3`) with a solid state or with CaptureAntibodyResuspension set to True. Please correct the conflicting options to continue.";
Error::CannotSpecifyStandardCaptureAntibodyConjugationOptions="StandardCaptureAntibodyConjugation related options `2` cannot be specified for standard capture antibody samples `1` (used for ELISA assay for standard samples `3`) with StandardCaptureAntibodyConjugation option set to False or Null.";
Error::MustSpecifyStandardCaptureAntibodyConjugationOptions="StandardCaptureAntibodyConjugation related options `2` cannot be Null for standard capture antibody samples `1` (used for ELISA assay for standard samples `3`) with StandardCaptureAntibodyConjugation set to True.";
Error::ConflictStandardCaptureAntibodyConjugationOptions="StandardCaptureAntibodyConjugation related options should be all Null or not Null for standard capture antibody samples `1` (used for ELISA assay for samples `2`) so the value of StandardCaptureAntibodyConjugation option can be selected. Please check all the option values.";
Error::UnsupportedStandardCaptureAntibodyPurificationColumn="The specified StandardCaptureAntibodyPurificationColumn should be a supported Zeba spin column (preferably 40K MWCO) for the purification of standard capture antibody samples `1`, used for ELISA assay of the samples `2`. Please select one of `3` to continue.";
Warning::NonOptimalStandardCaptureAntibodyPurificationColumn="The specified StandardCaptureAntibodyPurificationColumn should be a Zeba 40K MWCO spin column for the  purification of standard capture antibody samples `1`, used for ELISA assay of the standard samples `2` for the best purification results. Please consider selecting `3`.";
Error::CannotSpecifyStandardCaptureAntibodyDilutionOptions="StandardCaptureAntibodyDilution related options `2` cannot be specified for standard capture antibody samples `1` (used for ELISA assay for standard samples `3`) with StandardCaptureAntibodyDilution set to Null.";
Warning::StandardCaptureAntibodyDilutionRecommended="StandardCaptureAntibodyDilution is recommended (not Null) for standard capture antibody samples `1` (used for ELISA assay for standard samples `2`), because resupension and/or conjugation of the antibody is performed in this protocol and the concentration of the antibody may be too high for capillary ELISA experiment.";
Error::MustSpecifyStandardCaptureAntibodyDilutionOptions="StandardCaptureAntibodyDilution related options `2` cannot be Null for standard capture antibody samples `1` (used for ELISA assay for standard samples `3`) with StandardCaptureAntibodyDilution set to True. Please check all the option values.";
Error::ConflictStandardCaptureAntibodyDilutionOptions="StandardCaptureAntibodyTargetConcentration and StandardCaptureAntibodyDiluent options should be both Null or not Null for standard capture antibody samples `1` (used for ELISA assay for standard samples `2`) so the value of StandardCaptureAntibodyDilution option can be selected: ";
Warning::NonOptimalStandardCaptureAntibodyDiluent="The StandardCaptureAntibodyDiluent option should be kept as Model[Sample,\"Simple Plex Reagent Diluent\"] or a sample object with this model for the standard capture antibody samples `1` for optimized dilution and ELISA results. These standard capture antibody samples are used for ELISA assays of the standard samples `2`.";
Error::MustSpecifyStandardCaptureAntibodyLoadingVolume="When a customizable cartridge is used, the StandardCaptureAntibodyLoadingVolume option is not Null for the standard capture antibody samples `1`, used for ELISA assay of `2`.";
Error::InvalidStandardDetectionAntibodyResuspensionForSolid="StandardDetectionAntibodyResuspension option must be True for solid state standard detection antibody samples `1`, used for ELISA assay for standard samples `2`.";
Error::InvalidStandardDetectionAntibodyResuspensionForLiquid="StandardDetectionAntibodyResuspension option cannot be True for liquid state standard detection antibody samples `1`, used for ELISA assay for standard samples `2`.";
Error::CannotSpecifyStandardDetectionAntibodyResuspensionOptions="StandardDetectionAntibodyResuspension related options `2` cannot be specified for standard detection antibody samples `1` (used for ELISA assay for standard samples `3`) with StandardDetectionAntibodyResuspension set to False or Null.";
Error::MustSpecifyStandardDetectionAntibodyResuspensionOptions="StandardDetectionAntibodyResuspension related options `2` cannot be Null for standard detection antibody samples `1` (used for ELISA assay for standard samples `3`) with a solid state or with DetectionAntibodyResuspension set to True. Please correct the conflicting options to continue.";
Error::CannotSpecifyStandardDetectionAntibodyConjugationOptions="StandardDetectionAntibodyConjugation related options `2` cannot be specified for standard detection antibody samples `1` (used for ELISA assay for standard samples `3`) with StandardDetectionAntibodyConjugation option set to False or Null.";
Error::MustSpecifyStandardDetectionAntibodyConjugationOptions="StandardDetectionAntibodyConjugation related options `2` cannot be Null for standard detection antibody samples `1` (used for ELISA assay for standard samples `3`) with StandardDetectionAntibodyConjugation set to True.";
Error::ConflictStandardDetectionAntibodyConjugationOptions="StandardDetectionAntibodyConjugation related options should be all Null or not Null for standard detection antibody samples `1` (used for ELISA assay for samples `2`) so the value of StandardDetectionAntibodyConjugation option can be selected. Please check all the option values.";
Error::UnsupportedStandardDetectionAntibodyPurificationColumn="The specified StandardDetectionAntibodyPurificationColumn should be a supported Zeba spin column (preferably 40K MWCO) for the purification of standard detection antibody samples `1`, used for ELISA assay of the samples `2`. Please select one of `3` to continue.";
Warning::NonOptimalStandardDetectionAntibodyPurificationColumn="The specified StandardDetectionAntibodyPurificationColumn should be a Zeba 40K MWCO spin column for the  purification of standard detection antibody samples `1`, used for ELISA assay of the standard samples `2` for the best purification results. Please consider selecting `3`.";
Error::CannotSpecifyStandardDetectionAntibodyDilutionOptions="StandardDetectionAntibodyDilution related options `2` cannot be specified for standard detection antibody samples `1` (used for ELISA assay for standard samples `3`) with StandardDetectionAntibodyDilution set to Null.";
Warning::StandardDetectionAntibodyDilutionRecommended="StandardDetectionAntibodyDilution is recommended (not Null) for standard detection antibody samples `1` (used for ELISA assay for standard samples `2`), because resupension and/or conjugation of the antibody is performed in this protocol and the concentration of the antibody may be too high for capillary ELISA experiment.";
Error::MustSpecifyStandardDetectionAntibodyDilutionOptions="StandardDetectionAntibodyDilution related options `2` cannot be Null for standard detection antibody samples `1` (used for ELISA assay for standard samples `3`) with StandardDetectionAntibodyDilution set to True. Please check all the option values.";
Error::ConflictStandardDetectionAntibodyDilutionOptions="StandardDetectionAntibodyTargetConcentration and StandardDetectionAntibodyDiluent options should be both Null or not Null for standard detection antibody samples `1` (used for ELISA assay for standard samples `2`) so the value of StandardDetectionAntibodyDilution option can be selected: ";
Warning::NonOptimalStandardDetectionAntibodyDiluent="The StandardDetectionAntibodyDiluent option should be kept as Model[Sample,\"Simple Plex Reagent Diluent\"] or a sample object with this model for the standard detection antibody samples `1` for optimized dilution and ELISA results. These standard detection antibody samples are used for ELISA assays of the standard samples `2`.";
Error::MustSpecifyStandardDetectionAntibodyLoadingVolume="When a customizable cartridge is used, the StandardDetectionAntibodyLoadingVolume option is not Null for the standard detection antibody samples `1`, used for ELISA assay of `2`.";
Warning::NonOptimalWashBuffer="The wash buffer should be Model[Sample,\"Simple Plex Wash Buffer\"] or an object with this model, as provided by the assay developer, for the best washing result.";
Warning::LongLeadTimeCartridge="The cartridge is a pre-loaded cartridge that is not in stock at ECL and may take 14 days to arrive. To start the experiment sooner, please consider testing a total of fewer than 48 samples and selecting Model[Container,Plate,Irregular,\"Human 48-Digoxigenin Cartridge\"] as the Cartridge.";
Error::MustSpecifyPreLoadedCartridgeAnalytes="To create a new pre-loaded capillay ELISA cartridge, Analytes must be specified with supported ExperimentCapillaryELISA pre-loaded cartridge analytes to create a new pre-loaded cartridge. Please check documentation of ExperimentCapillaryELISA for the list of current supported analytes and select the desired targets in Analytes options. If a customizable cartridge is desired, please make sure the total number of samples (including all dilutions and the standard samples) is fewer than 48 and select CartridgeType Customizable.";
Warning::EmptyCartridgeChannel="The selected CartridgeType can test up to `1` analytes but only `2` are specified. To fill up the empty capillary channels, please consider selecting additional supported ExperimentCapillaryELISA pre-loaded cartridge analytes. Please check ExperimentCapillaryELISA help file for the list of current supported analytes.";
Error::InvalidStandardOptionLength="The specified Standard related options is longer than the automatically selected Standard. Please specify desired samples in Standard option to match the length of the Standard related options.";
Error::ConflictCapillaryELISAAntibodyObjectSample="The same solid state Object[Sample] `1` are not used as both capture antibody and detection antibody in the experiment. Please specify a different antibody sample to continue.";
Error::ConflictCapillaryELISAAntibodyOptions="When the same Object[Sample] `1` are used as antibody for different samples and resuspension is required, same antibody preparation option values should be used. Please correct the conflicting options to continue.";
Warning::NonOptimalStandardResuspensionConcentration="To achieve the best standard curve through sample manipulation of the standard samples `1`, it is recommended to set the resuspension concentrations to 10 times of the Upper Limit of Quantitation (`2`) of their analytes.";
Error::IncompleteResolvedStandardComposition="The StandardComposition of analytes of interest must be provided for standard samples `1` to be used for data processing.";
Warning::NonOptimalStandardDiluent="The StandardDiluent specified for the standard samples `1` should be the preferred diluent `2` of the cartridge to achieve the best ELISA results.";
Warning::ConflictStandardAntibodyEpitopes="The StandardCaptureAntibody and StandardDetectionAntibody of the standard samples `1` share the same binding epitopes on the analytes. The ELISA results may be affected. Please consider using different antibody pairs.";
Warning::NoELISAAssayTypeForAntibodySamples="ELISA is not a member of AssayTypes for the antibody samples `1`. The sample may have not been evaluated/certified for ELISA application by the manufacturer and the experiment may not give optimal results. Please check to make sure desired antibody samples are selected.";
Error::MustSpecifyStandardCaptureAntibody="The StandardCaptureAntibody must be specified for the standard samples `1` when the cartridge is customizable:";
Error::MustSpecifyStandardDetectionAntibody="The StandardDetectionAntibody must be specified for the standard samples `1` when the cartridge is customizable.";
Error::MustSpecifyStandardDigoxigeninReagentVolume="The StandardDigoxigeninReagentVolume must be specified for the standard samples `1` to perform bioconjugation when StandardCaptureAntibodyConjugation is True.";
Error::MustSpecifyStandardBiotinReagentVolume="The StandardBiotinReagentVolume must be specified for the standard samples `1` to perform bioconjugation when StandardDetectionAntibodyConjugation is True.";
Warning::NotEnoughStandardDigoxigeninReagentVolume="The StandardDigoxigeninReagentVolume should provide excess amount of digoxigenin reagent compared to StandardCaptureAntibody in the bioconjugation process to achieve the best conjugation efficiency for standard capture antibody samples `1` (used for ELISA experiment of `2`).";
Warning::NotEnoughStandardBiotinReagentVolume="The StandardBiotinReagentVolume should provide excess amount of biotin reagent compared to StandardDetectionAntibody in the bioconjugation process to achieve the best conjugation efficiency for standard detection antibody samples `1` (used for ELISA experiment of `2`).";
Error::ExceedStandardCaptureAntibodyConjugationContainerCapacity="The MaxVolume `3` of the specified StandardCaptureAntibodyConjugationContainer are smaller than the total conjugation preparation volume `4` of standard capture antibody samples `1`, used for ELISA assay of `2`. Please specify a different StandardCaptureAntibodyConjugationContainer with larger MaxVolume capacity (for example, `5`).";
Error::ExceedStandardDetectionAntibodyConjugationContainerCapacity="The MaxVolume `3` of the specified StandardDetectionAntibodyConjugationContainer are smaller than the total conjugation preparation volume `4` of standard detection antibody samples `1`, used for ELISA assay of `2`. Please specify a different StandardDetectionAntibodyConjugationContainer with larger MaxVolume capacity (for example, `5`).";
Error::ExceedStandardCaptureAntibodyPurificationColumnCapacity="The MaxVolume `3` of the specified StandardCaptureAntibodyPurificationColumn are smaller than the total conjugation preparation volume `4` of standard capture antibody samples `1`, used for ELISA assay of `2`. Please specify a different StandardCaptureAntibodyPurificationColumn with larger MaxVolume capacity (for example, `5`).";
Error::ExceedStandardDetectionAntibodyPurificationColumnCapacity="The MaxVolume `3` of the specified StandardDetectionAntibodyPurificationColumn are smaller than the total conjugation preparation volume `4` of standard detection antibody samples `1`, used for ELISA assay of `2`. Please specify a different StandardDetectionAntibodyPurificationColumn with larger MaxVolume capacity (for example, `5`).";
Error::TooHighStandardCaptureAntibodyDilution="The specified StandardCaptureAntibodyTargetConcentration for the standard capture antibody samples `1` cannot be higher than the StandardCaptureAntibodyResuspensionConcentration. These standard capture antibody samples are used for ELISA assays of the standard samples `2`. Please specify a lower concentration.";
Error::TooHighStandardDetectionAntibodyDilution="The specified StandardDetectionAntibodyTargetConcentration for the standard detection antibody samples `1` cannot be higher than the StandardDetectionAntibodyResuspensionConcentration. These standard detection antibody samples are used for ELISA assays of the standard samples `2`. Please specify a lower concentration.";
Warning::NonOptimalStandardCaptureAntibodyDilution="The specified StandardCaptureAntibodyTargetConcentration for the standard capture antibody samples `1` is higher than 50 Microgram/Milliliter. These standard capture antibody samples are used for ELISA assays of the standard samples `2`. Please specify a lower concentration to achieve better ELISA test results.";
Warning::NonOptimalStandardDetectionAntibodyDilution="The specified StandardDetectionAntibodyTargetConcentration for the standard detection antibody samples `1` is higher than 50 Microgram/Milliliter. These standard detection antibody samples are used for ELISA assays of the standard samples `2`. Please specify a lower concentration to achieve better ELISA test results.";
Error::IncompleteResolvedSpikeConcentration="The SpikeConcentration of analytes of interest in SpikeSample `1` must be provided for the samples `2` for data processing purpose. Please update the SpikeConcentration option to continue.";
Warning::NonOptimalCapillaryELISASampleDilution="It is recommended to dilute the samples `1` to at least the minimum dilution factor `2` before loaded into the capillary ELISA cartridge for the best ELISA results.";
Warning::ConflictAntibodyEpitopes="The CustomCaptureAntibody and CustomDetectionAntibody of the samples `1` share the same binding epitopes on the analytes. The ELISA results may be affected. Please consider using different antibody pairs.";
Error::MustSpecifyCaptureAntibody="The CustomCaptureAntibody must be specified for the samples `1` when the cartridge is customizable:";
Error::MustSpecifyDetectionAntibody="The CustomDetectionAntibody must be specified for the samples `1` when the cartridge is customizable.";
Error::MustSpecifyDigoxigeninReagentVolume="The DigoxigeninReagentVolume must be specified for the samples `1` to perform bioconjugation when CaptureAntibodyConjugation is True.";
Error::MustSpecifyBiotinReagentVolume="The BiotinReagentVolume must be specified for the samples `1` to perform bioconjugation when DetectionAntibodyConjugation is True.";
Warning::NotEnoughDigoxigeninReagentVolume="The DigoxigeninReagentVolume should provide excess amount of digoxigenin reagent compared to CustomCaptureAntibody in the bioconjugation process to achieve the best conjugation efficiency for capture antibody samples `1` (used for ELISA experiment of `2`).";
Warning::NotEnoughBiotinReagentVolume="The BiotinReagentVolume should provide excess amount of biotin reagent compared to CustomDetectionAntibody in the bioconjugation process to achieve the best conjugation efficiency for detection antibody samples `1` (used for ELISA experiment of `2`).";
Error::ExceedCaptureAntibodyConjugationContainerCapacity="The MaxVolume `3` of the specified CaptureAntibodyConjugationContainer are smaller than the total conjugation preparation volume `4` of capture antibody samples `1`, used for ELISA assay of `2`. Please specify a different CaptureAntibodyConjugationContainer with larger MaxVolume capacity (for example, `5`).";
Error::ExceedDetectionAntibodyConjugationContainerCapacity="The MaxVolume `3` of the specified DetectionAntibodyConjugationContainer must be smaller than the total conjugation preparation volume `4` of detection antibody samples `1`, used for ELISA assay of `2`. Please specify a different DetectionAntibodyConjugationContainer with larger MaxVolume capacity (for example, `5`).";
Error::ExceedCaptureAntibodyPurificationColumnCapacity="The MaxVolume `3` of the specified CaptureAntibodyPurificationColumn must be smaller than the total conjugation preparation volume `4` of capture antibody samples `1`, used for ELISA assay of `2`. Please specify a different CaptureAntibodyPurificationColumn with larger MaxVolume capacity (for example, `5`).";
Error::ExceedDetectionAntibodyPurificationColumnCapacity="The MaxVolume `3` of the specified DetectionAntibodyPurificationColumn must be smaller than the total conjugation preparation volume `4` of detection antibody samples `1`, used for ELISA assay of `2`. Please specify a different DetectionAntibodyPurificationColumn with larger MaxVolume capacity (for example, `5`).";
Error::TooHighCaptureAntibodyDilution="The specified CaptureAntibodyTargetConcentration for the capture antibody samples `1` cannot be higher than the CaptureAntibodyResuspensionConcentration. These capture antibody samples are used for ELISA assays of `2`. Please specify a lower concentration.";
Error::TooHighDetectionAntibodyDilution="The specified DetectionAntibodyTargetConcentration for the detection antibody samples `1` cannot be higher than the DetectionAntibodyResuspensionConcentration. These detection antibody samples are used for ELISA assays of `2`. Please specify a lower concentration.";
Warning::NonOptimalCaptureAntibodyDilution="The specified CaptureAntibodyTargetCconcentration for the capture antibody samples `1` is higher than 50 Microgram/Milliliter. These capture antibody samples are used for ELISA assays of `2`. Please specify a lower concentration to achieve better ELISA test results.";
Warning::NonOptimalDetectionAntibodyDilution="The specified DetectionAntibodyTargetConcentration for the detection antibody samples `1` is higher than 50 Microgram/Milliliter. These capture antibody samples are used for ELISA assays of `2`. Please specify a lower concentration to achieve better ELISA test results.";
Error::CapillaryELISAConflictingStorageConditions="The samples `1` are given different storage conditions in `2` options. Please make sure they match and only one storage condition is specified per identical sample.";




(* ::Subsubsection::Closed:: *)
(* ExperimentCapillaryELISA Main Function *)


(* ::Subsubsubsection::Closed:: *)
(* ExperimentCapillaryELISA Main Function - Sample Overload *)


ExperimentCapillaryELISA[mySamples:ListableP[ObjectP[Object[Sample]]],myOptions:OptionsPattern[]]:=Module[
    {
        listedSamples,listedOptions,outputSpecification,output,gatherTests,
        suppliedStandard,listedStandard,listedIndexMatchingParentOptions,processedListedOptions,
        validSamplePreparationResult,mySamplesWithPreparedSamples,myOptionsWithPreparedSamples,samplePreparationCache,mySamplesWithPreparedSamplesNamed,myOptionsWithPreparedSamplesNamed,
        safeOpsNamed,safeOps,safeOpsTests,validLengths,validLengthTests,templatedOptions,templateTests,inheritedOptions,tempExpandedSafeOps,expandedSafeOps,
        instrumentFields,modelInstrumentFields,objectSampleFields,modelSampleFields,analyteFields,antibodyFields,sampleObjectContainerFields,sampleModelContainerFields,sampleAllFields,modelSampleAllFields,identityModelFields,cartridgeFields,modelCartridgeFields,manufacturingSpecificationFields,objectContainerFields,modelContainerFields,containerAllFields,modelContainerAllFields,
        optionsWithObjects,potentialIdentityModels,potentialInstruments,potentialCartridges,potentialModelCartridges,potentialReagents,potentialContainers,liquidHandlerCompatibleContainers,potentialManufacturingSpecifications,potentialSpinColumns,
        allObjects,userSpecifiedObjects,simulatedSampleQ,objectsExistQs,objectsExistTests,moleculeObjects,sampleObjects,modelSampleObjects,instrumentObjects,modelInstrumentObjects,cartridgeObjects,cartridgeModelObjects,manufacturingSpecificationObjects,containerObjects,modelContainerObjects,
        cacheBall, samplePreparationFastAssoc,
        resolvedOptionsResult,resolvedOptions,resolvedOptionsTests,collapsedResolvedOptions,protocolObject,resourcePackets,resourcePacketTests
    },

    (* Determine the requested return value from the function *)
    outputSpecification=Quiet[OptionValue[Output]];
    output=ToList[outputSpecification];

    (* Determine if we should keep a running list of tests *)
    gatherTests=MemberQ[output,Tests];

    (* Make sure we're working with a list of samples and options *)
    (* Remove temporal links and named objects. *)
    {listedSamples,listedOptions}=removeLinks[ToList[mySamples],ToList[myOptions]];

	(* Add a special step here to make sure we are working on a list of Standard because they are index matching parents in ExperimentCapillaryELISA. If they are not in a list, the ValidInputLengthsQ may not be able to catch the length conflict in the options. Also the ExpandIndexMatchedInputs cannot successfully expand the options into a list either.
For example, if we have Standard->Model[Sample,"Milli-Q water"],StandardResuspension->{True,False}, ValidInputLengthsQ cannot recognize the issue.
Another example, if we have Standard->Model[Sample,"Milli-Q water"],StandardResuspension->True, we are not getting a list after ExpandIndexMatchedInputs. If we do Standard->{Model[Sample,"Milli-Q water"]},StandardResuspension->True, we will automatically get StandardResuspension->{True}. Then we don't need to worry about working with an option that is not a list.
We do not worry about input samples because our option is from myOptionsWithPreparedSamples and our function simulateSamplePreparationPackets takes in ToList[mySamples].
*)
	(* Note that we have kept Standard as Null if they are specified as so. We check in our resolver that when they are Null, the options that are index matched to these options must also be Null. We don't check them here. *)

	suppliedStandard=Lookup[listedOptions,Standard,Automatic];
	listedStandard=Which[
		MatchQ[suppliedStandard,Null],Null,
		MatchQ[suppliedStandard,Automatic],Automatic,
		True,ToList[suppliedStandard]
	];

	listedIndexMatchingParentOptions={Standard->listedStandard};

	processedListedOptions=Normal[Join[Association[listedOptions],Association[listedIndexMatchingParentOptions]]];


	(* Simulate our sample preparation. *)
    validSamplePreparationResult=Check[
        (* Simulate sample preparation. *)
        {mySamplesWithPreparedSamplesNamed,myOptionsWithPreparedSamplesNamed,samplePreparationCache}=simulateSamplePreparationPackets[
            ExperimentCapillaryELISA,
            listedSamples,
            ToList[processedListedOptions]
        ],
        $Failed,
        {Error::MissingDefineNames}
    ];

    (* If we are given an invalid define name, return early. *)
    If[MatchQ[validSamplePreparationResult,$Failed],
        (* Return early. *)
        (* Note: We've already thrown a message above in simulateSamplePreparationPackets. *)
	    ClearMemoization[Experiment`Private`simulateSamplePreparationPackets];Return[$Failed]
    ];

    (* Call SafeOptions to make sure all options match pattern *)
    {safeOpsNamed,safeOpsTests}=If[gatherTests,
        SafeOptions[ExperimentCapillaryELISA,myOptionsWithPreparedSamplesNamed,AutoCorrect->False,Output->{Result,Tests}],
        {SafeOptions[ExperimentCapillaryELISA,myOptionsWithPreparedSamplesNamed,AutoCorrect->False],{}}
    ];

    {mySamplesWithPreparedSamples,safeOps,myOptionsWithPreparedSamples}=sanitizeInputs[mySamplesWithPreparedSamplesNamed,safeOpsNamed,myOptionsWithPreparedSamplesNamed];

    (* Call ValidInputLengthsQ to make sure all options are the right length *)
    (* Note that even if we don't check the Null index matching parents here. The problem with other index matching options with different lengths are still caught. It is not an issue. We check in our resolver that when parents are Null, the index matching options are also Null. *)
    {validLengths,validLengthTests}=If[gatherTests,
        ValidInputLengthsQ[ExperimentCapillaryELISA,{mySamplesWithPreparedSamples},myOptionsWithPreparedSamples,Output->{Result,Tests}],
        {ValidInputLengthsQ[ExperimentCapillaryELISA,{mySamplesWithPreparedSamples},myOptionsWithPreparedSamples],Null}
    ];

    (* If the specified options don't match their patterns or if option lengths are invalid return $Failed *)
    If[MatchQ[safeOps,$Failed],
        Return[outputSpecification/.{
            Result->$Failed,
            Tests->safeOpsTests,
            Options->$Failed,
            Preview->Null
        }]
    ];

    (* If option lengths are invalid return $Failed (or the tests up to this point) *)
    If[!validLengths,
        Return[outputSpecification/.{
            Result->$Failed,
            Tests->Join[safeOpsTests,validLengthTests],
            Options->$Failed,
            Preview->Null
        }]
    ];

    (* Use any template options to get values for options not specified in myOptions *)
    {templatedOptions,templateTests}=If[gatherTests,
        ApplyTemplateOptions[ExperimentCapillaryELISA,{ToList[mySamplesWithPreparedSamples]},myOptionsWithPreparedSamples,Output->{Result,Tests}],
        {ApplyTemplateOptions[ExperimentCapillaryELISA,{ToList[mySamplesWithPreparedSamples]},myOptionsWithPreparedSamples],Null}
    ];

    (* Return early if the template cannot be used - will only occur if the template object does not exist. *)
    If[MatchQ[templatedOptions,$Failed],
        Return[outputSpecification/.{
            Result->$Failed,
            Tests->Join[safeOpsTests,validLengthTests,templateTests],
            Options->$Failed,
            Preview->Null
        }]
    ];

    (* Replace our safe options with our inherited options from our template. *)
    inheritedOptions=ReplaceRule[safeOps,templatedOptions];

    (* Expand index-matching options. This also includes the expansion of Standard related options with Standard as IndexMatchingParent *)
    tempExpandedSafeOps=Last[ExpandIndexMatchedInputs[ExperimentCapillaryELISA,{ToList[mySamplesWithPreparedSamples]},inheritedOptions]];

	(* To follow up on the index matching parent issues - Standard. When we have Automatic/Null index matching parent but any option with a list, our Automatic/Null also gets expanded. For example, if we get StandardResuspension->{True,False} but Automatic Standard, for some reason, our options are turned into Standard->{Automatic,Automatic},StandardResuspension->{True,False}. This is same for Null and creates some issues with our resolver. *)
	(* Here we can turn the index matching parents back to their supplied values so we can easily process in resolver*)
	expandedSafeOps=ReplaceRule[tempExpandedSafeOps,{Standard->suppliedStandard}];

    (*-- DOWNLOAD THE INFORMATION THAT WE NEED FOR OUR OPTION RESOLVER AND RESOURCE PACKET FUNCTION --*)

    (* Fields to download from instrument objects *)
    instrumentFields={
        Packet[Model,Status,Name],
        Packet[Model[{Depracated,Name}]]
    };

    (* Fields to download from instrument models *)
    modelInstrumentFields={
        Packet[Deprecated,Name]
    };

    (* Fields to download from all samples - include mySamples, Standard samples, Spike samples, Capture Antibody samples, Detection Antibody samples and other reagents *)
    (* Define all the fields that we want *)
    objectSampleFields=SamplePreparationCacheFields[Object[Sample]];
    modelSampleFields=Join[SamplePreparationCacheFields[Model[Sample]], {UsedAsSolvent,ConcentratedBufferDiluent,ConcentratedBufferDilutionFactor,BaselineStock}];
    analyteFields={Name,Object,Targets,Antibodies,SecondaryAntibodies,DefaultSampleModel,MolecularWeight,State,Molecule};
    antibodyFields={Name,Object,Targets,SecondaryAntibodies,Epitopes,DefaultSampleModel,MolecularWeight,State,AssayTypes,Clonality,Molecule};
    sampleObjectContainerFields=SamplePreparationCacheFields[Object[Container]];
    sampleModelContainerFields=SamplePreparationCacheFields[Model[Container]];

    (* Fields to download from all sample objects *)
    sampleAllFields={
        Packet[Sequence@@objectSampleFields],
        Packet[Analytes[analyteFields]],
		Packet[Analytes[DefaultSampleModel][modelSampleFields]],
		Packet[Analytes[DefaultSampleModel][Analytes][analyteFields]],
		Packet[Analytes[DefaultSampleModel][Analytes][Antibodies][antibodyFields]],
		Packet[Analytes[DefaultSampleModel][Analytes][Antibodies][DefaultSampleModel][modelSampleFields]],
		Packet[Analytes[DefaultSampleModel][Analytes][SecondaryAntibodies][antibodyFields]],
		Packet[Analytes[DefaultSampleModel][Analytes][SecondaryAntibodies][DefaultSampleModel][modelSampleFields]],
        Packet[Analytes[Antibodies][antibodyFields]],
        Packet[Analytes[Antibodies][DefaultSampleModel][modelSampleFields]],
        Packet[Analytes[SecondaryAntibodies][antibodyFields]],
        Packet[Analytes[SecondaryAntibodies][DefaultSampleModel][modelSampleFields]],
        Packet[Field[Composition[[All, 2]]][analyteFields]],
		Packet[Field[Composition[[All, 2]]][DefaultSampleModel][modelSampleFields]],
		Packet[Field[Composition[[All, 2]]][DefaultSampleModel][Analytes][analyteFields]],
		Packet[Field[Composition[[All, 2]]][DefaultSampleModel][Analytes][Antibodies][antibodyFields]],
		Packet[Field[Composition[[All, 2]]][DefaultSampleModel][Analytes][Antibodies][DefaultSampleModel][modelSampleFields]],
		Packet[Field[Composition[[All, 2]]][DefaultSampleModel][Analytes][SecondaryAntibodies][antibodyFields]],
		Packet[Field[Composition[[All, 2]]][DefaultSampleModel][Analytes][SecondaryAntibodies][DefaultSampleModel][modelSampleFields]],
        Packet[Field[Composition[[All, 2]]][Antibodies][antibodyFields]],
        Packet[Field[Composition[[All, 2]]][Antibodies][DefaultSampleModel][modelSampleFields]],
        Packet[Field[Composition[[All, 2]]][SecondaryAntibodies][antibodyFields]],
		Packet[Field[Composition[[All, 2]]][SecondaryAntibodies][DefaultSampleModel][modelSampleFields]],
        Packet[Container[sampleObjectContainerFields]],
        Packet[Container[Model][sampleModelContainerFields]]
    };

    (* Fields to download from all sample models (not including mySamples, which cannot be Model[Sample]) *)
    modelSampleAllFields={
        Packet[Sequence@@modelSampleFields],
        Packet[Analytes[analyteFields]],
		Packet[Analytes[DefaultSampleModel][modelSampleFields]],
		Packet[Analytes[DefaultSampleModel][Analytes][analyteFields]],
		Packet[Analytes[DefaultSampleModel][Analytes][Antibodies][antibodyFields]],
		Packet[Analytes[DefaultSampleModel][Analytes][Antibodies][DefaultSampleModel][modelSampleFields]],
		Packet[Analytes[DefaultSampleModel][Analytes][SecondaryAntibodies][antibodyFields]],
		Packet[Analytes[DefaultSampleModel][Analytes][SecondaryAntibodies][DefaultSampleModel][modelSampleFields]],
        Packet[Analytes[Antibodies][antibodyFields]],
        Packet[Analytes[Antibodies][DefaultSampleModel][modelSampleFields]],
        Packet[Analytes[SecondaryAntibodies][antibodyFields]],
        Packet[Analytes[SecondaryAntibodies][DefaultSampleModel][modelSampleFields]],
        Packet[Field[Composition[[All, 2]]][analyteFields]],
		Packet[Field[Composition[[All, 2]]][DefaultSampleModel][modelSampleFields]],
		Packet[Field[Composition[[All, 2]]][DefaultSampleModel][Analytes][analyteFields]],
		Packet[Field[Composition[[All, 2]]][DefaultSampleModel][Analytes][Antibodies][antibodyFields]],
		Packet[Field[Composition[[All, 2]]][DefaultSampleModel][Analytes][Antibodies][DefaultSampleModel][modelSampleFields]],
		Packet[Field[Composition[[All, 2]]][DefaultSampleModel][Analytes][SecondaryAntibodies][antibodyFields]],
		Packet[Field[Composition[[All, 2]]][DefaultSampleModel][Analytes][SecondaryAntibodies][DefaultSampleModel][modelSampleFields]],
        Packet[Field[Composition[[All, 2]]][Antibodies][antibodyFields]],
        Packet[Field[Composition[[All, 2]]][Antibodies][DefaultSampleModel][modelSampleFields]],
        Packet[Field[Composition[[All, 2]]][SecondaryAntibodies][antibodyFields]],
		Packet[Field[Composition[[All, 2]]][SecondaryAntibodies][DefaultSampleModel][modelSampleFields]]
    };

	(* Fields to download from analytes or other molecules *)
	identityModelFields={
		Packet[Sequence@@analyteFields],
		Packet[DefaultSampleModel[modelSampleFields]],
		Packet[Antibodies[antibodyFields]],
		Packet[Antibodies[DefaultSampleModel][modelSampleFields]],
		Packet[SecondaryAntibodies[antibodyFields]],
		Packet[SecondaryAntibodies[DefaultSampleModel][modelSampleFields]]
	};

    (* Fields to download from capillary ELISA cartridge objects *)
    (* For the capillary ELISA cartridges, we did not try to download anything for Recommended Standard. For a pre-loaded cartridge, we always resolve Standard to Null, if not specified by the user. The RecommendedStandard is for user's information only. *)
    cartridgeFields={
        Packet[
			Name,Deprecated,Sterile,AspectRatio,NumberOfWells,Footprint,Aperture,InternalDepth,SelfStanding,OpenContainer,MinVolume,MaxVolume,Dimensions,InternalDimensions,InternalDiameter,MaxTemperature,Positions,FilterType,MembraneMaterial,MolecularWeightCutoff,PoreSize,PrefilterMembraneMaterial,PrefilterPoreSize,MaxCentrifugationForce,Model,Status,AnalyteNames,AnalyteMolecules,CartridgeType,MaxNumberOfSamples,MinBufferVolume
		]
    };

	modelContainerFields=Join[SamplePreparationCacheFields[Model[Container]],{MolecularWeightCutoff,DestinationContainerModel}];

    (* Fields to download from capillary ELISA cartridge models *)
    modelCartridgeFields={
        Packet[Name,Deprecated,Sterile,AspectRatio,NumberOfWells,Footprint,Aperture,InternalDepth,SelfStanding,OpenContainer,MinVolume,MaxVolume,Dimensions,InternalDimensions,InternalDiameter,MaxTemperature,Positions,FilterType,MembraneMaterial,MolecularWeightCutoff,PoreSize,PrefilterMembraneMaterial,PrefilterPoreSize,MaxCentrifugationForce,AnalyteNames,AnalyteMolecules,CartridgeType,MaxNumberOfSamples,MinBufferVolume,MaxVolume]
    };

    (* Fields to download from all capillary ELISA cartridge manufacturing specification objects *)
	(* Because we allow the input of CapillaryELISAAanalyteP as Analytes, when it is used for customizable cartridge, we can throw only a warning message and use the corresponding identity model as the analyte to resolve antibodies *)
    manufacturingSpecificationFields={
        Packet[Name,AnalyteName,AnalyteMolecule,CartridgeType,Species,RecommendedMinDilutionFactor,RecommendedDiluent,IncompatibleAnalytes,UpperQuantitationLimit,LowerQuantitationLimit],
        Packet[AnalyteMolecule[analyteFields]],
		Packet[AnalyteMolecule[DefaultSampleModel][modelSampleFields]],
		Packet[AnalyteMolecule[Antibodies][antibodyFields]],
		Packet[AnalyteMolecule[Antibodies][DefaultSampleModel][modelSampleFields]],
		Packet[AnalyteMolecule[SecondaryAntibodies][antibodyFields]],
		Packet[AnalyteMolecule[SecondaryAntibodies][DefaultSampleModel][modelSampleFields]]
    };

    (* Fields to download from container objects. These are defined first to avoid evaluation sequence error. The MolecularWeightCutOff and DestinationContainerModel only apply for Model[Container,Vessel,Filter] for the desalting spin columns. *)
    objectContainerFields=SamplePreparationCacheFields[Object[Container]];
    modelContainerFields=Join[SamplePreparationCacheFields[Model[Container]],{MolecularWeightCutoff,DestinationContainerModel}];

    (* Fields to download from container objects - including all reaction, dilution, measurement and storage container *)
    containerAllFields={
        Packet[Sequence@@objectContainerFields],
        Packet[Model[modelContainerFields]]
    };

    (* Fields to download from container models - including all reaction, dilution, measurement and storage container *)
    modelContainerAllFields={
        Packet[Sequence@@modelContainerFields]
    };

    (* Any options whose values could be an object *)
    (* Note that even if KnownConcentration and SpikeConcentration may have identity models in the options, we are not downloading from there (as we only compares whether those are identical to the Composition fields of the corresponding samples *)
    optionsWithObjects={
        Instrument,Cartridge,Analytes,

		SpikeSample,Diluent,

		CustomCaptureAntibody,CaptureAntibodyResuspensionDiluent,
		DigoxigeninReagent,CaptureAntibodyConjugationBuffer,CaptureAntibodyConjugationContainer,CaptureAntibodyPurificationColumn,CaptureAntibodyColumnWashBuffer,
		CaptureAntibodyDiluent,

		CustomDetectionAntibody,DetectionAntibodyResuspensionDiluent,
		BiotinReagent,DetectionAntibodyConjugationBuffer,DetectionAntibodyConjugationContainer,DetectionAntibodyPurificationColumn,DetectionAntibodyColumnWashBuffer,
		DetectionAntibodyDiluent,

		Standard,StandardResuspensionDiluent,StandardDiluent,

		StandardCaptureAntibody,StandardCaptureAntibodyResuspensionDiluent,
		StandardDigoxigeninReagent,StandardCaptureAntibodyConjugationBuffer,StandardCaptureAntibodyConjugationContainer,StandardCaptureAntibodyPurificationColumn,StandardCaptureAntibodyColumnWashBuffer,
		StandardCaptureAntibodyDiluent,

		StandardDetectionAntibody,StandardDetectionAntibodyResuspensionDiluent,
		StandardBiotinReagent,StandardDetectionAntibodyConjugationBuffer,StandardDetectionAntibodyConjugationContainer,StandardDetectionAntibodyPurificationColumn,StandardDetectionAntibodyColumnWashBuffer,
		StandardDetectionAntibodyDiluent,
		
        WashBuffer

    };

    (* Get the models/objects that may be automatically resolved to in the resolver *)
	potentialIdentityModels={
    Model[Molecule, "id:KBL5Dvwx7eq7"], (* Model[Molecule,"Digoxigenin NHS ester"] *)
    Model[Molecule, "id:1ZA60vLKWYD8"] (* Model[Molecule,"Biotinamidohexanoyl-6-aminohexanoic acid N-hydroxysuccinimide ester"] *)
	};

    (* All the instruments to use *)
    potentialInstruments={
      Model[Instrument, CapillaryELISA, "id:XnlV5jKM7zPM"] (* Model[Instrument,CapillaryELISA,"Ella"] *)
    };

    (* All the in-stock capillary ELISA cartridge objects. One of these may be selected if it matches the analytes in the input samples and provides enough capacity *)
    potentialCartridges=Search[Object[Container,Plate,Irregular,CapillaryELISA],Status=={Stocked,Available}];

    (* All the available SinglePlex72X1 capillary ELISA cartridge models and the customizable cartridge model *)
    potentialModelCartridges=Search[Model[Container,Plate,Irregular,CapillaryELISA],CartridgeType=={Customizable,SinglePlex72X1}];

    (* All the possible diluents, buffers and reagents *)
    (* TODO: make sure this list is complete after I get the complete list from ProteinSimple *)
    potentialReagents={
      Model[Sample, "id:eGakldJEGX4o"], (* Model[Sample,"Simple Plex Sample Diluent 13"] *)
      Model[Sample, StockSolution, "id:4pO6dMWvnA0X"], (* Model[Sample,StockSolution,"Filtered PBS, Sterile"] *)
      Model[Sample, StockSolution, "id:rea9jlRwZe9e"], (* Model[Sample,StockSolution,"Digoxigenin-NHS, 0.67 mg/mL in DMF"] *)
      Model[Sample, StockSolution, "id:bq9LA0JWaP8r"], (* Model[Sample,StockSolution,"Biotin-XX, 1 mg/mL in DMSO"] *)
      Model[Sample, StockSolution, "id:1ZA60vL4PZbq"], (* Model[Sample,StockSolution,"Sodium bicarbonate working stock 75 mg/mL"] *)
      Model[Sample, "id:pZx9jo8LZ7z5"], (* Model[Sample,"Simple Plex Reagent Diluent"] *)
      Model[Sample, "id:4pO6dM50p9kw"], (* Model[Sample,"Simple Plex Wash Buffer"] *)
      Model[Sample, "id:8qZ1VWNmdLBD"] (* Model[Sample,"Milli-Q water"] *)
    };

    (* All the possible containers *)
	liquidHandlerCompatibleContainers=Experiment`Private`hamiltonAliquotContainers["Memoization"];
    potentialContainers=Join[
		PreferredContainer[All],
		PreferredContainer[All,Type->Plate],
		liquidHandlerCompatibleContainers
	];

    (* All the possible spin columns. We only automatically resolve to these three. We also will hard-code some parameters into the resolver/ resource packets/ procedure before we have a better plan for using these as a standard part of ExperimentFilter or Filter primitives for ExperimentSampleManipulation. We do also support 7K MWCO spin desalting columns but we will NOT resolve to them. *)
    potentialSpinColumns=Search[Model[Container,Vessel,Filter],MembraneMaterial==ZebaDesaltingResin];
    
    (* All the available manufacturing specifications. We have to get all of them as it might be possible to resolve to any of these. *)
    potentialManufacturingSpecifications=Search[Object[ManufacturingSpecification,CapillaryELISACartridge]];

    (* Flatten and merge all possible objects needed into a list *)
    allObjects=DeleteDuplicates[
        Cases[
            Flatten@Join[
                mySamplesWithPreparedSamples,
                (* Models/Objects possibly resolved to*)
				potentialIdentityModels,
				potentialInstruments,
                potentialCartridges,
                potentialModelCartridges,
                potentialReagents,
                potentialContainers,
				potentialSpinColumns,
                potentialManufacturingSpecifications,
                (* All options that could have an object *)
                Lookup[expandedSafeOps,optionsWithObjects]
            ],
            ObjectP[]
        ]
    ];

	(* Extract any objects that the user has explicitly specified *)
	userSpecifiedObjects=DeleteDuplicates[
		Cases[
			Flatten@Join[
				listedSamples,
				(* All options that could have an object *)
				Lookup[expandedSafeOps,optionsWithObjects]
			],
			ObjectP[]
		]
	];

	(* make a fast association to quickly pull stuff out of the sample preparation cache *)
	samplePreparationFastAssoc = makeFastAssocFromCache[samplePreparationCache];

	(* Check that the specified objects exist or are visible to the current user *)
	simulatedSampleQ=Map[
		Lookup[
			fetchPacketFromFastAssoc[#,samplePreparationFastAssoc],
			Simulated,
			False
		]&,
		userSpecifiedObjects
	];
	objectsExistQs=DatabaseMemberQ[
		PickList[userSpecifiedObjects,simulatedSampleQ,False]
	];

	(* Build tests for object existence *)
	objectsExistTests=If[gatherTests,
		Module[{failingTest,passingTest},

			failingTest=If[!MemberQ[objectsExistQs,False],
				Nothing,
				Test["The specified objects "<>ToString[PickList[PickList[userSpecifiedObjects,simulatedSampleQ,False],objectsExistQs,False]]<>" exist in the database:",True,False]
			];

			passingTest=If[!MemberQ[objectsExistQs,True],
				Nothing,
				Test["The specified objects "<>ToString[PickList[PickList[userSpecifiedObjects,simulatedSampleQ,False],objectsExistQs,True]]<>" exist in the database:",True,True]
			];

			{failingTest,passingTest}
		],
		{}
	];

	(* If objects do not exist, return failure *)
	If[!(And@@objectsExistQs),
		If[!gatherTests,
			Message[Error::ObjectDoesNotExist,PickList[PickList[userSpecifiedObjects,simulatedSampleQ,False],objectsExistQs,False]];
			Message[Error::InvalidInput,PickList[PickList[userSpecifiedObjects,simulatedSampleQ,False],objectsExistQs,False]]
		];
		Return[outputSpecification/.{
			Result->$Failed,
			Tests->Join[safeOpsTests,validLengthTests,templateTests,objectsExistTests],
			Options->$Failed,
			Preview->Null
		}]
	];


	(* Isolate objects of particular types so we can build an indexed-download call *)
    moleculeObjects=Cases[allObjects,ObjectP[Model[Molecule]]];
	sampleObjects=Cases[allObjects,ObjectP[Object[Sample]]];
    modelSampleObjects=Cases[allObjects,ObjectP[Model[Sample]]];
    instrumentObjects=Cases[allObjects,ObjectP[Object[Instrument]]];
    modelInstrumentObjects=Cases[allObjects,ObjectP[Model[Instrument]]];
    cartridgeObjects=Cases[allObjects,ObjectP[Object[Container,Plate,Irregular,CapillaryELISA]]];
    cartridgeModelObjects=Cases[allObjects,ObjectP[Model[Container,Plate,Irregular,CapillaryELISA]]];
    manufacturingSpecificationObjects=Cases[allObjects,ObjectP[Object[ManufacturingSpecification,CapillaryELISACartridge]]];
    containerObjects=DeleteCases[Cases[allObjects,ObjectP[Object[Container]]],ObjectP[Object[Container,Plate,Irregular,CapillaryELISA]]];
    modelContainerObjects=DeleteCases[Cases[allObjects,ObjectP[Model[Container]]],ObjectP[Model[Container,Plate,Irregular,CapillaryELISA]]];

    (* Make one download for all possible parameters needed *)
    cacheBall=Quiet[
        FlattenCachePackets[
            {
                samplePreparationCache,
                Download[
                    {
						moleculeObjects,
                        sampleObjects,
                        modelSampleObjects,
                        instrumentObjects,
                        modelInstrumentObjects,
                        cartridgeObjects,
                        cartridgeModelObjects,
                        manufacturingSpecificationObjects,
                        containerObjects,
                        modelContainerObjects
                    },
                    {
						identityModelFields,
                        sampleAllFields,
                        modelSampleAllFields,
                        instrumentFields,
                        modelInstrumentFields,
                        cartridgeFields,
                        modelCartridgeFields,
                        manufacturingSpecificationFields,
                        containerAllFields,
                        modelContainerAllFields
                    },
                    Cache->samplePreparationCache,
                    Date->Now
                ]
            }
        ],
        {Download::FieldDoesntExist,Download::NotLinkField}
    ];

    (* Build the resolved options *)
    resolvedOptionsResult=If[gatherTests,
        (* We are gathering tests. This silences any messages being thrown. *)
        {resolvedOptions,resolvedOptionsTests}=resolveExperimentCapillaryELISAOptions[listedSamples,expandedSafeOps,Cache->cacheBall,Output->{Result,Tests}];

        (* Therefore, we have to run the tests to see if we encountered a failure. *)
        If[RunUnitTest[<|"Tests"->resolvedOptionsTests|>,OutputFormat->SingleBoolean,Verbose->False],
            {resolvedOptions,resolvedOptionsTests},
            $Failed
        ],

        (* We are not gathering tests. Simply check for Error::InvalidInput and Error::InvalidOption. *)
        Check[
            {resolvedOptions,resolvedOptionsTests}={resolveExperimentCapillaryELISAOptions[listedSamples,expandedSafeOps,Cache->cacheBall],{}},
            $Failed,
            {Error::InvalidInput,Error::InvalidOption}
        ]
    ];

    (* Collapse the resolved options *)
    collapsedResolvedOptions = CollapseIndexMatchedOptions[
        ExperimentCapillaryELISA,
        resolvedOptions,
        Ignore->ToList[myOptions],
        Messages->False
    ];

    (* If option resolution failed, return early. *)
    If[MatchQ[resolvedOptionsResult,$Failed],
        Return[outputSpecification/.{
            Result -> $Failed,
            Tests->Join[safeOpsTests,validLengthTests,templateTests,objectsExistTests,resolvedOptionsTests],
            Options->RemoveHiddenOptions[ExperimentCapillaryELISA,collapsedResolvedOptions],
            Preview->Null
        }]
    ];

    (* Build packets with resources *)
    {resourcePackets,resourcePacketTests} = If[gatherTests,
      capillaryELISAResourcePackets[ToList[mySamplesWithPreparedSamples],expandedSafeOps,resolvedOptions,Cache->cacheBall,Output->{Result,Tests}],
      {capillaryELISAResourcePackets[ToList[mySamplesWithPreparedSamples],expandedSafeOps,resolvedOptions,Cache->cacheBall],{}}
    ];

    (* If we don't have to return the Result, don't bother calling UploadProtocol[...]. *)
    If[!MemberQ[output,Result],
      Return[outputSpecification/.{
        Result -> Null,
        Tests -> Flatten[{safeOpsTests,validLengthTests,templateTests,objectsExistTests,resolvedOptionsTests,resourcePacketTests}],
        Options -> RemoveHiddenOptions[ExperimentCapillaryELISA,collapsedResolvedOptions],
        Preview -> Null
      }]
    ];

    (* We have to return the result. Call UploadProtocol[...] to prepare our protocol packet (and upload it if asked). *)
    protocolObject = If[!MatchQ[resourcePackets,$Failed]&&!MatchQ[resolvedOptionsResult,$Failed],
		UploadProtocol[
        	resourcePackets,
        	Upload->Lookup[safeOps,Upload],
			Confirm->Lookup[safeOps,Confirm],
			ParentProtocol->Lookup[safeOps,ParentProtocol],
			Priority->Lookup[safeOps,Priority],
			StartDate->Lookup[safeOps,StartDate],
			HoldOrder->Lookup[safeOps,HoldOrder],
			QueuePosition->Lookup[safeOps,QueuePosition],
			ConstellationMessage->Object[Protocol,CapillaryELISA],
			Cache->samplePreparationCache
		],
		$Failed
    ];

    (* Return requested output *)
    outputSpecification/.{
        Result->protocolObject,
        Tests->Flatten[{safeOpsTests,validLengthTests,templateTests,objectsExistTests,resolvedOptionsTests,resourcePacketTests}],
        Options->RemoveHiddenOptions[ExperimentCapillaryELISA,collapsedResolvedOptions],
        Preview->Null
    }
];


(* ::Subsubsubsection::Closed:: *)
(* ExperimentCapillaryELISA Main Function - Container Overload*)


(* Note: The container overload should come after the sample overload. *)
ExperimentCapillaryELISA[myContainers:ListableP[ObjectP[{Object[Container],Object[Sample]}]|_String|{LocationPositionP,_String|ObjectP[Object[Container]]}],myOptions:OptionsPattern[]]:=Module[
    {
        listedOptions,outputSpecification,output,gatherTests,
        validSamplePreparationResult,mySamplesWithPreparedSamples,myOptionsWithPreparedSamples,objectsExistQs,objectsExistTests,containerToSampleCache,
        samplePreparationCache,containerToSampleResult,containerToSampleOutput,updatedCache,samples,sampleOptions,containerToSampleTests,sampleCache
    },
	

    (* Make sure we're working with a list of options *)
    listedOptions=ToList[myOptions];

    (* Determine the requested return value from the function *)
    outputSpecification=Quiet[OptionValue[Output]];
    output=ToList[outputSpecification];

    (* Determine if we should keep a running list of tests *)
    gatherTests=MemberQ[output,Tests];

    (* First, simulate our sample preparation. *)
    validSamplePreparationResult=Check[
        (* Simulate sample preparation. *)
        {mySamplesWithPreparedSamples,myOptionsWithPreparedSamples,samplePreparationCache}=simulateSamplePreparationPackets[
            ExperimentCapillaryELISA,
            ToList[myContainers],
            ToList[myOptions]
        ],
        $Failed,
        {Error::MissingDefineNames}
    ];

    (* If we are given an invalid define name, return early. *)
    If[MatchQ[validSamplePreparationResult,$Failed],
        (* Return early. *)
        (* Note: We've already thrown a message above in simulateSamplePreparationPackets. *)
	    ClearMemoization[Experiment`Private`simulateSamplePreparationPackets];Return[$Failed]
    ];

	(* Before we turn containers into samples, we want to check that all containers exist in the database. We don't check any other option objects as they will be checked in our main Sample overload. We don't want random result to be returned from containerToSample function *)
	objectsExistQs=DatabaseMemberQ[ToList[myContainers]];

	(* Build tests for object existence *)
	objectsExistTests=If[gatherTests,
		Module[{failingTest,passingTest},

			failingTest=If[!MemberQ[objectsExistQs,False],
				Nothing,
				Test["The specified objects "<>ToString[PickList[ToList[myContainers],objectsExistQs,False]]<>" exist in the database:",True,False]
			];

			passingTest=If[!MemberQ[objectsExistQs,True],
				Nothing,
				Test["The specified objects "<>ToString[PickList[ToList[myContainers],objectsExistQs,True]]<>" exist in the database:",True,True]
			];

			{failingTest,passingTest}
		],
		{}
	];

	(* If objects do not exist, return failure *)
	If[!(And@@objectsExistQs),
		If[!gatherTests,
			Message[Error::ObjectDoesNotExist,PickList[ToList[myContainers],objectsExistQs,False]];
			Message[Error::InvalidInput,PickList[ToList[myContainers],objectsExistQs,False]]
		];
		Return[outputSpecification/.{
			Result->$Failed,
			Tests->objectsExistTests,
			Options->$Failed,
			Preview->Null
		}]
	];


	(* Convert our given containers into samples and sample index-matched options. *)
    containerToSampleResult=If[gatherTests,
        (* We are gathering tests. This silences any messages being thrown. *)
        {containerToSampleOutput,containerToSampleTests}=containerToSampleOptions[
            ExperimentCapillaryELISA,
            mySamplesWithPreparedSamples,
            myOptionsWithPreparedSamples,
            Output->{Result,Tests},
            Cache->samplePreparationCache
        ];

        (* Therefore, we have to run the tests to see if we encountered a failure. *)
        If[RunUnitTest[<|"Tests"->containerToSampleTests|>,OutputFormat->SingleBoolean,Verbose->False],
            Null,
            $Failed
        ],

        (* We are not gathering tests. Simply check for Error::InvalidInput and Error::InvalidOption. *)
        Check[
            containerToSampleOutput=containerToSampleOptions[
                ExperimentCapillaryELISA,
                mySamplesWithPreparedSamples,
                myOptionsWithPreparedSamples,
                Output->Result,
                Cache->samplePreparationCache
            ],
            $Failed,
            {Error::EmptyContainers, Error::ContainerEmptyWells, Error::WellDoesNotExist}
        ]
    ];

    (* Update our cache with our new simulated values. *)
    (* It is important that the sample preparation cache appears first in the cache ball. *)
    updatedCache=Flatten[{
        samplePreparationCache,
        Lookup[listedOptions,Cache,{}]
    }];

    (* If we were given an empty container, return early. *)
    If[MatchQ[containerToSampleResult,$Failed],
        (* containerToSampleOptions failed - return $Failed *)
        outputSpecification/.{
            Result->$Failed,
            Tests->Join[objectsExistTests,containerToSampleTests],
            Options->$Failed,
            Preview->Null
        },
        (* Split up our containerToSample result into the samples and sampleOptions. *)
        {samples,sampleOptions,sampleCache}=containerToSampleOutput;

        (* Call our main function with our samples and converted options. *)
        (* Note that unlike the main function, we don't turn index matching parent options into lists in this overload as our options are transferred into the main function and are processed there. *)
        ExperimentCapillaryELISA[samples,ReplaceRule[sampleOptions,Cache->Flatten[updatedCache,sampleCache]]]
    ]
];


(* ::Subsubsection::Closed:: *)
(* resolveExperimentCapillaryELISAOptions Helper Function *)

DefineOptions[
	resolveExperimentCapillaryELISAOptions,
	Options:>{HelperOutputOption,CacheOption}
];

resolveExperimentCapillaryELISAOptions[mySamples:{ObjectP[Object[Sample]]...},myOptions:{_Rule...},myResolutionOptions:OptionsPattern[resolveExperimentCapillaryELISAOptions]]:=Module[
    {
        (* Preparation *)
        outputSpecification,output,gatherTests,messages,cache,
        samplePrepOptions,capillaryELISAOptions,simulatedSamples,resolvedSamplePrepOptions,simulatedCache,samplePrepTests,
        capillaryELISAOptionsAssociation,standardOptions,standardAntibodyOptions,antibodyOptions,spikeOptions, simulatedFastAssoc,

        (* All option variables *)
		suppliedInstrument,suppliedCartridgeType,suppliedCartridge,suppliedSpecies,suppliedAnalytes,processedSuppliedAnalytes,
		suppliedSampleVolume,suppliedSpikeSample,suppliedSpikeVolume,suppliedSpikeSampleStorageCondition,suppliedDilutionCurve,suppliedSerialDilutionCurve,suppliedDiluent,suppliedDilutionMixVolume,suppliedDilutionNumberOfMixes,suppliedDilutionMixRate,
		suppliedCustomCaptureAntibody,suppliedCaptureAntibodyResuspension,suppliedCaptureAntibodyResuspensionConcentration,suppliedCaptureAntibodyResuspensionDiluent,suppliedCaptureAntibodyStorageCondition,suppliedCaptureAntibodyConjugation,suppliedCaptureAntibodyVolume,suppliedDigoxigeninReagent,suppliedDigoxigeninReagentVolume,suppliedCaptureAntibodyConjugationBuffer,suppliedCaptureAntibodyConjugationBufferVolume,suppliedCaptureAntibodyConjugationContainer,suppliedCaptureAntibodyConjugationTime,suppliedCaptureAntibodyConjugationTemperature,suppliedCaptureAntibodyPurificationColumn,suppliedCaptureAntibodyColumnWashBuffer,suppliedCaptureAntibodyConjugationStorageCondition,suppliedCaptureAntibodyDilution,suppliedCaptureAntibodyTargetConcentration,suppliedCaptureAntibodyDiluent,
		suppliedCustomDetectionAntibody,suppliedDetectionAntibodyResuspension,suppliedDetectionAntibodyResuspensionConcentration,suppliedDetectionAntibodyResuspensionDiluent,suppliedDetectionAntibodyStorageCondition,suppliedDetectionAntibodyConjugation,suppliedDetectionAntibodyVolume,suppliedBiotinReagent,suppliedBiotinReagentVolume,suppliedDetectionAntibodyConjugationBuffer,suppliedDetectionAntibodyConjugationBufferVolume,suppliedDetectionAntibodyConjugationContainer,suppliedDetectionAntibodyConjugationTime,suppliedDetectionAntibodyConjugationTemperature,suppliedDetectionAntibodyPurificationColumn,suppliedDetectionAntibodyColumnWashBuffer,suppliedDetectionAntibodyConjugationStorageCondition,suppliedDetectionAntibodyDilution,suppliedDetectionAntibodyTargetConcentration,suppliedDetectionAntibodyDiluent,
		suppliedStandard,suppliedStandardResuspension,suppliedStandardResuspensionConcentration,suppliedStandardResuspensionDiluent,suppliedStandardStorageCondition,suppliedStandardDilutionCurve,suppliedStandardSerialDilutionCurve,suppliedStandardDiluent,suppliedStandardDilutionMixVolume,suppliedStandardDilutionNumberOfMixes,suppliedStandardDilutionMixRate,
		suppliedStandardCaptureAntibody,suppliedStandardCaptureAntibodyResuspension,suppliedStandardCaptureAntibodyResuspensionConcentration,suppliedStandardCaptureAntibodyResuspensionDiluent,suppliedStandardCaptureAntibodyStorageCondition,suppliedStandardCaptureAntibodyConjugation,suppliedStandardCaptureAntibodyVolume,suppliedStandardDigoxigeninReagent,suppliedStandardDigoxigeninReagentVolume,suppliedStandardCaptureAntibodyConjugationBuffer,suppliedStandardCaptureAntibodyConjugationBufferVolume,suppliedStandardCaptureAntibodyConjugationContainer,suppliedStandardCaptureAntibodyConjugationTime,suppliedStandardCaptureAntibodyConjugationTemperature,suppliedStandardCaptureAntibodyPurificationColumn,suppliedStandardCaptureAntibodyColumnWashBuffer,suppliedStandardCaptureAntibodyConjugationStorageCondition,suppliedStandardCaptureAntibodyDilution,suppliedStandardCaptureAntibodyTargetConcentration,suppliedStandardCaptureAntibodyDiluent,
		suppliedStandardDetectionAntibody,suppliedStandardDetectionAntibodyResuspension,suppliedStandardDetectionAntibodyResuspensionConcentration,suppliedStandardDetectionAntibodyResuspensionDiluent,suppliedStandardDetectionAntibodyStorageCondition,suppliedStandardDetectionAntibodyConjugation,suppliedStandardDetectionAntibodyVolume,suppliedStandardBiotinReagent,suppliedStandardBiotinReagentVolume,suppliedStandardDetectionAntibodyConjugationBuffer,suppliedStandardDetectionAntibodyConjugationBufferVolume,suppliedStandardDetectionAntibodyConjugationContainer,suppliedStandardDetectionAntibodyConjugationTime,suppliedStandardDetectionAntibodyConjugationTemperature,suppliedStandardDetectionAntibodyPurificationColumn,suppliedStandardDetectionAntibodyColumnWashBuffer,suppliedStandardDetectionAntibodyConjugationStorageCondition,suppliedStandardDetectionAntibodyDilution,suppliedStandardDetectionAntibodyTargetConcentration,suppliedStandardDetectionAntibodyDiluent,
		suppliedWashBuffer,
		suppliedLoadingVolume,suppliedCaptureAntibodyLoadingVolume,suppliedDetectionAntibodyLoadingVolume,suppliedStandardLoadingVolume,suppliedStandardCaptureAntibodyLoadingVolume,suppliedStandardDetectionAntibodyLoadingVolume,
		suppliedStandardComposition,suppliedSpikeConcentration,
		suppliedNumberOfReplicates,

		resolvedInstrument,resolvedCartridgeType,resolvedCartridge,resolvedSpecies,resolvedAnalytes,
		resolvedSampleVolume,resolvedSpikeSample,resolvedSpikeSampleStorageCondition,resolvedSpikeVolume,resolvedDilutionCurve,resolvedSerialDilutionCurve,resolvedDiluent,resolvedDilutionMixVolume,resolvedDilutionNumberOfMixes,resolvedDilutionMixRate,
		resolvedCustomCaptureAntibody,resolvedCaptureAntibodyResuspension,resolvedCaptureAntibodyResuspensionConcentration,resolvedCaptureAntibodyResuspensionDiluent,resolvedCaptureAntibodyStorageCondition,resolvedCaptureAntibodyConjugation,resolvedCaptureAntibodyVolume,resolvedDigoxigeninReagent,resolvedDigoxigeninReagentVolume,resolvedCaptureAntibodyConjugationBuffer,resolvedCaptureAntibodyConjugationBufferVolume,resolvedCaptureAntibodyConjugationContainer,resolvedCaptureAntibodyConjugationTime,resolvedCaptureAntibodyConjugationTemperature,resolvedCaptureAntibodyPurificationColumn,resolvedCaptureAntibodyColumnWashBuffer,resolvedCaptureAntibodyConjugationStorageCondition,resolvedCaptureAntibodyDilution,resolvedCaptureAntibodyTargetConcentration,resolvedCaptureAntibodyDiluent,
		resolvedCustomDetectionAntibody,resolvedDetectionAntibodyResuspension,resolvedDetectionAntibodyResuspensionConcentration,resolvedDetectionAntibodyResuspensionDiluent,resolvedDetectionAntibodyStorageCondition,resolvedDetectionAntibodyConjugation,resolvedDetectionAntibodyVolume,resolvedBiotinReagent,resolvedBiotinReagentVolume,resolvedDetectionAntibodyConjugationBuffer,resolvedDetectionAntibodyConjugationBufferVolume,resolvedDetectionAntibodyConjugationContainer,resolvedDetectionAntibodyConjugationTime,resolvedDetectionAntibodyConjugationTemperature,resolvedDetectionAntibodyPurificationColumn,resolvedDetectionAntibodyColumnWashBuffer,resolvedDetectionAntibodyConjugationStorageCondition,resolvedDetectionAntibodyDilution,resolvedDetectionAntibodyTargetConcentration,resolvedDetectionAntibodyDiluent,
		resolvedStandard,resolvedStandardResuspension,resolvedStandardResuspensionConcentration,resolvedStandardResuspensionDiluent,resolvedStandardStorageCondition,resolvedStandardDilutionCurve,resolvedStandardSerialDilutionCurve,resolvedStandardDiluent,resolvedStandardDilutionMixVolume,resolvedStandardDilutionNumberOfMixes,resolvedStandardDilutionMixRate,
		resolvedStandardCaptureAntibody,resolvedStandardCaptureAntibodyResuspension,resolvedStandardCaptureAntibodyResuspensionConcentration,resolvedStandardCaptureAntibodyResuspensionDiluent,resolvedStandardCaptureAntibodyStorageCondition,resolvedStandardCaptureAntibodyConjugation,resolvedStandardCaptureAntibodyVolume,resolvedStandardDigoxigeninReagent,resolvedStandardDigoxigeninReagentVolume,resolvedStandardCaptureAntibodyConjugationBuffer,resolvedStandardCaptureAntibodyConjugationBufferVolume,resolvedStandardCaptureAntibodyConjugationContainer,resolvedStandardCaptureAntibodyConjugationTime,resolvedStandardCaptureAntibodyConjugationTemperature,resolvedStandardCaptureAntibodyPurificationColumn,resolvedStandardCaptureAntibodyColumnWashBuffer,resolvedStandardCaptureAntibodyConjugationStorageCondition,resolvedStandardCaptureAntibodyDilution,resolvedStandardCaptureAntibodyTargetConcentration,resolvedStandardCaptureAntibodyDiluent,
		resolvedStandardDetectionAntibody,resolvedStandardDetectionAntibodyResuspension,resolvedStandardDetectionAntibodyResuspensionConcentration,resolvedStandardDetectionAntibodyResuspensionDiluent,resolvedStandardDetectionAntibodyStorageCondition,resolvedStandardDetectionAntibodyConjugation,resolvedStandardDetectionAntibodyVolume,resolvedStandardBiotinReagent,resolvedStandardBiotinReagentVolume,resolvedStandardDetectionAntibodyConjugationBuffer,resolvedStandardDetectionAntibodyConjugationBufferVolume,resolvedStandardDetectionAntibodyConjugationContainer,resolvedStandardDetectionAntibodyConjugationTime,resolvedStandardDetectionAntibodyConjugationTemperature,resolvedStandardDetectionAntibodyPurificationColumn,resolvedStandardDetectionAntibodyColumnWashBuffer,resolvedStandardDetectionAntibodyConjugationStorageCondition,resolvedStandardDetectionAntibodyDilution,resolvedStandardDetectionAntibodyTargetConcentration,resolvedStandardDetectionAntibodyDiluent,
		resolvedWashBuffer,
		resolvedLoadingVolume,resolvedCaptureAntibodyLoadingVolume,resolvedDetectionAntibodyLoadingVolume,resolvedStandardLoadingVolume,resolvedStandardCaptureAntibodyLoadingVolume,resolvedStandardDetectionAntibodyLoadingVolume,
		resolvedStandardComposition,resolvedSpikeConcentration,
		resolvedNumberOfReplicates,
        resolvedConfirm,resolvedName,resolvedTemplate,resolvedSamplesInStorageCondition,resolvedPreparatoryPrimitives,resolvedCache,resolvedFastTrack,resolvedOperator,resolvedOutput,resolvedParentProtocol,resolvedUpload,

        (* Download *)
        simulatedSamplePackets,simulatedSampleContainers,simulatedSampleContainerModels,samplePackets,
        suppliedInstrumentPacket,suppliedInstrumentModelPacket,suppliedCartridgePacket,suppliedCustomizableAnalytes,suppliedAnalytesNoDuplicates,suppliedAnalytesManufacturingSpecificationPackets,suppliedPreLoadedAnalyteMolecules,suppliedPreLoadedAnalytes,
		suppliedSpikePackets,suppliedDiluentPackets,suppliedDiluentModels,
		suppliedCustomCaptureAntibodyPackets,suppliedCaptureAntibodyPurificationColumnPackets,suppliedCaptureAntibodyDiluentPackets,suppliedCaptureAntibodyDiluentModels,suppliedCustomDetectionAntibodyPackets,suppliedDetectionAntibodyPurificationColumnPackets,suppliedDetectionAntibodyDiluentPackets,suppliedDetectionAntibodyDiluentModels,
		suppliedStandardPackets,suppliedStandardDiluentPackets,suppliedStandardDiluentModels,
		suppliedStandardCaptureAntibodyPackets,suppliedStandardCaptureAntibodyPurificationColumnPackets,suppliedStandardCaptureAntibodyDiluentPackets,suppliedStandardCaptureAntibodyDiluentModels,suppliedStandardDetectionAntibodyPackets,suppliedStandardDetectionAntibodyPurificationColumnPackets,suppliedStandardDetectionAntibodyDiluentPackets,suppliedStandardDetectionAntibodyDiluentModels,
		suppliedWashBufferPacket,suppliedWashBufferModel,
		potentialSpinColumns,potential40KSpinColumns,potential40KSpinColumnPackets,potential40KSpinColumnMaxVolumes,sorted40KSpinColumnsWithMaxVolumes,

        (* Input Validation Checks *)
		intNumberOfReplicates,discardedSamplePackets,discardedInvalidInputs,discardedTest,tooManyInvalidInputs,tooManyInvalidOption,tooManyInputsTests,

        (* Option Precision Checks *)
		unroundedDilutionCurve,unroundedSerialDilutionCurve,unroundedCaptureAntibodyResuspensionConcentration,unroundedCaptureAntibodyTargetConcentration,unroundedDetectionAntibodyResuspensionConcentration,unroundedDetectionAntibodyTargetConcentration,unroundedStandardResuspensionConcentration,unroundedStandardDilutionCurve,unroundedStandardSerialDilutionCurve,unroundedStandardCaptureAntibodyResuspensionConcentration,unroundedStandardCaptureAntibodyTargetConcentration,unroundedStandardDetectionAntibodyResuspensionConcentration,unroundedStandardDetectionAntibodyTargetConcentration,
        dilutionCurveOptions,dilutionCurveValues,processedUnroundedDilutionCurve,processedUnroundedStandardDilutionCurve,processedDilutionCurveValues,dilutionCurveVolumeValuePositions,dilutionCurveDilutionFactorValuePositions,dilutionCurveVolumeValueAssociation,dilutionCurveDilutionFactorValueAssociation,dilutionCurveVolumeRoundedAssociation,dilutionCurveVolumePrecisionTests,dilutionCurveDilutionFactorRoundedAssociation,dilutionCurveDilutionFactorPrecisionTests,roundedDilutionCurveOptions,
		serialDilutionCurveOptions,processedUnroundedStandardSerialDilutionCurve,processedUnroundedSerialDilutionCurve,serialDilutionCurveValues,serialDilutionCurveVolumeValuePositions,serialDilutionCurveDilutionFactorValuePositions,serialDilutionCurveVolumeValueAssociation,serialDilutionCurveDilutionFactorValueAssociation,serialDilutionCurveVolumeRoundedAssociation,serialDilutionCurveVolumePrecisionTests,serialDilutionCurveDilutionFactorRoundedAssociation,serialDilutionCurveDilutionFactorPrecisionTests,roundedSerialDilutionCurveOptions,
		concentrationOptions,concentrationOptionValues,molarValuePositions,massConcentrationValuePositions,molarValueAssociation,massConcentrationValueAssociation,molarRoundedAssociation,molarPrecisionTests,massConcentrationRoundedAssociation,massConcentrationPrecisionTests,roundedConcentrationOptions,
		roundedOtherCapillaryELISAOptions,otherPrecisionTests,roundedCapillaryELISAOptionsAssociation,allRoundingTests,

        (* Option Conflict Checks *)
        validNameQ,nameInvalidOption,validNameTest,notRetiredInstrumentQ,notDeprecatedInstrumentQ,instrumentInvalidOption,notRetiredInstrumentTests,notDeprecatedInstrumentTests,discardedCartridgeInvalidOption,discardedCartridgeInvalidTest,totalNumberOfSamples,tooManyLoadingSamplesOptions,tooManyLoadingSamplesTests,cartridgeSamplesCapacity,exceedCartridgeCapacityOption,exceedCartridgeCapacityTests,
        invalidCustomizableCartridgeTypeOptions,invalidCustomizableCartridgeTypeTests,suppliedCartridgeTypeFromCartridge,conflictCartridgeTypeQ,conflictCartridgeTypeOptions,conflictCartridgeTypeTests,suppliedAnalyteNamesFromCartridge,suppliedAnalyteMoleculesFromCartridge,conflictCartridgeAndAnalytesQ,conflictCartridgeAndAnalytesOptions,conflictCartridgeAndAnalytesTests,conflictPreLoadedAnalytesQ,conflictPreLoadedAnalytesOptions,conflictPreLoadedAnalytesTests,exceedLengthAnalytesQ,exceedLengthAnalytesSamples,exceedLengthAnalytesOptions,exceedLengthAnalytesTests,conflictMultiPlexCartridgeTypeOptions,conflictMultiPlexCartridgeTypeTests,
		duplicatedAnalyteIdentityModels,duplicatedAnalytes,duplicatedAnalytesOption,duplicatedAnalytesTests,totalNumberOfPreLoadedAnalytes,recommendedCartridgeType,tooManyAnalytesOption,tooManyAnalytesTests,tooManyAnalytesForSampleNumberQ,tooManyAnalytesForSampleNumberOption,tooManyAnalytesForSampleNumberTests,unsupportedAnalytes,supportedAnalytes,unsupportedAnalytesOption,unsupportedAnalytesTests,analyteSpecies,wrongAnalytesSpeciesQ,wrongSpeciesAnalytes,wrongSpeciesAnalytesOption,wrongSpeciesAnalytesTests,analyteCartridgeTypes,analyteMultiPlexQ,wrongCartridgeTypeAnalytes,wrongCartridgeTypeAnalytesOption,wrongCartridgeTypeAnalytesTests,analyteDiluents,analyteAllDiluents,analyteCommonDiluentQ,analyteMinDilutionFactors,analyteAllMinDilutionFactors,analyteCommonMinDilutionFactorQ,analyteIncompatibleAnalytes,incompatibleAnalyteQ,incompatibleAnalyteDiluentOption,incompatibleAnalyteMinDilutionFactorOption,incompatibleAnalytesOption,incompatibleAnalyteDiluentTests,incompatibleAnalyteDilutionFactorTests,incompatibleAnalytesTests,
		invalidSpikeOptionChecks,invalidSpikeOptionInputs,invalidSpikeOptions,invalidSpikeTests,nonLiquidSpikeQ,nonLiquidSpikeOption,nonLiquidSpikeTests,missingSpikeVolumeChecks,missingSpikeOptionsChecks,missingSpikeOptionInputs,missingSpikeOptionSpikes,missingSpikeOptions,missingSpikeOptionTests,wrongAnalyteSpikeConcentrationQ,wrongAnalyteSpikeConcentrationOption,wrongAnalyteSpikeConcentrationTests,notEnoughSampleSpikeVolumeQ,notEnoughSampleSpikeVolumeSamples,notEnoughSampleSpikeVolumeOptions,notEnoughSampleSpikeVolumeTests,
		conflictDilutionCurveQ,conflictDilutionCurveOptions,conflictDilutionCurveTests,mandatoryDilutionQ,mandatoryDilutionSamples,mandatoryDilutionProvidedOptions,mandatoryDilutionAutomaticOptions,mandatoryDilutionTests,nonOptimalLoadingVolumeQ,nonOptimalLoadingVolumeTests,exceedDilutionLoadingVolumeQ,exceedDilutionLoadingVolumeSamples,exceedDilutionLoadingVolumes,exceedDilutionLoadingVolumeOptions,exceedDilutionLoadingVolumeTests,invalidDilutionCurveQ,invalidDilutionCurveOption,invalidDilutionCurveTests,invalidDilutionMixVolumeQ,invalidDilutionMixVolumeSamples,invalidDilutionMixVolumeOption,invalidDilutionMixVolumeTests,
		invalidAntibodyRelatedOptionChecks,invalidAntibodyRelatedOptionSamples,invalidAntibodyRelatedOptions,invalidAntibodyRelatedTests,
		captureAntibodyStates,solidCaptureAntibodyResuspensionValidQ,liquidCaptureAntibodyResuspensionValidQ,solidCaptureAntibodyResuspensionInvalidSamples,solidCaptureAntibodyResuspensionInvalidAntibodies,liquidCaptureAntibodyResuspensionInvalidSamples,liquidCaptureAntibodyResuspensionInvalidAntibodies,captureAntibodyResuspensionInvalidSamples,captureAntibodyResuspensionInvalidAntibodies,solidCaptureAntibodyResuspensionInvalidOption,liquidCaptureAntibodyResuspensionInvalidOption,captureAntibodyResuspensionInvalidTests,captureAntibodyResuspensionOptions, invalidCaptureAntibodyResuspensionRelatedOptionChecks,invalidCaptureAntibodyResuspensionRelatedOptionLiquidChecks,invalidCaptureAntibodyResuspensionRelatedOptionSamples,invalidCaptureAntibodyResuspensionRelatedOptionAntibodies,invalidCaptureAntibodyResuspensionOptions,invalidCaptureAntibodyResuspensionTests,missingCaptureAntibodyResuspensionOptionChecks,missingCaptureAntibodyResuspensionOptionSolidChecks,missingCaptureAntibodyResuspensionSamples,missingCaptureAntibodyResuspensionAntibodies,missingCaptureAntibodyResuspensionOptions,missingCaptureAntibodyResuspensionTests,
		captureAntibodyConjugationOptions,invalidCaptureAntibodyConjugationRelatedOptionChecks,invalidCaptureAntibodyConjugationRelatedOptionSamples,invalidCaptureAntibodyConjugationRelatedOptionAntibodies,invalidCaptureAntibodyConjugationOptions,invalidCaptureAntibodyConjugationTests,missingCaptureAntibodyConjugationRelatedOptionChecks,missingCaptureAntibodyConjugationRelatedOptionSamples,missingCaptureAntibodyConjugationRelatedOptionAntibodies,missingCaptureAntibodyConjugationOptions,missingCaptureAntibodyConjugationTests,captureAntibodyConjugationOptionValues,captureAntibodyConjugationOptionConflictQ,captureAntibodyConjugationOptionConflictSamples,captureAntibodyConjugationOptionConflictAntibodies,captureAntibodyConjugationConflictOptions,captureAntibodyConjugationOptionConflictTests,suppliedCaptureAntibodyPurificationColumnMWCO,unsupportedCaptureAntibodyPurificationColumnOption,unsupportedCaptureAntibodyPurificationColumnTests,nonOptimalCaptureAntibodyPurificationColumnTests,
		captureAntibodyDilutionOptions,invalidCaptureAntibodyDilutionRelatedOptionChecks,invalidCaptureAntibodyDilutionRelatedOptionSamples,invalidCaptureAntibodyDilutionRelatedOptionAntibodies,invalidCaptureAntibodyDilutionOptions,invalidCaptureAntibodyDilutionTests,missingRecommendedCaptureAntibodyDilutionQ,missingRecommendedCaptureAntibodyDilutionSamples,missingRecommendedCaptureAntibodyDilutionAntibodies,missingRecommendedCaptureAntibodyDilutionTests,missingCaptureAntibodyDilutionOptionsChecks,missingCaptureAntibodyDilutionOptionsSamples,missingCaptureAntibodyDilutionOptionsAntibodies,missingCaptureAntibodyDilutionOptions,missingCaptureAntibodyDilutionOptionTests,captureAntibodyDilutionOptionValues,captureAntibodyDilutionOptionConflictQ,captureAntibodyDilutionOptionConflictSamples,captureAntibodyDilutionOptionConflictAntibodies,captureAntibodyDilutionConflictOptions,captureAntibodyDilutionOptionConflictTests,nonOptimalCaptureAntibodyDiluentQ,nonOptimalCaptureAntibodyDiluentSamples,nonOptimalCaptureAntibodyDiluentAntibodies,nonOptimalCaptureAntibodyDiluentTests,missingCaptureAntibodyLoadingVolumeChecks,missingCaptureAntibodyLoadingVolumeSamples,missingCaptureAntibodyLoadingVolumeAntibodies,missingCaptureAntibodyLoadingVolumeOption,missingCaptureAntibodyLoadingVolumeTests,
		detectionAntibodyStates,solidDetectionAntibodyResuspensionValidQ,liquidDetectionAntibodyResuspensionValidQ,solidDetectionAntibodyResuspensionInvalidSamples,solidDetectionAntibodyResuspensionInvalidAntibodies,liquidDetectionAntibodyResuspensionInvalidSamples,liquidDetectionAntibodyResuspensionInvalidAntibodies,detectionAntibodyResuspensionInvalidSamples,detectionAntibodyResuspensionInvalidAntibodies,solidDetectionAntibodyResuspensionInvalidOption,liquidDetectionAntibodyResuspensionInvalidOption,detectionAntibodyResuspensionInvalidTests,detectionAntibodyResuspensionOptions, invalidDetectionAntibodyResuspensionRelatedOptionChecks,invalidDetectionAntibodyResuspensionRelatedOptionLiquidChecks,invalidDetectionAntibodyResuspensionRelatedOptionSamples,invalidDetectionAntibodyResuspensionRelatedOptionAntibodies,invalidDetectionAntibodyResuspensionOptions,invalidDetectionAntibodyResuspensionTests,missingDetectionAntibodyResuspensionOptionChecks,missingDetectionAntibodyResuspensionOptionSolidChecks,missingDetectionAntibodyResuspensionSamples,missingDetectionAntibodyResuspensionAntibodies,missingDetectionAntibodyResuspensionOptions,missingDetectionAntibodyResuspensionTests,
		detectionAntibodyConjugationOptions,invalidDetectionAntibodyConjugationRelatedOptionChecks,invalidDetectionAntibodyConjugationRelatedOptionSamples,invalidDetectionAntibodyConjugationRelatedOptionAntibodies,invalidDetectionAntibodyConjugationOptions,invalidDetectionAntibodyConjugationTests,missingDetectionAntibodyConjugationRelatedOptionChecks,missingDetectionAntibodyConjugationRelatedOptionSamples,missingDetectionAntibodyConjugationRelatedOptionAntibodies,missingDetectionAntibodyConjugationOptions,missingDetectionAntibodyConjugationTests,detectionAntibodyConjugationOptionValues,detectionAntibodyConjugationOptionConflictQ,detectionAntibodyConjugationOptionConflictSamples,detectionAntibodyConjugationOptionConflictAntibodies,detectionAntibodyConjugationConflictOptions,detectionAntibodyConjugationOptionConflictTests,suppliedDetectionAntibodyPurificationColumnMWCO,unsupportedDetectionAntibodyPurificationColumnOption,unsupportedDetectionAntibodyPurificationColumnTests,nonOptimalDetectionAntibodyPurificationColumnTests,
		detectionAntibodyDilutionOptions,invalidDetectionAntibodyDilutionRelatedOptionChecks,invalidDetectionAntibodyDilutionRelatedOptionSamples,invalidDetectionAntibodyDilutionRelatedOptionAntibodies,invalidDetectionAntibodyDilutionOptions,invalidDetectionAntibodyDilutionTests,missingRecommendedDetectionAntibodyDilutionQ,missingRecommendedDetectionAntibodyDilutionSamples,missingRecommendedDetectionAntibodyDilutionAntibodies,missingRecommendedDetectionAntibodyDilutionTests,missingDetectionAntibodyDilutionOptionsChecks,missingDetectionAntibodyDilutionOptionsSamples,missingDetectionAntibodyDilutionOptionsAntibodies,missingDetectionAntibodyDilutionOptions,missingDetectionAntibodyDilutionOptionTests,detectionAntibodyDilutionOptionValues,detectionAntibodyDilutionOptionConflictQ,detectionAntibodyDilutionOptionConflictSamples,detectionAntibodyDilutionOptionConflictAntibodies,detectionAntibodyDilutionConflictOptions,detectionAntibodyDilutionOptionConflictTests,nonOptimalDetectionAntibodyDiluentQ,nonOptimalDetectionAntibodyDiluentSamples,nonOptimalDetectionAntibodyDiluentAntibodies,nonOptimalDetectionAntibodyDiluentTests,missingDetectionAntibodyLoadingVolumeChecks,missingDetectionAntibodyLoadingVolumeSamples,missingDetectionAntibodyLoadingVolumeAntibodies,missingDetectionAntibodyLoadingVolumeOption,missingDetectionAntibodyLoadingVolumeTests,
		nullStandardMemberOption,nullStandardMemberTests,nullStandardRelatedOptionsQ,invalidStandardOptions,invalidStandardTests,
		standardStates,solidStandardResuspensionValidQ,liquidStandardResuspensionValidQ,solidStandardResuspensionInvalidSamples,liquidStandardResuspensionInvalidSamples,standardResuspensionInvalidSamples,solidStandardResuspensionInvalidOption,liquidStandardResuspensionInvalidOption,standardResuspensionInvalidTests,standardResuspensionOptions,invalidStandardResuspensionRelatedOptionChecks,invalidStandardResuspensionRelatedOptionLiquidChecks,invalidStandardResuspensionRelatedOptionSamples,invalidStandardResuspensionOptions,invalidStandardResuspensionTests,missingStandardResuspensionOptionChecks,missingStandardResuspensionOptionSolidChecks,missingStandardResuspensionSamples,missingStandardResuspensionAntibodies,missingStandardResuspensionOptions,missingStandardResuspensionTests,
		missingStandardRelatedOptionsChecks,missingStandardRelatedOptionsSamples,missingStandardRelatedOptions,missingStandardRelatedOptionsTests,conflictStandardDilutionCurveQ,conflictStandardDilutionCurveOptions,conflictStandardDilutionCurveTests,mandatoryStandardDilutionQ,mandatoryStandardDilutionSamples,mandatoryStandardDilutionProvidedOptions,mandatoryStandardDilutionAutomaticOptions,mandatoryStandardDilutionTests,nonOptimalStandardDilutionCurveQ,nonOptimalStandardDilutionCurveTests,nonOptimalStandardLoadingVolumeQ,nonOptimalStandardLoadingVolumeTests,exceedStandardDilutionLoadingVolumeQ,exceedStandardDilutionLoadingVolumes,exceedStandardDilutionNonAutomaticLoadingVolumes,exceedStandardDilutionLoadingVolumeSamples,exceedStandardDilutionLoadingVolumeOptions,exceedStandardDilutionLoadingVolumeTests,invalidStandardDilutionCurveQ,invalidStandardDilutionCurveOption,invalidStandardDilutionCurveTests,invalidStandardDilutionMixVolumeQ,invalidStandardDilutionMixVolumeSamples,invalidStandardDilutionMixVolumeOption,invalidStandardDilutionMixVolumeTests,conflictStandardStandardCompositionQ,conflictStandardCompositionTests,exceedStandardStandardCompositionQ,exceedStandardStandardCompositionOption,exceedStandardStandardCompositionTests,wrongAnalyteStandardCompositionQ,wrongAnalyteStandardCompositionOption,wrongAnalyteStandardCompositionTests,
		invalidStandardAntibodyRelatedOptionChecks,invalidStandardAntibodyRelatedOptionSamples,invalidStandardAntibodyRelatedOptions,invalidStandardAntibodyRelatedTests,
		standardCaptureAntibodyStates,solidStandardCaptureAntibodyResuspensionValidQ,liquidStandardCaptureAntibodyResuspensionValidQ,solidStandardCaptureAntibodyResuspensionInvalidSamples,solidStandardCaptureAntibodyResuspensionInvalidAntibodies,liquidStandardCaptureAntibodyResuspensionInvalidSamples,liquidStandardCaptureAntibodyResuspensionInvalidAntibodies,standardCaptureAntibodyResuspensionInvalidSamples,standardCaptureAntibodyResuspensionInvalidAntibodies, solidStandardCaptureAntibodyResuspensionInvalidOption,liquidStandardCaptureAntibodyResuspensionInvalidOption,standardCaptureAntibodyResuspensionInvalidTests,standardCaptureAntibodyResuspensionOptions, invalidStandardCaptureAntibodyResuspensionRelatedOptionChecks,invalidStandardCaptureAntibodyResuspensionRelatedOptionLiquidChecks,invalidStandardCaptureAntibodyResuspensionRelatedOptionSamples,invalidStandardCaptureAntibodyResuspensionRelatedOptionAntibodies,invalidStandardCaptureAntibodyResuspensionOptions,invalidStandardCaptureAntibodyResuspensionTests,missingStandardCaptureAntibodyResuspensionOptionChecks,missingStandardCaptureAntibodyResuspensionOptionSolidChecks,missingStandardCaptureAntibodyResuspensionSamples,missingStandardCaptureAntibodyResuspensionAntibodies,missingStandardCaptureAntibodyResuspensionOptions,missingStandardCaptureAntibodyResuspensionTests,
        standardCaptureAntibodyConjugationOptions,invalidStandardCaptureAntibodyConjugationRelatedOptionChecks,invalidStandardCaptureAntibodyConjugationRelatedOptionSamples,invalidStandardCaptureAntibodyConjugationRelatedOptionAntibodies,invalidStandardCaptureAntibodyConjugationOptions,invalidStandardCaptureAntibodyConjugationTests,missingStandardCaptureAntibodyConjugationRelatedOptionChecks,missingStandardCaptureAntibodyConjugationRelatedOptionSamples,missingStandardCaptureAntibodyConjugationRelatedOptionAntibodies,missingStandardCaptureAntibodyConjugationOptions,missingStandardCaptureAntibodyConjugationTests,standardCaptureAntibodyConjugationOptionValues,standardCaptureAntibodyConjugationOptionConflictQ,standardCaptureAntibodyConjugationOptionConflictSamples,standardCaptureAntibodyConjugationOptionConflictAntibodies,standardCaptureAntibodyConjugationConflictOptions,standardCaptureAntibodyConjugationOptionConflictTests,suppliedStandardCaptureAntibodyPurificationColumnMWCO,unsupportedStandardCaptureAntibodyPurificationColumnOption,unsupportedStandardCaptureAntibodyPurificationColumnTests,nonOptimalStandardCaptureAntibodyPurificationColumnTests,
		standardCaptureAntibodyDilutionOptions,invalidStandardCaptureAntibodyDilutionRelatedOptionChecks,invalidStandardCaptureAntibodyDilutionRelatedOptionSamples,invalidStandardCaptureAntibodyDilutionRelatedOptionAntibodies,invalidStandardCaptureAntibodyDilutionOptions,invalidStandardCaptureAntibodyDilutionTests,missingRecommendedStandardCaptureAntibodyDilutionQ,missingRecommendedStandardCaptureAntibodyDilutionSamples,missingRecommendedStandardCaptureAntibodyDilutionAntibodies,missingRecommendedStandardCaptureAntibodyDilutionTests,missingStandardCaptureAntibodyDilutionOptionsChecks,missingStandardCaptureAntibodyDilutionOptionsSamples,missingStandardCaptureAntibodyDilutionOptionsAntibodies,missingStandardCaptureAntibodyDilutionOptions,missingStandardCaptureAntibodyDilutionOptionTests,standardCaptureAntibodyDilutionOptionValues,standardCaptureAntibodyDilutionOptionConflictQ,standardCaptureAntibodyDilutionOptionConflictSamples,standardCaptureAntibodyDilutionOptionConflictAntibodies,standardCaptureAntibodyDilutionConflictOptions,standardCaptureAntibodyDilutionOptionConflictTests,nonOptimalStandardCaptureAntibodyDiluentQ,nonOptimalStandardCaptureAntibodyDiluentSamples,nonOptimalStandardCaptureAntibodyDiluentAntibodies,nonOptimalStandardCaptureAntibodyDiluentTests,missingStandardCaptureAntibodyLoadingVolumeChecks,missingStandardCaptureAntibodyLoadingVolumeSamples,missingStandardCaptureAntibodyLoadingVolumeAntibodies,missingStandardCaptureAntibodyLoadingVolumeOption,missingStandardCaptureAntibodyLoadingVolumeTests,
		standardDetectionAntibodyStates,solidStandardDetectionAntibodyResuspensionValidQ,liquidStandardDetectionAntibodyResuspensionValidQ,solidStandardDetectionAntibodyResuspensionInvalidSamples,solidStandardDetectionAntibodyResuspensionInvalidAntibodies,liquidStandardDetectionAntibodyResuspensionInvalidSamples,liquidStandardDetectionAntibodyResuspensionInvalidAntibodies,standardDetectionAntibodyResuspensionInvalidSamples,standardDetectionAntibodyResuspensionInvalidAntibodies, solidStandardDetectionAntibodyResuspensionInvalidOption,liquidStandardDetectionAntibodyResuspensionInvalidOption,standardDetectionAntibodyResuspensionInvalidTests,standardDetectionAntibodyResuspensionOptions, invalidStandardDetectionAntibodyResuspensionRelatedOptionChecks,invalidStandardDetectionAntibodyResuspensionRelatedOptionLiquidChecks,invalidStandardDetectionAntibodyResuspensionRelatedOptionSamples,invalidStandardDetectionAntibodyResuspensionRelatedOptionAntibodies,invalidStandardDetectionAntibodyResuspensionOptions,invalidStandardDetectionAntibodyResuspensionTests,missingStandardDetectionAntibodyResuspensionOptionChecks,missingStandardDetectionAntibodyResuspensionOptionSolidChecks,missingStandardDetectionAntibodyResuspensionSamples,missingStandardDetectionAntibodyResuspensionAntibodies,missingStandardDetectionAntibodyResuspensionOptions,missingStandardDetectionAntibodyResuspensionTests,
		standardDetectionAntibodyConjugationOptions,invalidStandardDetectionAntibodyConjugationRelatedOptionChecks,invalidStandardDetectionAntibodyConjugationRelatedOptionSamples,invalidStandardDetectionAntibodyConjugationRelatedOptionAntibodies,invalidStandardDetectionAntibodyConjugationOptions,invalidStandardDetectionAntibodyConjugationTests,missingStandardDetectionAntibodyConjugationRelatedOptionChecks,missingStandardDetectionAntibodyConjugationRelatedOptionSamples,missingStandardDetectionAntibodyConjugationRelatedOptionAntibodies,missingStandardDetectionAntibodyConjugationOptions,missingStandardDetectionAntibodyConjugationTests,standardDetectionAntibodyConjugationOptionValues,standardDetectionAntibodyConjugationOptionConflictQ,standardDetectionAntibodyConjugationOptionConflictSamples,standardDetectionAntibodyConjugationOptionConflictAntibodies,standardDetectionAntibodyConjugationConflictOptions,standardDetectionAntibodyConjugationOptionConflictTests,suppliedStandardDetectionAntibodyPurificationColumnMWCO,unsupportedStandardDetectionAntibodyPurificationColumnOption,unsupportedStandardDetectionAntibodyPurificationColumnTests,nonOptimalStandardDetectionAntibodyPurificationColumnTests,
		standardDetectionAntibodyDilutionOptions,invalidStandardDetectionAntibodyDilutionRelatedOptionChecks,invalidStandardDetectionAntibodyDilutionRelatedOptionSamples,invalidStandardDetectionAntibodyDilutionRelatedOptionAntibodies,invalidStandardDetectionAntibodyDilutionOptions,invalidStandardDetectionAntibodyDilutionTests,missingRecommendedStandardDetectionAntibodyDilutionQ,missingRecommendedStandardDetectionAntibodyDilutionSamples,missingRecommendedStandardDetectionAntibodyDilutionAntibodies,missingRecommendedStandardDetectionAntibodyDilutionTests,missingStandardDetectionAntibodyDilutionOptionsChecks,missingStandardDetectionAntibodyDilutionOptionsSamples,missingStandardDetectionAntibodyDilutionOptionsAntibodies,missingStandardDetectionAntibodyDilutionOptions,missingStandardDetectionAntibodyDilutionOptionTests,standardDetectionAntibodyDilutionOptionValues,standardDetectionAntibodyDilutionOptionConflictQ,standardDetectionAntibodyDilutionOptionConflictSamples,standardDetectionAntibodyDilutionOptionConflictAntibodies,standardDetectionAntibodyDilutionConflictOptions,standardDetectionAntibodyDilutionOptionConflictTests,nonOptimalStandardDetectionAntibodyDiluentQ,nonOptimalStandardDetectionAntibodyDiluentSamples,nonOptimalStandardDetectionAntibodyDiluentAntibodies,nonOptimalStandardDetectionAntibodyDiluentTests,missingStandardDetectionAntibodyLoadingVolumeChecks,missingStandardDetectionAntibodyLoadingVolumeSamples,missingStandardDetectionAntibodyLoadingVolumeAntibodies,missingStandardDetectionAntibodyLoadingVolumeOption,missingStandardDetectionAntibodyLoadingVolumeTests,
		nonOptimalWashBufferTests,
		customCaptureAntibodyOptionValues,customDetectionAntibodyOptionValues,standardCaptureAntibodyOptionValues,standardDetectionAntibodyOptionValues,allCaptureAntibodyOptionValues,allDetectionAntibodyOptionValues,objectSampleCaptureAntibodyOptionValues,objectSampleDetectionAntibodyOptionValues,objectSampleAntibodyOptionValues,objectSampleDetectionAntibodies,objectSampleCaptureAntibodies,conflictAntibodyObjectSampleOptions,conflictAntibodyObjectSampleTests,gatheredObjectSampleAntibodyOptionValues,transposedGatheredObjectSampleAntibodyOptionValues,noDuplicateObjectSampleAntibodyValues,moreThanOneValueObjectSampleAntibodyQ,conflictObjectSampleQ,conflictOptionAntibodyObjectSamples,conflictOptionValueAntibodyOptions,conflictOptionValueAntibodyTests,objectSampleOptionValuesCollapsed,

		(* Resolve Options - not including the ones in MapThread modules *)
        preLoadedAnalytes,customizableAnalytes,rankedPreLoadedAnalytes,rankedPreLoadedAnalytesManufacturingSpecifications,resolvedCartridgePacket,longLeadTimeCartridgeQ,longLeadTimeCartridgeTests,resolvedCustomizableCartridgeQ,resolvedPreLoadedAnalytes,resolvedPreLoadeAnalyteMolecules,resolvedPreLoadedAnalyteNames,missingPreLoadedAnalytesOption,missingPreLoadedAnalytesTests,emptyCartridgeChannelQ,emptyCartridgeChannelTests,resolvedCustomizableAnalytes,firstPreLoadedAnalyteName,firstPreLoadedAnalyteManufacturingSpecification,bestDiluent,bestMinDilutionFactor, resolvedAnalytePackets,resolvedAnalyteDefaultModels,resolvedPreLoadedAnalyteDefaultModels,commonCustomizableAnalyteDefaultModels,suppliedFirstStandardDilutionCurve,suppliedFirstStandardSerialDilutionCurve,standardDilutionNumber,allowedStandardNumber,resolvedPreLoadedStandardAnalytes,resolvedCustomizableStandardAnalytes,
		mapThreadFriendlyOptions,standardOptionLengthInvalidOptions,standardOptionLengthInvalidTests,extractedStandardOptions,extractedStandardOptionFirstValues,mapThreadExpandedStandardOptions,standardMapThreadFriendlyOptions,
		nonOptimalStandardResuspensionWarnings,incompleteResolvedStandardCompositionErrors,nonOptimalStandardDiluentWarnings,conflictStandardAntibodyEpitopeWarnings,standardCaptureAntibodyAssayTypeWarnings,standardDetectionAntibodyAssayTypeWarnings,missingStandardCaptureAntibodyErrors,missingStandardDetectionAntibodyErrors,missingStandardDigoxigeninReagentVolumeErrors,missingStandardBiotinReagentVolumeErrors,notEnoughStandardDigoxigeninReagentVolumeWarnings,notEnoughStandardBiotinReagentVolumeWarnings,exceedStandardCaptureAntibodyConjugationContainerErrors,exceedStandardDetectionAntibodyConjugationContainerErrors,exceedStandardCaptureAntibodyPurificationColumnErrors,exceedStandardDetectionAntibodyPurificationColumnErrors,invalidStandardCaptureAntibodyDilutionErrors,invalidStandardDetectionAntibodyDilutionErrors,nonOptimalStandardCaptureAntibodyDilutionWarnings,nonOptimalStandardDetectionAntibodyDilutionWarnings,standardUpperQuantitationLimits,standardCaptureAntibodyConjuationReactionVolumes,standardCaptureAntibodyConjugationContainerMaxVolumes,standardCaptureAntibodyPurificationColumnMaxVolumes,preferredStandardCaptureAntibodyPurificationColumns,standardDetectionAntibodyConjuationReactionVolumes,standardDetectionAntibodyConjugationContainerMaxVolumes,standardDetectionAntibodyPurificationColumnMaxVolumes,preferredStandardDetectionAntibodyPurificationColumns,
		incompleteResolvedSpikeConcentrationErrors,nonOptimalDilutionWarnings,conflictAntibodyEpitopeWarnings,captureAntibodyAssayTypeWarnings,detectionAntibodyAssayTypeWarnings,missingCaptureAntibodyErrors,missingDetectionAntibodyErrors,missingDigoxigeninReagentVolumeErrors,missingBiotinReagentVolumeErrors,notEnoughDigoxigeninReagentVolumeWarnings,notEnoughBiotinReagentVolumeWarnings,exceedCaptureAntibodyConjugationContainerErrors,exceedDetectionAntibodyConjugationContainerErrors,exceedCaptureAntibodyPurificationColumnErrors,exceedDetectionAntibodyPurificationColumnErrors,invalidCaptureAntibodyDilutionErrors,invalidDetectionAntibodyDilutionErrors,nonOptimalCaptureAntibodyDilutionWarnings,nonOptimalDetectionAntibodyDilutionWarnings,captureAntibodyConjuationReactionVolumes,captureAntibodyConjugationContainerMaxVolumes,captureAntibodyPurificationColumnMaxVolumes,preferredCaptureAntibodyPurificationColumns,detectionAntibodyConjuationReactionVolumes,detectionAntibodyConjugationContainerMaxVolumes,detectionAntibodyPurificationColumnMaxVolumes,preferredDetectionAntibodyPurificationColumns,

		(* Unresolvable Option Checks *)
		nonOptimalStandardResuspensionTests,incompleteResolvedStandardCompositionOption,incompleteResolvedStandardCompositionTests,nonOptimalStandardDiluentTests,conflictStandardAntibodyEpitopeTests,antibodyAssayTypeDisQualified,antibodyAssayTypeQualified,antibodyAssayTypeQualificationTests,missingStandardCaptureAntibodyOptions,missingStandardCaptureAntibodyTests,missingStandardDetectionAntibodyOptions,missingStandardDetectionAntibodyTests,missingStandardDigoxigeninReagentVolumeOptions,missingStandardDigoxigeninReagentVolumeTests,missingStandardBiotinReagentVolumeOptions,missingStandardBiotinReagentVolumeTests,notEnoughStandardDigoxigeninReagentVolumeTests,notEnoughStandardBiotinReagentVolumeTests,preferredStandardCaptureAntibodyConjugationContainers,exceedStandardCaptureAntibodyConjugationContainerOption,exceedStandardCaptureAntibodyConjugationContainerTests,preferredStandardDetectionAntibodyConjugationContainers,exceedStandardDetectionAntibodyConjugationContainerOption,exceedStandardDetectionAntibodyConjugationContainerTests,exceedStandardCaptureAntibodyPurificationColumnOption,exceedStandardCaptureAntibodyPurificationColumnTests,exceedStandardDetectionAntibodyPurificationColumnOption,exceedStandardDetectionAntibodyPurificationColumnTests,tooHighStandardCaptureAntibodyDilutionOption,tooHighStandardCaptureAntibodyDilutionTests,tooHighStandardDetectionAntibodyDilutionOption,tooHighStandardDetectionAntibodyDilutionTests,nonOptimalStandardCaptureAntibodyDilutionTests, nonOptimalStandardDetectionAntibodyDilutionTests,incompleteResolvedSpikeConcentrationOption,incompleteResolvedSpikeConcentrationTests,nonOptimalDilutionTests,conflictAntibodyEpitopeTests,missingCaptureAntibodyOptions,missingCaptureAntibodyTests,missingDetectionAntibodyOptions,missingDetectionAntibodyTests,missingDigoxigeninReagentVolumeOptions,missingDigoxigeninReagentVolumeTests,missingBiotinReagentVolumeOptions,missingBiotinReagentVolumeTests,notEnoughDigoxigeninReagentVolumeTests,notEnoughBiotinReagentVolumeTests,preferredCaptureAntibodyConjugationContainers,exceedCaptureAntibodyConjugationContainerOption,exceedCaptureAntibodyConjugationContainerTests,preferredDetectionAntibodyConjugationContainers,exceedDetectionAntibodyConjugationContainerOption,exceedDetectionAntibodyConjugationContainerTests,exceedCaptureAntibodyPurificationColumnOption,exceedCaptureAntibodyPurificationColumnTests,exceedDetectionAntibodyPurificationColumnOption,exceedDetectionAntibodyPurificationColumnTests,tooHighCaptureAntibodyDilutionOption,tooHighCaptureAntibodyDilutionTests,tooHighDetectionAntibodyDilutionOption,tooHighDetectionAntibodyDilutionTests,nonOptimalCaptureAntibodyDilutionTests,nonOptimalDetectionAntibodyDilutionTests,
      allSamples,allStorageConditions,allSamplesWithStorageConditions,uniqueSamplesWithStorageConditions,conflictSamplesWithStorageConditions,conflictSampleStorageOptions,conflictSampleStorageConditionTest,uniqueSamplesForContainerCheck,uniqueStorageConditionsForContainerCheck,validContainerStorageConditionResult,validContainerStorageConditionTests,invalidContainerStorageOptions,

        (* General Invalid Variables Tracker and Summary *)
        invalidInputs,invalidOptions,
		requiredSampleVolumes,targetContainers,
        resolvedAliquotOptions,aliquotTests,aliquotOptionsToBeRounded,aliquotPrecisions,roundedAliquotOptions,
		resolvedPostProcessingOptions,resolvedOptions,allOptions,allTests
    },

    (*-- SETUP OUR USER SPECIFIED OPTIONS AND CACHE --*)

    (* Determine the requested output format of this function. *)
    outputSpecification=OptionValue[Output];
    output=ToList[outputSpecification];

    (* Determine if we should keep a running list of tests to return to the user. *)
    gatherTests=MemberQ[output,Tests];

    (* When we are not gathering tests, we are supposed to throw error/warning messages *)
    messages=!gatherTests;

    (* Fetch our cache from the parent function. *)
    cache=Lookup[ToList[myResolutionOptions],Cache,{}];

    (* Separate out our CapillaryELISA options from our Sample Prep options. Since myOptions are expanded for index matching, the new capillaryELISAOptios and capillaryELISAOptionsAssocation are also expanded. *)
    {samplePrepOptions,capillaryELISAOptions}=splitPrepOptions[myOptions];

    (* Resolve our sample prep options *)
    {{simulatedSamples,resolvedSamplePrepOptions,simulatedCache},samplePrepTests}=If[gatherTests,
        resolveSamplePrepOptions[ExperimentCapillaryELISA,mySamples,samplePrepOptions,Cache->cache,Output->{Result,Tests}],
        {resolveSamplePrepOptions[ExperimentCapillaryELISA,mySamples,samplePrepOptions,Cache->cache,Output->Result],{}}
    ];

    (* Convert list of rules to Association so we can Lookup, Append, Join as usual. *)
    capillaryELISAOptionsAssociation=Association[capillaryELISAOptions];

	(* make a fast association to quickly pull stuff out of the simulated cache *)
	simulatedFastAssoc = makeFastAssocFromCache[simulatedCache];

    (* Extract the packets that we need from our downloaded cache. *)
    (* Remember to download from simulatedSamples, using our simulatedCache *)
    (* Quiet[Download[...,Cache->simulatedCache],Download::FieldDoesntExist] *)

    (* Note: Due to the speciality of ExperimentCapillaryELISA,
    Download part here first covers the cases for samplePackets and simulatedPackets.
    Then it comes with some other Download packets.
    For most cases, we need to resolve some options first and then we can decide what to download.
    For example, if we don't have cartridge options and analytes resolved, we don't know what to download for standard, antibody, etc.
    When we don't have capture antibody resolved, we don't really know what to download for capture antibody related options.
    These Download will not interact with option precision rounding either, as those will only affect quantity options.
    It should be fine to download later, from cache. *)

    (* An alternative method to Download from Cache - fetchPacketFromFastAssoc function - in shared Experiment Framework - to get information from cache *)
    (* Fetch simulated samples *)
    simulatedSamplePackets=Experiment`Private`fetchPacketFromFastAssoc[#,simulatedFastAssoc]&/@simulatedSamples;

    (* Get information about the containers of the simulated samples *)
    simulatedSampleContainers=Lookup[simulatedSamplePackets,Container];

    simulatedSampleContainerModels=Map[
      Experiment`Private`fastAssocLookup[simulatedFastAssoc,#, {Model,Object}]&,
      simulatedSampleContainers
    ];


    (* Extract downloaded mySamples packets *)
    samplePackets=Experiment`Private`fetchPacketFromFastAssoc[#,simulatedFastAssoc]&/@mySamples;

    (* Get information for the instrument and cartridge for option conflict checks *)
    (* If Instrument is specified by the user, download from cache *)
    suppliedInstrument=Lookup[capillaryELISAOptionsAssociation,Instrument];
    (* Fetch instrument object packet *)
    suppliedInstrumentPacket=If[MatchQ[suppliedInstrument,ObjectP[Object[Instrument,CapillaryELISA]]],
        Experiment`Private`fetchPacketFromFastAssoc[suppliedInstrument,simulatedFastAssoc],
        Null
    ];
    (* Fetch instrument model packet *)
    suppliedInstrumentModelPacket=Which[
        MatchQ[suppliedInstrument,ObjectP[Object[Instrument,CapillaryELISA]]],
        Experiment`Private`fetchPacketFromFastAssoc[Lookup[suppliedInstrumentPacket,Model],simulatedFastAssoc],
        MatchQ[suppliedInstrument,ObjectP[Model[Instrument,CapillaryELISA]]],
        Experiment`Private`fetchPacketFromFastAssoc[suppliedInstrument,simulatedFastAssoc],
        True,
        Null
    ];

    (* If Cartridge is specified by the user, download from the cache *)
    suppliedCartridge=Lookup[capillaryELISAOptionsAssociation,Cartridge];
    suppliedCartridgePacket=If[!MatchQ[suppliedCartridge,Automatic|Null],
		Experiment`Private`fetchPacketFromFastAssoc[suppliedCartridge, simulatedFastAssoc],
        <||>
    ];

    (* Get information for the analytes for option conflict checks *)
	suppliedAnalytes=Lookup[capillaryELISAOptionsAssociation,Analytes];

	(* Get our supplied customizable analytes. We only allow one analyte per sample. We will throw an error when it's longer than 1 but will resolve based on the first one provided. This is also the opportunity for us to turn the CapillaryELISAAnalyteP into the identity models without links for customizable cartridge *)
	(* A very special case here is that our option Analytes is not expanded correctly. This is because our option allows single value or a list. For example, with two samples {S1,S2}, Analytes->{A1,A2} can mean that both analytes should be tested for each individual sample or A1-S1 and A2-S2. The option expanding process will expand it to {{A1,A2},{A1,A2}} regardless. To make sure we don't throw unnecessary errors, we want to re-process the option. We only do this when the length of each list matches the length of samples. When user gives {A1,A2,A3} for {S1,S2}, we don't do anything here. An error will be thrown if we resolve to customizable cartridge for trying to measure more than 1 analyte. This may not be the perfect error as it can be an index matching error but should stop the user from submitting the protocol. *)
	processedSuppliedAnalytes=Which[
		(* Samples not equal to analytes *)
		Length[First[suppliedAnalytes]]!=Length[mySamples],
		suppliedAnalytes,

		(* each one element is not a list *)
		!MatchQ[suppliedAnalytes,{_List...}],
		suppliedAnalytes,

		(* different element in the option *)
		Length[DeleteDuplicates[suppliedAnalytes]]>1,
		suppliedAnalytes,

		(* Get only the 1st element *)
		True,First[suppliedAnalytes]

	];
    suppliedCustomizableAnalytes=Map[
		Which[
			MatchQ[#,Automatic],#,
			MatchQ[#,ObjectP[Model[Molecule]]],#,
			MatchQ[#,CapillaryELISAAnalyteP],
			Download[
				Lookup[
					FirstCase[
						simulatedCache,
						KeyValuePattern[{Type->Object[ManufacturingSpecification,CapillaryELISACartridge],AnalyteName->#}],
						<||>
					],
					AnalyteMolecule,
					Null
				],
				Object,
				Cache->simulatedCache
			],
			(* For the other cases, we get a list. Get its first member*)
			MatchQ[FirstOrDefault[#],ObjectP[Model[Molecule]]],First[#],
			MatchQ[FirstOrDefault[#],CapillaryELISAAnalyteP],
			Download[
				Lookup[
					FirstCase[
						simulatedCache,
						KeyValuePattern[{Type->Object[ManufacturingSpecification,CapillaryELISACartridge],AnalyteName->First[#]}],
						<||>
					],
					AnalyteMolecule,
					Null
				],
				Object,
				Cache->simulatedCache
			],
			True,Null
		]&,
		processedSuppliedAnalytes
	];

	(* Get our supplied potential pre-loaded analytes. We delete the cases of Automatic. If all members of the Analytes option is Automatic, we keep Automatic. This is the potential list, meaning that the molecules we get may not be pre-loaded analytes *)
	suppliedAnalytesNoDuplicates=FirstOrDefault[
		DeleteDuplicates[
			DeleteCases[
				suppliedAnalytes,
				Automatic
			]
		],
		Automatic
	];
	(* Get the analytes' manufacturing specifications *)
	(* Download all the manufacturing specifications for the specified analytes. The Analytes option has be expanded. If using a pre-loaded cartridge, all samples must be subject to the same analytes. *)
	suppliedAnalytesManufacturingSpecificationPackets=Which[
		MatchQ[ToList[suppliedAnalytesNoDuplicates],{CapillaryELISAAnalyteP...}],
		Map[
			DeleteDuplicates[
				Cases[
					simulatedCache,
					KeyValuePattern[{Type->Object[ManufacturingSpecification,CapillaryELISACartridge],AnalyteName->#}]
				]
			]&,
			ToList[suppliedAnalytesNoDuplicates]
		],
		MatchQ[ToList[suppliedAnalytesNoDuplicates],{ObjectP[Model[Molecule]]...}],
		Map[
			DeleteDuplicates[
				Cases[
					simulatedCache,
					KeyValuePattern[{Type->Object[ManufacturingSpecification,CapillaryELISACartridge],AnalyteMolecule->LinkP[#]}]
				]
			]&,
			ToList[suppliedAnalytesNoDuplicates]
		],
		True,
		{}
	];

	(* Pick the pre-loaded analytes from the supplied list - this can be either analyte names or molecules *)
	suppliedPreLoadedAnalytes=If[MatchQ[suppliedAnalytesNoDuplicates,Automatic],
		Automatic,
		PickList[ToList[suppliedAnalytesNoDuplicates],suppliedAnalytesManufacturingSpecificationPackets,Except[{}]]
	];

	(* We also want to get the identity models of the pre-loaded analytes - This is because we want to make sure there are no duplicates *)
	suppliedPreLoadedAnalyteMolecules=If[MatchQ[suppliedPreLoadedAnalytes,Automatic],
		Automatic,
		Map[
			If[MatchQ[#,CapillaryELISAAnalyteP],
				Download[
					Lookup[
						FirstCase[
							simulatedCache,
							KeyValuePattern[{Type->Object[ManufacturingSpecification,CapillaryELISACartridge],AnalyteName->#}],
							<||>
						],
						AnalyteMolecule,
						Null
					],
					(* Get rid of the link *)
					Object
				],
				(* Keep the existing identity model *)
				#
			]&,
			suppliedPreLoadedAnalytes
		]
	];


	(* Get the supplied SpikeSample packets for Model[Sample] or Object[Sample]. Spike is index matched to input samples so they must be a list. *)
	suppliedSpikeSample=Lookup[capillaryELISAOptionsAssociation,SpikeSample];
	suppliedSpikePackets=Experiment`Private`fetchPacketFromFastAssoc[#,simulatedFastAssoc]&/@suppliedSpikeSample;

	(* Get the supplied Diluent packets *)
	suppliedDiluent=Lookup[capillaryELISAOptionsAssociation,Diluent];
	suppliedDiluentPackets=Map[
		If[!MatchQ[#,Automatic|Null],
			Experiment`Private`fetchPacketFromFastAssoc[#,simulatedFastAssoc],
			<||>
		]&,
		ToList[suppliedDiluent]
	];
	suppliedDiluentModels=Map[
		Switch[Lookup[#,Object,Null],
			Null,Null,
			ObjectP[Model[Sample]],Lookup[#,Object],
			ObjectP[Object[Sample]],Lookup[#,Model,Null]
		]&,
		suppliedDiluentPackets
	];

	(* Get the supplied CaptureAntibody packets for Model[Sample] or Object[Sample] *)
	suppliedCustomCaptureAntibody=Lookup[capillaryELISAOptionsAssociation,CustomCaptureAntibody];
	suppliedCustomCaptureAntibodyPackets=Map[
		If[!MatchQ[#,Automatic|Null],
			Experiment`Private`fetchPacketFromFastAssoc[#,simulatedFastAssoc],
			<||>
		]&,
		ToList[suppliedCustomCaptureAntibody]
	];

	(* Get the supplied CaptureAntibodyPurificationColumn packets *)
	suppliedCaptureAntibodyPurificationColumn=Lookup[capillaryELISAOptionsAssociation,CaptureAntibodyPurificationColumn];
	suppliedCaptureAntibodyPurificationColumnPackets=Map[
		If[!MatchQ[#,Automatic|Null],
			Experiment`Private`fetchPacketFromFastAssoc[#,simulatedFastAssoc],
			<||>
		]&,
		ToList[suppliedCaptureAntibodyPurificationColumn]
	];

	(* Get the supplied CaptureAntibodyDiluent packets *)
	suppliedCaptureAntibodyDiluent=Lookup[capillaryELISAOptionsAssociation,CaptureAntibodyDiluent];
	suppliedCaptureAntibodyDiluentPackets=Map[
		If[!MatchQ[#,Automatic|Null],
			Experiment`Private`fetchPacketFromFastAssoc[#,simulatedFastAssoc],
			<||>
		]&,
		ToList[suppliedCaptureAntibodyDiluent]
	];
	suppliedCaptureAntibodyDiluentModels=Map[
		Switch[Lookup[#,Object,Null],
			Null,Null,
			ObjectP[Model[Sample]],Lookup[#,Object],
			ObjectP[Object[Sample]],Lookup[#,Model,Null]
		]&,
		suppliedCaptureAntibodyDiluentPackets
	];
	(* Get the supplied DetectionAntibody packets for Model[Sample] or Object[Sample] *)
	suppliedCustomDetectionAntibody=Lookup[capillaryELISAOptionsAssociation,CustomDetectionAntibody];
	suppliedCustomDetectionAntibodyPackets=Map[
		If[!MatchQ[#,Automatic|Null],
			Experiment`Private`fetchPacketFromFastAssoc[#,simulatedFastAssoc],
			<||>
		]&,
		ToList[suppliedCustomDetectionAntibody]
	];

	(* Get the supplied DetectionAntibodyPurificationColumn packets *)
	suppliedDetectionAntibodyPurificationColumn=Lookup[capillaryELISAOptionsAssociation,DetectionAntibodyPurificationColumn];
	suppliedDetectionAntibodyPurificationColumnPackets=Map[
		If[!MatchQ[#,Automatic|Null],
			Experiment`Private`fetchPacketFromFastAssoc[#,simulatedFastAssoc],
			<||>
		]&,
		ToList[suppliedDetectionAntibodyPurificationColumn]
	];

	(* Get the supplied DetectionAntibodyDiluent packets *)
	suppliedDetectionAntibodyDiluent=Lookup[capillaryELISAOptionsAssociation,DetectionAntibodyDiluent];
	suppliedDetectionAntibodyDiluentPackets=Map[
		If[!MatchQ[#,Automatic|Null|{}],
			Experiment`Private`fetchPacketFromFastAssoc[#,simulatedFastAssoc],
			<||>
		]&,
		ToList[suppliedDetectionAntibodyDiluent]
	];
	suppliedDetectionAntibodyDiluentModels=Map[
		Switch[Lookup[#,Object,Null],
			Null,Null,
			ObjectP[Model[Sample]],Lookup[#,Object],
			ObjectP[Object[Sample]],Lookup[#,Model,Null]
		]&,
		suppliedDetectionAntibodyDiluentPackets
	];

	(* Get information for the Standard samples for option conflict checks *)
    (* Get the supplied Standard packets for Model[Sample] or Object[Sample] *)
    suppliedStandard=Lookup[capillaryELISAOptionsAssociation,Standard];
    suppliedStandardPackets=If[MatchQ[suppliedStandard,Automatic|Null|{}],
		{},
        Experiment`Private`fetchPacketFromFastAssoc[#,simulatedFastAssoc]&/@ToList[suppliedStandard]
    ];

    (* Get the supplied StandardDiluent packets *)
    suppliedStandardDiluent=Lookup[capillaryELISAOptionsAssociation,StandardDiluent];
    suppliedStandardDiluentPackets=Map[
        If[!MatchQ[#,Automatic|Null],
            Experiment`Private`fetchPacketFromFastAssoc[#,simulatedFastAssoc],
            <||>
        ]&,
        ToList[suppliedStandardDiluent]
    ];
    suppliedStandardDiluentModels=Map[
        Switch[Lookup[#,Object,Null],
            Null,Null,
            ObjectP[Model[Sample]],Lookup[#,Object],
            ObjectP[Object[Sample]],Lookup[#,Model,Null]
        ]&,
        suppliedStandardDiluentPackets
    ];



    (* Get the supplied StandardCaptureAntibody packets for Model[Sample] or Object[Sample] *)
    suppliedStandardCaptureAntibody=Lookup[capillaryELISAOptionsAssociation,StandardCaptureAntibody];
    suppliedStandardCaptureAntibodyPackets=Map[
        If[!MatchQ[#,Automatic|Null],
            Experiment`Private`fetchPacketFromFastAssoc[#,simulatedFastAssoc],
            <||>
        ]&,
        ToList[suppliedStandardCaptureAntibody]
    ];

    (* Get the supplied StandardCaptureAntibodyPurificationColumn packets *)
    suppliedStandardCaptureAntibodyPurificationColumn=Lookup[capillaryELISAOptionsAssociation,StandardCaptureAntibodyPurificationColumn];
    suppliedStandardCaptureAntibodyPurificationColumnPackets=Map[
        If[!MatchQ[#,Automatic|Null],
            Experiment`Private`fetchPacketFromFastAssoc[#,simulatedFastAssoc],
            <||>
        ]&,
        ToList[suppliedStandardCaptureAntibodyPurificationColumn]
    ];


    (* Get the supplied StandardCaptureAntibodyDiluent packets *)
    suppliedStandardCaptureAntibodyDiluent=Lookup[capillaryELISAOptionsAssociation,StandardCaptureAntibodyDiluent];
    suppliedStandardCaptureAntibodyDiluentPackets=Map[
        If[!MatchQ[#,Automatic|Null],
            Experiment`Private`fetchPacketFromFastAssoc[#,simulatedFastAssoc],
            <||>
        ]&,
        ToList[suppliedStandardCaptureAntibodyDiluent]
    ];
    suppliedStandardCaptureAntibodyDiluentModels=Map[
        Switch[Lookup[#,Object,Null],
            Null,Null,
            ObjectP[Model[Sample]],Lookup[#,Object],
            ObjectP[Object[Sample]],Lookup[#,Model,Null]
        ]&,
        suppliedStandardCaptureAntibodyDiluentPackets
    ];

    (* Get the supplied StandardDetectionAntibody packets for Model[Sample] or Object[Sample] *)
    suppliedStandardDetectionAntibody=Lookup[capillaryELISAOptionsAssociation,StandardDetectionAntibody];
    suppliedStandardDetectionAntibodyPackets=Map[
        If[!MatchQ[#,Automatic|Null],
            Experiment`Private`fetchPacketFromFastAssoc[#,simulatedFastAssoc],
            <||>
        ]&,
        ToList[suppliedStandardDetectionAntibody]
    ];

    (* Get the supplied StandardDetectionAntibodyPurificationColumn packets *)
    suppliedStandardDetectionAntibodyPurificationColumn=Lookup[capillaryELISAOptionsAssociation,StandardDetectionAntibodyPurificationColumn];
    suppliedStandardDetectionAntibodyPurificationColumnPackets=Map[
      If[!MatchQ[#,Automatic|Null],
        Experiment`Private`fetchPacketFromFastAssoc[#,simulatedFastAssoc],
        <||>
      ]&,
      ToList[suppliedStandardDetectionAntibodyPurificationColumn]
    ];

    (* Get the supplied StandardDetectionAntibodyDiluent packets *)
    suppliedStandardDetectionAntibodyDiluent=Lookup[capillaryELISAOptionsAssociation,StandardDetectionAntibodyDiluent];
    suppliedStandardDetectionAntibodyDiluentPackets=Map[
        If[!MatchQ[#,Automatic|Null|{}],
            Experiment`Private`fetchPacketFromFastAssoc[#,simulatedFastAssoc],
            <||>
        ]&,
        ToList[suppliedStandardDetectionAntibodyDiluent]
    ];
    suppliedStandardDetectionAntibodyDiluentModels=Map[
        Switch[Lookup[#,Object,Null],
            Null,Null,
            ObjectP[Model[Sample]],Lookup[#,Object],
            ObjectP[Object[Sample]],Lookup[#,Model,Null]
        ]&,
        suppliedStandardDetectionAntibodyDiluentPackets
    ];
	
    (* Get the supplied WashBuffer packet *)
    suppliedWashBuffer=Lookup[capillaryELISAOptionsAssociation,WashBuffer];
    suppliedWashBufferPacket=Experiment`Private`fetchPacketFromFastAssoc[suppliedWashBuffer,simulatedFastAssoc];
    suppliedWashBufferModel=If[MatchQ[suppliedWashBuffer,ObjectP[Model[Sample]]],
        suppliedWashBuffer,
        Lookup[suppliedWashBufferPacket,Model,Null]
    ];

	(* Get the information about potential spin columns *)
	potentialSpinColumns=Search[Model[Container,Vessel,Filter],MembraneMaterial==ZebaDesaltingResin];
	potential40KSpinColumns=Search[Model[Container,Vessel,Filter],MembraneMaterial==ZebaDesaltingResin&&MolecularWeightCutoff==40000Dalton];
	potential40KSpinColumnPackets=Experiment`Private`fetchPacketFromFastAssoc[#,simulatedFastAssoc]&/@potential40KSpinColumns;
	(* Get the MaxVolume of the 40K spin column for resolver *)
	potential40KSpinColumnMaxVolumes=Lookup[potential40KSpinColumnPackets,{Object,MaxVolume}];
	(* Sort the spin columns by MaxVolume *)
	sorted40KSpinColumnsWithMaxVolumes=SortBy[potential40KSpinColumnMaxVolumes,Last];

    (* DEFINE OPTION CATEGORIES *)
    standardOptions={
		StandardResuspension,
		StandardResuspensionConcentration,
		StandardResuspensionDiluent,
		StandardStorageCondition,
		StandardDilutionCurve,
		StandardSerialDilutionCurve,
		StandardDiluent,
		StandardDilutionMixVolume,
		StandardDilutionNumberOfMixes,
		StandardDilutionMixRate,
		StandardCaptureAntibody,
		StandardCaptureAntibodyResuspension,
		StandardCaptureAntibodyResuspensionConcentration,
		StandardCaptureAntibodyResuspensionDiluent,
		StandardCaptureAntibodyStorageCondition,
		StandardCaptureAntibodyConjugation,
		StandardCaptureAntibodyVolume,
		StandardDigoxigeninReagent,
		StandardDigoxigeninReagentVolume,
		StandardCaptureAntibodyConjugationBuffer,
		StandardCaptureAntibodyConjugationBufferVolume,
		StandardCaptureAntibodyConjugationContainer,
		StandardCaptureAntibodyConjugationTime,
		StandardCaptureAntibodyConjugationTemperature,
		StandardCaptureAntibodyPurificationColumn,
		StandardCaptureAntibodyColumnWashBuffer,
		StandardCaptureAntibodyConjugationStorageCondition,
		StandardCaptureAntibodyDilution,
		StandardCaptureAntibodyTargetConcentration,
		StandardCaptureAntibodyDiluent,
		StandardDetectionAntibody,
		StandardDetectionAntibodyResuspension,
		StandardDetectionAntibodyResuspensionConcentration,
		StandardDetectionAntibodyResuspensionDiluent,
		StandardDetectionAntibodyStorageCondition,
		StandardDetectionAntibodyConjugation,
		StandardDetectionAntibodyVolume,
		StandardBiotinReagent,
		StandardBiotinReagentVolume,
		StandardDetectionAntibodyConjugationBuffer,
		StandardDetectionAntibodyConjugationBufferVolume,
		StandardDetectionAntibodyConjugationContainer,
		StandardDetectionAntibodyConjugationTime,
		StandardDetectionAntibodyConjugationTemperature,
		StandardDetectionAntibodyPurificationColumn,
		StandardDetectionAntibodyColumnWashBuffer,
		StandardDetectionAntibodyConjugationStorageCondition,
		StandardDetectionAntibodyDilution,
		StandardDetectionAntibodyTargetConcentration,
		StandardDetectionAntibodyDiluent,
		StandardLoadingVolume,
		StandardCaptureAntibodyLoadingVolume,
		StandardDetectionAntibodyLoadingVolume,
		StandardComposition
    };

    standardAntibodyOptions={
		StandardCaptureAntibody,
		StandardCaptureAntibodyResuspension,
		StandardCaptureAntibodyResuspensionConcentration,
		StandardCaptureAntibodyResuspensionDiluent,
		StandardCaptureAntibodyStorageCondition,
		StandardCaptureAntibodyConjugation,
		StandardCaptureAntibodyVolume,
		StandardDigoxigeninReagent,
		StandardDigoxigeninReagentVolume,
		StandardCaptureAntibodyConjugationBuffer,
		StandardCaptureAntibodyConjugationBufferVolume,
		StandardCaptureAntibodyConjugationContainer,
		StandardCaptureAntibodyConjugationTime,
		StandardCaptureAntibodyConjugationTemperature,
		StandardCaptureAntibodyPurificationColumn,
		StandardCaptureAntibodyColumnWashBuffer,
		StandardCaptureAntibodyConjugationStorageCondition,
		StandardCaptureAntibodyDilution,
		StandardCaptureAntibodyTargetConcentration,
		StandardCaptureAntibodyDiluent,
		StandardDetectionAntibody,
		StandardDetectionAntibodyResuspension,
		StandardDetectionAntibodyResuspensionConcentration,
		StandardDetectionAntibodyResuspensionDiluent,
		StandardDetectionAntibodyStorageCondition,
		StandardDetectionAntibodyConjugation,
		StandardDetectionAntibodyVolume,
		StandardBiotinReagent,
		StandardBiotinReagentVolume,
		StandardDetectionAntibodyConjugationBuffer,
		StandardDetectionAntibodyConjugationBufferVolume,
		StandardDetectionAntibodyConjugationContainer,
		StandardDetectionAntibodyConjugationTime,
		StandardDetectionAntibodyConjugationTemperature,
		StandardDetectionAntibodyPurificationColumn,
		StandardDetectionAntibodyColumnWashBuffer,
		StandardDetectionAntibodyConjugationStorageCondition,
		StandardDetectionAntibodyDilution,
		StandardDetectionAntibodyTargetConcentration,
		StandardDetectionAntibodyDiluent,
		StandardCaptureAntibodyLoadingVolume,
		StandardDetectionAntibodyLoadingVolume
    };

    antibodyOptions={
		CustomCaptureAntibody,
		CaptureAntibodyResuspension,
		CaptureAntibodyResuspensionConcentration,
		CaptureAntibodyResuspensionDiluent,
		CaptureAntibodyStorageCondition,
		CaptureAntibodyConjugation,
		CaptureAntibodyVolume,
		DigoxigeninReagent,
		DigoxigeninReagentVolume,
		CaptureAntibodyConjugationBuffer,
		CaptureAntibodyConjugationBufferVolume,
		CaptureAntibodyConjugationContainer,
		CaptureAntibodyConjugationTime,
		CaptureAntibodyConjugationTemperature,
		CaptureAntibodyPurificationColumn,
		CaptureAntibodyColumnWashBuffer,
		CaptureAntibodyConjugationStorageCondition,
		CaptureAntibodyDilution,
		CaptureAntibodyTargetConcentration,
		CaptureAntibodyDiluent,
		CustomDetectionAntibody,
		DetectionAntibodyResuspension,
		DetectionAntibodyResuspensionConcentration,
		DetectionAntibodyResuspensionDiluent,
		DetectionAntibodyStorageCondition,
		DetectionAntibodyConjugation,
		DetectionAntibodyVolume,
		BiotinReagent,
		BiotinReagentVolume,
		DetectionAntibodyConjugationBuffer,
		DetectionAntibodyConjugationBufferVolume,
		DetectionAntibodyConjugationContainer,
		DetectionAntibodyConjugationTime,
		DetectionAntibodyConjugationTemperature,
		DetectionAntibodyPurificationColumn,
		DetectionAntibodyColumnWashBuffer,
		DetectionAntibodyConjugationStorageCondition,
		DetectionAntibodyDilution,
		DetectionAntibodyTargetConcentration,
		DetectionAntibodyDiluent,
		CaptureAntibodyLoadingVolume,
		DetectionAntibodyLoadingVolume
    };

    spikeOptions={
        SpikeVolume,
        SpikeConcentration,
		SpikeSampleStorageCondition
	};


    (* If you have Warning:: messages, do NOT throw them when MatchQ[$ECLApplication,Engine]. Warnings should NOT be surfaced in engine. *)

    (*-- INPUT VALIDATION CHECKS --*)

    (* 1 - Discarded Sample Test *)
    (* Get the samples from mySamples that are discarded. *)
    discardedSamplePackets=Cases[Flatten[samplePackets],KeyValuePattern[Status->Discarded]];

    (* Set discardedInvalidInputs to the input objects whose statuses are Discarded *)
    discardedInvalidInputs=If[MatchQ[discardedSamplePackets,{}],
        {},
        Lookup[discardedSamplePackets,Object]
    ];

    (* If there are invalid inputs and we are throwing messages, throw an error message and keep track of the invalid inputs.*)
    If[Length[discardedInvalidInputs]>0&&messages,
        Message[Error::DiscardedSamples,ObjectToString[discardedInvalidInputs,Cache->simulatedCache]]
    ];

    (* If we are gathering tests, create a passing and/or failing test with the appropriate result. *)
    discardedTest=If[gatherTests,
        Module[{failingTest,passingTest},

            failingTest=If[Length[discardedInvalidInputs]==0,
                Nothing,
                Test["Our input samples "<>ObjectToString[discardedInvalidInputs,Cache->simulatedCache]<>" are not discarded:",True,False]
            ];

            passingTest=If[Length[discardedInvalidInputs]==Length[mySamples],
                Nothing,
                Test["Our input samples "<>ObjectToString[Complement[mySamples,discardedInvalidInputs],Cache->simulatedCache]<>" are not discarded:",True,True]
            ];

            {failingTest,passingTest}
        ],
        {}
    ];

	(* This is no longer needed as the liquid/solid check has been added to resolveAliquotOptions. Ann error will be thrown there and the input are added to Error::InvalidInputs *)
    (* 2 - Solid Sample Test *)
	(*
    (* Get the samples that are not liquids - the capillary ELISA cartridge cannot accept solid state samples *)
    nonLiquidSamplePackets=Map[
        If[!MatchQ[Lookup[#1,State],Alternatives[Liquid,Null]],
            #1,
            Nothing]&,
        simulatedSamplePackets
    ];

    (* Keep track of samples that are not liquid *)
    nonLiquidSampleInvalidInputs=If[MatchQ[nonLiquidSamplePackets,{}],
        {},
        Lookup[nonLiquidSamplePackets,Object]
    ];

    (* If there are invalid inputs and we are throwing messages,do so *)
    If[Length[nonLiquidSampleInvalidInputs]>0&&messages,
        Message[Error::NonCapillaryELISALiquidSample,ObjectToString[nonLiquidSampleInvalidInputs,Cache->simulatedCache]];
    ];

    (* If we are gathering tests, create a passing and/or failing test with the appropriate result. *)
    nonLiquidSampleTests=If[gatherTests,
        Module[{failingTest,passingTest},

            failingTest=If[Length[nonLiquidSampleInvalidInputs]==0,
                Nothing,
                Test["Our input samples "<>ObjectToString[nonLiquidSampleInvalidInputs,Cache->simulatedCache]<>" are not in solid state:",True,False]
            ];

            passingTest=If[Length[nonLiquidSampleInvalidInputs]==Length[mySamples],
                Nothing,
                Test["Our input samples "<>ObjectToString[Complement[mySamples,nonLiquidSampleInvalidInputs],Cache->simulatedCache]<>" are not in solid state:",True,True]
            ];

            {failingTest,passingTest}
        ],
        {}
    ];
    *)

    (* 3 - Total Number Of Sample Test *)
    (* Check to see whether the total number of mySamples is over 72 or not *)
    (* If there are more than 72 input samples, set all of the samples to tooManyInvalidInputs *)
	suppliedNumberOfReplicates=Lookup[capillaryELISAOptionsAssociation,NumberOfReplicates];
	(* Change Null to 1 for NumberOfReplicates *)
	intNumberOfReplicates=suppliedNumberOfReplicates/.{Null->1};
    tooManyInvalidInputs=If[(Length[simulatedSamples]*intNumberOfReplicates)>72,
        Lookup[Flatten[samplePackets],Object],
        {}
    ];
	tooManyInvalidOption=If[(Length[simulatedSamples]*intNumberOfReplicates)>72&&!NullQ[suppliedNumberOfReplicates],
		{NumberOfReplicates},
		{}
	];

    (* If there are too many input samples and we are throwing messages, throw an error message and keep track of the invalid inputs *)
    If[Length[tooManyInvalidInputs]>0&&messages,
        Message[Error::TooManyCapillaryELISAInputSamples]
    ];

    (* If we are gathering tests, create a passing and/or failing test for too many inputs with the appropriate result. *)
    tooManyInputsTests=If[gatherTests,
        Module[{failingTest,passingTest},
            passingTest=If[Length[tooManyInvalidInputs]==0,
                Test["There are 72 or fewer input samples (including NumberOfReplicates).",True,True],
                Nothing
            ];

            failingTest=If[Length[tooManyInvalidInputs]==Length[simulatedSamples],
                Test["There are 72 or fewer input samples in "<>ObjectToString[tooManyInvalidInputs,Cache->simulatedCache]<>" (including NumberOfReplicates).",True,False],
                Nothing
            ];

            {failingTest,passingTest}
        ],
        {}
    ];


    (* -- OPTION PRECISION CHECKS -- *)

    (* Before calling RoundOptionPrecision option to process majority of the options, the options with more than 1 field - lists of list after index matching must be processed separately. Meanwhile, some options may even have different patterns or a mixture of fields to be rounded or not. This is because RoundOptionPrecision option can only take a singleton or a list of singletons after index matching. *)

    (* Following the method from ExperimentHPLC - For all options with this problem, we find all the positions with different types of units (volume, unitless - for dilution ratio, concentration, etc..). Then we build associations for each unit type with completely flattened unit values. Then we rebuild the original option value formats with rounded units but ReplacePart-ing the rounded values at the original positions. *)

    (* Here we actually will generate tests/warning messages for each unit type in one option. This is reasonable as we will need to tell the user what to expect for the precision if they decide to look at the tests and error messages. *)

    (* The list of options that we need to process separately:
            -DilutionCurve;
            -SerialDilutionCurve;
            -CaptureAntibodyResuspensionConcentration;
            -CaptureAntibodyTargetConcentration;
            -DetectionAntibodyResuspensionConcentration;
            -DetectionAntibodyTargetConcentration;
            -StandardResuspensionConcentration;
            -StandardDilutionCurve;
            -StandardSerialDilutionCurve;
            -StandardCaptureAntibodyResuspensionConcentration;
            -StandardCaptureAntibodyTargetConcentration;
            -StandardDetectionAntibodyResuspensionConcentration;
            -StandardDetectionAntibodyTargetConcentration.
    *)
	
	(* Note that we don't care about the StandardComposition or SpikeConcentration precision as they are not used in any experimental operations. They will be used for data processing only. *)

    (* Get the unrounded values for all options above *)
	{unroundedDilutionCurve,unroundedSerialDilutionCurve,unroundedCaptureAntibodyResuspensionConcentration,unroundedCaptureAntibodyTargetConcentration,unroundedDetectionAntibodyResuspensionConcentration,unroundedDetectionAntibodyTargetConcentration,unroundedStandardResuspensionConcentration,unroundedStandardDilutionCurve,unroundedStandardSerialDilutionCurve,unroundedStandardCaptureAntibodyResuspensionConcentration,unroundedStandardCaptureAntibodyTargetConcentration,unroundedStandardDetectionAntibodyResuspensionConcentration,unroundedStandardDetectionAntibodyTargetConcentration}=Lookup[
        capillaryELISAOptionsAssociation,
        {DilutionCurve,SerialDilutionCurve,CaptureAntibodyResuspensionConcentration,CaptureAntibodyTargetConcentration,DetectionAntibodyResuspensionConcentration,DetectionAntibodyTargetConcentration,StandardResuspensionConcentration,StandardDilutionCurve,StandardSerialDilutionCurve,StandardCaptureAntibodyResuspensionConcentration,StandardCaptureAntibodyTargetConcentration,StandardDetectionAntibodyResuspensionConcentration,StandardDetectionAntibodyTargetConcentration}];

    (* Put options into different groups. We want to process the options in the same group together but don't want to process all options together due to the possible confusion. *)

	(* Dilution options *)
    (* StandardDilutionCurve and DilutionCurve may have volume values in Unit Microliter and dilution factor values without unit. The other possible option value is number of dilutions in dynamic dilution options. When we limit RangeP[0,1] for positions of dilution factor values, we may accidentally pick 1 number of dilution. We can get rid off the last member of the option as it is for NumberOfDilutions *)
    dilutionCurveOptions={DilutionCurve,StandardDilutionCurve};
    dilutionCurveValues={unroundedDilutionCurve,unroundedStandardDilutionCurve};

	(* The DilutionCurve option is already expanded so it's safe to do a map and get most of each member *)
	processedUnroundedDilutionCurve=Map[
		If[MatchQ[#,{GreaterP[0Microliter],{_,_},_Integer}],
			Most[#],
			#
		]&,
		unroundedDilutionCurve
	];

	(* The StandardDilutionCurve may not be expanded if Standard is not populated. Get rid of the NumberOfDilutions depending on the pattern of the unrounded option *)
	processedUnroundedStandardDilutionCurve=Which[
		MatchQ[unroundedStandardDilutionCurve,Automatic|Null],
		unroundedStandardDilutionCurve,
		MatchQ[unroundedStandardDilutionCurve,{GreaterP[0Microliter],{_,_},_Integer}],Most[unroundedStandardDilutionCurve],
		True,
		(* Case of expanded *)
		Map[
			If[MatchQ[#,{GreaterP[0Microliter],{_,_},_Integer}],
				Most[#],
				#
			]&,
			unroundedStandardDilutionCurve
		]
	];

	processedDilutionCurveValues={processedUnroundedDilutionCurve,processedUnroundedStandardDilutionCurve};

    (* Find all positions in the dilution curve related options where a volume value exists. Search through infinity to make sure we have all values included. *)
    dilutionCurveVolumeValuePositions=Map[
        Position[ToList[#],GreaterEqualP[0Microliter],Infinity,Heads->False]&,
		processedDilutionCurveValues
    ];
    (* Find all positions in the dilution curve related options where a dilution factor RangeP[0,1] value exists. Search through infinity to make sure we have all values included. *)
    dilutionCurveDilutionFactorValuePositions=Map[
        Position[ToList[#],RangeP[0,1],Infinity,Heads->False]&,
		processedDilutionCurveValues
    ];

    (* Build association with completely flattened volume values *)
    dilutionCurveVolumeValueAssociation=Association@MapThread[
        Function[{optionName,optionValue,indices},
            (optionName->(Extract[ToList[optionValue],#]&/@indices))
        ],
        {dilutionCurveOptions,dilutionCurveValues,dilutionCurveVolumeValuePositions}
    ];
    (* Build association with completely flattened dilution factor (unit-less) values *)
    dilutionCurveDilutionFactorValueAssociation=Association@MapThread[
        Function[{optionName,optionValue,indices},
            (optionName->(Extract[ToList[optionValue],#]&/@indices))
        ],
        {dilutionCurveOptions,dilutionCurveValues,dilutionCurveDilutionFactorValuePositions}
    ];

    (* Pass built volume and diluiton factor value association into RoundOptionPrecision to get processed. Gather tests if needed. *)
    {dilutionCurveVolumeRoundedAssociation,dilutionCurveVolumePrecisionTests}=If[gatherTests,
        RoundOptionPrecision[
            dilutionCurveVolumeValueAssociation,
            dilutionCurveOptions,
            ConstantArray[10^-1Microliter,Length[dilutionCurveOptions]],
            Output->{Result,Tests}
        ],
        {
            RoundOptionPrecision[
                dilutionCurveVolumeValueAssociation,
                dilutionCurveOptions,
                ConstantArray[10^-1Microliter,Length[dilutionCurveOptions]]
            ],
            {}
        }
    ];
    {dilutionCurveDilutionFactorRoundedAssociation,dilutionCurveDilutionFactorPrecisionTests}=If[gatherTests&&!MatchQ[Flatten[dilutionCurveDilutionFactorValuePositions],{}],
        RoundOptionPrecision[
            dilutionCurveDilutionFactorValueAssociation,
            dilutionCurveOptions,
            ConstantArray[10^-2,Length[dilutionCurveOptions]],
            Output->{Result,Tests}
        ],
        (* We don't generate tests for dilution factor precision when we don't have any dilution factor values in the option (even if gatherTests is True). This is quite possible. We do generate volume tests for any cases as volume is required in any option pattern. *)
        {
            RoundOptionPrecision[
                dilutionCurveDilutionFactorValueAssociation,
                dilutionCurveOptions,
                ConstantArray[10^-2,Length[dilutionCurveOptions]]
            ],
            {}
        }
    ];

    (* Rebuild the dilution curve options by replacing the flat rounded values at the positions they were originally found *)
    roundedDilutionCurveOptions=Association@MapThread[
        Function[{optionName,optionValue,volumePositions,dilutionFactorPositions},
            optionName->If[MatchQ[optionValue,_List],
                ReplacePart[
                    optionValue,
                    Join[
                        MapThread[
                            Rule,
                            {volumePositions,Lookup[dilutionCurveVolumeRoundedAssociation,optionName]}
                        ],
                        MapThread[
                            Rule,
                            {dilutionFactorPositions,Lookup[dilutionCurveDilutionFactorRoundedAssociation,optionName]}
                        ]
                    ]
                ],
                ReplacePart[
                    ToList[optionValue],
                    Join[
                        MapThread[
                            Rule,
                            {volumePositions,Lookup[dilutionCurveVolumeRoundedAssociation,optionName]}
                        ],
                        MapThread[
                            Rule,
                            {dilutionFactorPositions,Lookup[dilutionCurveDilutionFactorRoundedAssociation,optionName]}
                        ]
                    ]
                ][[1]]
            ]
        ],
        {dilutionCurveOptions,dilutionCurveValues,dilutionCurveVolumeValuePositions,dilutionCurveDilutionFactorValuePositions}
    ];


	(* StandardSerialDilutionCurve and SerialDilutionCurve may have volume values in Unit Microliter and dilution factor values without unit. The other possible option value is number of dilutions in serial dilution options. When we limit RangeP[0,1] for positions of dilution factor values, we may accidentally pick 1 number of dilution. When all serial dilution values for all samples are provided as {volume,volume,number}, this effect may generate an additional non-existing test about 10^-2 precision for number of dilutions. To avoid this, we must first process to extract all number of dilution values out. If we have any value that is provided as {volume,{dilution factor,number}} or {volume,{dilution factor..}}, we don't really worry about extracting values. Because in a case like that, 1 number of dilution should not affect any results. As for rounding, 1 will not get rounded to anything. As for error message, because no rounding happens, no error message should be thrown for this. As for test, a number of dilutions value must come with a dilution factor value. A test must have been generated for serial dilution curve 10^-2 precision. No additional test should be generated during this process. *)
    serialDilutionCurveOptions={SerialDilutionCurve,StandardSerialDilutionCurve};

	(* The SerialDilutionCurve option is already expanded so it's safe to do a map and get rid of NumberOfDilutions *)
    processedUnroundedSerialDilutionCurve=Map[
		If[MatchQ[#,{GreaterP[0Microliter],GreaterP[0Microliter],_Integer}],
			Most[#],
			#
		]&,
		unroundedSerialDilutionCurve
	];

	(* The StandardSerialDilutionCurve may not be expanded if Standard is not populated. If that is the case, we don't have to worry about the precision. *)
	processedUnroundedStandardSerialDilutionCurve=Which[
		MatchQ[unroundedStandardSerialDilutionCurve,Automatic|Null],
		unroundedStandardSerialDilutionCurve,
		MatchQ[unroundedStandardSerialDilutionCurve,{GreaterP[0Microliter],GreaterP[0Microliter],_Integer}],Most[unroundedStandardSerialDilutionCurve],
		True,
		Map[
			If[MatchQ[#,{GreaterP[0Microliter],GreaterP[0Microliter],_Integer}],
				Most[#],
				#
			]&,
			unroundedStandardSerialDilutionCurve
		]
	];

    serialDilutionCurveValues={processedUnroundedSerialDilutionCurve,processedUnroundedStandardSerialDilutionCurve};

    (* Find all positions in the serial dilution curve related options where a volume value exists. Search through infinity to make sure we have all values included. *)
    serialDilutionCurveVolumeValuePositions=Map[
        Position[ToList[#],GreaterEqualP[0Microliter],Infinity,Heads->False]&,
        serialDilutionCurveValues
    ];
    (* Find all positions in the dilution curve related options where a dilution factor Range[0,1] value exists. Search through infinity to make sure we have all values included. *)
    serialDilutionCurveDilutionFactorValuePositions=Map[
        Position[ToList[#],RangeP[0,1],Infinity,Heads->False]&,
        serialDilutionCurveValues
    ];

    (* Build association with completely flattened volume values *)
    serialDilutionCurveVolumeValueAssociation=Association@MapThread[
        Function[{optionName,optionValue,indices},
            (optionName->(Extract[ToList[optionValue],#]&/@indices))
        ],
        {serialDilutionCurveOptions,serialDilutionCurveValues,serialDilutionCurveVolumeValuePositions}
    ];
    (* Build association with completely flattened dilution factor (unit-less) values *)
    serialDilutionCurveDilutionFactorValueAssociation=Association@MapThread[
        Function[{optionName,optionValue,indices},
            (optionName->(Extract[ToList[optionValue],#]&/@indices))
        ],
        {serialDilutionCurveOptions,serialDilutionCurveValues,serialDilutionCurveDilutionFactorValuePositions}
    ];

    (* Pass built volume and diluiton factor value association into RoundOptionPrecision to get processed. Gather tests if needed. *)
    {serialDilutionCurveVolumeRoundedAssociation,serialDilutionCurveVolumePrecisionTests}=If[gatherTests,
        RoundOptionPrecision[
            serialDilutionCurveVolumeValueAssociation,
            serialDilutionCurveOptions,
            ConstantArray[10^-1Microliter,Length[serialDilutionCurveOptions]],
            Output->{Result,Tests}
        ],
        {
            RoundOptionPrecision[
                serialDilutionCurveVolumeValueAssociation,
                serialDilutionCurveOptions,
                ConstantArray[10^-1Microliter,Length[serialDilutionCurveOptions]]
            ],
            {}
        }
    ];
    {serialDilutionCurveDilutionFactorRoundedAssociation,serialDilutionCurveDilutionFactorPrecisionTests}=If[gatherTests&&!MatchQ[Flatten[serialDilutionCurveDilutionFactorValuePositions],{}],
        RoundOptionPrecision[
            serialDilutionCurveDilutionFactorValueAssociation,
            serialDilutionCurveOptions,
            ConstantArray[10^-2,Length[serialDilutionCurveOptions]],
            Output->{Result,Tests}
        ],
        (* We don't generate tests for dilution factor precision when we don't have any dilution factor values in the option (even if gatherTests is True). This is quite possible. We do generate volume tests for any cases as volume is required in any option pattern. *)
        {
            RoundOptionPrecision[
                serialDilutionCurveDilutionFactorValueAssociation,
                serialDilutionCurveOptions,
                ConstantArray[10^-2,Length[serialDilutionCurveOptions]]
            ],
            {}
        }
    ];

    (* Rebuild the serial dilution curve options by replacing the flat rounded values at the positions they were originally found int *)
    (* Note that we don't need to put the extracted number of dilution values back. This is because when we extracted the values, they are always the last in the sublist, it will not affect the positions of other values in the list. Here our ReplacePart is done directly to the original option value. *)
    roundedSerialDilutionCurveOptions=Association@MapThread[
        Function[{optionName,optionValue,volumePositions,dilutionFactorPositions},
            optionName->If[MatchQ[optionValue,_List],
                ReplacePart[
                    optionValue,
                    Join[
                        MapThread[
                            Rule,
                            {volumePositions,Lookup[serialDilutionCurveVolumeRoundedAssociation,optionName]}
                        ],
                        MapThread[
                            Rule,
                            {dilutionFactorPositions,Lookup[serialDilutionCurveDilutionFactorRoundedAssociation,optionName]}
                        ]
                    ]
                ],
                ReplacePart[
                    ToList[optionValue],
                    Join[
                        MapThread[
                            Rule,
                            {volumePositions,Lookup[serialDilutionCurveVolumeRoundedAssociation,optionName]}
                        ],
                        MapThread[
                            Rule,
                            {dilutionFactorPositions,Lookup[serialDilutionCurveDilutionFactorRoundedAssociation,optionName]}
                        ]
                    ]
                ][[1]]
            ]
        ],
        {serialDilutionCurveOptions,{unroundedSerialDilutionCurve,unroundedStandardSerialDilutionCurve},serialDilutionCurveVolumeValuePositions,serialDilutionCurveDilutionFactorValuePositions}
    ];

	(* Concentration Options *)
	(* Our concentration options allow different units - Molar or Milligram/Milliliter *)
	(* Here we don't have to care about whether Standard related options are in a list or not. We join all the option values together and they will be in a list anyway. *)
	concentrationOptions={CaptureAntibodyResuspensionConcentration,CaptureAntibodyTargetConcentration,DetectionAntibodyResuspensionConcentration,DetectionAntibodyTargetConcentration,StandardResuspensionConcentration,StandardCaptureAntibodyResuspensionConcentration,StandardCaptureAntibodyTargetConcentration,StandardDetectionAntibodyResuspensionConcentration,StandardDetectionAntibodyTargetConcentration};
	concentrationOptionValues={unroundedCaptureAntibodyResuspensionConcentration,unroundedCaptureAntibodyTargetConcentration,unroundedDetectionAntibodyResuspensionConcentration,unroundedDetectionAntibodyTargetConcentration,unroundedStandardResuspensionConcentration,unroundedStandardCaptureAntibodyResuspensionConcentration,unroundedStandardCaptureAntibodyTargetConcentration,unroundedStandardDetectionAntibodyResuspensionConcentration,unroundedStandardDetectionAntibodyTargetConcentration};

	(* Find all positions in the concentration related options where a Molar concentration value exists. Search through infinity to make sure we have all values included. *)
	molarValuePositions=Map[
		Position[ToList[#],GreaterEqualP[0Molar],Infinity,Heads->False]&,
		concentrationOptionValues
	];
	(* Find all positions in the concentration related options where a mass concentration value exists. Search through infinity to make sure we have all values included. *)
	massConcentrationValuePositions=Map[
		Position[ToList[#],GreaterEqualP[0Milligram/Milliliter],Infinity,Heads->False]&,
		concentrationOptionValues
	];

	(* Build association with completely flattened volume values *)
	molarValueAssociation=Association@MapThread[
		Function[{optionName,optionValue,indices},
			(optionName->(Extract[ToList[optionValue],#]&/@indices))
		],
		{concentrationOptions,concentrationOptionValues,molarValuePositions}
	];
	(* Build association with completely flattened dilution factor (unit-less) values *)
	massConcentrationValueAssociation=Association@MapThread[
		Function[{optionName,optionValue,indices},
			(optionName->(Extract[ToList[optionValue],#]&/@indices))
		],
		{concentrationOptions,concentrationOptionValues,massConcentrationValuePositions}
	];

	(* Pass built volume and diluiton factor value association into RoundOptionPrecision to get processed. Gather tests if needed. *)
	(* When we don't have molar/mass concentration values, we don't gather tests anyway. *)
	{molarRoundedAssociation,molarPrecisionTests}=If[gatherTests&&!MatchQ[Flatten[molarValuePositions],{}],
		RoundOptionPrecision[
			molarValueAssociation,
			concentrationOptions,
			ConstantArray[10^-9Molar,Length[concentrationOptions]],
			Output->{Result,Tests}
		],
		{
			RoundOptionPrecision[
				molarValueAssociation,
				concentrationOptions,
				ConstantArray[10^-9Molar,Length[concentrationOptions]]
			],
			{}
		}
	];
	{massConcentrationRoundedAssociation,massConcentrationPrecisionTests}=If[gatherTests&&!MatchQ[Flatten[massConcentrationValuePositions],{}],
		RoundOptionPrecision[
			massConcentrationValueAssociation,
			concentrationOptions,
			ConstantArray[10^-1Microgram/Milliliter,Length[concentrationOptions]],
			Output->{Result,Tests}
		],
		{
			RoundOptionPrecision[
				massConcentrationValueAssociation,
				concentrationOptions,
				ConstantArray[10^-1Microgram/Milliliter,Length[concentrationOptions]]
			],
			{}
		}
	];

	(* Rebuild the dilution curve options by replacing the flat rounded values at the positions they were originally found *)
	roundedConcentrationOptions=Association@MapThread[
		Function[{optionName,optionValue,molarPositions,massConcentrationPositions},
			optionName->If[MatchQ[optionValue,_List],
				ReplacePart[
					optionValue,
					Join[
						MapThread[
							Rule,
							{molarPositions,Lookup[molarRoundedAssociation,optionName]}
						],
						MapThread[
							Rule,
							{massConcentrationPositions,Lookup[massConcentrationRoundedAssociation,optionName]}
						]
					]
				],
				ReplacePart[
					ToList[optionValue],
					Join[
						MapThread[
							Rule,
							{molarPositions,Lookup[molarRoundedAssociation,optionName]}
						],
						MapThread[
							Rule,
							{massConcentrationPositions,Lookup[massConcentrationRoundedAssociation,optionName]}
						]
					]
				][[1]]
			]
		],
		{concentrationOptions,concentrationOptionValues,molarValuePositions,massConcentrationValuePositions}
	];

	(* Round other options in one RoundOptionPrecision call *)
    {
        roundedOtherCapillaryELISAOptions,
        otherPrecisionTests
    }=If[gatherTests,
        RoundOptionPrecision[
            capillaryELISAOptionsAssociation,
            {
				SampleVolume,SpikeVolume,DilutionMixVolume,DilutionMixRate,
				CaptureAntibodyVolume,DigoxigeninReagentVolume,CaptureAntibodyConjugationBufferVolume,CaptureAntibodyConjugationTime,CaptureAntibodyConjugationTemperature,
				DetectionAntibodyVolume,BiotinReagentVolume,DetectionAntibodyConjugationBufferVolume,DetectionAntibodyConjugationTime,DetectionAntibodyConjugationTemperature,
				StandardDilutionMixVolume,StandardDilutionMixRate,
				StandardCaptureAntibodyVolume,StandardDigoxigeninReagentVolume,StandardCaptureAntibodyConjugationBufferVolume,StandardCaptureAntibodyConjugationTime,StandardCaptureAntibodyConjugationTemperature,
				StandardDetectionAntibodyVolume,StandardBiotinReagentVolume,StandardDetectionAntibodyConjugationBufferVolume,StandardDetectionAntibodyConjugationTime,StandardDetectionAntibodyConjugationTemperature,
				LoadingVolume,CaptureAntibodyLoadingVolume,DetectionAntibodyLoadingVolume,StandardLoadingVolume,StandardCaptureAntibodyLoadingVolume,StandardDetectionAntibodyLoadingVolume
            },
			{
				10^-1Microliter, 10^-1Microliter, 10^-1Microliter, 10^-1Microliter / Second,
				10^-1Microliter, 10^-1Microliter, 10^-1Microliter, 1Second, 1Celsius,
				10^-1Microliter, 10^-1Microliter, 10^-1Microliter, 1Second, 1Celsius,
				10^-1Microliter, 10^-1Microliter / Second,
				10^-1Microliter, 10^-1Microliter, 10^-1Microliter, 1Second, 1Celsius,
				10^-1Microliter, 10^-1Microliter, 10^-1Microliter, 1Second, 1Celsius,
				10^-1Microliter, 10^-1Microliter, 10^-1Microliter, 10^-1Microliter, 10^-1Microliter, 10^-1Microliter
			},
            Output->{Result,Tests}
        ],
        {
            RoundOptionPrecision[
                capillaryELISAOptionsAssociation,
                {
					SampleVolume,SpikeVolume,DilutionMixVolume,DilutionMixRate,
					CaptureAntibodyVolume,DigoxigeninReagentVolume,CaptureAntibodyConjugationBufferVolume,CaptureAntibodyConjugationTime,CaptureAntibodyConjugationTemperature,
					DetectionAntibodyVolume,BiotinReagentVolume,DetectionAntibodyConjugationBufferVolume,DetectionAntibodyConjugationTime,DetectionAntibodyConjugationTemperature,
					StandardDilutionMixVolume,StandardDilutionMixRate,
					StandardCaptureAntibodyVolume,StandardDigoxigeninReagentVolume,StandardCaptureAntibodyConjugationBufferVolume,StandardCaptureAntibodyConjugationTime,StandardCaptureAntibodyConjugationTemperature,
					StandardDetectionAntibodyVolume,StandardBiotinReagentVolume,StandardDetectionAntibodyConjugationBufferVolume,StandardDetectionAntibodyConjugationTime,StandardDetectionAntibodyConjugationTemperature,
					LoadingVolume,CaptureAntibodyLoadingVolume,DetectionAntibodyLoadingVolume,StandardLoadingVolume,StandardCaptureAntibodyLoadingVolume,StandardDetectionAntibodyLoadingVolume
                },
                {
					10^-1Microliter, 10^-1Microliter, 10^-1Microliter, 10^-1Microliter / Second,
					10^-1Microliter, 10^-1Microliter, 10^-1Microliter, 1Second, 1Celsius,
					10^-1Microliter, 10^-1Microliter, 10^-1Microliter, 1Second, 1Celsius,
					10^-1Microliter, 10^-1Microliter / Second,
					10^-1Microliter, 10^-1Microliter, 10^-1Microliter, 1Second, 1Celsius,
					10^-1Microliter, 10^-1Microliter, 10^-1Microliter, 1Second, 1Celsius,
					10^-1Microliter, 10^-1Microliter, 10^-1Microliter, 10^-1Microliter, 10^-1Microliter, 10^-1Microliter
                }
            ],
            {}
        }
    ];

    (* Put all rounding results together. The new rounded values overwrite the old user-supllied values. *)
    roundedCapillaryELISAOptionsAssociation=Join[
        capillaryELISAOptionsAssociation,
        roundedOtherCapillaryELISAOptions,
        roundedConcentrationOptions,
        roundedDilutionCurveOptions,
		roundedSerialDilutionCurveOptions
    ];

    (* Put all tests together *)
    allRoundingTests=Join[
        dilutionCurveVolumePrecisionTests,
        dilutionCurveDilutionFactorPrecisionTests,
		serialDilutionCurveVolumePrecisionTests,
        serialDilutionCurveDilutionFactorPrecisionTests,
		molarPrecisionTests,
		massConcentrationPrecisionTests,
        otherPrecisionTests
    ];

    (* PREPARATION *)
    (* Set all non-index matched options to variables from rounded option association so that they can be referred to easily later. This only applies to the options that we didn't download earlier in Download part. *)
    {
		suppliedCartridgeType,suppliedSpecies,
		suppliedSampleVolume,suppliedSpikeVolume,suppliedSpikeSampleStorageCondition,suppliedDilutionCurve,suppliedSerialDilutionCurve,suppliedDiluent,suppliedDilutionMixVolume,suppliedDilutionNumberOfMixes,suppliedDilutionMixRate,
		suppliedCaptureAntibodyResuspension,suppliedCaptureAntibodyResuspensionConcentration,suppliedCaptureAntibodyResuspensionDiluent,suppliedCaptureAntibodyStorageCondition,suppliedCaptureAntibodyConjugation,suppliedCaptureAntibodyVolume,suppliedDigoxigeninReagent,suppliedDigoxigeninReagentVolume,suppliedCaptureAntibodyConjugationBuffer,suppliedCaptureAntibodyConjugationBufferVolume,suppliedCaptureAntibodyConjugationContainer,suppliedCaptureAntibodyConjugationTime,suppliedCaptureAntibodyConjugationTemperature,suppliedCaptureAntibodyColumnWashBuffer,suppliedCaptureAntibodyConjugationStorageCondition,suppliedCaptureAntibodyDilution,suppliedCaptureAntibodyTargetConcentration,
		suppliedDetectionAntibodyResuspension,suppliedDetectionAntibodyResuspensionConcentration,suppliedDetectionAntibodyResuspensionDiluent,suppliedDetectionAntibodyStorageCondition,suppliedDetectionAntibodyConjugation,suppliedDetectionAntibodyVolume,suppliedBiotinReagent,suppliedBiotinReagentVolume,suppliedDetectionAntibodyConjugationBuffer,suppliedDetectionAntibodyConjugationBufferVolume,suppliedDetectionAntibodyConjugationContainer,suppliedDetectionAntibodyConjugationTime,suppliedDetectionAntibodyConjugationTemperature,suppliedDetectionAntibodyColumnWashBuffer,suppliedDetectionAntibodyConjugationStorageCondition,suppliedDetectionAntibodyDilution,suppliedDetectionAntibodyTargetConcentration,
		suppliedStandardResuspension,suppliedStandardResuspensionConcentration,suppliedStandardResuspensionDiluent,suppliedStandardStorageCondition,suppliedStandardDilutionCurve,suppliedStandardSerialDilutionCurve,suppliedStandardDilutionMixVolume,suppliedStandardDilutionNumberOfMixes,suppliedStandardDilutionMixRate,
		suppliedStandardCaptureAntibodyResuspension,suppliedStandardCaptureAntibodyResuspensionConcentration,suppliedStandardCaptureAntibodyResuspensionDiluent,suppliedStandardCaptureAntibodyStorageCondition,suppliedStandardCaptureAntibodyConjugation,suppliedStandardCaptureAntibodyVolume,suppliedStandardDigoxigeninReagent,suppliedStandardDigoxigeninReagentVolume,suppliedStandardCaptureAntibodyConjugationBuffer,suppliedStandardCaptureAntibodyConjugationBufferVolume,suppliedStandardCaptureAntibodyConjugationContainer,suppliedStandardCaptureAntibodyConjugationTime,suppliedStandardCaptureAntibodyConjugationTemperature,suppliedStandardCaptureAntibodyColumnWashBuffer,suppliedStandardCaptureAntibodyConjugationStorageCondition,suppliedStandardCaptureAntibodyDilution,suppliedStandardCaptureAntibodyTargetConcentration,
		suppliedStandardDetectionAntibodyResuspension,suppliedStandardDetectionAntibodyResuspensionConcentration,suppliedStandardDetectionAntibodyResuspensionDiluent,suppliedStandardDetectionAntibodyStorageCondition,suppliedStandardDetectionAntibodyConjugation,suppliedStandardDetectionAntibodyVolume,suppliedStandardBiotinReagent,suppliedStandardBiotinReagentVolume,suppliedStandardDetectionAntibodyConjugationBuffer,suppliedStandardDetectionAntibodyConjugationBufferVolume,suppliedStandardDetectionAntibodyConjugationContainer,suppliedStandardDetectionAntibodyConjugationTime,suppliedStandardDetectionAntibodyConjugationTemperature,suppliedStandardDetectionAntibodyColumnWashBuffer,suppliedStandardDetectionAntibodyConjugationStorageCondition,suppliedStandardDetectionAntibodyDilution,suppliedStandardDetectionAntibodyTargetConcentration,
		suppliedLoadingVolume,suppliedCaptureAntibodyLoadingVolume,suppliedDetectionAntibodyLoadingVolume,suppliedStandardLoadingVolume,suppliedStandardCaptureAntibodyLoadingVolume,suppliedStandardDetectionAntibodyLoadingVolume,
		suppliedStandardComposition,suppliedSpikeConcentration
    }=Lookup[roundedCapillaryELISAOptionsAssociation,
        {
			CartridgeType,Species,
			SampleVolume,SpikeVolume,SpikeSampleStorageCondition,DilutionCurve,SerialDilutionCurve,Diluent,DilutionMixVolume,DilutionNumberOfMixes,DilutionMixRate,
			CaptureAntibodyResuspension,CaptureAntibodyResuspensionConcentration,CaptureAntibodyResuspensionDiluent,CaptureAntibodyStorageCondition,CaptureAntibodyConjugation,CaptureAntibodyVolume,DigoxigeninReagent,DigoxigeninReagentVolume,CaptureAntibodyConjugationBuffer,CaptureAntibodyConjugationBufferVolume,CaptureAntibodyConjugationContainer,CaptureAntibodyConjugationTime,CaptureAntibodyConjugationTemperature,CaptureAntibodyColumnWashBuffer,CaptureAntibodyConjugationStorageCondition,CaptureAntibodyDilution,CaptureAntibodyTargetConcentration,
			DetectionAntibodyResuspension,DetectionAntibodyResuspensionConcentration,DetectionAntibodyResuspensionDiluent,DetectionAntibodyStorageCondition,DetectionAntibodyConjugation,DetectionAntibodyVolume,BiotinReagent,BiotinReagentVolume,DetectionAntibodyConjugationBuffer,DetectionAntibodyConjugationBufferVolume,DetectionAntibodyConjugationContainer,DetectionAntibodyConjugationTime,DetectionAntibodyConjugationTemperature,DetectionAntibodyColumnWashBuffer,DetectionAntibodyConjugationStorageCondition,DetectionAntibodyDilution,DetectionAntibodyTargetConcentration,
			StandardResuspension,StandardResuspensionConcentration,StandardResuspensionDiluent,StandardStorageCondition,StandardDilutionCurve,StandardSerialDilutionCurve,StandardDilutionMixVolume,StandardDilutionNumberOfMixes,StandardDilutionMixRate,
			StandardCaptureAntibodyResuspension,StandardCaptureAntibodyResuspensionConcentration,StandardCaptureAntibodyResuspensionDiluent,StandardCaptureAntibodyStorageCondition,StandardCaptureAntibodyConjugation,StandardCaptureAntibodyVolume,StandardDigoxigeninReagent,StandardDigoxigeninReagentVolume,StandardCaptureAntibodyConjugationBuffer,StandardCaptureAntibodyConjugationBufferVolume,StandardCaptureAntibodyConjugationContainer,StandardCaptureAntibodyConjugationTime,StandardCaptureAntibodyConjugationTemperature,StandardCaptureAntibodyColumnWashBuffer,StandardCaptureAntibodyConjugationStorageCondition,StandardCaptureAntibodyDilution,StandardCaptureAntibodyTargetConcentration,
			StandardDetectionAntibodyResuspension,StandardDetectionAntibodyResuspensionConcentration,StandardDetectionAntibodyResuspensionDiluent,StandardDetectionAntibodyStorageCondition,StandardDetectionAntibodyConjugation,StandardDetectionAntibodyVolume,StandardBiotinReagent,StandardBiotinReagentVolume,StandardDetectionAntibodyConjugationBuffer,StandardDetectionAntibodyConjugationBufferVolume,StandardDetectionAntibodyConjugationContainer,StandardDetectionAntibodyConjugationTime,StandardDetectionAntibodyConjugationTemperature,StandardDetectionAntibodyColumnWashBuffer,StandardDetectionAntibodyConjugationStorageCondition,StandardDetectionAntibodyDilution,StandardDetectionAntibodyTargetConcentration,
			LoadingVolume,CaptureAntibodyLoadingVolume,DetectionAntibodyLoadingVolume,StandardLoadingVolume,StandardCaptureAntibodyLoadingVolume,StandardDetectionAntibodyLoadingVolume,
			StandardComposition,SpikeConcentration
        }
    ];

    
    (* Set resolved options for NON-AUTOMATIC options. These options are returned to the user directly after resolver. *)
    {
        resolvedInstrument,
		resolvedSpecies,
        resolvedSpikeSample,
		resolvedSpikeSampleStorageCondition,
        resolvedDilutionNumberOfMixes,
        resolvedDilutionMixRate,
        resolvedWashBuffer,
		resolvedLoadingVolume,
		resolvedNumberOfReplicates
    }={
		suppliedInstrument,
		suppliedSpecies,
		suppliedSpikeSample,
		suppliedSpikeSampleStorageCondition,
		suppliedDilutionNumberOfMixes,
		suppliedDilutionMixRate,
		suppliedWashBuffer,
		suppliedLoadingVolume,
		suppliedNumberOfReplicates
    };
    (* Shared Options *)
    {
		resolvedCache,
		resolvedFastTrack,
		resolvedTemplate,
		resolvedParentProtocol,
		resolvedOperator,
        resolvedConfirm,
		resolvedName,
		resolvedUpload,
		resolvedOutput,
        resolvedSamplesInStorageCondition,
		resolvedPreparatoryPrimitives
    }=Lookup[roundedCapillaryELISAOptionsAssociation,
        {
			Cache,
			FastTrack,
			Template,
			ParentProtocol,
			Operator,
			Confirm,
			Name,
			Upload,
			Output,
			SamplesInStorageCondition,
			PreparatoryUnitOperations
        }
    ];


    (*-- CONFLICTING OPTIONS CHECKS --*)

    (* 1 Name Check *)
    (* If the specified Name is not in the database, it is valid. *)
    validNameQ=If[MatchQ[Lookup[roundedCapillaryELISAOptionsAssociation,Name],_String],
        !DatabaseMemberQ[Object[Protocol,CapillaryELISA,Lookup[roundedCapillaryELISAOptionsAssociation,Name]]],
        True
    ];

    (* If name option is invalid and we are throwing messages, throw an error message and keep track of our invalid options for Error::InvalidOptions. *)
    nameInvalidOption=If[!validNameQ&&messages,
        Message[Error::DuplicateName,Object[Protocol,CapillaryELISA]];
        {Name},
		{}
    ];

    (* Generate Test for Name check *)
    validNameTest=If[gatherTests,
        Test["If specified, Name is not already a Capillary ELISA protocol name:",validNameQ,True],
        {}
    ];


    (* 2 Instrument Check *)
    (* Check for the instrument's status and model instrument's deprecation *)
    notRetiredInstrumentQ=Or[
        NullQ[suppliedInstrumentPacket],
        !MatchQ[Lookup[suppliedInstrumentPacket,Status],Retired]
    ];
    notDeprecatedInstrumentQ=Or[
        NullQ[suppliedInstrumentModelPacket],
        !TrueQ[Lookup[suppliedInstrumentModelPacket,Deprecated]]
    ];

    (* Keep track of invalid instrument option and return error message if we need to do so *)
    instrumentInvalidOption=Which[
        !notRetiredInstrumentQ&&!notDeprecatedInstrumentQ&&messages,Message[Error::RetiredCapillaryELISAInstrument,ObjectToString[suppliedInstrument,Cache->simulatedCache]];Message[Error::DeprecatedCapillaryELISAInstrumentModel,ObjectToString[Lookup[suppliedInstrumentModelPacket,Object]]];{Instrument},
        !notRetiredInstrumentQ&&messages,Message[Error::RetiredCapillaryELISAInstrument,ObjectToString[suppliedInstrument,Cache->simulatedCache]];{Instrument},
        !notDeprecatedInstrumentQ&&messages,Message[Error::DeprecatedCapillaryELISAInstrumentModel,ObjectToString[Lookup[suppliedInstrumentModelPacket,Object]]];{Instrument},
        True,{}
    ];

    (* If we need to gather tests, generate the tests for instrument checks *)
    notRetiredInstrumentTests=If[gatherTests,
        Test["If specified, Instrument is not retired:",notRetiredInstrumentQ,True],
        {}
    ];
    notDeprecatedInstrumentTests=If[gatherTests,
        Test["Instrument model is not deprecated:",notDeprecatedInstrumentQ,True],
        {}
    ];


    (* 3 Cartridge Check *)
    (* The specified Cartridge cannot be discarded *)
    discardedCartridgeInvalidOption=If[MatchQ[Lookup[suppliedCartridgePacket,Status,Null],Discarded]&&messages,
        Message[Error::DiscardedCapillaryELISACartridge,ObjectToString[Lookup[suppliedCartridgePacket,Object],Cache->simulatedCache]];{Cartridge},
        {}
    ];

    (* If we need to gather tests, generate the tests for cartridge check *)
    discardedCartridgeInvalidTest=If[gatherTests,
        Module[{passingTest,failingTest},
            passingTest=If[MatchQ[discardedCartridgeInvalidOption,{}],
                Test["If specified, Cartridge is not discarded:",True,True],
                Nothing
            ];
            failingTest=If[!MatchQ[discardedCartridgeInvalidOption,{}],
                Test["If specified, Cartridge is not discarded:",True,False],
                Nothing
            ];
            {passingTest,failingTest}
        ],
        {}
    ];

    (* 4 Loading Sample Number Check *)
    (* Get the total number of samples, considering all dilutions and all provided standard samples - If Standard is automatic, we don't put it in here. We assume no Standard when it is automatic. A message is thrown later if we need Standard for the protocol but cannot fit the samples in. *)
    (* Here we don't need to worry about the collapsed index matching options as our input for resolver is expandedSafeOps. We also do not need to worry about the standard sample is not a list. In our main function, we added a step to turn Standard and Analytes into list as index matching parent. *)

    totalNumberOfSamples=Total[
        Join[

            (* Count the number of standard samples if not Null *)
            If[!MatchQ[suppliedStandard,Null|{}|Automatic],

                (* Repeat for every standard sample *)
                MapThread[

                    (* call helper function to figure out the number of samples with default 5 dilutions for a standard sample *)
                    resolveDilutedSampleNumber[#1,#2,5]&,
                    {suppliedStandardDilutionCurve,suppliedStandardSerialDilutionCurve}
                ],

                (* give 0 if no standard sample *)
                {0}
            ],

            (* Repeat for every simulated sample *)
            MapThread[

                (* call helper function to figure out the number of samples with default 1 dilution for an input sample *)
				(resolveDilutedSampleNumber[#1,#2,1]*intNumberOfReplicates)&,
                {suppliedDilutionCurve,suppliedSerialDilutionCurve}
            ]
        ]
    ];

    (* The total number of samples cannot be over 72 *)
	(* We turn off this Error when there are too many input samples to avoid giving duplicated messages *)
    tooManyLoadingSamplesOptions=If[TrueQ[totalNumberOfSamples>72]&&!TrueQ[Length[tooManyInvalidInputs]>0]&&messages,
        Message[Error::TooManyLoadingSamplesForCapillaryELISA];{Standard,DilutionCurve,SerialDilutionCurve},
        {}
    ];

    (* If we need to gather tests, generate the tests for the total number of samples check *)
    tooManyLoadingSamplesTests=If[gatherTests,
        Module[{passingTest,failingTest},
            passingTest=If[TrueQ[totalNumberOfSamples<=72],
                Test["The total number of loading samples (including standards and all dilutions) is less than or equal to 72:",True,True],
                Nothing
            ];
            failingTest=If[TrueQ[totalNumberOfSamples>72],
                Test["The total number of loading samples (including standards and all dilutions) is less than or equal to 72:",True,False],
                Nothing
            ];
            {passingTest,failingTest}
        ],
        {}
    ];

    (* Check whether the total number of samples is over the limit of the specified cartridge *)
    (* Get the total number of samples allowed in the cartridge and also keep the option name where the number is from *)
    cartridgeSamplesCapacity=Which[
        (*If Cartridge is specified, go with the maximum number of cartridge. We will throw an error later if CartridgeType option is also specified and not in accordance with Cartridge *)
        !MatchQ[suppliedCartridge,Automatic|Null],{Lookup[suppliedCartridgePacket,MaxNumberOfSamples],Cartridge},

        (* If CartridgeType is specified, go with the maximum number of CartridgeType *)
        !MatchQ[suppliedCartridgeType,Automatic|Null],{Last[cartridgeCapacity[suppliedCartridgeType]],CartridgeType},

        (* Otherwise just go with Infinity. We have already thrown an error above if the number of samples is over 72. We will throw an error later if both Cartridge and CartridgeType are set to Null *)
        True,{Infinity,Null}
    ];

    (* The total number of samples cannot be over the capacity of the specified Cartridge or CartridgeType *)
	(* We turn off this error when total number of samples is over 72 to avoid giving too many errors *)
    exceedCartridgeCapacityOption=If[TrueQ[totalNumberOfSamples<=72]&&TrueQ[totalNumberOfSamples>cartridgeSamplesCapacity[[1]]]&&messages,
        Message[Error::ExceedCapillaryELISACartridgeCapacity,ToString[cartridgeSamplesCapacity[[2]]]];
        {cartridgeSamplesCapacity[[2]]},
        {}
    ];

    (* If we need to gather tests, generate the tests for the total number of samples exceeding cartridge capacity check *)
    exceedCartridgeCapacityTests=If[gatherTests,
        Module[{passingTest,failingTest},
            passingTest=If[MatchQ[exceedCartridgeCapacityOption,{}],
                Test["The total number of loading samples (including standards and all dilutions) is less than or equal to the capacity of the cartridge or cartridge type:",True,True],
                Nothing
            ];
            failingTest=If[!MatchQ[exceedCartridgeCapacityOption,{}],
                Test["The total number of loading samples (including standards and all dilutions) is less than or equal to the capacity of the cartridge or cartridge type:",True,False],
                Nothing
            ];
            {passingTest,failingTest}
        ],
        {}
    ];


    (* 5 Cartridge and Cartridge related options Conflict Checks *)
    (* CartridgeType cannot be Customizable if Cartridge is Null *)
    invalidCustomizableCartridgeTypeOptions=If[MatchQ[{suppliedCartridge,suppliedCartridgeType},{Null,Customizable}]&&messages,
        Message[Error::CannotCreateNewCustomizableCartridge];
        {Cartridge,CartridgeType},
        {}
    ];

    (* If we need to gather tests, generate tests for customizable cartridge type when cartridge is set to Null *)
    invalidCustomizableCartridgeTypeTests=If[gatherTests,
        Module[{passingTest,failingTest},
            passingTest=If[MatchQ[invalidCustomizableCartridgeTypeOptions,{}],
                Test["If Cartridge is set to Null, CartridgeType cannot be set to Customizable as we cannot create a new customizable cartridge:",True,True],
                Nothing
            ];
            failingTest=If[!MatchQ[invalidCustomizableCartridgeTypeOptions,{}],
                Test["If Cartridge is set to Null, CartridgeType cannot be set to Customizable as we cannot create a new customizable cartridge:",True,False],
                Nothing
            ];
            {passingTest,failingTest}
        ],
        {}
    ];

    (* Cartridge and Cartridge related options - CartridgeType and Analytes must be in accordance for a pre-loaded cartridge *)
    (* Get the cartridge type of the specified cartridge *)
    suppliedCartridgeTypeFromCartridge=Lookup[suppliedCartridgePacket,CartridgeType,Null];

	(* Check CartridgeType *)
    conflictCartridgeTypeQ=If[!MatchQ[suppliedCartridge,Null|Automatic],
		MatchQ[suppliedCartridgeType,suppliedCartridgeTypeFromCartridge|Automatic],
        True
    ];

    (* Throw an error message if cartridge related options are not in accordance with the specified cartridge *)
    conflictCartridgeTypeOptions=If[!conflictCartridgeTypeQ,
        Message[Error::ConflictCartridgeAndCartridgeType];
		{Cartridge,CartridgeType},
        {}
    ];

    (* If we need to gather tests, generate tests for conflicting Cartridge related options *)
    conflictCartridgeTypeTests=If[gatherTests,
		Test["If Cartridge is set to a Model[Container,Plate,Irregular,CapillaryELISA] or an Object[Container,Plate,Irregular,CapillaryELISA], CartridgeType is in accordance with the Cartridge option:",conflictCartridgeTypeQ,True],
        {}
    ];

	(* Check Analytes *)
	(* This is a little complicated. We are checking only the specified Analytes for the first sample to make things easier. *)
	(* Get the AnalyteNames and AnalyteMolecules from suppliedCartridge *)
	suppliedAnalyteNamesFromCartridge=Lookup[suppliedCartridgePacket,AnalyteNames,Null];
	suppliedAnalyteMoleculesFromCartridge=Lookup[suppliedCartridgePacket,AnalyteMolecules,Null];

	(* Generate our checkings *)
	conflictCartridgeAndAnalytesQ=If[MatchQ[suppliedPreLoadedAnalytes,Automatic]||MatchQ[suppliedCartridgeTypeFromCartridge,Customizable]||MatchQ[suppliedCartridge,Automatic|Null],
		True,
		Or@@{
			MatchQ[ToList[suppliedPreLoadedAnalytes],suppliedAnalyteNamesFromCartridge],
			MatchQ[ToList[suppliedPreLoadedAnalytes],suppliedAnalyteMoleculesFromCartridge]
		}
	];

	(* Throw an error message if cartridge related options are not in accordance with the specified cartridge *)
	conflictCartridgeAndAnalytesOptions=If[!conflictCartridgeAndAnalytesQ,
		Message[Error::ConflictCartridgeAndAnalytes];
		{Cartridge,Analytes},
		{}
	];

	(* If we need to gather tests, generate tests for conflicting Cartridge related options *)
	conflictCartridgeAndAnalytesTests=If[gatherTests,
		Test["If Cartridge is set to a pre-loaded Model[Container,Plate,Irregular,CapillaryELISA] or an Object[Container,Plate,Irregular,CapillaryELISA], Analytes is in accordance with the Cartridge option:",conflictCartridgeAndAnalytesQ,True],
		{}
	];

	(* Another thing we should check is that if we have a cartridge that is not customizable, we should have all the Analytes the same or Automatic *)
	(* We want to simplify the process - we allow the user to input either CapillaryELISAAnalyteP or the identity model. If they mix/match through all the input samples with some of them putting in identity models and some putting in the pattern strings, we still throw error message. *)
	(* We can check whether the supplied pre-loaded analytes has a length of 1 or 0 for Automatic *)

	conflictPreLoadedAnalytesQ=Which[
		(* If Cartridge is Customizable, there is no conflict *)
		MatchQ[suppliedCartridgeTypeFromCartridge,Customizable]||MatchQ[suppliedCartridgeType,Customizable],
		False,
		(* If it's automatic and there are fewer than 48 samples, we can resolve to Customizable cartridge later *)
		MatchQ[suppliedCartridge,Automatic]&&totalNumberOfSamples<=48,
		False,
		True,
		TrueQ[Length[DeleteCases[DeleteDuplicates[ToList[#]&/@suppliedAnalytes],{Automatic}]]>1]
	];

	(* Throw an error message if we have conflicting Analytes *)
	conflictPreLoadedAnalytesOptions=If[conflictPreLoadedAnalytesQ,
		Message[Error::ConflictPreLoadedAnalytes];
		{Analytes},
		{}
	];

	(* If we need to gather tests, generate tests for conflicting Analytes *)
	conflictPreLoadedAnalytesTests=If[gatherTests,
		Test["All samples must be subject to the same analyates in a capillary ELISA experiment using a pre-loaded capillary ELISA cartridge:",conflictPreLoadedAnalytesQ,False],
		{}
	];


    (* SPECIAL STEP: Here we want to get Cartridge option resolved first. Cartridge option is very important in the experiment and used to check a lot of conflicts. To avoid missing some conflicts, we can resolve it first *)
    (* -- RESOLVE THE MASTER SWITCH OF OPTION Cartridge -- *)
    (* 1 - get the total number of samples, considering all dilutions and all standard samples. This is already done as totalNumberOfSamples from option conflict check *)

    (* 2 - get the ELISA analytes from the input samples, one packet for the pre-loaded cartridge and one packet for the customizable cartridge - the customizable packet is not used to determine the cartridge but used for the selection of antibodies instead, which happens later *)
    {preLoadedAnalytes,customizableAnalytes}=selectCapillaryELISAAnalyteFromSample[simulatedSamples,Cache->simulatedCache];

    (* 3 - rank the pre-loaded cartridge analytes from all input samples from the most to the least. Get the corresponding manufacturing specifications *)
    rankedPreLoadedAnalytes=ReverseSortBy[Tally[preLoadedAnalytes],Last][[All,1]];
    rankedPreLoadedAnalytesManufacturingSpecifications=Map[
        DeleteDuplicates[
            Cases[
                simulatedCache,
                KeyValuePattern[{Type->Object[ManufacturingSpecification,CapillaryELISACartridge],AnalyteMolecule->LinkP[#]}]
            ]
        ]&,
        rankedPreLoadedAnalytes
    ];

    (* 4 - resolve Cartridge option based on the information provided *)
    resolvedCartridge=Which[

		MatchQ[suppliedCartridge,Except[Automatic]],
        (* If Cartridge is set by the user, go with the user-selected cartridge *)
        suppliedCartridge,

        (* If we have different analyte members for different samples and fewer than 48 samples, we just choose the customizable cartridge. No need to resolve *)
		(* There may be cases that they actually want to do multiplex but our processedSuppliedAnalytes makes it the wrong way. This is really rare and the user can specify the cartridge type *)
		(* Every member in the processed analytes must be a single analyte to work with customizable cartridge *)
		(And@@Map[Length[ToList[#]]==1&,processedSuppliedAnalytes])&&TrueQ[Length[DeleteDuplicates[processedSuppliedAnalytes]]>1]&&totalNumberOfSamples<=48&&MatchQ[suppliedCartridgeType,Automatic|Customizable],
      Model[Container, Plate, Irregular, CapillaryELISA, "id:3em6ZvLneGBW"], (* Model[Container,Plate,Irregular,CapillaryELISA,"Human 48-Digoxigenin Cartridge"] *)

        (* If Cartridge is not set by the user, call helper function resolveCapillaryELISACartridge with the ranked pre-loaded cartridge analyte list, the number of samples and the user-supplied options *)
        True,
        resolveCapillaryELISACartridge[rankedPreLoadedAnalytes,totalNumberOfSamples,suppliedCartridgeType,suppliedPreLoadedAnalyteMolecules]
    ];

    resolvedCartridgePacket=Experiment`Private`fetchPacketFromFastAssoc[resolvedCartridge,simulatedFastAssoc];

    (* Throw warning messages if we get a pre-loaded cartridge that is not in stock *)
    longLeadTimeCartridgeQ=If[!MatchQ[$ECLApplication,Engine],
        Which[
            (* When we don't have a cartridge and the cartridge type is not set to customizable, we need to throw a warning *)
            MatchQ[resolvedCartridge,Null]&&!MatchQ[suppliedCartridgeType,Customizable],Message[Warning::LongLeadTimeCartridge];True,

            (* When we have a null cartridge but a customizable type, we already throw a message earlier. We can assume it is customizable cartridge from now on *)
            MatchQ[resolvedCartridge,Null]&&MatchQ[suppliedCartridgeType,Customizable],False,

            (* When we get a cartridge object, there is no leading time. It can be discarded and an error message was thrown earlier *)
            MatchQ[resolvedCartridgePacket,ObjectP[Object[Container,Plate,Irregular,CapillaryELISA]]],False,
            MatchQ[Lookup[resolvedCartridgePacket,CartridgeType,Null],Customizable],False,
            (* When we get a model, check to see whether we have any Available or Stocked cartridge *)
            MatchQ[resolvedCartridgePacket,ObjectP[Model[Container,Plate,Irregular,CapillaryELISA]]]&&MemberQ[resolvedCartridgePacketObjectsStates,Available|Stocked],False,
            True,Message[Warning::LongLeadTimeCartridge];True
        ]
    ];

    (* make tests for LongLeadTimeCartridge warning if we need to do so *)
    longLeadTimeCartridgeTests=If[gatherTests,
        Test["The cartridge is a pre-loaded cartridge that is not in stock at ECL and may take 14 days to arrive:",longLeadTimeCartridgeQ,False],
        Nothing
    ];

    (* set a boolean to easily check whether we have a customizable cartridge *)
    resolvedCustomizableCartridgeQ=Which[
        MatchQ[resolvedCartridge,Null]&&!MatchQ[suppliedCartridgeType,Customizable],False,
        MatchQ[resolvedCartridge,Null]&&MatchQ[suppliedCartridgeType,Customizable],True,
        True,MatchQ[Lookup[resolvedCartridgePacket,CartridgeType,Null],Customizable]
    ];

    (* resolve CartridgeType *)
    resolvedCartridgeType=Which[

        (* keep user-defined value *)
        !MatchQ[suppliedCartridgeType,Automatic],suppliedCartridgeType,

        (* If resolvedCartridge is not Null, set to its CartridgeType *)
        !MatchQ[resolvedCartridge,Null],Lookup[resolvedCartridgePacket,CartridgeType],

        (* If more than 4 analytes are selected, go with MultiPlex32X8 *)
        TrueQ[Length[suppliedPreLoadedAnalyteMolecules]>4],MultiPlex32X8,

        (* If more than 1 analytes are selected, go with MultiAnalyte32X4 *)
        TrueQ[Length[suppliedPreLoadedAnalyteMolecules]>1],MultiAnalyte32X4,

        (* Go with SinglePlex72X1 for other cases *)
        True,SinglePlex72X1
    ];


    (*-- Back to CONFLICT CHECK --*)
	(* If we have a customizable cartridge, it cannot be used for multiplex assays. Only 1 analyte can be tested per sample *)
	exceedLengthAnalytesQ=If[resolvedCustomizableCartridgeQ,
		Map[
			TrueQ[Length[ToList[#]]>1]&,
			processedSuppliedAnalytes
		],
		ConstantArray[False,Length[mySamples]]
	];

	exceedLengthAnalytesSamples=PickList[mySamples,exceedLengthAnalytesQ];

	(* Throw an error message if we have conflicting Analytes *)
	exceedLengthAnalytesOptions=If[MemberQ[exceedLengthAnalytesQ,True],
		Message[Error::ExceedLengthAnalytesForCustomizableCartridge,ObjectToString[exceedLengthAnalytesSamples,Cache->simulatedCache]];
		{Analytes},
		{}
	];

	(* If we need to gather tests, generate tests for conflicting Analytes *)
	exceedLengthAnalytesTests=If[gatherTests&&resolvedCustomizableCartridgeQ,
		Module[{failingTest,passingTest},
			failingTest=If[!MemberQ[exceedLengthAnalytesQ,True],
				Nothing,
				Test["In a customizable cartridge, only 1 analyte can be tested for the samples "<>ObjectToString[exceedLengthAnalytesSamples,Cache->simulatedCache]<>" in a capillary ELISA experiment:",True,False]
			];
			passingTest=If[!MemberQ[exceedLengthAnalytesQ,False],
				Nothing,
				Test["In a customizable cartridge, only 1 analyte can be tested for the samples "<>ObjectToString[PickList[mySamples,exceedLengthAnalytesQ,False],Cache->simulatedCache]<>" in a capillary ELISA experiment:",True,True]
			];
			{failingTest,passingTest}
		],
		{}
	];

    (* CartridgeType cannot be MultiPlex32X8 if Species is not Human. MultiPlex32X8 is for Pro-Inflammation and Oncology panel only. *)
    conflictMultiPlexCartridgeTypeOptions=If[MatchQ[{resolvedCartridgeType,suppliedSpecies},{MultiPlex32X8,Except[Human]}]&&messages,
        Message[Error::CannotUseMultiPlex32X8CartridgeForNonHuman];
        {CartridgeType,Species},
        {}
    ];

    (* If we need to gather tests, generate tests for selecting non-human species for MultiPlex32X8 cartridge *)
    conflictMultiPlexCartridgeTypeTests=If[gatherTests,
        Module[{passingTest,failingTest},
            passingTest=If[MatchQ[conflictMultiPlexCartridgeTypeOptions,{}],
                Test["If Species is not set to Human, CartridgeType cannot be set to MultiPlex32X8:",True,True],
                Nothing
            ];
            failingTest=If[!MatchQ[conflictMultiPlexCartridgeTypeOptions,{}],
                Test["If Species is not set to Human, CartridgeType cannot be set to MultiPlex32X8:",True,False],
                Nothing
            ];
            {passingTest,failingTest}
        ],
        {}
    ];

    (* 6 Analytes Check *)
	(* For pre-loaded analytes! *)
    (* Analytes should not have duplicated members. This also works for Null or Automatic as they will not be affected by DeleteDuplicates *)
    (* Find the duplicated members in the Analytes option. We check the identity models as even different generation assays are available for a certain analyte, they cannot be combined. *)
    duplicatedAnalyteIdentityModels=If[!MatchQ[suppliedPreLoadedAnalyteMolecules,Automatic]&&!resolvedCustomizableCartridgeQ&&!MatchQ[resolvedCartridgeType,Customizable],
        DeleteDuplicates[Select[ToList[suppliedPreLoadedAnalyteMolecules],Count[ToList[suppliedPreLoadedAnalyteMolecules],#]>1&]],
        {}
    ];

	(* Keep the supplied Analyte Molecules or turn into Analyte Names *)
	duplicatedAnalytes=PickList[ToList[suppliedPreLoadedAnalytes],ToList[suppliedPreLoadedAnalyteMolecules],Alternatives@@duplicatedAnalyteIdentityModels];

    (* If we have duplicated members, throw error message. *)
    duplicatedAnalytesOption=If[!MatchQ[duplicatedAnalytes,{}]&&messages,
        Message[Error::DuplicatedAnalytes,ObjectToString[duplicatedAnalytes,Cache->simulatedCache]];{Analytes},
        {}
    ];

    (* If we need to gather tests, generate tests for duplicated analytes *)
    duplicatedAnalytesTests=If[gatherTests,
        Test["The specified Analytes for a pre-loaded capillary ELISA cartridge do not have duplicated members:",MatchQ[duplicatedAnalytes,{}],True],
        {}
    ];

    (* The total number of analytes must be smaller than the capacity of the specified CartridgeType. We do this for the Analytes option when Cartridge is Null and CartridgeType is specified, after duplicates are taken out to avoid giving the user too many error messages. *)
	totalNumberOfPreLoadedAnalytes=Length[DeleteDuplicates[ToList[suppliedPreLoadedAnalyteMolecules]]];
	recommendedCartridgeType=Which[
		totalNumberOfPreLoadedAnalytes>4,MultiPlex32X8,
		totalNumberOfPreLoadedAnalytes>1,MultiAnalyte32X4,
		True,Null
	];

    tooManyAnalytesOption=Which[
        !MatchQ[resolvedCartridge,Null],{},

        (* Compare with the analytes capacity of the specified CartridgeType. This is not a problem with suppliedPreLoadedAnalytes set to Automatic as its length would be 1. *)
		(* Longer than 8 *)
		TrueQ[totalNumberOfPreLoadedAnalytes>8]&&messages,
		Message[Error::TooManyAnalytes,8,"any pre-loaded capillary ELISA cartridge type","Please select fewer analytes to continue."];{Analytes},

        TrueQ[totalNumberOfPreLoadedAnalytes>First[cartridgeCapacity[resolvedCartridgeType]]]&&messages,
        Message[Error::TooManyAnalytes,ToString[First[cartridgeCapacity[resolvedCartridgeType]]],"the specified CartridgeType option","Please select fewer analytes or select a cartridge type with higher capacity (for example, "<>ToString[recommendedCartridgeType]<>") to continue."];{Analytes},
        True,{}
    ];

    (* If we need to gather tests, generate tests for too many analytes *)
    tooManyAnalytesTests=If[gatherTests,
        Test["The number of the specified Analytes option is no more than the total allowed number of the specified CartridgeType:",MatchQ[tooManyAnalytesOption,{}],True],
        {}
    ];

    (* When we have Cartridge set to Null, CartridgeType set to Automatic, we will resolve to MultiPlex32X8 or MultiAnalyte32X4 for more than 1 analyte. However, when the total number of samples is over 32, we cannot accept more than 1 analyte. This is because a MultiPlex or MultiAnalyte cartridge cannot do more than 32 samples. *)
    tooManyAnalytesForSampleNumberQ=If[MatchQ[resolvedCartridge,Null]&&MatchQ[resolvedCartridgeType,MultiAnalyte32X4|MultiPlex32X8],
        TrueQ[totalNumberOfSamples>32],
        False
    ];

    (* Get tooManyAnalytesForSampleNumberOption *)
    tooManyAnalytesForSampleNumberOption=If[tooManyAnalytesForSampleNumberQ&&messages,
        Message[Error::TooManyAnalytesForSampleNumber];{Analytes},
        {}
    ];

    (* If we need to gather tests, generate tests for too many analytes for the total sample number *)
    tooManyAnalytesForSampleNumberTests=If[gatherTests,
        Test["The total number of the samples must be less than or equal to 48 for a customizable cartridge or 32 for a pre-loaded multi-analyte cartridge, in order to test more than 1 analyte in the protocol:",tooManyAnalytesForSampleNumberQ,False],
        {}
    ];

    (* The specified analytes in Analytes option must be supported by the pre-loaded cartridges *)
    (* Check with the global variable preLoadedCartridgeAnalytes to find a list of unsupported analytes *)
    unsupportedAnalytes=Which[
        (* No need to check when Cartridge is Customizable *)
        !MatchQ[resolvedCartridge,Null],{},
        (* Just in case user selects customizable cartridge while setting cartridge to Null. An error is thrown earlier. *)
        MatchQ[resolvedCartridgeType,Customizable],{},
        (* If the analytes are provided as CapillaryELISAAnalyteP, they are definitely supported. We don't worry about turning the identity models back to CapillaryELISAAnalyteP here. *)
        MatchQ[suppliedAnalytesNoDuplicates,ListableP[ObjectP[Model[Molecule]]]],
        DeleteCases[ToList[suppliedAnalytesNoDuplicates],ObjectP[findPreLoadedCartridgeAnalytes[Cache->simulatedCache]]],
        True,{}
    ];
    supportedAnalytes=Which[
        (* No need to check when Cartridge is Customizable *)
        !MatchQ[resolvedCartridge,Null],{},
        (* Just in case user selects customizable cartridge while setting cartridge to Null. An error is thrown earlier. *)
        MatchQ[resolvedCartridgeType,Customizable],{},
		MatchQ[suppliedPreLoadedAnalytes,ListableP[CapillaryELISAAnalyteP]],
		suppliedPreLoadedAnalytes,
		MatchQ[suppliedPreLoadedAnalytes,Automatic],
		{},
		True,
        Complement[ToList[suppliedPreLoadedAnalytes],unsupportedAnalytes]
    ];

    unsupportedAnalytesOption=Which[
        !MatchQ[resolvedCartridge,Null],{},
        (* Just in case user selects customizable cartridge while setting cartridge to Null. An error is thrown earlier. *)
        MatchQ[resolvedCartridgeType,Customizable],{},
        MatchQ[suppliedPreLoadedAnalytes,Automatic],{},
        !MatchQ[unsupportedAnalytes,{}]&&messages,
        Message[Error::UnsupportedAnalytes,ObjectToString[unsupportedAnalytes,Cache->simulatedCache]];{Analytes},
        True,{}
    ];

    (* If we need to gather tests, generate tests for unsupported analytes *)
    unsupportedAnalytesTests=If[gatherTests,
        Module[{passingTest,failingTest},
            passingTest=Which[
				MatchQ[suppliedPreLoadedAnalytes,Automatic]||!MatchQ[resolvedCartridge,Null]||MatchQ[resolvedCartridgeType,Customizable],
				Test["The specified Analytes are supported by the assay developer for pre-loaded capillary ELISA cartridges:",True,True],
				Length[supportedAnalytes]==0,
                Nothing,
				True,
                Test["The specified Analytes "<>ObjectToString[supportedAnalytes,Cache->simulatedCache]<>" are supported by the assay developer for pre-loaded capillary ELISA cartridges:",True,True]
            ];
            failingTest=If[Length[unsupportedAnalytes]==0,
                Nothing,
                Test["The specified Analytes "<>ObjectToString[unsupportedAnalytes,Cache->simulatedCache]<>" are supported by the assay developer for pre-loaded capillary ELISA cartridges:",True,False]
            ];
            {passingTest,failingTest}
        ],
        {}
    ];

    (* The specified analytes must be in accordance with the specified Species. *)
    (* Find the species of each analyte through their manufacturing specifications *)
    analyteSpecies=Map[
        Lookup[#,Species]&,
        suppliedAnalytesManufacturingSpecificationPackets,
		{2}
    ];

    (* Check the Species of each analyte *)
    wrongAnalytesSpeciesQ=Map[
		If[MatchQ[#,{}],
			(* We can avoid checking unsupported analytes *)
			True,
			MemberQ[#,suppliedSpecies]
		]&,
		analyteSpecies
	];

    (* Get the wrong species analytes out of the manufacturing specifications - either as CapillaryELISAAnalyteP or the identity models *)
    wrongSpeciesAnalytes=If[!MatchQ[suppliedPreLoadedAnalytes,Automatic|{}]&&MatchQ[resolvedCartridge,Null]&&!MatchQ[resolvedCartridgeType,Customizable],
		PickList[ToList[suppliedAnalytesNoDuplicates],wrongAnalytesSpeciesQ,False],
        {}
    ];

    (* Track the invalid options and throw messages if we have wrong species analytes *)
    wrongSpeciesAnalytesOption=Which[
        (* No need to check when Cartridge is Customizable *)
        !MatchQ[resolvedCartridge,Null],{},
        (* Just in case user selects customizable cartridge while setting cartridge to Null. An error is thrown earlier. *)
        MatchQ[resolvedCartridgeType,Customizable],{},
        MatchQ[suppliedSpecies,Automatic],{},
        MatchQ[suppliedAnalytes,{Automatic..}],{},

        !MatchQ[wrongSpeciesAnalytes,{}]&&messages,
        Message[Error::AnalytesSpeciesUnavailable,ObjectToString[wrongSpeciesAnalytes,Cache->simulatedCache]];{Analytes,Species},
        True,{}
    ];

    (* If we need to gather tests, generate tests for wrong species analytes *)
    wrongSpeciesAnalytesTests=If[gatherTests,
        Module[{passingTest,failingTest},
            passingTest=Which[
                MatchQ[suppliedPreLoadedAnalytes,Automatic]||!MatchQ[resolvedCartridge,Null]||MatchQ[resolvedCartridgeType,Customizable],
                Test["The specified Analytes are in accordance with the specified Species:",True,True],
                MatchQ[Complement[suppliedPreLoadedAnalytes,wrongSpeciesAnalytes],{}],
                Nothing,
                True,
                Test["The specified Analytes "<>ObjectToString[Complement[suppliedPreLoadedAnalytes,wrongSpeciesAnalytes],Cache->simulatedCache]<>" are in accordance with the specified Species:",True,True]
            ];
            failingTest=If[MatchQ[wrongSpeciesAnalytes,{}],
                Nothing,
                Test["The specified Analytes "<>ObjectToString[wrongSpeciesAnalytes,Cache->simulatedCache]<>" are in accordance with the specified Species:",True,False]
            ];
            {passingTest,failingTest}
        ],
        {}
    ];

    (* The specified analytes must be in Pro-Inflammation and Oncology panel to be used with MultiPlex32X8 cartridge *)
    (* Find the supported CartridgeType for each analyte, considering all the possible cases if available *)
	analyteCartridgeTypes=Map[
        Lookup[#,CartridgeType,{}]&,
		suppliedAnalytesManufacturingSpecificationPackets,
        {2}
    ];

    (* Check whether each analyte can be used with MultiPlex32X8 cartridge type *)
    analyteMultiPlexQ=If[!MatchQ[analyteCartridgeTypes,{}|{{}}],
        Map[
            If[MatchQ[#,{}],
				(* We can avoid checking unsupported analytes *)
				True,
				MemberQ[Flatten[#],MultiPlex32X8]
			]&,
            analyteCartridgeTypes
        ],
        {}
    ];

    (* Get a list of wrong cartridge type analytes *)
    wrongCartridgeTypeAnalytes=If[!MatchQ[suppliedPreLoadedAnalytes,Automatic|{}]&&MatchQ[resolvedCartridge,Null]&&!MatchQ[resolvedCartridgeType,Customizable],
        PickList[ToList[suppliedAnalytesNoDuplicates],analyteMultiPlexQ,False],
        {}
    ];

    (* Find whether each specified member of Analytes can be used with MultiPlex32X8 cartridge type *)
    wrongCartridgeTypeAnalytesOption=Which[
        !MatchQ[resolvedCartridge,Null],{},

        (* Check this when MultiPlex32X8 is selected *)
        MemberQ[analyteMultiPlexQ,False]&&MatchQ[resolvedCartridgeType,MultiPlex32X8]&&messages,
        Message[Error::AnalytesIncompatibleWithCartridgeType,ObjectToString[wrongCartridgeTypeAnalytes,Cache->simulatedCache]];{Analytes},

        True,{}
    ];

    (* If we need to gather tests, generate tests for wrong cartridge type analytes *)
    wrongCartridgeTypeAnalytesTests=If[gatherTests,
        Module[{passingTest,failingTest},
            passingTest=Which[
                MatchQ[suppliedAnalytes,{Automatic..}]||!MatchQ[resolvedCartridge,Null]||MatchQ[resolvedCartridgeType,Customizable],
                Test["The specified Analytes are available for MultiPlex32X8 cartridge:",True,True],
                MatchQ[Complement[suppliedAnalytesNoDuplicates,wrongCartridgeTypeAnalytes],{}],
                Nothing,
                True,
                Test["The specified Analytes "<>ObjectToString[Complement[suppliedAnalytesNoDuplicates,wrongCartridgeTypeAnalytes],Cache->simulatedCache]<>" are available for MultiPlex32X8 cartridge:",True,True]
            ];
            failingTest=If[MatchQ[wrongCartridgeTypeAnalytes,{}],
                Nothing,
                Test["The specified Analytes "<>ObjectToString[wrongCartridgeTypeAnalytes,Cache->simulatedCache]<>" are available for MultiPlex32X8 cartridge:",True,False]
            ];
            {passingTest,failingTest}
        ],
        {}
    ];

    (* Find whether the specified members of Analytes are incompatible with each other. This is a large project as we have to check Diluent, MinDilutionFactor and also special IncompatibleAnalytes. All the information is from manufacturing specifications. *)
	(* It should be noted that for a single analyte, even if different generations of assays are available - like for IL-6, their minimum dilution factor and recommended diluent should be the same because the nature of the analyte is the same - like serum, plasma, etc... *)
	(* The only thing that can be different for different assay generations is whether they can be used for MultiPlex32X8 and we have checked it above *)
	(* TODO The checks we are doing here cannot cover the case that one assay generation share the minimum dilution factor with other analytes but another assay generation share the diluent with other analytes. This should not happen as we mentioned above. In the future cases, we can try to check this by combining all the checks together. It is not quite necessary at this moment. In the worst case, we are turned down by the sales rep during ordering process. *)
    (* Get the Diluents information of each analyte *)
    analyteDiluents=Map[
		Download[Lookup[#,RecommendedDiluent],Object]&,
		suppliedAnalytesManufacturingSpecificationPackets,
        {2}
    ];

    (* For each analyte, flatten the list to combine all the possible analyte assay generations to show all possible diluents *)
    analyteAllDiluents=DeleteCases[
		Map[
			DeleteDuplicates[
				Flatten[#]
			]&,
			analyteDiluents
		],
		(* Delete empty list for the cases that we have unsupported analytes *)
		{}
	];

    (* Check whether the analytes can share the same diluent *)
    analyteCommonDiluentQ=If[MatchQ[Flatten[analyteAllDiluents],{}]||!MatchQ[resolvedCartridge,Null]||MatchQ[resolvedCartridgeType,Customizable],
        True,
        !MatchQ[Intersection@@analyteAllDiluents,{}]
    ];

    (* Get the MinDilutionFactor information of each analyte *)
    analyteMinDilutionFactors=DeleteCases[
		Map[
			Lookup[#,RecommendedMinDilutionFactor]&,
			suppliedAnalytesManufacturingSpecificationPackets,
			{2}
		],
		{}
	];

    (* For each analyte, flatten the list to combine all the possible analyte assay generations to show all possible MinDilutionFactor *)
    analyteAllMinDilutionFactors=Map[
        DeleteDuplicates[#]&,
		analyteMinDilutionFactors
    ];

    (* Check whether the analytes can share the same MinDilutionFactor *)
    analyteCommonMinDilutionFactorQ=If[MatchQ[Flatten[analyteMinDilutionFactors],{}]||!MatchQ[resolvedCartridge,Null]||MatchQ[resolvedCartridgeType,Customizable],
        True,
        !MatchQ[Intersection@@analyteAllMinDilutionFactors,{}]
    ];

    (* Get the IncompatibleAnalytes information of each analyte. Turn the manufacturing specifications into analyte names so that we can easily compare. *)
    analyteIncompatibleAnalytes=Map[
		Download[
			Lookup[#,IncompatibleAnalytes,{}],
			Object,
			Cache->simulatedCache
		]&,
		suppliedAnalytesManufacturingSpecificationPackets,
        {2}
    ];

    (* Check whether each analyte's incompatible analytes have members from the experiment's analytes *)
    incompatibleAnalyteQ=If[!MatchQ[resolvedCartridge,Null]||MatchQ[resolvedCartridgeType,Customizable],
        True,
        ContainsNone[
            Flatten[analyteIncompatibleAnalytes],
            Download[Flatten[suppliedAnalytesManufacturingSpecificationPackets],Object,Cache->simulatedCache]
        ]
    ];

    (* If any of the Diluent, MinDilutionFactor and IncompatibleAnalytes checks failed, throw error messages *)
    (* TODO: If I get more details from ProteinSimple, these messages and tests will be updated*)
    incompatibleAnalyteDiluentOption=If[!analyteCommonDiluentQ&&messages,
        Message[Error::NoCommonDiluentForAnalytes,ObjectToString[Lookup[Flatten[suppliedAnalytesManufacturingSpecificationPackets],Object,{}],Cache->simulatedCache]];{Analytes},
		{}
    ];
    incompatibleAnalyteMinDilutionFactorOption=If[!analyteCommonMinDilutionFactorQ&&messages,
        Message[Error::NoCommonMinDilutionFactorForAnalytes,ObjectToString[Lookup[Flatten[suppliedAnalytesManufacturingSpecificationPackets],Object,{}],Cache->simulatedCache]];{Analytes},
		{}
    ];
    incompatibleAnalytesOption=If[!incompatibleAnalyteQ&&messages,
        Message[Error::IncompatibleAnalytes,ObjectToString[Lookup[Flatten[suppliedAnalytesManufacturingSpecificationPackets],Object,{}],Cache->simulatedCache]];{Analytes},
		{}
    ];

    (* If we need to gather tests, generate tests for incompatible analytes *)
    incompatibleAnalyteDiluentTests=If[gatherTests,
        Test["The specified analytes must be able to share the same diluent to be used together in a single capillary ELISA cartridge:",analyteCommonDiluentQ,True],
        {}
    ];
    incompatibleAnalyteDilutionFactorTests=If[gatherTests,
        Test["The specified analytes must be able to share the same minimum dilution factor to be used together in a single capillary ELISA cartridge:",analyteCommonMinDilutionFactorQ,True],
        {}
    ];
    incompatibleAnalytesTests=If[gatherTests,
        Test["The specified Analytes should be compatible with each other to be used together in a single capillary ELISA cartridge:",incompatibleAnalyteQ,True],
        {}
    ];

	(* 7 Spike Check *)

	(* When SpikeSample is Null, all Spike related options should be Null or Automatic. Get a list of samples with non-Null options and a list of non-Null options. Call helper function mustNullOptionCheck to get the lists. *)
	invalidSpikeOptionChecks=mustNullOptionCheck[SpikeSample,Null,spikeOptions,roundedCapillaryELISAOptionsAssociation];

	(* Get a list of samples with non-Null spike options *)
	invalidSpikeOptionInputs=PickList[mySamples,invalidSpikeOptionChecks[[1]],False];

	(* Get a list of Spike related options with non-Null values. This covers the case when there is no invalid options *)
	invalidSpikeOptions=invalidSpikeOptionChecks[[2]];

	(* Throw error message if we get invalid samples and options *)
	If[!MatchQ[invalidSpikeOptions,{}]&&messages,
		Message[Error::CannotSpecifySpikeOptions,ObjectToString[invalidSpikeOptionInputs,Cache->simulatedCache],ToString[invalidSpikeOptions]];invalidSpikeOptions,
		{}
	];

	(* If we are gathering tests, generate tests for invalid Spike related options. *)
	invalidSpikeTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=If[Length[invalidSpikeOptions]==Length[spikeOptions],
				Nothing,
				Test["The SpikeSample related options "<>ToString[Complement[spikeOptions,invalidSpikeOptions]]<>" are Null for the samples with SpikeSample set to Null:",True,True]
			];
			failingTest=If[Length[invalidSpikeOptions]==0,
				Nothing,
				Test["The SpikeSample related options "<>ToString[invalidSpikeOptions]<>" are Null for the samples "<>ObjectToString[invalidSpikeOptionInputs,Cache->simulatedCache]<>" with SpikeSample set to Null:",True,False]
			];
			{passingTest,failingTest}
		],
		{}
	];

	(* Get the Spike samples that are not liquids - the capillary ELISA cartridge cannot accept solid state samples and we are not doing resuspension for Spike samples *)
	nonLiquidSpikeQ=Map[
		Which[
			MatchQ[#,Null],False,
			!MatchQ[Lookup[#,State,Null],Alternatives[Liquid,Null]],True,
			True,False
		]&,
		suppliedSpikePackets
	];

	(* Keep track of invalid option and throw error message if we need to do so *)
	nonLiquidSpikeOption=If[MemberQ[nonLiquidSpikeQ,True]&&messages,
		Message[Error::NonLiquidSpike,ObjectToString[PickList[suppliedSpikeSample,nonLiquidSpikeQ],Cache->simulatedCache],ObjectToString[PickList[mySamples,nonLiquidSpikeQ],Cache->simulatedCache]];{SpikeSample},
		{}
	];

	(* If we are gathering tests, generate tests for non-liquid Spike samples. *)
	nonLiquidSpikeTests=If[gatherTests,
		Module[{failingTest,passingTest},
			failingTest=If[!MemberQ[nonLiquidSpikeQ,True],
				Nothing,
				Test["The SpikeSample "<>ObjectToString[PickList[suppliedSpikeSample,nonLiquidSpikeQ],Cache->simulatedCache]<>" to be mix with "<>ObjectToString[PickList[mySamples,nonLiquidSpikeQ],Cache->simulatedCache]<>" are not in solid state:",True,False]
			];
			passingTest=If[!MemberQ[nonLiquidSpikeQ,False],
				Nothing,
				Test["The SpikeSample "<>ObjectToString[PickList[suppliedSpikeSample,nonLiquidSpikeQ,False],Cache->simulatedCache]<>" to be mix with "<>ObjectToString[PickList[mySamples,nonLiquidSpikeQ,False],Cache->simulatedCache]<>" are not in solid state:",True,True]
			];
			{failingTest,passingTest}
		],
		{}
	];

	(* When SpikeSample is not Null, Spike options and also SampleVolume should not be Null. Get a list of samples with Null options. Call helper function mustNotNullOptionCheck to get the lists. *)
	(* It is OK to leave SpikeSampleStorageCondition as Null as we can use their default storage condition *)
	missingSpikeOptionsChecks=mustNotNullOptionCheck[SpikeSample,Except[Null],Join[{SpikeVolume,SpikeConcentration,SampleVolume}],roundedCapillaryELISAOptionsAssociation];

	(* Get a list of samples and spikes with Null SpikeVolume *)
	missingSpikeOptionInputs=PickList[mySamples,missingSpikeOptionsChecks[[1]],False];
	missingSpikeOptionSpikes=PickList[suppliedSpikeSample,missingSpikeOptionsChecks[[1]],False];
	missingSpikeOptions=missingSpikeOptionsChecks[[2]];

	(* Throw error message if we get invalid samples and options *)
	If[!MatchQ[missingSpikeOptionInputs,{}]&&messages,
		Message[Error::MustSpecifySpikeOptions,ObjectToString[missingSpikeOptionInputs,Cache->simulatedCache],ObjectToString[missingSpikeOptionSpikes,Cache->simulatedCache],ToString[missingSpikeOptions]];missingSpikeOptions,
		{}
	];

	(* If we are gathering tests, generate tests for missing SpikeVolume. *)
	missingSpikeOptionTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=If[Length[missingSpikeOptions]==3,
				Nothing,
				Test["The SpikeSample related options and SampleVolume are not Null for the samples "<>ObjectToString[Complement[mySamples,missingSpikeOptionInputs],Cache->simulatedCache]<>"when SpikeSample is not Null:",True,True]
			];
			failingTest=If[Length[missingSpikeOptions]==0,
				Nothing,
				Test["The SpikeSample related options and SampleVolume "<>ToString[missingSpikeOptions]<>" are not Null for the SpikeSample "<>ObjectToString[missingSpikeOptionSpikes,Cache->simulatedCache]<>" (to be mixed with the samples "<>ObjectToString[missingSpikeOptionInputs,Cache->simulatedCache]<>") when SpikeSample is not Null:",True,False]
			];
			{passingTest,failingTest}
		],
		{}
	];

	(* The provided SpikeConcentration should share the same analytes as in the Analytes option. We only check this when both are not Automatic. We limit that at least one member is shared. We can ignore the other members for data processing. *)
	(* Analytes and SpikeConcentration should both been expanded to the length of mySamples so it's safe to do MapThread *)
	(* We need to check whether the cartridge is customizable or pre-loaded *)

	wrongAnalyteSpikeConcentrationQ=If[MatchQ[resolvedCartridge,Customizable]||MatchQ[resolvedCartridgeType,Customizable],
		MapThread[
			(* When we have a Customizable cartridge, we can compare with the customizable analytes *)
			If[MatchQ[#1,Automatic]||MatchQ[#2,Automatic|Null],
				False,
				!MemberQ[#2[[All,2]],#1]
			]&,
			{suppliedCustomizableAnalytes,suppliedSpikeConcentration}
		],
		(* When we have a pre-loaded cartridge, we limit that at least one analyte is shared. *)
		Map[
			Which[
				MatchQ[#,Automatic|Null],
				False,
				(* We get Analyte Molecules from the Cartridge *)
				!MatchQ[suppliedAnalyteMoleculesFromCartridge,Null],
				MatchQ[Intersection[#[[All,1]],suppliedAnalyteMoleculesFromCartridge],{}],
				(* We get Analyte Molecules from the Analytes *)
				!MatchQ[suppliedPreLoadedAnalyteMolecules,Automatic],
				MatchQ[Intersection[#[[All,1]],suppliedPreLoadedAnalyteMolecules],{}],
				True,False
			]&,
			suppliedSpikeConcentration
		]
	];

	(* Track the invalid option and throw error message for wrong analyte concentration of spike sample for a non-customizable cartridge *)
	wrongAnalyteSpikeConcentrationOption=If[MemberQ[wrongAnalyteSpikeConcentrationQ,True]&&messages,
		Message[Error::IncosistentAnalyteAndSpikeConcentration,ObjectToString[PickList[suppliedSpikeSample,wrongAnalyteSpikeConcentrationQ],Cache->simulatedCache],ObjectToString[PickList[mySamples,wrongAnalyteSpikeConcentrationQ],Cache->simulatedCache]];{SpikeConcentration},
		{}
	];

	(* If we are gathering tests, generate tests for wrong analyte SpikeConcentration options *)
	wrongAnalyteSpikeConcentrationTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=If[MemberQ[wrongAnalyteSpikeConcentrationQ,False],
				Test["The SpikeConcentration shows the concentration of analytes for the SpikeSample "<>ObjectToString[PickList[suppliedSpikeSample,wrongAnalyteSpikeConcentrationQ,False],Cache->simulatedCache]<>" to be mixed with the input samples"<>ObjectToString[PickList[mySamples,wrongAnalyteSpikeConcentrationQ,False],Cache->simulatedCache],True,True],
				Nothing
			];
			failingTest=If[MemberQ[wrongAnalyteSpikeConcentrationQ,True],
				Test["The SpikeConcentration shows the concentration of analytes for the SpikeSample "<>ObjectToString[PickList[suppliedSpikeSample,wrongAnalyteSpikeConcentrationQ],Cache->simulatedCache]<>" to be mixed with the input samples"<>ObjectToString[PickList[mySamples,wrongAnalyteSpikeConcentrationQ],Cache->simulatedCache],True,False],
				Nothing
			];
			{passingTest,failingTest}
		],
		{}
	];

	(* The total volume of Spike sample plus the input sample should be larger than the required sample volume of the dilution curve options. *)
	notEnoughSampleSpikeVolumeQ=MapThread[
		Which[
			(* If we don't have SpikeSample, check whether SampleVolume is provided. If yes, use that number to check the required volume. *)
			MatchQ[#1,Null]&&MatchQ[#2,GreaterEqualP[0Microliter]],TrueQ[#2<resolveRequiredSampleVolumeForDilution[#4,#5,30Microliter]],
			MatchQ[#1,Null],False,

			(* If we have SpikeSample, check the total volume of Spike plus input sample. *)
			MatchQ[#2,Automatic]&&MatchQ[#3,Automatic],TrueQ[60Microliter<resolveRequiredSampleVolumeForDilution[#4,#5,30Microliter]],
			MatchQ[#2,Automatic]&&!MatchQ[#3,Automatic|Null],TrueQ[2*#3<resolveRequiredSampleVolumeForDilution[#4,#5,30Microliter]],
			!MatchQ[#2,Automatic|Null]&&MatchQ[#3,Automatic],TrueQ[2*#2<resolveRequiredSampleVolumeForDilution[#4,#5,30Microliter]],
			!MatchQ[#2,Automatic|Null]&&!MatchQ[#3,Automatic|Null],TrueQ[#2+#3<resolveRequiredSampleVolumeForDilution[#4,#5,30Microliter]],

			(* If we have Null volumes or in other cases, just give False to this check as an error has been thrown. *)
			True,False
		]&,
		{suppliedSpikeSample,suppliedSampleVolume,suppliedSpikeVolume,suppliedDilutionCurve,suppliedSerialDilutionCurve}
	];

	(* Find the samples with low volume smaller than the required sample volume of the dilutions *)
	notEnoughSampleSpikeVolumeSamples=PickList[mySamples,notEnoughSampleSpikeVolumeQ];

	(* Track invalid option and throw message for not enough sample volume *)
	notEnoughSampleSpikeVolumeOptions=If[MemberQ[notEnoughSampleSpikeVolumeQ,True],
		Message[Error::NotEnoughSampleVolumeAndSpikeVolume,ObjectToString[notEnoughSampleSpikeVolumeSamples,Cache->simulatedCache]];{SpikeVolume,SampleVolume},
		{}
	];

	(* If we are gathering tests, generate tests for providing too small sample volume and/or spike volume *)
	notEnoughSampleSpikeVolumeTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=If[Length[notEnoughSampleSpikeVolumeSamples]==Length[mySamples],
				Nothing,
				Test["The given SampleVolume (plus SpikeVolume, if applicable) is larger than the required volume used to make the specified dilution curves for "<>ObjectToString[Complement[mySamples,notEnoughSampleSpikeVolumeSamples],Cache->simulatedCache],True,True]
			];
			failingTest=If[Length[notEnoughSampleSpikeVolumeSamples]==0,
				Nothing,
				Test["The given SampleVolume (plus SpikeVolume, if applicable) is larger than the required volume used to make the specified dilution curves for "<>ObjectToString[notEnoughSampleSpikeVolumeSamples,Cache->simulatedCache],True,False]
			];
			{passingTest,failingTest}
		],
		{}
	];


	(* 8 Sample Dilution Check *)
	(* One of DilutionCurve and SerialDilutionCurve must be populated *)
	conflictDilutionCurveQ=MapThread[
		!MatchQ[{#1,#2},{Null,Except[Null]}|{Except[Null],Null}|{Automatic,_}|{_,Automatic}]&,
		{suppliedDilutionCurve,suppliedSerialDilutionCurve}
	];

	(* Track the invalid option and throw error message for conflicting dilution curve options *)
	conflictDilutionCurveOptions=If[MemberQ[conflictDilutionCurveQ,True]&&messages,
		Message[Error::ConflictDilutionCurve,ObjectToString[PickList[mySamples,conflictDilutionCurveQ],Cache->simulatedCache]];{DilutionCurve,SerialDilutionCurve},
		{}
	];

	(* If we are gathering tests, generate tests for conflicting dilution curve options *)
	conflictDilutionCurveTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=If[MemberQ[conflictDilutionCurveQ,False],
				Test["Only one of DilutionCurve and SerialDilutionCurve can be specified or Null for samples "<>ObjectToString[PickList[mySamples,conflictDilutionCurveQ,False],Cache->simulatedCache],True,True],
				Nothing
			];
			failingTest=If[MemberQ[conflictDilutionCurveQ,True],
				Test["Only one of DilutionCurve and SerialDilutionCurve can be specified or Null for samples "<>ObjectToString[PickList[mySamples,conflictDilutionCurveQ],Cache->simulatedCache],True,False],
				Nothing
			];
			{passingTest,failingTest}
		],
		{}
	];

	(* When one of the Dilution options is set to Null, we use the other to set dilution. Throw a warning here to let the user know we are still doing dilution *)
	mandatoryDilutionQ=MapThread[
		Which[
			MatchQ[{#1,#2},{Null,Automatic}],{True,DilutionCurve,SerialDilutionCurve},
			MatchQ[{#1,#2},{Automatic,Null}],{True,SerialDilutionCurve,DilutionCurve},
			True,{False,Null,Null}
		]&,
		{suppliedDilutionCurve,suppliedSerialDilutionCurve}
	];

	(* Find the samples *)
	mandatoryDilutionSamples=PickList[mySamples,mandatoryDilutionQ,{True,_,_}];
	mandatoryDilutionProvidedOptions=PickList[mandatoryDilutionQ[[All,2]],mandatoryDilutionQ,{True,_,_}];
	mandatoryDilutionAutomaticOptions=PickList[mandatoryDilutionQ[[All,3]],mandatoryDilutionQ,{True,_,_}];

	If[MemberQ[mandatoryDilutionQ,{True,_,_}]&&messages,
		Message[Warning::CapillaryELISASampleDilution,ObjectToString[mandatoryDilutionSamples,Cache->simulatedCache],ToString[mandatoryDilutionProvidedOptions],ToString[mandatoryDilutionAutomaticOptions]],
		{}
	];

	(* If we are gathering tests, generate tests for mandatory dilution curve options *)
	mandatoryDilutionTests=If[gatherTests,
		Module[{passingTest,failingTest},
			failingTest=If[MemberQ[mandatoryDilutionQ,{True,_,_}],
				Test["Dilution is required for the samples "<>ObjectToString[PickList[mySamples,mandatoryDilutionQ,{True,_,_}],Cache->simulatedCache]<>" even if one of the dilution options is set to Null:",True,False],
				Nothing
			];
			passingTest=If[MemberQ[mandatoryDilutionQ,{False,_,_}],
				Test["Dilution is required for the samples "<>ObjectToString[mandatoryDilutionSamples,Cache->simulatedCache]<>" even if one of the dilution options is set to Null:",True,True],
				Nothing
			];
			{passingTest,failingTest}
		],
		{}
	];

	(* Note that we check whether the dilution factor of the analyte meets the minimum dilution factor inside MapThread. This avoids accessing manufacturing specification information twice. *)

	(* The loading volume of each sample should be larger than 50 Microliter for best results *)
	nonOptimalLoadingVolumeQ=Map[
		TrueQ[#<50Microliter]&&!MatchQ[#,Automatic]&,
		suppliedLoadingVolume
	];

	(* Throw warning message for non optimal loading volume *)
	If[MemberQ[nonOptimalLoadingVolumeQ,True]&&!MatchQ[$ECLApplication,Engine]&&messages,
		Message[Warning::NonOptimalLoadingVolume,ObjectToString[PickList[mySamples,nonOptimalLoadingVolumeQ],Cache->simulatedCache]];{LoadingVolume},
		{}
	];

	(* If we are gathering tests, generate tests for non optimal loading volume *)
	nonOptimalLoadingVolumeTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=If[MemberQ[nonOptimalLoadingVolumeQ,False],
				Test["The loading volume of samples "<>ObjectToString[PickList[mySamples,nonOptimalLoadingVolumeQ,False],Cache->simulatedCache]<>" should be larger than 50 Microliter for optimized results:",True,True],
				Nothing
			];
			failingTest=If[MemberQ[nonOptimalLoadingVolumeQ,True],
				Test["The loading volume of samples "<>ObjectToString[PickList[mySamples,nonOptimalLoadingVolumeQ],Cache->simulatedCache]<>" should be larger than 50 Microliter for optimized results:",True,False],
				Nothing
			];
			{passingTest,failingTest}
		],
		{}
	];

	(* The total preparation volume of each sample should not be smaller than the loading volume plus 5 Microliter. 5 Microliter is added to make sure the volume can be pipetted out of the container. Default to 50 Microliter loading volume for our automatic resolved option *)
	exceedDilutionLoadingVolumeQ=MapThread[
		TrueQ[(#1+5Microliter)>resolveMinDilutedSamplePreparationVolume[#2,#3,60Microliter]]&,
		{suppliedLoadingVolume,suppliedDilutionCurve,suppliedSerialDilutionCurve}
	];

	(* Find the samples with preparation volume smaller than the loading volume plus 5 Microliter *)
	exceedDilutionLoadingVolumeSamples=PickList[mySamples,exceedDilutionLoadingVolumeQ];
	exceedDilutionLoadingVolumes=PickList[suppliedLoadingVolume,exceedDilutionLoadingVolumeQ];

	(* Track invalid option and throw message for too small preparation volume *)
	exceedDilutionLoadingVolumeOptions=If[MemberQ[exceedDilutionLoadingVolumeQ,True]&&messages,
		Message[Error::NotEnoughDilutionPreparationVolume,ObjectToString[exceedDilutionLoadingVolumeSamples,Cache->simulatedCache],ToString[exceedDilutionLoadingVolumes]];{DilutionCurve,SerialDilutionCurve,LoadingVolume},
		{}
	];

	(* If we are gathering tests, generate tests for exceeded dilution loading volume *)
	exceedDilutionLoadingVolumeTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=If[Length[exceedDilutionLoadingVolumeSamples]==Length[mySamples],
				Nothing,
				Test["The prepared volume of each diluted sample "<>ObjectToString[Complement[mySamples,exceedDilutionLoadingVolumeSamples],Cache->simulatedCache]<>" is larger than the loading volume plus 5 Microliter:",True,True]
			];
			failingTest=If[Length[exceedDilutionLoadingVolumeSamples]==0,
				Nothing,
				Test["The prepared volume of each diluted sample "<>ObjectToString[exceedDilutionLoadingVolumeSamples,Cache->simulatedCache]<>" is larger than the loading volume plus 5 Microliter:",True,False]
			];
			{passingTest,failingTest}
		],
		{}
	];

	(* Check for inside DilutionCurve option, if a linear dilution is desired, the volume of sample does not exceed the total assay volume or a dilution factor does not exceed 1 *)
	invalidDilutionCurveQ=Map[
		Which[
			MatchQ[#,{VolumeP,{VolumeP,VolumeP},_Integer}],
			TrueQ[#[[2,1]]+(Last[#]-1)*#[[2,2]]>First[#]],
			MatchQ[#,{VolumeP,{_Real,_Real},_Integer}],
			TrueQ[#[[2,1]]+(Last[#]-1)*#[[2,2]]>1],
			True,False
		]&,
		suppliedDilutionCurve
	];

	(* Track invalid option and throw message for invalid dilution curve *)
    (* TODO Incorrect message here because this pattern for DilutionCurve is disabled. This message should not be thrown. *)
	invalidDilutionCurveOption=If[MemberQ[invalidDilutionCurveQ,True]&&messages,
        (* Message[Error::InvalidCapillaryELISASampleDilutionCurve,ObjectToString[PickList[mySamples,invalidDilutionCurveQ],Cache->simulatedCache]]; *)
		Message[Error::TooLargeDilutionMixVolumeForCapillaryELISASample,ObjectToString[PickList[mySamples,invalidDilutionCurveQ],Cache->simulatedCache]];{DilutionCurve},
		{}
	];

	(* If we are gathering tests, generate tests for invalid dilution curve *)
	invalidDilutionCurveTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=If[!MemberQ[invalidDilutionCurveQ,False],
				Nothing,
				Test["The provided linear DilutionCurve for samples "<>ObjectToString[PickList[mySamples,invalidDilutionCurveQ,False],Cache->simulatedCache]<>" do not yield a diluted sample with dilution factor larger than 1:",True,True]
			];
			failingTest=If[!MemberQ[invalidDilutionCurveQ,True],
				Nothing,
				Test["The provided linear DilutionCurve for samples "<>ObjectToString[PickList[mySamples,invalidDilutionCurveQ],Cache->simulatedCache]<>" do not yield a diluted sample with dilution factor larger than 1:",True,False]
			];
			{passingTest,failingTest}
		],
		{}
	];

    (* Check for invalid dilution mix volume. It cannot be larger than the volume of the diluted sample *)
    (* Note that DilutionMixVolume is not an automatic option. It is default at 20Microliter. We require a loading volume of at least 25 Microliter so when the sample is below 20Microliter, there must already been an error. *)
    (* The total preparation volume of each sample should not be smaller than the DilutionMixVolume *)
    invalidDilutionMixVolumeQ=MapThread[
        TrueQ[#1>resolveMinDilutedSamplePreparationVolume[#2,#3,60Microliter]]&,
        {suppliedDilutionMixVolume,suppliedDilutionCurve,suppliedSerialDilutionCurve}
    ];

    (* Track invalid option and throw message for invalid dilution curve *)
    invalidDilutionMixVolumeSamples=PickList[mySamples,invalidDilutionMixVolumeQ];

    (* Track invalid option and throw message for too small preparation volume *)
    invalidDilutionMixVolumeOption=If[MemberQ[invalidDilutionMixVolumeQ,True]&&messages,
        Message[Error::TooLargeDilutionMixVolumeForCapillaryELISASample,ObjectToString[invalidDilutionMixVolumeSamples,Cache->simulatedCache]];{DilutionCurve,SerialDilutionCurve,DilutionMixVolume},
        {}
    ];

    (* If we are gathering tests, generate tests for exceeded dilution loading volume *)
    invalidDilutionMixVolumeTests=If[gatherTests,
        Module[{passingTest,failingTest},
            passingTest=If[Length[invalidDilutionMixVolumeSamples]==Length[mySamples],
                Nothing,
                Test["The prepared volume of each diluted sample "<>ObjectToString[Complement[mySamples,invalidDilutionMixVolumeSamples],Cache->simulatedCache]<>" is larger than the dilution mix volume:",True,True]
            ];
            failingTest=If[Length[invalidDilutionMixVolumeSamples]==0,
                Nothing,
                Test["The prepared volume of each diluted sample "<>ObjectToString[invalidDilutionMixVolumeSamples,Cache->simulatedCache]<>" is larger than the dilution mix volume:",True,False]
            ];
            {passingTest,failingTest}
        ],
        {}
    ];

	(* 9 CaptureAntibody and DetectionAntibody Check *)
	(* If the cartridge is not customizable, we must have all CaptureAntibody options as Null. Get a list of samples with non-Null options and a list of non-Null options. Call helper function mustNullOptionCheck to get the lists. Here to use the helper function, we randomly choose an option LoadingVolume, which does not allow Null, as the marker. *)
	invalidAntibodyRelatedOptionChecks=If[!resolvedCustomizableCartridgeQ,
		mustNullOptionCheck[LoadingVolume,Except[Null],antibodyOptions,roundedCapillaryELISAOptionsAssociation],
		{ConstantArray[True,Length[mySamples]],{}}
	];

	(* Get a list of samples with non-Null antibody options *)
	invalidAntibodyRelatedOptionSamples=PickList[mySamples,invalidAntibodyRelatedOptionChecks[[1]],False];

	(* Get a list of antibody options with non-Null values. This covers the case when there is no invalid options *)
	invalidAntibodyRelatedOptions=invalidAntibodyRelatedOptionChecks[[2]];

	(* Throw error message if we get invalid samples and options *)
	If[!MatchQ[invalidAntibodyRelatedOptions,{}]&&messages,
		Message[Error::CannotSpecifyAntibodyOptions,ObjectToString[invalidAntibodyRelatedOptionSamples,Cache->simulatedCache],ToString[invalidAntibodyRelatedOptions]];invalidAntibodyRelatedOptions,
		{}
	];

	(* If we are gathering tests, generate tests for invalid antibody related options. *)
	invalidAntibodyRelatedTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=If[Length[invalidAntibodyRelatedOptions]==Length[antibodyOptions],
				Nothing,
				Test["The CustomCaptureAntibody and CustomDetectionAntibody related options "<>ToString[Complement[antibodyOptions,invalidAntibodyRelatedOptions]]<>" are Null for the samples when the cartridge is not customizable:",True,True]
			];
			failingTest=If[Length[invalidAntibodyRelatedOptions]==0,
				Nothing,
				Test["The CustomCaptureAntibody and CustomDetectionAntibody related options "<>ToString[invalidAntibodyRelatedOptions]<>" are Null for the samples "<>ObjectToString[invalidAntibodyRelatedOptionSamples]<>" when the cartridge is not customizable:",True,False]
			];
			{passingTest,failingTest}
		],
		{}
	];

	(* We don't check whether we are missing CustomCaptureAntibody and CustomDetectionAntibody here. It will be checked together with resolved antibodies *)
	

	(* 10 CaptureAntibody Resuspension Check *)
	(* CaptureAntibodyResuspension must be in accordance with the state of sample - True for solid sample and False for liquid sample *)
	captureAntibodyStates=Map[
		Lookup[#1,State,Null]&,
		suppliedCustomCaptureAntibodyPackets
	];

	(* Check solid state capture antibody samples *)
	solidCaptureAntibodyResuspensionValidQ=MapThread[
		MatchQ[{Lookup[#1,State,Null],#2},{Solid,True|Automatic}|{Except[Solid],_}]&,
		{suppliedCustomCaptureAntibodyPackets,suppliedCaptureAntibodyResuspension}
	];
	(* Check liquid state capture antibody samples *)
	liquidCaptureAntibodyResuspensionValidQ=MapThread[
		MatchQ[{Lookup[#1,State,Null],#2},{Liquid,Except[True]}|{Except[Liquid],_}]&,
		{suppliedCustomCaptureAntibodyPackets,suppliedCaptureAntibodyResuspension}
	];

	(* Find the samples and capture antibody samples with invalid CaptureAntibodyResuspension *)
	solidCaptureAntibodyResuspensionInvalidSamples=If[MemberQ[solidCaptureAntibodyResuspensionValidQ,False],
		PickList[mySamples,solidCaptureAntibodyResuspensionValidQ,False],
		{}
	];
	solidCaptureAntibodyResuspensionInvalidAntibodies=If[MemberQ[solidCaptureAntibodyResuspensionValidQ,False],
		PickList[suppliedCustomCaptureAntibody,solidCaptureAntibodyResuspensionValidQ,False],
		{}
	];

	liquidCaptureAntibodyResuspensionInvalidSamples=If[MemberQ[liquidCaptureAntibodyResuspensionValidQ,False],
		PickList[mySamples,liquidCaptureAntibodyResuspensionValidQ,False],
		{}
	];
	liquidCaptureAntibodyResuspensionInvalidAntibodies=If[MemberQ[liquidCaptureAntibodyResuspensionValidQ,False],
		PickList[suppliedCustomCaptureAntibody,liquidCaptureAntibodyResuspensionValidQ,False],
		{}
	];

	captureAntibodyResuspensionInvalidSamples=Join[solidCaptureAntibodyResuspensionInvalidSamples,liquidCaptureAntibodyResuspensionInvalidSamples];
	captureAntibodyResuspensionInvalidAntibodies=Join[solidCaptureAntibodyResuspensionInvalidAntibodies,liquidCaptureAntibodyResuspensionInvalidAntibodies];

	(* Track the invalid option and throw messages *)
	solidCaptureAntibodyResuspensionInvalidOption=If[!MatchQ[solidCaptureAntibodyResuspensionInvalidSamples,{}]&&messages,
		Message[Error::InvalidCaptureAntibodyResuspensionForSolid,ObjectToString[solidCaptureAntibodyResuspensionInvalidAntibodies,Cache->simulatedCache],ObjectToString[solidCaptureAntibodyResuspensionInvalidSamples,Cache->simulatedCache]];{CaptureAntibodyResuspension},
		{}
	];
	liquidCaptureAntibodyResuspensionInvalidOption=If[!MatchQ[liquidCaptureAntibodyResuspensionInvalidSamples,{}]&&messages,
		Message[Error::InvalidCaptureAntibodyResuspensionForLiquid,ObjectToString[liquidCaptureAntibodyResuspensionInvalidAntibodies,Cache->simulatedCache],ObjectToString[liquidCaptureAntibodyResuspensionInvalidSamples,Cache->simulatedCache]];{CaptureAntibodyResuspension},
		{}
	];

	(* If we are gathering tests, generate tests for invalid capture antibody resuspensions *)
	captureAntibodyResuspensionInvalidTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=Which[
				!resolvedCustomizableCartridgeQ,
				Test["CaptureAntibodyResuspension is True for solid state capture antibody samples and not True for liquid state capture antibody samples:",True,True],
				Length[captureAntibodyResuspensionInvalidSamples]==Length[simulatedSamples],
				Nothing,
				True,
				Test["CaptureAntibodyResuspension is True for solid state capture antibody samples and not True for liquid state capture antibody samples "<>ObjectToString[Complement[mySamples,captureAntibodyResuspensionInvalidSamples],Cache->simulatedCache]<>" (used for ELISA assay of the samples "<>ObjectToString[Complement[suppliedCustomCaptureAntibody,captureAntibodyResuspensionInvalidAntibodies],Cache->simulatedCache]<>") to resuspend only solid state samples:",True,True]
			];
			failingTest=If[Length[captureAntibodyResuspensionInvalidSamples]==0,
				Nothing,
				Test["CaptureAntibodyResuspension is True for solid state capture antibody samples and not True for liquid state capture antibody samples "<>ObjectToString[captureAntibodyResuspensionInvalidSamples,Cache->simulatedCache]<>" (used for ELISA assay of the samples "<>ObjectToString[captureAntibodyResuspensionInvalidAntibodies,Cache->simulatedCache]<>") to resuspend only solid state samples:",True,False]
			];
			{passingTest,failingTest}
		],
		{}
	];

	(* When CaptureAntibodyResuspension is set to Null or False or CustomCaptureAntibody is in liquid state, all CaptureAntibodyResuspension related options should be Null or Automatic. Get a list of samples with non-Null options and a list of non-Null options. Call helper function mustNullOptionCheck to get the lists. *)
	(* Note that we allow CaptureAntibodyStorageCondition to be non-Null here because it can be applied to the original liquid state sample *)
	captureAntibodyResuspensionOptions={CaptureAntibodyResuspensionConcentration,CaptureAntibodyResuspensionDiluent};

	(* We need to check the following cases: When CaptureAntibodyResuspension is not True or Automatic, capture antibody resuspension options should be Null. If CaptureAntibodyResuspension is Automatic but the CustomCaptureAntibody is in liquid state, the same. *)
	invalidCaptureAntibodyResuspensionRelatedOptionChecks=mustNullOptionCheck[CaptureAntibodyResuspension,Except[True|Automatic],captureAntibodyResuspensionOptions,roundedCapillaryELISAOptionsAssociation];

	(* To check the case with liquid-state capture antibody, we create a fake option association *)
	(* Here fakeCaptureantibodyStateOption is not a defined module variable. *)
	invalidCaptureAntibodyResuspensionRelatedOptionLiquidChecks=mustNullOptionCheck[fakeCaptureAntibodyStateOption,Liquid,captureAntibodyResuspensionOptions,Join[<|fakeCaptureAntibodyStateOption->captureAntibodyStates|>,roundedCapillaryELISAOptionsAssociation]];

	(* Get a list of samples and antibodies with non-Null capture antibody resuspension options *)
	invalidCaptureAntibodyResuspensionRelatedOptionSamples=Union[PickList[mySamples,invalidCaptureAntibodyResuspensionRelatedOptionChecks[[1]],False],PickList[mySamples,invalidCaptureAntibodyResuspensionRelatedOptionLiquidChecks[[1]],False]];
	invalidCaptureAntibodyResuspensionRelatedOptionAntibodies=Union[PickList[suppliedCustomCaptureAntibody,invalidCaptureAntibodyResuspensionRelatedOptionChecks[[1]],False],PickList[suppliedCustomCaptureAntibody,invalidCaptureAntibodyResuspensionRelatedOptionLiquidChecks[[1]],False]];

	(* Get a list of capture antibody resuspension options with non-Null values. This covers the case when there is no invalid options *)
	invalidCaptureAntibodyResuspensionOptions=Union[invalidCaptureAntibodyResuspensionRelatedOptionChecks[[2]],invalidCaptureAntibodyResuspensionRelatedOptionLiquidChecks[[2]]];

	(* Throw error message if we get invalid samples and options *)
	If[!MatchQ[invalidCaptureAntibodyResuspensionOptions,{}]&&messages,
		Message[Error::CannotSpecifyCaptureAntibodyResuspensionOptions,ObjectToString[invalidCaptureAntibodyResuspensionRelatedOptionAntibodies,Cache->simulatedCache],ToString[invalidCaptureAntibodyResuspensionOptions],ObjectToString[invalidCaptureAntibodyResuspensionRelatedOptionSamples,Cache->simulatedCache]];invalidCaptureAntibodyResuspensionOptions,
		{}
	];

	(* If we are gathering tests, generate tests for invalid capture antibody resuspension related options. *)
	invalidCaptureAntibodyResuspensionTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=If[Length[invalidCaptureAntibodyResuspensionOptions]==Length[captureAntibodyResuspensionOptions],
				Nothing,
				Test["The capture antibody resuspension related options "<>ToString[Complement[captureAntibodyResuspensionOptions,invalidCaptureAntibodyResuspensionOptions]]<>" are Null for liquid capture antibody samples or the capture antibody samples with CaptureAntibodyResuspension set to False or Null:",True,True]
			];
			failingTest=If[Length[invalidCaptureAntibodyResuspensionOptions]==0,
				Nothing,
				Test["The capture antibody resuspension related options "<>ToString[invalidCaptureAntibodyResuspensionOptions]<>" are Null for the capture antibody samples "<>ObjectToString[invalidCaptureAntibodyResuspensionRelatedOptionAntibodies,Cache->simulatedCache]<>" (used for ELISA assay with samples "<>ObjectToString[invalidCaptureAntibodyResuspensionRelatedOptionSamples,Cache->simulatedCache]<>") with a liquid state or CaptureAntibodyResuspension option set to False or Null:",True,False]
			];
			{passingTest,failingTest}
		],
		{}
	];

	(* When CaptureAntibodyResuspension is set to True, all CaptureAntibodyResuspension related options should be specified or Automatic. Get a list of samples with Null options and a list of Null options. Call helper function mustNotNullOptionCheck to get the lists. *)
	(* CaptureAntibodyStorageCondition can not be Null in this case since we are making a new sample *)
	missingCaptureAntibodyResuspensionOptionChecks=mustNotNullOptionCheck[CaptureAntibodyResuspension,True,Append[captureAntibodyResuspensionOptions,CaptureAntibodyStorageCondition],roundedCapillaryELISAOptionsAssociation];

	(* To check the case with solid-state capture antibody, we create a fake option association *)
	(* Here fakeCaptureantibodySateOption is not a defined module variable. *)
	missingCaptureAntibodyResuspensionOptionSolidChecks=mustNotNullOptionCheck[fakeCaptureAntibodyStateOption,Solid,Append[captureAntibodyResuspensionOptions,CaptureAntibodyStorageCondition],Join[<|fakeCaptureAntibodyStateOption->captureAntibodyStates|>,roundedCapillaryELISAOptionsAssociation]];

	(* Get a list of samples and antibodies with Null capture antibody resuspension options *)
	missingCaptureAntibodyResuspensionSamples=Union[PickList[mySamples,missingCaptureAntibodyResuspensionOptionChecks[[1]],False],PickList[mySamples,missingCaptureAntibodyResuspensionOptionSolidChecks[[1]],False]];
	missingCaptureAntibodyResuspensionAntibodies=Union[PickList[suppliedCustomCaptureAntibody,missingCaptureAntibodyResuspensionOptionChecks[[1]],False],PickList[suppliedCustomCaptureAntibody,missingCaptureAntibodyResuspensionOptionSolidChecks[[1]],False]];

	(* Get a list of capture antibody resuspension options with Null values. This covers the case when there is no invalid options *)
	missingCaptureAntibodyResuspensionOptions=Union[missingCaptureAntibodyResuspensionOptionChecks[[2]],missingCaptureAntibodyResuspensionOptionSolidChecks[[2]]];

	(* Throw error message if we get invalid samples and options *)
	If[!MatchQ[missingCaptureAntibodyResuspensionOptions,{}]&&messages,
		Message[Error::MustSpecifyCaptureAntibodyResuspensionOptions,ObjectToString[missingCaptureAntibodyResuspensionAntibodies,Cache->simulatedCache],ToString[missingCaptureAntibodyResuspensionOptions],ObjectToString[missingCaptureAntibodyResuspensionSamples,Cache->simulatedCache]];missingCaptureAntibodyResuspensionOptions,
		{}
	];

	(* If we are gathering tests, generate tests for invalid capture antibody resuspension related options. *)
	missingCaptureAntibodyResuspensionTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=If[Length[missingCaptureAntibodyResuspensionOptions]==Length[captureAntibodyResuspensionOptions]+1,
				Nothing,
				Test["The CaptureAntibodyResuspension related options "<>ToString[Complement[captureAntibodyResuspensionOptions,missingCaptureAntibodyResuspensionOptions]]<>" are not Null for the samples with solid state or with CaptureAntibodyResuspension option set to True:",True,True]
			];
			failingTest=If[Length[missingCaptureAntibodyResuspensionOptions]==0,
				Nothing,
				Test["The CaptureAntibodyResuspension related options "<>ToString[missingCaptureAntibodyResuspensionOptions]<>" are not Null for the capture antibody samples "<>ObjectToString[missingCaptureAntibodyResuspensionAntibodies,Cache->simulatedCache]<>" (used for ELISA assay of "<>ObjectToString[missingCaptureAntibodyResuspensionSamples,Cache->simulatedCache]<>") with solid state or with CaptureAntibodyResuspension option set to True:",True,False]
			];
			{passingTest,failingTest}
		],
		{}
	];


	(* 11 CaptureAntibody Conjugation Checks *)
	(* When CaptureAntibodyConjugation is set to Null or False, all CaptureAntibodyConjugation related options should be Null or Automatic. Get a list of samples with non-Null options and a list of non-Null options. Call helper function mustNullOptionCheck to get the lists. *)
	captureAntibodyConjugationOptions={
		CaptureAntibodyVolume,
		DigoxigeninReagent,
		DigoxigeninReagentVolume,
		CaptureAntibodyConjugationBuffer,
		CaptureAntibodyConjugationBufferVolume,
		CaptureAntibodyConjugationContainer,
		CaptureAntibodyConjugationTime,
		CaptureAntibodyConjugationTemperature,
		CaptureAntibodyPurificationColumn,
		CaptureAntibodyColumnWashBuffer,
		CaptureAntibodyConjugationStorageCondition
	};

	invalidCaptureAntibodyConjugationRelatedOptionChecks=mustNullOptionCheck[CaptureAntibodyConjugation,Except[True|Automatic],captureAntibodyConjugationOptions,roundedCapillaryELISAOptionsAssociation];

	(* Get a list of samples and antibodies with non-Null capture antibody conjugation options *)
	invalidCaptureAntibodyConjugationRelatedOptionSamples=PickList[mySamples,invalidCaptureAntibodyConjugationRelatedOptionChecks[[1]],False];
	invalidCaptureAntibodyConjugationRelatedOptionAntibodies=PickList[suppliedCustomCaptureAntibody,invalidCaptureAntibodyConjugationRelatedOptionChecks[[1]],False];

	(* Get a list of capture antibody Conjugation options with non-Null values. This covers the case when there is no invalid options *)
	invalidCaptureAntibodyConjugationOptions=invalidCaptureAntibodyConjugationRelatedOptionChecks[[2]];

	(* Throw error message if we get invalid samples and options *)
	If[!MatchQ[invalidCaptureAntibodyConjugationOptions,{}]&&messages,
		Message[Error::CannotSpecifyCaptureAntibodyConjugationOptions,ObjectToString[invalidCaptureAntibodyConjugationRelatedOptionAntibodies,Cache->simulatedCache],ToString[invalidCaptureAntibodyConjugationOptions],ObjectToString[invalidCaptureAntibodyConjugationRelatedOptionSamples,Cache->simulatedCache]];invalidCaptureAntibodyConjugationOptions,
		{}
	];

	(* If we are gathering tests, generate tests for invalid capture antibody Conjugation related options. *)
	invalidCaptureAntibodyConjugationTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=If[Length[invalidCaptureAntibodyConjugationOptions]==Length[CaptureAntibodyConjugationOptions],
				Nothing,
				Test["The capture antibody Conjugation related options "<>ToString[Complement[captureAntibodyConjugationOptions,invalidCaptureAntibodyConjugationOptions]]<>" are Null for the capture antibody samples with CaptureAntibodyConjugation set to False or Null:",True,True]
			];
			failingTest=If[Length[invalidCaptureAntibodyConjugationOptions]==0,
				Nothing,
				Test["The capture antibody Conjugation related options "<>ToString[invalidCaptureAntibodyConjugationOptions]<>" are Null for the capture antibody samples "<>ObjectToString[invalidCaptureAntibodyConjugationRelatedOptionAntibodies,Cache->simulatedCache]<>" (used for ELISA assay with samples "<>ObjectToString[invalidCaptureAntibodyConjugationRelatedOptionSamples,Cache->simulatedCache]<>") with CaptureAntibodyConjugation set to False or Null:",True,False]
			];
			{passingTest,failingTest}
		],
		{}
	];

	(* When CaptureAntibodyConjugation is set to True, all CaptureAntibodyConjugation related options should be specified or Automatic. Get a list of samples with Null options and a list of Null options. Call helper function mustNotNullOptionCheck to get the lists. *)

	missingCaptureAntibodyConjugationRelatedOptionChecks=mustNotNullOptionCheck[CaptureAntibodyConjugation,True,captureAntibodyConjugationOptions,roundedCapillaryELISAOptionsAssociation];

	(* Get a list of samples and antibodies with Null capture antibody conjugation options *)
	missingCaptureAntibodyConjugationRelatedOptionSamples=PickList[mySamples,missingCaptureAntibodyConjugationRelatedOptionChecks[[1]],False];
	missingCaptureAntibodyConjugationRelatedOptionAntibodies=PickList[suppliedCustomCaptureAntibody,missingCaptureAntibodyConjugationRelatedOptionChecks[[1]],False];

	(* Get a list of capture antibody Conjugation options with Null values. This covers the case when there is no missing options *)
	missingCaptureAntibodyConjugationOptions=missingCaptureAntibodyConjugationRelatedOptionChecks[[2]];

	(* Throw error message if we get missing samples and options *)
	If[!MatchQ[missingCaptureAntibodyConjugationOptions,{}]&&messages,
		Message[Error::MustSpecifyCaptureAntibodyConjugationOptions,ObjectToString[missingCaptureAntibodyConjugationRelatedOptionAntibodies,Cache->simulatedCache],ToString[missingCaptureAntibodyConjugationOptions],ObjectToString[missingCaptureAntibodyConjugationRelatedOptionSamples,Cache->simulatedCache]];missingCaptureAntibodyConjugationOptions,
		{}
	];

	(* If we are gathering tests, generate tests for missing capture antibody Conjugation related options. *)
	missingCaptureAntibodyConjugationTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=If[Length[missingCaptureAntibodyConjugationOptions]==Length[captureAntibodyConjugationOptions],
				Nothing,
				Test["The capture antibody Conjugation related options "<>ToString[Complement[captureAntibodyConjugationOptions,missingCaptureAntibodyConjugationOptions]]<>" are not Null for the capture antibody samples with CaptureAntibodyConjugation set to True:",True,True]
			];
			failingTest=If[Length[missingCaptureAntibodyConjugationOptions]==0,
				Nothing,
				Test["The capture antibody Conjugation related options "<>ToString[missingCaptureAntibodyConjugationOptions]<>" are Null for the capture antibody samples "<>ObjectToString[missingCaptureAntibodyConjugationRelatedOptionAntibodies,Cache->simulatedCache]<>" (used for ELISA assay with samples "<>ObjectToString[missingCaptureAntibodyConjugationRelatedOptionSamples,Cache->simulatedCache]<>") with CaptureAntibodyConjugation set to True:",True,False]
			];
			{passingTest,failingTest}
		],
		{}
	];

	(* We should not have a mixed Null/Not-Null conjugation options when CaptureAntibodyConjugation is set to Automatic. In that case, we cannot resolve the correct boolean value. Get the list of samples with a mixing set of options. *)
	captureAntibodyConjugationOptionValues=Lookup[roundedCapillaryELISAOptionsAssociation,Prepend[captureAntibodyConjugationOptions,CaptureAntibodyConjugation]];

	captureAntibodyConjugationOptionConflictQ=MapThread[
		Function[
			{conjugation,antibodyVolume,conjugationReagent,conjugationReagentVolume,conjugationBuffer,conjugationBufferVolume,conjugationContainer,conjugationTime,conjugationTemperature,purificationColumn,washBuffer,storageCondition},
			If[MatchQ[conjugation,Automatic],
				And[
					MemberQ[{antibodyVolume,conjugationReagent,conjugationReagentVolume,conjugationBuffer,conjugationBufferVolume,conjugationContainer,conjugationTime,conjugationTemperature,purificationColumn,washBuffer,storageCondition},Null],
					MemberQ[{antibodyVolume,conjugationReagent,conjugationReagentVolume,conjugationBuffer,conjugationBufferVolume,conjugationContainer,conjugationTime,conjugationTemperature,purificationColumn,washBuffer,storageCondition},Except[Null|Automatic]]
				],
				False
			]
		],
		captureAntibodyConjugationOptionValues
	];

	(* Get the list of samples with conflicting options *)
	captureAntibodyConjugationOptionConflictSamples=PickList[mySamples,captureAntibodyConjugationOptionConflictQ];
	captureAntibodyConjugationOptionConflictAntibodies=PickList[suppliedCustomCaptureAntibody,captureAntibodyConjugationOptionConflictQ];

	(* Throw error message if we get invalid samples and options *)
	captureAntibodyConjugationConflictOptions=If[!MatchQ[captureAntibodyConjugationOptionConflictSamples,{}]&&messages,
		Message[Error::ConflictCaptureAntibodyConjugationOptions,ObjectToString[captureAntibodyConjugationOptionConflictAntibodies,Cache->simulatedCache],ObjectToString[captureAntibodyConjugationOptionConflictSamples,Cache->simulatedCache]];captureAntibodyConjugationOptions,
		{}
	];

	(* If we are gathering tests, generate tests for conflicting capture antibody Conjugation related options. *)
	captureAntibodyConjugationOptionConflictTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=If[Length[captureAntibodyConjugationOptionConflictSamples]==Length[simulatedSamples],
				Nothing,
				Test["CaptureAntibodyConjugation related options should be all Null or not Null for capture antibody samples "<>ObjectToString[PickList[mySamples,captureAntibodyConjugationOptionConflictQ,False],Cache->simulatedCache]<>" (used for ELISA assay with samples "<>ObjectToString[PickList[suppliedCustomCaptureAntibody,captureAntibodyConjugationOptionConflictQ,False],Cache->simulatedCache]<>") so the value of CaptureAntibodyConjugation option can be selected:",True,True]
			];
			failingTest=If[Length[captureAntibodyConjugationOptionConflictSamples]==0,
				Nothing,
				Test["CaptureAntibodyConjugation related options should be all Null or not Null for capture antibody samples "<>ObjectToString[captureAntibodyConjugationOptionConflictAntibodies,Cache->simulatedCache]<>" (used for ELISA assay with samples "<>ObjectToString[captureAntibodyConjugationOptionConflictSamples,Cache->simulatedCache]<>") so the value of CaptureAntibodyConjugation option can be selected:",True,False]
			];
			{passingTest,failingTest}
		],
		{}
	];


	(* Note that we check the reaction ratio of antibody sample and conjugation reagent in the MapThread to avoid resolving the concentrations twice. *)
	(* Note that we check whether the total preparation volume of each conjugated capture antibody sample is larger than the MaxVolume of the specified CaptureAntibodyConjugationContainer, the specified CaptureAntibodyPurificationColumn and the specified CaptureAntibodyStorageContainer also within the MapThread. Because we need to resolve the concentrations and volumes, we don't want to perform the process twice for conflicting check. *)

	(* The specified CaptureAntibodyPurificationColumn is a supported spin column, preferrably 40 K MWCO *)

	(* Right now, It is NOT a good idea to support regular filter as it will require getting the redundant at the top of the filter. Also, washing/collection of the sample will need more manipulations. *)
	(* We only support 6 different types of 7K/40K MWCO spin column, with different capacities. *)
	(* Check whether each of the supplied spin column is supported, with the first boolean indicating 7K/40K for error checking while the second boolean indicating 40K for warning *)

	suppliedCaptureAntibodyPurificationColumnMWCO=MapThread[
		{
			Or[
				MatchQ[#1,Automatic|Null],
				MatchQ[
					#2,
					ObjectP[potentialSpinColumns]
				],
				MatchQ[
					Lookup[#2,Model,Null],
					ObjectP[potentialSpinColumns]
				]
			],
			Or[
				MatchQ[#1,Automatic|Null],
				MatchQ[
					#2,
					ObjectP[potential40KSpinColumns]
				],
				MatchQ[
					Lookup[#2,Model,Null],
					ObjectP[potential40KSpinColumns]
				]
			]
		}&,
		{suppliedCaptureAntibodyPurificationColumn,suppliedCaptureAntibodyPurificationColumnPackets}
	];

	(* Throw an error message if we find a purification column that is not supported. *)
	unsupportedCaptureAntibodyPurificationColumnOption=If[MemberQ[suppliedCaptureAntibodyPurificationColumnMWCO,{False,False}]&&messages,
		Message[Error::UnsupportedCaptureAntibodyPurificationColumn,ObjectToString[PickList[suppliedCustomCaptureAntibody,suppliedCaptureAntibodyPurificationColumnMWCO,{False,False}],Cache->simulatedCache],ObjectToString[PickList[mySamples,suppliedCaptureAntibodyPurificationColumnMWCO,{False,False}],Cache->simulatedCache],ObjectToString[potential40KSpinColumns,Cache->simulatedCache]];{CaptureAntibodyPurificationColumn},
		Nothing
	];

	(* Throw a warning message if we find a purification column that is not 40K MWCO. We only throw warning when an error is not thrown*)
	If[MemberQ[suppliedCaptureAntibodyPurificationColumnMWCO,{True,False}]&&!MatchQ[$ECLApplication,Engine]&&messages,
		Message[Warning::NonOptimalCaptureAntibodyPurificationColumn,ObjectToString[PickList[suppliedCustomCaptureAntibody,suppliedCaptureAntibodyPurificationColumnMWCO,{True,False}],Cache->simulatedCache],ObjectToString[PickList[mySamples,suppliedCaptureAntibodyPurificationColumnMWCO,{True,False}],Cache->simulatedCache],ObjectToString[potential40KSpinColumns,Cache->simulatedCache]],
		Nothing
	];

	(* If we are gathering tests, generate tests for unsupported capture antibody purification column  *)
	unsupportedCaptureAntibodyPurificationColumnTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=Which[
				!resolvedCustomizableCartridgeQ,
				Test["The specified CaptureAntibodyPurificationColumn is a supported Zeba spin column (preferably 40K MWCO) for the capture antibody samples:",True,True],
				!MemberQ[suppliedCaptureAntibodyPurificationColumnMWCO,{True,_}],
				Nothing,
				True,
				Test["The specified CaptureAntibodyPurificationColumn is a supported Zeba spin column (preferably 40K MWCO) for the capture antibody samples "<>ObjectToString[PickList[suppliedCustomCaptureAntibody,suppliedCaptureAntibodyPurificationColumnMWCO,{True,_}],Cache->simulatedCache]<>", used for ELISA assay of the samples "<>ObjectToString[PickList[mySamples,suppliedCaptureAntibodyPurificationColumnMWCO,{True,_}],Cache->simulatedCache],True,True]
			];
			failingTest=If[!MemberQ[suppliedCaptureAntibodyPurificationColumnMWCO,{False,False}],
				Nothing,
				Test["The specified CaptureAntibodyPurificationColumn is a supported Zeba spin column (preferably 40K MWCO) for the capture antibody samples "<>ObjectToString[PickList[suppliedCustomCaptureAntibody,suppliedCaptureAntibodyPurificationColumnMWCO,{False,False}],Cache->simulatedCache]<>", used for ELISA assay of the samples "<>ObjectToString[PickList[mySamples,suppliedCaptureAntibodyPurificationColumnMWCO,{False,False}],Cache->simulatedCache],True,False]
			];
			{passingTest,failingTest}
		],
		{}
	];

	(* If we are gathering tests, generate tests for non-optimal capture antibody purification column *)
	nonOptimalCaptureAntibodyPurificationColumnTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=Which[
				!resolvedCustomizableCartridgeQ,
				Test["The specified CaptureAntibodyPurificationColumn is 40K MWCO for the capture antibody samples:",True,True],
				!MemberQ[suppliedCaptureAntibodyPurificationColumnMWCO,{True,True}],
				Nothing,
				True,
				Test["The specified CaptureAntibodyPurificationColumn is 40K MWCO for the capture antibody samples "<>ObjectToString[PickList[suppliedCustomCaptureAntibody,suppliedCaptureAntibodyPurificationColumnMWCO,{True,True}],Cache->simulatedCache]<>", used for ELISA assay of the samples "<>ObjectToString[PickList[mySamples,suppliedCaptureAntibodyPurificationColumnMWCO,{True,True}],Cache->simulatedCache],True,True]
			];
			failingTest=If[!MemberQ[suppliedCaptureAntibodyPurificationColumnMWCO,{_,False}],
				Nothing,
				Test["The specified CaptureAntibodyPurificationColumn is 40K MWCO for the capture antibody samples "<>ObjectToString[PickList[suppliedCustomCaptureAntibody,suppliedCaptureAntibodyPurificationColumnMWCO,{_,False}],Cache->simulatedCache]<>", used for ELISA assay of the samples "<>ObjectToString[PickList[mySamples,suppliedCaptureAntibodyPurificationColumnMWCO,{_,False}],Cache->simulatedCache],True,False]
			];
			{passingTest,failingTest}
		],
		{}
	];


	(* 12 CaptureAntibody Dilution Checks *)
	(* When CaptureAntibodyDilution is set to Null, all CaptureAntibodyDilution related options should be Null or Automatic. Get a list of samples with non-Null options and a list of non-Null options. Call helper function mustNullOptionCheck to get the lists. *)
	captureAntibodyDilutionOptions={CaptureAntibodyTargetConcentration,CaptureAntibodyDiluent};

	invalidCaptureAntibodyDilutionRelatedOptionChecks=mustNullOptionCheck[CaptureAntibodyDilution,Null|False,captureAntibodyDilutionOptions,roundedCapillaryELISAOptionsAssociation];

	(* Get a list of samples and antibodies with non-Null capture antibody Dilution options *)
	invalidCaptureAntibodyDilutionRelatedOptionSamples=PickList[mySamples,invalidCaptureAntibodyDilutionRelatedOptionChecks[[1]],False];
	invalidCaptureAntibodyDilutionRelatedOptionAntibodies=PickList[suppliedCustomCaptureAntibody,invalidCaptureAntibodyDilutionRelatedOptionChecks[[1]],False];

	(* Get a list of capture antibody Dilution options with non-Null values. This covers the case when there is no invalid options *)
	invalidCaptureAntibodyDilutionOptions=invalidCaptureAntibodyDilutionRelatedOptionChecks[[2]];

	(* Throw error message if we get invalid samples and options *)
	If[!MatchQ[invalidCaptureAntibodyDilutionOptions,{}]&&messages,
		Message[Error::CannotSpecifyCaptureAntibodyDilutionOptions,ObjectToString[invalidCaptureAntibodyDilutionRelatedOptionAntibodies,Cache->simulatedCache],ToString[invalidCaptureAntibodyDilutionOptions],ObjectToString[invalidCaptureAntibodyDilutionRelatedOptionSamples,Cache->simulatedCache]];invalidCaptureAntibodyDilutionOptions,
		{}
	];

	(* If we are gathering tests, generate tests for invalid capture antibody Dilution related options. *)
	invalidCaptureAntibodyDilutionTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=If[Length[invalidCaptureAntibodyDilutionOptions]==Length[captureAntibodyDilutionOptions],
				Nothing,
				Test["The capture antibody dilution related options "<>ToString[Complement[captureAntibodyDilutionOptions,invalidCaptureAntibodyDilutionOptions]]<>" are Null for the capture antibody samples with CaptureAntibodyDilution set to Null or False:",True,True]
			];
			failingTest=If[Length[invalidCaptureAntibodyDilutionOptions]==0,
				Nothing,
				Test["The capture antibody Dilution related options "<>ToString[invalidCaptureAntibodyDilutionOptions]<>" are Null for the capture antibody samples "<>ObjectToString[invalidCaptureAntibodyDilutionRelatedOptionAntibodies,Cache->simulatedCache]<>" (used for ELISA assay with samples "<>ObjectToString[invalidCaptureAntibodyDilutionRelatedOptionSamples,Cache->simulatedCache]<>") with CaptureAntibodyDilution set to Null or False:",True,False]
			];
			{passingTest,failingTest}
		],
		{}
	];

	(* When the capture antibody sample goes through either resuspension or conjugation process in this protocol, it is recommend to do dilution - CaptureAntibodyDilution is not set to Null/False. *)
	missingRecommendedCaptureAntibodyDilutionQ=MapThread[
		MatchQ[{Lookup[#1,State,Null],#2,#3},{Solid,_,Null|False}|{_,True,Null|False}]&,
		{suppliedCustomCaptureAntibodyPackets,suppliedCaptureAntibodyConjugation,suppliedCaptureAntibodyDilution}
	];

	(* Get a list of samples and antibodies with null capture antibody dilution option but a dilution is recommended *)
	missingRecommendedCaptureAntibodyDilutionSamples=PickList[mySamples,missingRecommendedCaptureAntibodyDilutionQ];
	missingRecommendedCaptureAntibodyDilutionAntibodies=PickList[suppliedCustomCaptureAntibody,missingRecommendedCaptureAntibodyDilutionQ];

	(* Throw warning message if we get samples for which a dilution is recommended *)
	If[!MatchQ[missingRecommendedCaptureAntibodyDilutionSamples,{}]&&!MatchQ[$ECLApplication,Engine]&&messages,
		Message[Warning::CaptureAntibodyDilutionRecommended,ObjectToString[missingRecommendedCaptureAntibodyDilutionAntibodies,Cache->simulatedCache],ObjectToString[missingRecommendedCaptureAntibodyDilutionSamples,Cache->simulatedCache]],
		Nothing
	];

	(* If we are gathering tests, generate tests for the samples for which a dilution is recommended *)
	missingRecommendedCaptureAntibodyDilutionTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=Which[
				!resolvedCustomizableCartridgeQ,
				Test["The CaptureAntibodyDilution option is not Null for the capture antibody samples when it is either resuspended or conjugated in this protocol:",True,True],
				Length[missingRecommendedCaptureAntibodyDilutionSamples]==Length[simulatedSamples],
				Nothing,
				True,
				Test["The CaptureAntibodyDilution option is not Null for the capture antibody samples "<>ObjectToString[Complement[suppliedCustomCaptureAntibody,missingRecommendedCaptureAntibodyDilutionAntibodies],Cache->simulatedCache]<>" (for ELISA assay of "<>ObjectToString[Complement[mySamples,missingRecommendedCaptureAntibodyDilutionSamples],Cache->simulatedCache]<>") when it is either resuspended or conjugated in this protocol:",True,True]
			];
			failingTest=If[Length[invalidCaptureAntibodyDilutionOptions]==0,
				Nothing,
				Test["The CaptureAntibodyDilution option is not Null for the capture antibody samples "<>ObjectToString[missingRecommendedCaptureAntibodyDilutionAntibodies,Cache->simulatedCache]<>" (for ELISA assay of "<>ObjectToString[missingRecommendedCaptureAntibodyDilutionSamples,Cache->simulatedCache]<>") when it is either resuspended or conjugated in this protocol:",True,False]
			];
			{passingTest,failingTest}
		],
		{}
	];
	
	(* When CaptureAntibodyDilution is True, CaptureAntibodyTargetConcentration and CaptureAntibodyDiluent should not be Null. Get a list of samples with Null option. Call helper function mustNotNullOptionCheck to get the lists. *)
	missingCaptureAntibodyDilutionOptionsChecks=mustNotNullOptionCheck[CaptureAntibodyDilution,Except[Null|Automatic],captureAntibodyDilutionOptions,roundedCapillaryELISAOptionsAssociation];

	(* Get a list of samples and antibodies with Null CaptureAntibodyDiluent *)
	missingCaptureAntibodyDilutionOptionsSamples=PickList[mySamples,missingCaptureAntibodyDilutionOptionsChecks[[1]],False];
	missingCaptureAntibodyDilutionOptionsAntibodies=PickList[suppliedCustomCaptureAntibody,missingCaptureAntibodyDilutionOptionsChecks[[1]],False];

	(* Get a list of capture antibody Dilution options with Null values. This covers the case when there is no invalid options *)
	missingCaptureAntibodyDilutionOptions=missingCaptureAntibodyDilutionOptionsChecks[[2]];

	(* Throw error message if we get invalid samples and options *)
	If[!MatchQ[missingCaptureAntibodyDilutionOptions,{}]&&messages,
		Message[Error::MustSpecifyCaptureAntibodyDilutionOptions,
			ObjectToString[missingCaptureAntibodyDilutionOptionsAntibodies,Cache->simulatedCache],
			missingCaptureAntibodyDilutionOptions,
			ObjectToString[missingCaptureAntibodyDilutionOptionsSamples,Cache->simulatedCache]];missingCaptureAntibodyDilutionOptions,
		{}
	];

	(* If we are gathering tests, generate tests for missing CaptureAntibodyDiluent. *)
	missingCaptureAntibodyDilutionOptionTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=If[Length[missingCaptureAntibodyDilutionOptions]==Length[captureAntibodyDilutionOptions],
				Nothing,
				Test["The capture antibody dilution related options "<>ToString[Complement[captureAntibodyDilutionOptions,missingCaptureAntibodyDilutionOptions]]<>" are not Null for the capture antibody samples with CaptureAntibodyDilution set True:",True,True]
			];
			failingTest=If[Length[missingCaptureAntibodyDilutionOptions]==0,
				Nothing,
				Test["The CaptureAntibodyDiluent options "<>ToString[missingCaptureAntibodyDilutionOptions]<>" are not Null for the capture antibody samples "<>ObjectToString[missingCaptureAntibodyDilutionOptionsAntibodies,Cache->simulatedCache]<>" (for ELISA assay of "<>ObjectToString[missingCaptureAntibodyDilutionOptionsSamples,Cache->simulatedCache]<>") when its CaptureAntibodyDilution is not Null:",True,False]
			];
			{passingTest,failingTest}
		],
		{}
	];

	(* We should not have a mixed Null/Not-Null dilution options when CaptureAntibodyDilution is set to Automatic. In that case, we cannot resolve the correct boolean value. Get the list of samples with a mixing set of options. *)
	captureAntibodyDilutionOptionValues=Lookup[roundedCapillaryELISAOptionsAssociation,Prepend[captureAntibodyDilutionOptions,CaptureAntibodyDilution]];

	captureAntibodyDilutionOptionConflictQ=MapThread[
		MatchQ[{#1,#2,#3},{Automatic,Except[Null|Automatic],Null}|{Automatic,Null,Except[Null|Automatic]}]&,
		captureAntibodyDilutionOptionValues
	];

	(* Get the list of samples with conflicting options *)
	captureAntibodyDilutionOptionConflictSamples=PickList[mySamples,captureAntibodyDilutionOptionConflictQ];
	captureAntibodyDilutionOptionConflictAntibodies=PickList[suppliedCustomCaptureAntibody,captureAntibodyDilutionOptionConflictQ];

	(* Throw error message if we get invalid samples and options *)
	captureAntibodyDilutionConflictOptions=If[!MatchQ[captureAntibodyDilutionOptionConflictSamples,{}]&&messages,
		Message[Error::ConflictCaptureAntibodyDilutionOptions,ObjectToString[captureAntibodyDilutionOptionConflictAntibodies,Cache->simulatedCache],ObjectToString[captureAntibodyDilutionOptionConflictSamples,Cache->simulatedCache]];captureAntibodyDilutionOptions,
		{}
	];

	(* If we are gathering tests, generate tests for conflicting capture antibody dilution related options. *)
	captureAntibodyDilutionOptionConflictTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=If[Length[captureAntibodyDilutionOptionConflictSamples]==Length[simulatedSamples],
				Nothing,
				Test["CaptureAntibodyTargetConcentration and CaptureAntibodyDiluent options should be both Null or not Null for capture antibody samples "<>ObjectToString[PickList[mySamples,captureAntibodyDilutionOptionConflictQ,False],Cache->simulatedCache]<>" (used for ELISA assay with samples "<>ObjectToString[PickList[suppliedCustomCaptureAntibody,captureAntibodyDilutionOptionConflictQ,False],Cache->simulatedCache]<>") so the value of CaptureAntibodyDilution option can be selected:",True,True]
			];
			failingTest=If[Length[captureAntibodyDilutionOptionConflictSamples]==0,
				Nothing,
				Test["CaptureAntibodyTargetConcentration and CaptureAntibodyDiluent options should be both Null or not Null for capture antibody samples "<>ObjectToString[captureAntibodyDilutionOptionConflictAntibodies,Cache->simulatedCache]<>" (used for ELISA assay with samples "<>ObjectToString[captureAntibodyDilutionOptionConflictSamples,Cache->simulatedCache]<>") so the value of CaptureAntibodyDilution option can be selected:",True,False]
			];
			{passingTest,failingTest}
		],
		{}
	];

	(* CaptureAntibodyDiluent should be Model[Sample, "Simple Plex Reagent Diluent"] for optimized result. Get a list of samples with non-optimized capture antibody diluent. *)
	nonOptimalCaptureAntibodyDiluentQ=Map[
		!MatchQ[#,Automatic|Null|Model[Sample, "id:pZx9jo8LZ7z5"]]&, (* Model[Sample,"Simple Plex Reagent Diluent"] *)
		suppliedCaptureAntibodyDiluentModels
	];

	(* Get a list of samples and antibodies with CaptureAntibodyDiluent not set to Model[Sample, "Simple Plex Reagent Diluent"]  or an object with this model *)
	nonOptimalCaptureAntibodyDiluentSamples=PickList[mySamples,nonOptimalCaptureAntibodyDiluentQ];
	nonOptimalCaptureAntibodyDiluentAntibodies=PickList[suppliedCustomCaptureAntibody,nonOptimalCaptureAntibodyDiluentQ];

	(* Throw warning message is we get a non-optimal diluent *)
	If[MemberQ[nonOptimalCaptureAntibodyDiluentQ,True]&&!MatchQ[$ECLApplication,Engine]&&messages,
		Message[Warning::NonOptimalCaptureAntibodyDiluent,ObjectToString[nonOptimalCaptureAntibodyDiluentAntibodies,Cache->simulatedCache],ObjectToString[nonOptimalCaptureAntibodyDiluentSamples,Cache->simulatedCache]];{CaptureAntibodyDiluent},
		{}
	];

	(* If we are gathering tests, generate tests for non-optimal CaptureAntibodyDiluent. *)
	nonOptimalCaptureAntibodyDiluentTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=Which[
				!resolvedCustomizableCartridgeQ,
				Test["The CaptureAntibodyDiluent option is kept as Model[Sample,\"Simple Plex Reagent Diluent\"] or a sample with this model for the capture antibody samples:",True,True],
				Length[nonOptimalCaptureAntibodyDiluentSamples]==Length[simulatedSamples],
				Nothing,
				True,
				Test["The CaptureAntibodyDiluent option is kept as Model[Sample,\"Simple Plex Reagent Diluent\"] or a sample with this model for the capture antibody samples "<>ObjectToString[Complement[suppliedCustomCaptureAntibody,nonOptimalCaptureAntibodyDiluentAntibodies],Cache->simulatedCache]<>" (for ELISA assay of "<>ObjectToString[Complement[mySamples,nonOptimalCaptureAntibodyDiluentSamples],Cache->simulatedCache]<>") for optimized dilution and ELISA results:",True,True]
			];
			failingTest=If[Length[nonOptimalCaptureAntibodyDiluentSamples]==0,
				Nothing,
				Test["The CaptureAntibodyDiluent option is kept as Model[Sample,\"Simple Plex Reagent Diluent\"] or a sample with this model for the capture antibody samples "<>ObjectToString[nonOptimalCaptureAntibodyDiluentAntibodies,Cache->simulatedCache]<>" (for ELISA assay of "<>ObjectToString[nonOptimalCaptureAntibodyDiluentSamples,Cache->simulatedCache]<>") for optimized dilution and ELISA results:",True,False]
			];
			{passingTest,failingTest}
		],
		{}
	];

	(* When CaptureAntibody is not Null, CaptureAntibodyLoadingVolume should not be Null. Get a list of samples with Null option. Call helper function mustNotNullOptionCheck to get the lists. *)
	missingCaptureAntibodyLoadingVolumeChecks=mustNotNullOptionCheck[CustomCaptureAntibody,Except[Null|Automatic],{CaptureAntibodyLoadingVolume},roundedCapillaryELISAOptionsAssociation][[1]];

	(* Get a list of samples and antibodies with Null CaptureAntibodyLoadingVolume *)
	missingCaptureAntibodyLoadingVolumeSamples=PickList[mySamples,missingCaptureAntibodyLoadingVolumeChecks,False];
	missingCaptureAntibodyLoadingVolumeAntibodies=PickList[suppliedCustomCaptureAntibody,missingCaptureAntibodyLoadingVolumeChecks,False];

	(* Throw error message if we get invalid samples and options *)
	missingCaptureAntibodyLoadingVolumeOption=If[!MatchQ[missingCaptureAntibodyLoadingVolumeSamples,{}]&&messages,
		Message[Error::MustSpecifyCaptureAntibodyLoadingVolume,ObjectToString[missingCaptureAntibodyLoadingVolumeAntibodies,Cache->simulatedCache],ObjectToString[missingCaptureAntibodyLoadingVolumeSamples,Cache->simulatedCache]];{CaptureAntibodyLoadingVolume},
		{}
	];

	(* If we are gathering tests, generate tests for missing CaptureAntibodyLoadingVolume. *)
	missingCaptureAntibodyLoadingVolumeTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=Which[
				!resolvedCustomizableCartridgeQ,
				Test["When a customizable cartridge is used, the CaptureAntibodyLoadingVolume option is not Null for the capture antibody samples:",True,True],
				Length[missingCaptureAntibodyLoadingVolumeSamples]==Length[simulatedSamples],
				Nothing,
				True,
				Test["When a customizable cartridge is used, the CaptureAntibodyLoadingVolume option is not Null for the capture antibody samples "<>ObjectToString[Complement[suppliedCustomCaptureAntibody,missingCaptureAntibodyLoadingVolumeAntibodies],Cache->simulatedCache]<>", used for ELISA assay of "<>ObjectToString[Complement[mySamples,missingCaptureAntibodyLoadingVolumeSamples],Cache->simulatedCache],True,True]
			];
			failingTest=If[Length[missingCaptureAntibodyLoadingVolumeSamples]==0,
				Nothing,
				Test["When a customizable cartridge is used, the CaptureAntibodyLoadingVolume option is not Null for the capture antibody samples "<>ObjectToString[missingCaptureAntibodyLoadingVolumeAntibodies,Cache->simulatedCache]<>", used for ELISA assay of "<>ObjectToString[missingCaptureAntibodyLoadingVolumeSamples,Cache->simulatedCache],True,False]
			];
			{passingTest,failingTest}
		],
		{}
	];


	(* 13 DetectionAntibody Resuspension Check *)
	(* DetectionAntibodyResuspension must be in accordance with the state of sample - True for solid sample and False for liquid sample *)
	(* Check solid state detection antibody samples *)

	detectionAntibodyStates=Map[
		Lookup[#1,State,Null]&,
		suppliedCustomDetectionAntibodyPackets
	];

	solidDetectionAntibodyResuspensionValidQ=MapThread[
		MatchQ[{Lookup[#1,State,Null],#2},{Solid,True|Automatic}|{Except[Solid],_}]&,
		{suppliedCustomDetectionAntibodyPackets,suppliedDetectionAntibodyResuspension}
	];
	(* Check liquid state detection antibody samples *)
	liquidDetectionAntibodyResuspensionValidQ=MapThread[
		MatchQ[{Lookup[#1,State,Null],#2},{Liquid,Except[True]}|{Except[Liquid],_}]&,
		{suppliedCustomDetectionAntibodyPackets,suppliedDetectionAntibodyResuspension}
	];

	(* Find the samples and detection antibody samples with invalid DetectionAntibodyResuspension *)
	solidDetectionAntibodyResuspensionInvalidSamples=If[MemberQ[solidDetectionAntibodyResuspensionValidQ,False],
		PickList[mySamples,solidDetectionAntibodyResuspensionValidQ,False],
		{}
	];
	solidDetectionAntibodyResuspensionInvalidAntibodies=If[MemberQ[solidDetectionAntibodyResuspensionValidQ,False],
		PickList[suppliedCustomDetectionAntibody,solidDetectionAntibodyResuspensionValidQ,False],
		{}
	];

	liquidDetectionAntibodyResuspensionInvalidSamples=If[MemberQ[liquidDetectionAntibodyResuspensionValidQ,False],
		PickList[mySamples,liquidDetectionAntibodyResuspensionValidQ,False],
		{}
	];
	liquidDetectionAntibodyResuspensionInvalidAntibodies=If[MemberQ[liquidDetectionAntibodyResuspensionValidQ,False],
		PickList[suppliedCustomDetectionAntibody,liquidDetectionAntibodyResuspensionValidQ,False],
		{}
	];

	detectionAntibodyResuspensionInvalidSamples=Join[solidDetectionAntibodyResuspensionInvalidSamples,liquidDetectionAntibodyResuspensionInvalidSamples];
	detectionAntibodyResuspensionInvalidAntibodies=Join[solidDetectionAntibodyResuspensionInvalidAntibodies,liquidDetectionAntibodyResuspensionInvalidAntibodies];

	(* Track the invalid option and throw messages *)
	solidDetectionAntibodyResuspensionInvalidOption=If[!MatchQ[solidDetectionAntibodyResuspensionInvalidSamples,{}]&&messages,
		Message[Error::InvalidDetectionAntibodyResuspensionForSolid,ObjectToString[solidDetectionAntibodyResuspensionInvalidAntibodies,Cache->simulatedCache],ObjectToString[solidDetectionAntibodyResuspensionInvalidSamples,Cache->simulatedCache]];{DetectionAntibodyResuspension},
		{}
	];
	liquidDetectionAntibodyResuspensionInvalidOption=If[!MatchQ[liquidDetectionAntibodyResuspensionInvalidSamples,{}]&&messages,
		Message[Error::InvalidDetectionAntibodyResuspensionForLiquid,ObjectToString[liquidDetectionAntibodyResuspensionInvalidAntibodies,Cache->simulatedCache],ObjectToString[liquidDetectionAntibodyResuspensionInvalidSamples,Cache->simulatedCache]];{DetectionAntibodyResuspension},
		{}
	];

	(* If we are gathering tests, generate tests for invalid detection antibody resuspensions *)
	detectionAntibodyResuspensionInvalidTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=Which[
				!resolvedCustomizableCartridgeQ,
				Test["DetectionAntibodyResuspension is True for solid state detection antibody samples and not True for liquid state detection antibody samples:",True,True],
				Length[detectionAntibodyResuspensionInvalidSamples]==Length[simulatedSamples],
				Nothing,
				True,
				Test["DetectionAntibodyResuspension is True for solid state detection antibody samples and not True for liquid state detection antibody samples "<>ObjectToString[Complement[mySamples,detectionAntibodyResuspensionInvalidSamples],Cache->simulatedCache]<>" (used for ELISA assay of the samples "<>ObjectToString[Complement[suppliedCustomDetectionAntibody,detectionAntibodyResuspensionInvalidAntibodies],Cache->simulatedCache]<>") to resuspend only solid state samples:",True,True]
			];
			failingTest=If[Length[detectionAntibodyResuspensionInvalidSamples]==0,
				Nothing,
				Test["DetectionAntibodyResuspension is True for solid state detection antibody samples and not True for liquid state detection antibody samples "<>ObjectToString[detectionAntibodyResuspensionInvalidSamples,Cache->simulatedCache]<>" (used for ELISA assay of the samples "<>ObjectToString[detectionAntibodyResuspensionInvalidAntibodies,Cache->simulatedCache]<>") to resuspend only solid state samples:",True,False]
			];
			{passingTest,failingTest}
		],
		{}
	];

	(* When DetectionAntibodyResuspension is set to Null or False or CustomDetectionAntibody is in liquid state, all DetectionAntibodyResuspension related options should be Null or Automatic. Get a list of samples with non-Null options and a list of non-Null options. Call helper function mustNullOptionCheck to get the lists. *)
	(* Note that we allow DetectionAntibodyStorageCondition to be non-Null here because it can be applied to the original liquid state sample *)
	detectionAntibodyResuspensionOptions={DetectionAntibodyResuspensionConcentration,DetectionAntibodyResuspensionDiluent};

	(* We need to check the following cases: When DetectionAntibodyResuspension is not True or Automatic, detection antibody resuspension options should be Null. If DetectionAntibodyResuspension is Automatic but the CustomDetectionAntibody is in liquid state, the same. *)
	invalidDetectionAntibodyResuspensionRelatedOptionChecks=mustNullOptionCheck[DetectionAntibodyResuspension,Except[True|Automatic],detectionAntibodyResuspensionOptions,roundedCapillaryELISAOptionsAssociation];

	(* To check the case with liquid-state detection antibody, we create a fake option association *)
	(* Here fakeDetectionantibodySateOption is not a defined module variable. *)
	invalidDetectionAntibodyResuspensionRelatedOptionLiquidChecks=mustNullOptionCheck[fakeDetectionAntibodyStateOption,Liquid,detectionAntibodyResuspensionOptions,Join[<|fakeDetectionAntibodyStateOption->detectionAntibodyStates|>,roundedCapillaryELISAOptionsAssociation]];

	(* Get a list of samples and antibodies with non-Null detection antibody resuspension options *)
	invalidDetectionAntibodyResuspensionRelatedOptionSamples=Union[PickList[mySamples,invalidDetectionAntibodyResuspensionRelatedOptionChecks[[1]],False],PickList[mySamples,invalidDetectionAntibodyResuspensionRelatedOptionLiquidChecks[[1]],False]];
	invalidDetectionAntibodyResuspensionRelatedOptionAntibodies=Union[PickList[suppliedCustomDetectionAntibody,invalidDetectionAntibodyResuspensionRelatedOptionChecks[[1]],False],PickList[suppliedCustomDetectionAntibody,invalidDetectionAntibodyResuspensionRelatedOptionLiquidChecks[[1]],False]];

	(* Get a list of detection antibody resuspension options with non-Null values. This covers the case when there is no invalid options *)
	invalidDetectionAntibodyResuspensionOptions=Union[invalidDetectionAntibodyResuspensionRelatedOptionChecks[[2]],invalidDetectionAntibodyResuspensionRelatedOptionLiquidChecks[[2]]];

	(* Throw error message if we get invalid samples and options *)
	If[!MatchQ[invalidDetectionAntibodyResuspensionOptions,{}]&&messages,
		Message[Error::CannotSpecifyDetectionAntibodyResuspensionOptions,ObjectToString[invalidDetectionAntibodyResuspensionRelatedOptionAntibodies,Cache->simulatedCache],ToString[invalidDetectionAntibodyResuspensionOptions],ObjectToString[invalidDetectionAntibodyResuspensionRelatedOptionSamples,Cache->simulatedCache]];invalidDetectionAntibodyResuspensionOptions,
		{}
	];

	(* If we are gathering tests, generate tests for invalid detection antibody resuspension related options. *)
	invalidDetectionAntibodyResuspensionTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=If[Length[invalidDetectionAntibodyResuspensionOptions]==Length[detectionAntibodyResuspensionOptions],
				Nothing,
				Test["The detection antibody resuspension related options "<>ToString[Complement[detectionAntibodyResuspensionOptions,invalidDetectionAntibodyResuspensionOptions]]<>" are Null for liquid detection antibody samples or the detection antibody samples with DetectionAntibodyResuspension set to False or Null:",True,True]
			];
			failingTest=If[Length[invalidDetectionAntibodyResuspensionOptions]==0,
				Nothing,
				Test["The detection antibody resuspension related options "<>ToString[invalidDetectionAntibodyResuspensionOptions]<>" are Null for the detection antibody samples "<>ObjectToString[invalidDetectionAntibodyResuspensionRelatedOptionAntibodies,Cache->simulatedCache]<>" (used for ELISA assay with samples "<>ObjectToString[invalidDetectionAntibodyResuspensionRelatedOptionSamples,Cache->simulatedCache]<>") with a liquid state or DetectionAntibodyResuspension option set to False or Null:",True,False]
			];
			{passingTest,failingTest}
		],
		{}
	];

	(* When DetectionAntibodyResuspension is set to True, all DetectionAntibodyResuspension related options should be specified or Automatic. Get a list of samples with Null options and a list of Null options. Call helper function mustNotNullOptionCheck to get the lists. *)
	(* DetectionAntibodyStorageCondition can not be Null in this case since we are making a new sample *)
	missingDetectionAntibodyResuspensionOptionChecks=mustNotNullOptionCheck[DetectionAntibodyResuspension,True,Append[detectionAntibodyResuspensionOptions,DetectionAntibodyStorageCondition],roundedCapillaryELISAOptionsAssociation];

	(* To check the case with solid-state detection antibody, we create a fake option association *)
	(* Here fakeDetectionantibodySateOption is not a defined module variable. *)
	missingDetectionAntibodyResuspensionOptionSolidChecks=mustNotNullOptionCheck[fakeDetectionAntibodyStateOption,Solid,Append[detectionAntibodyResuspensionOptions,DetectionAntibodyStorageCondition],Join[<|fakeDetectionAntibodyStateOption->detectionAntibodyStates|>,roundedCapillaryELISAOptionsAssociation]];

	(* Get a list of samples and antibodies with Null detection antibody resuspension options *)
	missingDetectionAntibodyResuspensionSamples=Union[PickList[mySamples,missingDetectionAntibodyResuspensionOptionChecks[[1]],False],PickList[mySamples,missingDetectionAntibodyResuspensionOptionSolidChecks[[1]],False]];
	missingDetectionAntibodyResuspensionAntibodies=Union[PickList[suppliedCustomDetectionAntibody,missingDetectionAntibodyResuspensionOptionChecks[[1]],False],PickList[suppliedCustomDetectionAntibody,missingDetectionAntibodyResuspensionOptionSolidChecks[[1]],False]];

	(* Get a list of detection antibody resuspension options with Null values. This covers the case when there is no invalid options *)
	missingDetectionAntibodyResuspensionOptions=Union[missingDetectionAntibodyResuspensionOptionChecks[[2]],missingDetectionAntibodyResuspensionOptionSolidChecks[[2]]];

	(* Throw error message if we get invalid samples and options *)
	If[!MatchQ[missingDetectionAntibodyResuspensionOptions,{}]&&messages,
		Message[Error::MustSpecifyDetectionAntibodyResuspensionOptions,ObjectToString[missingDetectionAntibodyResuspensionAntibodies,Cache->simulatedCache],ToString[missingDetectionAntibodyResuspensionOptions],ObjectToString[missingDetectionAntibodyResuspensionSamples,Cache->simulatedCache]];missingDetectionAntibodyResuspensionOptions,
		{}
	];

	(* If we are gathering tests, generate tests for invalid detection antibody resuspension related options. *)
	missingDetectionAntibodyResuspensionTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=If[Length[missingDetectionAntibodyResuspensionOptions]==Length[detectionAntibodyResuspensionOptions]+1,
				Nothing,
				Test["The DetectionAntibodyResuspension related options "<>ToString[Complement[detectionAntibodyResuspensionOptions,missingDetectionAntibodyResuspensionOptions]]<>" are not Null for the samples with DetectionAntibodyResuspension set to True:",True,True]
			];
			failingTest=If[Length[missingDetectionAntibodyResuspensionOptions]==0,
				Nothing,
				Test["The DetectionAntibodyResuspension related options "<>ToString[missingDetectionAntibodyResuspensionOptions]<>" are not Null for the detection antibody samples "<>ObjectToString[missingDetectionAntibodyResuspensionAntibodies,Cache->simulatedCache]<>" (used for ELISA assay of "<>ObjectToString[missingDetectionAntibodyResuspensionSamples,Cache->simulatedCache]<>") with DetectionAntibodyResuspension set to True:",True,False]
			];
			{passingTest,failingTest}
		],
		{}
	];


	(* 14 DetectionAntibody Conjugation Checks *)
	(* When DetectionAntibodyConjugation is set to Null or False, all DetectionAntibodyConjugation related options should be Null or Automatic. Get a list of samples with non-Null options and a list of non-Null options. Call helper function mustNullOptionCheck to get the lists. *)
	detectionAntibodyConjugationOptions={
		DetectionAntibodyVolume,
		BiotinReagent,
		BiotinReagentVolume,
		DetectionAntibodyConjugationBuffer,
		DetectionAntibodyConjugationBufferVolume,
		DetectionAntibodyConjugationContainer,
		DetectionAntibodyConjugationTime,
		DetectionAntibodyConjugationTemperature,
		DetectionAntibodyPurificationColumn,
		DetectionAntibodyColumnWashBuffer,
		DetectionAntibodyConjugationStorageCondition
	};

	invalidDetectionAntibodyConjugationRelatedOptionChecks=mustNullOptionCheck[DetectionAntibodyConjugation,Except[True|Automatic],detectionAntibodyConjugationOptions,roundedCapillaryELISAOptionsAssociation];

	(* Get a list of samples and antibodies with non-Null detection antibody conjugation options *)
	invalidDetectionAntibodyConjugationRelatedOptionSamples=PickList[mySamples,invalidDetectionAntibodyConjugationRelatedOptionChecks[[1]],False];
	invalidDetectionAntibodyConjugationRelatedOptionAntibodies=PickList[suppliedCustomDetectionAntibody,invalidDetectionAntibodyConjugationRelatedOptionChecks[[1]],False];

	(* Get a list of detection antibody Conjugation options with non-Null values. This covers the case when there is no invalid options *)
	invalidDetectionAntibodyConjugationOptions=invalidDetectionAntibodyConjugationRelatedOptionChecks[[2]];

	(* Throw error message if we get invalid samples and options *)
	If[!MatchQ[invalidDetectionAntibodyConjugationOptions,{}]&&messages,
		Message[Error::CannotSpecifyDetectionAntibodyConjugationOptions,ObjectToString[invalidDetectionAntibodyConjugationRelatedOptionAntibodies,Cache->simulatedCache],ToString[invalidDetectionAntibodyConjugationOptions],ObjectToString[invalidDetectionAntibodyConjugationRelatedOptionSamples,Cache->simulatedCache]];invalidDetectionAntibodyConjugationOptions,
		{}
	];

	(* If we are gathering tests, generate tests for invalid detection antibody Conjugation related options. *)
	invalidDetectionAntibodyConjugationTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=If[Length[invalidDetectionAntibodyConjugationOptions]==Length[DetectionAntibodyConjugationOptions],
				Nothing,
				Test["The detection antibody Conjugation related options "<>ToString[Complement[detectionAntibodyConjugationOptions,invalidDetectionAntibodyConjugationOptions]]<>" are Null for the detection antibody samples with DetectionAntibodyConjugation set to False or Null:",True,True]
			];
			failingTest=If[Length[invalidDetectionAntibodyConjugationOptions]==0,
				Nothing,
				Test["The detection antibody Conjugation related options "<>ToString[invalidDetectionAntibodyConjugationOptions]<>" are Null for the detection antibody samples "<>ObjectToString[invalidDetectionAntibodyConjugationRelatedOptionAntibodies,Cache->simulatedCache]<>" (used for ELISA assay with samples "<>ObjectToString[invalidDetectionAntibodyConjugationRelatedOptionSamples,Cache->simulatedCache]<>") with DetectionAntibodyConjugation set to False or Null:",True,False]
			];
			{passingTest,failingTest}
		],
		{}
	];

	(* When DetectionAntibodyConjugation is set to True, all DetectionAntibodyConjugation related options should be specified or Automatic. Get a list of samples with Null options and a list of Null options. Call helper function mustNotNullOptionCheck to get the lists. *)

	missingDetectionAntibodyConjugationRelatedOptionChecks=mustNotNullOptionCheck[DetectionAntibodyConjugation,True,detectionAntibodyConjugationOptions,roundedCapillaryELISAOptionsAssociation];

	(* Get a list of samples and antibodies with Null detection antibody conjugation options *)
	missingDetectionAntibodyConjugationRelatedOptionSamples=PickList[mySamples,missingDetectionAntibodyConjugationRelatedOptionChecks[[1]],False];
	missingDetectionAntibodyConjugationRelatedOptionAntibodies=PickList[suppliedCustomDetectionAntibody,missingDetectionAntibodyConjugationRelatedOptionChecks[[1]],False];

	(* Get a list of detection antibody Conjugation options with Null values. This covers the case when there is no missing options *)
	missingDetectionAntibodyConjugationOptions=missingDetectionAntibodyConjugationRelatedOptionChecks[[2]];

	(* Throw error message if we get missing samples and options *)
	If[!MatchQ[missingDetectionAntibodyConjugationOptions,{}]&&messages,
		Message[Error::MustSpecifyDetectionAntibodyConjugationOptions,ObjectToString[missingDetectionAntibodyConjugationRelatedOptionAntibodies,Cache->simulatedCache],ToString[missingDetectionAntibodyConjugationOptions],ObjectToString[missingDetectionAntibodyConjugationRelatedOptionSamples,Cache->simulatedCache]];missingDetectionAntibodyConjugationOptions,
		{}
	];

	(* If we are gathering tests, generate tests for missing detection antibody Conjugation related options. *)
	missingDetectionAntibodyConjugationTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=If[Length[missingDetectionAntibodyConjugationOptions]==Length[detectionAntibodyConjugationOptions],
				Nothing,
				Test["The detection antibody Conjugation related options "<>ToString[Complement[detectionAntibodyConjugationOptions,missingDetectionAntibodyConjugationOptions]]<>" are not Null for the detection antibody samples with DetectionAntibodyConjugation set to True:",True,True]
			];
			failingTest=If[Length[missingDetectionAntibodyConjugationOptions]==0,
				Nothing,
				Test["The detection antibody Conjugation related options "<>ToString[missingDetectionAntibodyConjugationOptions]<>" are Null for the detection antibody samples "<>ObjectToString[missingDetectionAntibodyConjugationRelatedOptionAntibodies,Cache->simulatedCache]<>" (used for ELISA assay with samples "<>ObjectToString[missingDetectionAntibodyConjugationRelatedOptionSamples,Cache->simulatedCache]<>") with DetectionAntibodyConjugation set to True:",True,False]
			];
			{passingTest,failingTest}
		],
		{}
	];

	(* We should not have a mixed Null/Not-Null conjugation options when DetectionAntibodyConjugation is set to Automatic. In that case, we cannot resolve the correct boolean value. Get the list of samples with a mixing set of options. *)
	detectionAntibodyConjugationOptionValues=Lookup[roundedCapillaryELISAOptionsAssociation,Prepend[detectionAntibodyConjugationOptions,DetectionAntibodyConjugation]];

	detectionAntibodyConjugationOptionConflictQ=MapThread[
		Function[
			{conjugation,antibodyVolume,conjugationReagent,conjugationReagentVolume,conjugationBuffer,conjugationBufferVolume,conjugationContainer,conjugationTime,conjugationTemperature,purificationColumn,washBuffer,storageCondition},
			If[MatchQ[conjugation,Automatic],
				And[
					MemberQ[{antibodyVolume,conjugationReagent,conjugationReagentVolume,conjugationBuffer,conjugationBufferVolume,conjugationContainer,conjugationTime,conjugationTemperature,purificationColumn,washBuffer,storageCondition},Null],
					MemberQ[{antibodyVolume,conjugationReagent,conjugationReagentVolume,conjugationBuffer,conjugationBufferVolume,conjugationContainer,conjugationTime,conjugationTemperature,purificationColumn,washBuffer,storageCondition},Except[Null|Automatic]]
				],
				False
			]
		],
		detectionAntibodyConjugationOptionValues
	];

	(* Get the list of samples with conflicting options *)
	detectionAntibodyConjugationOptionConflictSamples=PickList[mySamples,detectionAntibodyConjugationOptionConflictQ];
	detectionAntibodyConjugationOptionConflictAntibodies=PickList[suppliedCustomDetectionAntibody,detectionAntibodyConjugationOptionConflictQ];

	(* Throw error message if we get invalid samples and options *)
	detectionAntibodyConjugationConflictOptions=If[!MatchQ[detectionAntibodyConjugationOptionConflictSamples,{}]&&messages,
		Message[Error::ConflictDetectionAntibodyConjugationOptions,ObjectToString[detectionAntibodyConjugationOptionConflictAntibodies,Cache->simulatedCache],ObjectToString[detectionAntibodyConjugationOptionConflictSamples,Cache->simulatedCache]];detectionAntibodyConjugationOptions,
		{}
	];

	(* If we are gathering tests, generate tests for conflicting detection antibody Conjugation related options. *)
	detectionAntibodyConjugationOptionConflictTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=If[Length[detectionAntibodyConjugationOptionConflictSamples]==Length[simulatedSamples],
				Nothing,
				Test["DetectionAntibodyConjugation related options should be all Null or not Null for detection antibody samples "<>ObjectToString[PickList[mySamples,detectionAntibodyConjugationOptionConflictQ,False],Cache->simulatedCache]<>" (used for ELISA assay with samples "<>ObjectToString[PickList[suppliedCustomDetectionAntibody,detectionAntibodyConjugationOptionConflictQ,False],Cache->simulatedCache]<>") so the value of DetectionAntibodyConjugation option can be selected:",True,True]
			];
			failingTest=If[Length[detectionAntibodyConjugationOptionConflictSamples]==0,
				Nothing,
				Test["DetectionAntibodyConjugation related options should be all Null or not Null for detection antibody samples "<>ObjectToString[detectionAntibodyConjugationOptionConflictAntibodies,Cache->simulatedCache]<>" (used for ELISA assay with samples "<>ObjectToString[detectionAntibodyConjugationOptionConflictSamples,Cache->simulatedCache]<>") so the value of DetectionAntibodyConjugation option can be selected:",True,False]
			];
			{passingTest,failingTest}
		],
		{}
	];


	(* Note that we check the reaction ratio of antibody sample and conjugation reagent in the MapThread to avoid resolving the concentrations twice. *)
	(* Note that we check whether the total preparation volume of each conjugated detection antibody sample is larger than the MaxVolume of the specified DetectionAntibodyConjugationContainer, the specified DetectionAntibodyPurificationColumn and the specified DetectionAntibodyStorageContainer also within the MapThread. Because we need to resolve the concentrations and volumes, we don't want to perform the process twice for conflicting check. *)

	(* The specified DetectionAntibodyPurificationColumn is a supported spin column, preferrably 40 K MWCO *)
	(* TODO If we have a better plan later to put these spin columns into SPE, we can avoid hard-coding this list of supported spin columns. *)

	(* Right now, It is NOT a good idea to support regular filter as it will require getting the redundant at the top of the filter. Also, washing/collection of the sample will need more manipulations. *)
	(* We only support 6 different types of 7K/40K MWCO spin column, with different capacities. *)
	(* Check whether each of the supplied spin column is supported, with the first boolean indicating 7K/40K for error checking while the second boolean indicating 40K for warning *)
	suppliedDetectionAntibodyPurificationColumnMWCO=MapThread[
		{
			Or[
				MatchQ[#1,Automatic|Null],
				MatchQ[
					#2,
					ObjectP[potentialSpinColumns]
				],
				MatchQ[
					Lookup[#2,Model,Null],
					ObjectP[potentialSpinColumns]
				]
			],
			Or[
				MatchQ[#1,Automatic|Null],
				MatchQ[
					#2,
					ObjectP[potential40KSpinColumns]
				],
				MatchQ[
					Lookup[#2,Model,Null],
					ObjectP[potential40KSpinColumns]
				]
			]
		}&,
		{suppliedDetectionAntibodyPurificationColumn,suppliedDetectionAntibodyPurificationColumnPackets}
	];

	(* Throw an error message if we find a purification column that is not supported. *)
	unsupportedDetectionAntibodyPurificationColumnOption=If[MemberQ[suppliedDetectionAntibodyPurificationColumnMWCO,{False,False}]&&messages,
		Message[Error::UnsupportedDetectionAntibodyPurificationColumn,ObjectToString[PickList[suppliedCustomDetectionAntibody,suppliedDetectionAntibodyPurificationColumnMWCO,{False,False}],Cache->simulatedCache],ObjectToString[PickList[mySamples,suppliedDetectionAntibodyPurificationColumnMWCO,{False,False}],Cache->simulatedCache],ObjectToString[potential40KSpinColumns,Cache->simulatedCache]];{DetectionAntibodyPurificationColumn},
		Nothing
	];

	(* Throw a warning message if we find a purification column that is not 40K MWCO. We only throw warning when an error is not thrown*)
	If[MemberQ[suppliedDetectionAntibodyPurificationColumnMWCO,{True,False}]&&!MatchQ[$ECLApplication,Engine]&&messages,
		Message[Warning::NonOptimalDetectionAntibodyPurificationColumn,ObjectToString[PickList[suppliedCustomDetectionAntibody,suppliedDetectionAntibodyPurificationColumnMWCO,{True,False}],Cache->simulatedCache],ObjectToString[PickList[mySamples,suppliedDetectionAntibodyPurificationColumnMWCO,{True,False}],Cache->simulatedCache],ObjectToString[potential40KSpinColumns,Cache->simulatedCache]],
		Nothing
	];

	(* If we are gathering tests, generate tests for unsupported detection antibody purification column  *)
	unsupportedDetectionAntibodyPurificationColumnTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=Which[
				!resolvedCustomizableCartridgeQ,
				Test["The specified DetectionAntibodyPurificationColumn is a supported Zeba spin column (preferably 40K MWCO) for the detection antibody samples:",True,True],
				!MemberQ[suppliedDetectionAntibodyPurificationColumnMWCO,{True,_}],
				Nothing,
				True,
				Test["The specified DetectionAntibodyPurificationColumn is a supported Zeba spin column (preferably 40K MWCO) for the detection antibody samples "<>ObjectToString[PickList[suppliedCustomDetectionAntibody,suppliedDetectionAntibodyPurificationColumnMWCO,{True,_}],Cache->simulatedCache]<>", used for ELISA assay of the samples "<>ObjectToString[PickList[mySamples,suppliedDetectionAntibodyPurificationColumnMWCO,{True,_}],Cache->simulatedCache],True,True]
			];
			failingTest=If[!MemberQ[suppliedDetectionAntibodyPurificationColumnMWCO,{False,False}],
				Nothing,
				Test["The specified DetectionAntibodyPurificationColumn is a supported Zeba spin column (preferably 40K MWCO) for the detection antibody samples "<>ObjectToString[PickList[suppliedCustomDetectionAntibody,suppliedDetectionAntibodyPurificationColumnMWCO,{False,False}],Cache->simulatedCache]<>", used for ELISA assay of the samples "<>ObjectToString[PickList[mySamples,suppliedDetectionAntibodyPurificationColumnMWCO,{False,False}],Cache->simulatedCache],True,False]
			];
			{passingTest,failingTest}
		],
		{}
	];

	(* If we are gathering tests, generate tests for non-optimal detection antibody purification column *)
	nonOptimalDetectionAntibodyPurificationColumnTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=Which[
				!resolvedCustomizableCartridgeQ,
				Test["The specified DetectionAntibodyPurificationColumn is 40K MWCO for the detection antibody samples:",True,True],
				!MemberQ[suppliedDetectionAntibodyPurificationColumnMWCO,{True,True}],
				Nothing,
				True,
				Test["The specified DetectionAntibodyPurificationColumn is 40K MWCO for the detection antibody samples "<>ObjectToString[PickList[suppliedCustomDetectionAntibody,suppliedDetectionAntibodyPurificationColumnMWCO,{True,True}],Cache->simulatedCache]<>", used for ELISA assay of the samples "<>ObjectToString[PickList[mySamples,suppliedDetectionAntibodyPurificationColumnMWCO,{True,True}],Cache->simulatedCache],True,True]
			];
			failingTest=If[!MemberQ[suppliedDetectionAntibodyPurificationColumnMWCO,{_,False}],
				Nothing,
				Test["The specified DetectionAntibodyPurificationColumn is 40K MWCO for the detection antibody samples "<>ObjectToString[PickList[suppliedCustomDetectionAntibody,suppliedDetectionAntibodyPurificationColumnMWCO,{_,False}],Cache->simulatedCache]<>", used for ELISA assay of the samples "<>ObjectToString[PickList[mySamples,suppliedDetectionAntibodyPurificationColumnMWCO,{_,False}],Cache->simulatedCache],True,False]
			];
			{passingTest,failingTest}
		],
		{}
	];


	(* 15 DetectionAntibody Dilution Checks *)
	(* When DetectionAntibodyDilution is set to Null, all DetectionAntibodyDilution related options should be Null or Automatic. Get a list of samples with non-Null options and a list of non-Null options. Call helper function mustNullOptionCheck to get the lists. *)
	detectionAntibodyDilutionOptions={DetectionAntibodyTargetConcentration,DetectionAntibodyDiluent};

	invalidDetectionAntibodyDilutionRelatedOptionChecks=mustNullOptionCheck[DetectionAntibodyDilution,Null|False,detectionAntibodyDilutionOptions,roundedCapillaryELISAOptionsAssociation];

	(* Get a list of samples and antibodies with non-Null detection antibody Dilution options *)
	invalidDetectionAntibodyDilutionRelatedOptionSamples=PickList[mySamples,invalidDetectionAntibodyDilutionRelatedOptionChecks[[1]],False];
	invalidDetectionAntibodyDilutionRelatedOptionAntibodies=PickList[suppliedCustomDetectionAntibody,invalidDetectionAntibodyDilutionRelatedOptionChecks[[1]],False];

	(* Get a list of detection antibody Dilution options with non-Null values. This covers the case when there is no invalid options *)
	invalidDetectionAntibodyDilutionOptions=invalidDetectionAntibodyDilutionRelatedOptionChecks[[2]];

	(* Throw error message if we get invalid samples and options *)
	If[!MatchQ[invalidDetectionAntibodyDilutionOptions,{}]&&messages,
		Message[Error::CannotSpecifyDetectionAntibodyDilutionOptions,ObjectToString[invalidDetectionAntibodyDilutionRelatedOptionAntibodies,Cache->simulatedCache],ToString[invalidDetectionAntibodyDilutionOptions],ObjectToString[invalidDetectionAntibodyDilutionRelatedOptionSamples,Cache->simulatedCache]];invalidDetectionAntibodyDilutionOptions,
		{}
	];

	(* If we are gathering tests, generate tests for invalid detection antibody Dilution related options. *)
	invalidDetectionAntibodyDilutionTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=If[Length[invalidDetectionAntibodyDilutionOptions]==Length[detectionAntibodyDilutionOptions],
				Nothing,
				Test["The detection antibody dilution related options "<>ToString[Complement[detectionAntibodyDilutionOptions,invalidDetectionAntibodyDilutionOptions]]<>" are Null for the detection antibody samples with DetectionAntibodyDilution set to Null or False:",True,True]
			];
			failingTest=If[Length[invalidDetectionAntibodyDilutionOptions]==0,
				Nothing,
				Test["The detection antibody Dilution related options "<>ToString[invalidDetectionAntibodyDilutionOptions]<>" are Null for the detection antibody samples "<>ObjectToString[invalidDetectionAntibodyDilutionRelatedOptionAntibodies,Cache->simulatedCache]<>" (used for ELISA assay with samples "<>ObjectToString[invalidDetectionAntibodyDilutionRelatedOptionSamples,Cache->simulatedCache]<>") with DetectionAntibodyDilution set to Null or False:",True,False]
			];
			{passingTest,failingTest}
		],
		{}
	];

	(* When the detection antibody sample goes through either resuspension or conjugation process in this protocol, it is recommend to do dilution - DetectionAntibodyDilution is not set to Null/False. *)
	missingRecommendedDetectionAntibodyDilutionQ=MapThread[
		MatchQ[{Lookup[#1,State,Null],#2,#3},{Solid,_,Null|False}|{_,True,Null|False}]&,
		{suppliedCustomDetectionAntibodyPackets,suppliedDetectionAntibodyConjugation,suppliedDetectionAntibodyDilution}
	];

	(* Get a list of samples and antibodies with null detection antibody dilution option but a dilution is recommended *)
	missingRecommendedDetectionAntibodyDilutionSamples=PickList[mySamples,missingRecommendedDetectionAntibodyDilutionQ];
	missingRecommendedDetectionAntibodyDilutionAntibodies=PickList[suppliedCustomDetectionAntibody,missingRecommendedDetectionAntibodyDilutionQ];

	(* Throw warning message if we get samples for which a dilution is recommended *)
	If[!MatchQ[missingRecommendedDetectionAntibodyDilutionSamples,{}]&&!MatchQ[$ECLApplication,Engine]&&messages,
		Message[Warning::DetectionAntibodyDilutionRecommended,ObjectToString[missingRecommendedDetectionAntibodyDilutionAntibodies,Cache->simulatedCache],ObjectToString[missingRecommendedDetectionAntibodyDilutionSamples,Cache->simulatedCache]],
		Nothing
	];

	(* If we are gathering tests, generate tests for the samples for which a dilution is recommended *)
	missingRecommendedDetectionAntibodyDilutionTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=Which[
				!resolvedCustomizableCartridgeQ,
				Test["The DetectionAntibodyDilution option is not Null for the detection antibody samples when it is either resuspended or conjugated in this protocol:",True,True],
				Length[missingRecommendedDetectionAntibodyDilutionSamples]==Length[simulatedSamples],
				Nothing,
				True,
				Test["The DetectionAntibodyDilution option is not Null for the detection antibody samples "<>ObjectToString[Complement[suppliedCustomDetectionAntibody,missingRecommendedDetectionAntibodyDilutionAntibodies],Cache->simulatedCache]<>" (for ELISA assay of "<>ObjectToString[Complement[mySamples,missingRecommendedDetectionAntibodyDilutionSamples],Cache->simulatedCache]<>") when it is either resuspended or conjugated in this protocol:",True,True]
			];
			failingTest=If[Length[invalidDetectionAntibodyDilutionOptions]==0,
				Nothing,
				Test["The DetectionAntibodyDilution option is not Null for the detection antibody samples "<>ObjectToString[missingRecommendedDetectionAntibodyDilutionAntibodies,Cache->simulatedCache]<>" (for ELISA assay of "<>ObjectToString[missingRecommendedDetectionAntibodyDilutionSamples,Cache->simulatedCache]<>") when it is either resuspended or conjugated in this protocol:",True,False]
			];
			{passingTest,failingTest}
		],
		{}
	];

	(* When DetectionAntibodyDilution is True, DetectionAntibodyTargetConcentration and DetectionAntibodyDiluent should not be Null. Get a list of samples with Null option. Call helper function mustNotNullOptionCheck to get the lists. *)
	missingDetectionAntibodyDilutionOptionsChecks=mustNotNullOptionCheck[DetectionAntibodyDilution,Except[Null|Automatic],detectionAntibodyDilutionOptions,roundedCapillaryELISAOptionsAssociation];

	(* Get a list of samples and antibodies with Null DetectionAntibodyDiluent *)
	missingDetectionAntibodyDilutionOptionsSamples=PickList[mySamples,missingDetectionAntibodyDilutionOptionsChecks[[1]],False];
	missingDetectionAntibodyDilutionOptionsAntibodies=PickList[suppliedCustomDetectionAntibody,missingDetectionAntibodyDilutionOptionsChecks[[1]],False];

	(* Get a list of detection antibody Dilution options with Null values. This covers the case when there is no invalid options *)
	missingDetectionAntibodyDilutionOptions=missingDetectionAntibodyDilutionOptionsChecks[[2]];

	(* Throw error message if we get invalid samples and options *)
	If[!MatchQ[missingDetectionAntibodyDilutionOptions,{}]&&messages,
		Message[Error::MustSpecifyDetectionAntibodyDilutionOptions,
			ObjectToString[missingDetectionAntibodyDilutionOptionsAntibodies,Cache->simulatedCache],
			missingDetectionAntibodyDilutionOptions,
			ObjectToString[missingDetectionAntibodyDilutionOptionsSamples,Cache->simulatedCache]];missingDetectionAntibodyDilutionOptions,
		{}
	];

	(* If we are gathering tests, generate tests for missing DetectionAntibodyDiluent. *)
	missingDetectionAntibodyDilutionOptionTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=If[Length[missingDetectionAntibodyDilutionOptions]==Length[detectionAntibodyDilutionOptions],
				Nothing,
				Test["The detection antibody dilution related options "<>ToString[Complement[detectionAntibodyDilutionOptions,missingDetectionAntibodyDilutionOptions]]<>" are not Null for the detection antibody samples with DetectionAntibodyDilution set True:",True,True]
			];
			failingTest=If[Length[missingDetectionAntibodyDilutionOptions]==0,
				Nothing,
				Test["The DetectionAntibodyDiluent options "<>ToString[missingDetectionAntibodyDilutionOptions]<>" are not Null for the detection antibody samples "<>ObjectToString[missingDetectionAntibodyDilutionOptionsAntibodies,Cache->simulatedCache]<>" (for ELISA assay of "<>ObjectToString[missingDetectionAntibodyDilutionOptionsSamples,Cache->simulatedCache]<>") when its DetectionAntibodyDilution is not Null:",True,False]
			];
			{passingTest,failingTest}
		],
		{}
	];

	(* We should not have a mixed Null/Not-Null dilution options when DetectionAntibodyDilution is set to Automatic. In that case, we cannot resolve the correct boolean value. Get the list of samples with a mixing set of options. *)
	detectionAntibodyDilutionOptionValues=Lookup[roundedCapillaryELISAOptionsAssociation,Prepend[detectionAntibodyDilutionOptions,DetectionAntibodyDilution]];

	detectionAntibodyDilutionOptionConflictQ=MapThread[
		MatchQ[{#1,#2,#3},{Automatic,Except[Null|Automatic],Null}|{Automatic,Null,Except[Null|Automatic]}]&,
		detectionAntibodyDilutionOptionValues
	];

	(* Get the list of samples with conflicting options *)
	detectionAntibodyDilutionOptionConflictSamples=PickList[mySamples,detectionAntibodyDilutionOptionConflictQ];
	detectionAntibodyDilutionOptionConflictAntibodies=PickList[suppliedCustomDetectionAntibody,detectionAntibodyDilutionOptionConflictQ];

	(* Throw error message if we get invalid samples and options *)
	detectionAntibodyDilutionConflictOptions=If[!MatchQ[detectionAntibodyDilutionOptionConflictSamples,{}]&&messages,
		Message[Error::ConflictDetectionAntibodyDilutionOptions,ObjectToString[detectionAntibodyDilutionOptionConflictAntibodies,Cache->simulatedCache],ObjectToString[detectionAntibodyDilutionOptionConflictSamples,Cache->simulatedCache]];detectionAntibodyDilutionOptions,
		{}
	];

	(* If we are gathering tests, generate tests for conflicting detection antibody dilution related options. *)
	detectionAntibodyDilutionOptionConflictTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=If[Length[detectionAntibodyDilutionOptionConflictSamples]==Length[simulatedSamples],
				Nothing,
				Test["DetectionAntibodyTargetConcentration and DetectionAntibodyDiluent options should be both Null or not Null for detection antibody samples "<>ObjectToString[PickList[mySamples,detectionAntibodyDilutionOptionConflictQ,False],Cache->simulatedCache]<>" (used for ELISA assay with samples "<>ObjectToString[PickList[suppliedCustomDetectionAntibody,detectionAntibodyDilutionOptionConflictQ,False],Cache->simulatedCache]<>") so the value of DetectionAntibodyDilution option can be selected:",True,True]
			];
			failingTest=If[Length[detectionAntibodyDilutionOptionConflictSamples]==0,
				Nothing,
				Test["DetectionAntibodyTargetConcentration and DetectionAntibodyDiluent options should be both Null or not Null for detection antibody samples "<>ObjectToString[detectionAntibodyDilutionOptionConflictAntibodies,Cache->simulatedCache]<>" (used for ELISA assay with samples "<>ObjectToString[detectionAntibodyDilutionOptionConflictSamples,Cache->simulatedCache]<>") so the value of DetectionAntibodyDilution option can be selected:",True,False]
			];
			{passingTest,failingTest}
		],
		{}
	];

	(* DetectionAntibodyDiluent should be Model[Sample,  "Simple Plex Reagent Diluent"] for optimized result. Get a list of samples with non-optimized detection antibody diluent. *)
	nonOptimalDetectionAntibodyDiluentQ=Map[
		!MatchQ[#,Automatic|Null|Model[Sample, "id:pZx9jo8LZ7z5"]]&, (* Model[Sample,"Simple Plex Reagent Diluent"] *)
		suppliedDetectionAntibodyDiluentModels
	];

	(* Get a list of samples and antibodies with DetectionAntibodyDiluent not set to Model[Sample, "Simple Plex Reagent Diluent"]  or an object with this model *)
	nonOptimalDetectionAntibodyDiluentSamples=PickList[mySamples,nonOptimalDetectionAntibodyDiluentQ];
	nonOptimalDetectionAntibodyDiluentAntibodies=PickList[suppliedCustomDetectionAntibody,nonOptimalDetectionAntibodyDiluentQ];

	(* Throw warning message is we get a non-optimal diluent *)
	If[MemberQ[nonOptimalDetectionAntibodyDiluentQ,True]&&!MatchQ[$ECLApplication,Engine]&&messages,
		Message[Warning::NonOptimalDetectionAntibodyDiluent,ObjectToString[nonOptimalDetectionAntibodyDiluentAntibodies,Cache->simulatedCache],ObjectToString[nonOptimalDetectionAntibodyDiluentSamples,Cache->simulatedCache]];{DetectionAntibodyDiluent},
		{}
	];

	(* If we are gathering tests, generate tests for non-optimal DetectionAntibodyDiluent. *)
	nonOptimalDetectionAntibodyDiluentTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=Which[
				!resolvedCustomizableCartridgeQ,
				Test["The DetectionAntibodyDiluent option is kept as Model[Sample,\"Simple Plex Reagent Diluent\"] or a sample with this model for the detection antibody samples:",True,True],
				Length[nonOptimalDetectionAntibodyDiluentSamples]==Length[simulatedSamples],
				Nothing,
				True,
				Test["The DetectionAntibodyDiluent option is kept as Model[Sample,\"Simple Plex Reagent Diluent\"] or a sample with this model for the detection antibody samples "<>ObjectToString[Complement[suppliedCustomDetectionAntibody,nonOptimalDetectionAntibodyDiluentAntibodies],Cache->simulatedCache]<>" (for ELISA assay of "<>ObjectToString[Complement[mySamples,nonOptimalDetectionAntibodyDiluentSamples],Cache->simulatedCache]<>") for optimized dilution and ELISA results:",True,True]
			];
			failingTest=If[Length[nonOptimalDetectionAntibodyDiluentSamples]==0,
				Nothing,
				Test["The DetectionAntibodyDiluent option is kept as Model[Sample,\"Simple Plex Reagent Diluent\"] or a sample with this model for the detection antibody samples "<>ObjectToString[nonOptimalDetectionAntibodyDiluentAntibodies,Cache->simulatedCache]<>" (for ELISA assay of "<>ObjectToString[nonOptimalDetectionAntibodyDiluentSamples,Cache->simulatedCache]<>") for optimized dilution and ELISA results:",True,False]
			];
			{passingTest,failingTest}
		],
		{}
	];

	(* When DetectionAntibody is not Null, DetectionAntibodyLoadingVolume should not be Null. Get a list of samples with Null option. Call helper function mustNotNullOptionCheck to get the lists. *)
	missingDetectionAntibodyLoadingVolumeChecks=mustNotNullOptionCheck[CustomDetectionAntibody,Except[Null|Automatic],{DetectionAntibodyLoadingVolume},roundedCapillaryELISAOptionsAssociation][[1]];

	(* Get a list of samples and antibodies with Null DetectionAntibodyLoadingVolume *)
	missingDetectionAntibodyLoadingVolumeSamples=PickList[mySamples,missingDetectionAntibodyLoadingVolumeChecks,False];
	missingDetectionAntibodyLoadingVolumeAntibodies=PickList[suppliedCustomDetectionAntibody,missingDetectionAntibodyLoadingVolumeChecks,False];

	(* Throw error message if we get invalid samples and options *)
	missingDetectionAntibodyLoadingVolumeOption=If[!MatchQ[missingDetectionAntibodyLoadingVolumeSamples,{}]&&messages,
		Message[Error::MustSpecifyDetectionAntibodyLoadingVolume,ObjectToString[missingDetectionAntibodyLoadingVolumeAntibodies,Cache->simulatedCache],ObjectToString[missingDetectionAntibodyLoadingVolumeSamples,Cache->simulatedCache]];{DetectionAntibodyLoadingVolume},
		{}
	];

	(* If we are gathering tests, generate tests for missing DetectionAntibodyLoadingVolume. *)
	missingDetectionAntibodyLoadingVolumeTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=Which[
				!resolvedCustomizableCartridgeQ,
				Test["When a customizable cartridge is used, the DetectionAntibodyLoadingVolume option is not Null for the detection antibody samples:",True,True],
				Length[missingDetectionAntibodyLoadingVolumeSamples]==Length[simulatedSamples],
				Nothing,
				True,
				Test["When a customizable cartridge is used, the DetectionAntibodyLoadingVolume option is not Null for the detection antibody samples "<>ObjectToString[Complement[suppliedCustomDetectionAntibody,missingDetectionAntibodyLoadingVolumeAntibodies],Cache->simulatedCache]<>", used for ELISA assay of "<>ObjectToString[Complement[mySamples,missingDetectionAntibodyLoadingVolumeSamples],Cache->simulatedCache],True,True]
			];
			failingTest=If[Length[missingDetectionAntibodyLoadingVolumeSamples]==0,
				Nothing,
				Test["When a customizable cartridge is used, the DetectionAntibodyLoadingVolume option is not Null for the detection antibody samples "<>ObjectToString[missingDetectionAntibodyLoadingVolumeAntibodies,Cache->simulatedCache]<>", used for ELISA assay of "<>ObjectToString[missingDetectionAntibodyLoadingVolumeSamples,Cache->simulatedCache],True,False]
			];
			{passingTest,failingTest}
		],
		{}
	];


    (* 16 Standard Check *)

	(* Standard cannot have a Null member. This is a weird test but this is actually allowed in Command Center. Setting a member to Null will mess up with resolving options. *)
	nullStandardMemberOption=If[!MatchQ[suppliedStandard,Automatic|Null|{}]&&MemberQ[suppliedStandard,Null]&&messages,
		Message[Error::CannotSpecifyNullStandard];{Standard},
		{}
	];

	(* If we are gathering tests, generate tests for having a Null member Standard *)
	nullStandardMemberTests=If[gatherTests,
		Test["The specified Standard option should not have Null member:",MatchQ[nullStandardMemberOption,{}],True],
		{}
	];

    (* When Standard is set to Null, all Standard related options should be Null or Automatic *)
    nullStandardRelatedOptionsQ=If[MatchQ[suppliedStandard,Null],
        Map[
            MatchQ[Lookup[roundedCapillaryELISAOptionsAssociation,#],Null|Automatic]&,
            standardOptions
        ],
        ConstantArray[True,Length[standardOptions]]
    ];

    (* Using PickList to find the options that are not Null/Automatic *)
    invalidStandardOptions=PickList[standardOptions,nullStandardRelatedOptionsQ,False];

    (* Track invalid option and throw message for incomplete Standard *)
    If[!MatchQ[invalidStandardOptions,{}]&&messages,
        Message[Error::CannotSpecifyStandardOptions,ToString[invalidStandardOptions]],
        Nothing
    ];

    (* If we are gathering tests, generate tests for invalid standard related options *)
    invalidStandardTests=If[gatherTests,
        Module[{passingTest,failingTest},
            passingTest=If[Length[invalidStandardOptions]==Length[standardOptions],
                Nothing,
                Test["The standard related options "<>ToString[PickList[standardOptions,nullStandardRelatedOptionsQ]]<>" are Null or Automatic when Standard is Null:",True,True]
            ];
            failingTest=If[Length[invalidStandardOptions]==0,
                Nothing,
                Test["The standard related options "<>ToString[invalidStandardOptions]<>" are Null or Automatic when Standard is Null:",True,False]
            ];
            {passingTest,failingTest}
        ],
        {}
    ];


    (* 17 Standard Resuspension Check *)
    (* StandardResuspension must be in accordance with the state of Standard sample - True for solid sample and False for liquid sample *)
	standardStates=If[!MatchQ[suppliedStandard,Null|Automatic|{}],
		Map[
			If[MatchQ[#1,Null],
				Null,
				Lookup[#1,State,Null]
			]&,
			suppliedStandardPackets
		],
		{}
	];

	(* Check solid state standard samples *)
    solidStandardResuspensionValidQ=If[!MatchQ[suppliedStandard,Null|Automatic|{}],
        MapThread[
			If[MatchQ[#1,Null],
				True,
            	MatchQ[{Lookup[#1,State,Null],#2},{Solid,True|Automatic}|{Except[Solid],_}]
			]&,
            {suppliedStandardPackets,suppliedStandardResuspension}
        ],
        {}
    ];
    (* Check liquid state standard samples *)
    liquidStandardResuspensionValidQ=If[!MatchQ[suppliedStandard,Null|Automatic|{}],
        MapThread[
			If[MatchQ[#1,Null],
				True,
            	MatchQ[{Lookup[#1,State,Null],#2},{Liquid,Except[True]}|{Except[Liquid],_}]
			]&,
            {suppliedStandardPackets,suppliedStandardResuspension}
        ],
        {}
    ];

    (* Find the standard samples with invalid StandardResuspension *)
    solidStandardResuspensionInvalidSamples=If[MemberQ[solidStandardResuspensionValidQ,False],
        PickList[ToList[suppliedStandard],solidStandardResuspensionValidQ,False],
        {}
    ];
    liquidStandardResuspensionInvalidSamples=If[MemberQ[liquidStandardResuspensionValidQ,False],
        PickList[ToList[suppliedStandard],liquidStandardResuspensionValidQ,False],
        {}
    ];
    standardResuspensionInvalidSamples=Union[solidStandardResuspensionInvalidSamples,liquidStandardResuspensionInvalidSamples];
    
    (* Track the invalid option and throw messages *)
    solidStandardResuspensionInvalidOption=If[!MatchQ[solidStandardResuspensionInvalidSamples,{}]&&messages,
        Message[Error::InvalidStandardResuspensionForSolid,ObjectToString[solidStandardResuspensionInvalidSamples,Cache->simulatedCache]];{StandardResuspension},
		{}
    ];
    liquidStandardResuspensionInvalidOption=If[!MatchQ[liquidStandardResuspensionInvalidSamples,{}]&&messages,
        Message[Error::InvalidStandardResuspensionForLiquid,ObjectToString[liquidStandardResuspensionInvalidSamples,Cache->simulatedCache]];{StandardResuspension},
		{}
    ];

    (* If we are gathering tests, generate tests for invalid standard resuspensions *)
    standardResuspensionInvalidTests=If[gatherTests,
        Module[{passingTest,failingTest},
            passingTest=Which[
                MatchQ[suppliedStandard,Automatic|Null|{}],
                Test["StandardResuspension is True for solid state standard samples and not True for liquid state standard samples to resuspend only solid state samples:",True,True],
                Length[standardResuspensionInvalidSamples]==Length[suppliedStandard],
                Nothing,
                True,
                Test["StandardResuspension is True for solid state standard samples and not True for liquid state standard samples "<>ObjectToString[Complement[suppliedStandard,standardResuspensionInvalidSamples],Cache->simulatedCache]<>" to resuspend only solid state samples:",True,True]
            ];
            failingTest=If[Length[standardResuspensionInvalidSamples]==0,
                Nothing,
                Test["StandardResuspension is True for solid state standard samples and not True for liquid state standard samples "<>ObjectToString[standardResuspensionInvalidSamples,Cache->simulatedCache]<>" to resuspend only solid state samples:",True,False]
            ];
            {passingTest,failingTest}
        ],
        {}
    ];

    (* When StandardResuspension is set to Null or False, all StandardResuspension related options should be Null or Automatic. Get a list of standard samples with non-Null options and a list of non-Null options. Call helper function mustNullOptionCheck to get the lists. *)
    standardResuspensionOptions={StandardResuspensionConcentration,StandardResuspensionDiluent,StandardStorageCondition};

	(* We need to check the following cases: When StandardResuspension is not True or Automatic, standard resuspension options should be Null. If StandardResuspension is Automatic but the Standard is in liquid state, the same. *)
	invalidStandardResuspensionRelatedOptionChecks=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
        mustNullOptionCheck[StandardResuspension,Except[True|Automatic],standardResuspensionOptions,roundedCapillaryELISAOptionsAssociation],
        {{},{}}
    ];

	(* To check the case with liquid-state capture antibody, we create a fake option association *)
	(* Here fakeStandardStateOption is not a defined module variable. *)
	invalidStandardResuspensionRelatedOptionLiquidChecks=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		mustNullOptionCheck[fakeStandardStateOption,Liquid,standardResuspensionOptions,Join[<|fakeStandardStateOption->standardStates|>,roundedCapillaryELISAOptionsAssociation]],
		{{},{}}
	];

    (* Get a list of samples with non-Null standard resuspension options *)
    invalidStandardResuspensionRelatedOptionSamples=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		Union[PickList[ToList[suppliedStandard],invalidStandardResuspensionRelatedOptionChecks[[1]],False],PickList[ToList[suppliedStandard],invalidStandardResuspensionRelatedOptionLiquidChecks[[1]],False]],
        {}
    ];

    (* Get a list of standard resuspension options with non-Null values. This covers the case when there is no invalid options *)
    invalidStandardResuspensionOptions=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		Union[invalidStandardResuspensionRelatedOptionChecks[[2]],invalidStandardResuspensionRelatedOptionLiquidChecks[[2]]],
		{}
	];

    (* Throw error message if we get invalid samples and options *)
    If[!MatchQ[invalidStandardResuspensionOptions,{}]&&messages,
        Message[Error::CannotSpecifyStandardResuspensionOptions,ObjectToString[invalidStandardResuspensionRelatedOptionSamples,Cache->simulatedCache],ToString[invalidStandardResuspensionOptions]];invalidStandardResuspensionOptions,
        {}
    ];

    (* If we are gathering tests, generate tests for invalid standard resuspension related options. *)
    invalidStandardResuspensionTests=If[gatherTests,
        Module[{passingTest,failingTest},
            passingTest=If[Length[invalidStandardResuspensionOptions]==Length[standardResuspensionOptions],
                Nothing,
                Test["The standard resuspension related options "<>ToString[Complement[standardResuspensionOptions,invalidStandardResuspensionOptions]]<>" are Null for the samples with a liquid state or with StandardResuspension option set to False or Null:",True,True]
            ];
            failingTest=If[Length[invalidStandardResuspensionOptions]==0,
                Nothing,
                Test["The standard resuspension related options "<>ToString[invalidStandardResuspensionOptions]<>" are Null for the samples "<>ObjectToString[invalidStandardResuspensionRelatedOptionSamples,Cache->simulatedCache]<>" with a liquid state or with StandardResuspension option set to False or Null:",True,False]
            ];
            {passingTest,failingTest}
        ],
        {}
    ];

	(* When StandardResuspension is set to True, all StandardResuspension related options should be specified or Automatic. Get a list of samples with Null options and a list of Null options. Call helper function mustNotNullOptionCheck to get the lists. *)
	missingStandardResuspensionOptionChecks=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		mustNotNullOptionCheck[StandardResuspension,True,standardResuspensionOptions,roundedCapillaryELISAOptionsAssociation],
		{{},{}}
	];

	(* To check the case with solid-state standard, we create a fake option association *)
	(* Here fakeStandardStateOption is not a defined module variable. *)
	missingStandardResuspensionOptionSolidChecks=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		mustNotNullOptionCheck[fakeStandardStateOption,Solid,standardResuspensionOptions,Join[<|fakeStandardStateOption->standardStates|>,roundedCapillaryELISAOptionsAssociation]],
		{{},{}}
	];

	(* Get a list of samples and antibodies with Null standard resuspension options *)
	missingStandardResuspensionSamples=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		Union[PickList[ToList[suppliedStandard],missingStandardResuspensionOptionChecks[[1]],False],PickList[ToList[suppliedStandard],missingStandardResuspensionOptionSolidChecks[[1]],False]],
		{}
	];

	(* Get a list of standard resuspension options with Null values. This covers the case when there is no invalid options *)
	missingStandardResuspensionOptions=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		Union[missingStandardResuspensionOptionChecks[[2]],missingStandardResuspensionOptionSolidChecks[[2]]],
		{}
	];

	(* Throw error message if we get invalid samples and options *)
	If[!MatchQ[missingStandardResuspensionOptions,{}]&&messages,
		Message[Error::MustSpecifyStandardResuspensionOptions,ObjectToString[missingStandardResuspensionSamples,Cache->simulatedCache],ToString[missingStandardResuspensionOptions]];missingStandardResuspensionOptions,
		{}
	];

	(* If we are gathering tests, generate tests for invalid standard resuspension related options. *)
	missingStandardResuspensionTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=If[Length[missingStandardResuspensionOptions]==Length[standardResuspensionOptions],
				Nothing,
				Test["The StandardResuspension related options "<>ToString[Complement[standardResuspensionOptions,missingStandardResuspensionOptions]]<>" are not Null for the samples with StandardResuspension set to True:",True,True]
			];
			failingTest=If[Length[missingStandardResuspensionOptions]==0,
				Nothing,
				Test["The StandardResuspension related options "<>ToString[missingStandardResuspensionOptions]<>" are not Null for the standard samples "<>ObjectToString[missingStandardResuspensionSamples,Cache->simulatedCache]<>" with StandardResuspension set to True:",True,False]
			];
			{passingTest,failingTest}
		],
		{}
	];


    (* Note that we check whether the resuspension concentration for a pre-loaded cartridge analyte is optimal inside the MapThread to avoid repeating the Lookup process twice. *)

    (* TODO: Think about how to add a conflict check for resuspension required volume over the volume limit of the solid sample's container. In most cases, we cannot know the details about the container until the sample arrives. Also, it is really rare to have a large volume for resuspension. This is skipped for now. *)

    (* Note that we check whether the diluent and the default diluent for a pre-loaded cartridge analyte are the same inside the MapThread using a Boolean tracker to avoid doing the process twice. *)


    (* 18 Standard Dilution and Composition Check *)
	(* When Standard is not Null, Standard related options should not be Null *)
	missingStandardRelatedOptionsChecks=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		mustNotNullOptionCheck[Standard,Except[Null|Automatic],{StandardDiluent,StandardDilutionMixVolume,StandardDilutionNumberOfMixes,StandardDilutionMixRate,StandardLoadingVolume,StandardComposition},roundedCapillaryELISAOptionsAssociation],
		{{},{}}
	];

	(* Get a list of standard samples with Null options *)
	missingStandardRelatedOptionsSamples=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		PickList[ToList[suppliedStandard],missingStandardRelatedOptionsChecks[[1]],False],
		{}
	];

	(* Find the options that are Null *)
	missingStandardRelatedOptions=missingStandardRelatedOptionsChecks[[2]];

	(* Track invalid option and throw message for incomplete Standard *)
	If[!MatchQ[missingStandardRelatedOptions,{}]&&messages,
		Message[Error::MustSpecifyStandardOptions,ToString[missingStandardRelatedOptions],ObjectToString[missingStandardRelatedOptionsSamples,Cache->simulatedCache]],
		Nothing
	];

	(* If we are gathering tests, generate tests for invalid standard related options *)
	missingStandardRelatedOptionsTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=If[Length[missingStandardRelatedOptions]==Length[{StandardDiluent,StandardDilutionMixVolume,StandardDilutionNumberOfMixes,StandardDilutionMixRate,StandardLoadingVolume,StandardComposition}],
				Nothing,
				Test["The standard related options "<>ToString[PickList[standardOptions,nullStandardRelatedOptionsQ]]<>" are not Null when Standard is uploaded:",True,True]
			];
			failingTest=If[Length[invalidStandardOptions]==0,
				Nothing,
				Test["The standard related options "<>ToString[invalidStandardOptions]<>" are not Null for standard samples "<>ObjectToString[missingStandardRelatedOptionsSamples,Cache->simulatedCache],True,False]
			];
			{passingTest,failingTest}
		],
		{}
	];

	(* One of StandardDilutionCurve and StandardSerialDilutionCurve must be populated *)
	conflictStandardDilutionCurveQ=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		MapThread[
			!MatchQ[{#1,#2},{Null|Automatic,Except[Null]}|{Except[Null],Null|Automatic}]&,
			{suppliedStandardDilutionCurve,suppliedStandardSerialDilutionCurve}
		],
		{}
	];

	(* Track the invalid option and throw error message for conflicting standard dilution curve options *)
	conflictStandardDilutionCurveOptions=If[MemberQ[conflictStandardDilutionCurveQ,True]&&messages,
		Message[Error::ConflictStandardDilutionCurve,ObjectToString[PickList[ToList[suppliedStandard],conflictStandardDilutionCurveQ],Cache->simulatedCache]];{StandardDilutionCurve,StandardSerialDilutionCurve},
		{}
	];

	(* If we are gathering tests, generate tests for conflicting standard dilution curve options *)
	conflictStandardDilutionCurveTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=Which[
				MatchQ[suppliedStandard,Null|{}|Automatic],
				Test["Only one of StandardDilutionCurve and StandardSerialDilutionCurve can be specified or Null for standard samples:",True,True],
				MemberQ[conflictStandardDilutionCurveQ,False],
				Test["Only one of StandardDilutionCurve and StandardSerialDilutionCurve can be specified or Null for standard samples "<>ObjectToString[PickList[ToList[suppliedStandard],conflictStandardDilutionCurveQ,False],Cache->simulatedCache],True,True],
				True,
				Nothing
			];
			failingTest=If[MemberQ[conflictStandardDilutionCurveQ,True],
				Test["Only one of StandardDilutionCurve and StandardSerialDilutionCurve can be specified or Null for standard samples "<>ObjectToString[PickList[ToList[suppliedStandard],conflictStandardDilutionCurveQ],Cache->simulatedCache],True,False],
				Nothing
			];
			{passingTest,failingTest}
		],
		{}
	];

	(* When one of the standard Dilution options is set to Null, we use the other to set dilution. Throw a warning here to let the user know we are still doing dilution *)
	mandatoryStandardDilutionQ=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		MapThread[
			Which[
				MatchQ[{#1,#2},{Null,Automatic}],{True,StandardDilutionCurve,StandardSerialDilutionCurve},
				MatchQ[{#1,#2},{Automatic,Null}],{True,StandardSerialDilutionCurve,StandardDilutionCurve},
				True,{False,Null,Null}
			]&,
			{suppliedStandardDilutionCurve,suppliedStandardSerialDilutionCurve}
		],
		{}
	];

	(* Find the samples *)
	mandatoryStandardDilutionSamples=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		PickList[ToList[suppliedStandard],mandatoryStandardDilutionQ,{True,_,_}],
		{}
	];
	mandatoryStandardDilutionProvidedOptions=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		PickList[mandatoryStandardDilutionQ[[All,2]],mandatoryStandardDilutionQ,{True,_,_}],
		{}
	];
	mandatoryStandardDilutionAutomaticOptions=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		PickList[mandatoryStandardDilutionQ[[All,3]],mandatoryStandardDilutionQ,{True,_,_}],
		{}
	];

	If[MemberQ[mandatoryStandardDilutionQ,{True,_,_}]&&messages,
		Message[Warning::CapillaryELISAStandardDilution,ObjectToString[mandatoryStandardDilutionSamples,Cache->simulatedCache],ToString[mandatoryStandardDilutionProvidedOptions],ToString[mandatoryStandardDilutionAutomaticOptions]],
		{}
	];

	(* If we are gathering tests, generate tests for conflicting dilution curve options *)
	mandatoryStandardDilutionTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=Which[
				MatchQ[suppliedStandard,Null|{}|Automatic],
				Test["Dilution is required for every standard sample:",True,True],
				MemberQ[mandatoryStandardDilutionQ,{False,_,_}],
				Test["Dilution is required for the standard samples "<>ObjectToString[PickList[ToList[suppliedStandard],mandatoryStandardDilutionQ,{False,_,_}],Cache->simulatedCache]<>" even if one of the dilution options is set to Null:",True,False],
				True,
				Nothing
			];
			failingTest=If[MemberQ[mandatoryStandardDilutionQ,{True,_,_}],
				Test["Dilution is required for the standard samples "<>ObjectToString[PickList[ToList[suppliedStandard],mandatoryStandardDilutionQ,{True,_,_}],Cache->simulatedCache]<>" even if one of the dilution options is set to Null:",True,False],
				Nothing
			];
			{passingTest,failingTest}
		],
		{}
	];

	(* The total number of diluted samples should be 5 or more to generate a valid standard curve *)
	nonOptimalStandardDilutionCurveQ=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		MapThread[
			(* call helper function to figure out the number of samples with default 5 dilutions for a standard sample *)
			TrueQ[resolveDilutedSampleNumber[#1,#2,5]<5]&,
			{suppliedStandardDilutionCurve,suppliedStandardSerialDilutionCurve}
		],
		{}
	];

	(* Throw warning message for non optimal standard dilution curve options *)
	If[MemberQ[nonOptimalStandardDilutionCurveQ,True]&&!MatchQ[$ECLApplication,Engine]&&messages,
		Message[Warning::NonOptimalStandardDilutionCurve,ObjectToString[PickList[ToList[suppliedStandard],nonOptimalStandardDilutionCurveQ],Cache->simulatedCache]];{StandardDilutionCurve,StandardSerialDilutionCurve},
		{}
	];

	(* If we are gathering tests, generate tests for non optimal standard dilution curve options *)
	nonOptimalStandardDilutionCurveTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=Which[
				MatchQ[suppliedStandard,Automatic|Null|{}],
				Test["The total number of dilutions for standard samples should be larger than 5 to generate a valid standard curve:",True,True],
				MemberQ[nonOptimalStandardDilutionCurveQ,False],
				Test["The total number of dilutions for standard samples "<>ObjectToString[PickList[ToList[suppliedStandard],nonOptimalStandardDilutionCurveQ,False],Cache->simulatedCache]<>" should be larger than 5 to generate a valid standard curve:",True,True],
				True,
				Nothing
			];
			failingTest=If[MemberQ[nonOptimalStandardDilutionCurveQ,True],
				Test["The total number of dilutions for standard samples "<>ObjectToString[PickList[ToList[suppliedStandard],nonOptimalStandardDilutionCurveQ],Cache->simulatedCache]<>" should be larger than 5 to generate a valid standard curve:",True,False],
				Nothing
			];
			{passingTest,failingTest}
		],
		{}
	];

	(* Note that we check whether the concentration of the analyte is out of the quantitation range and whether the diluent is the same as default inside MapThread. This avoids accessing manufacturing specification information twice. *)

	(* The loading volume of each sample should be larger than 50 Microliter for best results *)
	nonOptimalStandardLoadingVolumeQ=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		Map[
			(TrueQ[#<50Microliter]&&!MatchQ[#,Automatic|Null])&,
			suppliedStandardLoadingVolume
		],
		{}
	];

	(* Throw warning message for non optimal standard loading volume *)
	If[MemberQ[nonOptimalStandardLoadingVolumeQ,True]&&!MatchQ[$ECLApplication,Engine]&&messages,
		Message[Warning::NonOptimalStandardLoadingVolume,ObjectToString[PickList[ToList[suppliedStandard],nonOptimalStandardLoadingVolumeQ],Cache->simulatedCache]];{StandardLoadingVolume},
		{}
	];

	(* If we are gathering tests, generate tests for non optimal standard loading volume *)
	nonOptimalStandardLoadingVolumeTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=Which[
				MatchQ[suppliedStandard,Null|{}|Automatic],
				Test["The loading volume of standard samples should be larger than 50 Microliter for optimized results:",True,True],
				MemberQ[nonOptimalStandardLoadingVolumeQ,False],
				Test["The loading volume of standard samples "<>ObjectToString[PickList[ToList[suppliedStandard],nonOptimalStandardLoadingVolumeQ,False],Cache->simulatedCache]<>" should be larger than 50 Microliter for optimized results:",True,True],
				True,
				Nothing
			];
			failingTest=If[MemberQ[nonOptimalStandardLoadingVolumeQ,True],
				Test["The loading volume of standard samples "<>ObjectToString[PickList[ToList[suppliedStandard],nonOptimalStandardLoadingVolumeQ],Cache->simulatedCache]<>" should be larger than 50 Microliter for optimized results:",True,False],
				Nothing
			];
			{passingTest,failingTest}
		],
		{}
	];

	(* The total preparation volume of each standard sample should not be smaller than the loading volume plus 5 Microliter. 5 Microliter is added to make sure the volume can be pipetted out of the container. Default to 50 Microliter loading volume for our automatic resolved option *)
	exceedStandardDilutionLoadingVolumeQ=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		MapThread[
			If[MatchQ[#1,Automatic|Null],
				TrueQ[55Microliter>resolveMinDilutedSamplePreparationVolume[#2,#3,60Microliter]],
				TrueQ[(#1+5Microliter)>resolveMinDilutedSamplePreparationVolume[#2,#3,60Microliter]]
			]&,
			{suppliedStandardLoadingVolume,suppliedStandardDilutionCurve,suppliedStandardSerialDilutionCurve}
		],
		{}
	];

	exceedStandardDilutionLoadingVolumes=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		PickList[suppliedStandardLoadingVolume,exceedStandardDilutionLoadingVolumeQ],
		{}
	];

	exceedStandardDilutionNonAutomaticLoadingVolumes=ReplaceAll[exceedStandardDilutionLoadingVolumes,Automatic->50 Microliter];

	(* Find the standard samples with preparation volume smaller than the loading volume plus 5 Microliter *)
	exceedStandardDilutionLoadingVolumeSamples=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		PickList[ToList[suppliedStandard],exceedStandardDilutionLoadingVolumeQ],
		{}
	];

	(* Track invalid option and throw message for too small preparation volume *)
	exceedStandardDilutionLoadingVolumeOptions=If[MemberQ[exceedStandardDilutionLoadingVolumeQ,True]&&messages,
		Message[Error::NotEnoughStandardDilutionPreparationVolume,ObjectToString[exceedStandardDilutionLoadingVolumeSamples,Cache->simulatedCache],ToString[exceedStandardDilutionNonAutomaticLoadingVolumes]];{StandardDilutionCurve,StandardSerialDilutionCurve,StandardLoadingVolume},
		{}
	];

	(* If we are gathering tests, generate tests for exceeded standard dilution volume *)
	exceedStandardDilutionLoadingVolumeTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=Which[
				MatchQ[suppliedStandard,Null|{}|Automatic],
				Test["The prepared volume of each diluted standard sample is larger than the loading volume plus 5 Microliter:",True,True],
				Length[exceedStandardDilutionLoadingVolumeSamples]==Length[suppliedStandard],
				Nothing,
				True,
				Test["The prepared volume of each diluted standard sample "<>ObjectToString[Complement[suppliedStandard,exceedStandardDilutionLoadingVolumeSamples],Cache->simulatedCache]<>" is larger than the loading volume plus 5 Microliter:",True,True]
			];
			failingTest=If[Length[exceedStandardDilutionLoadingVolumeSamples]==0,
				Nothing,
				Test["The prepared volume of each diluted standard sample "<>ObjectToString[exceedStandardDilutionLoadingVolumeSamples,Cache->simulatedCache]<>" is larger than the loading volume plus 5 Microliter:",True,False]
			];
			{passingTest,failingTest}
		],
		{}
	];

	(* Check for inside StandardDilutionCurve option, if a linear standard dilution is desired, the volume of sample does not exceed the total assay volume or a standard dilution factor does not exceed 1 *)
	invalidStandardDilutionCurveQ=Map[
		Which[
			MatchQ[#,{VolumeP,{VolumeP,VolumeP},_Integer}],
			TrueQ[#[[2,1]]+(Last[#]-1)*#[[2,2]]>First[#]],
			MatchQ[#,{VolumeP,{_Real,_Real},_Integer}],
			TrueQ[#[[2,1]]+(Last[#]-1)*#[[2,2]]>1],
			True,False
		]&,
		suppliedStandardDilutionCurve
	];

	(* Track invalid option and throw message for invalid standard dilution curve *)
	invalidStandardDilutionCurveOption=If[MemberQ[invalidStandardDilutionCurveQ,True]&&messages,
        (* Message[Error::InvalidCapillaryELISASampleStandardDilutionCurve,ObjectToString[PickList[ToList[suppliedStandard],invalidStandardDilutionCurveQ],Cache->simulatedCache]]; *)
        Message[Error::TooLargeDilutionMixVolumeForCapillaryELISAStandard,ObjectToString[PickList[ToList[suppliedStandard],invalidStandardDilutionCurveQ],Cache->simulatedCache]];{StandardDilutionCurve},
		{}
	];

	(* If we are gathering tests, generate tests for invalid standard dilution curve *)
	invalidStandardDilutionCurveTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=Which[
				MatchQ[suppliedStandard,Null|{}|Automatic],
				Test["The provided linear StandardDilutionCurve do not yield a diluted sample with standard dilution factor larger than 1:",True,True],
				!MemberQ[invalidStandardDilutionCurveQ,False],
				Nothing,
				True,
				Test["The provided linear StandardDilutionCurve for samples "<>ObjectToString[PickList[ToList[suppliedStandard],invalidStandardDilutionCurveQ,False],Cache->simulatedCache]<>" do not yield a diluted sample with standard dilution factor larger than 1:",True,True]
			];
			failingTest=If[!MemberQ[invalidStandardDilutionCurveQ,True],
				Nothing,
				Test["The provided linear StandardDilutionCurve for samples "<>ObjectToString[PickList[ToList[suppliedStandard],invalidStandardDilutionCurveQ],Cache->simulatedCache]<>" do not yield a diluted sample with standard dilution factor larger than 1:",True,False]
			];
			{passingTest,failingTest}
		],
		{}
	];

    (* Check for invalid standard dilution mix volume. It cannot be larger than the volume of the diluted standard sample *)
    (* StandardDilutionMixVolume is default at 20Microliter. We require a loading volume of at least 25 Microliter so when the sample is below 20Microliter, there must already been an error. *)
    (* The total preparation volume of each sample should not be smaller than the DilutionMixVolume *)
    invalidStandardDilutionMixVolumeQ=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
        MapThread[
            If[MatchQ[#1,Automatic|Null],
                TrueQ[20Microliter>resolveMinDilutedSamplePreparationVolume[#2,#3,60Microliter]],
                TrueQ[#1>resolveMinDilutedSamplePreparationVolume[#2,#3,60Microliter]]
            ]&,
            {suppliedStandardDilutionMixVolume,suppliedStandardDilutionCurve,suppliedStandardSerialDilutionCurve}
        ],
        {}
    ];

    (* Track invalid option and throw message for invalid dilution curve *)
    invalidStandardDilutionMixVolumeSamples=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
        PickList[ToList[suppliedStandard],invalidStandardDilutionMixVolumeQ],
        {}
    ];

    (* Track invalid option and throw message for too small preparation volume *)
    invalidStandardDilutionMixVolumeOption=If[MemberQ[invalidStandardDilutionMixVolumeQ,True]&&messages,
        Message[Error::TooLargeDilutionMixVolumeForCapillaryELISAStandard,ObjectToString[invalidStandardDilutionMixVolumeSamples,Cache->simulatedCache]];{StandardDilutionCurve,StandardSerialDilutionCurve,StandardDilutionMixVolume},
        {}
    ];

    (* If we are gathering tests, generate tests for exceeded dilution loading volume *)
    invalidStandardDilutionMixVolumeTests=If[gatherTests,
        Module[{passingTest,failingTest},
            passingTest=Which[
                MatchQ[suppliedStandard,Null|{}|Automatic],
                Test["The prepared volume of each diluted standard sample is larger than the standard dilution mix volume:",True,True],
                Length[invalidStandardDilutionMixVolumeSamples]==Length[suppliedStandard],
                Nothing,
                True,
                Test["The prepared volume of each diluted standard sample "<>ObjectToString[Complement[suppliedStandard,exceedStandardDilutionLoadingVolumeSamples],Cache->simulatedCache]<>" is larger than the standard dilution mix volume:",True,True]
            ];
            failingTest=If[Length[exceedStandardDilutionLoadingVolumeSamples]==0,
                Nothing,
                Test["The prepared volume of each diluted standard sample "<>ObjectToString[exceedStandardDilutionLoadingVolumeSamples,Cache->simulatedCache]<>" is larger than the dilution mix volume:",True,False]
            ];
            {passingTest,failingTest}
        ],
        {}
    ];



    (* StandardComposition should be same as StandardResuspensionConcentration if StandardResuspension is True. Use ToList to convert Null or Automatic cases. *)
	conflictStandardStandardCompositionQ=If[!MatchQ[suppliedStandard,Automatic|Null|{}],
		MapThread[
			If[MatchQ[#1,GreaterEqualP[0Microgram/Milliliter]|GreaterEqualP[0Molar]],
				!MatchQ[#2,{___,{#1,_},___}|Automatic],
				False
			]&,
			{suppliedStandardResuspensionConcentration,suppliedStandardComposition}
		],
		{}
	];

	(* Track invalid option and throw warning message for conflicting known concentration *)
	If[MemberQ[conflictStandardStandardCompositionQ,True]&&!MatchQ[$ECLApplication,Engine]&&messages,
		Message[Warning::ConflictCapillaryELISAStandardComposition,ObjectToString[PickList[ToList[suppliedStandard],conflictStandardStandardCompositionQ],Cache->simulatedCache]]
	];

	(* If we are gathering tests, generate tests for conflicting StandardComposition options *)
	conflictStandardCompositionTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=Which[
				MatchQ[suppliedStandard,Null|{}|Automatic],
				Test["StandardComposition of standard samples are the same as StandardResuspensionConcentration when resuspension of solid sample is performed in this protocol:",True,True],
				MemberQ[conflictStandardStandardCompositionQ,False],
				Test["StandardComposition of standard samples "<>ObjectToString[PickList[ToList[suppliedStandard],conflictStandardStandardCompositionQ,False],Cache->simulatedCache]<>" are the same as StandardResuspensionConcentration when resuspension of solid sample is performed in this protocol:",True,True],
				True,
				Nothing
			];
			failingTest=If[MemberQ[conflictStandardStandardCompositionQ,True],
				Test["StandardComposition of standard samples "<>ObjectToString[PickList[ToList[suppliedStandard],conflictStandardStandardCompositionQ],Cache->simulatedCache]<>" are the same as StandardResuspensionConcentration when resuspension of solid sample is performed in this protocol:",True,True],
				Nothing
			];
			{passingTest,failingTest}
		],
		{}
	];

	(* StandardComposition should be provided as a single number if Cartridge is Customizable so that we can use the number for standard curve *)
	exceedStandardStandardCompositionQ=If[resolvedCustomizableCartridgeQ&&!MatchQ[suppliedStandard,Automatic|Null|{}],
		Map[
			If[MatchQ[#,Automatic|Null],
				False,
				TrueQ[Length[#]>1]
			]&,
			suppliedStandardComposition
		],
		ConstantArray[False,Length[suppliedStandardComposition]]
	];

	(* Track the invalid option and throw error message for exceeded known concentration of standard sample for a customizable cartridge *)
	exceedStandardStandardCompositionOption=If[MemberQ[exceedStandardStandardCompositionQ,True]&&messages,
		Message[Error::ExceedStandardComposition,ObjectToString[PickList[ToList[suppliedStandard],exceedStandardStandardCompositionQ],Cache->simulatedCache]];{StandardComposition},
		{}
	];

	(* If we are gathering tests, generate tests for exceeded StandardComposition options *)
	exceedStandardStandardCompositionTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=Which[
				MatchQ[suppliedStandard,Null|{}|Automatic],
				Test["If the cartridge is customizable, only one StandardComposition is provided for standard samples:",True,True],
				MemberQ[exceedStandardStandardCompositionQ,False],
				Test["If the cartridge is customizable, only one StandardComposition is provided for standard samples "<>ObjectToString[PickList[ToList[suppliedStandard],exceedStandardStandardCompositionQ,False],Cache->simulatedCache],True,True],
				True,
				Nothing
			];
			failingTest=If[MemberQ[exceedStandardStandardCompositionQ,True],
				Test["If the cartridge is customizable, only one StandardComposition is provided for standard samples "<>ObjectToString[PickList[ToList[suppliedStandard],exceedStandardStandardCompositionQ],Cache->simulatedCache],True,True],
				Nothing
			];
			{passingTest,failingTest}
		],
		{}
	];

	(* For a non-customizable cartridge, the analytes in StandardComposition should be members of Analytes or the analytes of Cartridge. We limit that at least one member is shared. We can ignore the other members for data processing. *)
	wrongAnalyteStandardCompositionQ=If[!resolvedCustomizableCartridgeQ&&!MatchQ[suppliedStandard,Null|{}|Automatic],
		Map[
			Which[
				MatchQ[#,Automatic|Null],
				False,
				(* We get Analyte Molecules from the Cartridge *)
				!MatchQ[suppliedAnalyteMoleculesFromCartridge,Null],
				MatchQ[Intersection[#[[All,2]],suppliedAnalyteMoleculesFromCartridge],{}],
				(* We get Analyte Molecules from the ANalytes *)
				!MatchQ[suppliedPreLoadedAnalyteMolecules,Automatic],
				MatchQ[Intersection[#[[All,2]],suppliedPreLoadedAnalyteMolecules],{}],
				True,False
			]&,
			suppliedStandardComposition
		],
		ConstantArray[False,Length[suppliedStandardComposition]]
	];

	(* Track the invalid option and throw error message for wrong analyte known concentration of standard sample for a non-customizable cartridge *)
	wrongAnalyteStandardCompositionOption=If[MemberQ[wrongAnalyteStandardCompositionQ,True]&&messages,
		Message[Error::AnalyteUnavailableInStandardComposition,ObjectToString[PickList[ToList[suppliedStandard],wrongAnalyteStandardCompositionQ],Cache->simulatedCache]];{StandardComposition},
		{}
	];

	(* If we are gathering tests, generate tests for wrong analyte StandardComposition options *)
	wrongAnalyteStandardCompositionTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=Which[
				MatchQ[suppliedStandard,Null|{}|Automatic],
				Test["If the cartridge is not customizable, the StandardComposition shows the concentration of at least one cartridge analyte for standard samples:",True,True],
				MemberQ[wrongAnalyteStandardCompositionQ,False],
				Test["If the cartridge is not customizable, the StandardComposition shows the concentration of at least one cartridge analyte for standard samples "<>ObjectToString[PickList[ToList[suppliedStandard],wrongAnalyteStandardCompositionQ,False],Cache->simulatedCache],True,True],
				True,
				Nothing
			];
			failingTest=If[MemberQ[wrongAnalyteStandardCompositionQ,True],
				Test["If the cartridge is not customizable, the StandardComposition shows the concentration of at least one cartridge analyte for standard samples "<>ObjectToString[PickList[ToList[suppliedStandard],wrongAnalyteStandardCompositionQ],Cache->simulatedCache],True,True],
				Nothing
			];
			{passingTest,failingTest}
		],
		{}
	];


    (* 19 Standard CaptureAntibody and DetectionAntibody Check *)
    (* If the cartridge is not customizable, we must have all Standard CaptureAntibody and DetectionAntibody options as Null. Get a list of standard samples with non-Null options and a list of non-Null options. Call helper function mustNullOptionCheck to get the lists. *)
    invalidStandardAntibodyRelatedOptionChecks=If[!MatchQ[suppliedStandard,Null|{}|Automatic]&&!resolvedCustomizableCartridgeQ,
        mustNullOptionCheck[Standard,Except[Null|Automatic],standardAntibodyOptions,roundedCapillaryELISAOptionsAssociation],
		{ConstantArray[True,Length[ToList[suppliedStandard]]],{}}
    ];

    (* Get a list of samples with non-Null standard antibody options *)
    invalidStandardAntibodyRelatedOptionSamples=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
        PickList[ToList[suppliedStandard],invalidStandardAntibodyRelatedOptionChecks[[1]],False],
        {}
    ];

    (* Get a list of standard antibody options with non-Null values. This covers the case when there is no invalid options *)
    invalidStandardAntibodyRelatedOptions=invalidStandardAntibodyRelatedOptionChecks[[2]];

    (* Throw error message if we get invalid samples and options *)
    If[!MatchQ[invalidStandardAntibodyRelatedOptions,{}]&&messages,
        Message[Error::CannotSpecifyStandardAntibodyOptions,ObjectToString[invalidStandardAntibodyRelatedOptionSamples,Cache->simulatedCache],ToString[invalidStandardAntibodyRelatedOptions]];invalidStandardAntibodyRelatedOptions,
        {}
    ];

    (* If we are gathering tests, generate tests for invalid standard antibody related options. *)
    invalidStandardAntibodyRelatedTests=If[gatherTests,
        Module[{passingTest,failingTest},
            passingTest=If[Length[invalidStandardAntibodyRelatedOptions]==Length[standardAntibodyOptions],
                Nothing,
                Test["The StandardCaptureAntibody and StandardDetectionAntibody related options "<>ToString[Complement[standardAntibodyOptions,invalidStandardAntibodyRelatedOptions]]<>" are Null for the standard samples when the cartridge is not customizable:",True,True]
            ];
            failingTest=If[Length[invalidStandardAntibodyRelatedOptions]==0,
                Nothing,
                Test["The StandardCaptureAntibody and StandardDetectionAntibody related options "<>ToString[invalidStandardAntibodyRelatedOptions]<>" are Null for the standard samples "<>ObjectToString[invalidStandardAntibodyRelatedOptionSamples,Cache->simulatedCache]<>" when the cartridge is not customizable:",True,False]
            ];
            {passingTest,failingTest}
        ],
        {}
    ];


    (* 20 Standard CaptureAntibody Resuspension Check *)
    (* StandardCaptureAntibodyResuspension must be in accordance with the state of Standard sample - True for solid sample and False for liquid sample *)
	(* StandardCaptureAntibodyResuspension must be in accordance with the state of sample - True for solid sample and False for liquid sample *)
	standardCaptureAntibodyStates=Map[
		Lookup[#1,State,Null]&,
		suppliedStandardCaptureAntibodyPackets
	];

	(* Check solid state standard capture antibody samples *)
	solidStandardCaptureAntibodyResuspensionValidQ=If[!MatchQ[suppliedStandard,Null|Automatic|{}],
		MapThread[
			MatchQ[{Lookup[#1,State,Null],#2},{Solid,True|Automatic}|{Except[Solid],_}]&,
			{suppliedStandardCaptureAntibodyPackets,suppliedStandardCaptureAntibodyResuspension}
		],
		ConstantArray[True,Length[suppliedStandard]]
	];
	(* Check liquid state standard capture antibody samples *)
	liquidStandardCaptureAntibodyResuspensionValidQ=If[!MatchQ[suppliedStandard,Null|Automatic|{}],
		MapThread[
			MatchQ[{Lookup[#1,State,Null],#2},{Liquid,Except[True]}|{Except[Liquid],_}]&,
			{suppliedStandardCaptureAntibodyPackets,suppliedStandardCaptureAntibodyResuspension}
		],
		ConstantArray[True,Length[suppliedStandard]]
	];

	(* Find the standard samples and standard capture antibody samples with invalid StandardCaptureAntibodyResuspension *)
	solidStandardCaptureAntibodyResuspensionInvalidSamples=If[MemberQ[solidStandardCaptureAntibodyResuspensionValidQ,False],
		PickList[ToList[suppliedStandard],solidStandardCaptureAntibodyResuspensionValidQ,False],
		{}
	];
	solidStandardCaptureAntibodyResuspensionInvalidAntibodies=If[MemberQ[solidStandardCaptureAntibodyResuspensionValidQ,False],
		PickList[suppliedStandardCaptureAntibody,solidStandardCaptureAntibodyResuspensionValidQ,False],
		{}
	];

	liquidStandardCaptureAntibodyResuspensionInvalidSamples=If[MemberQ[liquidStandardCaptureAntibodyResuspensionValidQ,False],
		PickList[ToList[suppliedStandard],liquidStandardCaptureAntibodyResuspensionValidQ,False],
		{}
	];
	liquidStandardCaptureAntibodyResuspensionInvalidAntibodies=If[MemberQ[liquidStandardCaptureAntibodyResuspensionValidQ,False],
		PickList[suppliedStandardCaptureAntibody,liquidStandardCaptureAntibodyResuspensionValidQ,False],
		{}
	];

	standardCaptureAntibodyResuspensionInvalidSamples=Join[solidStandardCaptureAntibodyResuspensionInvalidSamples,liquidStandardCaptureAntibodyResuspensionInvalidSamples];
	standardCaptureAntibodyResuspensionInvalidAntibodies=Join[solidStandardCaptureAntibodyResuspensionInvalidAntibodies,liquidStandardCaptureAntibodyResuspensionInvalidAntibodies];

	(* Track the invalid option and throw messages *)
	solidStandardCaptureAntibodyResuspensionInvalidOption=If[!MatchQ[solidStandardCaptureAntibodyResuspensionInvalidSamples,{}]&&messages,
		Message[Error::InvalidStandardCaptureAntibodyResuspensionForSolid,ObjectToString[solidStandardCaptureAntibodyResuspensionInvalidAntibodies,Cache->simulatedCache],ObjectToString[solidStandardCaptureAntibodyResuspensionInvalidSamples,Cache->simulatedCache]];{StandardCaptureAntibodyResuspension},
		{}
	];
	liquidStandardCaptureAntibodyResuspensionInvalidOption=If[!MatchQ[liquidStandardCaptureAntibodyResuspensionInvalidSamples,{}]&&messages,
		Message[Error::InvalidStandardCaptureAntibodyResuspensionForLiquid,ObjectToString[liquidStandardCaptureAntibodyResuspensionInvalidAntibodies,Cache->simulatedCache],ObjectToString[liquidStandardCaptureAntibodyResuspensionInvalidSamples,Cache->simulatedCache]];{StandardCaptureAntibodyResuspension},
		{}
	];

	(* If we are gathering tests, generate tests for invalid standard capture antibody resuspensions *)
	standardCaptureAntibodyResuspensionInvalidTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=Which[
				MatchQ[suppliedStandard,Automatic|Null|{}]||!resolvedCustomizableCartridgeQ,
				Test["StandardCaptureAntibodyResuspension is True for solid state standard capture antibody samples and not True for liquid state standard capture antibody samples:",True,True],
				Length[standardCaptureAntibodyResuspensionInvalidSamples]==Length[suppliedStandard],
				Nothing,
				True,
				Test["StandardCaptureAntibodyResuspension is True for solid state standard capture antibody samples and not True for liquid state standard capture antibody samples "<>ObjectToString[Complement[suppliedStandard,standardCaptureAntibodyResuspensionInvalidSamples],Cache->simulatedCache]<>" (used for ELISA assay of the standard samples "<>ObjectToString[Complement[suppliedStandardCaptureAntibody,standardCaptureAntibodyResuspensionInvalidAntibodies],Cache->simulatedCache]<>") to resuspend only solid state samples:",True,True]
			];
			failingTest=If[Length[standardCaptureAntibodyResuspensionInvalidSamples]==0,
				Nothing,
				Test["StandardCaptureAntibodyResuspension is True for solid state standard capture antibody samples and not True for liquid state standard capture antibody samples "<>ObjectToString[standardCaptureAntibodyResuspensionInvalidSamples,Cache->simulatedCache]<>" (used for ELISA assay of the standard samples "<>ObjectToString[standardCaptureAntibodyResuspensionInvalidAntibodies,Cache->simulatedCache]<>") to resuspend only solid state samples:",True,False]
			];
			{passingTest,failingTest}
		],
		{}
	];

	(* When StandardCaptureAntibodyResuspension is set to Null or False or StandardCaptureAntibody is in liquid state, all StandardCaptureAntibodyResuspension related options should be Null or Automatic. Get a list of samples with non-Null options and a list of non-Null options. Call helper function mustNullOptionCheck to get the lists. *)
	(* Note that we allow StandardCaptureAntibodyStorageCondition to be non-Null here because it can be applied to the original liquid state sample *)
	standardCaptureAntibodyResuspensionOptions={StandardCaptureAntibodyResuspensionConcentration,StandardCaptureAntibodyResuspensionDiluent};

	(* We need to check the following cases: When StandardCaptureAntibodyResuspension is not True or Automatic, standard capture antibody resuspension options should be Null. If StandardCaptureAntibodyResuspension is Automatic but the StandardCaptureAntibody is in liquid state, the same. *)
	invalidStandardCaptureAntibodyResuspensionRelatedOptionChecks=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		mustNullOptionCheck[StandardCaptureAntibodyResuspension,Except[True|Automatic],standardCaptureAntibodyResuspensionOptions,roundedCapillaryELISAOptionsAssociation],
		{{},{}}
	];

	(* To check the case with liquid-state capture antibody, we create a fake option association *)
	(* Here fakeStandardCaptureAntibodyStateOption is not a defined module variable. *)
	invalidStandardCaptureAntibodyResuspensionRelatedOptionLiquidChecks=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		mustNullOptionCheck[fakeStandardCaptureAntibodyStateOption,Liquid,standardCaptureAntibodyResuspensionOptions,Join[<|fakeStandardCaptureAntibodyStateOption->standardCaptureAntibodyStates|>,roundedCapillaryELISAOptionsAssociation]],
		{{},{}}
	];

	(* Get a list of samples and antibodies with non-Null capture antibody resuspension options *)
	invalidStandardCaptureAntibodyResuspensionRelatedOptionSamples=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		Union[PickList[ToList[suppliedStandard],invalidStandardCaptureAntibodyResuspensionRelatedOptionChecks[[1]],False],PickList[ToList[suppliedStandard],invalidStandardCaptureAntibodyResuspensionRelatedOptionLiquidChecks[[1]],False]],
		{}
	];
	invalidStandardCaptureAntibodyResuspensionRelatedOptionAntibodies=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		Union[PickList[suppliedStandardCaptureAntibody,invalidStandardCaptureAntibodyResuspensionRelatedOptionChecks[[1]],False],PickList[suppliedStandardCaptureAntibody,invalidStandardCaptureAntibodyResuspensionRelatedOptionLiquidChecks[[1]],False]],
		{}
	];

	(* Get a list of capture antibody resuspension options with non-Null values. This covers the case when there is no invalid options *)
	invalidStandardCaptureAntibodyResuspensionOptions=Union[invalidStandardCaptureAntibodyResuspensionRelatedOptionChecks[[2]],invalidStandardCaptureAntibodyResuspensionRelatedOptionLiquidChecks[[2]]];

	(* Throw error message if we get invalid samples and options *)
	If[!MatchQ[invalidStandardCaptureAntibodyResuspensionOptions,{}]&&messages,
		Message[Error::CannotSpecifyStandardCaptureAntibodyResuspensionOptions,ObjectToString[invalidStandardCaptureAntibodyResuspensionRelatedOptionAntibodies,Cache->simulatedCache],ToString[invalidStandardCaptureAntibodyResuspensionOptions],ObjectToString[invalidStandardCaptureAntibodyResuspensionRelatedOptionSamples,Cache->simulatedCache]];invalidStandardCaptureAntibodyResuspensionOptions,
		{}
	];

	(* If we are gathering tests, generate tests for invalid capture antibody resuspension related options. *)
	invalidStandardCaptureAntibodyResuspensionTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=If[Length[invalidStandardCaptureAntibodyResuspensionOptions]==Length[standardCaptureAntibodyResuspensionOptions],
				Nothing,
				Test["The standard capture antibody resuspension related options "<>ToString[Complement[standardCaptureAntibodyResuspensionOptions,invalidStandardCaptureAntibodyResuspensionOptions]]<>" are Null for liquid capture antibody samples or the standard capture antibody samples with StandardCaptureAntibodyResuspension set to False or Null:",True,True]
			];
			failingTest=If[Length[invalidStandardCaptureAntibodyResuspensionOptions]==0,
				Nothing,
				Test["The standard capture antibody resuspension related options "<>ToString[invalidStandardCaptureAntibodyResuspensionOptions]<>" are Null for the standard capture antibody samples "<>ObjectToString[invalidStandardCaptureAntibodyResuspensionRelatedOptionAntibodies,Cache->simulatedCache]<>" (used for ELISA assay with samples "<>ObjectToString[invalidStandardCaptureAntibodyResuspensionRelatedOptionSamples,Cache->simulatedCache]<>") with a liquid state or StandardCaptureAntibodyResuspension option set to False or Null:",True,False]
			];
			{passingTest,failingTest}
		],
		{}
	];

	(* When StandardCaptureAntibodyResuspension is set to True, all StandardCaptureAntibodyResuspension related options should be specified or Automatic. Get a list of samples with Null options and a list of Null options. Call helper function mustNotNullOptionCheck to get the lists. *)
	(* CaptureAntibodyStorageCondition can not be Null in this case since we are making a new sample *)
	missingStandardCaptureAntibodyResuspensionOptionChecks=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		mustNotNullOptionCheck[StandardCaptureAntibodyResuspension,True,Append[standardCaptureAntibodyResuspensionOptions,StandardCaptureAntibodyStorageCondition],roundedCapillaryELISAOptionsAssociation],
		{{},{}}
	];

	(* To check the case with solid-state capture antibody, we create a fake option association *)
	(* Here fakeStandardCaptureantibodySateOption is not a defined module variable. *)
	missingStandardCaptureAntibodyResuspensionOptionSolidChecks=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		mustNotNullOptionCheck[fakeStandardCaptureAntibodyStateOption,Solid,Append[standardCaptureAntibodyResuspensionOptions,StandardCaptureAntibodyStorageCondition],Join[<|fakeStandardCaptureAntibodyStateOption->standardCaptureAntibodyStates|>,roundedCapillaryELISAOptionsAssociation]],
		{{},{}}
	];

	(* Get a list of samples and antibodies with Null capture antibody resuspension options *)
	missingStandardCaptureAntibodyResuspensionSamples=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		Union[PickList[ToList[suppliedStandard],missingStandardCaptureAntibodyResuspensionOptionChecks[[1]],False],PickList[ToList[suppliedStandard],missingStandardCaptureAntibodyResuspensionOptionSolidChecks[[1]],False]],
		{}
	];
	missingStandardCaptureAntibodyResuspensionAntibodies=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		Union[PickList[suppliedStandardCaptureAntibody,missingStandardCaptureAntibodyResuspensionOptionChecks[[1]],False],PickList[suppliedStandardCaptureAntibody,missingStandardCaptureAntibodyResuspensionOptionSolidChecks[[1]],False]],
		{}
	];

	(* Get a list of capture antibody resuspension options with Null values. This covers the case when there is no invalid options *)
	missingStandardCaptureAntibodyResuspensionOptions=Union[missingStandardCaptureAntibodyResuspensionOptionChecks[[2]],missingStandardCaptureAntibodyResuspensionOptionSolidChecks[[2]]];

	(* Throw error message if we get invalid samples and options *)
	If[!MatchQ[missingStandardCaptureAntibodyResuspensionOptions,{}]&&messages,
		Message[Error::MustSpecifyStandardCaptureAntibodyResuspensionOptions,ObjectToString[missingStandardCaptureAntibodyResuspensionAntibodies,Cache->simulatedCache],ToString[missingStandardCaptureAntibodyResuspensionOptions],ObjectToString[missingStandardCaptureAntibodyResuspensionSamples,Cache->simulatedCache]];missingStandardCaptureAntibodyResuspensionOptions,
		{}
	];

	(* If we are gathering tests, generate tests for invalid capture antibody resuspension related options. *)
	missingStandardCaptureAntibodyResuspensionTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=If[Length[missingStandardCaptureAntibodyResuspensionOptions]==Length[standardCaptureAntibodyResuspensionOptions]+1,
				Nothing,
				Test["The StandardCaptureAntibodyResuspension related options "<>ToString[Complement[standardCaptureAntibodyResuspensionOptions,missingStandardCaptureAntibodyResuspensionOptions]]<>" are not Null for the stanadard samples with solid state or with StandardCaptureAntibodyResuspension option set to True:",True,True]
			];
			failingTest=If[Length[missingStandardCaptureAntibodyResuspensionOptions]==0,
				Nothing,
				Test["The StandardCaptureAntibodyResuspension related options "<>ToString[missingStandardCaptureAntibodyResuspensionOptions]<>" are not Null for the standard capture antibody samples "<>ObjectToString[missingStandardCaptureAntibodyResuspensionAntibodies,Cache->simulatedCache]<>" (used for ELISA assay of "<>ObjectToString[missingStandardCaptureAntibodyResuspensionSamples,Cache->simulatedCache]<>") with solid state or with StandardCaptureAntibodyResuspension option set to True:",True,False]
			];
			{passingTest,failingTest}
		],
		{}
	];


    (* 21 StandardCaptureAntibody Conjugation Checks *)
    (* When StandardCaptureAntibodyConjugation is set to Null or False, all StandardCaptureAntibodyConjugation related options should be Null or Automatic. Get a list of standard samples with non-Null options and a list of non-Null options. Call helper function mustNullOptionCheck to get the lists. *)
	standardCaptureAntibodyConjugationOptions={
		StandardCaptureAntibodyVolume,
		StandardDigoxigeninReagent,
		StandardDigoxigeninReagentVolume,
		StandardCaptureAntibodyConjugationBuffer,
		StandardCaptureAntibodyConjugationBufferVolume,
		StandardCaptureAntibodyConjugationContainer,
		StandardCaptureAntibodyConjugationTime,
		StandardCaptureAntibodyConjugationTemperature,
		StandardCaptureAntibodyPurificationColumn,
		StandardCaptureAntibodyColumnWashBuffer,
		StandardCaptureAntibodyConjugationStorageCondition
	};

    invalidStandardCaptureAntibodyConjugationRelatedOptionChecks=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
        mustNullOptionCheck[StandardCaptureAntibodyConjugation,Except[True|Automatic],standardCaptureAntibodyConjugationOptions,roundedCapillaryELISAOptionsAssociation],
        {{},{}}
    ];

    (* Get a list of samples and antibodies with non-Null standard capture antibody conjugation options *)
    invalidStandardCaptureAntibodyConjugationRelatedOptionSamples=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
        PickList[ToList[suppliedStandard],invalidStandardCaptureAntibodyConjugationRelatedOptionChecks[[1]],False],
        {}
    ];
    invalidStandardCaptureAntibodyConjugationRelatedOptionAntibodies=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
        PickList[suppliedStandardCaptureAntibody,invalidStandardCaptureAntibodyConjugationRelatedOptionChecks[[1]],False],
        {}
    ];

    (* Get a list of standard capture antibody Conjugation options with non-Null values. This covers the case when there is no invalid options *)
    invalidStandardCaptureAntibodyConjugationOptions=invalidStandardCaptureAntibodyConjugationRelatedOptionChecks[[2]];

    (* Throw error message if we get invalid samples and options *)
    If[!MatchQ[invalidStandardCaptureAntibodyConjugationOptions,{}]&&messages,
        Message[Error::CannotSpecifyStandardCaptureAntibodyConjugationOptions,ObjectToString[invalidStandardCaptureAntibodyConjugationRelatedOptionAntibodies,Cache->simulatedCache],ToString[invalidStandardCaptureAntibodyConjugationOptions],ObjectToString[invalidStandardCaptureAntibodyConjugationRelatedOptionSamples,Cache->simulatedCache]];invalidStandardCaptureAntibodyConjugationOptions,
        {}
    ];

    (* If we are gathering tests, generate tests for invalid standard capture antibody Conjugation related options. *)
    invalidStandardCaptureAntibodyConjugationTests=If[gatherTests,
        Module[{passingTest,failingTest},
            passingTest=If[Length[invalidStandardCaptureAntibodyConjugationOptions]==Length[standardCaptureAntibodyConjugationOptions],
                Nothing,
                Test["The standard capture antibody Conjugation related options "<>ToString[Complement[standardCaptureAntibodyConjugationOptions,invalidStandardCaptureAntibodyConjugationOptions]]<>" are Null for the capture antibody samples with StandardCaptureAntibodyConjugation set to False or Null:",True,True]
            ];
            failingTest=If[Length[invalidStandardCaptureAntibodyConjugationOptions]==0,
                Nothing,
                Test["The standard capture antibody Conjugation related options "<>ToString[invalidStandardCaptureAntibodyConjugationOptions]<>" are Null for the standard capture antibody samples "<>ObjectToString[invalidStandardCaptureAntibodyConjugationRelatedOptionAntibodies,Cache->simulatedCache]<>" (used for ELISA assay with standard samples "<>ObjectToString[invalidStandardCaptureAntibodyConjugationRelatedOptionSamples,Cache->simulatedCache]<>") with StandardCaptureAntibodyConjugation set to False or Null:",True,False]
            ];
            {passingTest,failingTest}
        ],
        {}
    ];

    (* When StandardCaptureAntibodyConjugation is set to True, all StandardCaptureAntibodyConjugation related options should be specified or Automatic. Get a list of standard samples with Null options and a list of Null options. Call helper function mustNotNullOptionCheck to get the lists. *)

    missingStandardCaptureAntibodyConjugationRelatedOptionChecks=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
        mustNotNullOptionCheck[StandardCaptureAntibodyConjugation,True,standardCaptureAntibodyConjugationOptions,roundedCapillaryELISAOptionsAssociation],
        {{},{}}
    ];

    (* Get a list of samples and antibodies with Null standard capture antibody conjugation options *)
    missingStandardCaptureAntibodyConjugationRelatedOptionSamples=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
        PickList[ToList[suppliedStandard],missingStandardCaptureAntibodyConjugationRelatedOptionChecks[[1]],False],
        {}
    ];
    missingStandardCaptureAntibodyConjugationRelatedOptionAntibodies=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
        PickList[suppliedStandardCaptureAntibody,missingStandardCaptureAntibodyConjugationRelatedOptionChecks[[1]],False],
        {}
    ];

    (* Get a list of standard capture antibody Conjugation options with Null values. This covers the case when there is no missing options *)
    missingStandardCaptureAntibodyConjugationOptions=missingStandardCaptureAntibodyConjugationRelatedOptionChecks[[2]];

    (* Throw error message if we get missing samples and options *)
    If[!MatchQ[missingStandardCaptureAntibodyConjugationOptions,{}]&&messages,
        Message[Error::MustSpecifyStandardCaptureAntibodyConjugationOptions,ObjectToString[missingStandardCaptureAntibodyConjugationRelatedOptionAntibodies,Cache->simulatedCache],ToString[missingStandardCaptureAntibodyConjugationOptions],ObjectToString[missingStandardCaptureAntibodyConjugationRelatedOptionSamples,Cache->simulatedCache]];missingStandardCaptureAntibodyConjugationOptions,
        {}
    ];

    (* If we are gathering tests, generate tests for missing standard capture antibody Conjugation related options. *)
    missingStandardCaptureAntibodyConjugationTests=If[gatherTests,
        Module[{passingTest,failingTest},
            passingTest=If[Length[missingStandardCaptureAntibodyConjugationOptions]==Length[standardCaptureAntibodyConjugationOptions],
                Nothing,
                Test["The standard capture antibody Conjugation related options "<>ToString[Complement[standardCaptureAntibodyConjugationOptions,missingStandardCaptureAntibodyConjugationOptions]]<>" are not Null for the capture antibody samples with StandardCaptureAntibodyConjugation set to True:",True,True]
            ];
            failingTest=If[Length[missingStandardCaptureAntibodyConjugationOptions]==0,
                Nothing,
                Test["The standard capture antibody Conjugation related options "<>ToString[missingStandardCaptureAntibodyConjugationOptions]<>" are Null for the standard capture antibody samples "<>ObjectToString[missingStandardCaptureAntibodyConjugationRelatedOptionAntibodies,Cache->simulatedCache]<>" (used for ELISA assay with standard samples "<>ObjectToString[missingStandardCaptureAntibodyConjugationRelatedOptionSamples,Cache->simulatedCache]<>") with StandardCaptureAntibodyConjugation set to True:",True,False]
            ];
            {passingTest,failingTest}
        ],
        {}
    ];

    (* Note that we check the reaction ratio of antibody sample and conjugation reagent in the MapThread to avoid resolving the concentrations twice. *)
    (* Note that we check whether the total preparation volume of each conjugated standard capture antibody sample is larger than the MaxVolume of the specified StandardCaptureAntibodyConjugationContainer, the specified StandardCaptureAntibodyPurificationColumn and the specified StandardCaptureAntibodyStorageContainer also within the MapThread. Because we need to resolve the concentrations and volumes, we don't want to perform the process twice for conflicting check. *)

	(* We should not have a mixed Null/Not-Null conjugation options when StandardCaptureAntibodyConjugation is set to Automatic. In that case, we cannot resolve the correct boolean value. Get the list of samples with a mixing set of options. *)
	standardCaptureAntibodyConjugationOptionValues=Lookup[roundedCapillaryELISAOptionsAssociation,Prepend[standardCaptureAntibodyConjugationOptions,StandardCaptureAntibodyConjugation]];

	standardCaptureAntibodyConjugationOptionConflictQ=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		MapThread[
			Function[
				{conjugation,antibodyVolume,conjugationReagent,conjugationReagentVolume,conjugationBuffer,conjugationBufferVolume,conjugationContainer,conjugationTime,conjugationTemperature,purificationColumn,washBuffer,storageCondition},
				If[MatchQ[conjugation,Automatic],
					And[
						MemberQ[{antibodyVolume,conjugationReagent,conjugationReagentVolume,conjugationBuffer,conjugationBufferVolume,conjugationContainer,conjugationTime,conjugationTemperature,purificationColumn,washBuffer,storageCondition},Null],
						MemberQ[{antibodyVolume,conjugationReagent,conjugationReagentVolume,conjugationBuffer,conjugationBufferVolume,conjugationContainer,conjugationTime,conjugationTemperature,purificationColumn,washBuffer,storageCondition},Except[Null|Automatic]]
					],
					False
				]
			],
			standardCaptureAntibodyConjugationOptionValues
		],
		{}
	];

	(* Get the list of standard samples with conflicting options *)
	standardCaptureAntibodyConjugationOptionConflictSamples=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		PickList[ToList[suppliedStandard],standardCaptureAntibodyConjugationOptionConflictQ],
		{}
	];
	standardCaptureAntibodyConjugationOptionConflictAntibodies=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		PickList[suppliedStandardCaptureAntibody,standardCaptureAntibodyConjugationOptionConflictQ],
		{}
	];

	(* Throw error message if we get invalid samples and options *)
	standardCaptureAntibodyConjugationConflictOptions=If[!MatchQ[standardCaptureAntibodyConjugationOptionConflictSamples,{}]&&messages,
		Message[Error::ConflictStandardCaptureAntibodyConjugationOptions,ObjectToString[standardCaptureAntibodyConjugationOptionConflictAntibodies,Cache->simulatedCache],ObjectToString[standardCaptureAntibodyConjugationOptionConflictSamples,Cache->simulatedCache]];standardCaptureAntibodyConjugationOptions,
		{}
	];

	(* If we are gathering tests, generate tests for conflicting standard capture antibody Conjugation related options. *)
	standardCaptureAntibodyConjugationOptionConflictTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=Which[
				MatchQ[suppliedStandard,Automatic|Null|{}],
				Test["StandardCaptureAntibodyConjugation related options should be all Null or not Null for standard capture antibody samples so the value of StandardCaptureAntibodyConjugation can be selected:",True,True],
				Length[standardCaptureAntibodyConjugationOptionConflictSamples]==Length[suppliedStandard],
				Nothing,
				True,
				Test["StandardCaptureAntibodyConjugation related options should be all Null or not Null for standard capture antibody samples "<>ObjectToString[PickList[ToList[suppliedStandard],standardCaptureAntibodyConjugationOptionConflictQ,False],Cache->simulatedCache]<>" (used for ELISA assay with samples "<>ObjectToString[PickList[suppliedStandardCaptureAntibody,standardCaptureAntibodyConjugationOptionConflictQ,False],Cache->simulatedCache]<>") so the value of StandardCaptureAntibodyConjugation option can be selected:",True,True]
			];
			failingTest=If[Length[standardCaptureAntibodyConjugationOptionConflictSamples]==0,
				Nothing,
				Test["StandardCaptureAntibodyConjugation related options should be all Null or not Null for standard capture antibody samples "<>ObjectToString[standardCaptureAntibodyConjugationOptionConflictAntibodies,Cache->simulatedCache]<>" (used for ELISA assay with samples "<>ObjectToString[standardCaptureAntibodyConjugationOptionConflictSamples,Cache->simulatedCache]<>") so the value of StandardCaptureAntibodyConjugation option can be selected:",True,False]
			];
			{passingTest,failingTest}
		],
		{}
	];


	(* Note that we check the reaction ratio of antibody sample and conjugation reagent in the MapThread to avoid resolving the concentrations twice. *)
	(* Note that we check whether the total preparation volume of each conjugated standard capture antibody sample is larger than the MaxVolume of the specified StandardCaptureAntibodyConjugationContainer, the specified StandardCaptureAntibodyPurificationColumn and the specified StandardCaptureAntibodyStorageContainer also within the MapThread. Because we need to resolve the concentrations and volumes, we don't want to perform the process twice for conflicting check. *)

	(* The specified StandardCaptureAntibodyPurificationColumn is a supported spin column, preferrably 40 K MWCO *)
	(* TODO If we have a better plan later to put these spin columns into SPE, we can avoid hard-coding this list of supported spin columns. *)

	(* Right now, It is NOT a good idea to support regular filter as it will require getting the redundant at the top of the filter. Also, washing/collection of the sample will need more manipulations. *)
	(* We only support 6 different types of 7K/40K MWCO spin column, with different capacities. *)
	(* Check whether each of the supplied spin column is supported, with the first boolean indicating 7K/40K for error checking while the second boolean indicating 40K for warning *)
	suppliedStandardCaptureAntibodyPurificationColumnMWCO=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		MapThread[
			{
				Or[
					MatchQ[#1,Automatic|Null],
					MatchQ[
						#2,
						ObjectP[potentialSpinColumns]
					],
					MatchQ[
						Lookup[#2,Model,Null],
						ObjectP[potentialSpinColumns]
					]
				],
				Or[
					MatchQ[#1,Automatic|Null],
					MatchQ[
						#2,
						ObjectP[potential40KSpinColumns]
					],
					MatchQ[
						Lookup[#2,Model,Null],
						ObjectP[potential40KSpinColumns]
					]
				]
			}&,
			{suppliedStandardCaptureAntibodyPurificationColumn,suppliedStandardCaptureAntibodyPurificationColumnPackets}
		],
		{}
	];

	(* Throw an error message if we find a purification column that is not supported. *)
	unsupportedStandardCaptureAntibodyPurificationColumnOption=If[MemberQ[suppliedStandardCaptureAntibodyPurificationColumnMWCO,{False,False}]&&messages,
		Message[Error::UnsupportedStandardCaptureAntibodyPurificationColumn,ObjectToString[PickList[suppliedStandardCaptureAntibody,suppliedStandardCaptureAntibodyPurificationColumnMWCO,{False,False}],Cache->simulatedCache],ObjectToString[PickList[ToList[suppliedStandard],suppliedStandardCaptureAntibodyPurificationColumnMWCO,{False,False}],Cache->simulatedCache],ObjectToString[potential40KSpinColumns,Cache->simulatedCache]];{StandardCaptureAntibodyPurificationColumn},
		Nothing
	];

	(* Throw a warning message if we find a purification column that is not 40K MWCO. We only throw warning when an error is not thrown*)
	If[MemberQ[suppliedStandardCaptureAntibodyPurificationColumnMWCO,{True,False}]&&!MatchQ[$ECLApplication,Engine]&&messages,
		Message[Warning::NonOptimalStandardCaptureAntibodyPurificationColumn,
			ObjectToString[PickList[suppliedStandardCaptureAntibody,suppliedStandardCaptureAntibodyPurificationColumnMWCO,{True,False}],Cache->simulatedCache],
			ObjectToString[PickList[ToList[suppliedStandard],suppliedStandardCaptureAntibodyPurificationColumnMWCO,{True,False}],Cache->simulatedCache],
			ObjectToString[potential40KSpinColumns,Cache->simulatedCache]],
		Nothing
	];

	(* If we are gathering tests, generate tests for unsupported standard capture antibody purification column  *)
	unsupportedStandardCaptureAntibodyPurificationColumnTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=Which[
				MatchQ[suppliedStandard,Automatic|Null|{}]||!resolvedCustomizableCartridgeQ,
				Test["The specified StandardCaptureAntibodyPurificationColumn is a supported Zeba spin column (preferably 40K MWCO) for the standard capture antibody samples:",True,True],
				!MemberQ[suppliedStandardCaptureAntibodyPurificationColumnMWCO,{True,_}],
				Nothing,
				True,
				Test["The specified StandardCaptureAntibodyPurificationColumn is a supported Zeba spin column (preferably 40K MWCO) for the standard capture antibody samples "<>ObjectToString[PickList[suppliedStandardCaptureAntibody,suppliedStandardCaptureAntibodyPurificationColumnMWCO,{True,_}],Cache->simulatedCache]<>", used for ELISA assay of the samples "<>ObjectToString[PickList[ToList[suppliedStandard],suppliedStandardCaptureAntibodyPurificationColumnMWCO,{True,_}],Cache->simulatedCache],True,True]
			];
			failingTest=If[!MemberQ[suppliedStandardCaptureAntibodyPurificationColumnMWCO,{False,False}],
				Nothing,
				Test["The specified StandardCaptureAntibodyPurificationColumn is a supported Zeba spin column (preferably 40K MWCO) for the standard capture antibody samples "<>ObjectToString[PickList[suppliedStandardCaptureAntibody,suppliedStandardCaptureAntibodyPurificationColumnMWCO,{False,False}],Cache->simulatedCache]<>", used for ELISA assay of the samples "<>ObjectToString[PickList[ToList[suppliedStandard],suppliedStandardCaptureAntibodyPurificationColumnMWCO,{False,False}],Cache->simulatedCache],True,False]
			];
			{passingTest,failingTest}
		],
		{}
	];

	(* If we are gathering tests, generate tests for non-optimal standard capture antibody purification column *)
	nonOptimalStandardCaptureAntibodyPurificationColumnTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=Which[
				MatchQ[suppliedStandard,Automatic|Null|{}]||!resolvedCustomizableCartridgeQ,
				Test["The specified StandardCaptureAntibodyPurificationColumn is 40K MWCO for the standard capture antibody samples:",True,True],
				!MemberQ[suppliedStandardCaptureAntibodyPurificationColumnMWCO,{True,True}],
				Nothing,
				True,
				Test["The specified StandardCaptureAntibodyPurificationColumn is 40K MWCO for the standard capture antibody samples "<>ObjectToString[PickList[suppliedStandardCaptureAntibody,suppliedStandardCaptureAntibodyPurificationColumnMWCO,{True,True}],Cache->simulatedCache]<>", used for ELISA assay of the samples "<>ObjectToString[PickList[ToList[suppliedStandard],suppliedStandardCaptureAntibodyPurificationColumnMWCO,{True,True}],Cache->simulatedCache],True,True]
			];
			failingTest=If[!MemberQ[suppliedStandardCaptureAntibodyPurificationColumnMWCO,{_,False}],
				Nothing,
				Test["The specified StandardCaptureAntibodyPurificationColumn is 40K MWCO for the standard capture antibody samples "<>ObjectToString[PickList[suppliedStandardCaptureAntibody,suppliedStandardCaptureAntibodyPurificationColumnMWCO,{_,False}],Cache->simulatedCache]<>", used for ELISA assay of the samples "<>ObjectToString[PickList[ToList[suppliedStandard],suppliedStandardCaptureAntibodyPurificationColumnMWCO,{_,False}],Cache->simulatedCache],True,False]
			];
			{passingTest,failingTest}
		],
		{}
	];


    (* 22 StandardCaptureAntibody Dilution Checks *)
    (* When StandardCaptureAntibodyDilution is set to Null, all StandardCaptureAntibodyDilution related options should be Null or Automatic. Get a list of standard samples with non-Null options and a list of non-Null options. Call helper function mustNullOptionCheck to get the lists. *)
    standardCaptureAntibodyDilutionOptions={StandardCaptureAntibodyTargetConcentration,StandardCaptureAntibodyDiluent};

    invalidStandardCaptureAntibodyDilutionRelatedOptionChecks=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
        mustNullOptionCheck[StandardCaptureAntibodyDilution,Null|False,standardCaptureAntibodyDilutionOptions,roundedCapillaryELISAOptionsAssociation],
        {{},{}}
    ];

    (* Get a list of samples and antibodies with non-Null standard capture antibody Dilution options *)
    invalidStandardCaptureAntibodyDilutionRelatedOptionSamples=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
        PickList[ToList[suppliedStandard],invalidStandardCaptureAntibodyDilutionRelatedOptionChecks[[1]],False],
        {}
    ];
    invalidStandardCaptureAntibodyDilutionRelatedOptionAntibodies=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
        PickList[suppliedStandardCaptureAntibody,invalidStandardCaptureAntibodyDilutionRelatedOptionChecks[[1]],False],
        {}
    ];

    (* Get a list of standard capture antibody Dilution options with non-Null values. This covers the case when there is no invalid options *)
    invalidStandardCaptureAntibodyDilutionOptions=invalidStandardCaptureAntibodyDilutionRelatedOptionChecks[[2]];

    (* Throw error message if we get invalid samples and options *)
    If[!MatchQ[invalidStandardCaptureAntibodyDilutionOptions,{}]&&messages,
        Message[Error::CannotSpecifyStandardCaptureAntibodyDilutionOptions,ObjectToString[invalidStandardCaptureAntibodyDilutionRelatedOptionAntibodies,Cache->simulatedCache],ToString[invalidStandardCaptureAntibodyDilutionOptions],ObjectToString[invalidStandardCaptureAntibodyDilutionRelatedOptionSamples,Cache->simulatedCache]];invalidStandardCaptureAntibodyDilutionOptions,
        {}
    ];

    (* If we are gathering tests, generate tests for invalid standard capture antibody Dilution related options. *)
    invalidStandardCaptureAntibodyDilutionTests=If[gatherTests,
        Module[{passingTest,failingTest},
            passingTest=Which[
				MatchQ[suppliedStandard,Automatic|Null|{}]||!resolvedCustomizableCartridgeQ,
				Test["The specified standard capture antibody dilution related options are Null for the standard capture antibody samples with StandardCaptureAntibodyDilution set to Null:",True,True],
				Length[invalidStandardCaptureAntibodyDilutionOptions]==Length[standardCaptureAntibodyDilutionOptions],
                Nothing,
                True,
				Test["The standard capture antibody dilution related options "<>ToString[Complement[standardCaptureAntibodyDilutionOptions,invalidStandardCaptureAntibodyDilutionOptions]]<>" are Null for the standard capture antibody samples with StandardCaptureAntibodyDilution set to Null or False:",True,True]
            ];
            failingTest=If[Length[invalidStandardCaptureAntibodyDilutionOptions]==0,
                Nothing,
                Test["The standard capture antibody Dilution related options "<>ToString[invalidStandardCaptureAntibodyDilutionOptions]<>" are Null for the standard capture antibody samples "<>ObjectToString[invalidStandardCaptureAntibodyDilutionRelatedOptionAntibodies,Cache->simulatedCache]<>" (used for ELISA assay with standard samples "<>ObjectToString[invalidStandardCaptureAntibodyDilutionRelatedOptionSamples,Cache->simulatedCache]<>") with StandardCaptureAntibodyDilution set to Null or False:",True,False]
            ];
            {passingTest,failingTest}
        ],
        {}
    ];

    (* When the standard capture antibody sample goes through either resuspension or conjugation process in this protocol, it is recommend to do dilution - StandardCaptureAntibodyDilution is not set to Null/False. *)
    missingRecommendedStandardCaptureAntibodyDilutionQ=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
        MapThread[
            MatchQ[{Lookup[#1,State,Null],#2,#3},{Solid,_,Null|False}|{_,True,Null|False}]&,
            {suppliedStandardCaptureAntibodyPackets,suppliedStandardCaptureAntibodyConjugation,suppliedStandardCaptureAntibodyDilution}
        ],
        {}
    ];

    (* Get a list of samples and antibodies with null standard capture antibody dilution option but a dilution is recommended *)
    missingRecommendedStandardCaptureAntibodyDilutionSamples=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
        PickList[ToList[suppliedStandard],missingRecommendedStandardCaptureAntibodyDilutionQ],
        {}
    ];
    missingRecommendedStandardCaptureAntibodyDilutionAntibodies=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
        PickList[suppliedStandardCaptureAntibody,missingRecommendedStandardCaptureAntibodyDilutionQ],
        {}
    ];

    (* Throw warning message if we get samples for which a dilution is recommended *)
    If[!MatchQ[missingRecommendedStandardCaptureAntibodyDilutionSamples,{}]&&!MatchQ[$ECLApplication,Engine]&&messages,
        Message[Warning::StandardCaptureAntibodyDilutionRecommended,ObjectToString[missingRecommendedStandardCaptureAntibodyDilutionAntibodies,Cache->simulatedCache],ObjectToString[missingRecommendedStandardCaptureAntibodyDilutionSamples,Cache->simulatedCache]],
        Nothing
    ];

    (* If we are gathering tests, generate tests for the samples for which a dilution is recommended *)
    missingRecommendedStandardCaptureAntibodyDilutionTests=If[gatherTests,
        Module[{passingTest,failingTest},
            passingTest=Which[
                MatchQ[suppliedStandard,Automatic|Null|{}]||!resolvedCustomizableCartridgeQ,
                Test["The StandardCaptureAntibodyDilution option is not Null for the capture antibody samples when it is either resuspended or conjugated in this protocol:",True,True],
                Length[missingRecommendedStandardCaptureAntibodyDilutionSamples]==Length[suppliedStandard],
                Nothing,
                True,
                Test["The StandardCaptureAntibodyDilution option is not Null for the capture antibody samples "<>ObjectToString[Complement[suppliedStandardCaptureAntibody,missingRecommendedStandardCaptureAntibodyDilutionAntibodies],Cache->simulatedCache]<>" (for ELISA assay of "<>ObjectToString[Complement[suppliedStandard,missingRecommendedStandardCaptureAntibodyDilutionSamples],Cache->simulatedCache]<>") when it is either resuspended or conjugated in this protocol:",True,True]
            ];
            failingTest=If[Length[invalidStandardCaptureAntibodyDilutionOptions]==0,
                Nothing,
                Test["The StandardCaptureAntibodyDilution option is not Null for the capture antibody samples "<>ObjectToString[missingRecommendedStandardCaptureAntibodyDilutionAntibodies,Cache->simulatedCache]<>" (for ELISA assay of "<>ObjectToString[missingRecommendedStandardCaptureAntibodyDilutionSamples,Cache->simulatedCache]<>") when it is either resuspended or conjugated in this protocol:",True,False]
            ];
            {passingTest,failingTest}
        ],
        {}
    ];

	(* When StandardCaptureAntibodyDilution is True, StandardCaptureAntibodyTargetConcentration and StandardCaptureAntibodyDiluent should not be Null. Get a list of samples with Null option. Call helper function mustNotNullOptionCheck to get the lists. *)
	missingStandardCaptureAntibodyDilutionOptionsChecks=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		mustNotNullOptionCheck[StandardCaptureAntibodyDilution,True,standardCaptureAntibodyDilutionOptions,roundedCapillaryELISAOptionsAssociation],
		{{},{}}
	];

	(* Get a list of samples and antibodies with Null standard capture antibody Dilution options *)
	missingStandardCaptureAntibodyDilutionOptionsSamples=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		PickList[ToList[suppliedStandard],missingStandardCaptureAntibodyDilutionOptionsChecks[[1]],False],
		{}
	];
	missingStandardCaptureAntibodyDilutionOptionsAntibodies=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		PickList[suppliedStandardCaptureAntibody,missingStandardCaptureAntibodyDilutionOptionsChecks[[1]],False],
		{}
	];

	(* Get a list of standard capture antibody Dilution options with Null values. This covers the case when there is no invalid options *)
	missingStandardCaptureAntibodyDilutionOptions=missingStandardCaptureAntibodyDilutionOptionsChecks[[2]];

	(* Throw error message if we get invalid samples and options *)
	If[!MatchQ[missingStandardCaptureAntibodyDilutionOptions,{}]&&messages,
		Message[Error::MustSpecifyStandardCaptureAntibodyDilutionOptions,ObjectToString[missingStandardCaptureAntibodyDilutionOptionsAntibodies,Cache->simulatedCache],ToString[missingStandardCaptureAntibodyDilutionOptions],ObjectToString[missingStandardCaptureAntibodyDilutionOptionsSamples,Cache->simulatedCache]];missingStandardCaptureAntibodyDilutionOptions,
		{}
	];

	(* If we are gathering tests, generate tests for missing StandardCaptureAntibodyDiluent. *)
	missingStandardCaptureAntibodyDilutionOptionTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=Which[
				MatchQ[suppliedStandard,Automatic|Null|{}]||!resolvedCustomizableCartridgeQ,
				Test["The standard capture antibody dilution related options are not Null for the capture antibody samples with StandardCaptureAntibodyDilution set to True:",True,True],
				Length[missingStandardCaptureAntibodyDilutionOptions]==Length[standardCaptureAntibodyDilutionOptions],
				Nothing,
				True,
				Test["The standard capture antibody dilution related options "<>ToString[Complement[standardCaptureAntibodyDilutionOptions,missingStandardCaptureAntibodyDilutionOptions]]<>" are not Null for the standard capture antibody samples with StandardCaptureAntibodyDilution set to True:",True,True]
			];
			failingTest=If[Length[missingStandardCaptureAntibodyDilutionOptions]==0,
				Nothing,
				Test["The StandardCaptureAntibodyDiluent options "<>ToString[missingStandardCaptureAntibodyDilutionOptions]<>" are not Null for the standard capture antibody samples "<>ObjectToString[missingStandardCaptureAntibodyDilutionOptionsAntibodies,Cache->simulatedCache]<>" (for ELISA assay of "<>ObjectToString[missingStandardCaptureAntibodyDilutionOptionsSamples,Cache->simulatedCache]<>") when its StandardCaptureAntibodyDilution is not Null:",True,False]
			];
			{passingTest,failingTest}
		],
		{}
	];

	(* We should not have a mixed Null/Not-Null dilution options when StandardCaptureAntibodyDilution is set to Automatic. In that case, we cannot resolve the correct boolean value. Get the list of samples with a mixing set of options. *)
	standardCaptureAntibodyDilutionOptionValues=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		Lookup[roundedCapillaryELISAOptionsAssociation,Prepend[standardCaptureAntibodyDilutionOptions,StandardCaptureAntibodyDilution]],
		{}
	];

	standardCaptureAntibodyDilutionOptionConflictQ=MapThread[
		MatchQ[{#1,#2,#3},{Automatic,Except[Null|Automatic],Null}|{Automatic,Null,Except[Null|Automatic]}]&,
		standardCaptureAntibodyDilutionOptionValues
	];

	(* Get the list of samples with conflicting options *)
	standardCaptureAntibodyDilutionOptionConflictSamples=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		PickList[ToList[suppliedStandard],standardCaptureAntibodyDilutionOptionConflictQ],
		{}
	];
	standardCaptureAntibodyDilutionOptionConflictAntibodies=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		PickList[suppliedStandardCaptureAntibody,standardCaptureAntibodyDilutionOptionConflictQ],
		{}
	];

	(* Throw error message if we get invalid samples and options *)
	standardCaptureAntibodyDilutionConflictOptions=If[!MatchQ[standardCaptureAntibodyDilutionOptionConflictSamples,{}]&&messages,
		Message[Error::ConflictStandardCaptureAntibodyDilutionOptions,ObjectToString[standardCaptureAntibodyDilutionOptionConflictAntibodies,Cache->simulatedCache],ObjectToString[standardCaptureAntibodyDilutionOptionConflictSamples,Cache->simulatedCache]];standardCaptureAntibodyDilutionOptions,
		{}
	];

	(* If we are gathering tests, generate tests for conflicting standard capture antibody dilution related options. *)
	standardCaptureAntibodyDilutionOptionConflictTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=Which[
				MatchQ[suppliedStandard,Null|{}|Automatic]||!resolvedCustomizableCartridgeQ,
				Test["StandardCaptureAntibodyTargetConcentration and StandardCaptureAntibodyDiluent options should be both Null or not Null for standard capture antibody samples so the value of StandardCaptureAntibodyDilution option can be selected:",True,True],
				Length[standardCaptureAntibodyDilutionOptionConflictSamples]==Length[suppliedStandard],
				Nothing,
				True,
				Test["StandardCaptureAntibodyTargetConcentration and StandardCaptureAntibodyDiluent options should be both Null or not Null for standard capture antibody samples "<>ObjectToString[PickList[ToList[suppliedStandard],standardCaptureAntibodyDilutionOptionConflictQ,False],Cache->simulatedCache]<>" (used for ELISA assay with samples "<>ObjectToString[PickList[suppliedStandardCaptureAntibody,standardCaptureAntibodyDilutionOptionConflictQ,False],Cache->simulatedCache]<>") so the value of StandardCaptureAntibodyDilution option can be selected:",True,True]
			];
			failingTest=If[Length[standardCaptureAntibodyDilutionOptionConflictSamples]==0,
				Nothing,
				Test["StandardCaptureAntibodyTargetConcentration and StandardCaptureAntibodyDiluent options should be both Null or not Null for standard capture antibody samples "<>ObjectToString[standardCaptureAntibodyDilutionOptionConflictAntibodies,Cache->simulatedCache]<>" (used for ELISA assay with samples "<>ObjectToString[standardCaptureAntibodyDilutionOptionConflictSamples,Cache->simulatedCache]<>") so the value of StandardCaptureAntibodyDilution option can be selected:",True,False]
			];
			{passingTest,failingTest}
		],
		{}
	];

    (* StandardCaptureAntibodyDiluent should be Model[Sample, "Simple Plex Reagent Diluent"] for optimized result. Get a list of standard samples with non-optimized standard capture antibody diluent. *)
    nonOptimalStandardCaptureAntibodyDiluentQ=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
        Map[
            !MatchQ[#,Automatic|Null|Model[Sample, "id:pZx9jo8LZ7z5"]]&, (* Model[Sample,"Simple Plex Reagent Diluent"] *)
            suppliedStandardCaptureAntibodyDiluentModels
        ],
        {}
      ];

    (* Get a list of samples and antibodies with StandardCaptureAntibodyDiluent not set to Model[Sample, "Simple Plex Reagent Diluent"]  or an object with this model *)
    nonOptimalStandardCaptureAntibodyDiluentSamples=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		PickList[ToList[suppliedStandard],nonOptimalStandardCaptureAntibodyDiluentQ],
		{}
	];
    nonOptimalStandardCaptureAntibodyDiluentAntibodies=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		PickList[suppliedStandardCaptureAntibody,nonOptimalStandardCaptureAntibodyDiluentQ],
		{}
	];

    (* Throw warning message is we get a non-optimal diluent *)
    If[MemberQ[nonOptimalStandardCaptureAntibodyDiluentQ,True]&&!MatchQ[$ECLApplication,Engine]&&messages,
      Message[Warning::NonOptimalStandardCaptureAntibodyDiluent,ObjectToString[nonOptimalStandardCaptureAntibodyDiluentAntibodies,Cache->simulatedCache],ObjectToString[nonOptimalStandardCaptureAntibodyDiluentSamples,Cache->simulatedCache]];{StandardCaptureAntibodyDiluent},
      {}
    ];

    (* If we are gathering tests, generate tests for non-optimal StandardCaptureAntibodyDiluent. *)
    nonOptimalStandardCaptureAntibodyDiluentTests=If[gatherTests,
        Module[{passingTest,failingTest},
            passingTest=Which[
				MatchQ[suppliedStandard,Null|{}|Automatic]||!resolvedCustomizableCartridgeQ,
				Test["The StandardCaptureAntibodyDiluent option is kept as Model[Sample,\"Simple Plex Reagent Diluent\"] or a sample with this model for the standard capture antibody samples:",True,True],
				Length[nonOptimalStandardCaptureAntibodyDiluentSamples]==Length[suppliedStandard],
                Nothing,
				True,
                Test["The StandardCaptureAntibodyDiluent option is kept as Model[Sample,\"Simple Plex Reagent Diluent\"] or a sample with this model for the standard capture antibody samples "<>ObjectToString[Complement[suppliedStandardCaptureAntibody,nonOptimalStandardCaptureAntibodyDiluentAntibodies],Cache->simulatedCache]<>" (for ELISA assay of "<>ObjectToString[Complement[suppliedStandard,nonOptimalStandardCaptureAntibodyDiluentSamples],Cache->simulatedCache]<>") for optimized dilution and ELISA results:",True,True]
            ];
            failingTest=If[Length[missingStandardCaptureAntibodyDiluentSamples]==0,
                Nothing,
                Test["The StandardCaptureAntibodyDiluent option is kept as Model[Sample,\"Simple Plex Reagent Diluent\"] or a sample with this model for the standard capture antibody samples "<>ObjectToString[nonOptimalStandardCaptureAntibodyDiluentAntibodies,Cache->simulatedCache]<>" (for ELISA assay of "<>ObjectToString[nonOptimalStandardCaptureAntibodyDiluentSamples,Cache->simulatedCache]<>") for optimized dilution and ELISA results:",True,False]
            ];
            {passingTest,failingTest}
        ],
        {}
    ];

    (* When StandardCaptureAntibody is not Null, StandardCaptureAntibodyLoadingVolume should not be Null. Get a list of standard samples with Null option. Call helper function mustNotNullOptionCheck to get the lists. *)
    missingStandardCaptureAntibodyLoadingVolumeChecks=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
        mustNotNullOptionCheck[StandardCaptureAntibody,Except[Null|Automatic],{StandardCaptureAntibodyLoadingVolume},roundedCapillaryELISAOptionsAssociation][[1]],
        {}
    ];

    (* Get a list of samples and antibodies with Null StandardCaptureAntibodyLoadingVolume *)
    missingStandardCaptureAntibodyLoadingVolumeSamples=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		PickList[ToList[suppliedStandard],missingStandardCaptureAntibodyLoadingVolumeChecks,False],
		{}
	];
    missingStandardCaptureAntibodyLoadingVolumeAntibodies=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		PickList[suppliedStandardCaptureAntibody,missingStandardCaptureAntibodyLoadingVolumeChecks,False],
		{}
	];

    (* Throw error message if we get invalid samples and options *)
    missingStandardCaptureAntibodyLoadingVolumeOption=If[!MatchQ[missingStandardCaptureAntibodyLoadingVolumeSamples,{}]&&messages,
        Message[Error::MustSpecifyStandardCaptureAntibodyLoadingVolume,ObjectToString[missingStandardCaptureAntibodyLoadingVolumeAntibodies,Cache->simulatedCache],ObjectToString[missingStandardCaptureAntibodyLoadingVolumeSamples,Cache->simulatedCache]];{StandardCaptureAntibodyLoadingVolume},
        {}
    ];

    (* If we are gathering tests, generate tests for missing StandardCaptureAntibodyLoadingVolume. *)
    missingStandardCaptureAntibodyLoadingVolumeTests=If[gatherTests,
        Module[{passingTest,failingTest},
            passingTest=Which[
				MatchQ[suppliedStandard,Automatic|Null|{}]||!resolvedCustomizableCartridgeQ,
				Test["When a customizable cartridge is used, the StandardCaptureAntibodyLoadingVolume option is not Null for the standard capture antibody samples:",True,True],
				Length[missingStandardCaptureAntibodyDilutionStorageConditionSamples]==Length[suppliedStandard],
                Nothing,
				True,
                Test["When a customizable cartridge is used, the StandardCaptureAntibodyLoadingVolume option is not Null for the standard capture antibody samples "<>ObjectToString[Complement[suppliedStandardCaptureAntibody,missingStandardCaptureAntibodyLoadingVolumeAntibodies],Cache->simulatedCache]<>", used for ELISA assay of "<>ObjectToString[Complement[suppliedStandard,missingStandardCaptureAntibodyLoadingVolumeSamples],Cache->simulatedCache],True,True]
            ];
            failingTest=If[Length[missingStandardCaptureAntibodyDilutionStorageConditionSamples]==0,
                Nothing,
                Test["When a customizable cartridge is used, the StandardCaptureAntibodyLoadingVolume option is not Null for the standard capture antibody samples "<>ObjectToString[missingStandardCaptureAntibodyLoadingVolumeAntibodies,Cache->simulatedCache]<>", used for ELISA assay of "<>ObjectToString[missingStandardCaptureAntibodyLoadingVolumeSamples,Cache->simulatedCache],True,False]
            ];
            {passingTest,failingTest}
        ],
        {}
    ];

	(* 23 Standard DetectionAntibody Resuspension Check *)
	(* StandardDetectionAntibodyResuspension must be in accordance with the state of Standard sample - True for solid sample and False for liquid sample *)
	(* StandardDetectionAntibodyResuspension must be in accordance with the state of sample - True for solid sample and False for liquid sample *)
	standardDetectionAntibodyStates=Map[
		Lookup[#1,State,Null]&,
		suppliedStandardDetectionAntibodyPackets
	];

	(* Check solid state standard detection antibody samples *)
	solidStandardDetectionAntibodyResuspensionValidQ=If[!MatchQ[suppliedStandard,Null|Automatic|{}],
		MapThread[
			MatchQ[{Lookup[#1,State,Null],#2},{Solid,True|Automatic}|{Except[Solid],_}]&,
			{suppliedStandardDetectionAntibodyPackets,suppliedStandardDetectionAntibodyResuspension}
		],
		ConstantArray[True,Length[suppliedStandard]]
	];
	(* Check liquid state standard detection antibody samples *)
	liquidStandardDetectionAntibodyResuspensionValidQ=If[!MatchQ[suppliedStandard,Null|Automatic|{}],
		MapThread[
			MatchQ[{Lookup[#1,State,Null],#2},{Liquid,Except[True]}|{Except[Liquid],_}]&,
			{suppliedStandardDetectionAntibodyPackets,suppliedStandardDetectionAntibodyResuspension}
		],
		ConstantArray[True,Length[suppliedStandard]]
	];

	(* Find the standard samples and standard detection antibody samples with invalid StandardDetectionAntibodyResuspension *)
	solidStandardDetectionAntibodyResuspensionInvalidSamples=If[MemberQ[solidStandardDetectionAntibodyResuspensionValidQ,False],
		PickList[ToList[suppliedStandard],solidStandardDetectionAntibodyResuspensionValidQ,False],
		{}
	];
	solidStandardDetectionAntibodyResuspensionInvalidAntibodies=If[MemberQ[solidStandardDetectionAntibodyResuspensionValidQ,False],
		PickList[suppliedStandardDetectionAntibody,solidStandardDetectionAntibodyResuspensionValidQ,False],
		{}
	];

	liquidStandardDetectionAntibodyResuspensionInvalidSamples=If[MemberQ[liquidStandardDetectionAntibodyResuspensionValidQ,False],
		PickList[ToList[suppliedStandard],liquidStandardDetectionAntibodyResuspensionValidQ,False],
		{}
	];
	liquidStandardDetectionAntibodyResuspensionInvalidAntibodies=If[MemberQ[liquidStandardDetectionAntibodyResuspensionValidQ,False],
		PickList[suppliedStandardDetectionAntibody,liquidStandardDetectionAntibodyResuspensionValidQ,False],
		{}
	];

	standardDetectionAntibodyResuspensionInvalidSamples=Join[solidStandardDetectionAntibodyResuspensionInvalidSamples,liquidStandardDetectionAntibodyResuspensionInvalidSamples];
	standardDetectionAntibodyResuspensionInvalidAntibodies=Join[solidStandardDetectionAntibodyResuspensionInvalidAntibodies,liquidStandardDetectionAntibodyResuspensionInvalidAntibodies];

	(* Track the invalid option and throw messages *)
	solidStandardDetectionAntibodyResuspensionInvalidOption=If[!MatchQ[solidStandardDetectionAntibodyResuspensionInvalidSamples,{}]&&messages,
		Message[Error::InvalidStandardDetectionAntibodyResuspensionForSolid,ObjectToString[solidStandardDetectionAntibodyResuspensionInvalidAntibodies,Cache->simulatedCache],ObjectToString[solidStandardDetectionAntibodyResuspensionInvalidSamples,Cache->simulatedCache]];{StandardDetectionAntibodyResuspension},
		{}
	];
	liquidStandardDetectionAntibodyResuspensionInvalidOption=If[!MatchQ[liquidStandardDetectionAntibodyResuspensionInvalidSamples,{}]&&messages,
		Message[Error::InvalidStandardDetectionAntibodyResuspensionForLiquid,ObjectToString[liquidStandardDetectionAntibodyResuspensionInvalidAntibodies,Cache->simulatedCache],ObjectToString[liquidStandardDetectionAntibodyResuspensionInvalidSamples,Cache->simulatedCache]];{StandardDetectionAntibodyResuspension},
		{}
	];

	(* If we are gathering tests, generate tests for invalid standard detection antibody resuspensions *)
	standardDetectionAntibodyResuspensionInvalidTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=Which[
				MatchQ[suppliedStandard,Automatic|Null|{}]||!resolvedCustomizableCartridgeQ,
				Test["StandardDetectionAntibodyResuspension is True for solid state standard detection antibody samples and not True for liquid state standard detection antibody samples:",True,True],
				Length[standardDetectionAntibodyResuspensionInvalidSamples]==Length[suppliedStandard],
				Nothing,
				True,
				Test["StandardDetectionAntibodyResuspension is True for solid state standard detection antibody samples and not True for liquid state standard detection antibody samples "<>ObjectToString[Complement[suppliedStandard,standardDetectionAntibodyResuspensionInvalidSamples],Cache->simulatedCache]<>" (used for ELISA assay of the standard samples "<>ObjectToString[Complement[suppliedStandardDetectionAntibody,standardDetectionAntibodyResuspensionInvalidAntibodies],Cache->simulatedCache]<>") to resuspend only solid state samples:",True,True]
			];
			failingTest=If[Length[standardDetectionAntibodyResuspensionInvalidSamples]==0,
				Nothing,
				Test["StandardDetectionAntibodyResuspension is True for solid state standard detection antibody samples and not True for liquid state standard detection antibody samples "<>ObjectToString[standardDetectionAntibodyResuspensionInvalidSamples,Cache->simulatedCache]<>" (used for ELISA assay of the standard samples "<>ObjectToString[standardDetectionAntibodyResuspensionInvalidAntibodies,Cache->simulatedCache]<>") to resuspend only solid state samples:",True,False]
			];
			{passingTest,failingTest}
		],
		{}
	];

	(* When StandardDetectionAntibodyResuspension is set to Null or False or StandardDetectionAntibody is in liquid state, all StandardDetectionAntibodyResuspension related options should be Null or Automatic. Get a list of samples with non-Null options and a list of non-Null options. Call helper function mustNullOptionCheck to get the lists. *)
	(* Note that we allow StandardDetectionAntibodyStorageCondition to be non-Null here because it can be applied to the original liquid state sample *)
	standardDetectionAntibodyResuspensionOptions={StandardDetectionAntibodyResuspensionConcentration,StandardDetectionAntibodyResuspensionDiluent};

	(* We need to check the following cases: When StandardDetectionAntibodyResuspension is not True or Automatic, standard detection antibody resuspension options should be Null. If StandardDetectionAntibodyResuspension is Automatic but the StandardDetectionAntibody is in liquid state, the same. *)
	invalidStandardDetectionAntibodyResuspensionRelatedOptionChecks=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		mustNullOptionCheck[StandardDetectionAntibodyResuspension,Except[True|Automatic],standardDetectionAntibodyResuspensionOptions,roundedCapillaryELISAOptionsAssociation],
		{{},{}}
	];

	(* To check the case with liquid-state detection antibody, we create a fake option association *)
	(* Here fakeDetectionantibodyStateOption is not a defined module variable. *)
	invalidStandardDetectionAntibodyResuspensionRelatedOptionLiquidChecks=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		mustNullOptionCheck[fakeStandardDetectionAntibodyStateOption,Liquid,standardDetectionAntibodyResuspensionOptions,Join[<|fakeStandardDetectionAntibodyStateOption->standardDetectionAntibodyStates|>,roundedCapillaryELISAOptionsAssociation]],
		{{},{}}
	];

	(* Get a list of samples and antibodies with non-Null detection antibody resuspension options *)
	invalidStandardDetectionAntibodyResuspensionRelatedOptionSamples=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		Union[PickList[ToList[suppliedStandard],invalidStandardDetectionAntibodyResuspensionRelatedOptionChecks[[1]],False],PickList[ToList[suppliedStandard],invalidStandardDetectionAntibodyResuspensionRelatedOptionLiquidChecks[[1]],False]],
		{}
	];
	invalidStandardDetectionAntibodyResuspensionRelatedOptionAntibodies=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		Union[PickList[suppliedStandardDetectionAntibody,invalidStandardDetectionAntibodyResuspensionRelatedOptionChecks[[1]],False],PickList[suppliedStandardDetectionAntibody,invalidStandardDetectionAntibodyResuspensionRelatedOptionLiquidChecks[[1]],False]],
		{}
	];

	(* Get a list of detection antibody resuspension options with non-Null values. This covers the case when there is no invalid options *)
	invalidStandardDetectionAntibodyResuspensionOptions=Union[invalidStandardDetectionAntibodyResuspensionRelatedOptionChecks[[2]],invalidStandardDetectionAntibodyResuspensionRelatedOptionLiquidChecks[[2]]];

	(* Throw error message if we get invalid samples and options *)
	If[!MatchQ[invalidStandardDetectionAntibodyResuspensionOptions,{}]&&messages,
		Message[Error::CannotSpecifyStandardDetectionAntibodyResuspensionOptions,ObjectToString[invalidStandardDetectionAntibodyResuspensionRelatedOptionAntibodies,Cache->simulatedCache],ToString[invalidStandardDetectionAntibodyResuspensionOptions],ObjectToString[invalidStandardDetectionAntibodyResuspensionRelatedOptionSamples,Cache->simulatedCache]];invalidStandardDetectionAntibodyResuspensionOptions,
		{}
	];

	(* If we are gathering tests, generate tests for invalid detection antibody resuspension related options. *)
	invalidStandardDetectionAntibodyResuspensionTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=If[Length[invalidStandardDetectionAntibodyResuspensionOptions]==Length[standardDetectionAntibodyResuspensionOptions],
				Nothing,
				Test["The standard detection antibody resuspension related options "<>ToString[Complement[standardDetectionAntibodyResuspensionOptions,invalidStandardDetectionAntibodyResuspensionOptions]]<>" are Null for liquid detection antibody samples or the standard detection antibody samples with StandardDetectionAntibodyResuspension set to False or Null:",True,True]
			];
			failingTest=If[Length[invalidStandardDetectionAntibodyResuspensionOptions]==0,
				Nothing,
				Test["The standard detection antibody resuspension related options "<>ToString[invalidStandardDetectionAntibodyResuspensionOptions]<>" are Null for the standard detection antibody samples "<>ObjectToString[invalidStandardDetectionAntibodyResuspensionRelatedOptionAntibodies,Cache->simulatedCache]<>" (used for ELISA assay with samples "<>ObjectToString[invalidStandardDetectionAntibodyResuspensionRelatedOptionSamples,Cache->simulatedCache]<>") with a liquid state or StandardDetectionAntibodyResuspension option set to False or Null:",True,False]
			];
			{passingTest,failingTest}
		],
		{}
	];

	(* When StandardDetectionAntibodyResuspension is set to True, all StandardDetectionAntibodyResuspension related options should be specified or Automatic. Get a list of samples with Null options and a list of Null options. Call helper function mustNotNullOptionCheck to get the lists. *)
	(* StandardDetectionAntibodyStorageCondition can not be Null in this case since we are making a new sample *)
	missingStandardDetectionAntibodyResuspensionOptionChecks=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		mustNotNullOptionCheck[StandardDetectionAntibodyResuspension,True,Append[standardDetectionAntibodyResuspensionOptions,StandardDetectionAntibodyStorageCondition],roundedCapillaryELISAOptionsAssociation],
		{{},{}}
	];

	(* To check the case with solid-state detection antibody, we create a fake option association *)
	(* Here fakeStandardDetectionantibodySateOption is not a defined module variable. *)
	missingStandardDetectionAntibodyResuspensionOptionSolidChecks=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		mustNotNullOptionCheck[fakeStandardDetectionAntibodyStateOption,Solid,Append[standardDetectionAntibodyResuspensionOptions,StandardDetectionAntibodyStorageCondition],Join[<|fakeStandardDetectionAntibodyStateOption->standardDetectionAntibodyStates|>,roundedCapillaryELISAOptionsAssociation]],
		{{},{}}
	];

	(* Get a list of samples and antibodies with Null detection antibody resuspension options *)
	missingStandardDetectionAntibodyResuspensionSamples=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		Union[PickList[ToList[suppliedStandard],missingStandardDetectionAntibodyResuspensionOptionChecks[[1]],False],PickList[ToList[suppliedStandard],missingStandardDetectionAntibodyResuspensionOptionSolidChecks[[1]],False]],
		{}
	];
	missingStandardDetectionAntibodyResuspensionAntibodies=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		Union[PickList[suppliedStandardDetectionAntibody,missingStandardDetectionAntibodyResuspensionOptionChecks[[1]],False],PickList[suppliedStandardDetectionAntibody,missingStandardDetectionAntibodyResuspensionOptionSolidChecks[[1]],False]],
		{}
	];

	(* Get a list of detection antibody resuspension options with Null values. This covers the case when there is no invalid options *)
	missingStandardDetectionAntibodyResuspensionOptions=Union[missingStandardDetectionAntibodyResuspensionOptionChecks[[2]],missingStandardDetectionAntibodyResuspensionOptionSolidChecks[[2]]];

	(* Throw error message if we get invalid samples and options *)
	If[!MatchQ[missingStandardDetectionAntibodyResuspensionOptions,{}]&&messages,
		Message[Error::MustSpecifyStandardDetectionAntibodyResuspensionOptions,ObjectToString[missingStandardDetectionAntibodyResuspensionAntibodies,Cache->simulatedCache],ToString[missingStandardDetectionAntibodyResuspensionOptions],ObjectToString[missingStandardDetectionAntibodyResuspensionSamples,Cache->simulatedCache]];missingStandardDetectionAntibodyResuspensionOptions,
		{}
	];

	(* If we are gathering tests, generate tests for invalid detection antibody resuspension related options. *)
	missingStandardDetectionAntibodyResuspensionTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=If[Length[missingStandardDetectionAntibodyResuspensionOptions]==Length[standardDetectionAntibodyResuspensionOptions]+1,
				Nothing,
				Test["The StandardDetectionAntibodyResuspension related options "<>ToString[Complement[standardDetectionAntibodyResuspensionOptions,missingStandardDetectionAntibodyResuspensionOptions]]<>" are not Null for the stanadard samples with solid state or with StandardDetectionAntibodyResuspension option set to True:",True,True]
			];
			failingTest=If[Length[missingStandardDetectionAntibodyResuspensionOptions]==0,
				Nothing,
				Test["The StandardDetectionAntibodyResuspension related options "<>ToString[missingStandardDetectionAntibodyResuspensionOptions]<>" are not Null for the standard detection antibody samples "<>ObjectToString[missingStandardDetectionAntibodyResuspensionAntibodies,Cache->simulatedCache]<>" (used for ELISA assay of "<>ObjectToString[missingStandardDetectionAntibodyResuspensionSamples,Cache->simulatedCache]<>") with solid state or with StandardDetectionAntibodyResuspension option set to True:",True,False]
			];
			{passingTest,failingTest}
		],
		{}
	];


	(* 24 StandardDetectionAntibody Conjugation Checks *)
	(* When StandardDetectionAntibodyConjugation is set to Null or False, all StandardDetectionAntibodyConjugation related options should be Null or Automatic. Get a list of standard samples with non-Null options and a list of non-Null options. Call helper function mustNullOptionCheck to get the lists. *)
	standardDetectionAntibodyConjugationOptions={
		StandardDetectionAntibodyVolume,
		StandardBiotinReagent,
		StandardBiotinReagentVolume,
		StandardDetectionAntibodyConjugationBuffer,
		StandardDetectionAntibodyConjugationBufferVolume,
		StandardDetectionAntibodyConjugationContainer,
		StandardDetectionAntibodyConjugationTime,
		StandardDetectionAntibodyConjugationTemperature,
		StandardDetectionAntibodyPurificationColumn,
		StandardDetectionAntibodyColumnWashBuffer,
		StandardDetectionAntibodyConjugationStorageCondition
	};

	invalidStandardDetectionAntibodyConjugationRelatedOptionChecks=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		mustNullOptionCheck[StandardDetectionAntibodyConjugation,Except[True|Automatic],standardDetectionAntibodyConjugationOptions,roundedCapillaryELISAOptionsAssociation],
		{{},{}}
	];

	(* Get a list of samples and antibodies with non-Null standard detection antibody conjugation options *)
	invalidStandardDetectionAntibodyConjugationRelatedOptionSamples=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		PickList[ToList[suppliedStandard],invalidStandardDetectionAntibodyConjugationRelatedOptionChecks[[1]],False],
		{}
	];
	invalidStandardDetectionAntibodyConjugationRelatedOptionAntibodies=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		PickList[suppliedStandardDetectionAntibody,invalidStandardDetectionAntibodyConjugationRelatedOptionChecks[[1]],False],
		{}
	];

	(* Get a list of standard detection antibody Conjugation options with non-Null values. This covers the case when there is no invalid options *)
	invalidStandardDetectionAntibodyConjugationOptions=invalidStandardDetectionAntibodyConjugationRelatedOptionChecks[[2]];

	(* Throw error message if we get invalid samples and options *)
	If[!MatchQ[invalidStandardDetectionAntibodyConjugationOptions,{}]&&messages,
		Message[Error::CannotSpecifyStandardDetectionAntibodyConjugationOptions,ObjectToString[invalidStandardDetectionAntibodyConjugationRelatedOptionAntibodies,Cache->simulatedCache],ToString[invalidStandardDetectionAntibodyConjugationOptions],ObjectToString[invalidStandardDetectionAntibodyConjugationRelatedOptionSamples,Cache->simulatedCache]];invalidStandardDetectionAntibodyConjugationOptions,
		{}
	];

	(* If we are gathering tests, generate tests for invalid standard detection antibody Conjugation related options. *)
	invalidStandardDetectionAntibodyConjugationTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=If[Length[invalidStandardDetectionAntibodyConjugationOptions]==Length[standardDetectionAntibodyConjugationOptions],
				Nothing,
				Test["The standard detection antibody Conjugation related options "<>ToString[Complement[standardDetectionAntibodyConjugationOptions,invalidStandardDetectionAntibodyConjugationOptions]]<>" are Null for the detection antibody samples with StandardDetectionAntibodyConjugation set to False or Null:",True,True]
			];
			failingTest=If[Length[invalidStandardDetectionAntibodyConjugationOptions]==0,
				Nothing,
				Test["The standard detection antibody Conjugation related options "<>ToString[invalidStandardDetectionAntibodyConjugationOptions]<>" are Null for the standard detection antibody samples "<>ObjectToString[invalidStandardDetectionAntibodyConjugationRelatedOptionAntibodies,Cache->simulatedCache]<>" (used for ELISA assay with standard samples "<>ObjectToString[invalidStandardDetectionAntibodyConjugationRelatedOptionSamples,Cache->simulatedCache]<>") with StandardDetectionAntibodyConjugation set to False or Null:",True,False]
			];
			{passingTest,failingTest}
		],
		{}
	];

	(* When StandardDetectionAntibodyConjugation is set to True, all StandardDetectionAntibodyConjugation related options should be specified or Automatic. Get a list of standard samples with Null options and a list of Null options. Call helper function mustNotNullOptionCheck to get the lists. *)

	missingStandardDetectionAntibodyConjugationRelatedOptionChecks=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		mustNotNullOptionCheck[StandardDetectionAntibodyConjugation,True,standardDetectionAntibodyConjugationOptions,roundedCapillaryELISAOptionsAssociation],
		{{},{}}
	];

	(* Get a list of samples and antibodies with Null standard detection antibody conjugation options *)
	missingStandardDetectionAntibodyConjugationRelatedOptionSamples=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		PickList[ToList[suppliedStandard],missingStandardDetectionAntibodyConjugationRelatedOptionChecks[[1]],False],
		{}
	];
	missingStandardDetectionAntibodyConjugationRelatedOptionAntibodies=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		PickList[suppliedStandardDetectionAntibody,missingStandardDetectionAntibodyConjugationRelatedOptionChecks[[1]],False],
		{}
	];

	(* Get a list of standard detection antibody Conjugation options with Null values. This covers the case when there is no missing options *)
	missingStandardDetectionAntibodyConjugationOptions=missingStandardDetectionAntibodyConjugationRelatedOptionChecks[[2]];

	(* Throw error message if we get missing samples and options *)
	If[!MatchQ[missingStandardDetectionAntibodyConjugationOptions,{}]&&messages,
		Message[Error::MustSpecifyStandardDetectionAntibodyConjugationOptions,ObjectToString[missingStandardDetectionAntibodyConjugationRelatedOptionAntibodies,Cache->simulatedCache],ToString[missingStandardDetectionAntibodyConjugationOptions],ObjectToString[missingStandardDetectionAntibodyConjugationRelatedOptionSamples,Cache->simulatedCache]];missingStandardDetectionAntibodyConjugationOptions,
		{}
	];

	(* If we are gathering tests, generate tests for missing standard detection antibody Conjugation related options. *)
	missingStandardDetectionAntibodyConjugationTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=If[Length[missingStandardDetectionAntibodyConjugationOptions]==Length[standardDetectionAntibodyConjugationOptions],
				Nothing,
				Test["The standard detection antibody Conjugation related options "<>ToString[Complement[standardDetectionAntibodyConjugationOptions,missingStandardDetectionAntibodyConjugationOptions]]<>" are not Null for the detection antibody samples with StandardDetectionAntibodyConjugation set to True:",True,True]
			];
			failingTest=If[Length[missingStandardDetectionAntibodyConjugationOptions]==0,
				Nothing,
				Test["The standard detection antibody Conjugation related options "<>ToString[missingStandardDetectionAntibodyConjugationOptions]<>" are Null for the standard detection antibody samples "<>ObjectToString[missingStandardDetectionAntibodyConjugationRelatedOptionAntibodies,Cache->simulatedCache]<>" (used for ELISA assay with standard samples "<>ObjectToString[missingStandardDetectionAntibodyConjugationRelatedOptionSamples,Cache->simulatedCache]<>") with StandardDetectionAntibodyConjugation set to True:",True,False]
			];
			{passingTest,failingTest}
		],
		{}
	];

	(* Note that we check the reaction ratio of antibody sample and conjugation reagent in the MapThread to avoid resolving the concentrations twice. *)
	(* Note that we check whether the total preparation volume of each conjugated standard detection antibody sample is larger than the MaxVolume of the specified StandardDetectionAntibodyConjugationContainer, the specified StandardDetectionAntibodyPurificationColumn and the specified StandardDetectionAntibodyStorageContainer also within the MapThread. Because we need to resolve the concentrations and volumes, we don't want to perform the process twice for conflicting check. *)

	(* We should not have a mixed Null/Not-Null conjugation options when StandardDetectionAntibodyConjugation is set to Automatic. In that case, we cannot resolve the correct boolean value. Get the list of samples with a mixing set of options. *)
	standardDetectionAntibodyConjugationOptionValues=Lookup[roundedCapillaryELISAOptionsAssociation,Prepend[standardDetectionAntibodyConjugationOptions,StandardDetectionAntibodyConjugation]];

	standardDetectionAntibodyConjugationOptionConflictQ=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		MapThread[
			Function[
				{conjugation,antibodyVolume,conjugationReagent,conjugationReagentVolume,conjugationBuffer,conjugationBufferVolume,conjugationContainer,conjugationTime,conjugationTemperature,purificationColumn,washBuffer,storageCondition},
				If[MatchQ[conjugation,Automatic],
					And[
						MemberQ[{antibodyVolume,conjugationReagent,conjugationReagentVolume,conjugationBuffer,conjugationBufferVolume,conjugationContainer,conjugationTime,conjugationTemperature,purificationColumn,washBuffer,storageCondition},Null],
						MemberQ[{antibodyVolume,conjugationReagent,conjugationReagentVolume,conjugationBuffer,conjugationBufferVolume,conjugationContainer,conjugationTime,conjugationTemperature,purificationColumn,washBuffer,storageCondition},Except[Null|Automatic]]
					],
					False
				]
			],
			standardDetectionAntibodyConjugationOptionValues
		],
		{}
	];

	(* Get the list of standard samples with conflicting options *)
	standardDetectionAntibodyConjugationOptionConflictSamples=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		PickList[ToList[suppliedStandard],standardDetectionAntibodyConjugationOptionConflictQ],
		{}
	];
	standardDetectionAntibodyConjugationOptionConflictAntibodies=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		PickList[suppliedStandardDetectionAntibody,standardDetectionAntibodyConjugationOptionConflictQ],
		{}
	];

	(* Throw error message if we get invalid samples and options *)
	standardDetectionAntibodyConjugationConflictOptions=If[!MatchQ[standardDetectionAntibodyConjugationOptionConflictSamples,{}]&&messages,
		Message[Error::ConflictStandardDetectionAntibodyConjugationOptions,ObjectToString[standardDetectionAntibodyConjugationOptionConflictAntibodies,Cache->simulatedCache],ObjectToString[standardDetectionAntibodyConjugationOptionConflictSamples,Cache->simulatedCache]];standardDetectionAntibodyConjugationOptions,
		{}
	];

	(* If we are gathering tests, generate tests for conflicting standard detection antibody Conjugation related options. *)
	standardDetectionAntibodyConjugationOptionConflictTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=Which[
				MatchQ[suppliedStandard,Automatic|Null|{}],
				Test["StandardDetectionAntibodyConjugation related options should be all Null or not Null for standard detection antibody samples so the value of StandardDetectionAntibodyConjugation can be selected:",True,True],
				Length[standardDetectionAntibodyConjugationOptionConflictSamples]==Length[suppliedStandard],
				Nothing,
				True,
				Test["StandardDetectionAntibodyConjugation related options should be all Null or not Null for standard detection antibody samples "<>ObjectToString[PickList[ToList[suppliedStandard],standardDetectionAntibodyConjugationOptionConflictQ,False],Cache->simulatedCache]<>" (used for ELISA assay with samples "<>ObjectToString[PickList[suppliedStandardDetectionAntibody,standardDetectionAntibodyConjugationOptionConflictQ,False],Cache->simulatedCache]<>") so the value of StandardDetectionAntibodyConjugation option can be selected:",True,True]
			];
			failingTest=If[Length[standardDetectionAntibodyConjugationOptionConflictSamples]==0,
				Nothing,
				Test["StandardDetectionAntibodyConjugation related options should be all Null or not Null for standard detection antibody samples "<>ObjectToString[standardDetectionAntibodyConjugationOptionConflictAntibodies,Cache->simulatedCache]<>" (used for ELISA assay with samples "<>ObjectToString[standardDetectionAntibodyConjugationOptionConflictSamples,Cache->simulatedCache]<>") so the value of StandardDetectionAntibodyConjugation option can be selected:",True,False]
			];
			{passingTest,failingTest}
		],
		{}
	];


	(* Note that we check the reaction ratio of antibody sample and conjugation reagent in the MapThread to avoid resolving the concentrations twice. *)
	(* Note that we check whether the total preparation volume of each conjugated standard detection antibody sample is larger than the MaxVolume of the specified StandardDetectionAntibodyConjugationContainer, the specified StandardDetectionAntibodyPurificationColumn and the specified StandardDetectionAntibodyStorageContainer also within the MapThread. Because we need to resolve the concentrations and volumes, we don't want to perform the process twice for conflicting check. *)

	(* The specified StandardDetectionAntibodyPurificationColumn is a supported spin column, preferrably 40 K MWCO *)
	(* TODO If we have a better plan later to put these spin columns into SPE, we can avoid hard-coding this list of supported spin columns. *)

	(* Right now, It is NOT a good idea to support regular filter as it will require getting the redundant at the top of the filter. Also, washing/collection of the sample will need more manipulations. *)
	(* We only support 6 different types of 7K/40K MWCO spin column, with different capacities. *)
	(* Check whether each of the supplied spin column is supported, with the first boolean indicating 7K/40K for error checking while the second boolean indicating 40K for warning *)
	suppliedStandardDetectionAntibodyPurificationColumnMWCO=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		MapThread[
			{
				Or[
					MatchQ[#1,Automatic|Null],
					MatchQ[
						#2,
						ObjectP[potentialSpinColumns]
					],
					MatchQ[
						Lookup[#2,Model,Null],
						ObjectP[potentialSpinColumns]
					]
				],
				Or[
					MatchQ[#1,Automatic|Null],
					MatchQ[
						#2,
						ObjectP[potential40KSpinColumns]
					],
					MatchQ[
						Lookup[#2,Model,Null],
						ObjectP[potential40KSpinColumns]
					]
				]
			}&,
			{suppliedStandardDetectionAntibodyPurificationColumn,suppliedStandardDetectionAntibodyPurificationColumnPackets}
		],
		{}
	];

	(* Throw an error message if we find a purification column that is not supported. *)
	unsupportedStandardDetectionAntibodyPurificationColumnOption=If[MemberQ[suppliedStandardDetectionAntibodyPurificationColumnMWCO,{False,False}]&&messages,
		Message[Error::UnsupportedStandardDetectionAntibodyPurificationColumn,ObjectToString[PickList[suppliedStandardDetectionAntibody,suppliedStandardDetectionAntibodyPurificationColumnMWCO,{False,False}],Cache->simulatedCache],ObjectToString[PickList[ToList[suppliedStandard],suppliedStandardDetectionAntibodyPurificationColumnMWCO,{False,False}],Cache->simulatedCache],ObjectToString[potential40KSpinColumns,Cache->simulatedCache]];{StandardDetectionAntibodyPurificationColumn},
		Nothing
	];

	(* Throw a warning message if we find a purification column that is not 40K MWCO. We only throw warning when an error is not thrown*)
	If[MemberQ[suppliedStandardDetectionAntibodyPurificationColumnMWCO,{True,False}]&&!MatchQ[$ECLApplication,Engine]&&messages,
		Message[Warning::NonOptimalStandardDetectionAntibodyPurificationColumn,ObjectToString[PickList[suppliedStandardDetectionAntibody,suppliedStandardDetectionAntibodyPurificationColumnMWCO,{True,False}],Cache->simulatedCache],ObjectToString[PickList[ToList[suppliedStandard],suppliedStandardDetectionAntibodyPurificationColumnMWCO,{True,False}],Cache->simulatedCache],ObjectToString[potential40KSpinColumns,Cache->simulatedCache]],
		Nothing
	];

	(* If we are gathering tests, generate tests for unsupported standard detection antibody purification column  *)
	unsupportedStandardDetectionAntibodyPurificationColumnTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=Which[
				MatchQ[suppliedStandard,Automatic|Null|{}]||!resolvedCustomizableCartridgeQ,
				Test["The specified StandardDetectionAntibodyPurificationColumn is a supported Zeba spin column (preferably 40K MWCO) for the standard detection antibody samples:",True,True],
				!MemberQ[suppliedStandardDetectionAntibodyPurificationColumnMWCO,{True,_}],
				Nothing,
				True,
				Test["The specified StandardDetectionAntibodyPurificationColumn is a supported Zeba spin column (preferably 40K MWCO) for the standard detection antibody samples "<>ObjectToString[PickList[suppliedStandardDetectionAntibody,suppliedStandardDetectionAntibodyPurificationColumnMWCO,{True,_}],Cache->simulatedCache]<>", used for ELISA assay of the samples "<>ObjectToString[PickList[ToList[suppliedStandard],suppliedStandardDetectionAntibodyPurificationColumnMWCO,{True,_}],Cache->simulatedCache],True,True]
			];
			failingTest=If[!MemberQ[suppliedStandardDetectionAntibodyPurificationColumnMWCO,{False,False}],
				Nothing,
				Test["The specified StandardDetectionAntibodyPurificationColumn is a supported Zeba spin column (preferably 40K MWCO) for the standard detection antibody samples "<>ObjectToString[PickList[suppliedStandardDetectionAntibody,suppliedStandardDetectionAntibodyPurificationColumnMWCO,{False,False}],Cache->simulatedCache]<>", used for ELISA assay of the samples "<>ObjectToString[PickList[ToList[suppliedStandard],suppliedStandardDetectionAntibodyPurificationColumnMWCO,{False,False}],Cache->simulatedCache],True,False]
			];
			{passingTest,failingTest}
		],
		{}
	];

	(* If we are gathering tests, generate tests for non-optimal standard detection antibody purification column *)
	nonOptimalStandardDetectionAntibodyPurificationColumnTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=Which[
				MatchQ[suppliedStandard,Automatic|Null|{}]||!resolvedCustomizableCartridgeQ,
				Test["The specified StandardDetectionAntibodyPurificationColumn is 40K MWCO for the standard detection antibody samples:",True,True],
				!MemberQ[suppliedStandardDetectionAntibodyPurificationColumnMWCO,{True,True}],
				Nothing,
				True,
				Test["The specified StandardDetectionAntibodyPurificationColumn is 40K MWCO for the standard detection antibody samples "<>ObjectToString[PickList[suppliedStandardDetectionAntibody,suppliedStandardDetectionAntibodyPurificationColumnMWCO,{True,True}],Cache->simulatedCache]<>", used for ELISA assay of the samples "<>ObjectToString[PickList[ToList[suppliedStandard],suppliedStandardDetectionAntibodyPurificationColumnMWCO,{True,True}],Cache->simulatedCache],True,True]
			];
			failingTest=If[!MemberQ[suppliedStandardDetectionAntibodyPurificationColumnMWCO,{_,False}],
				Nothing,
				Test["The specified StandardDetectionAntibodyPurificationColumn is 40K MWCO for the standard detection antibody samples "<>ObjectToString[PickList[suppliedStandardDetectionAntibody,suppliedStandardDetectionAntibodyPurificationColumnMWCO,{_,False}],Cache->simulatedCache]<>", used for ELISA assay of the samples "<>ObjectToString[PickList[ToList[suppliedStandard],suppliedStandardDetectionAntibodyPurificationColumnMWCO,{_,False}],Cache->simulatedCache],True,False]
			];
			{passingTest,failingTest}
		],
		{}
	];


	(* 25 StandardDetectionAntibody Dilution Checks *)
	(* When StandardDetectionAntibodyDilution is set to Null, all StandardDetectionAntibodyDilution related options should be Null or Automatic. Get a list of standard samples with non-Null options and a list of non-Null options. Call helper function mustNullOptionCheck to get the lists. *)
	standardDetectionAntibodyDilutionOptions={StandardDetectionAntibodyTargetConcentration,StandardDetectionAntibodyDiluent};

	invalidStandardDetectionAntibodyDilutionRelatedOptionChecks=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		mustNullOptionCheck[StandardDetectionAntibodyDilution,Null|False,standardDetectionAntibodyDilutionOptions,roundedCapillaryELISAOptionsAssociation],
		{{},{}}
	];

	(* Get a list of samples and antibodies with non-Null standard detection antibody Dilution options *)
	invalidStandardDetectionAntibodyDilutionRelatedOptionSamples=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		PickList[ToList[suppliedStandard],invalidStandardDetectionAntibodyDilutionRelatedOptionChecks[[1]],False],
		{}
	];
	invalidStandardDetectionAntibodyDilutionRelatedOptionAntibodies=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		PickList[suppliedStandardDetectionAntibody,invalidStandardDetectionAntibodyDilutionRelatedOptionChecks[[1]],False],
		{}
	];

	(* Get a list of standard detection antibody Dilution options with non-Null values. This covers the case when there is no invalid options *)
	invalidStandardDetectionAntibodyDilutionOptions=invalidStandardDetectionAntibodyDilutionRelatedOptionChecks[[2]];

	(* Throw error message if we get invalid samples and options *)
	If[!MatchQ[invalidStandardDetectionAntibodyDilutionOptions,{}]&&messages,
		Message[Error::CannotSpecifyStandardDetectionAntibodyDilutionOptions,ObjectToString[invalidStandardDetectionAntibodyDilutionRelatedOptionAntibodies,Cache->simulatedCache],ToString[invalidStandardDetectionAntibodyDilutionOptions],ObjectToString[invalidStandardDetectionAntibodyDilutionRelatedOptionSamples,Cache->simulatedCache]];invalidStandardDetectionAntibodyDilutionOptions,
		{}
	];

	(* If we are gathering tests, generate tests for invalid standard detection antibody Dilution related options. *)
	invalidStandardDetectionAntibodyDilutionTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=Which[
				MatchQ[suppliedStandard,Automatic|Null|{}]||!resolvedCustomizableCartridgeQ,
				Test["The specified standard detection antibody dilution related options are Null for the standard detection antibody samples with StandardDetectionAntibodyDilution set to Null:",True,True],
				Length[invalidStandardDetectionAntibodyDilutionOptions]==Length[standardDetectionAntibodyDilutionOptions],
				Nothing,
				True,
				Test["The standard detection antibody dilution related options "<>ToString[Complement[standardDetectionAntibodyDilutionOptions,invalidStandardDetectionAntibodyDilutionOptions]]<>" are Null for the standard detection antibody samples with StandardDetectionAntibodyDilution set to Null or False:",True,True]
			];
			failingTest=If[Length[invalidStandardDetectionAntibodyDilutionOptions]==0,
				Nothing,
				Test["The standard detection antibody Dilution related options "<>ToString[invalidStandardDetectionAntibodyDilutionOptions]<>" are Null for the standard detection antibody samples "<>ObjectToString[invalidStandardDetectionAntibodyDilutionRelatedOptionAntibodies,Cache->simulatedCache]<>" (used for ELISA assay with standard samples "<>ObjectToString[invalidStandardDetectionAntibodyDilutionRelatedOptionSamples,Cache->simulatedCache]<>") with StandardDetectionAntibodyDilution set to Null or False:",True,False]
			];
			{passingTest,failingTest}
		],
		{}
	];

	(* When the standard detection antibody sample goes through either resuspension or conjugation process in this protocol, it is recommend to do dilution - StandardDetectionAntibodyDilution is not set to Null/False. *)
	missingRecommendedStandardDetectionAntibodyDilutionQ=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		MapThread[
			MatchQ[{Lookup[#1,State,Null],#2,#3},{Solid,_,Null|False}|{_,True,Null|False}]&,
			{suppliedStandardDetectionAntibodyPackets,suppliedStandardDetectionAntibodyConjugation,suppliedStandardDetectionAntibodyDilution}
		],
		{}
	];

	(* Get a list of samples and antibodies with null standard detection antibody dilution option but a dilution is recommended *)
	missingRecommendedStandardDetectionAntibodyDilutionSamples=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		PickList[ToList[suppliedStandard],missingRecommendedStandardDetectionAntibodyDilutionQ],
		{}
	];
	missingRecommendedStandardDetectionAntibodyDilutionAntibodies=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		PickList[suppliedStandardDetectionAntibody,missingRecommendedStandardDetectionAntibodyDilutionQ],
		{}
	];

	(* Throw warning message if we get samples for which a dilution is recommended *)
	If[!MatchQ[missingRecommendedStandardDetectionAntibodyDilutionSamples,{}]&&!MatchQ[$ECLApplication,Engine]&&messages,
		Message[Warning::StandardDetectionAntibodyDilutionRecommended,ObjectToString[missingRecommendedStandardDetectionAntibodyDilutionAntibodies,Cache->simulatedCache],ObjectToString[missingRecommendedStandardDetectionAntibodyDilutionSamples,Cache->simulatedCache]],
		Nothing
	];

	(* If we are gathering tests, generate tests for the samples for which a dilution is recommended *)
	missingRecommendedStandardDetectionAntibodyDilutionTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=Which[
				MatchQ[suppliedStandard,Automatic|Null|{}]||!resolvedCustomizableCartridgeQ,
				Test["The StandardDetectionAntibodyDilution option is not Null for the detection antibody samples when it is either resuspended or conjugated in this protocol:",True,True],
				Length[missingRecommendedStandardDetectionAntibodyDilutionSamples]==Length[suppliedStandard],
				Nothing,
				True,
				Test["The StandardDetectionAntibodyDilution option is not Null for the detection antibody samples "<>ObjectToString[Complement[suppliedStandardDetectionAntibody,missingRecommendedStandardDetectionAntibodyDilutionAntibodies],Cache->simulatedCache]<>" (for ELISA assay of "<>ObjectToString[Complement[suppliedStandard,missingRecommendedStandardDetectionAntibodyDilutionSamples],Cache->simulatedCache]<>") when it is either resuspended or conjugated in this protocol:",True,True]
			];
			failingTest=If[Length[invalidStandardDetectionAntibodyDilutionOptions]==0,
				Nothing,
				Test["The StandardDetectionAntibodyDilution option is not Null for the detection antibody samples "<>ObjectToString[missingRecommendedStandardDetectionAntibodyDilutionAntibodies,Cache->simulatedCache]<>" (for ELISA assay of "<>ObjectToString[missingRecommendedStandardDetectionAntibodyDilutionSamples,Cache->simulatedCache]<>") when it is either resuspended or conjugated in this protocol:",True,False]
			];
			{passingTest,failingTest}
		],
		{}
	];

	(* When StandardDetectionAntibodyDilution is True, StandardDetectionAntibodyTargetConcentration and StandardDetectionAntibodyDiluent should not be Null. Get a list of samples with Null option. Call helper function mustNotNullOptionCheck to get the lists. *)
	missingStandardDetectionAntibodyDilutionOptionsChecks=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		mustNotNullOptionCheck[StandardDetectionAntibodyDilution,True,standardDetectionAntibodyDilutionOptions,roundedCapillaryELISAOptionsAssociation],
		{{},{}}
	];

	(* Get a list of samples and antibodies with Null standard detection antibody Dilution options *)
	missingStandardDetectionAntibodyDilutionOptionsSamples=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		PickList[ToList[suppliedStandard],missingStandardDetectionAntibodyDilutionOptionsChecks[[1]],False],
		{}
	];
	missingStandardDetectionAntibodyDilutionOptionsAntibodies=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		PickList[suppliedStandardDetectionAntibody,missingStandardDetectionAntibodyDilutionOptionsChecks[[1]],False],
		{}
	];

	(* Get a list of standard detection antibody Dilution options with Null values. This covers the case when there is no invalid options *)
	missingStandardDetectionAntibodyDilutionOptions=missingStandardDetectionAntibodyDilutionOptionsChecks[[2]];

	(* Throw error message if we get invalid samples and options *)
	If[!MatchQ[missingStandardDetectionAntibodyDilutionOptions,{}]&&messages,
		Message[Error::MustSpecifyStandardDetectionAntibodyDilutionOptions,ObjectToString[missingStandardDetectionAntibodyDilutionOptionsAntibodies,Cache->simulatedCache],ToString[missingStandardDetectionAntibodyDilutionOptions],ObjectToString[missingStandardDetectionAntibodyDilutionOptionsSamples,Cache->simulatedCache]];missingStandardDetectionAntibodyDilutionOptions,
		{}
	];

	(* If we are gathering tests, generate tests for missing StandardDetectionAntibodyDiluent. *)
	missingStandardDetectionAntibodyDilutionOptionTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=Which[
				MatchQ[suppliedStandard,Automatic|Null|{}]||!resolvedCustomizableCartridgeQ,
				Test["The standard detection antibody dilution related options are not Null for the detection antibody samples with StandardDetectionAntibodyDilution set to True:",True,True],
				Length[missingStandardDetectionAntibodyDilutionOptions]==Length[standardDetectionAntibodyDilutionOptions],
				Nothing,
				True,
				Test["The standard detection antibody dilution related options "<>ToString[Complement[standardDetectionAntibodyDilutionOptions,missingStandardDetectionAntibodyDilutionOptions]]<>" are not Null for the standard detection antibody samples with StandardDetectionAntibodyDilution set to True:",True,True]
			];
			failingTest=If[Length[missingStandardDetectionAntibodyDilutionOptions]==0,
				Nothing,
				Test["The StandardDetectionAntibodyDiluent options "<>ToString[missingStandardDetectionAntibodyDilutionOptions]<>" are not Null for the standard detection antibody samples "<>ObjectToString[missingStandardDetectionAntibodyDilutionOptionsAntibodies,Cache->simulatedCache]<>" (for ELISA assay of "<>ObjectToString[missingStandardDetectionAntibodyDilutionOptionsSamples,Cache->simulatedCache]<>") when its StandardDetectionAntibodyDilution is not Null:",True,False]
			];
			{passingTest,failingTest}
		],
		{}
	];

	(* We should not have a mixed Null/Not-Null dilution options when StandardDetectionAntibodyDilution is set to Automatic. In that case, we cannot resolve the correct boolean value. Get the list of samples with a mixing set of options. *)
	standardDetectionAntibodyDilutionOptionValues=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		Lookup[roundedCapillaryELISAOptionsAssociation,Prepend[standardDetectionAntibodyDilutionOptions,StandardDetectionAntibodyDilution]],
		{}
	];

	standardDetectionAntibodyDilutionOptionConflictQ=MapThread[
		MatchQ[{#1,#2,#3},{Automatic,Except[Null|Automatic],Null}|{Automatic,Null,Except[Null|Automatic]}]&,
		standardDetectionAntibodyDilutionOptionValues
	];

	(* Get the list of samples with conflicting options *)
	standardDetectionAntibodyDilutionOptionConflictSamples=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		PickList[ToList[suppliedStandard],standardDetectionAntibodyDilutionOptionConflictQ],
		{}
	];
	standardDetectionAntibodyDilutionOptionConflictAntibodies=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		PickList[suppliedStandardDetectionAntibody,standardDetectionAntibodyDilutionOptionConflictQ],
		{}
	];

	(* Throw error message if we get invalid samples and options *)
	standardDetectionAntibodyDilutionConflictOptions=If[!MatchQ[standardDetectionAntibodyDilutionOptionConflictSamples,{}]&&messages,
		Message[Error::ConflictStandardDetectionAntibodyDilutionOptions,ObjectToString[standardDetectionAntibodyDilutionOptionConflictAntibodies,Cache->simulatedCache],ObjectToString[standardDetectionAntibodyDilutionOptionConflictSamples,Cache->simulatedCache]];standardDetectionAntibodyDilutionOptions,
		{}
	];

	(* If we are gathering tests, generate tests for conflicting standard detection antibody dilution related options. *)
	standardDetectionAntibodyDilutionOptionConflictTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=Which[
				MatchQ[suppliedStandard,Null|{}|Automatic]||!resolvedCustomizableCartridgeQ,
				Test["StandardDetectionAntibodyTargetConcentration and StandardDetectionAntibodyDiluent options should be both Null or not Null for standard detection antibody samples so the value of StandardDetectionAntibodyDilution option can be selected:",True,True],
				Length[standardDetectionAntibodyDilutionOptionConflictSamples]==Length[suppliedStandard],
				Nothing,
				True,
				Test["StandardDetectionAntibodyTargetConcentration and StandardDetectionAntibodyDiluent options should be both Null or not Null for standard detection antibody samples "<>ObjectToString[PickList[ToList[suppliedStandard],standardDetectionAntibodyDilutionOptionConflictQ,False],Cache->simulatedCache]<>" (used for ELISA assay with samples "<>ObjectToString[PickList[suppliedStandardDetectionAntibody,standardDetectionAntibodyDilutionOptionConflictQ,False],Cache->simulatedCache]<>") so the value of StandardDetectionAntibodyDilution option can be selected:",True,True]
			];
			failingTest=If[Length[standardDetectionAntibodyDilutionOptionConflictSamples]==0,
				Nothing,
				Test["StandardDetectionAntibodyTargetConcentration and StandardDetectionAntibodyDiluent options should be both Null or not Null for standard detection antibody samples "<>ObjectToString[standardDetectionAntibodyDilutionOptionConflictAntibodies,Cache->simulatedCache]<>" (used for ELISA assay with samples "<>ObjectToString[standardDetectionAntibodyDilutionOptionConflictSamples,Cache->simulatedCache]<>") so the value of StandardDetectionAntibodyDilution option can be selected:",True,False]
			];
			{passingTest,failingTest}
		],
		{}
	];

	(* StandardDetectionAntibodyDiluent should be Model[Sample, "Simple Plex Reagent Diluent"] for optimized result. Get a list of standard samples with non-optimized standard detection antibody diluent. *)
	nonOptimalStandardDetectionAntibodyDiluentQ=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		Map[
			!MatchQ[#,Automatic|Null|Model[Sample, "id:pZx9jo8LZ7z5"]]&, (* Model[Sample,"Simple Plex Reagent Diluent"] *)
			suppliedStandardDetectionAntibodyDiluentModels
		],
		{}
	];

	(* Get a list of samples and antibodies with StandardDetectionAntibodyDiluent not set to Model[Sample, "Simple Plex Reagent Diluent"]  or an object with this model *)
	nonOptimalStandardDetectionAntibodyDiluentSamples=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		PickList[ToList[suppliedStandard],nonOptimalStandardDetectionAntibodyDiluentQ],
		{}
	];
	nonOptimalStandardDetectionAntibodyDiluentAntibodies=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		PickList[suppliedStandardDetectionAntibody,nonOptimalStandardDetectionAntibodyDiluentQ],
		{}
	];

	(* Throw warning message is we get a non-optimal diluent *)
	If[MemberQ[nonOptimalStandardDetectionAntibodyDiluentQ,True]&&!MatchQ[$ECLApplication,Engine]&&messages,
		Message[Warning::NonOptimalStandardDetectionAntibodyDiluent,ObjectToString[nonOptimalStandardDetectionAntibodyDiluentAntibodies,Cache->simulatedCache],ObjectToString[nonOptimalStandardDetectionAntibodyDiluentSamples,Cache->simulatedCache]];{StandardDetectionAntibodyDiluent},
		{}
	];

	(* If we are gathering tests, generate tests for non-optimal StandardDetectionAntibodyDiluent. *)
	nonOptimalStandardDetectionAntibodyDiluentTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=Which[
				MatchQ[suppliedStandard,Null|{}|Automatic]||!resolvedCustomizableCartridgeQ,
				Test["The StandardDetectionAntibodyDiluent option is kept as Model[Sample,\"Simple Plex Reagent Diluent\"] or a sample with this model for the standard detection antibody samples:",True,True],
				Length[nonOptimalStandardDetectionAntibodyDiluentSamples]==Length[suppliedStandard],
				Nothing,
				True,
				Test["The StandardDetectionAntibodyDiluent option is kept as Model[Sample,\"Simple Plex Reagent Diluent\"] or a sample with this model for the standard detection antibody samples "<>ObjectToString[Complement[suppliedStandardDetectionAntibody,nonOptimalStandardDetectionAntibodyDiluentAntibodies],Cache->simulatedCache]<>" (for ELISA assay of "<>ObjectToString[Complement[suppliedStandard,nonOptimalStandardDetectionAntibodyDiluentSamples],Cache->simulatedCache]<>") for optimized dilution and ELISA results:",True,True]
			];
			failingTest=If[Length[missingStandardDetectionAntibodyDiluentSamples]==0,
				Nothing,
				Test["The StandardDetectionAntibodyDiluent option is kept as Model[Sample,\"Simple Plex Reagent Diluent\"] or a sample with this model for the standard detection antibody samples "<>ObjectToString[nonOptimalStandardDetectionAntibodyDiluentAntibodies,Cache->simulatedCache]<>" (for ELISA assay of "<>ObjectToString[nonOptimalStandardDetectionAntibodyDiluentSamples,Cache->simulatedCache]<>") for optimized dilution and ELISA results:",True,False]
			];
			{passingTest,failingTest}
		],
		{}
	];

	(* When StandardDetectionAntibody is not Null, StandardDetectionAntibodyLoadingVolume should not be Null. Get a list of standard samples with Null option. Call helper function mustNotNullOptionCheck to get the lists. *)
	missingStandardDetectionAntibodyLoadingVolumeChecks=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		mustNotNullOptionCheck[StandardDetectionAntibody,Except[Null|Automatic],{StandardDetectionAntibodyLoadingVolume},roundedCapillaryELISAOptionsAssociation][[1]],
		{}
	];

	(* Get a list of samples and antibodies with Null StandardDetectionAntibodyLoadingVolume *)
	missingStandardDetectionAntibodyLoadingVolumeSamples=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		PickList[ToList[suppliedStandard],missingStandardDetectionAntibodyLoadingVolumeChecks,False],
		{}
	];
	missingStandardDetectionAntibodyLoadingVolumeAntibodies=If[!MatchQ[suppliedStandard,Null|{}|Automatic],
		PickList[suppliedStandardDetectionAntibody,missingStandardDetectionAntibodyLoadingVolumeChecks,False],
		{}
	];

	(* Throw error message if we get invalid samples and options *)
	missingStandardDetectionAntibodyLoadingVolumeOption=If[!MatchQ[missingStandardDetectionAntibodyLoadingVolumeSamples,{}]&&messages,
		Message[Error::MustSpecifyStandardDetectionAntibodyLoadingVolume,ObjectToString[missingStandardDetectionAntibodyLoadingVolumeAntibodies,Cache->simulatedCache],ObjectToString[missingStandardDetectionAntibodyLoadingVolumeSamples,Cache->simulatedCache]];{StandardDetectionAntibodyLoadingVolume},
		{}
	];

	(* If we are gathering tests, generate tests for missing StandardDetectionAntibodyLoadingVolume. *)
	missingStandardDetectionAntibodyLoadingVolumeTests=If[gatherTests,
		Module[{passingTest,failingTest},
			passingTest=Which[
				MatchQ[suppliedStandard,Automatic|Null|{}]||!resolvedCustomizableCartridgeQ,
				Test["When a customizable cartridge is used, the StandardDetectionAntibodyLoadingVolume option is not Null for the standard detection antibody samples:",True,True],
				Length[missingStandardDetectionAntibodyDilutionStorageConditionSamples]==Length[suppliedStandard],
				Nothing,
				True,
				Test["When a customizable cartridge is used, the StandardDetectionAntibodyLoadingVolume option is not Null for the standard detection antibody samples "<>ObjectToString[Complement[suppliedStandardDetectionAntibody,missingStandardDetectionAntibodyLoadingVolumeAntibodies],Cache->simulatedCache]<>", used for ELISA assay of "<>ObjectToString[Complement[suppliedStandard,missingStandardDetectionAntibodyLoadingVolumeSamples],Cache->simulatedCache],True,True]
			];
			failingTest=If[Length[missingStandardDetectionAntibodyDilutionStorageConditionSamples]==0,
				Nothing,
				Test["When a customizable cartridge is used, the StandardDetectionAntibodyLoadingVolume option is not Null for the standard detection antibody samples "<>ObjectToString[missingStandardDetectionAntibodyLoadingVolumeAntibodies,Cache->simulatedCache]<>", used for ELISA assay of "<>ObjectToString[missingStandardDetectionAntibodyLoadingVolumeSamples,Cache->simulatedCache],True,False]
			];
			{passingTest,failingTest}
		],
		{}
	];


	(* 26 WashBuffer Check *)
	(* Throw a warning message if wash buffer is not optimal *)
	If[!MatchQ[suppliedWashBufferModel,ObjectReferenceP[Model[Sample, "id:4pO6dM50p9kw"]]]&&!MatchQ[$ECLApplication,Engine], (* Model[Sample,"Simple Plex Wash Buffer"]  *)
		Message[Warning::NonOptimalWashBuffer],
		Nothing
	];

	(* Generate Tests for non optimal wash buffer *)
	nonOptimalWashBufferTests=Test[
		"The wash buffer should be Model[Sample,\"Simple Plex Wash Buffer\"] or an object with this model, as provided by the assay developer, for the best washing result:",
		MatchQ[suppliedWashBufferModel,ObjectReferenceP[Model[Sample, "id:4pO6dM50p9kw"]]], (* Model[Sample,"Simple Plex Wash Buffer"] *)
		True
	];

	(* 27 Antibodies used across different samples *)
	(* When the same Object[Sample] is used as CustomCaptureAntibody, CustomDetectionAntibody, StandardCaptureAntibody, StandardDetectionAntibody, we want to resolve option based on the options provided across different samples *)

	(* CustomCaptureAntibody and CustomDetectionAntibody options must be expanded *)
	customCaptureAntibodyOptionValues=Transpose[
		Join[
			Lookup[
				roundedCapillaryELISAOptionsAssociation,
				{
					CustomCaptureAntibody,
					CaptureAntibodyResuspension,
					CaptureAntibodyResuspensionConcentration,
					CaptureAntibodyResuspensionDiluent,
					CaptureAntibodyStorageCondition,
					CaptureAntibodyConjugation,
					CaptureAntibodyVolume,
					DigoxigeninReagent,
					DigoxigeninReagentVolume,
					CaptureAntibodyConjugationBuffer,
					CaptureAntibodyConjugationBufferVolume,
					CaptureAntibodyConjugationContainer,
					CaptureAntibodyConjugationTime,
					CaptureAntibodyConjugationTemperature,
					CaptureAntibodyPurificationColumn,
					CaptureAntibodyColumnWashBuffer,
					CaptureAntibodyConjugationStorageCondition,
					CaptureAntibodyDilution,
					CaptureAntibodyTargetConcentration,
					CaptureAntibodyDiluent
				}
			],
			{captureAntibodyStates}
		]
	];

	customDetectionAntibodyOptionValues=Transpose[
		Join[
			Lookup[
				roundedCapillaryELISAOptionsAssociation,
				{
					CustomDetectionAntibody,
					DetectionAntibodyResuspension,
					DetectionAntibodyResuspensionConcentration,
					DetectionAntibodyResuspensionDiluent,
					DetectionAntibodyStorageCondition,
					DetectionAntibodyConjugation,
					DetectionAntibodyVolume,
					BiotinReagent,
					BiotinReagentVolume,
					DetectionAntibodyConjugationBuffer,
					DetectionAntibodyConjugationBufferVolume,
					DetectionAntibodyConjugationContainer,
					DetectionAntibodyConjugationTime,
					DetectionAntibodyConjugationTemperature,
					DetectionAntibodyPurificationColumn,
					DetectionAntibodyColumnWashBuffer,
					DetectionAntibodyConjugationStorageCondition,
					DetectionAntibodyDilution,
					DetectionAntibodyTargetConcentration,
					DetectionAntibodyDiluent
				}
			],
			{detectionAntibodyStates}
		]
	];

	standardCaptureAntibodyOptionValues=If[MatchQ[suppliedStandard,Automatic|Null|{}],
		{},
		Transpose[
			Join[
				Lookup[
					roundedCapillaryELISAOptionsAssociation,
					{
						StandardCaptureAntibody,
						StandardCaptureAntibodyResuspension,
						StandardCaptureAntibodyResuspensionConcentration,
						StandardCaptureAntibodyResuspensionDiluent,
						StandardCaptureAntibodyStorageCondition,
						StandardCaptureAntibodyConjugation,
						StandardCaptureAntibodyVolume,
						StandardDigoxigeninReagent,
						StandardDigoxigeninReagentVolume,
						StandardCaptureAntibodyConjugationBuffer,
						StandardCaptureAntibodyConjugationBufferVolume,
						StandardCaptureAntibodyConjugationContainer,
						StandardCaptureAntibodyConjugationTime,
						StandardCaptureAntibodyConjugationTemperature,
						StandardCaptureAntibodyPurificationColumn,
						StandardCaptureAntibodyColumnWashBuffer,
						StandardCaptureAntibodyConjugationStorageCondition,
						StandardCaptureAntibodyDilution,
						StandardCaptureAntibodyTargetConcentration,
						StandardCaptureAntibodyDiluent
					}
				],
				{standardCaptureAntibodyStates}
			]
		]
	];

	standardDetectionAntibodyOptionValues=If[MatchQ[suppliedStandard,Automatic|Null|{}],
		{},
		Transpose[
			Join[
				Lookup[
					roundedCapillaryELISAOptionsAssociation,
					{
						StandardDetectionAntibody,
						StandardDetectionAntibodyResuspension,
						StandardDetectionAntibodyResuspensionConcentration,
						StandardDetectionAntibodyResuspensionDiluent,
						StandardDetectionAntibodyStorageCondition,
						StandardDetectionAntibodyConjugation,
						StandardDetectionAntibodyVolume,
						StandardBiotinReagent,
						StandardBiotinReagentVolume,
						StandardDetectionAntibodyConjugationBuffer,
						StandardDetectionAntibodyConjugationBufferVolume,
						StandardDetectionAntibodyConjugationContainer,
						StandardDetectionAntibodyConjugationTime,
						StandardDetectionAntibodyConjugationTemperature,
						StandardDetectionAntibodyPurificationColumn,
						StandardDetectionAntibodyColumnWashBuffer,
						StandardDetectionAntibodyConjugationStorageCondition,
						StandardDetectionAntibodyDilution,
						StandardDetectionAntibodyTargetConcentration,
						StandardDetectionAntibodyDiluent
					}
				],
				{standardDetectionAntibodyStates}
			]
		]
	];

	(* Get all option values together *)
	allCaptureAntibodyOptionValues=Join[customCaptureAntibodyOptionValues,standardCaptureAntibodyOptionValues];

	allDetectionAntibodyOptionValues=Join[customDetectionAntibodyOptionValues,standardDetectionAntibodyOptionValues];

	(* Keep the cases only when the antibody is an Object[Sample] and the state is Solid. We should have the same states for the same sample. *)

	objectSampleCaptureAntibodyOptionValues=Cases[allCaptureAntibodyOptionValues,{ObjectP[Object[Sample]],___,Solid}];
	objectSampleDetectionAntibodyOptionValues=Cases[allDetectionAntibodyOptionValues,{ObjectP[Object[Sample]],___,Solid}];

	(* A special test - the same solid state sample Object[Sample] should not be used as capture antibody and detection antibody *)
	(* This covers two cases - (1) If no conjugation is needed, then it does not make sense to use the same object for both capture and detection antibodies. (2) If conjugation is needed, we require that the same options must be used for solid state antibody. Because conjugations are different, it is basically not possible. *)
	objectSampleCaptureAntibodies=objectSampleCaptureAntibodyOptionValues[[All,1]];
	objectSampleDetectionAntibodies=objectSampleDetectionAntibodyOptionValues[[All,1]];

	conflictAntibodyObjectSampleOptions=If[!MatchQ[Intersection[objectSampleCaptureAntibodies,objectSampleDetectionAntibodies],{}],
		Message[Error::ConflictCapillaryELISAAntibodyObjectSample,ObjectToString[Intersection[objectSampleCaptureAntibodies,objectSampleDetectionAntibodies],Cache->simulatedCache]];{CustomCaptureAntibody,CustomDetectionAntibody,StandardCaptureAntibody,StandardDetectionAntibody},
		{}
	];

	conflictAntibodyObjectSampleTests=If[gatherTests,
		Test["When a customizable cartridge is used in the protocol, the same solid state Object[Sample] are not used as both capture antibody and detection antibody:",MatchQ[conflictOptionAntibodyObjectSamples,{}],True],
		{}
	];

	(* Combine the different antibody option values together for easy lookup in MapThread *)
	objectSampleAntibodyOptionValues=Join[objectSampleCaptureAntibodyOptionValues,objectSampleDetectionAntibodyOptionValues];

	(* Gather the cases by the antibody sample and keep only the cases that are longer than 1 - used for multiple cases*)
	gatheredObjectSampleAntibodyOptionValues=Select[GatherBy[objectSampleAntibodyOptionValues,First],Length[#]>1&];

	(* Transpose the options to get the same option into the same list *)
	transposedGatheredObjectSampleAntibodyOptionValues=Map[
		Transpose[#]&,
		gatheredObjectSampleAntibodyOptionValues
	];

	(* Get the options values without duplicates *)
	noDuplicateObjectSampleAntibodyValues=Map[
		DeleteDuplicates[DeleteCases[#,Automatic]]&,
		transposedGatheredObjectSampleAntibodyOptionValues,
		{2}
	];

	(* Check whether the option has more than one value *)
	moreThanOneValueObjectSampleAntibodyQ=Map[
		Length[#]>1&,
		noDuplicateObjectSampleAntibodyValues,
		{2}
	];

	(* Check the option values and if any of the option is conflicting, throw an error message *)
	conflictObjectSampleQ=Map[
		Or@@#&,
		moreThanOneValueObjectSampleAntibodyQ
	];

	conflictOptionAntibodyObjectSamples=PickList[Flatten[noDuplicateObjectSampleAntibodyValues[[All,1]]],conflictObjectSampleQ];

	(* Throw an error message when we get an invalid antibody sample *)
	conflictOptionValueAntibodyOptions=If[!MatchQ[conflictOptionAntibodyObjectSamples,{}],
		Message[Error::ConflictCapillaryELISAAntibodyOptions,ObjectToString[conflictOptionAntibodyObjectSamples,Cache->simulatedCache]];{CustomCaptureAntibody,CustomDetectionAntibody,StandardCaptureAntibody,StandardDetectionAntibody},
		{}
	];

	(* If we are gathering tests, generate tests for providing conflicting antibody related options *)
	conflictOptionValueAntibodyTests=If[gatherTests,
		Test["When the same Object[Sample] are used as antibody for different samples and resuspension is required, same antibody preparation option values should be used. Please correct the conflicting options to continue:",MatchQ[conflictOptionAntibodyObjectSamples,{}],True],
		{}
	];

	(* Also get a list of the supplied options to direct the option resolving *)
	objectSampleOptionValuesCollapsed=Map[
		FirstOrDefault[#,Automatic]&,
		noDuplicateObjectSampleAntibodyValues,
		{2}
	];



	(* OPTION RESOLVER *)
    (* -- Cartridge option is already resolved earlier *)


    (* -- RESOLVE CARTRIDGE RELATED OPTIONS (NON-INDEX MATCHED OPTIONS) -- *)

    (* resolve Analytes for a pre-loaded capillary ELISA cartridge. For the cases of customizable cartridge, our Analytes should index match with input samples. The resolving part is done inside MapThread*)
    resolvedPreLoadedAnalytes=Which[

        (* keep user-defined value *)
        !MatchQ[suppliedPreLoadedAnalytes,Automatic],suppliedPreLoadedAnalytes,

        (* If resolvedCartridge is customizable, set the pre-loaded analytes to Null *)
        resolvedCustomizableCartridgeQ,Null,

        (* If resolvedCartridge is not Null, set to its AnalyteNames *)
        !MatchQ[resolvedCartridge,Null],Lookup[resolvedCartridgePacket,AnalyteNames],

        (* Set the members of rankedPreLoadedAnalytes to be Analytes. Call helper function with information about cartridge type, species and available analytes *)
        True, First@resolvePreLoadedCartridgeAnalytes[resolvedCartridgeType,resolvedSpecies,rankedPreLoadedAnalytes,Cache->simulatedCache]

    ];

	(* Get the molecules *)
	resolvedPreLoadeAnalyteMolecules=Which[

		(* keep user-defined value *)
		!MatchQ[suppliedPreLoadedAnalyteMolecules,Automatic],suppliedPreLoadedAnalyteMolecules,

		(* If resolvedCartridge is customizable, set the pre-loaded analytes to Null *)
		resolvedCustomizableCartridgeQ,Null,

		(* If resolvedCartridge is not Null, set to its AnalyteMolecules *)
		!MatchQ[resolvedCartridge,Null],Download[Lookup[resolvedCartridgePacket,AnalyteMolecules],Object,Cache->simulatedCache],

		(* Set the members of rankedPreLoadedAnalytes to be Analytes. Call helper function with information about cartridge type, species and available analytes *)
		True,Last@resolvePreLoadedCartridgeAnalytes[resolvedCartridgeType,resolvedSpecies,rankedPreLoadedAnalytes,Cache->simulatedCache]

	];

	(* We would need to turn resolvedPreLoadedAnalytes into AnalyteNames so that we can make sure we get one and only one manufacturing specification for each analyte. For the automatically resolved Analytes, we have already turned the option into AnalyteNames, this is only for the supplied cases *)
	(* Turn identity models into AnalyteNames. We have checked that at least one generation is compatible with the others. Select a good combination *)
	resolvedPreLoadedAnalyteNames=If[MatchQ[resolvedPreLoadedAnalytes,ListableP[ObjectP[Model[Molecule]]]],

		(* Turn AnalyteMolecules into AnalyteNames. All errors should have been thrown earlier so it is safe to use our helper function for this purpose. *)
		First@resolvePreLoadedCartridgeAnalytes[resolvedCartridgeType,resolvedSpecies,resolvedPreLoadedAnalytes,Cache->simulatedCache],

		(* Keep the AnalyteNames or Null or {} *)
		resolvedPreLoadedAnalytes

	];

    (* Throw error messages if we cannot resolve pre-loaded analytes *)
    missingPreLoadedAnalytesOption=If[!resolvedCustomizableCartridgeQ&&MatchQ[resolvedPreLoadedAnalytes,Null|{}],
        Message[Error::MustSpecifyPreLoadedCartridgeAnalytes];{Analytes},
        {}
    ];

    (* Generate Test for missing analytes options *)
    missingPreLoadedAnalytesTests=If[gatherTests,
        Module[{passingTest,failingTest},
            passingTest=If[MatchQ[missingPreLoadedAnalytesOption,{}],
                Test["The Analytes option should be specified with supported capillary ELISA cartridge analytes for a pre-loaded capillary ELISA cartridge:",True,True],
                Nothing
            ];
            failingTest=If[!MatchQ[missingPreLoadedAnalytesOption,{}],
                Test["The Analytes option should be specified with supported capillary ELISA cartridge analytes for a pre-loaded capillary ELISA cartridge:",True,False],
                Nothing
            ];
            {passingTest,failingTest}
        ],
        Nothing
    ];

    (* Throw warning messages if we don't have enough analytes in the cartridge *)
    emptyCartridgeChannelQ=Which[
		resolvedCustomizableCartridgeQ,False,
		(* If we get a cartridge, then no warning *)
		!MatchQ[resolvedCartridge,Null],False,
		MatchQ[resolvedPreLoadedAnalytes,Null|{}],False,
		TrueQ[Length[resolvedPreLoadedAnalytes]<cartridgeCapacity[resolvedCartridgeType][[1]]]&&!MatchQ[$ECLApplication,Engine],
        Message[Warning::EmptyCartridgeChannel,ToString[cartridgeCapacity[resolvedCartridgeType][[1]]],ToString[Length[resolvedPreLoadedAnalytes]]];True,
		True,False
    ];

    (* make tests for empty cartridge channel warning if we need to do so *)
    emptyCartridgeChannelTests=If[gatherTests,
        Test["Every channel in the pre-loaded capillary ELISA cartridge should provide assay for a distinct analyte:",emptyCartridgeChannelQ,False],
        Nothing
    ];

	(* Resolve Customizable Analytes for each sample. Keep the first value of user provided or our resolved analyte *)
	(* PLease note that this is not the analytes that we are going to return as we are not suppposed to change user-defined option values. *)
	resolvedCustomizableAnalytes=MapThread[
		If[MatchQ[#1,Automatic],
			#2,
			#1
		]&,
		{suppliedCustomizableAnalytes,customizableAnalytes}
	];

    (* INFORMATION ABOUT DIILUENT AND MINDILUTIONFACTOR *)
    (* We also want to gather information about diluent and minimum dilution factor before we enter the 2 map threads. This will help us decide the options *)
	(* All the analytes should share the same information. Get the first member of resolvedPreLoadedAnalyteNames and get information from there *)
	firstPreLoadedAnalyteName=If[MatchQ[resolvedPreLoadedAnalyteNames,{}|Null],
		Null,
		FirstOrDefault[resolvedPreLoadedAnalyteNames]
	];

	firstPreLoadedAnalyteManufacturingSpecification=FirstCase[
		simulatedCache,
		KeyValuePattern[{Type->Object[ManufacturingSpecification,CapillaryELISACartridge],AnalyteName->firstPreLoadedAnalyteName}],
		<||>
	];

	(* Get the best Diluent/MinDilutionFactor from our resolved Analytes *)
	bestDiluent=Which[

		(* If we don't have a pre-loaded cartridge or analytes, go with SD-13 *)
		resolvedCustomizableCartridgeQ,Model[Sample, "id:eGakldJEGX4o"], (* Model[Sample, "Simple Plex Sample Diluent 13"] *)
		MatchQ[firstPreLoadedAnalyteName,Null],Model[Sample, "id:eGakldJEGX4o"], (* Model[Sample, "Simple Plex Sample Diluent 13"] *)

		(* Otherwise we can use the diluent from analytes *)
		True,Download[Lookup[firstPreLoadedAnalyteManufacturingSpecification,RecommendedDiluent,Model[Sample, "id:eGakldJEGX4o"]],Object,Cache->simulatedCache,Date->Now] (* Model[Sample, "Simple Plex Sample Diluent 13"] *)

	];

	bestMinDilutionFactor=Which[
		(* If we don't have a pre-loaded cartridge or analytes, go with SD-13 *)
		resolvedCustomizableCartridgeQ,0.5,
		MatchQ[firstPreLoadedAnalyteName,Null],0.5,

		(* Otherwise we can use the diluent from analytes *)
		True,Lookup[firstPreLoadedAnalyteManufacturingSpecification,RecommendedMinDilutionFactor,0.5]

	];


	(* GET PREPARED FOR MAPTHREAD *)

    (* Get the default sample model of the resolved analytes *)
    resolvedAnalytePackets=If[resolvedCustomizableCartridgeQ,
		Experiment`Private`fetchPacketFromFastAssoc[#,simulatedFastAssoc]&/@resolvedCustomizableAnalytes,
		Experiment`Private`fetchPacketFromFastAssoc[#,simulatedFastAssoc]&/@resolvedPreLoadeAnalyteMolecules
	];
    resolvedAnalyteDefaultModels=If[!MatchQ[resolvedAnalytePackets,Null|{}],
      Map[
        If[!MatchQ[#,<||>|Null|{}],
          Module[{defaultSampleModel},
            defaultSampleModel = Lookup[#,DefaultSampleModel,Null];
            If[MatchQ[defaultSampleModel,Null],
              Null,
              Experiment`Private`fastAssocLookup[simulatedFastAssoc,defaultSampleModel,Object]
            ]
          ],
          Null
        ]&,
        resolvedAnalytePackets
      ],
      Null
    ];

	(* Get rid of the duplicates and Null members *)
	resolvedPreLoadedAnalyteDefaultModels=DeleteDuplicates[DeleteCases[ToList[resolvedAnalyteDefaultModels],Null]];

    (* Select the most common customizable analyte from all the input samples and get its default sample model *)
    commonCustomizableAnalyteDefaultModels=ReverseSortBy[Tally[DeleteCases[ToList[resolvedAnalyteDefaultModels],Null]],Last][[All,1]];

    (* Get the remaining allowed number of samples to help decide Standard. Use user-defined Dilution options or we default to get 5 diluted sample for each standard *)
    (* Because we only need this number when Standard is automatic and Dilution options should be index matched to Standard, we can expect to have only 1 standard dilution settings. We are taking the first element out of the options anyway for an estimation. *)
	suppliedFirstStandardDilutionCurve=Which[
		MatchQ[suppliedStandardDilutionCurve,{(Automatic|Null|{{VolumeP,VolumeP}...}|{{VolumeP,_Real}...}|{VolumeP,{VolumeP,VolumeP},_Integer}|{VolumeP,{_Real,_Real},_Integer})..}],
		First[suppliedStandardDilutionCurve],
		True,suppliedStandardDilutionCurve
	];

	suppliedFirstStandardSerialDilutionCurve=Which[
		MatchQ[suppliedStandardSerialDilutionCurve,{(Automatic|Null|{VolumeP,VolumeP,_Integer}|{VolumeP,{_Real,_Integer}}|{VolumeP,{_Real..}})..}],
		First[suppliedStandardSerialDilutionCurve],
		True,suppliedStandardSerialDilutionCurve
	];


	standardDilutionNumber=Which[
		(* Because they are index matched, Null list cases should show up together. *)
		MatchQ[suppliedStandardDilutionCurve,{}|Null]||MatchQ[suppliedStandardSerialDilutionCurve,{}|Null],5,
		True,resolveDilutedSampleNumber[suppliedFirstStandardDilutionCurve,suppliedFirstStandardSerialDilutionCurve,5]
	];
	allowedStandardNumber=Max[Quotient[cartridgeCapacity[resolvedCartridgeType][[1]]-totalNumberOfSamples,standardDilutionNumber],0];



    (* -- RESOLVE THE MASTER SWITCH OF STANDARD -- *)

    (* A helper function is designed here to help ensure the total number of samples does not go beyond the allowed number of the cartridge *)
    resolvedStandard=Which[

        (* keep user-defined value *)
        !MatchQ[suppliedStandard,Automatic],suppliedStandard,

        (* If cartridge is not customizable and all other Standard related options are either Null or Automatic, set resolvedStandard to Null *)
        !resolvedCustomizableCartridgeQ&&ContainsOnly[Flatten[Lookup[roundedCapillaryELISAOptionsAssociation,standardOptions]],{Automatic,Null}],Null,

        (* If cartridge is not customizable and some Standard related options are not Null or Automatic, set resolvedStandard to members of resolvedAnalyteDefaultModels, up to allowed number *)
        !resolvedCustomizableCartridgeQ,Take[resolvedPreLoadedAnalyteDefaultModels,Min[Length[resolvedPreLoadedAnalyteDefaultModels],allowedStandardNumber]],

        (* If cartridge is customizable, set resolvedStandard to members of commonCustomizableAnalyteDefaultModels, up to allowed number *)
        resolvedCustomizableCartridgeQ,Take[commonCustomizableAnalyteDefaultModels,Min[Length[commonCustomizableAnalyteDefaultModels],allowedStandardNumber]]

    ]/.{}->Null;

    (* Find the analyte of all the Standard sample. Get two lists - one with pre-loaded analytes and one with customizable analyte. As we mentioned earlier, it is technically allowed to have a Null member in Standard, we are not going to enter MapThread for those cases. *)
    resolvedPreLoadedStandardAnalytes=If[MatchQ[resolvedStandard,{}|Null],
		{},
		Map[
			If[MatchQ[#,Null],
				{},
				selectCapillaryELISAAnalyteFromSample[#,Cache->simulatedCache][[1]]
			]&,
			ToList[resolvedStandard]
		]
	];

	resolvedCustomizableStandardAnalytes=If[MatchQ[resolvedStandard,{}|Null],
		{},
		Map[
			If[MatchQ[#,Null],
				Null,
				FirstOrDefault[selectCapillaryELISAAnalyteFromSample[#,Cache->simulatedCache][[2]]]
			]&,
			ToList[resolvedStandard]
		]
	];


	(* Preparation of our Options for MapThread *)
	(* Convert our options into a MapThread friendly version. *)
	mapThreadFriendlyOptions=OptionsHandling`Private`mapThreadOptions[ExperimentCapillaryELISA,roundedCapillaryELISAOptionsAssociation];

	(* One special here is that the mapThreadFriendlyOptions is expanded (and transposed) only for the options that are index matched to the input samples, not to the index matching parent options - Standard in this case. They are kept We also need to prepare for our Standard resolver.*)
	(* It is very weird to set Standard to Automatic but set any of the standard options to something, even a list. However, as long as all the options are set to the same length, the previous tests cannot catch this error. We can use any option as the indicator. *)
	standardOptionLengthInvalidOptions=Which[
		MatchQ[resolvedStandard,Null]&&ContainsOnly[Flatten[Lookup[roundedCapillaryELISAOptionsAssociation,standardOptions]],{Automatic,Null}],{},
		(* We cannot find the standard sample to use but some options are populated *)
		MatchQ[resolvedStandard,Null],Message[Error::InvalidStandardOptionLength];{Standard},
		(* We can find some Standard sample and our options are 1 value or a list of 1 value - they can be expanded *)
		Length[suppliedStandardResuspension]<=1,{},
		Length[suppliedStandardResuspension]!=Length[ToList[resolvedStandard]],Message[Error::InvalidStandardOptionLength];{Standard},
		True,{}
	];

	(* Gather tests if we need to do so *)
	standardOptionLengthInvalidTests=If[gatherTests,
		Test["The specified Standard related options is longer than the automatically selected Standard. Please specify desired samples in Standard option to match the length of the Standard related options:",MatchQ[standardOptionLengthInvalidOptions,{}],True],
		{}
	];

	(* Generate MapThread friendly option for standard. It is very similar to OptionsHandling`Private`mapThreadOptions. However, we don't really care about other options in the map thread so we are taking out only the standard options *)
	extractedStandardOptions=KeyTake[roundedCapillaryELISAOptionsAssociation,standardOptions];

	(* In the case that the lengths of options don't match resolvedStandard, we will use the first value for resolver. *)
	extractedStandardOptionFirstValues=If[Length[suppliedStandardResuspension]==0,
		extractedStandardOptions,
		Association[
			Map[
				(Keys[#]->First[Values[#]])&,
				Normal[extractedStandardOptions]
			]
		]
	];

	(* Turn the options into a map thread friendly version *)
	mapThreadExpandedStandardOptions=Map[
		Function[
			{singleOption},
			Module[{optionSymbol,optionValues,optionSymbolList},
				(* Seperate out the option symbol from the option values. *)
				optionSymbol=singleOption[[1]];
				optionValues=ToList[singleOption[[2]]];

				(* Get a list of optionSymbol that is the same length as optionValue. *)
				optionSymbolList=ConstantArray[optionSymbol,Length[optionValues]];

				MapThread[
					(#1->#2)&,
					{optionSymbolList,optionValues}
				]
			]
		],
		Normal[extractedStandardOptions]
	];

	standardMapThreadFriendlyOptions=Which[
		MatchQ[resolvedStandard,Null|{}],{},

		(* If the standard options are given as single values, just create a constant array *)
		Length[suppliedStandardResuspension]==0,ConstantArray[extractedStandardOptions,Length[ToList[resolvedStandard]]],

		(* If the standard options are provided as single value lists, get a constant array for the value *)
		Length[suppliedStandardResuspension]==1,ConstantArray[extractedStandardOptionFirstValues,Length[ToList[resolvedStandard]]],

		(* Longer than 2 but the lengths match *)
		Length[ToList[resolvedStandard]]==Length[suppliedStandardResuspension],
		Transpose[mapThreadExpandedStandardOptions],

		(* Otherwise we use the first value *)
		True,
		ConstantArray[extractedStandardOptionFirstValues,Length[ToList[resolvedStandard]]]

	];


    (* -- RESOLVE ALL OPTIONS RELATED TO STANDARD -- *)
    {
        resolvedStandardResuspension,
        resolvedStandardResuspensionConcentration,
        resolvedStandardResuspensionDiluent,
		resolvedStandardStorageCondition,
        resolvedStandardDilutionCurve,
        resolvedStandardSerialDilutionCurve,
        resolvedStandardDiluent,
        resolvedStandardDilutionMixVolume,
        resolvedStandardDilutionNumberOfMixes,
        resolvedStandardDilutionMixRate,
        resolvedStandardCaptureAntibody,
        resolvedStandardCaptureAntibodyResuspension,
        resolvedStandardCaptureAntibodyResuspensionConcentration,
        resolvedStandardCaptureAntibodyResuspensionDiluent,
        resolvedStandardCaptureAntibodyStorageCondition,
        resolvedStandardCaptureAntibodyConjugation,
        resolvedStandardCaptureAntibodyVolume,
        resolvedStandardDigoxigeninReagent,
        resolvedStandardDigoxigeninReagentVolume,
        resolvedStandardCaptureAntibodyConjugationBuffer,
        resolvedStandardCaptureAntibodyConjugationBufferVolume,
        resolvedStandardCaptureAntibodyConjugationContainer,
        resolvedStandardCaptureAntibodyConjugationTime,
        resolvedStandardCaptureAntibodyConjugationTemperature,
        resolvedStandardCaptureAntibodyPurificationColumn,
        resolvedStandardCaptureAntibodyColumnWashBuffer,
        resolvedStandardCaptureAntibodyConjugationStorageCondition,
        resolvedStandardCaptureAntibodyDilution,
		resolvedStandardCaptureAntibodyTargetConcentration,
        resolvedStandardCaptureAntibodyDiluent,
        resolvedStandardDetectionAntibody,
        resolvedStandardDetectionAntibodyResuspension,
        resolvedStandardDetectionAntibodyResuspensionConcentration,
        resolvedStandardDetectionAntibodyResuspensionDiluent,
        resolvedStandardDetectionAntibodyStorageCondition,
        resolvedStandardDetectionAntibodyConjugation,
        resolvedStandardDetectionAntibodyVolume,
        resolvedStandardBiotinReagent,
        resolvedStandardBiotinReagentVolume,
        resolvedStandardDetectionAntibodyConjugationBuffer,
        resolvedStandardDetectionAntibodyConjugationBufferVolume,
        resolvedStandardDetectionAntibodyConjugationContainer,
        resolvedStandardDetectionAntibodyConjugationTime,
        resolvedStandardDetectionAntibodyConjugationTemperature,
        resolvedStandardDetectionAntibodyPurificationColumn,
        resolvedStandardDetectionAntibodyColumnWashBuffer,
        resolvedStandardDetectionAntibodyConjugationStorageCondition,
        resolvedStandardDetectionAntibodyDilution,
		resolvedStandardDetectionAntibodyTargetConcentration,
        resolvedStandardDetectionAntibodyDiluent,
		resolvedStandardLoadingVolume,
		resolvedStandardCaptureAntibodyLoadingVolume,
        resolvedStandardDetectionAntibodyLoadingVolume,
		resolvedStandardComposition,
		nonOptimalStandardResuspensionWarnings,
		incompleteResolvedStandardCompositionErrors,
		nonOptimalStandardDiluentWarnings,
        conflictStandardAntibodyEpitopeWarnings,
		standardCaptureAntibodyAssayTypeWarnings,
		standardDetectionAntibodyAssayTypeWarnings,
        missingStandardCaptureAntibodyErrors,
        missingStandardDetectionAntibodyErrors,
        missingStandardDigoxigeninReagentVolumeErrors,
        missingStandardBiotinReagentVolumeErrors,
		notEnoughStandardDigoxigeninReagentVolumeWarnings,
		notEnoughStandardBiotinReagentVolumeWarnings,
		exceedStandardCaptureAntibodyConjugationContainerErrors,
		exceedStandardDetectionAntibodyConjugationContainerErrors,
		exceedStandardCaptureAntibodyPurificationColumnErrors,
		exceedStandardDetectionAntibodyPurificationColumnErrors,
		invalidStandardCaptureAntibodyDilutionErrors,
		invalidStandardDetectionAntibodyDilutionErrors,
		nonOptimalStandardCaptureAntibodyDilutionWarnings,
		nonOptimalStandardDetectionAntibodyDilutionWarnings,
		standardUpperQuantitationLimits,
		standardCaptureAntibodyConjuationReactionVolumes,
		standardCaptureAntibodyConjugationContainerMaxVolumes,
		standardCaptureAntibodyPurificationColumnMaxVolumes,
		preferredStandardCaptureAntibodyPurificationColumns,
		standardDetectionAntibodyConjuationReactionVolumes,
		standardDetectionAntibodyConjugationContainerMaxVolumes,
		standardDetectionAntibodyPurificationColumnMaxVolumes,
		preferredStandardDetectionAntibodyPurificationColumns
    }=If[MatchQ[resolvedStandard,Null|{}],

        (* No need to do MapThread when Standard is Null or empty list. Just keep user-defined options or set to Null. Error message has been thrown in Option Conflict Check stage *)
        Join[
			userDefinedOrDefault[Lookup[roundedCapillaryELISAOptionsAssociation,standardOptions],Null],
			ConstantArray[{},29]
		],

        (* When Standard is not Null, MapThread over each of our standard samples. *)
        Transpose[
            MapThread[
                Function[
                    {myStandardSample,standardPreLoadedAnalyte,standardCustomizableAnalyte,myMapThreadOptions},
                    Module[
                        {
                            (* All option value variables *)
							standardResuspension,standardResuspensionConcentration,standardResuspensionDiluent,standardStorageCondition,standardDilutionCurve,standardSerialDilutionCurve,standardDiluent,standardDilutionMixVolume,standardDilutionNumberOfMixes,standardDilutionMixRate,
							standardCaptureAntibody,standardCaptureAntibodyResuspension,standardCaptureAntibodyResuspensionConcentration,standardCaptureAntibodyResuspensionDiluent,standardCaptureAntibodyStorageCondition,standardCaptureAntibodyConjugation,standardCaptureAntibodyVolume,standardDigoxigeninReagent,standardDigoxigeninReagentVolume,standardCaptureAntibodyConjugationBuffer,standardCaptureAntibodyConjugationBufferVolume,totalStandardCaptureAntibodyConjugationVolume,preferredStandardCaptureAntibodyConjugationContainer,standardCaptureAntibodyConjugationContainer,standardCaptureAntibodyConjugationTime,standardCaptureAntibodyConjugationTemperature,standardCaptureAntibodyPurificationColumn,standardCaptureAntibodyColumnWashBuffer,standardCaptureAntibodyConjugationStorageCondition,standardCaptureAntibodyDilution,standardCaptureAntibodyTargetConcentration,standardCaptureAntibodyDiluent,
							standardDetectionAntibody,standardDetectionAntibodyResuspension,standardDetectionAntibodyResuspensionConcentration,standardDetectionAntibodyResuspensionDiluent,standardDetectionAntibodyStorageCondition,standardDetectionAntibodyConjugation,standardDetectionAntibodyVolume,standardBiotinReagent,standardBiotinReagentVolume,standardDetectionAntibodyConjugationBuffer,standardDetectionAntibodyConjugationBufferVolume,totalStandardDetectionAntibodyConjugationVolume,preferredStandardDetectionAntibodyConjugationContainer,standardDetectionAntibodyConjugationContainer,standardDetectionAntibodyConjugationTime,standardDetectionAntibodyConjugationTemperature,preferredStandardDetectionAntibodyPurificationColumn,standardDetectionAntibodyPurificationColumn,standardDetectionAntibodyColumnWashBuffer,standardDetectionAntibodyConjugationStorageCondition,standardDetectionAntibodyDilution,standardDetectionAntibodyTargetConcentration,standardDetectionAntibodyDiluent,standardLoadingVolume,standardCaptureAntibodyLoadingVolume,standardDetectionAntibodyLoadingVolume,standardComposition,

                            (* All error tracking variables *)
							nonOptimalStandardResuspensionWarning,incompleteResolvedStandardCompositionError,nonOptimalStandardDiluentWarning,conflictStandardAntibodyEpitopeWarning,standardCaptureAntibodyAssayTypeWarning,standardDetectionAntibodyAssayTypeWarning,missingStandardCaptureAntibodyError,missingStandardDetectionAntibodyError,missingStandardDigoxigeninReagentVolumeError,missingStandardBiotinReagentVolumeError,notEnoughStandardDigoxigeninReagentVolumeWarning,notEnoughStandardBiotinReagentVolumeWarning,exceedStandardCaptureAntibodyConjugationContainerError,exceedStandardDetectionAntibodyConjugationContainerError,exceedStandardCaptureAntibodyPurificationColumnError,exceedStandardDetectionAntibodyPurificationColumnError,invalidStandardCaptureAntibodyDilutionError,invalidStandardDetectionAntibodyDilutionError,nonOptimalStandardCaptureAntibodyDilutionWarning,nonOptimalStandardDetectionAntibodyDilutionWarning,

                            (* All other variables *)
							myStandardPacket,myStandardState,presentedStandardPreLoadedAnalyte,presentedStandardPreLoadedAnalyteName,presentedStandardPreLoadedAnalyteSpec,standardUpperQuantitationLimit,resolvedStandardDiluentPacket,resolvedStandardDiluentModel,standardCaptureAntibodyNewRules,standardDetectionAntibodyNewRules,processedMyMapThreadOptions,bestStandardDilutionMixVolume,
							captureAntibodyAverageMolecularWeight,captureAntibodyConjugatedQ,captureAntibodyIdentityModels,captureAntibodyIdentityModelPacket,captureAntibodySecondaryAntibidies,captureAntibodyMolecularWeights,standardDigoxigeninReagentComposition,standardDigoxigeninReagentConcentration,standardDigoxigeninReagentPacket,digoxigeninMoleculeMolecularWeight,captureAntibodyPacket,captureAntibodyState,standardCaptureAntibodyConcentration,standardCaptureAntibodyMassConcentration,preferredStandardCaptureAntibodyPurificationColumn,standardCaptureAntibodyConjugationContainerPacket,standardCaptureAntibodyConjugationContainerMaxVolume,standardCaptureAntibodyPurificationColumnPacket,standardCaptureAntibodyPurificationColumnModel,standardCaptureAntibodyPurificationColumnMaxVolume,standardCaptureAntibodyTargetMassConcentration,
							detectionAntibodyAverageMolecularWeight,detectionAntibodyConjugatedQ,detectionAntibodyIdentityModels,detectionAntibodyIdentityModelPacket,detectionAntibodyTargets,detectionAntibodyMolecularWeights,standardBiotinReagentComposition,standardBiotinReagentConcentration,standardBiotinReagentPacket,biotinMoleculeMolecularWeight,detectionAntibodyPacket,detectionAntibodyState,standardDetectionAntibodyConcentration,standardDetectionAntibodyMassConcentration,standardDetectionAntibodyConjugationContainerPacket,standardDetectionAntibodyConjugationContainerMaxVolume,standardDetectionAntibodyPurificationColumnPacket,standardDetectionAntibodyPurificationColumnModel,standardDetectionAntibodyPurificationColumnMaxVolume,standardDetectionAntibodyTargetMassConcentration
                        },

                        (* Setup our error tracking variables *)
                        {nonOptimalStandardResuspensionWarning,incompleteResolvedStandardCompositionError,nonOptimalStandardDiluentWarning,conflictStandardAntibodyEpitopeWarning,standardCaptureAntibodyAssayTypeWarning,standardDetectionAntibodyAssayTypeWarning,missingStandardCaptureAntibodyError,missingStandardDetectionAntibodyError,missingStandardDigoxigeninReagentVolumeError,missingStandardBiotinReagentVolumeError,notEnoughStandardDigoxigeninReagentVolumeWarning,notEnoughStandardBiotinReagentVolumeWarning,exceedStandardCaptureAntibodyConjugationContainerError,exceedStandardDetectionAntibodyConjugationContainerError,exceedStandardCaptureAntibodyPurificationColumnError,exceedStandardDetectionAntibodyPurificationColumnError,invalidStandardCaptureAntibodyDilutionError,invalidStandardDetectionAntibodyDilutionError,nonOptimalStandardCaptureAntibodyDilutionWarning,nonOptimalStandardDetectionAntibodyDilutionWarning}=ConstantArray[False,20];
                            
                        (* Get the packet of myStandardSample *)
                        myStandardPacket=Experiment`Private`fetchPacketFromFastAssoc[myStandardSample,simulatedFastAssoc];

                        (* Check the state of the sample - Solid or Liquid *)
                        myStandardState=If[MatchQ[myStandardPacket,Null],
							Null,
							Lookup[myStandardPacket,State,Null]
						];

                        (* Resolve standardResuspension based on the State of the Standard sample *)
                        standardResuspension=Which[
                            !MatchQ[Lookup[myMapThreadOptions,StandardResuspension],Automatic],Lookup[myMapThreadOptions,StandardResuspension],
							NullQ[myStandardSample],Null,
                            MatchQ[myStandardState,Solid],True,
                            True,False
                        ];

						(* If we get a pre-loaded Analyte for our standard sample, we use that to resolve resuspension concentration *)
						presentedStandardPreLoadedAnalyte=If[!resolvedCustomizableCartridgeQ&&!MatchQ[resolvedPreLoadeAnalyteMolecules,Null|{}],
							FirstOrDefault[Intersection[standardPreLoadedAnalyte,resolvedPreLoadeAnalyteMolecules]],
							Null
						];

						(* Get the corresponding Analyte Name *)
						presentedStandardPreLoadedAnalyteName=If[!MatchQ[presentedStandardPreLoadedAnalyte,Null],
							FirstOrDefault[PickList[resolvedPreLoadedAnalyteNames,resolvedPreLoadeAnalyteMolecules,presentedStandardPreLoadedAnalyte]],
							Null
						];

						(* Get the analyte manufacturing specification *)
						presentedStandardPreLoadedAnalyteSpec=If[!MatchQ[presentedStandardPreLoadedAnalyte,Null],
							FirstCase[
								simulatedCache,
								KeyValuePattern[{Type->Object[ManufacturingSpecification,CapillaryELISACartridge],AnalyteName->presentedStandardPreLoadedAnalyteName}],
								{}
							],
							{}
						];

                        (* Resolve standardResuspensionConcentration based on standardAnalyteSpec *)
                        standardResuspensionConcentration=Which[

                            (* Keep user-defined value *)
                            !MatchQ[Lookup[myMapThreadOptions,StandardResuspensionConcentration],Automatic],Lookup[myMapThreadOptions,StandardResuspensionConcentration],

							(* If we get a Null standard, set to Null *)
							MatchQ[myStandardPacket,Null],Null,

                            (* If Standard is not in solid state, just set to Null *)
                            !MatchQ[standardResuspension,True],Null,

							(* If it is a customizable cartridge, set to a certain value *)
							resolvedCustomizableCartridgeQ,100 Microgram/Milliliter,

                            (* If we cannot find presentedStandardPreLoadedAnalyteSpec, set to a certain value *)
                            MatchQ[presentedStandardPreLoadedAnalyteSpec,{}],100 Microgram/Milliliter,

                            (* If we have a standardAnalyteSpec, get its UpperQuantitationLimit *)
							MatchQ[Lookup[presentedStandardPreLoadedAnalyteSpec,UpperQuantitationLimit,Null],Null],100 Microgram/Milliliter,

                            True,Lookup[presentedStandardPreLoadedAnalyteSpec,UpperQuantitationLimit]*10
                        ];

						(* Set our nonOptimalStandardResuspensionWarning to True if we get a concentration that is too high or too low - outside 1-25 ULOD range *)
						nonOptimalStandardResuspensionWarning=If[MatchQ[Lookup[presentedStandardPreLoadedAnalyteSpec,UpperQuantitationLimit,Null],Null]||resolvedCustomizableCartridgeQ||!MatchQ[standardResuspension,True],
							False,
							TrueQ[standardResuspensionConcentration>25*Lookup[presentedStandardPreLoadedAnalyteSpec,UpperQuantitationLimit]]||TrueQ[standardResuspensionConcentration<Lookup[presentedStandardPreLoadedAnalyteSpec,UpperQuantitationLimit]]
						];

						(* Also return the upper quantitation limit *)
						standardUpperQuantitationLimit=If[MatchQ[Lookup[presentedStandardPreLoadedAnalyteSpec,UpperQuantitationLimit,Null],Null],
							Null,
							Lookup[presentedStandardPreLoadedAnalyteSpec,UpperQuantitationLimit]
						];

                        (* Resolve standardResuspensionDiluent. Keep the user-defined value or the best diluent based on the cartridge *)
                        standardResuspensionDiluent=Which[
							!MatchQ[Lookup[myMapThreadOptions,StandardResuspensionDiluent],Automatic],
							Lookup[myMapThreadOptions,StandardResuspensionDiluent],
							NullQ[myStandardSample],
							Null,
							!MatchQ[standardResuspension,True],
							Null,
							True,
							bestDiluent
                        ];

                        (* Set standardStorageCondition to Freezer or keep user-defined value when standardResuspension is True *)
						standardStorageCondition=If[MatchQ[standardResuspension,True]&&!MatchQ[myStandardPacket,Null],

                            userDefinedOrDefault[{Lookup[myMapThreadOptions,StandardStorageCondition]},Freezer][[1]],

                            (* For False/Null standardResuspension, set storageCondition to Null *)
                            userDefinedOrDefault[{Lookup[myMapThreadOptions,StandardStorageCondition]},Null][[1]]
                        ];

                        (* Resolve knownConcentration either using resuspension concentration or using information from Composition Field *)
						standardComposition=Which[

                            (* Keep user-defined value *)
                            !MatchQ[Lookup[myMapThreadOptions,StandardComposition],Automatic],Lookup[myMapThreadOptions,StandardComposition],

							(* If we get a Null standard, set to Null *)
							MatchQ[myStandardPacket,Null],Null,

                            (* If standardResuspension is True and the cartridge is a customizable cartridge, set to the resuspension concentration if we get an analyte *)
                            MatchQ[standardResuspension,True]&&resolvedCustomizableCartridgeQ&&!MatchQ[standardCustomizableAnalyte,Null],{{standardResuspensionConcentration,standardCustomizableAnalyte}},

                            (* If standardResuspension is True and we find a presentedStandardPreLoadedAnalyte, set to its combination *)
                            MatchQ[standardResuspension,True]&&!MatchQ[presentedStandardPreLoadedAnalyte,Null],{{standardResuspensionConcentration,presentedStandardPreLoadedAnalyte}},

                            (* Otherwise we throw an error if it is resuspended but we cannot figure out which analyte it is for *)
                            MatchQ[standardResuspension,True],Null,

                            (* If we have got a liquid state sample and we don't have a customizable cartridge, we can try to find the concentration from its composition field. This can be an empty list *)
                            !resolvedCustomizableCartridgeQ&&!MatchQ[resolvedPreLoadeAnalyteMolecules,Null|{}],
							Map[
								Function[
									{comp},
									{First[comp],Download[Last[comp],Object,Cache->simulatedCache]}
								],
								Select[Lookup[myStandardPacket,Composition,{}],MatchQ[#,{Except[Null],ObjectP[resolvedPreLoadedAnalytes]}]&]
							],

                            (* If we have got a liquid state sample and we got a customizable cartridge, we can try to find the concentration from its composition field *)
                            resolvedCustomizableCartridgeQ&&!MatchQ[standardCustomizableAnalyte,Null],
							Map[
								Function[
									{comp},
									{First[comp],Download[Last[comp],Object,Cache->simulatedCache]}
								],
								Select[Lookup[myStandardPacket,Composition,{}],MatchQ[#,{Except[Null],ObjectP[standardCustomizableAnalyte]}]&]
							],

                            (* Return Null if we cannot find anything *)
                            True,Null

                        ];

                        (* Set error tracking boolean to True if we cannot figure out StandardComposition *)
						incompleteResolvedStandardCompositionError=If[MatchQ[standardComposition,{}|Null]&&!MatchQ[myStandardSample,Null],
                            True,
                            False
                        ];

                        (* Resolve standardDilutionCurve and standardSerialDilutionCurve *)
                        {standardDilutionCurve,standardSerialDilutionCurve}=Switch[Join[{myStandardSample},Lookup[myMapThreadOptions,{StandardDilutionCurve,StandardSerialDilutionCurve}]],

                            (* If neither is not automatic, keep user-defined values *)
                            {_,Except[Automatic],Except[Automatic]},Lookup[myMapThreadOptions,{StandardDilutionCurve,StandardSerialDilutionCurve}],

                            (* If one is automatic and the other one is not, set the other one to Null *)
                            {_,Except[Automatic|Null],Automatic},{Lookup[myMapThreadOptions,StandardDilutionCurve],Null},
                            {_,Automatic,Except[Automatic|Null]},{Null,Lookup[myMapThreadOptions,StandardSerialDilutionCurve]},

							(* If serial dilution is set to Null, we can use dilution curve for the same thing. *)
							{Except[Null],Automatic,Null},{{{60Microliter,0.1},{60Microliter,0.01},{60Microliter,0.001},{60Microliter,0.0001},{60Microliter,0.00001}},Null},
							(* If we get a Null Standard, set to Null *)
							{Null,Automatic,Null},{Null,Null},

                            (* If both are automatic or dilution curve is Null, go with serial dilution curve *)
                            {Except[Null],Automatic|Null,Automatic},{Null,{60Microliter,{0.1,5}}},
							(* If both are automatic or dilution curve is Null for a Null Standard, set to Null *)
							{Null,Automatic|Null,Automatic},{Null,Null}

                        ];

                        (* Resolve standardDiluent *)
                        standardDiluent=Which[

                            (* Keep user-defined value *)
                            !MatchQ[Lookup[myMapThreadOptions,StandardDiluent],Automatic],Lookup[myMapThreadOptions,StandardDiluent],

							(* If we get a Null standard, set to Null *)
							MatchQ[myStandardPacket,Null],Null,

                            (* If standardResuspensionDiluent is not Null, just set to it *)
                            !MatchQ[standardResuspensionDiluent,Null],standardResuspensionDiluent,

                            (* Otherwise just go with the best diluent of the experiment *)
							True,bestDiluent

                        ];

						(* Set the error tracking boolean to True if we get a non-optimal diluent *)
						resolvedStandardDiluentPacket=Experiment`Private`fetchPacketFromFastAssoc[standardDiluent,simulatedFastAssoc];
						resolvedStandardDiluentModel=Which[
							MatchQ[standardDiluent,ObjectP[Model[Sample]]],standardDiluent,
							MatchQ[standardDiluent,Null],Null,
							MatchQ[standardDiluent,ObjectP[Object[Sample]]],Lookup[resolvedStandardDiluentPacket,Model,Null]
						];

						nonOptimalStandardDiluentWarning=!MatchQ[resolvedStandardDiluentModel,bestDiluent]&&!NullQ[myStandardSample];

						(* Get the minimum diluted sample volume to decide the DilutionMixVolume. They are no longer Automatic so we can default to 0 Microliter. We also limit it to 970 Microliter to make sure the volume does not exceed the largest tip volume on the liquid handler. *)
						bestStandardDilutionMixVolume=SafeRound[Min[0.5*resolveMinDilutedSamplePreparationVolume[standardDilutionCurve,standardSerialDilutionCurve,0Microliter],970Microliter],10^-1Microliter];

                        (* Resolve other Standard related options *)
                        {standardDilutionMixVolume,standardDilutionNumberOfMixes,standardDilutionMixRate,standardLoadingVolume}=If[MatchQ[myStandardSample,Null],
							userDefinedOrDefault[Lookup[myMapThreadOptions,{StandardDilutionMixVolume,StandardDilutionNumberOfMixes,StandardDilutionMixRate,StandardLoadingVolume}],Null],
							userDefinedOrDefault[Lookup[myMapThreadOptions,{StandardDilutionMixVolume,StandardDilutionNumberOfMixes,StandardDilutionMixRate,StandardLoadingVolume}],{bestStandardDilutionMixVolume,5,100Microliter/Second,50Microliter}]
						];

                        (* MasterSwitch inside MasterSwitch - StandardCaptureAntibody options and StandardDetectionAntibody options *)
                        (* Here we need to enter our MasterSwitch, if the cartridge is not customizable, we can easily set all antibody related options to Null. Otherwise we need to go into them. I still do them one by one to avoid opening another huge Module. *)
                        {standardCaptureAntibody,standardDetectionAntibody,standardCaptureAntibodyAssayTypeWarning,standardDetectionAntibodyAssayTypeWarning,conflictStandardAntibodyEpitopeWarning}=Which[

                            (* Directly set antibody information to Null and epitope conflicting error and all assay type warnings to False when the cartridge is not customizable or we cannot get the Analyte resolved *)
                            !resolvedCustomizableCartridgeQ||NullQ[standardCustomizableAnalyte]||NullQ[myStandardSample],
							Join[
								userDefinedOrDefault[Lookup[myMapThreadOptions,{StandardCaptureAntibody,StandardDetectionAntibody}],Null],
								{False,False,MatchQ[Lookup[myMapThreadOptions,StandardCaptureAntibody],ObjectP[Lookup[myMapThreadOptions,StandardDetectionAntibody]]]&&!NullQ[Lookup[myMapThreadOptions,StandardCaptureAntibody]]}
							],

                            (* Otherwise we call our big helper function to resolve the antibody pair. It also returns epitope conflicting information. We will check whether we are able to resolve both capture antibody and detection antibody in the following step. *)
                            True,findAntibodyPairs[standardCustomizableAnalyte,Lookup[myMapThreadOptions,StandardCaptureAntibody],Lookup[myMapThreadOptions,StandardDetectionAntibody]]
                        ];

                        (* If we cannot resolve any of the antibody, we are going to return errors *)
                        {missingStandardCaptureAntibodyError,missingStandardDetectionAntibodyError}=If[resolvedCustomizableCartridgeQ&&!MatchQ[myStandardSample,Null],
                            {MatchQ[standardCaptureAntibody,Null],MatchQ[standardDetectionAntibody,Null]},
                            {False,False}
                        ];

						
						(* For a single antibody Object[Sample], we want to avoid resolving the options to different values and lead to conflicts. We can check whether our resolved antibodies are members of objectSampleOptionValuesCollapsed. Then we can create a new MapThreadOption list. *)
						standardCaptureAntibodyNewRules=If[MemberQ[objectSampleOptionValuesCollapsed[[All,1]],standardCaptureAntibody],
							Association[
								MapThread[
									(#1->#2)&,
									{{StandardCaptureAntibodyResuspension,StandardCaptureAntibodyResuspensionConcentration,StandardCaptureAntibodyResuspensionDiluent,StandardCaptureAntibodyStorageCondition,StandardCaptureAntibodyConjugation,StandardCaptureAntibodyVolume,StandardDigoxigeninReagent,StandardDigoxigeninReagentVolume,StandardCaptureAntibodyConjugationBuffer,StandardCaptureAntibodyConjugationBufferVolume,StandardCaptureAntibodyConjugationContainer,StandardCaptureAntibodyConjugationTime,StandardCaptureAntibodyConjugationTemperature,StandardCaptureAntibodyPurificationColumn,StandardCaptureAntibodyColumnWashBuffer,StandardCaptureAntibodyConjugationStorageCondition,StandardCaptureAntibodyDilution,StandardCaptureAntibodyTargetConcentration,StandardCaptureAntibodyDiluent},Most[Rest[FirstCase[objectSampleOptionValuesCollapsed,{standardCaptureAntibody,___}]]]}
								]
							],
							<||>
						];

						standardDetectionAntibodyNewRules=If[MemberQ[objectSampleOptionValuesCollapsed[[All,1]],standardDetectionAntibody],
							Association[
								MapThread[
									(#1->#2)&,
									{{StandardDetectionAntibodyResuspension,StandardDetectionAntibodyResuspensionConcentration,StandardDetectionAntibodyResuspensionDiluent,StandardDetectionAntibodyStorageCondition,StandardDetectionAntibodyConjugation,StandardDetectionAntibodyVolume,StandardBiotinReagent,StandardBiotinReagentVolume,StandardDetectionAntibodyConjugationBuffer,StandardDetectionAntibodyConjugationBufferVolume,StandardDetectionAntibodyConjugationContainer,StandardDetectionAntibodyConjugationTime,StandardDetectionAntibodyConjugationTemperature,StandardDetectionAntibodyPurificationColumn,StandardDetectionAntibodyColumnWashBuffer,StandardDetectionAntibodyConjugationStorageCondition,StandardDetectionAntibodyDilution,StandardDetectionAntibodyTargetConcentration,StandardDetectionAntibodyDiluent},Most[Rest[FirstCase[objectSampleOptionValuesCollapsed,{standardDetectionAntibody,___}]]]}
								]
							],
							<||>
						];

						(* Get the new Association so that we will not have a conflict *)
						processedMyMapThreadOptions=Join[Association[myMapThreadOptions],standardCaptureAntibodyNewRules,standardDetectionAntibodyNewRules];


						(* StandardCaptureAntibody OPTIONS *)
                        (* Get the packet of standardCaptureAntibody *)
                        captureAntibodyPacket=If[!MatchQ[standardCaptureAntibody,Null],
                            Experiment`Private`fetchPacketFromFastAssoc[standardCaptureAntibody,simulatedFastAssoc],
                            {}
                        ];

                        (* Check the state of the capture antibody - Solid or Liquid *)
                        captureAntibodyState=Lookup[captureAntibodyPacket,State,Null];

                        (* Resolve standardCaptureAntibodyResuspension based on the State of the capture antibody sample *)
                        standardCaptureAntibodyResuspension=Which[
                            !MatchQ[Lookup[processedMyMapThreadOptions,StandardCaptureAntibodyResuspension],Automatic],Lookup[processedMyMapThreadOptions,StandardCaptureAntibodyResuspension],
                            !resolvedCustomizableCartridgeQ,Null,
                            missingStandardCaptureAntibodyError,Null,
                            MatchQ[captureAntibodyState,Solid],True,
                            True,False
                        ];

                        (* Depending on standardCaptureAntibodyResuspension, resolve other resuspension related options *)
                        {standardCaptureAntibodyResuspensionConcentration,standardCaptureAntibodyResuspensionDiluent,standardCaptureAntibodyStorageCondition}=If[MatchQ[standardCaptureAntibodyResuspension,True]&&resolvedCustomizableCartridgeQ,

                            (* If standardCaptureAntibodyResuspension is required, set to default values or keep user's values *)
                            userDefinedOrDefault[Lookup[processedMyMapThreadOptions,{StandardCaptureAntibodyResuspensionConcentration,StandardCaptureAntibodyResuspensionDiluent,StandardCaptureAntibodyStorageCondition}],{1Milligram/Milliliter,Model[Sample, StockSolution, "id:4pO6dMWvnA0X"],Freezer}], (* Model[Sample, StockSolution,"Filtered PBS, Sterile"] *)

                            (* If standardCaptureAntibodyResuspension is not required, set to Null values or keep user's values with error already thrown *)
                            userDefinedOrDefault[Lookup[processedMyMapThreadOptions,{StandardCaptureAntibodyResuspensionConcentration,StandardCaptureAntibodyResuspensionDiluent,StandardCaptureAntibodyStorageCondition}],Null]
                        ];

                        (* Find all identity models of the capture antibody *)
                        captureAntibodyIdentityModels=Select[Lookup[captureAntibodyPacket,Composition,{}],MatchQ[#,{_,ObjectP[Model[Molecule,Protein,Antibody]]}]&];

                        (* Get the concentration of the capture antibody. Make sure we get the correct unit *)
                        standardCaptureAntibodyConcentration=Which[
                            !MatchQ[standardCaptureAntibodyResuspensionConcentration,Null],standardCaptureAntibodyResuspensionConcentration,

                            (* Use the concentration of the first antibody identity model *)
                            MatchQ[captureAntibodyIdentityModels,{}],Null,

							MatchQ[captureAntibodyIdentityModels[[1]][[1]],GreaterEqualP[0Molar]|GreaterEqualP[0Microgram/Milliliter]],captureAntibodyIdentityModels[[1]][[1]],
                            True,Null
                        ];

						(* Check the packet of the capture antibody for modification *)
						captureAntibodyIdentityModelPacket=If[!MatchQ[captureAntibodyIdentityModels,{}],
							Experiment`Private`fetchPacketFromFastAssoc[captureAntibodyIdentityModels[[1]][[2]],simulatedFastAssoc],
							<||>
						];

                        (* Find all molecules of the identity models *)
						captureAntibodySecondaryAntibidies=Lookup[captureAntibodyIdentityModelPacket,SecondaryAntibodies,{}];
                        (* Find all molecular weights of all identity models *)
                        captureAntibodyMolecularWeights=DeleteCases[
                          Map[
                            Experiment`Private`fastAssocLookup[simulatedFastAssoc,#,{Object,MolecularWeight}]&,
                            captureAntibodyIdentityModels[[All,2]]
                          ],
                          Null
                        ];
                        (* Use the average molecular weight or 150000 Dalton for caculation *)
                        captureAntibodyAverageMolecularWeight=If[MatchQ[captureAntibodyMolecularWeights,{}],
                            150000Dalton,
                            Mean[captureAntibodyMolecularWeights]
                        ];

						(* Check whether one of the targets is anti-digoxigenin *)
                        captureAntibodyConjugatedQ=MemberQ[captureAntibodySecondaryAntibidies,ObjectP[Model[Molecule, Protein, Antibody, "id:E8zoYvN9m4aA"]]]; (* Model[Molecule, Protein, Antibody, "Anti-Digoxigenin Antibody"] *)

                        (* Resolve standardCaptureAntibodyConjugation based on the composition of the capture antibody sample. We also check whether any of the resuspension values are set to Null or populated to help resolving the conjugation boolean*)
                        standardCaptureAntibodyConjugation=Which[
                            !MatchQ[Lookup[processedMyMapThreadOptions,StandardCaptureAntibodyConjugation],Automatic],Lookup[processedMyMapThreadOptions,StandardCaptureAntibodyConjugation],
                            !resolvedCustomizableCartridgeQ,Null,
                            MatchQ[standardCaptureAntibody,Null],Null,
							(* Any of the conjugation options are set to not Null or Automatic - Set conjugation to True *)
							MemberQ[Lookup[processedMyMapThreadOptions,{StandardCaptureAntibodyVolume,StandardDigoxigeninReagent,StandardDigoxigeninReagentVolume,StandardCaptureAntibodyConjugationBuffer,StandardCaptureAntibodyConjugationBufferVolume,StandardCaptureAntibodyConjugationContainer,StandardCaptureAntibodyConjugationTime,StandardCaptureAntibodyConjugationTemperature,StandardCaptureAntibodyPurificationColumn,StandardCaptureAntibodyColumnWashBuffer,StandardCaptureAntibodyConjugationStorageCondition}],Except[Null|Automatic]],True,

							(* Any of the conjugation options are set to Null - Set conjugation to False *)
							MemberQ[Lookup[processedMyMapThreadOptions,{StandardCaptureAntibodyVolume,StandardDigoxigeninReagent,StandardDigoxigeninReagentVolume,StandardCaptureAntibodyConjugationBuffer,StandardCaptureAntibodyConjugationBufferVolume,StandardCaptureAntibodyConjugationContainer,StandardCaptureAntibodyConjugationTime,StandardCaptureAntibodyConjugationTemperature,StandardCaptureAntibodyPurificationColumn,StandardCaptureAntibodyColumnWashBuffer,StandardCaptureAntibodyConjugationStorageCondition}],Null],False,

							(* Otherwise just go with our resolved conjugation value *)
							True,!captureAntibodyConjugatedQ
                        ];

                        (* Resolve StandardCaptureAntibodyVolume and StandardDigoxigeninReagent based on whether conjugation is required *)
                        {standardCaptureAntibodyVolume,standardDigoxigeninReagent}=If[MatchQ[standardCaptureAntibodyConjugation,True]&&resolvedCustomizableCartridgeQ,
                            userDefinedOrDefault[Lookup[processedMyMapThreadOptions,{StandardCaptureAntibodyVolume,StandardDigoxigeninReagent}],{100Microliter,Model[Sample, StockSolution, "id:rea9jlRwZe9e"]}], (* Model[Sample,StockSolution,"Digoxigenin-NHS, 0.67 mg/mL in DMF"] *)
                            userDefinedOrDefault[Lookup[processedMyMapThreadOptions,{StandardCaptureAntibodyVolume,StandardDigoxigeninReagent}],Null]
                        ];

                        (* Get the packet of standardDigoxigeninReagent *)
                        standardDigoxigeninReagentPacket=Experiment`Private`fetchPacketFromFastAssoc[standardDigoxigeninReagent,simulatedFastAssoc];

                        (* Get the composition of standardDigoxigeninReagent with the one for Model[Molecule,"Digoxigenin NHS ester"]. We currently may not be able to search for another Digoxigenin modification molecule as its reaction mechanism may be completely different and the ratio must also be adjusted. *)
                        standardDigoxigeninReagentComposition=If[!MatchQ[standardDigoxigeninReagentPacket,Null],
                            Select[Lookup[standardDigoxigeninReagentPacket,Composition,{}],MatchQ[#,{_,ObjectP[Model[Molecule, "id:KBL5Dvwx7eq7"]]}]&], (* Model[Molecule, "Digoxigenin NHS ester"] *)
							{}
						];

                        (* Get the concentration of digoxigenin reagent from its composition *)
                        standardDigoxigeninReagentConcentration=If[!MatchQ[standardDigoxigeninReagentComposition,{}],
                            standardDigoxigeninReagentComposition[[1,1]],
							Null
						];

						digoxigeninMoleculeMolecularWeight=Quantity[658.8, "Grams"/"Moles"]; (* Model[Molecule,"Digoxigenin NHS ester"] *)

                        (* Resolve standardDigoxigeninReagentVolume and set boolean error if we cannot resolve it *)
                        {standardDigoxigeninReagentVolume,missingStandardDigoxigeninReagentVolumeError}=Which[
                            !MatchQ[Lookup[processedMyMapThreadOptions,StandardDigoxigeninReagentVolume],Automatic],{Lookup[processedMyMapThreadOptions,StandardDigoxigeninReagentVolume],False},
							MatchQ[myStandardSample,Null],{Null,False},
                            !resolvedCustomizableCartridgeQ,{Null,False},
                            missingStandardCaptureAntibodyError,{Null,False},
                            !standardCaptureAntibodyConjugation,{Null,False},

                            (* When the standardCaptureAntibodyConjugation is True but we cannot resolve standardCaptureAntibodyConcentration, we have to set standardDigoxigeninReagentVolume to Null*)
                            MatchQ[standardCaptureAntibodyConcentration,Null],{Null,True},

                            (* When we cannot find standardDigoxigeninReagentConcentration from its composition, we also have to set standardDigoxigeninReagentVolume to Null *)
                            MatchQ[standardDigoxigeninReagentConcentration,Null],{Null,True},

                            (* Otherwise we can set to 5:1 excess using the concentrations and standardCaptureAntibodyVolume by calling the helper function *)
                            True,{SafeRound[calculateDigoxigeninVolume[captureAntibodyAverageMolecularWeight,digoxigeninMoleculeMolecularWeight,standardCaptureAntibodyVolume,standardCaptureAntibodyConcentration,standardDigoxigeninReagentConcentration],10^-1Microliter],False}
                        ];

						(* We also want to check whether the volume of digoxigenin reagent is giving more conjugation reagent compared to antibodies. This check only happens when we have all the information required *)
						notEnoughStandardDigoxigeninReagentVolumeWarning=Which[
							!standardCaptureAntibodyConjugation,False,
							MatchQ[standardCaptureAntibodyVolume,Null],False,
							MatchQ[standardCaptureAntibodyConcentration,Null],False,
							MatchQ[standardDigoxigeninReagentVolume,Null],False,
							MatchQ[standardDigoxigeninReagentConcentration,Null],False,
							True,TrueQ[calculateDigoxigeninVolume[captureAntibodyAverageMolecularWeight,digoxigeninMoleculeMolecularWeight,standardCaptureAntibodyVolume,standardCaptureAntibodyConcentration,standardDigoxigeninReagentConcentration]/5>standardDigoxigeninReagentVolume]
						];

                        (* Resolve standardCaptureAntibodyConjugationBuffer *)
                        standardCaptureAntibodyConjugationBuffer=Which[
                            !MatchQ[Lookup[processedMyMapThreadOptions,StandardCaptureAntibodyConjugationBuffer],Automatic],Lookup[processedMyMapThreadOptions,StandardCaptureAntibodyConjugationBuffer],
							!resolvedCustomizableCartridgeQ,Null,
                            !MatchQ[standardCaptureAntibodyConjugation,True],Null,
                            MatchQ[standardCaptureAntibodyConjugation,True],Model[Sample, StockSolution, "id:1ZA60vL4PZbq"] (* Model[Sample, StockSolution, "Sodium bicarbonate working stock 75 mg/mL"] *)
                        ];


                        (* Resolve standardCaptureAntibodyConjugationBufferVolume *)
                        standardCaptureAntibodyConjugationBufferVolume=Which[
                            !MatchQ[Lookup[processedMyMapThreadOptions,StandardCaptureAntibodyConjugationBufferVolume],Automatic],Lookup[processedMyMapThreadOptions,StandardCaptureAntibodyConjugationBufferVolume],
							!resolvedCustomizableCartridgeQ,Null,
                            !MatchQ[standardCaptureAntibodyConjugation,True],Null,

                            (* If the user has set standardCaptureAntibodyVolume to Null, we cannot resolve the volume of buffer. This error has been thrown during conflict option check. *)
                            MatchQ[standardCaptureAntibodyVolume,Null],Null,

                            (* If we cannot resolve standardDigoxigeninReagentVolume or the user has set it to Null, we cannot resolve the volume of buffer. An error has been thrown earlier. *)
                            MatchQ[standardDigoxigeninReagentVolume,Null],Null,

                            (* Otherwise we can set the volume of buffer to 1/9 of total volume of two reagents *)
                            True,SafeRound[1/9*(standardCaptureAntibodyVolume+standardDigoxigeninReagentVolume),10^-1Microliter]
                        ];

						(* Get the total volume to resolve the conjugation container *)
						totalStandardCaptureAntibodyConjugationVolume=If[MemberQ[{standardCaptureAntibodyVolume,standardDigoxigeninReagentVolume,standardCaptureAntibodyConjugationBufferVolume},Null],
							(* Use 0 Microliter if we cannot resolve any of the volumes *)
							0Microliter,
							(standardCaptureAntibodyVolume+standardDigoxigeninReagentVolume+standardCaptureAntibodyConjugationBufferVolume)
						];

						preferredStandardCaptureAntibodyConjugationContainer=PreferredContainer[totalStandardCaptureAntibodyConjugationVolume];

                        (* Resolve other capture antibody conjugation options *)
                        {
                            standardCaptureAntibodyConjugationContainer,
                            standardCaptureAntibodyConjugationTime,
                            standardCaptureAntibodyConjugationTemperature,
                            standardCaptureAntibodyConjugationStorageCondition,
							standardCaptureAntibodyColumnWashBuffer
                        }=If[MatchQ[standardCaptureAntibodyConjugation,True]&&resolvedCustomizableCartridgeQ,

                            (* Set default values when conjugation is needed *)
                            userDefinedOrDefault[
								Lookup[
									processedMyMapThreadOptions,
									{
										StandardCaptureAntibodyConjugationContainer,
										StandardCaptureAntibodyConjugationTime,
										StandardCaptureAntibodyConjugationTemperature,
										StandardCaptureAntibodyConjugationStorageCondition,
										StandardCaptureAntibodyColumnWashBuffer
									}
								],
								{preferredStandardCaptureAntibodyConjugationContainer,1Hour,Ambient,Refrigerator,Model[Sample, StockSolution, "id:4pO6dMWvnA0X"]} (* Model[Sample, StockSolution, "Filtered PBS, Sterile"] *)
                            ],

                            (* Set to Null when conjugation is not needed *)
                            userDefinedOrDefault[
                                Lookup[
									processedMyMapThreadOptions,
                                    {
                                        StandardCaptureAntibodyConjugationContainer,
                                        StandardCaptureAntibodyConjugationTime,
                                        StandardCaptureAntibodyConjugationTemperature,
                                        StandardCaptureAntibodyConjugationStorageCondition,
										StandardCaptureAntibodyColumnWashBuffer
                                    }
                                ],
                                Null
                            ]
                        ];

                        (* Resolve standardCaptureAntibodyPurificationColumn and all purification related options *)
						(* Decide the preferred purification column using the provided volumes *)
						preferredStandardCaptureAntibodyPurificationColumn=Which[
							!resolvedCustomizableCartridgeQ,Null,
							!MatchQ[standardCaptureAntibodyConjugation,True],Null,

							(* If the user has set standardCaptureAntibodyVolume to Null, we cannot resolve the total volume of the conjugation reaction. This error has been thrown during conflict option check. *)
							MatchQ[standardCaptureAntibodyVolume,Null],Null,

							(* If we cannot resolve standardDigoxigeninReagentVolume or the user has set it to Null, we cannot resolve the total volume of the conjugation reaction. *)
							MatchQ[standardDigoxigeninReagentVolume,Null],Null,

							(* If we cannot resolve standardCaptureAntibodyConjugationBufferVolume or the user has set it to Null, we cannot resolve the total volume of the conjugation reaction. *)
							MatchQ[standardCaptureAntibodyConjugationBufferVolume,Null],Null,

							(* Otherwise we can get the total volume and decide the purification column to use *)
							True,
							First[
								FirstOrDefault[
									Select[
										sorted40KSpinColumnsWithMaxVolumes,
										Last[#]>=(totalStandardCaptureAntibodyConjugationVolume+100Microliter)&
									],
									(* Get a default if the volume is too large but it should not happen *)
									Last[sorted40KSpinColumnsWithMaxVolumes]
								]
							]
						];

						standardCaptureAntibodyPurificationColumn=If[!MatchQ[Lookup[processedMyMapThreadOptions,StandardCaptureAntibodyPurificationColumn],Automatic],
							Lookup[processedMyMapThreadOptions,StandardCaptureAntibodyPurificationColumn],
							preferredStandardCaptureAntibodyPurificationColumn
                        ];

						(* We want to check whether the volume of the conjugation reaction is above the MaxVolume of any containers - conjugation container, purification column *)
						standardCaptureAntibodyConjugationContainerPacket=Experiment`Private`fetchPacketFromFastAssoc[standardCaptureAntibodyConjugationContainer,simulatedFastAssoc];
						standardCaptureAntibodyConjugationContainerMaxVolume=If[MatchQ[standardCaptureAntibodyConjugationContainerPacket,Null],
							Infinity*Microliter,
							Lookup[standardCaptureAntibodyConjugationContainerPacket,MaxVolume,Infinity*Microliter]
						];
						exceedStandardCaptureAntibodyConjugationContainerError=Which[
							MatchQ[standardCaptureAntibodyVolume,Null],False,
							MatchQ[standardDigoxigeninReagentVolume,Null],False,
							MatchQ[standardCaptureAntibodyConjugationBufferVolume,Null],False,
							True,TrueQ[totalStandardCaptureAntibodyConjugationVolume>standardCaptureAntibodyConjugationContainerMaxVolume]
						];

						(* Get the packet with purification column information *)
						standardCaptureAntibodyPurificationColumnPacket=Experiment`Private`fetchPacketFromFastAssoc[standardCaptureAntibodyPurificationColumn,simulatedFastAssoc];

						(* Get the model of the purification column *)
						standardCaptureAntibodyPurificationColumnModel=Which[
							MatchQ[standardCaptureAntibodyPurificationColumn,ObjectP[Model[Container,Vessel,Filter]]],standardCaptureAntibodyPurificationColumn,
							MatchQ[standardCaptureAntibodyPurificationColumn,ObjectP[Model[Container,Vessel,Filter]]],Lookup[standardCaptureAntibodyPurificationColumnPacket,Model,Null],
							True,Null
						];

						(* Get the MaxVolume of purification column *)
						standardCaptureAntibodyPurificationColumnMaxVolume=If[NullQ[standardCaptureAntibodyPurificationColumnModel],
							Infinity*Microliter,
							Lookup[
								Experiment`Private`fetchPacketFromFastAssoc[standardCaptureAntibodyPurificationColumnModel,simulatedFastAssoc],
								MaxVolume,
								Infinity*Microliter
							]
						];
						exceedStandardCaptureAntibodyPurificationColumnError=Which[
							MatchQ[standardCaptureAntibodyVolume,Null],False,
							MatchQ[standardDigoxigeninReagentVolume,Null],False,
							MatchQ[standardCaptureAntibodyConjugationBufferVolume,Null],False,
							True,TrueQ[totalStandardCaptureAntibodyConjugationVolume>(standardCaptureAntibodyPurificationColumnMaxVolume-100Microliter)]
						];

                        (* Resolve StandardCaptureAntibodyDilution. *)
						(* First we can convert the standardCaptureAntibodyConcentration into mass concentration *)

						standardCaptureAntibodyMassConcentration=If[MatchQ[standardCaptureAntibodyConcentration,GreaterEqualP[0Molar]],
							standardCaptureAntibodyConcentration*captureAntibodyAverageMolecularWeight,
							standardCaptureAntibodyConcentration
						];

						(* Check the concentration of the standard capture antibody sample to decide whether to dilute *)
                        standardCaptureAntibodyDilution=Which[
                            !MatchQ[Lookup[processedMyMapThreadOptions,StandardCaptureAntibodyDilution],Automatic],Lookup[processedMyMapThreadOptions,StandardCaptureAntibodyDilution],
							!resolvedCustomizableCartridgeQ,Null,
							missingStandardCaptureAntibodyError,Null,

							(* Any of the dilution options are set to not Null or Automatic - Set dilution to True *)
							MemberQ[Lookup[processedMyMapThreadOptions,{StandardCaptureAntibodyTargetConcentration,StandardCaptureAntibodyDiluent}],Except[Null|Automatic]],True,
							(* Any of the dilution options are set to Null - Set conjugation to False *)
							MemberQ[Lookup[processedMyMapThreadOptions,{StandardCaptureAntibodyTargetConcentration,StandardCaptureAntibodyDiluent}],Null],False,


                            (* If we find a concentration for the standard capture antibody sample and it's over 5 Microgram/Milliliter, we dilute it *)
                            TrueQ[standardCaptureAntibodyMassConcentration>5Microgram/Milliliter],True,

                            (* If we cannot find a concentration but a bioconjugation is performed, we also dilute it *)
                            MatchQ[standardCaptureAntibodyConcentration,Null]&&MatchQ[standardCaptureAntibodyConjugation,True],True,

                            (* Otherwise we keep the sample and do not dilute it *)
                            True,False
                        ];

						standardCaptureAntibodyTargetConcentration=Which[
							!MatchQ[Lookup[processedMyMapThreadOptions,StandardCaptureAntibodyTargetConcentration],Automatic],Lookup[processedMyMapThreadOptions,StandardCaptureAntibodyTargetConcentration],
							!resolvedCustomizableCartridgeQ,Null,
							missingStandardCaptureAntibodyError,Null,
							!MatchQ[standardCaptureAntibodyDilution,True],Null,

							(* If we find a concentration for the standard capture antibody sample and it's below 3.5 Microgram/Milliliter, we set the target concentration to 1/2 of its original concentration *)
							(* This is a randomly selected number to cover the loss of conjugation/purification - Typically a Zeba spin column has a recovery % of over 80% *)
							TrueQ[standardCaptureAntibodyMassConcentration<=3.5Microgram/Milliliter],standardCaptureAntibodyConcentration/2,

							(* Otherwise we dilute to 3.5 Microgram/Milliliter *)
							True,3.5 Microgram/Milliliter
						];

						(* Here we add two checks to make sure the dilution is valid. We use the resuspension concentration with an estimated loss to 50% during conjugation and purification - this covers the dilution from conjugation reaction and also the loss from spin column *)
						(* Convert standardCaptureAntibodyTargetConcentration into mass concentration *)
						standardCaptureAntibodyTargetMassConcentration=If[MatchQ[standardCaptureAntibodyTargetConcentration,GreaterEqualP[0Molar]],
							standardCaptureAntibodyTargetConcentration*captureAntibodyAverageMolecularWeight,
							standardCaptureAntibodyTargetConcentration
						];

						invalidStandardCaptureAntibodyDilutionError=Which[
							!MatchQ[standardCaptureAntibodyTargetConcentration,GreaterEqualP[0Microgram/Milliliter]|GreaterEqualP[0Molar]],False,

							(* Comment out the estimation of conjguation loss *)
							(*
							(* We get both concentrations in the same units but conjugation set as True *)
							MatchQ[standardCaptureAntibodyTargetMassConcentration,GreaterEqualP[0Microgram/Milliliter]]&&MatchQ[standardCaptureAntibodyMassConcentration,GreaterEqualP[0Milligram/Milliliter]]&&MatchQ[standardCaptureAntibodyConjugation,True],
							TrueQ[standardCaptureAntibodyTargetMassConcentration>0.5*standardCaptureAntibodyMassConcentration],
							*)

							(* DilutionTargetConcentration should not be larger than Resuspension Concentration *)
							MatchQ[standardCaptureAntibodyTargetMassConcentration,GreaterEqualP[0Microgram/Milliliter]]&&MatchQ[standardCaptureAntibodyMassConcentration,GreaterEqualP[0Milligram/Milliliter]],
							TrueQ[standardCaptureAntibodyTargetMassConcentration>standardCaptureAntibodyMassConcentration],

							True,False
						];

						(* A warning can be thrown for setting a concentration that is too high for capillary ELISA experiment *)
						nonOptimalStandardCaptureAntibodyDilutionWarning=If[MatchQ[standardCaptureAntibodyTargetMassConcentration,GreaterEqualP[0Microgram/Milliliter]],
							TrueQ[standardCaptureAntibodyTargetMassConcentration>50Microgram/Milliliter],
							False
						];

                        (* Resolve standardCaptureAntibodyDiluent *)
                        standardCaptureAntibodyDiluent=If[MatchQ[standardCaptureAntibodyDilution,Except[True]]||!resolvedCustomizableCartridgeQ,
                            userDefinedOrDefault[Lookup[processedMyMapThreadOptions,{StandardCaptureAntibodyDiluent}],Null][[1]],
                            userDefinedOrDefault[Lookup[processedMyMapThreadOptions,{StandardCaptureAntibodyDiluent}],{Model[Sample, "id:pZx9jo8LZ7z5"]}][[1]] (* Model[Sample,"Simple Plex Reagent Diluent"] *)
						];

                        (* Resolve standardCaptureAntibodyLoadingVolume - as long as we have a customizable cartridge, default to 50 Microliter. It doesn't matter whether we have resolved capture antibody or not *)
                        standardCaptureAntibodyLoadingVolume=Which[
							MatchQ[Lookup[processedMyMapThreadOptions,StandardCaptureAntibodyLoadingVolume],Except[Automatic]],Lookup[processedMyMapThreadOptions,StandardCaptureAntibodyLoadingVolume],
							!resolvedCustomizableCartridgeQ,Null,
							True,50Microliter
                        ];

						(* StandardDetectionAntibody OPTIONS *)
						(* Get the packet of standardDetectionAntibody *)
						detectionAntibodyPacket=If[!MatchQ[standardDetectionAntibody,Null],
							Experiment`Private`fetchPacketFromFastAssoc[standardDetectionAntibody,simulatedFastAssoc],
							{}
						];

						(* Check the state of the detection antibody - Solid or Liquid *)
						detectionAntibodyState=Lookup[detectionAntibodyPacket,State,Null];

						(* Resolve standardDetectionAntibodyResuspension based on the State of the detection antibody sample *)
						standardDetectionAntibodyResuspension=Which[
							!MatchQ[Lookup[processedMyMapThreadOptions,StandardDetectionAntibodyResuspension],Automatic],Lookup[processedMyMapThreadOptions,StandardDetectionAntibodyResuspension],
							!resolvedCustomizableCartridgeQ,Null,
							missingStandardDetectionAntibodyError,Null,
							MatchQ[detectionAntibodyState,Solid],True,
							True,False
						];

						(* Depending on standardDetectionAntibodyResuspension, resolve other resuspension related options *)
						{standardDetectionAntibodyResuspensionConcentration,standardDetectionAntibodyResuspensionDiluent,standardDetectionAntibodyStorageCondition}=If[MatchQ[standardDetectionAntibodyResuspension,True]&&resolvedCustomizableCartridgeQ,

							(* If standardDetectionAntibodyResuspension is required, set to default values or keep user's values *)
							userDefinedOrDefault[Lookup[processedMyMapThreadOptions,{StandardDetectionAntibodyResuspensionConcentration,StandardDetectionAntibodyResuspensionDiluent,StandardDetectionAntibodyStorageCondition}],{1Milligram/Milliliter,Model[Sample, StockSolution, "id:4pO6dMWvnA0X"],Freezer}], (* Model[Sample, StockSolution,"Filtered PBS, Sterile"] *)

							(* If standardDetectionAntibodyResuspension is not required, set to Null values or keep user's values with error already thrown *)
							userDefinedOrDefault[Lookup[processedMyMapThreadOptions,{StandardDetectionAntibodyResuspensionConcentration,StandardDetectionAntibodyResuspensionDiluent,StandardDetectionAntibodyStorageCondition}],Null]
						];

						(* Find all identity models of the detection antibody *)
						detectionAntibodyIdentityModels=Select[Lookup[detectionAntibodyPacket,Composition,{}],MatchQ[#,{_,ObjectP[Model[Molecule,Protein,Antibody]]}]&];

						(* Get the concentration of the detection antibody. Make sure we get the correct unit *)
						standardDetectionAntibodyConcentration=Which[
							!MatchQ[standardDetectionAntibodyResuspensionConcentration,Null],standardDetectionAntibodyResuspensionConcentration,

							(* Use the concentration of the first antibody identity model *)
							MatchQ[detectionAntibodyIdentityModels,{}],Null,

							MatchQ[detectionAntibodyIdentityModels[[1]][[1]],GreaterEqualP[0Molar]|GreaterEqualP[0Microgram/Milliliter]],detectionAntibodyIdentityModels[[1]][[1]],
							True,Null
						];

						(* Check the packet of the detection antibody for modification *)
						detectionAntibodyIdentityModelPacket=If[!MatchQ[detectionAntibodyIdentityModels,{}],
							Experiment`Private`fetchPacketFromFastAssoc[detectionAntibodyIdentityModels[[1]][[2]],simulatedFastAssoc],
							<||>
						];

						(* Find all molecules of the identity models *)
						detectionAntibodyTargets=Lookup[detectionAntibodyIdentityModelPacket,Targets,{}];

						(* Find all molecular weights of all identity models *)
						detectionAntibodyMolecularWeights=DeleteCases[
              Map[
                Experiment`Private`fastAssocLookup[simulatedFastAssoc,#,{Object,MolecularWeight}]&,
                detectionAntibodyIdentityModels[[All,2]]
              ]
              ,Null
            ];
						(* Use the average molecular weight or 150000 Dalton for caculation *)
						detectionAntibodyAverageMolecularWeight=If[MatchQ[detectionAntibodyMolecularWeights,{}],
							150000Dalton,
							Mean[detectionAntibodyMolecularWeights]
						];

						(* Check whether one of the motifs is modification of biotin *)
						detectionAntibodyConjugatedQ=MemberQ[detectionAntibodyTargets,ObjectP[Model[Molecule, Protein, "id:4pO6dM507ZMz"]]]; (* Model[Molecule,Protein,"Streptavidin"] *)

						(* Resolve standardDetectionAntibodyConjugation based on the composition of the detection antibody sample. We also check whether any of the resuspension values are set to Null or populated to help resolving the conjugation boolean*)
						standardDetectionAntibodyConjugation=Which[
							!MatchQ[Lookup[processedMyMapThreadOptions,StandardDetectionAntibodyConjugation],Automatic],Lookup[processedMyMapThreadOptions,StandardDetectionAntibodyConjugation],
							!resolvedCustomizableCartridgeQ,Null,
							MatchQ[standardDetectionAntibody,Null],Null,
							(* Any of the conjugation options are set to not Null or Automatic - Set conjugation to True *)
							MemberQ[Lookup[processedMyMapThreadOptions,{StandardDetectionAntibodyVolume,StandardBiotinReagent,StandardBiotinReagentVolume,StandardDetectionAntibodyConjugationBuffer,StandardDetectionAntibodyConjugationBufferVolume,StandardDetectionAntibodyConjugationContainer,StandardDetectionAntibodyConjugationTime,StandardDetectionAntibodyConjugationTemperature,StandardDetectionAntibodyPurificationColumn,StandardDetectionAntibodyColumnWashBuffer,StandardDetectionAntibodyConjugationStorageCondition}],Except[Null|Automatic]],True,

							(* Any of the conjugation options are set to Null - Set conjugation to False *)
							MemberQ[Lookup[processedMyMapThreadOptions,{StandardDetectionAntibodyVolume,StandardBiotinReagent,StandardBiotinReagentVolume,StandardDetectionAntibodyConjugationBuffer,StandardDetectionAntibodyConjugationBufferVolume,StandardDetectionAntibodyConjugationContainer,StandardDetectionAntibodyConjugationTime,StandardDetectionAntibodyConjugationTemperature,StandardDetectionAntibodyPurificationColumn,StandardDetectionAntibodyColumnWashBuffer,StandardDetectionAntibodyConjugationStorageCondition}],Null],False,

							(* Otherwise just go with our resolved conjugation value *)
							True,!detectionAntibodyConjugatedQ
						];

						(* Resolve StandardDetectionAntibodyVolume and StandardBiotinReagent based on whether conjugation is required *)
						{standardDetectionAntibodyVolume,standardBiotinReagent}=If[MatchQ[standardDetectionAntibodyConjugation,True]&&resolvedCustomizableCartridgeQ,
							userDefinedOrDefault[Lookup[processedMyMapThreadOptions,{StandardDetectionAntibodyVolume,StandardBiotinReagent}],{100Microliter,Model[Sample, StockSolution, "id:bq9LA0JWaP8r"]}], (* Model[Sample,StockSolution,"Biotin-XX, 1 mg/mL in DMSO"] *)
							userDefinedOrDefault[Lookup[processedMyMapThreadOptions,{StandardDetectionAntibodyVolume,StandardBiotinReagent}],Null]
						];

						(* Get the packet of standardBiotinReagent *)
						standardBiotinReagentPacket=Experiment`Private`fetchPacketFromFastAssoc[standardBiotinReagent,simulatedFastAssoc];

						(* Get the composition of standardBiotinReagent with the one for Model[Molecule,"Biotinamidohexanoyl-6-aminohexanoic acid N-hydroxysuccinimide ester"]. We currently may not be able to search for another Biotin modification molecule as its reaction mechanism may be completely different and the ratio must also be adjusted. *)
						standardBiotinReagentComposition=If[!MatchQ[standardBiotinReagentPacket,Null],
							Select[Lookup[standardBiotinReagentPacket,Composition,{}],MatchQ[#,{_,ObjectP[Model[Molecule, "id:1ZA60vLKWYD8"]]}]&], (* Model[Molecule,"Biotinamidohexanoyl-6-aminohexanoic acid N-hydroxysuccinimide ester"] *)
							{}
						];

						(* Get the concentration of biotin reagent from its composition *)
						standardBiotinReagentConcentration=If[!MatchQ[standardBiotinReagentComposition,{}],
							standardBiotinReagentComposition[[1,1]],
							Null
						];

						biotinMoleculeMolecularWeight=Quantity[567.7, "Grams"/"Moles"]; (* Model[Molecule,"Biotinamidohexanoyl-6-aminohexanoic acid N-hydroxysuccinimide ester"] *)

						(* Resolve standardBiotinReagentVolume and set boolean error if we cannot resolve it *)
						{standardBiotinReagentVolume,missingStandardBiotinReagentVolumeError}=Which[
							!MatchQ[Lookup[processedMyMapThreadOptions,StandardBiotinReagentVolume],Automatic],{Lookup[processedMyMapThreadOptions,StandardBiotinReagentVolume],False},
							MatchQ[myStandardSample,Null],{Null,False},
							!resolvedCustomizableCartridgeQ,{Null,False},
							missingStandardDetectionAntibodyError,{Null,False},
							!standardDetectionAntibodyConjugation,{Null,False},

							(* When the standardDetectionAntibodyConjugation is True but we cannot resolve standardDetectionAntibodyConcentration, we have to set standardBiotinReagentVolume to Null*)
							MatchQ[standardDetectionAntibodyConcentration,Null],{Null,True},

							(* When we cannot find standardBiotinReagentConcentration from its composition, we also have to set standardBiotinReagentVolume to Null *)
							MatchQ[standardBiotinReagentConcentration,Null],{Null,True},

							(* Otherwise we can set to 5:1 excess using the concentrations and standardDetectionAntibodyVolume by calling the helper function *)
							True,{SafeRound[calculateBiotinVolume[detectionAntibodyAverageMolecularWeight,biotinMoleculeMolecularWeight,standardDetectionAntibodyVolume,standardDetectionAntibodyConcentration,standardBiotinReagentConcentration],10^-1Microliter],False}
						];

						(* We also want to check whether the volume of biotin reagent is giving more conjugation reagent compared to antibodies. This check only happens when we have all the information required *)
						notEnoughStandardBiotinReagentVolumeWarning=Which[
							!standardDetectionAntibodyConjugation,False,
							MatchQ[standardDetectionAntibodyVolume,Null],False,
							MatchQ[standardDetectionAntibodyConcentration,Null],False,
							MatchQ[standardBiotinReagentVolume,Null],False,
							MatchQ[standardBiotinReagentConcentration,Null],False,
							True,TrueQ[calculateBiotinVolume[detectionAntibodyAverageMolecularWeight,biotinMoleculeMolecularWeight,standardDetectionAntibodyVolume,standardDetectionAntibodyConcentration,standardBiotinReagentConcentration]/10>standardBiotinReagentVolume]
						];

						(* Resolve standardDetectionAntibodyConjugationBuffer *)
						standardDetectionAntibodyConjugationBuffer=Which[
							!MatchQ[Lookup[processedMyMapThreadOptions,StandardDetectionAntibodyConjugationBuffer],Automatic],Lookup[processedMyMapThreadOptions,StandardDetectionAntibodyConjugationBuffer],
							!resolvedCustomizableCartridgeQ,Null,
							!MatchQ[standardDetectionAntibodyConjugation,True],Null,
							MatchQ[standardDetectionAntibodyConjugation,True],Model[Sample, StockSolution, "id:1ZA60vL4PZbq"] (* Model[Sample, StockSolution, "Sodium bicarbonate working stock 75 mg/mL"] *)
						];


						(* Resolve standardDetectionAntibodyConjugationBufferVolume *)
						standardDetectionAntibodyConjugationBufferVolume=Which[
							!MatchQ[Lookup[processedMyMapThreadOptions,StandardDetectionAntibodyConjugationBufferVolume],Automatic],Lookup[processedMyMapThreadOptions,StandardDetectionAntibodyConjugationBufferVolume],
							!resolvedCustomizableCartridgeQ,Null,
							!MatchQ[standardDetectionAntibodyConjugation,True],Null,

							(* If the user has set standardDetectionAntibodyVolume to Null, we cannot resolve the volume of buffer. This error has been thrown during conflict option check. *)
							MatchQ[standardDetectionAntibodyVolume,Null],Null,

							(* If we cannot resolve standardBiotinReagentVolume or the user has set it to Null, we cannot resolve the volume of buffer. An error has been thrown earlier. *)
							MatchQ[standardBiotinReagentVolume,Null],Null,

							(* Otherwise we can set the volume of buffer to 1/9 of total volume of two reagents *)
							True,SafeRound[1/9*(standardDetectionAntibodyVolume+standardBiotinReagentVolume),10^-1Microliter]
						];


						(* Get the total volume to resolve the conjugation container *)
						totalStandardDetectionAntibodyConjugationVolume=If[MemberQ[{standardDetectionAntibodyVolume,standardBiotinReagentVolume,standardDetectionAntibodyConjugationBufferVolume},Null],
							(* Use 0 Microliter if we cannot resolve any of the volumes *)
							0Microliter,
							(standardDetectionAntibodyVolume+standardBiotinReagentVolume+standardDetectionAntibodyConjugationBufferVolume)
						];

						preferredStandardDetectionAntibodyConjugationContainer=PreferredContainer[totalStandardDetectionAntibodyConjugationVolume];

						(* Resolve other detection antibody conjugation options *)
						{
							standardDetectionAntibodyConjugationContainer,
							standardDetectionAntibodyConjugationTime,
							standardDetectionAntibodyConjugationTemperature,
							standardDetectionAntibodyConjugationStorageCondition,
							standardDetectionAntibodyColumnWashBuffer
						}=If[MatchQ[standardDetectionAntibodyConjugation,True]&&resolvedCustomizableCartridgeQ,

							(* Set default values when conjugation is needed *)
							userDefinedOrDefault[
								Lookup[
									processedMyMapThreadOptions,
									{
										StandardDetectionAntibodyConjugationContainer,
										StandardDetectionAntibodyConjugationTime,
										StandardDetectionAntibodyConjugationTemperature,
										StandardDetectionAntibodyConjugationStorageCondition,
										StandardDetectionAntibodyColumnWashBuffer
									}
								],
								{preferredStandardDetectionAntibodyConjugationContainer,1Hour,Ambient,Refrigerator,Model[Sample, StockSolution, "id:4pO6dMWvnA0X"]} (* Model[Sample, StockSolution, "Filtered PBS, Sterile"] *)
							],

							(* Set to Null when conjugation is not needed *)
							userDefinedOrDefault[
								Lookup[
									processedMyMapThreadOptions,
									{
										StandardDetectionAntibodyConjugationContainer,
										StandardDetectionAntibodyConjugationTime,
										StandardDetectionAntibodyConjugationTemperature,
										StandardDetectionAntibodyConjugationStorageCondition,
										StandardDetectionAntibodyColumnWashBuffer
									}
								],
								Null
							]
						];

						(* Resolve standardDetectionAntibodyPurificationColumn and all purification related options *)
						(* Decide the preferred purification column using the provided volumes *)
						preferredStandardDetectionAntibodyPurificationColumn=Which[
							!resolvedCustomizableCartridgeQ,Null,
							!MatchQ[standardDetectionAntibodyConjugation,True],Null,

							(* If the user has set standardDetectionAntibodyVolume to Null, we cannot resolve the total volume of the conjugation reaction. This error has been thrown during conflict option check. *)
							MatchQ[standardDetectionAntibodyVolume,Null],Null,

							(* If we cannot resolve standardBiotinReagentVolume or the user has set it to Null, we cannot resolve the total volume of the conjugation reaction. *)
							MatchQ[standardBiotinReagentVolume,Null],Null,

							(* If we cannot resolve standardDetectionAntibodyConjugationBufferVolume or the user has set it to Null, we cannot resolve the total volume of the conjugation reaction. *)
							MatchQ[standardDetectionAntibodyConjugationBufferVolume,Null],Null,

							(* Otherwise we can get the total volume and decide the purification column to use *)
							True,
							First[
								FirstOrDefault[
									Select[
										sorted40KSpinColumnsWithMaxVolumes,
										Last[#]>=(totalStandardDetectionAntibodyConjugationVolume+100Microliter)&
									],
									(* Get a default if the volume is too large but it should not happen *)
									Last[sorted40KSpinColumnsWithMaxVolumes]
								]
							]

						];
						
						standardDetectionAntibodyPurificationColumn=If[!MatchQ[Lookup[processedMyMapThreadOptions,StandardDetectionAntibodyPurificationColumn],Automatic],
							Lookup[processedMyMapThreadOptions,StandardDetectionAntibodyPurificationColumn],
							preferredStandardDetectionAntibodyPurificationColumn
						];

						(* We want to check whether the volume of the conjugation reaction is above the MaxVolume of any containers - conjugation container, purification colume *)
						standardDetectionAntibodyConjugationContainerPacket=Experiment`Private`fetchPacketFromFastAssoc[standardDetectionAntibodyConjugationContainer,simulatedFastAssoc];
						standardDetectionAntibodyConjugationContainerMaxVolume=If[MatchQ[standardDetectionAntibodyConjugationContainerPacket,Null],
							Infinity*Microliter,
							Lookup[standardDetectionAntibodyConjugationContainerPacket,MaxVolume,Infinity*Microliter]
						];
						exceedStandardDetectionAntibodyConjugationContainerError=Which[
							MatchQ[standardDetectionAntibodyVolume,Null],False,
							MatchQ[standardBiotinReagentVolume,Null],False,
							MatchQ[standardDetectionAntibodyConjugationBufferVolume,Null],False,
							True,TrueQ[totalStandardDetectionAntibodyConjugationVolume>standardDetectionAntibodyConjugationContainerMaxVolume]
						];

						(* Get the packet with purification column information *)
						standardDetectionAntibodyPurificationColumnPacket=Experiment`Private`fetchPacketFromFastAssoc[standardDetectionAntibodyPurificationColumn,simulatedFastAssoc];

						(* Get the model of the purification column *)
						standardDetectionAntibodyPurificationColumnModel=Which[
							MatchQ[standardDetectionAntibodyPurificationColumn,ObjectP[Model[Container,Vessel,Filter]]],standardDetectionAntibodyPurificationColumn,
							MatchQ[standardDetectionAntibodyPurificationColumn,ObjectP[Model[Container,Vessel,Filter]]],Lookup[standardDetectionAntibodyPurificationColumnPacket,Model,Null],
							True,Null
						];

						(* Get the MaxVolume of purification column *)
						standardDetectionAntibodyPurificationColumnMaxVolume=If[NullQ[standardDetectionAntibodyPurificationColumnModel],
							Infinity*Microliter,
							Lookup[
								Experiment`Private`fetchPacketFromFastAssoc[standardDetectionAntibodyPurificationColumnModel,simulatedFastAssoc],
								MaxVolume,
								Infinity*Microliter
							]
						];
						exceedStandardDetectionAntibodyPurificationColumnError=Which[
							MatchQ[standardDetectionAntibodyVolume,Null],False,
							MatchQ[standardBiotinReagentVolume,Null],False,
							MatchQ[standardDetectionAntibodyConjugationBufferVolume,Null],False,
							True,TrueQ[totalStandardDetectionAntibodyConjugationVolume>(standardDetectionAntibodyPurificationColumnMaxVolume-100Microliter)]
						];

						(* Resolve StandardDetectionAntibodyDilution. *)
						(* First we can convert the standardDetectionAntibodyConcentration into mass concentration *)

						standardDetectionAntibodyMassConcentration=If[MatchQ[standardDetectionAntibodyConcentration,GreaterEqualP[0Molar]],
							standardDetectionAntibodyConcentration*detectionAntibodyAverageMolecularWeight,
							standardDetectionAntibodyConcentration
						];

						(* Check the concentration of the standard detection antibody sample to decide whether to dilute *)
						standardDetectionAntibodyDilution=Which[
							!MatchQ[Lookup[processedMyMapThreadOptions,StandardDetectionAntibodyDilution],Automatic],Lookup[processedMyMapThreadOptions,StandardDetectionAntibodyDilution],
							!resolvedCustomizableCartridgeQ,Null,
							missingStandardDetectionAntibodyError,Null,

							(* Any of the dilution options are set to not Null or Automatic - Set dilution to True *)
							MemberQ[Lookup[processedMyMapThreadOptions,{Standard,DetectionAntibodyTargetConcentration,DetectionAntibodyDiluent}],Except[Null|Automatic]],True,
							(* Any of the conjugation options are set to Null - Set conjugation to False *)
							MemberQ[Lookup[processedMyMapThreadOptions,{Standard,DetectionAntibodyTargetConcentration,DetectionAntibodyDiluent}],Null],False,


							(* If we find a concentration for the standard detection antibody sample and it's over 5 Microgram/Milliliter, we dilute it *)
							TrueQ[standardDetectionAntibodyMassConcentration>5Microgram/Milliliter],True,

							(* If we cannot find a concentration but a bioconjugation is performed, we also dilute it *)
							MatchQ[standardDetectionAntibodyConcentration,Null]&&MatchQ[standardDetectionAntibodyConjugation,True],True,

							(* Otherwise we keep the sample and do not dilute it *)
							True,False
						];

						standardDetectionAntibodyTargetConcentration=Which[
							!MatchQ[Lookup[processedMyMapThreadOptions,StandardDetectionAntibodyTargetConcentration],Automatic],Lookup[processedMyMapThreadOptions,StandardDetectionAntibodyTargetConcentration],
							!resolvedCustomizableCartridgeQ,Null,
							missingStandardDetectionAntibodyError,Null,
							!MatchQ[standardDetectionAntibodyDilution,True],True,

							(* If we find a concentration for the standard detection antibody sample and it's below 3.5 Microgram/Milliliter, we set the target concentration to 1/2 of its original concentration *)
							(* This is a randomly selected number to cover the loss of conjugation/purification - Typically a Zeba spin column has a recovery % of over 80% *)
							TrueQ[standardDetectionAntibodyMassConcentration<=3.5Microgram/Milliliter],standardDetectionAntibodyConcentration/2,

							(* Otherwise we dilute to 3.5 Microgram/Milliliter *)
							True,3.5 Microgram/Milliliter
						];

						(* Here we add two checks to make sure the dilution is valid. We use the resuspension concentration with an estimated loss to 50% during conjugation and purification - this covers the dilution from conjugation reaction and also the loss from spin column *)
						(* Convert standardDetectionAntibodyTargetConcentration into mass concentration *)
						standardDetectionAntibodyTargetMassConcentration=If[MatchQ[standardDetectionAntibodyTargetConcentration,GreaterEqualP[0Molar]],
							standardDetectionAntibodyTargetConcentration*detectionAntibodyAverageMolecularWeight,
							standardDetectionAntibodyTargetConcentration
						];

						invalidStandardDetectionAntibodyDilutionError=Which[
							!MatchQ[standardDetectionAntibodyTargetConcentration,GreaterEqualP[0Microgram/Milliliter]|GreaterEqualP[0Molar]],False,

							(* Comment out the estimation of conjguation loss *)
							(*
							(* We get both concentrations in the same units but conjugation set as True *)
							MatchQ[standardDetectionAntibodyTargetMassConcentration,GreaterEqualP[0Microgram/Milliliter]]&&MatchQ[standardDetectionAntibodyMassConcentration,GreaterEqualP[0Milligram/Milliliter]]&&MatchQ[standardDetectionAntibodyConjugation,True],
							TrueQ[standardDetectionAntibodyTargetMassConcentration>0.5*standardDetectionAntibodyMassConcentration],
							*)

							(* DilutionTargetConcentration should not be larger than Resuspension Concentration *)
							MatchQ[standardDetectionAntibodyTargetMassConcentration,GreaterEqualP[0Microgram/Milliliter]]&&MatchQ[standardDetectionAntibodyMassConcentration,GreaterEqualP[0Milligram/Milliliter]],
							TrueQ[standardDetectionAntibodyTargetMassConcentration>standardDetectionAntibodyMassConcentration],

							True,False
						];

						(* A warning can be thrown for setting a concentration that is too high for capillary ELISA experiment *)
						nonOptimalStandardDetectionAntibodyDilutionWarning=If[MatchQ[standardDetectionAntibodyTargetMassConcentration,GreaterEqualP[0Microgram/Milliliter]],
							TrueQ[standardDetectionAntibodyTargetMassConcentration>50Microgram/Milliliter],
							False
						];

						(* Resolve standardDetectionAntibodyDiluent *)
						standardDetectionAntibodyDiluent=If[MatchQ[standardDetectionAntibodyDilution,Except[True]]||!resolvedCustomizableCartridgeQ,
							userDefinedOrDefault[Lookup[processedMyMapThreadOptions,{StandardDetectionAntibodyDiluent}],Null][[1]],
							userDefinedOrDefault[Lookup[processedMyMapThreadOptions,{StandardDetectionAntibodyDiluent}],{Model[Sample, "id:pZx9jo8LZ7z5"]}][[1]] (* Model[Sample, "Simple Plex Reagent Diluent"] *)
						];

						(* Resolve standardDetectionAntibodyLoadingVolume - as long as we have a customizable cartridge, default to 50 Microliter. It doesn't matter whether we have resolved detection antibody or not *)
						standardDetectionAntibodyLoadingVolume=Which[
							MatchQ[Lookup[processedMyMapThreadOptions,StandardDetectionAntibodyLoadingVolume],Except[Automatic]],Lookup[processedMyMapThreadOptions,StandardDetectionAntibodyLoadingVolume],
							!resolvedCustomizableCartridgeQ,Null,
							True,50Microliter
						];

                        
                        (* We now have all the Standard related options resolved and we are ready to return everything back to MapThread *)
                        {
							standardResuspension,
							standardResuspensionConcentration,
							standardResuspensionDiluent,
							standardStorageCondition,
							standardDilutionCurve,
							standardSerialDilutionCurve,
							standardDiluent,
							standardDilutionMixVolume,
							standardDilutionNumberOfMixes,
							standardDilutionMixRate,
							standardCaptureAntibody,
							standardCaptureAntibodyResuspension,
							standardCaptureAntibodyResuspensionConcentration,
							standardCaptureAntibodyResuspensionDiluent,
							standardCaptureAntibodyStorageCondition,
							standardCaptureAntibodyConjugation,
							standardCaptureAntibodyVolume,
							standardDigoxigeninReagent,
							standardDigoxigeninReagentVolume,
							standardCaptureAntibodyConjugationBuffer,
							standardCaptureAntibodyConjugationBufferVolume,
							standardCaptureAntibodyConjugationContainer,
							standardCaptureAntibodyConjugationTime,
							standardCaptureAntibodyConjugationTemperature,
							standardCaptureAntibodyPurificationColumn,
							standardCaptureAntibodyColumnWashBuffer,
							standardCaptureAntibodyConjugationStorageCondition,
							standardCaptureAntibodyDilution,
							standardCaptureAntibodyTargetConcentration,
							standardCaptureAntibodyDiluent,
							standardDetectionAntibody,
							standardDetectionAntibodyResuspension,
							standardDetectionAntibodyResuspensionConcentration,
							standardDetectionAntibodyResuspensionDiluent,
							standardDetectionAntibodyStorageCondition,
							standardDetectionAntibodyConjugation,
							standardDetectionAntibodyVolume,
							standardBiotinReagent,
							standardBiotinReagentVolume,
							standardDetectionAntibodyConjugationBuffer,
							standardDetectionAntibodyConjugationBufferVolume,
							standardDetectionAntibodyConjugationContainer,
							standardDetectionAntibodyConjugationTime,
							standardDetectionAntibodyConjugationTemperature,
							standardDetectionAntibodyPurificationColumn,
							standardDetectionAntibodyColumnWashBuffer,
							standardDetectionAntibodyConjugationStorageCondition,
							standardDetectionAntibodyDilution,
							standardDetectionAntibodyTargetConcentration,
							standardDetectionAntibodyDiluent,
							standardLoadingVolume,
							standardCaptureAntibodyLoadingVolume,
							standardDetectionAntibodyLoadingVolume,
							standardComposition,
							nonOptimalStandardResuspensionWarning,
							incompleteResolvedStandardCompositionError,
							nonOptimalStandardDiluentWarning,
							conflictStandardAntibodyEpitopeWarning,
							standardCaptureAntibodyAssayTypeWarning,
							standardDetectionAntibodyAssayTypeWarning,
							missingStandardCaptureAntibodyError,
							missingStandardDetectionAntibodyError,
							missingStandardDigoxigeninReagentVolumeError,
							missingStandardBiotinReagentVolumeError,
							notEnoughStandardDigoxigeninReagentVolumeWarning,
							notEnoughStandardBiotinReagentVolumeWarning,
							exceedStandardCaptureAntibodyConjugationContainerError,
							exceedStandardDetectionAntibodyConjugationContainerError,
							exceedStandardCaptureAntibodyPurificationColumnError,
							exceedStandardDetectionAntibodyPurificationColumnError,
							invalidStandardCaptureAntibodyDilutionError,
							invalidStandardDetectionAntibodyDilutionError,
							nonOptimalStandardCaptureAntibodyDilutionWarning,
							nonOptimalStandardDetectionAntibodyDilutionWarning,
							standardUpperQuantitationLimit,
							totalStandardCaptureAntibodyConjugationVolume,
							standardCaptureAntibodyConjugationContainerMaxVolume,
							standardCaptureAntibodyPurificationColumnMaxVolume,
							preferredStandardCaptureAntibodyPurificationColumn,
							totalStandardDetectionAntibodyConjugationVolume,
							standardDetectionAntibodyConjugationContainerMaxVolume,
							standardDetectionAntibodyPurificationColumnMaxVolume,
							preferredStandardDetectionAntibodyPurificationColumn
                        }

                    ]
                ],

				(* MapThread on our resolvedStandard, the resolved standard analytes and the map thread friendly options *)
				{ToList[resolvedStandard],resolvedPreLoadedStandardAnalytes,resolvedCustomizableStandardAnalytes,standardMapThreadFriendlyOptions}
            ]
        ]
    ];


    (* -- RESOLVE ALL MAPTHREAD OPTIONS -- *)
	(* Note that SpikeSample is not an automatic option. We can just use the user-defined value as input for MapThread *)
    {
		resolvedAnalytes,
        resolvedSampleVolume,
        resolvedSpikeVolume,
        resolvedDilutionCurve,
        resolvedSerialDilutionCurve,
        resolvedDiluent,
		resolvedDilutionMixVolume,
		resolvedCustomCaptureAntibody,
        resolvedCaptureAntibodyResuspension,
        resolvedCaptureAntibodyResuspensionConcentration,
        resolvedCaptureAntibodyResuspensionDiluent,
        resolvedCaptureAntibodyStorageCondition,
        resolvedCaptureAntibodyConjugation,
        resolvedCaptureAntibodyVolume,
        resolvedDigoxigeninReagent,
        resolvedDigoxigeninReagentVolume,
        resolvedCaptureAntibodyConjugationBuffer,
        resolvedCaptureAntibodyConjugationBufferVolume,
        resolvedCaptureAntibodyConjugationContainer,
        resolvedCaptureAntibodyConjugationTime,
        resolvedCaptureAntibodyConjugationTemperature,
        resolvedCaptureAntibodyPurificationColumn,
        resolvedCaptureAntibodyColumnWashBuffer,
        resolvedCaptureAntibodyConjugationStorageCondition,
        resolvedCaptureAntibodyDilution,
		resolvedCaptureAntibodyTargetConcentration,
        resolvedCaptureAntibodyDiluent,
		resolvedCustomDetectionAntibody,
		resolvedDetectionAntibodyResuspension,
		resolvedDetectionAntibodyResuspensionConcentration,
		resolvedDetectionAntibodyResuspensionDiluent,
		resolvedDetectionAntibodyStorageCondition,
		resolvedDetectionAntibodyConjugation,
		resolvedDetectionAntibodyVolume,
		resolvedBiotinReagent,
		resolvedBiotinReagentVolume,
		resolvedDetectionAntibodyConjugationBuffer,
		resolvedDetectionAntibodyConjugationBufferVolume,
		resolvedDetectionAntibodyConjugationContainer,
		resolvedDetectionAntibodyConjugationTime,
		resolvedDetectionAntibodyConjugationTemperature,
		resolvedDetectionAntibodyPurificationColumn,
		resolvedDetectionAntibodyColumnWashBuffer,
		resolvedDetectionAntibodyConjugationStorageCondition,
		resolvedDetectionAntibodyDilution,
		resolvedDetectionAntibodyTargetConcentration,
		resolvedDetectionAntibodyDiluent,
		resolvedCaptureAntibodyLoadingVolume,
		resolvedDetectionAntibodyLoadingVolume,
		resolvedSpikeConcentration,
		incompleteResolvedSpikeConcentrationErrors,
		nonOptimalDilutionWarnings,
		conflictAntibodyEpitopeWarnings,
		captureAntibodyAssayTypeWarnings,
		detectionAntibodyAssayTypeWarnings,
		missingCaptureAntibodyErrors,
		missingDetectionAntibodyErrors,
		missingDigoxigeninReagentVolumeErrors,
		missingBiotinReagentVolumeErrors,
		notEnoughDigoxigeninReagentVolumeWarnings,
		notEnoughBiotinReagentVolumeWarnings,
		exceedCaptureAntibodyConjugationContainerErrors,
		exceedDetectionAntibodyConjugationContainerErrors,
		exceedCaptureAntibodyPurificationColumnErrors,
		exceedDetectionAntibodyPurificationColumnErrors,
		invalidCaptureAntibodyDilutionErrors,
		invalidDetectionAntibodyDilutionErrors,
		nonOptimalCaptureAntibodyDilutionWarnings,
		nonOptimalDetectionAntibodyDilutionWarnings,
		captureAntibodyConjuationReactionVolumes,
		captureAntibodyConjugationContainerMaxVolumes,
		captureAntibodyPurificationColumnMaxVolumes,
		preferredCaptureAntibodyPurificationColumns,
		detectionAntibodyConjuationReactionVolumes,
		detectionAntibodyConjugationContainerMaxVolumes,
		detectionAntibodyPurificationColumnMaxVolumes,
		preferredDetectionAntibodyPurificationColumns
    }=Transpose[
        MapThread[
            Function[
                {mySample,myAnalyte,myMapThreadOptions},
                Module[
                    {
                        (* All option variables *)
						analyte,analyteMolecule,sampleVolume,spikeVolume,dilutionCurve,serialDilutionCurve,diluent,dilutionMixVolume,
						customCaptureAntibody,captureAntibodyResuspension,captureAntibodyResuspensionConcentration,captureAntibodyResuspensionDiluent,captureAntibodyStorageCondition,captureAntibodyConjugation,captureAntibodyVolume,digoxigeninReagent,digoxigeninReagentVolume,captureAntibodyConjugationBuffer,captureAntibodyConjugationBufferVolume,preferredCaptureAntibodyConjugationContainer,totalCaptureAntibodyConjugationVolume,captureAntibodyConjugationContainer,captureAntibodyConjugationTime,captureAntibodyConjugationTemperature,captureAntibodyPurificationColumn,captureAntibodyColumnWashBuffer,captureAntibodyConjugationStorageCondition,captureAntibodyDilution,captureAntibodyTargetConcentration,captureAntibodyDiluent,
						customDetectionAntibody,detectionAntibodyResuspension,detectionAntibodyResuspensionConcentration,detectionAntibodyResuspensionDiluent,detectionAntibodyStorageCondition,detectionAntibodyConjugation,detectionAntibodyVolume,biotinReagent,biotinReagentVolume,detectionAntibodyConjugationBuffer,detectionAntibodyConjugationBufferVolume,preferredDetectionAntibodyConjugationContainer,totalDetectionAntibodyConjugationVolume,detectionAntibodyConjugationContainer,detectionAntibodyConjugationTime,detectionAntibodyConjugationTemperature,detectionAntibodyPurificationColumn,detectionAntibodyColumnWashBuffer,detectionAntibodyConjugationStorageCondition,detectionAntibodyDilution,detectionAntibodyTargetConcentration,detectionAntibodyDiluent,captureAntibodyLoadingVolume,detectionAntibodyLoadingVolume,
						spikeConcentration,

                        (* All error track booleans *)
						incompleteResolvedSpikeConcentrationError,nonOptimalDilutionWarning,conflictAntibodyEpitopeWarning,captureAntibodyAssayTypeWarning,detectionAntibodyAssayTypeWarning,missingCaptureAntibodyError,missingDetectionAntibodyError,missingDigoxigeninReagentVolumeError,missingBiotinReagentVolumeError,notEnoughDigoxigeninReagentVolumeWarning,notEnoughBiotinReagentVolumeWarning,exceedCaptureAntibodyConjugationContainerError,exceedDetectionAntibodyConjugationContainerError,exceedCaptureAntibodyPurificationColumnError,exceedDetectionAntibodyPurificationColumnError,invalidCaptureAntibodyDilutionError,invalidDetectionAntibodyDilutionError,nonOptimalCaptureAntibodyDilutionWarning,nonOptimalDetectionAntibodyDilutionWarning,

                        (* All other variables *)
                        mySamplePacket,spikeSample,spikePacket,spikeAnalyte,bestDilutionMixVolume,captureAntibodyNewRules,detectionAntibodyNewRules,processedMyMapThreadOptions,captureAntibodyPacket,captureAntibodyState,captureAntibodyIdentityModels,captureAntibodyIdentityModelPacket,captureAntibodyConcentration,captureAntibodySecondaryAntibidies,captureAntibodyMolecularWeights,captureAntibodyAverageMolecularWeight,captureAntibodyConjugatedQ,digoxigeninReagentPacket,digoxigeninReagentComposition,digoxigeninReagentConcentration,digoxigeninMoleculeMolecularWeight,captureAntibodyPurificationColumnPacket,preferredCaptureAntibodyPurificationColumn,captureAntibodyPurificationColumnModel,captureAntibodyConjugationContainerPacket,captureAntibodyConjugationContainerMaxVolume,captureAntibodyPurificationColumnMaxVolume,captureAntibodyMassConcentration,captureAntibodyTargetMassConcentration,detectionAntibodyPacket,detectionAntibodyState,detectionAntibodyIdentityModels,detectionAntibodyIdentityModelPacket,detectionAntibodyConcentration,detectionAntibodyTargets,detectionAntibodyMolecularWeights,detectionAntibodyAverageMolecularWeight,detectionAntibodyConjugatedQ,biotinReagentPacket,biotinReagentComposition,biotinReagentConcentration,biotinMoleculeMolecularWeight,detectionAntibodyPurificationColumnPacket,detectionAntibodyPurificationColumnModel,preferredDetectionAntibodyPurificationColumn,detectionAntibodyConjugationContainerPacket,detectionAntibodyConjugationContainerMaxVolume,detectionAntibodyPurificationColumnMaxVolume,detectionAntibodyMassConcentration,detectionAntibodyTargetMassConcentration
                    },

                    (* Setup our error tracking variables *)
                    {incompleteResolvedSpikeConcentrationError,nonOptimalDilutionWarning,conflictAntibodyEpitopeWarning,captureAntibodyAssayTypeWarning,detectionAntibodyAssayTypeWarning,missingCaptureAntibodyError,missingDetectionAntibodyError,missingDigoxigeninReagentVolumeError,missingBiotinReagentVolumeError,notEnoughDigoxigeninReagentVolumeWarning,notEnoughBiotinReagentVolumeWarning,exceedCaptureAntibodyConjugationContainerError,exceedDetectionAntibodyConjugationContainerError,exceedCaptureAntibodyPurificationColumnError,exceedDetectionAntibodyPurificationColumnError,invalidCaptureAntibodyDilutionError,invalidDetectionAntibodyDilutionError,nonOptimalCaptureAntibodyDilutionWarning,nonOptimalDetectionAntibodyDilutionWarning}=ConstantArray[False,19];

                    (* Get the packet of mySample *)
                    mySamplePacket=Experiment`Private`fetchPacketFromFastAssoc[mySample,simulatedFastAssoc];

                    (* Check whether we have got a spike sample and get the packet *)
					spikeSample=Lookup[myMapThreadOptions,SpikeSample];
                    spikePacket=Experiment`Private`fetchPacketFromFastAssoc[spikeSample,simulatedFastAssoc];

                    (* Find the analyte of the spike sample. We only keep the part from customizable analyte - the most common analyte in the sample. We can use it to resolve the analyte of the sample if needed *)
                    spikeAnalyte=If[!MatchQ[spikeSample,Null],
						FirstOrDefault[selectCapillaryELISAAnalyteFromSample[spikeSample,Cache->simulatedCache][[2]]],
						Null
					];

					(* We have already resolved the analytes - Depending on the type of cartridge, return the analyte *)
					analyte=Which[
						!MatchQ[Lookup[myMapThreadOptions,Analytes],Automatic],Lookup[myMapThreadOptions,Analytes],

						(* Get the pre-loaded cartridge analytes *)
						!resolvedCustomizableCartridgeQ,resolvedPreLoadedAnalytes,

						(* Get myAnalyte if it is not Null *)
						!NullQ[myAnalyte],myAnalyte,

						(* Otherwise we can use spikeAnalyte - This covers the case with Null*)
						True,spikeAnalyte
					];

					(* set up a variable for analyteMolecule. This is used for the case that an analyte name is provided but we need a molecule for resolver *)
					analyteMolecule=Which[
						MatchQ[analyte,ListableP[ObjectP[Model[Molecule]]]],
						analyte,

						(* Otherwise we can use the resolved analyte molecules *)
						resolvedCustomizableCartridgeQ,myAnalyte,

						True,analyte

					];

                    (* Resolve sampleVolume *)
                    sampleVolume=Which[

                        (* Keep user-defined value *)
                        !MatchQ[Lookup[myMapThreadOptions,SampleVolume],Automatic],Lookup[myMapThreadOptions,SampleVolume],

                        (* No need to get sample volume when spike is Null *)
                        MatchQ[spikeSample,Null],Null,

                        (* Default to 30Microliter to mix with spike *)
                        True,30Microliter
                    ];

                    (* Resolve spikeVolume *)
                    spikeVolume=Which[

                        (* Keep user-defined value *)
                        !MatchQ[Lookup[myMapThreadOptions,SpikeVolume],Automatic],Lookup[myMapThreadOptions,SpikeVolume],

                        (* No spike volume when spike is Null *)
                        MatchQ[spikeSample,Null],Null,

                        (* Default to sampleVolume to mix with the input sample *)
                        True,sampleVolume
                    ];

                    (* Resolve spikeConcentration using information from Composition Field *)
                    spikeConcentration=Which[

                        (* Keep user-defined value *)
                        !MatchQ[Lookup[myMapThreadOptions,SpikeConcentration],Automatic],Lookup[myMapThreadOptions,SpikeConcentration],

                        (* Set to Null if we don't have a spike *)
                        MatchQ[spikeSample,Null]||MatchQ[spikePacket,Null],Null,

                        (* If we don't have a customizable cartridge, we can try to find the concentration from its composition field. This can be an empty list *)
                        True,
						Map[
							Function[
								{comp},
								{First[comp],Download[Last[comp],Object,Cache->simulatedCache]}
							],
							Select[Lookup[spikePacket,Composition,{}],MatchQ[#,{Except[Null],ObjectP[analyteMolecule]}]&]
						]


                    ]/.{}->Null;

                    (* Set error tracking boolean to True if we cannot figure out spikeConcentration *)
					incompleteResolvedSpikeConcentrationError=If[MatchQ[spikeConcentration,{}|Null]&&!MatchQ[spikeSample,Null],
                        True,
                        False
                    ];
                    
                    (* Resolve dilutionCurve and serialDilutionCurve *)
                    {dilutionCurve,serialDilutionCurve}=Switch[Lookup[myMapThreadOptions,{DilutionCurve,SerialDilutionCurve}],

                        (* If neither is not automatic, keep user-defined values *)
                        {Except[Automatic],Except[Automatic]},Lookup[myMapThreadOptions,{DilutionCurve,SerialDilutionCurve}],

                        (* If one is automatic and the other one is not, set the other one to Null *)
                        {Except[Automatic|Null],Automatic},{Lookup[myMapThreadOptions,DilutionCurve],Null},
                        {Automatic,Except[Automatic|Null]},{Null,Lookup[myMapThreadOptions,SerialDilutionCurve]},

                        (* If one is automatic with the other one set to Null, go with dilution curve to get 1 sample with minimum dilution factor *)
                        {Automatic,Automatic|Null},{{{60Microliter,bestMinDilutionFactor}},Null},

						{Null,Automatic},{Null,{60Microliter,{bestMinDilutionFactor,1}}}

                    ];

					(* Find the most concentrated dilution factor to check that minimum dilution factor is fulfilled. *)
					nonOptimalDilutionWarning=If[NullQ[findMostConcentrationDilutionFactor[dilutionCurve,serialDilutionCurve]],
						False,
						TrueQ[findMostConcentrationDilutionFactor[dilutionCurve,serialDilutionCurve]>bestMinDilutionFactor]
					];

                    (* Resolve diluent *)
                    diluent=Which[

                        (* Keep user-defined value *)
                        !MatchQ[Lookup[myMapThreadOptions,Diluent],Automatic],Lookup[myMapThreadOptions,Diluent],
                        
                        (* Otherwise we can go with the common diluent for the cartridge*)
                        True,bestDiluent
                    ];

					(* Get the minimum diluted sample volume to decide the DilutionMixVolume. They are no longer Automatic so we can default to 0 Microliter. We also limit it to 970 Microliter to make sure the volume does not exceed the largest tip volume on the liquid handler. *)
					bestDilutionMixVolume=SafeRound[Min[0.5*resolveMinDilutedSamplePreparationVolume[dilutionCurve,serialDilutionCurve,0Microliter],970Microliter],10^-1Microliter];

					(* Resolve DilutionMixVolume *)
					dilutionMixVolume=userDefinedOrDefault[Lookup[myMapThreadOptions,{DilutionMixVolume}],{bestDilutionMixVolume}][[1]];

					(* DilutionNumberOfMixes, DilutionMixRate, DilutionStorageCondition and LoadingVolume are not Automatic options *)

					(* MasterSwitch inside MasterSwitch - CaptureAntibody options and DetectionAntibody options *)
					(* Here we need to enter our MasterSwitch, if the cartridge is not customizable, we can easily set all antibody related options to Null. Otherwise we need to go into them. I still do them one by one to avoid opening another huge Module. *)
					{customCaptureAntibody,customDetectionAntibody,captureAntibodyAssayTypeWarning,detectionAntibodyAssayTypeWarning,conflictAntibodyEpitopeWarning}=Which[

						(* Directly set antibody information to Null and epitope conflicting error to whether we get the same antibody sample - guaranteed same epitopes when the cartridge is not customizable *)
						(* If Analytes is provided by the user, it may not be correctly handled in the mapthread expansion. We can get the first member of the list *)
						!resolvedCustomizableCartridgeQ||NullQ[FirstOrDefault[ToList[analyte]]],
						Join[
							userDefinedOrDefault[Lookup[myMapThreadOptions,{CustomCaptureAntibody,CustomDetectionAntibody}],Null],
							{False,False,MatchQ[Lookup[myMapThreadOptions,CustomCaptureAntibody],ObjectP[Lookup[myMapThreadOptions,CustomDetectionAntibody]]]&&!NullQ[Lookup[myMapThreadOptions,CustomCaptureAntibody]]}
						],

						(* Otherwise we call our big helper function to resolve the antibody pair. It also returns epitope conflicting information. We will check whether we are able to resolve both capture antibody and detection antibody in the following step. *)
						True,findAntibodyPairs[FirstOrDefault[ToList[analyteMolecule]],Lookup[myMapThreadOptions,CustomCaptureAntibody],Lookup[myMapThreadOptions,CustomDetectionAntibody],Cache->simulatedCache]
					];

					(* If we cannot resolve any of the antibody, we are going to return errors *)
					{missingCaptureAntibodyError,missingDetectionAntibodyError}=If[resolvedCustomizableCartridgeQ,
						{MatchQ[customCaptureAntibody,Null],MatchQ[customDetectionAntibody,Null]},
						{False,False}
					];

					(* For a single antibody Object[Sample], we want to avoid resolving the options to different values and lead to conflicts. We can check whether our resolved antibodies are members of objectSampleOptionValuesCollapsed. Then we can create a new MapThreadOption list. *)
					captureAntibodyNewRules=If[MemberQ[objectSampleOptionValuesCollapsed[[All,1]],customCaptureAntibody],
						Association[
							MapThread[
								(#1->#2)&,
								{{CaptureAntibodyResuspension,CaptureAntibodyResuspensionConcentration,CaptureAntibodyResuspensionDiluent,CaptureAntibodyStorageCondition,CaptureAntibodyConjugation,CaptureAntibodyVolume,DigoxigeninReagent,DigoxigeninReagentVolume,CaptureAntibodyConjugationBuffer,CaptureAntibodyConjugationBufferVolume,CaptureAntibodyConjugationContainer,CaptureAntibodyConjugationTime,CaptureAntibodyConjugationTemperature,CaptureAntibodyPurificationColumn,CaptureAntibodyColumnWashBuffer,CaptureAntibodyConjugationStorageCondition,CaptureAntibodyDilution,CaptureAntibodyTargetConcentration,CaptureAntibodyDiluent},Most[Rest[FirstCase[objectSampleOptionValuesCollapsed,{customCaptureAntibody,___}]]]}
							]
						],
						<||>
					];

					detectionAntibodyNewRules=If[MemberQ[objectSampleOptionValuesCollapsed[[All,1]],customDetectionAntibody],
						Association[
							MapThread[
								(#1->#2)&,
								{{DetectionAntibodyResuspension,DetectionAntibodyResuspensionConcentration,DetectionAntibodyResuspensionDiluent,DetectionAntibodyStorageCondition,DetectionAntibodyConjugation,DetectionAntibodyVolume,BiotinReagent,BiotinReagentVolume,DetectionAntibodyConjugationBuffer,DetectionAntibodyConjugationBufferVolume,DetectionAntibodyConjugationContainer,DetectionAntibodyConjugationTime,DetectionAntibodyConjugationTemperature,DetectionAntibodyPurificationColumn,DetectionAntibodyColumnWashBuffer,DetectionAntibodyConjugationStorageCondition,DetectionAntibodyDilution,DetectionAntibodyTargetConcentration,DetectionAntibodyDiluent},Most[Rest[FirstCase[objectSampleOptionValuesCollapsed,{customDetectionAntibody,___}]]]}
							]
						],
						<||>
					];

					(* Get the new Association so that we will not have a conflict *)
					processedMyMapThreadOptions=Join[myMapThreadOptions,captureAntibodyNewRules,detectionAntibodyNewRules];

					(* CaptureAntibody OPTIONS *)
					(* Get the packet of customCaptureAntibody *)
					captureAntibodyPacket=If[!MatchQ[customCaptureAntibody,Null],
						Experiment`Private`fetchPacketFromFastAssoc[customCaptureAntibody,simulatedFastAssoc],
						{}
					];

					(* Check the state of the capture antibody - Solid or Liquid *)
					captureAntibodyState=Lookup[captureAntibodyPacket,State,Null];

					(* Resolve captureAntibodyResuspension based on the State of the capture antibody sample *)
					captureAntibodyResuspension=Which[
						!MatchQ[Lookup[processedMyMapThreadOptions,CaptureAntibodyResuspension],Automatic],Lookup[processedMyMapThreadOptions,CaptureAntibodyResuspension],
						!resolvedCustomizableCartridgeQ,Null,
						missingCaptureAntibodyError,Null,
						MatchQ[captureAntibodyState,Solid],True,
						True,False
					];

					(* Depending on captureAntibodyResuspension, resolve other resuspension related options *)
					{captureAntibodyResuspensionConcentration,captureAntibodyResuspensionDiluent,captureAntibodyStorageCondition}=If[MatchQ[captureAntibodyResuspension,True]&&resolvedCustomizableCartridgeQ,

						(* If captureAntibodyResuspension is required, set to default values or keep user's values *)
						userDefinedOrDefault[Lookup[processedMyMapThreadOptions,{CaptureAntibodyResuspensionConcentration,CaptureAntibodyResuspensionDiluent,CaptureAntibodyStorageCondition}],{1Milligram/Milliliter,Model[Sample, StockSolution, "id:4pO6dMWvnA0X"],Freezer}], (* Model[Sample, StockSolution,"Filtered PBS, Sterile"] *)

						(* If captureAntibodyResuspension is not required, set to Null values or keep user's values with error already thrown *)
						userDefinedOrDefault[Lookup[processedMyMapThreadOptions,{CaptureAntibodyResuspensionConcentration,CaptureAntibodyResuspensionDiluent,CaptureAntibodyStorageCondition}],Null]
					];

					(* Find all identity models of the capture antibody *)
					captureAntibodyIdentityModels=Select[Lookup[captureAntibodyPacket,Composition,{}],MatchQ[#,{_,ObjectP[Model[Molecule,Protein,Antibody]]}]&];

					(* Get the concentration of the capture antibody *)
					captureAntibodyConcentration=Which[
						!MatchQ[captureAntibodyResuspensionConcentration,Null],captureAntibodyResuspensionConcentration,

						(* Use the concentration of the first antibody identity model *)
						MatchQ[captureAntibodyIdentityModels,{}],Null,

						MatchQ[captureAntibodyIdentityModels[[1]][[1]],GreaterEqualP[0Molar]|GreaterEqualP[0Microgram/Milliliter]],captureAntibodyIdentityModels[[1]][[1]],
						True,Null
					];

					(* Check the packet of the capture antibody for modification *)
					captureAntibodyIdentityModelPacket=If[!MatchQ[captureAntibodyIdentityModels,{}],
						Experiment`Private`fetchPacketFromFastAssoc[captureAntibodyIdentityModels[[1]][[2]],simulatedFastAssoc],
						<||>
					];

					(* Find all molecules of the identity models *)
					captureAntibodySecondaryAntibidies=Lookup[captureAntibodyIdentityModelPacket,SecondaryAntibodies,{}];

					(* Find all molecular weights of all identity models *)
          captureAntibodyMolecularWeights=DeleteCases[Map[
            Experiment`Private`fastAssocLookup[simulatedFastAssoc,#,{Object,MolecularWeight}]&,
            captureAntibodyIdentityModels[[All,2]]
          ],
          Null];

					(* Use the average molecular weight or 150000 Dalton for caculation *)
					captureAntibodyAverageMolecularWeight=If[MatchQ[captureAntibodyMolecularWeights,{}],
						150000Dalton,
						Mean[captureAntibodyMolecularWeights]
					];

					(* Check whether one of the targets is anti-digoxigenin *)
					captureAntibodyConjugatedQ=MemberQ[captureAntibodySecondaryAntibidies,ObjectP[Model[Molecule, Protein, Antibody, "id:E8zoYvN9m4aA"]]]; (* Model[Molecule, Protein, Antibody, "Anti-Digoxigenin Antibody"] *)

					(* Resolve captureAntibodyConjugation based on the composition of the capture antibody sample. We also check whether any of the resuspension values are set to Null or populated to help resolving the conjugation boolean*)
					captureAntibodyConjugation=Which[
						!MatchQ[Lookup[processedMyMapThreadOptions,CaptureAntibodyConjugation],Automatic],Lookup[processedMyMapThreadOptions,CaptureAntibodyConjugation],
						!resolvedCustomizableCartridgeQ,Null,
						missingCaptureAntibodyError,Null,
						(* Any of the conjugation options are set to not Null or Automatic - Set conjugation to True *)
						MemberQ[Lookup[processedMyMapThreadOptions,{CaptureAntibodyVolume,DigoxigeninReagent,DigoxigeninReagentVolume,CaptureAntibodyConjugationBuffer,CaptureAntibodyConjugationBufferVolume,CaptureAntibodyConjugationContainer,CaptureAntibodyConjugationTime,CaptureAntibodyConjugationTemperature,CaptureAntibodyPurificationColumn,CaptureAntibodyColumnWashBuffer,CaptureAntibodyConjugationStorageCondition}],Except[Null|Automatic]],True,

						(* Any of the conjugation options are set to Null - Set conjugation to False *)
						MemberQ[Lookup[processedMyMapThreadOptions,{CaptureAntibodyVolume,DigoxigeninReagent,DigoxigeninReagentVolume,CaptureAntibodyConjugationBuffer,CaptureAntibodyConjugationBufferVolume,CaptureAntibodyConjugationContainer,CaptureAntibodyConjugationTime,CaptureAntibodyConjugationTemperature,CaptureAntibodyPurificationColumn,CaptureAntibodyColumnWashBuffer,CaptureAntibodyConjugationStorageCondition}],Null],False,

						(* Otherwise just go with our resolved conjugation value *)
						True,!captureAntibodyConjugatedQ
					];

					(* Resolve CaptureAntibodyVolume and DigoxigeninReagent based on whether conjugation is required *)
					{captureAntibodyVolume,digoxigeninReagent}=If[MatchQ[captureAntibodyConjugation,True]&&resolvedCustomizableCartridgeQ,
						userDefinedOrDefault[Lookup[processedMyMapThreadOptions,{CaptureAntibodyVolume,DigoxigeninReagent}],{100Microliter,Model[Sample, StockSolution, "id:rea9jlRwZe9e"]}], (* Model[Sample, StockSolution, "Digoxigenin-NHS, 0.67 mg/mL in DMF"] *)
						userDefinedOrDefault[Lookup[processedMyMapThreadOptions,{CaptureAntibodyVolume,DigoxigeninReagent}],Null]
					];

					(* Get the packet of digoxigeninReagent *)
					digoxigeninReagentPacket=Experiment`Private`fetchPacketFromFastAssoc[digoxigeninReagent,simulatedFastAssoc];

					(* Get the composition of digoxigeninReagent with the one for Model[Molecule,"Digoxigenin NHS ester"]. We currently may not be able to search for another Digoxigenin modification molecule as its reaction mechanism may be completely different and the ratio must also be adjusted. *)
					digoxigeninReagentComposition=If[!MatchQ[digoxigeninReagentPacket,Null],
						Select[Lookup[digoxigeninReagentPacket,Composition,{}],MatchQ[#,{_,ObjectP[Model[Molecule, "id:KBL5Dvwx7eq7"]]}]&], (* Model[Molecule, "Digoxigenin NHS ester"] *)
						{}
					];

					(* Get the concentration of digoxigenin reagent from its composition *)
					digoxigeninReagentConcentration=If[!MatchQ[digoxigeninReagentComposition,{}],
						digoxigeninReagentComposition[[1,1]],
						Null
					];

					digoxigeninMoleculeMolecularWeight=Quantity[658.8, "Grams"/"Moles"]; (* Model[Molecule,"Digoxigenin NHS ester"] *)


					(* Resolve digoxigeninReagentVolume and set boolean error if we cannot resolve it *)
					{digoxigeninReagentVolume,missingDigoxigeninReagentVolumeError}=Which[
						!MatchQ[Lookup[processedMyMapThreadOptions,DigoxigeninReagentVolume],Automatic],{Lookup[processedMyMapThreadOptions,DigoxigeninReagentVolume],False},
						!resolvedCustomizableCartridgeQ,{Null,False},
						missingCaptureAntibodyError,{Null,False},
						!captureAntibodyConjugation,{Null,False},

						(* When the captureAntibodyConjugation is True but we cannot resolve captureAntibodyConcentration, we have to set digoxigeninReagentVolume to Null*)
						MatchQ[captureAntibodyConcentration,Null],{Null,True},

						(* When we cannot find digoxigeninReagentConcentration from its composition, we also have to set digoxigeninReagentVolume to Null *)
						MatchQ[digoxigeninReagentConcentration,Null],{Null,True},

						(* Otherwise we can set to 5:1 excess using the concentrations and captureAntibodyVolume by calling the helper function *)
						True,{SafeRound[calculateDigoxigeninVolume[captureAntibodyAverageMolecularWeight,digoxigeninMoleculeMolecularWeight,captureAntibodyVolume,captureAntibodyConcentration,digoxigeninReagentConcentration],10^-1Microliter],False}
					];

					(* We also want to check whether the volume of digoxigenin reagent is giving more conjugation reagent compared to antibodies. This check only happens when we have all the information required *)
					notEnoughDigoxigeninReagentVolumeWarning=Which[
						!captureAntibodyConjugation,False,
						MatchQ[captureAntibodyVolume,Null],False,
						MatchQ[captureAntibodyConcentration,Null],False,
						MatchQ[digoxigeninReagentVolume,Null],False,
						MatchQ[digoxigeninReagentConcentration,Null],False,
						True,TrueQ[calculateDigoxigeninVolume[captureAntibodyAverageMolecularWeight,digoxigeninMoleculeMolecularWeight,captureAntibodyVolume,captureAntibodyConcentration,digoxigeninReagentConcentration]/5>digoxigeninReagentVolume]
					];

					(* Resolve captureAntibodyConjugationBuffer *)
					captureAntibodyConjugationBuffer=Which[
						!MatchQ[Lookup[processedMyMapThreadOptions,CaptureAntibodyConjugationBuffer],Automatic],Lookup[processedMyMapThreadOptions,CaptureAntibodyConjugationBuffer],
						!resolvedCustomizableCartridgeQ,Null,
						!MatchQ[captureAntibodyConjugation,True],Null,
						MatchQ[captureAntibodyConjugation,True],Model[Sample, StockSolution, "id:1ZA60vL4PZbq"] (* Model[Sample,StockSolution,"Sodium bicarbonate working stock 75 mg/mL"] *)
					];


					(* Resolve captureAntibodyConjugationBufferVolume *)
					captureAntibodyConjugationBufferVolume=Which[
						!MatchQ[Lookup[processedMyMapThreadOptions,CaptureAntibodyConjugationBufferVolume],Automatic],Lookup[processedMyMapThreadOptions,CaptureAntibodyConjugationBufferVolume],
						!resolvedCustomizableCartridgeQ,Null,
						!MatchQ[captureAntibodyConjugation,True],Null,

						(* If the user has set captureAntibodyVolume to Null, we cannot resolve the volume of buffer. This error has been thrown during conflict option check. *)
						MatchQ[captureAntibodyVolume,Null],Null,

						(* If we cannot resolve digoxigeninReagentVolume or the user has set it to Null, we cannot resolve the volume of buffer. An error has been thrown earlier. *)
						MatchQ[digoxigeninReagentVolume,Null],Null,

						(* Otherwise we can set the volume of buffer to 1/9 of total volume of two reagents *)
						True,SafeRound[1/9*(captureAntibodyVolume+digoxigeninReagentVolume),10^-1Microliter]
					];

					(* Get the total volume to resolve the conjugation container *)
					totalCaptureAntibodyConjugationVolume=If[MemberQ[{captureAntibodyVolume,digoxigeninReagentVolume,captureAntibodyConjugationBufferVolume},Null],
						(* Use 0 Microliter if we cannot resolve any of the volumes *)
						0Microliter,
						(captureAntibodyVolume+digoxigeninReagentVolume+captureAntibodyConjugationBufferVolume)
					];

					preferredCaptureAntibodyConjugationContainer=PreferredContainer[totalCaptureAntibodyConjugationVolume];

					(* Resolve other capture antibody conjugation options *)
					{
						captureAntibodyConjugationContainer,
						captureAntibodyConjugationTime,
						captureAntibodyConjugationTemperature,
						captureAntibodyConjugationStorageCondition,
						captureAntibodyColumnWashBuffer
					}=If[MatchQ[captureAntibodyConjugation,True]&&resolvedCustomizableCartridgeQ,

						(* Set default values when conjugation is needed *)
						userDefinedOrDefault[
							Lookup[
								processedMyMapThreadOptions,
								{
									CaptureAntibodyConjugationContainer,
									CaptureAntibodyConjugationTime,
									CaptureAntibodyConjugationTemperature,
									CaptureAntibodyConjugationStorageCondition,
									CaptureAntibodyColumnWashBuffer
								}
							],
							{preferredCaptureAntibodyConjugationContainer,1Hour,Ambient,Refrigerator,Model[Sample, StockSolution, "id:4pO6dMWvnA0X"]} (* Model[Sample,StockSolution,"Filtered PBS, Sterile"] *)
						],

						(* Set to Null when conjugation is not needed *)
						userDefinedOrDefault[
							Lookup[
								processedMyMapThreadOptions,
								{
									CaptureAntibodyConjugationContainer,
									CaptureAntibodyConjugationTime,
									CaptureAntibodyConjugationTemperature,
									CaptureAntibodyConjugationStorageCondition,
									CaptureAntibodyColumnWashBuffer
								}
							],
							Null
						]
					];

					(* Resolve captureAntibodyPurificationColumn and all purification related options *)
					(* Decide the preferred purification column using the provided volumes *)
					preferredCaptureAntibodyPurificationColumn=Which[
						!resolvedCustomizableCartridgeQ,Null,
						!MatchQ[captureAntibodyConjugation,True],Null,

						(* If the user has set captureAntibodyVolume to Null, we cannot resolve the total volume of the conjugation reaction. This error has been thrown during conflict option check. *)
						MatchQ[captureAntibodyVolume,Null],Null,

						(* If we cannot resolve digoxigeninReagentVolume or the user has set it to Null, we cannot resolve the total volume of the conjugation reaction. *)
						MatchQ[digoxigeninReagentVolume,Null],Null,

						(* If we cannot resolve captureAntibodyConjugationBufferVolume or the user has set it to Null, we cannot resolve the total volume of the conjugation reaction. *)
						MatchQ[captureAntibodyConjugationBufferVolume,Null],Null,

						(* Otherwise we can get the total volume and decide the purification column to use *)
						True,
						First[
							FirstOrDefault[
								Select[
									sorted40KSpinColumnsWithMaxVolumes,
									Last[#]>=(totalCaptureAntibodyConjugationVolume+100Microliter)&
								],
								(* Get a default if the volume is too large but it should not happen *)
								Last[sorted40KSpinColumnsWithMaxVolumes]
							]
						]
					];
					captureAntibodyPurificationColumn=If[!MatchQ[Lookup[processedMyMapThreadOptions,CaptureAntibodyPurificationColumn],Automatic],
						Lookup[processedMyMapThreadOptions,CaptureAntibodyPurificationColumn],
						preferredCaptureAntibodyPurificationColumn
					];

					(* We want to check whether the volume of the conjugation reaction is above the MaxVolume of any containers - conjugation container, purification colume and storage container *)
					captureAntibodyConjugationContainerPacket=Experiment`Private`fetchPacketFromFastAssoc[captureAntibodyConjugationContainer,simulatedFastAssoc];
					captureAntibodyConjugationContainerMaxVolume=If[MatchQ[captureAntibodyConjugationContainerPacket,Null],
						Infinity*Microliter,
						Lookup[captureAntibodyConjugationContainerPacket,MaxVolume,Infinity*Microliter]
					];
					exceedCaptureAntibodyConjugationContainerError=Which[
						MatchQ[captureAntibodyVolume,Null],False,
						MatchQ[digoxigeninReagentVolume,Null],False,
						MatchQ[captureAntibodyConjugationBufferVolume,Null],False,
						True,TrueQ[totalCaptureAntibodyConjugationVolume>captureAntibodyConjugationContainerMaxVolume]
					];

					(* Get the packet with purification column information *)
					captureAntibodyPurificationColumnPacket=Experiment`Private`fetchPacketFromFastAssoc[captureAntibodyPurificationColumn,simulatedFastAssoc];

					(* Get the model of the purification column *)
					captureAntibodyPurificationColumnModel=Which[
						MatchQ[captureAntibodyPurificationColumn,ObjectP[Model[Container,Vessel,Filter]]],captureAntibodyPurificationColumn,
						MatchQ[captureAntibodyPurificationColumn,ObjectP[Model[Container,Vessel,Filter]]],Lookup[captureAntibodyPurificationColumnPacket,Model,Null],
						True,Null
					];

					(* Get the MaxVolume of purification column *)
					captureAntibodyPurificationColumnMaxVolume=If[NullQ[captureAntibodyPurificationColumnModel],
						Infinity*Microliter,
						Lookup[
							Experiment`Private`fetchPacketFromFastAssoc[captureAntibodyPurificationColumnModel,simulatedFastAssoc],
							MaxVolume,
							Infinity*Microliter
						]
					];
					exceedCaptureAntibodyPurificationColumnError=Which[
						MatchQ[captureAntibodyVolume,Null],False,
						MatchQ[digoxigeninReagentVolume,Null],False,
						MatchQ[captureAntibodyConjugationBufferVolume,Null],False,
						True,TrueQ[totalCaptureAntibodyConjugationVolume>(captureAntibodyPurificationColumnMaxVolume-100Microliter)]
					];

					(* Resolve captureAntibodyDilution. *)
					(* First we can convert the captureAntibodyConcentration into mass concentration *)

					captureAntibodyMassConcentration=If[MatchQ[captureAntibodyConcentration,GreaterEqualP[0Molar]],
						captureAntibodyConcentration*captureAntibodyAverageMolecularWeight,
						captureAntibodyConcentration
					];


					(* Check the concentration of the standard capture antibody sample to decide whether to dilute *)
					captureAntibodyDilution=Which[
						!MatchQ[Lookup[processedMyMapThreadOptions,CaptureAntibodyDilution],Automatic],Lookup[processedMyMapThreadOptions,CaptureAntibodyDilution],
						!resolvedCustomizableCartridgeQ,Null,
						missingCaptureAntibodyError,Null,

						(* Any of the dilution options are set to not Null or Automatic - Set dilution to True *)
						MemberQ[Lookup[processedMyMapThreadOptions,{CaptureAntibodyTargetConcentration,CaptureAntibodyDiluent}],Except[Null|Automatic]],True,
						(* Any of the dilution options are set to Null - Set conjugation to False *)
						MemberQ[Lookup[processedMyMapThreadOptions,{CaptureAntibodyTargetConcentration,CaptureAntibodyDiluent}],Null],False,


						(* If we find a concentration for the standard capture antibody sample and it's over 5 Microgram/Milliliter, we dilute it *)
						TrueQ[captureAntibodyMassConcentration>5Microgram/Milliliter],True,

						(* If we cannot find a concentration but a bioconjugation is performed, we also dilute it *)
						MatchQ[captureAntibodyConcentration,Null]&&MatchQ[captureAntibodyConjugation,True],True,

						(* Otherwise we keep the sample and do not dilute it *)
						True,False
					];

					captureAntibodyTargetConcentration=Which[
						!MatchQ[Lookup[processedMyMapThreadOptions,CaptureAntibodyTargetConcentration],Automatic],Lookup[processedMyMapThreadOptions,CaptureAntibodyTargetConcentration],
						!resolvedCustomizableCartridgeQ,Null,
						missingCaptureAntibodyError,Null,
						!MatchQ[captureAntibodyDilution,True],Null,

						(* If we find a concentration for the standard capture antibody sample and it's below 3.5 Microgram/Milliliter, we set the target concentration to 1/2 of its original concentration *)
						(* This is a randomly selected number to cover the loss of conjugation/purification - Typically a Zeba spin column has a recovery % of over 80% *)
						TrueQ[captureAntibodyMassConcentration<=3.5Microgram/Milliliter],captureAntibodyConcentration/2,

						(* Otherwise we dilute to 3.5 Microgram/Milliliter *)
						True,3.5 Microgram/Milliliter
					];

					(* Here we add two checks to make sure the dilution is valid. We use the resuspension concentration with an estimated loss to 50% during conjugation and purification - this covers the dilution from conjugation reaction and also the loss from spin column *)
					(* Convert captureAntibodyTargetConcentration into mass concentration *)
					captureAntibodyTargetMassConcentration=If[MatchQ[captureAntibodyTargetConcentration,GreaterEqualP[0Molar]],
						captureAntibodyTargetConcentration*captureAntibodyAverageMolecularWeight,
						captureAntibodyTargetConcentration
					];

					invalidCaptureAntibodyDilutionError=Which[
						!MatchQ[captureAntibodyTargetConcentration,GreaterEqualP[0Microgram/Milliliter]|GreaterEqualP[0Molar]],False,

						(* Comment out the estimation of conjguation loss *)
						(*
						(* We get both concentrations in the same units but conjugation set as True *)
						MatchQ[captureAntibodyTargetMassConcentration,GreaterEqualP[0Microgram/Milliliter]]&&MatchQ[captureAntibodyMassConcentration,GreaterEqualP[0Milligram/Milliliter]]&&MatchQ[captureAntibodyConjugation,True],
						TrueQ[captureAntibodyTargetMassConcentration>0.5*captureAntibodyMassConcentration],
						*)

						(* DilutionTargetConcentration should not be larger than Resuspension Concentration *)
						MatchQ[captureAntibodyTargetMassConcentration,GreaterEqualP[0Microgram/Milliliter]]&&MatchQ[captureAntibodyMassConcentration,GreaterEqualP[0Milligram/Milliliter]],
						TrueQ[captureAntibodyTargetMassConcentration>captureAntibodyMassConcentration],

						True,False
					];

					(* A warning can be thrown for setting a concentration that is too high for capillary ELISA experiment *)
					nonOptimalCaptureAntibodyDilutionWarning=If[MatchQ[captureAntibodyTargetMassConcentration,GreaterEqualP[0Microgram/Milliliter]],
						TrueQ[captureAntibodyTargetMassConcentration>50Microgram/Milliliter],
						False
					];

					(* Resolve captureAntibodyDiluent *)
					captureAntibodyDiluent=If[MatchQ[captureAntibodyDilution,Except[True]]||!resolvedCustomizableCartridgeQ,
						userDefinedOrDefault[Lookup[processedMyMapThreadOptions,{CaptureAntibodyDiluent}],Null][[1]],
						userDefinedOrDefault[Lookup[processedMyMapThreadOptions,{CaptureAntibodyDiluent}],{Model[Sample, "id:pZx9jo8LZ7z5"]}][[1]] (* Model[Sample,"Simple Plex Reagent Diluent"] *)
					];


					(* Resolve captureAntibodyLoadingVolume - as long as we have a customizable cartridge, default to 50 Microliter. It doesn't matter whether we have resolved capture antibody or not *)
					captureAntibodyLoadingVolume=Which[
						MatchQ[Lookup[processedMyMapThreadOptions,CaptureAntibodyLoadingVolume],Except[Automatic]],Lookup[processedMyMapThreadOptions,CaptureAntibodyLoadingVolume],
						!resolvedCustomizableCartridgeQ,Null,
						True,50Microliter
					];
					

					(* DetectionAntibody OPTIONS *)
					(* Get the packet of customDetectionAntibody *)
					detectionAntibodyPacket=If[!MatchQ[customDetectionAntibody,Null],
						Experiment`Private`fetchPacketFromFastAssoc[customDetectionAntibody,simulatedFastAssoc],
						{}
					];

					(* Check the state of the detection antibody - Solid or Liquid *)
					detectionAntibodyState=Lookup[detectionAntibodyPacket,State,Null];

					(* Resolve detectionAntibodyResuspension based on the State of the detection antibody sample *)
					detectionAntibodyResuspension=Which[
						!MatchQ[Lookup[myMapThreadOptions,DetectionAntibodyResuspension],Automatic],Lookup[myMapThreadOptions,DetectionAntibodyResuspension],
						!resolvedCustomizableCartridgeQ,Null,
						missingDetectionAntibodyError,Null,
						MatchQ[detectionAntibodyState,Solid],True,
						True,False
					];

					(* Depending on detectionAntibodyResuspension, resolve other resuspension related options *)
					{detectionAntibodyResuspensionConcentration,detectionAntibodyResuspensionDiluent,detectionAntibodyStorageCondition}=If[MatchQ[detectionAntibodyResuspension,True]&&resolvedCustomizableCartridgeQ,

						(* If detectionAntibodyResuspension is required, set to default values or keep user's values *)
						userDefinedOrDefault[Lookup[processedMyMapThreadOptions,{DetectionAntibodyResuspensionConcentration,DetectionAntibodyResuspensionDiluent,DetectionAntibodyStorageCondition}],{1Milligram/Milliliter,Model[Sample, StockSolution, "id:4pO6dMWvnA0X"],Freezer}], (* Model[Sample, StockSolution,"Filtered PBS, Sterile"] *)

						(* If detectionAntibodyResuspension is not required, set to Null values or keep user's values with error already thrown *)
						userDefinedOrDefault[Lookup[processedMyMapThreadOptions,{DetectionAntibodyResuspensionConcentration,DetectionAntibodyResuspensionDiluent,DetectionAntibodyStorageCondition}],Null]
					];

					(* Find all identity models of the detection antibody *)
					detectionAntibodyIdentityModels=Select[Lookup[detectionAntibodyPacket,Composition,{}],MatchQ[#,{_,ObjectP[Model[Molecule,Protein,Antibody]]}]&];

					(* Get the concentration of the detection antibody *)
					detectionAntibodyConcentration=Which[
						!MatchQ[detectionAntibodyResuspensionConcentration,Null],detectionAntibodyResuspensionConcentration,

						(* Use the concentration of the first antibody identity model *)
						MatchQ[detectionAntibodyIdentityModels,{}],Null,

						MatchQ[detectionAntibodyIdentityModels[[1]][[1]],GreaterEqualP[0Molar]|GreaterEqualP[0Microgram/Milliliter]],detectionAntibodyIdentityModels[[1]][[1]],
						True,Null
					];

					(* Check the packet of the detection antibody for modification *)
					detectionAntibodyIdentityModelPacket=If[!MatchQ[detectionAntibodyIdentityModels,{}],
						Experiment`Private`fetchPacketFromFastAssoc[detectionAntibodyIdentityModels[[1]][[2]],simulatedFastAssoc],
						<||>
					];

					(* Find all molecules of the identity models *)
					detectionAntibodyTargets=Lookup[detectionAntibodyIdentityModelPacket,Targets,{}];

					(* Find all molecular weights of all identity models *)
          detectionAntibodyMolecularWeights=DeleteCases[
            Map[
              Experiment`Private`fastAssocLookup[simulatedFastAssoc,#,MolecularWeight]&,
              detectionAntibodyIdentityModels[[All,2]]
            ],
            Null
          ];

					(* Use the average molecular weight or 150000 Dalton for caculation *)
					detectionAntibodyAverageMolecularWeight=If[MatchQ[detectionAntibodyMolecularWeights,{}],
						150000Dalton,
						Mean[detectionAntibodyMolecularWeights]
					];

					(* Check whether one of the motifs is modification of biotin *)
					detectionAntibodyConjugatedQ=MemberQ[detectionAntibodyTargets,ObjectP[Model[Molecule, Protein, "id:4pO6dM507ZMz"]]]; (* Model[Molecule, Protein, "Streptavidin"] *)


					(* Resolve detectionAntibodyConjugation based on the composition of the detection antibody sample. We also check whether any of the resuspension values are set to Null or populated to help resolving the conjugation boolean*)
					detectionAntibodyConjugation=Which[
						!MatchQ[Lookup[processedMyMapThreadOptions,DetectionAntibodyConjugation],Automatic],Lookup[processedMyMapThreadOptions,DetectionAntibodyConjugation],
						!resolvedCustomizableCartridgeQ,Null,
						missingDetectionAntibodyError,Null,
						(* Any of the conjugation options are set to not Null or Automatic - Set conjugation to True *)
						MemberQ[Lookup[processedMyMapThreadOptions,{DetectionAntibodyVolume,BiotinReagent,BiotinReagentVolume,DetectionAntibodyConjugationBuffer,DetectionAntibodyConjugationBufferVolume,DetectionAntibodyConjugationContainer,DetectionAntibodyConjugationTime,DetectionAntibodyConjugationTemperature,DetectionAntibodyPurificationColumn,DetectionAntibodyColumnWashBuffer,DetectionAntibodyConjugationStorageCondition}],Except[Null|Automatic]],True,

						(* Any of the conjugation options are set to Null - Set conjugation to False *)
						MemberQ[Lookup[processedMyMapThreadOptions,{DetectionAntibodyVolume,BiotinReagent,BiotinReagentVolume,DetectionAntibodyConjugationBuffer,DetectionAntibodyConjugationBufferVolume,DetectionAntibodyConjugationContainer,DetectionAntibodyConjugationTime,DetectionAntibodyConjugationTemperature,DetectionAntibodyPurificationColumn,DetectionAntibodyColumnWashBuffer,DetectionAntibodyConjugationStorageCondition}],Null],False,

						(* Otherwise just go with our resolved conjugation value *)
						True,!detectionAntibodyConjugatedQ
					];

					(* Resolve detectionAntibodyVolume and biotinReagent based on whether conjugation is required *)
					{detectionAntibodyVolume,biotinReagent}=If[MatchQ[detectionAntibodyConjugation,True]&&resolvedCustomizableCartridgeQ,
						userDefinedOrDefault[Lookup[processedMyMapThreadOptions,{DetectionAntibodyVolume,BiotinReagent}],{100Microliter,Model[Sample, StockSolution, "id:bq9LA0JWaP8r"]}], (* Model[Sample,StockSolution,"Biotin-XX, 1 mg/mL in DMSO"] *)
						userDefinedOrDefault[Lookup[processedMyMapThreadOptions,{DetectionAntibodyVolume,BiotinReagent}],Null]
					];

					(* Get the packet of biotinReagent *)
					biotinReagentPacket=Experiment`Private`fetchPacketFromFastAssoc[biotinReagent,simulatedFastAssoc];

					(* Get the composition of biotinReagent with the one for Model[Molecule,"Biotinamidohexanoyl-6-aminohexanoic acid N-hydroxysuccinimide ester"]. We currently may not be able to search for another Biotin modification molecule as its reaction mechanism may be completely different and the ratio must also be adjusted. *)
					biotinReagentComposition=If[!MatchQ[biotinReagentPacket,Null],
						Select[Lookup[biotinReagentPacket,Composition,{}],MatchQ[#,{_,ObjectP[Model[Molecule, "id:1ZA60vLKWYD8"]]}]&], (* Model[Molecule,"Biotinamidohexanoyl-6-aminohexanoic acid N-hydroxysuccinimide ester"] *)
						{}
					];

					(* Get the concentration of biotin reagent from its composition *)
					biotinReagentConcentration=If[!MatchQ[biotinReagentComposition,{}],
						biotinReagentComposition[[1,1]],
						Null
					];

					biotinMoleculeMolecularWeight=Quantity[567.7, "Grams"/"Moles"]; (* Model[Molecule,"Biotinamidohexanoyl-6-aminohexanoic acid N-hydroxysuccinimide ester"] *)


					(* Resolve biotinReagentVolume and set boolean error if we cannot resolve it *)
					{biotinReagentVolume,missingBiotinReagentVolumeError}=Which[
						!MatchQ[Lookup[processedMyMapThreadOptions,BiotinReagentVolume],Automatic],{Lookup[processedMyMapThreadOptions,BiotinReagentVolume],False},
						!resolvedCustomizableCartridgeQ,{Null,False},
						missingDetectionAntibodyError,{Null,False},
						!detectionAntibodyConjugation,{Null,False},

						(* When the detectionAntibodyConjugation is True but we cannot resolve detectionAntibodyConcentration, we have to set biotinReagentVolume to Null*)
						MatchQ[detectionAntibodyConcentration,Null],{Null,True},

						(* When we cannot find biotinReagentConcentration from its composition, we also have to set biotinReagentVolume to Null *)
						MatchQ[biotinReagentConcentration,Null],{Null,True},

						(* Otherwise we can set to 5:1 excess using the concentrations and detectionAntibodyVolume by calling the helper function *)
						True,{SafeRound[calculateBiotinVolume[detectionAntibodyAverageMolecularWeight,biotinMoleculeMolecularWeight,detectionAntibodyVolume,detectionAntibodyConcentration,biotinReagentConcentration],10^-1Microliter],False}
					];

					(* We also want to check whether the volume of biotin reagent is giving more conjugation reagent compared to antibodies. This check only happens when we have all the information required *)
					notEnoughBiotinReagentVolumeWarning=Which[
						!detectionAntibodyConjugation,False,
						MatchQ[detectionAntibodyVolume,Null],False,
						MatchQ[detectionAntibodyConcentration,Null],False,
						MatchQ[biotinReagentVolume,Null],False,
						MatchQ[biotinReagentConcentration,Null],False,
						True,TrueQ[calculateBiotinVolume[detectionAntibodyAverageMolecularWeight,biotinMoleculeMolecularWeight,detectionAntibodyVolume,detectionAntibodyConcentration,biotinReagentConcentration]/10>biotinReagentVolume]
					];

					(* Resolve detectionAntibodyConjugationBuffer *)
					detectionAntibodyConjugationBuffer=Which[
						!MatchQ[Lookup[processedMyMapThreadOptions,DetectionAntibodyConjugationBuffer],Automatic],Lookup[processedMyMapThreadOptions,DetectionAntibodyConjugationBuffer],
						!resolvedCustomizableCartridgeQ,Null,
						!MatchQ[detectionAntibodyConjugation,True],Null,
						MatchQ[detectionAntibodyConjugation,True],Model[Sample, StockSolution, "id:1ZA60vL4PZbq"] (* Model[Sample,StockSolution,"Sodium bicarbonate working stock 75 mg/mL"] *)
					];


					(* Resolve detectionAntibodyConjugationBufferVolume *)
					detectionAntibodyConjugationBufferVolume=Which[
						!MatchQ[Lookup[processedMyMapThreadOptions,DetectionAntibodyConjugationBufferVolume],Automatic],Lookup[processedMyMapThreadOptions,DetectionAntibodyConjugationBufferVolume],
						!resolvedCustomizableCartridgeQ,Null,
						!MatchQ[detectionAntibodyConjugation,True],Null,

						(* If the user has set detectionAntibodyVolume to Null, we cannot resolve the volume of buffer. This error has been thrown during conflict option check. *)
						MatchQ[detectionAntibodyVolume,Null],Null,

						(* If we cannot resolve biotinReagentVolume or the user has set it to Null, we cannot resolve the volume of buffer. An error has been thrown earlier. *)
						MatchQ[biotinReagentVolume,Null],Null,

						(* Otherwise we can set the volume of buffer to 1/9 of total volume of two reagents *)
						True,SafeRound[1/9*(detectionAntibodyVolume+biotinReagentVolume),10^-1Microliter]
					];


					(* Get the total volume to resolve the conjugation container *)
					totalDetectionAntibodyConjugationVolume=If[MemberQ[{detectionAntibodyVolume,biotinReagentVolume,detectionAntibodyConjugationBufferVolume},Null],
						(* Use 0 Microliter if we cannot resolve any of the volumes *)
						0Microliter,
						(detectionAntibodyVolume+biotinReagentVolume+detectionAntibodyConjugationBufferVolume)
					];

					preferredDetectionAntibodyConjugationContainer=PreferredContainer[totalDetectionAntibodyConjugationVolume];

					(* Resolve other detection antibody conjugation options *)
					{
						detectionAntibodyConjugationContainer,
						detectionAntibodyConjugationTime,
						detectionAntibodyConjugationTemperature,
						detectionAntibodyConjugationStorageCondition,
						detectionAntibodyColumnWashBuffer
					}=If[MatchQ[detectionAntibodyConjugation,True]&&resolvedCustomizableCartridgeQ,

						(* Set default values when conjugation is needed *)
						userDefinedOrDefault[
							Lookup[
								processedMyMapThreadOptions,
								{
									DetectionAntibodyConjugationContainer,
									DetectionAntibodyConjugationTime,
									DetectionAntibodyConjugationTemperature,
									DetectionAntibodyConjugationStorageCondition,
									DetectionAntibodyColumnWashBuffer
								}
							],
							{preferredDetectionAntibodyConjugationContainer,1Hour,Ambient,Refrigerator,Model[Sample, StockSolution, "id:4pO6dMWvnA0X"]} (* Model[Sample,StockSolution,"Filtered PBS, Sterile"] *)
						],

						(* Set to Null when conjugation is not needed *)
						userDefinedOrDefault[
							Lookup[
								processedMyMapThreadOptions,
								{
									DetectionAntibodyConjugationContainer,
									DetectionAntibodyConjugationTime,
									DetectionAntibodyConjugationTemperature,
									DetectionAntibodyConjugationStorageCondition,
									DetectionAntibodyColumnWashBuffer
								}
							],
							Null
						]
					];

					(* Resolve detectionAntibodyPurificationColumn and all purification related options *)
					(* Decide the preferred purification column using the provided volumes *)
					preferredDetectionAntibodyPurificationColumn=Which[
						!resolvedCustomizableCartridgeQ,Null,
						!MatchQ[detectionAntibodyConjugation,True],Null,

						(* If the user has set detectionAntibodyVolume to Null, we cannot resolve the total volume of the conjugation reaction. This error has been thrown during conflict option check. *)
						MatchQ[detectionAntibodyVolume,Null],Null,

						(* If we cannot resolve biotinReagentVolume or the user has set it to Null, we cannot resolve the total volume of the conjugation reaction. *)
						MatchQ[biotinReagentVolume,Null],Null,

						(* If we cannot resolve detectionAntibodyConjugationBufferVolume or the user has set it to Null, we cannot resolve the total volume of the conjugation reaction. *)
						MatchQ[detectionAntibodyConjugationBufferVolume,Null],Null,

						(* Otherwise we can get the total volume and decide the purification column to use *)
						True,
						First[
							FirstOrDefault[
								Select[
									sorted40KSpinColumnsWithMaxVolumes,
									Last[#]>=(totalDetectionAntibodyConjugationVolume+100Microliter)&
								],
								(* Get a default if the volume is too large but it should not happen *)
								Last[sorted40KSpinColumnsWithMaxVolumes]
							]
						]
					];

					detectionAntibodyPurificationColumn=If[!MatchQ[Lookup[processedMyMapThreadOptions,DetectionAntibodyPurificationColumn],Automatic],
						Lookup[processedMyMapThreadOptions,DetectionAntibodyPurificationColumn],
						preferredDetectionAntibodyPurificationColumn
					];

					(* We want to check whether the volume of the conjugation reaction is above the MaxVolume of any containers - conjugation container, purification colume and storage container *)
					detectionAntibodyConjugationContainerPacket=Experiment`Private`fetchPacketFromFastAssoc[detectionAntibodyConjugationContainer,simulatedFastAssoc];
					detectionAntibodyConjugationContainerMaxVolume=If[MatchQ[detectionAntibodyConjugationContainerPacket,Null],
						Infinity*Microliter,
						Lookup[detectionAntibodyConjugationContainerPacket,MaxVolume,Infinity*Microliter]
					];
					exceedDetectionAntibodyConjugationContainerError=Which[
						MatchQ[detectionAntibodyVolume,Null],False,
						MatchQ[biotinReagentVolume,Null],False,
						MatchQ[detectionAntibodyConjugationBufferVolume,Null],False,
						True,TrueQ[totalDetectionAntibodyConjugationVolume>detectionAntibodyConjugationContainerMaxVolume]
					];

					(* Get the packet with purification column information *)
					detectionAntibodyPurificationColumnPacket=Experiment`Private`fetchPacketFromFastAssoc[detectionAntibodyPurificationColumn,simulatedFastAssoc];

					(* Get the model of the purification column *)
					detectionAntibodyPurificationColumnModel=Which[
						MatchQ[detectionAntibodyPurificationColumn,ObjectP[Model[Container,Vessel,Filter]]],detectionAntibodyPurificationColumn,
						MatchQ[detectionAntibodyPurificationColumn,ObjectP[Model[Container,Vessel,Filter]]],Lookup[detectionAntibodyPurificationColumnPacket,Model,Null],
						True,Null
					];

					(* Get the MaxVolume of purification column *)
					detectionAntibodyPurificationColumnMaxVolume=If[NullQ[detectionAntibodyPurificationColumnModel],
						Infinity*Microliter,
						Lookup[
							Experiment`Private`fetchPacketFromFastAssoc[detectionAntibodyPurificationColumnModel,simulatedFastAssoc],
							MaxVolume,
							Infinity*Microliter
						]
					];
					exceedDetectionAntibodyPurificationColumnError=Which[
						MatchQ[detectionAntibodyVolume,Null],False,
						MatchQ[biotinReagentVolume,Null],False,
						MatchQ[detectionAntibodyConjugationBufferVolume,Null],False,
						True,TrueQ[totalDetectionAntibodyConjugationVolume>(detectionAntibodyPurificationColumnMaxVolume-100Microliter)]
					];

					(* Resolve detectionAntibodyDilution. *)
					(* First we can convert the detectionAntibodyConcentration into mass concentration *)

					detectionAntibodyMassConcentration=If[MatchQ[detectionAntibodyConcentration,GreaterEqualP[0Molar]],
						detectionAntibodyConcentration*detectionAntibodyAverageMolecularWeight,
						detectionAntibodyConcentration
					];

					(* Resolve detectionAntibodyDilution. Check the concentration of the detection antibody sample to decide whether to dilute *)
					detectionAntibodyDilution=Which[
						!MatchQ[Lookup[processedMyMapThreadOptions,DetectionAntibodyDilution],Automatic],Lookup[processedMyMapThreadOptions,DetectionAntibodyDilution],
						!resolvedCustomizableCartridgeQ,Null,
						missingDetectionAntibodyError,Null,

						(* Any of the dilution options are set to not Null or Automatic - Set dilution to True *)
						MemberQ[Lookup[processedMyMapThreadOptions,{DetectionAntibodyTargetConcentration,DetectionAntibodyDiluent}],Except[Null|Automatic]],True,
						(* Any of the conjugation options are set to Null - Set conjugation to False *)
						MemberQ[Lookup[processedMyMapThreadOptions,{DetectionAntibodyTargetConcentration,DetectionAntibodyDiluent}],Null],False,


						(* If we find a concentration for the standard detection antibody sample and it's over 5 Microgram/Milliliter, we dilute it *)
						TrueQ[detectionAntibodyMassConcentration>5Microgram/Milliliter],True,

						(* If we cannot find a concentration but a bioconjugation is performed, we also dilute it *)
						MatchQ[detectionAntibodyConcentration,Null]&&MatchQ[detectionAntibodyConjugation,True],True,

						(* Otherwise we keep the sample and do not dilute it *)
						True,False
					];

					detectionAntibodyTargetConcentration=Which[
						!MatchQ[Lookup[processedMyMapThreadOptions,DetectionAntibodyTargetConcentration],Automatic],Lookup[processedMyMapThreadOptions,DetectionAntibodyTargetConcentration],
						!resolvedCustomizableCartridgeQ,Null,
						missingDetectionAntibodyError,Null,
						!MatchQ[detectionAntibodyDilution,True],True,

						(* If we find a concentration for the standard detection antibody sample and it's below 3.5 Microgram/Milliliter, we set the target concentration to 1/2 of its original concentration *)
						(* This is a randomly selected number to cover the loss of conjugation/purification - Typically a Zeba spin column has a recovery % of over 80% *)
						TrueQ[detectionAntibodyMassConcentration<=3.5Microgram/Milliliter],detectionAntibodyConcentration/2,

						(* Otherwise we dilute to 3.5 Microgram/Milliliter *)
						True,3.5 Microgram/Milliliter
					];

					(* Here we add two checks to make sure the dilution is valid. We use the resuspension concentration with an estimated loss to 50% during conjugation and purification - this covers the dilution from conjugation reaction and also the loss from spin column *)
					(* Convert detectionAntibodyTargetConcentration into mass concentration *)
					detectionAntibodyTargetMassConcentration=If[MatchQ[detectionAntibodyTargetConcentration,GreaterEqualP[0Molar]],
						detectionAntibodyTargetConcentration*detectionAntibodyAverageMolecularWeight,
						detectionAntibodyTargetConcentration
					];

					invalidDetectionAntibodyDilutionError=Which[
						!MatchQ[detectionAntibodyTargetConcentration,GreaterEqualP[0Microgram/Milliliter]|GreaterEqualP[0Molar]],False,

						(* Comment out the estimation of conjguation loss *)
						(*
						(* We get both concentrations in the same units but conjugation set as True *)
						MatchQ[detectionAntibodyTargetMassConcentration,GreaterEqualP[0Microgram/Milliliter]]&&MatchQ[detectionAntibodyMassConcentration,GreaterEqualP[0Milligram/Milliliter]]&&MatchQ[detectionAntibodyConjugation,True],
						TrueQ[detectionAntibodyTargetMassConcentration>0.5*detectionAntibodyMassConcentration],
						*)

						(* DilutionTargetConcentration should not be larger than Resuspension Concentration *)
						MatchQ[detectionAntibodyTargetMassConcentration,GreaterEqualP[0Microgram/Milliliter]]&&MatchQ[detectionAntibodyMassConcentration,GreaterEqualP[0Milligram/Milliliter]],
						TrueQ[detectionAntibodyTargetMassConcentration>detectionAntibodyMassConcentration],

						True,False
					];

					(* A warning can be thrown for setting a concentration that is too high for capillary ELISA experiment *)
					nonOptimalDetectionAntibodyDilutionWarning=If[MatchQ[detectionAntibodyTargetMassConcentration,GreaterEqualP[0Microgram/Milliliter]],
						TrueQ[detectionAntibodyTargetMassConcentration>50Microgram/Milliliter],
						False
					];

					(* Resolve detectionAntibodyDiluent *)
					detectionAntibodyDiluent=If[MatchQ[detectionAntibodyDilution,Except[True]]||!resolvedCustomizableCartridgeQ,
						userDefinedOrDefault[Lookup[processedMyMapThreadOptions,{DetectionAntibodyDiluent}],Null][[1]],
						userDefinedOrDefault[Lookup[processedMyMapThreadOptions,{DetectionAntibodyDiluent}],{Model[Sample, "id:pZx9jo8LZ7z5"]}][[1]] (* Model[Sample,"Simple Plex Reagent Diluent"] *)
					];

					(* Resolve detectionAntibodyLoadingVolume - as long as we have a customizable cartridge, default to 50 Microliter. It doesn't matter whether we have resolved detection antibody or not *)
					detectionAntibodyLoadingVolume=Which[
						MatchQ[Lookup[processedMyMapThreadOptions,DetectionAntibodyLoadingVolume],Except[Automatic]],Lookup[processedMyMapThreadOptions,DetectionAntibodyLoadingVolume],
						!resolvedCustomizableCartridgeQ,Null,
						True,50Microliter
					];

                    (* We now have all the map thread options resolved and we are ready to return everything back *)
                    {
						analyte,
						sampleVolume,
						spikeVolume,
						dilutionCurve,
						serialDilutionCurve,
						diluent,
						dilutionMixVolume,
						customCaptureAntibody,
						captureAntibodyResuspension,
						captureAntibodyResuspensionConcentration,
						captureAntibodyResuspensionDiluent,
						captureAntibodyStorageCondition,
						captureAntibodyConjugation,
						captureAntibodyVolume,
						digoxigeninReagent,
						digoxigeninReagentVolume,
						captureAntibodyConjugationBuffer,
						captureAntibodyConjugationBufferVolume,
						captureAntibodyConjugationContainer,
						captureAntibodyConjugationTime,
						captureAntibodyConjugationTemperature,
						captureAntibodyPurificationColumn,
						captureAntibodyColumnWashBuffer,
						captureAntibodyConjugationStorageCondition,
						captureAntibodyDilution,
						captureAntibodyTargetConcentration,
						captureAntibodyDiluent,
						customDetectionAntibody,
						detectionAntibodyResuspension,
						detectionAntibodyResuspensionConcentration,
						detectionAntibodyResuspensionDiluent,
						detectionAntibodyStorageCondition,
						detectionAntibodyConjugation,
						detectionAntibodyVolume,
						biotinReagent,
						biotinReagentVolume,
						detectionAntibodyConjugationBuffer,
						detectionAntibodyConjugationBufferVolume,
						detectionAntibodyConjugationContainer,
						detectionAntibodyConjugationTime,
						detectionAntibodyConjugationTemperature,
						detectionAntibodyPurificationColumn,
						detectionAntibodyColumnWashBuffer,
						detectionAntibodyConjugationStorageCondition,
						detectionAntibodyDilution,
						detectionAntibodyTargetConcentration,
						detectionAntibodyDiluent,
						captureAntibodyLoadingVolume,
						detectionAntibodyLoadingVolume,
						spikeConcentration,
						incompleteResolvedSpikeConcentrationError,
						nonOptimalDilutionWarning,
						conflictAntibodyEpitopeWarning,
						captureAntibodyAssayTypeWarning,
						detectionAntibodyAssayTypeWarning,
						missingCaptureAntibodyError,
						missingDetectionAntibodyError,
						missingDigoxigeninReagentVolumeError,
						missingBiotinReagentVolumeError,
						notEnoughDigoxigeninReagentVolumeWarning,
						notEnoughBiotinReagentVolumeWarning,
						exceedCaptureAntibodyConjugationContainerError,
						exceedDetectionAntibodyConjugationContainerError,
						exceedCaptureAntibodyPurificationColumnError,
						exceedDetectionAntibodyPurificationColumnError,
						invalidCaptureAntibodyDilutionError,
						invalidDetectionAntibodyDilutionError,
						nonOptimalCaptureAntibodyDilutionWarning,
						nonOptimalDetectionAntibodyDilutionWarning,
						totalCaptureAntibodyConjugationVolume,
						captureAntibodyConjugationContainerMaxVolume,
						captureAntibodyPurificationColumnMaxVolume,
						preferredCaptureAntibodyPurificationColumn,
						totalDetectionAntibodyConjugationVolume,
						detectionAntibodyConjugationContainerMaxVolume,
						detectionAntibodyPurificationColumnMaxVolume,
						preferredDetectionAntibodyPurificationColumn
                    }
                ]
            ],
			(* MapThread on our samples and the map thread friendly options. I also transfer in the information about customizable analytes for the ease of antibody resolving. *)
			{simulatedSamples,resolvedCustomizableAnalytes,mapThreadFriendlyOptions}
        ]
    ];



    (*-- UNRESOLVABLE OPTION CHECKS --*)

	(* Check for non-optimal standard resuspension concentration warnings. Throw warning message for True members *)
	If[(Or@@nonOptimalStandardResuspensionWarnings)&&!MatchQ[$ECLApplication,Engine]&&messages,
		Message[Warning::NonOptimalStandardResuspensionConcentration,ObjectToString[PickList[ToList[resolvedStandard],nonOptimalStandardResuspensionWarnings],Cache->simulatedCache],ToString[PickList[standardUpperQuantitationLimits,nonOptimalStandardResuspensionWarnings]]],
		Nothing
	];

	(* Create the corresponding tests for non optimal standard resuspension concentration *)
	nonOptimalStandardResuspensionTests=If[gatherTests,
		Module[{failingTest,passingTest},

			passingTest=Which[
				MatchQ[resolvedStandard,{}|Null],
				Test["To achieve the best standard curve through sample manipulation of the standard samples, it is recommended to set the resuspension concentrations to 10 times of the Upper Limit of Quantitation of their analytes:",True,True],
				!MemberQ[nonOptimalStandardResuspensionWarnings,False],
				Nothing,
				True,
				Test["To achieve the best standard curve through sample manipulation of the standard samples "<>ObjectToString[PickList[ToList[resolvedStandard],nonOptimalStandardResuspensionWarnings,False],Cache->simulatedCache]<>", it is recommended to set the resuspension concentrations to 10 times of the Upper Limit of Quantitation of their analytes:",True,True]
			];

			failingTest=If[!MemberQ[nonOptimalStandardResuspensionWarnings,True],
				Nothing,
				Test["To achieve the best standard curve through sample manipulation of the standard samples "<>ObjectToString[PickList[ToList[resolvedStandard],nonOptimalStandardResuspensionWarnings],Cache->simulatedCache]<>", it is recommended to set the resuspension concentrations to 10 times of the Upper Limit of Quantitation of their analytes:",False,True]
			];

			{failingTest,passingTest}
		],
		{}
	];

	(* Check for incomplete resolved known concentration errors - in the cases where we cannot find the concentrations. Throw error message for True members *)
	incompleteResolvedStandardCompositionOption=If[(Or@@incompleteResolvedStandardCompositionErrors)&&messages,
		Message[Error::IncompleteResolvedStandardComposition,ObjectToString[PickList[ToList[resolvedStandard],incompleteResolvedStandardCompositionErrors],Cache->simulatedCache]];{StandardComposition},
		{}
	];

	(* Create the corresponding tests for incomplete known concentration errors *)
	incompleteResolvedStandardCompositionTests=If[gatherTests,
		Module[{failingTest,passingTest},

			passingTest=Which[
				MatchQ[resolvedStandard,{}|Null],
				Test["The StandardComposition of analytes of interest must be provided for standard samples to be used for data processing:",True,True],
				!MemberQ[incompleteResolvedStandardCompositionErrors,False],
				Nothing,
				True,
				Test["The StandardComposition of analytes of interest must be provided for standard samples "<>ObjectToString[PickList[ToList[resolvedStandard],incompleteResolvedStandardCompositionErrors,False],Cache->simulatedCache]<>" to be used for data processing:",True,True]
			];

			failingTest=If[!MemberQ[incompleteResolvedStandardCompositionErrors,True],
				Nothing,
				Test["The KnownConcentration of analytes of interest is provided for standard samples "<>ObjectToString[PickList[ToList[resolvedStandard],incompleteResolvedStandardCompositionErrors],Cache->simulatedCache]<>" to be used for data processing:",True,False]
			];

			{failingTest,passingTest}
		],
		{}
	];

	(* Check for non-optimal standard diluent warnings. Throw warning message for True members *)
	If[(Or@@nonOptimalStandardDiluentWarnings)&&!MatchQ[$ECLApplication,Engine]&&messages,
		Message[Warning::NonOptimalStandardDiluent,ObjectToString[PickList[ToList[resolvedStandard],nonOptimalStandardDiluentWarnings],Cache->simulatedCache],ObjectToString[bestDiluent,Cache->simulatedCache]],
		Nothing
	];

	(* Create the corresponding tests for non optimal standard diluent *)
	nonOptimalStandardDiluentTests=If[gatherTests,
		Module[{failingTest,passingTest},

			passingTest=Which[
				MatchQ[resolvedStandard,{}|Null],
				Test["The StandardDiluent option is kept as the preferred diluent of the cartridge to achieve the best ELISA results:",True,True],
				!MemberQ[nonOptimalStandardDiluentWarnings,False],
				Nothing,
				True,
				Test["The StandardDiluent option for the standard samples "<>ObjectToString[PickList[ToList[resolvedStandard],nonOptimalStandardDiluentWarnings,False],Cache->simulatedCache]<>" is kept as the preferred diluent "<>ObjectToString[bestDiluent,Cache->simulatedCache]<>" of the cartridge to achieve the best ELISA results:",True,True]
			];

			failingTest=If[!MemberQ[nonOptimalStandardDiluentWarnings,True],
				Nothing,
				Test["The StandardDiluent option for the standard samples "<>ObjectToString[PickList[ToList[resolvedStandard],nonOptimalStandardDiluentWarnings],Cache->simulatedCache]<>" is kept as the preferred diluent "<>ObjectToString[bestDiluent,Cache->simulatedCache]<>" of the cartridge to achieve the best ELISA results:",False,True]
			];

			{failingTest,passingTest}
		],
		{}
	];

	(* Check for conflicting epitope warnings. Throw warning message for True members *)
	If[(Or@@conflictStandardAntibodyEpitopeWarnings)&&!MatchQ[$ECLApplication,Engine]&&messages,
		Message[Warning::ConflictStandardAntibodyEpitopes,ObjectToString[PickList[ToList[resolvedStandard],conflictStandardAntibodyEpitopeWarnings],Cache->simulatedCache]],
		Nothing
	];

	(* Create the corresponding tests for conflict standard antibody epitopes *)
	conflictStandardAntibodyEpitopeTests=If[gatherTests,
		Module[{failingTest,passingTest},

			passingTest=Which[
				MatchQ[resolvedStandard,{}|Null]||!resolvedCustomizableCartridgeQ,
				Test["The StandardCaptureAntibody and StandardDetectionAntibody of the standard samples do not share the same binding epitopes on the analytes:",True,True],
				!MemberQ[conflictStandardAntibodyEpitopeWarnings,False],
				Nothing,
				True,
				Test["The StandardCaptureAntibody and StandardDetectionAntibody of the standard samples "<>ObjectToString[PickList[ToList[resolvedStandard],conflictStandardAntibodyEpitopeWarnings,False],Cache->simulatedCache]<>" do not share the same binding epitopes on the analytes:",True,True]
			];

			failingTest=If[!MemberQ[conflictStandardAntibodyEpitopeWarnings,True],
				Nothing,
				Test["The StandardCaptureAntibody and StandardDetectionAntibody of the standard samples "<>ObjectToString[PickList[ToList[resolvedStandard],conflictStandardAntibodyEpitopeWarnings],Cache->simulatedCache]<>" do not share the same binding epitopes on the analytes:",False,True]
			];

			{failingTest,passingTest}
		],
		{}
	];

	(* Check for missing ELISA AssayTypes for antibody samples. Throw warning message for True members. We combine all the antibody samples for the message and test *)
	antibodyAssayTypeDisQualified=DeleteDuplicates[
		DeleteCases[
			Join[
				If[MatchQ[resolvedStandard,{}|Null],
					{},
					PickList[resolvedStandardCaptureAntibody,standardCaptureAntibodyAssayTypeWarnings]
				],
				If[MatchQ[resolvedStandard,{}|Null],
					{},
					PickList[resolvedStandardDetectionAntibody,standardDetectionAntibodyAssayTypeWarnings]
				],
				PickList[resolvedCustomCaptureAntibody,captureAntibodyAssayTypeWarnings],
				PickList[resolvedCustomDetectionAntibody,detectionAntibodyAssayTypeWarnings]
			],
			Null
		]
	];

	antibodyAssayTypeQualified=DeleteDuplicates[
		DeleteCases[
			Join[
				If[MatchQ[resolvedStandard,{}|Null],
					{},
					PickList[resolvedStandardCaptureAntibody,standardCaptureAntibodyAssayTypeWarnings,False]
				],
				If[MatchQ[resolvedStandard,{}|Null],
					{},
					PickList[resolvedStandardDetectionAntibody,standardDetectionAntibodyAssayTypeWarnings,False]
				],
				PickList[resolvedCustomCaptureAntibody,captureAntibodyAssayTypeWarnings,False],
				PickList[resolvedCustomDetectionAntibody,detectionAntibodyAssayTypeWarnings,False]
			],
			Null
		]
	];

	If[!MatchQ[antibodyAssayTypeDisQualified,{}]&&!MatchQ[$ECLApplication,Engine]&&messages,
		Message[Warning::NoELISAAssayTypeForAntibodySamples,ObjectToString[antibodyAssayTypeDisQualified,Cache->simulatedCache]],
		Nothing
	];

	(* Create the corresponding tests for conflict standard antibody epitopes *)
	antibodyAssayTypeQualificationTests=If[gatherTests,
		Module[{failingTest,passingTest},

			passingTest=Which[
				!resolvedCustomizableCartridgeQ,
				Test["ELISA is a member of AssayTypes for the antibody samples:",True,True],
				MatchQ[antibodyAssayTypeQualified,{}],
				Nothing,
				True,
				Test["ELISA is not a member of AssayTypes for the antibody samples "<>ObjectToString[antibodyAssayTypeDisQualified,Cache->simulatedCache],True,True]
			];

			failingTest=If[MatchQ[antibodyAssayTypeDisQualified,{}],
				Nothing,
				Test["ELISA is not a member of AssayTypes for the antibody samples "<>ObjectToString[antibodyAssayTypeQualified,Cache->simulatedCache],False,True]
			];

			{failingTest,passingTest}
		],
		{}
	];


	(* Check for unresolved standard capture antibody errors. Throw error message for True members *)
	missingStandardCaptureAntibodyOptions=If[(Or@@missingStandardCaptureAntibodyErrors)&&messages,
		Message[Error::MustSpecifyStandardCaptureAntibody,ObjectToString[PickList[ToList[resolvedStandard],missingStandardCaptureAntibodyErrors],Cache->simulatedCache]];{StandardCaptureAntibody},
		{}
	];

	(* Create the corresponding tests for unresolved standard capture antibody errors *)
	missingStandardCaptureAntibodyTests=If[gatherTests,
		Module[{failingTest,passingTest},

			passingTest=Which[
				MatchQ[resolvedStandard,{}|Null]||!resolvedCustomizableCartridgeQ,
				Test["The StandardCaptureAntibody must be specified for the standard samples when the cartridge is customizable:",True,True],
				!MemberQ[missingStandardCaptureAntibodyErrors,False],
				Nothing,
				True,
				Test["The StandardCaptureAntibody must be specified for the standard samples "<>ObjectToString[PickList[ToList[resolvedStandard],missingStandardCaptureAntibodyErrors,False],Cache->simulatedCache]<>" when the cartridge is customizable:",True,True]
			];

			failingTest=If[!MemberQ[missingStandardCaptureAntibodyErrors,True],
				Nothing,
				Test["The StandardCaptureAntibody must be specified for the standard samples "<>ObjectToString[PickList[ToList[resolvedStandard],missingStandardCaptureAntibodyErrors],Cache->simulatedCache]<>" when the cartridge is customizable:",False,True]
			];

			{failingTest,passingTest}
		],
		{}
	];

	(* Check for unresolved standard detection antibody errors. Throw error message for True members *)
	missingStandardDetectionAntibodyOptions=If[(Or@@missingStandardDetectionAntibodyErrors)&&messages,
		Message[Error::MustSpecifyStandardDetectionAntibody,ObjectToString[PickList[ToList[resolvedStandard],missingStandardDetectionAntibodyErrors],Cache->simulatedCache]];{StandardDetectionAntibody},
		{}
	];

	(* Create the corresponding tests for unresolved standard detection antibody errors *)
	missingStandardDetectionAntibodyTests=If[gatherTests,
		Module[{failingTest,passingTest},

			passingTest=Which[
				MatchQ[resolvedStandard,{}|Null]||!resolvedCustomizableCartridgeQ,
				Test["The StandardDetectionAntibody must be specified for the standard samples when the cartridge is customizable:",True,True],
				!MemberQ[missingStandardDetectionAntibodyErrors,False],
				Nothing,
				True,
				Test["The StandardDetectionAntibody must be specified for the standard samples "<>ObjectToString[PickList[ToList[resolvedStandard],missingStandardDetectionAntibodyErrors,False],Cache->simulatedCache]<>" when the cartridge is customizable:",True,True]
			];

			failingTest=If[!MemberQ[missingStandardDetectionAntibodyErrors,True],
				Nothing,
				Test["The StandardDetectionAntibody must be specified for the standard samples "<>ObjectToString[PickList[ToList[resolvedStandard],missingStandardDetectionAntibodyErrors],Cache->simulatedCache]<>" when the cartridge is customizable:",False,True]
			];

			{failingTest,passingTest}
		],
		{}
	];

	(* Check for unresolved standard digoxigenin reagent volume errors. This can happen because of unresolvable antibody concentration or unresolvable digoxigenin-NHS concentration. Throw error message for True members *)
	missingStandardDigoxigeninReagentVolumeOptions=If[(Or@@missingStandardDigoxigeninReagentVolumeErrors)&&messages,
		Message[Error::MustSpecifyStandardDigoxigeninReagentVolume,ObjectToString[PickList[ToList[resolvedStandard],missingStandardDigoxigeninReagentVolumeErrors],Cache->simulatedCache]];{StandardDigoxigeninReagentVolume},
		{}
	];

	(* Create the corresponding tests for unresolved standard digoxigenin reagent volume errors *)
	missingStandardDigoxigeninReagentVolumeTests=If[gatherTests,
		Module[{failingTest,passingTest},

			passingTest=Which[
				MatchQ[resolvedStandard,{}|Null]||!resolvedCustomizableCartridgeQ,
				Test["The StandardDigoxigeninReagentVolume must be specified for the standard samples to perform bioconjugation when StandardCaptureAntibodyConjugation is True:",True,True],
				!MemberQ[missingStandardDigoxigeninReagentVolumeErrors,False],
				Nothing,
				True,
				Test["The StandardDigoxigeninReagentVolume must be specified for the standard samples "<>ObjectToString[PickList[ToList[resolvedStandard],missingStandardDigoxigeninReagentVolumeErrors,False],Cache->simulatedCache]<>" to perform bioconjugation when StandardCaptureAntibodyConjugation is True:",True,True]
			];

			failingTest=If[!MemberQ[missingStandardDigoxigeninReagentVolumeErrors,True],
				Nothing,
				Test["The StandardDigoxigeninReagentVolume must be specified for the standard samples "<>ObjectToString[PickList[ToList[resolvedStandard],missingStandardDigoxigeninReagentVolumeErrors],Cache->simulatedCache]<>" to perform bioconjugation when StandardCaptureAntibodyConjugation is True:",False,True]
			];

			{failingTest,passingTest}
		],
		{}
	];

	(* Check for unresolved standard biotin reagent volume errors. This can happen because of unresolvable antibody concentration or unresolvable biotin-XX concentration. Throw error message for True members *)
	missingStandardBiotinReagentVolumeOptions=If[(Or@@missingStandardBiotinReagentVolumeErrors)&&messages,
		Message[Error::MustSpecifyStandardBiotinReagentVolume,ObjectToString[PickList[ToList[resolvedStandard],missingStandardBiotinReagentVolumeErrors],Cache->simulatedCache]];{StandardBiotinReagentVolume},
		{}
	];

	(* Create the corresponding tests for unresolved standard biotin reagent volume errors *)
	missingStandardBiotinReagentVolumeTests=If[gatherTests,
		Module[{failingTest,passingTest},

			passingTest=Which[
				MatchQ[resolvedStandard,{}|Null]||!resolvedCustomizableCartridgeQ,
				Test["The StandardBiotinReagentVolume must be specified for the standard samples to perform bioconjugation when StandardCaptureAntibodyConjugation is True:",True,True],
				!MemberQ[missingStandardBiotinReagentVolumeErrors,False],
				Nothing,
				True,
				Test["The StandardBiotinReagentVolume must be specified for the standard samples "<>ObjectToString[PickList[ToList[resolvedStandard],missingStandardBiotinReagentVolumeErrors,False],Cache->simulatedCache]<>" to perform bioconjugation when StandardCaptureAntibodyConjugation is True:",True,True]
			];

			failingTest=If[!MemberQ[missingStandardBiotinReagentVolumeErrors,True],
				Nothing,
				Test["The StandardBiotinReagentVolume must be specified for the standard samples "<>ObjectToString[PickList[ToList[resolvedStandard],missingStandardBiotinReagentVolumeErrors],Cache->simulatedCache]<>" to perform bioconjugation when StandardCaptureAntibodyConjugation is True:",False,True]
			];

			{failingTest,passingTest}
		],
		{}
	];

	(* Check for not enough standard digoxigenin reagent volume. This happens when the amount of digoxigenin is less than amount of antibody. Throw warning message for True members *)
	If[(Or@@notEnoughStandardDigoxigeninReagentVolumeWarnings)&&!MatchQ[$ECLApplication,Engine]&&messages,
		Message[Warning::NotEnoughStandardDigoxigeninReagentVolume,ObjectToString[PickList[resolvedStandardCaptureAntibody,notEnoughStandardDigoxigeninReagentVolumeWarnings],Cache->simulatedCache],ObjectToString[PickList[ToList[resolvedStandard],notEnoughStandardDigoxigeninReagentVolumeWarnings],Cache->simulatedCache]],
		Nothing
	];

	(* Create the corresponding tests for not enough standard digoxigenin reagent volume errors *)
	notEnoughStandardDigoxigeninReagentVolumeTests=If[gatherTests,
		Module[{failingTest,passingTest},

			passingTest=Which[
				MatchQ[resolvedStandard,{}|Null]||!resolvedCustomizableCartridgeQ,
				Test["The StandardDigoxigeninReagentVolume should provide excess amount of digoxigenin reagent compared to StandardCaptureAntibody in the bioconjugation process to achieve the best conjugation efficiency for standard capture antibody samples:",True,True],
				!MemberQ[notEnoughStandardDigoxigeninReagentVolumeWarnings,False],
				Nothing,
				True,
				Test["The StandardDigoxigeninReagentVolume should provide excess amount of digoxigenin reagent compared to StandardCaptureAntibody in the bioconjugation process to achieve the best conjugation efficiency for standard capture antibody samples "<>ObjectToString[PickList[resolvedStandardCaptureAntibody,notEnoughStandardDigoxigeninReagentVolumeWarnings,False],Cache->simulatedCache]<>" used for ELISA experiment of "<>ObjectToString[PickList[ToList[resolvedStandard],notEnoughStandardDigoxigeninReagentVolumeWarnings,False],Cache->simulatedCache],True,True]
			];

			failingTest=If[!MemberQ[notEnoughStandardDigoxigeninReagentVolumeWarnings,True],
				Nothing,
				Test["The StandardDigoxigeninReagentVolume should provide excess amount of digoxigenin reagent compared to StandardCaptureAntibody in the bioconjugation process to achieve the best conjugation efficiency for standard capture antibody samples "<>ObjectToString[PickList[resolvedStandardCaptureAntibody,notEnoughStandardDigoxigeninReagentVolumeWarnings],Cache->simulatedCache]<>" used for ELISA experiment of "<>ObjectToString[PickList[ToList[resolvedStandard],notEnoughStandardDigoxigeninReagentVolumeWarnings],Cache->simulatedCache],False,True]
			];

			{failingTest,passingTest}
		],
		{}
	];

	(* Check for not enough standard biotin reagent volume. This happens when the amount of biotin is less than amount of antibody. Throw warning message for True members *)
	If[(Or@@notEnoughStandardBiotinReagentVolumeWarnings)&&!MatchQ[$ECLApplication,Engine]&&messages,
		Message[Warning::NotEnoughStandardBiotinReagentVolume,ObjectToString[PickList[resolvedStandardDetectionAntibody,notEnoughStandardBiotinReagentVolumeWarnings],Cache->simulatedCache],ObjectToString[PickList[ToList[resolvedStandard],notEnoughStandardBiotinReagentVolumeWarnings],Cache->simulatedCache]],
		Nothing
	];

	(* Create the corresponding tests for not enough standard biotin reagent volume errors *)
	notEnoughStandardBiotinReagentVolumeTests=If[gatherTests,
		Module[{failingTest,passingTest},

			passingTest=Which[
				MatchQ[resolvedStandard,{}|Null]||!resolvedCustomizableCartridgeQ,
				Test["The StandardBiotinReagentVolume should provide excess amount of biotin reagent compared to StandardDetectionAntibody in the bioconjugation process to achieve the best conjugation efficiency for standard detection antibody samples:",True,True],
				!MemberQ[notEnoughStandardBiotinReagentVolumeWarnings,False],
				Nothing,
				True,
				Test["The StandardBiotinReagentVolume should provide excess amount of biotin reagent compared to StandardDetectionAntibody in the bioconjugation process to achieve the best conjugation efficiency for standard detection antibody samples "<>ObjectToString[PickList[resolvedStandardDetectionAntibody,notEnoughStandardBiotinReagentVolumeWarnings,False],Cache->simulatedCache]<>" used for ELISA experiment of "<>ObjectToString[PickList[ToList[resolvedStandard],notEnoughStandardBiotinReagentVolumeWarnings,False],Cache->simulatedCache],True,True]
			];

			failingTest=If[!MemberQ[notEnoughStandardBiotinReagentVolumeWarnings,True],
				Nothing,
				Test["The StandardBiotinReagentVolume should provide excess amount of biotin reagent compared to StandardDetectionAntibody in the bioconjugation process to achieve the best conjugation efficiency for standard detection antibody samples "<>ObjectToString[PickList[resolvedStandardDetectionAntibody,notEnoughStandardBiotinReagentVolumeWarnings],Cache->simulatedCache]<>" used for ELISA experiment of "<>ObjectToString[PickList[ToList[resolvedStandard],notEnoughStandardBiotinReagentVolumeWarnings],Cache->simulatedCache],False,True]
			];

			{failingTest,passingTest}
		],
		{}
	];

	(* Check for the errors in cases that the total conjugation preparation volumes are over the MaxVolume of the conjugation container. Throw error message for True members *)
	preferredStandardCaptureAntibodyConjugationContainers=Map[
		PreferredContainer[#]&,
		standardCaptureAntibodyConjuationReactionVolumes
	];

	exceedStandardCaptureAntibodyConjugationContainerOption=If[(Or@@exceedStandardCaptureAntibodyConjugationContainerErrors)&&messages,
		Message[Error::ExceedStandardCaptureAntibodyConjugationContainerCapacity,
			ObjectToString[PickList[resolvedStandardCaptureAntibody,exceedStandardCaptureAntibodyConjugationContainerErrors],Cache->simulatedCache],
			ObjectToString[PickList[ToList[resolvedStandard],exceedStandardCaptureAntibodyConjugationContainerErrors],Cache->simulatedCache],
			ToString[PickList[standardCaptureAntibodyConjugationContainerMaxVolumes,exceedStandardCaptureAntibodyConjugationContainerErrors]],
			ToString[PickList[standardCaptureAntibodyConjuationReactionVolumes,exceedStandardCaptureAntibodyConjugationContainerErrors]],
			ObjectToString[preferredStandardCaptureAntibodyConjugationContainers,Cache->simulatedCache]
		];
		{StandardCaptureAntibodyConjugationContainer},
		{}
	];

	(* Create the corresponding tests for exceeding standard capture antibody conjugation container capacity errors *)
	exceedStandardCaptureAntibodyConjugationContainerTests=If[gatherTests,
		Module[{failingTest,passingTest},

			passingTest=Which[
				MatchQ[resolvedStandard,{}|Null]||!resolvedCustomizableCartridgeQ,
				Test["The MaxVolume of the specified StandardCaptureAntibodyConjugationContainer is larger than the total conjugation preparation volume of standard capture antibody samples:",True,True],
				!MemberQ[exceedStandardCaptureAntibodyConjugationContainerErrors,False],
				Nothing,
				True,
				Test["The MaxVolume of the specified StandardCaptureAntibodyConjugationContainer must be larger than the total conjugation preparation volume of standard capture antibody samples "<>ObjectToString[PickList[resolvedStandardCaptureAntibody,exceedStandardCaptureAntibodyConjugationContainerErrors,False],Cache->simulatedCache]<>", used for ELISA assay of "<>ObjectToString[PickList[ToList[resolvedStandard],exceedStandardCaptureAntibodyConjugationContainerErrors,False],Cache->simulatedCache],True,True]
			];

			failingTest=If[!MemberQ[exceedStandardCaptureAntibodyConjugationContainerErrors,True],
				Nothing,
				Test["The MaxVolume of the specified StandardCaptureAntibodyConjugationContainer must be larger than the total conjugation preparation volume of standard capture antibody samples "<>ObjectToString[PickList[resolvedStandardCaptureAntibody,exceedStandardCaptureAntibodyConjugationContainerErrors],Cache->simulatedCache]<>", used for ELISA assay of "<>ObjectToString[PickList[ToList[resolvedStandard],exceedStandardCaptureAntibodyConjugationContainerErrors],Cache->simulatedCache],False,True]
			];

			{failingTest,passingTest}
		],
		{}
	];

	(* Check for the errors in cases that the total conjugation preparation volumes are over the MaxVolume of the conjugation container. Throw error message for True members *)
	preferredStandardDetectionAntibodyConjugationContainers=Map[
		PreferredContainer[#]&,
		standardDetectionAntibodyConjuationReactionVolumes
	];

	exceedStandardDetectionAntibodyConjugationContainerOption=If[(Or@@exceedStandardDetectionAntibodyConjugationContainerErrors)&&messages,
		Message[Error::ExceedStandardDetectionAntibodyConjugationContainerCapacity,
			ObjectToString[PickList[resolvedStandardDetectionAntibody,exceedStandardDetectionAntibodyConjugationContainerErrors],Cache->simulatedCache],
			ObjectToString[PickList[ToList[resolvedStandard],exceedStandardDetectionAntibodyConjugationContainerErrors],Cache->simulatedCache],
			ToString[PickList[standardDetectionAntibodyConjugationContainerMaxVolumes,exceedStandardDetectionAntibodyConjugationContainerErrors]],
			ToString[PickList[standardDetectionAntibodyConjuationReactionVolumes,exceedStandardDetectionAntibodyConjugationContainerErrors]],
			ObjectToString[preferredStandardDetectionAntibodyConjugationContainers,Cache->simulatedCache]
		];
		{StandardDetectionAntibodyConjugationContainer},
		{}
	];

	(* Create the corresponding tests for exceeding standard detection antibody conjugation capacity errors *)
	exceedStandardDetectionAntibodyConjugationContainerTests=If[gatherTests,
		Module[{failingTest,passingTest},

			passingTest=Which[
				MatchQ[resolvedStandard,{}|Null]||!resolvedCustomizableCartridgeQ,
				Test["The MaxVolume of the specified StandardDetectionAntibodyConjugationContainer is larger than the total conjugation preparation volume of standard detection antibody samples:",True,True],
				!MemberQ[exceedStandardDetectionAntibodyConjugationContainerErrors,False],
				Nothing,
				True,
				Test["The MaxVolume of the specified StandardDetectionAntibodyConjugationContainer must be larger than the total conjugation preparation volume of standard detection antibody samples "<>ObjectToString[PickList[resolvedStandardDetectionAntibody,exceedStandardDetectionAntibodyConjugationContainerErrors,False],Cache->simulatedCache]<>", used for ELISA assay of "<>ObjectToString[PickList[ToList[resolvedStandard],exceedStandardDetectionAntibodyConjugationContainerErrors,False],Cache->simulatedCache],True,True]
			];

			failingTest=If[!MemberQ[exceedStandardDetectionAntibodyConjugationContainerErrors,True],
				Nothing,
				Test["The MaxVolume of the specified StandardDetectionAntibodyConjugationContainer must be larger than the total conjugation preparation volume of standard detection antibody samples "<>ObjectToString[PickList[resolvedStandardDetectionAntibody,exceedStandardDetectionAntibodyConjugationContainerErrors],Cache->simulatedCache]<>", used for ELISA assay of "<>ObjectToString[PickList[ToList[resolvedStandard],exceedStandardDetectionAntibodyConjugationContainerErrors],Cache->simulatedCache],False,True]
			];

			{failingTest,passingTest}
		],
		{}
	];

	(* Check for the errors in cases that the total conjugation preparation volumes are over the MaxVolume of the purification column. Throw error message for True members *)
	exceedStandardCaptureAntibodyPurificationColumnOption=If[(Or@@exceedStandardCaptureAntibodyPurificationColumnErrors)&&messages,
		Message[Error::ExceedStandardCaptureAntibodyPurificationColumnCapacity,
			ObjectToString[PickList[resolvedStandardCaptureAntibody,exceedStandardCaptureAntibodyPurificationColumnErrors],Cache->simulatedCache],
			ObjectToString[PickList[ToList[resolvedStandard],exceedStandardCaptureAntibodyPurificationColumnErrors],Cache->simulatedCache],
			ToString[PickList[standardCaptureAntibodyPurificationColumnMaxVolumes,exceedStandardCaptureAntibodyPurificationColumnErrors]],
			ToString[PickList[standardCaptureAntibodyConjuationReactionVolumes,exceedStandardCaptureAntibodyPurificationColumnErrors]],
			ObjectToString[PickList[preferredStandardCaptureAntibodyPurificationColumns,exceedStandardCaptureAntibodyPurificationColumnErrors],Cache->simulatedCache]
		];
		{StandardCaptureAntibodyPurificationColumn},
		{}
	];

	(* Create the corresponding tests for exceeding standard capture antibody purification column errors *)
	exceedStandardCaptureAntibodyPurificationColumnTests=If[gatherTests,
		Module[{failingTest,passingTest},

			passingTest=Which[
				MatchQ[resolvedStandard,{}|Null]||!resolvedCustomizableCartridgeQ,
				Test["The MaxVolume of the specified StandardCaptureAntibodyPurificationColumn is larger than the total conjugation preparation volume of standard capture antibody samples:",True,True],
				!MemberQ[exceedStandardCaptureAntibodyPurificationColumnErrors,False],
				Nothing,
				True,
				Test["The MaxVolume of the specified StandardCaptureAntibodyPurificationColumn must be larger than the total conjugation preparation volume of standard capture antibody samples "<>ObjectToString[PickList[resolvedStandardCaptureAntibody,exceedStandardCaptureAntibodyPurificationColumnErrors,False],Cache->simulatedCache]<>", used for ELISA assay of "<>ObjectToString[PickList[ToList[resolvedStandard],exceedStandardCaptureAntibodyPurificationColumnErrors,False],Cache->simulatedCache],True,True]
			];

			failingTest=If[!MemberQ[exceedStandardCaptureAntibodyPurificationColumnErrors,True],
				Nothing,
				Test["The MaxVolume of the specified StandardCaptureAntibodyPurificationColumn must be larger than the total conjugation preparation volume of standard capture antibody samples "<>ObjectToString[PickList[resolvedStandardCaptureAntibody,exceedStandardCaptureAntibodyPurificationColumnErrors],Cache->simulatedCache]<>", used for ELISA assay of "<>ObjectToString[PickList[ToList[resolvedStandard],exceedStandardCaptureAntibodyPurificationColumnErrors],Cache->simulatedCache],False,True]
			];

			{failingTest,passingTest}
		],
		{}
	];

	(* Check for the errors in cases that the total conjugation preparation volumes are over the MaxVolume of the purification column. Throw error message for True members *)
	exceedStandardDetectionAntibodyPurificationColumnOption=If[(Or@@exceedStandardDetectionAntibodyPurificationColumnErrors)&&messages,
		Message[Error::ExceedStandardDetectionAntibodyPurificationColumnCapacity,
			ObjectToString[PickList[resolvedStandardDetectionAntibody,exceedStandardDetectionAntibodyPurificationColumnErrors],Cache->simulatedCache],
			ObjectToString[PickList[ToList[resolvedStandard],exceedStandardDetectionAntibodyPurificationColumnErrors],Cache->simulatedCache],
			ToString[PickList[standardDetectionAntibodyPurificationColumnMaxVolumes,exceedStandardDetectionAntibodyPurificationColumnErrors]],
			ToString[PickList[standardDetectionAntibodyConjuationReactionVolumes,exceedStandardDetectionAntibodyPurificationColumnErrors]],
			ObjectToString[PickList[preferredStandardDetectionAntibodyPurificationColumns,exceedStandardDetectionAntibodyPurificationColumnErrors],Cache->simulatedCache]
		];
		{StandardDetectionAntibodyPurificationColumn},
		{}
	];

	(* Create the corresponding tests for exceeding stanadrd detection antibody purification column errors *)
	exceedStandardDetectionAntibodyPurificationColumnTests=If[gatherTests,
		Module[{failingTest,passingTest},

			passingTest=Which[
				MatchQ[resolvedStandard,{}|Null]||!resolvedCustomizableCartridgeQ,
				Test["The MaxVolume of the specified StandardDetectionAntibodyPurificationColumn is larger than the total conjugation preparation volume of standard detection antibody samples:",True,True],
				!MemberQ[exceedStandardDetectionAntibodyPurificationColumnErrors,False],
				Nothing,
				True,
				Test["The MaxVolume of the specified StandardDetectionAntibodyPurificationColumn must be larger than the total conjugation preparation volume of standard detection antibody samples "<>ObjectToString[PickList[resolvedStandardDetectionAntibody,exceedStandardDetectionAntibodyPurificationColumnErrors,False],Cache->simulatedCache]<>", used for ELISA assay of "<>ObjectToString[PickList[ToList[resolvedStandard],exceedStandardDetectionAntibodyPurificationColumnErrors,False],Cache->simulatedCache],True,True]
			];

			failingTest=If[!MemberQ[exceedStandardDetectionAntibodyPurificationColumnErrors,True],
				Nothing,
				Test["The MaxVolume of the specified StandardDetectionAntibodyPurificationColumn must be larger than the total conjugation preparation volume of standard detection antibody samples "<>ObjectToString[PickList[resolvedStandardDetectionAntibody,exceedStandardDetectionAntibodyPurificationColumnErrors],Cache->simulatedCache]<>", used for ELISA assay of "<>ObjectToString[PickList[ToList[resolvedStandard],exceedStandardDetectionAntibodyPurificationColumnErrors],Cache->simulatedCache],False,True]
			];

			{failingTest,passingTest}
		],
		{}
	];

	(* Check for the too high dilution concentration errors that are over the resuspension concentrations of the standard capture antibody samples. Throw error message for True members *)
	tooHighStandardCaptureAntibodyDilutionOption=If[(Or@@invalidStandardCaptureAntibodyDilutionErrors)&&messages,
		Message[Error::TooHighStandardCaptureAntibodyDilution,
			ObjectToString[PickList[resolvedStandardCaptureAntibody,invalidStandardCaptureAntibodyDilutionErrors],Cache->simulatedCache],
			ObjectToString[PickList[ToList[resolvedStandard],invalidStandardCaptureAntibodyDilutionErrors],Cache->simulatedCache]
		];{StandardCaptureAntibodyTargetConcentration},
		{}
	];

	(* Create the corresponding tests for too high dilution concentration errors *)
	tooHighStandardCaptureAntibodyDilutionTests=If[gatherTests,
		Module[{failingTest,passingTest},

			passingTest=Which[
				MatchQ[resolvedStandard,{}|Null]||!resolvedCustomizableCartridgeQ,
				Test["The specified StandardCaptureAntibodyTargetConcentration for the standard capture antibody samples is not higher than its resuspension/ conjugation concentration:",True,True],
				!MemberQ[invalidStandardCaptureAntibodyDilutionErrors,False],
				Nothing,
				True,
				Test["The specified StandardCaptureAntibodyTargetConcentration for the standard capture antibody samples "<>ObjectToString[PickList[resolvedStandardCaptureAntibody,invalidStandardCaptureAntibodyDilutionErrors,False],Cache->simulatedCache]<>" (used for ELISA assay of "<>ObjectToString[PickList[ToList[resolvedStandard],invalidStandardCaptureAntibodyDilutionErrors,False],Cache->simulatedCache]<>") is not too high and can achieved after the resuspension and/or conjugation processes of the samples:",True,True]
			];

			failingTest=If[!MemberQ[invalidStandardCaptureAntibodyDilutionErrors,True],
				Nothing,
				Test["The specified StandardCaptureAntibodyTargetConcentration for the standard capture antibody samples "<>ObjectToString[PickList[resolvedStandardCaptureAntibody,invalidStandardCaptureAntibodyDilutionErrors],Cache->simulatedCache]<>" (used for ELISA assay of "<>ObjectToString[PickList[ToList[resolvedStandard],invalidStandardCaptureAntibodyDilutionErrors],Cache->simulatedCache]<>") is not too high and can be achieved after the resuspension and/or conjugation processes of the samples.",False,True]
			];

			{failingTest,passingTest}
		],
		{}
	];

	(* Check for the too high dilution concentration errors that are over the resuspension concentrations of the standard detection antibody samples. Throw error message for True members *)
	tooHighStandardDetectionAntibodyDilutionOption=If[(Or@@invalidStandardDetectionAntibodyDilutionErrors)&&messages,
		Message[Error::TooHighStandardDetectionAntibodyDilution,ObjectToString[PickList[resolvedStandardDetectionAntibody,invalidStandardDetectionAntibodyDilutionErrors],Cache->simulatedCache],ObjectToString[PickList[ToList[resolvedStandard],invalidStandardDetectionAntibodyDilutionErrors],Cache->simulatedCache]];{StandardDetectionAntibodyTargetConcentration},
		{}
	];

	(* Create the corresponding tests for too high dilution concentration errors *)
	tooHighStandardDetectionAntibodyDilutionTests=If[gatherTests,
		Module[{failingTest,passingTest},

			passingTest=Which[
				MatchQ[resolvedStandard,{}|Null]||!resolvedCustomizableCartridgeQ,
				Test["The specified StandardDetectionAntibodyTargetConcentration for the standard detection antibody samples is not higher than its resuspension/ conjugation concentration:",True,True],
				!MemberQ[invalidStandardDetectionAntibodyDilutionErrors,False],
				Nothing,
				True,
				Test["The specified StandardDetectionAntibodyTargetConcentration for the standard detection antibody samples "<>ObjectToString[PickList[resolvedStandardDetectionAntibody,invalidStandardDetectionAntibodyDilutionErrors,False],Cache->simulatedCache]<>" (used for ELISA assay of "<>ObjectToString[PickList[ToList[resolvedStandard],invalidStandardDetectionAntibodyDilutionErrors,False],Cache->simulatedCache]<>") is not too high and can be achieved after the resuspension and/or conjugation processes of the samples.",True,True]
			];

			failingTest=If[!MemberQ[invalidStandardDetectionAntibodyDilutionErrors,True],
				Nothing,
				Test["The specified StandardDetectionAntibodyTargetConcentration for the standard detection antibody samples "<>ObjectToString[PickList[resolvedStandardDetectionAntibody,invalidStandardDetectionAntibodyDilutionErrors],Cache->simulatedCache]<>" (used for ELISA assay of "<>ObjectToString[PickList[ToList[resolvedStandard],invalidStandardDetectionAntibodyDilutionErrors],Cache->simulatedCache]<>") is not too high and can be after the resuspension and/or conjugation processes of the samples.",False,True]
			];

			{failingTest,passingTest}
		],
		{}
	];

	(* Check for non-optimal standard antibody dilution warnings - higher than 50Microgram/Milliliter. Throw warning message for True members *)
	If[(Or@@nonOptimalStandardCaptureAntibodyDilutionWarnings)&&!MatchQ[$ECLApplication,Engine]&&messages,
		Message[Warning::NonOptimalStandardCaptureAntibodyDilution,ObjectToString[PickList[resolvedStandardDetectionAntibody,nonOptimalStandardCaptureAntibodyDilutionWarnings],Cache->simulatedCache],ObjectToString[PickList[ToList[resolvedStandard],nonOptimalStandardCaptureAntibodyDilutionWarnings],Cache->simulatedCache]],
		Nothing
	];

	(* Create the corresponding tests for not enough standard biotin reagent volume errors *)
	nonOptimalStandardCaptureAntibodyDilutionTests=If[gatherTests,
		Module[{failingTest,passingTest},

			passingTest=Which[
				MatchQ[resolvedStandard,{}|Null]||!resolvedCustomizableCartridgeQ,
				Test["The specified StandardCaptureAntibodyTargetConcentration for the standard capture antibody samples is close to 3.5 Microgram/Milliliter:",True,True],
				!MemberQ[nonOptimalStandardCaptureAntibodyDilutionWarnings,False],
				Nothing,
				True,
				Test["The specified StandardCaptureAntibodyTargetConcentration for the standard capture antibody samples "<>ObjectToString[PickList[resolvedStandardDetectionAntibody,nonOptimalStandardCaptureAntibodyDilutionWarnings,False],Cache->simulatedCache]<>" (used for ELISA experiment of "<>ObjectToString[PickList[ToList[resolvedStandard],nonOptimalStandardCaptureAntibodyDilutionWarnings,False],Cache->simulatedCache]<>") is close to 3.5 Microgram/Milliliter:",True,True]
			];

			failingTest=If[!MemberQ[nonOptimalStandardCaptureAntibodyDilutionWarnings,True],
				Nothing,
				Test["The specified StandardCaptureAntibodyTargetConcentration for the standard capture antibody samples "<>ObjectToString[PickList[resolvedStandardDetectionAntibody,nonOptimalStandardCaptureAntibodyDilutionWarnings],Cache->simulatedCache]<>" (used for ELISA experiment of "<>ObjectToString[PickList[ToList[resolvedStandard],nonOptimalStandardCaptureAntibodyDilutionWarnings],Cache->simulatedCache]<>") is close to 3.5 Microgram/Milliliter:",False,True]
			];

			{failingTest,passingTest}
		],
		{}
	];

	(* Check for non-optimal standard antibody dilution warnings - higher than 50Microgram/Milliliter. Throw warning message for True members *)
	If[(Or@@nonOptimalStandardDetectionAntibodyDilutionWarnings)&&!MatchQ[$ECLApplication,Engine]&&messages,
		Message[Warning::NonOptimalStandardDetectionAntibodyDilution,ObjectToString[PickList[resolvedStandardDetectionAntibody,nonOptimalStandardDetectionAntibodyDilutionWarnings],Cache->simulatedCache],ObjectToString[PickList[ToList[resolvedStandard],nonOptimalStandardDetectionAntibodyDilutionWarnings],Cache->simulatedCache]],
		Nothing
	];

	(* Create the corresponding tests for not enough standard biotin reagent volume errors *)
	nonOptimalStandardDetectionAntibodyDilutionTests=If[gatherTests,
		Module[{failingTest,passingTest},

			passingTest=Which[
				MatchQ[resolvedStandard,{}|Null]||!resolvedCustomizableCartridgeQ,
				Test["The specified StandardDetectionAntibodyTargetConcentration for the standard detection antibody samples is close to 3.5 Microgram/Milliliter:",True,True],
				!MemberQ[nonOptimalStandardDetectionAntibodyDilutionWarnings,False],
				Nothing,
				True,
				Test["The specified StandardDetectionAntibodyTargetConcentration for the standard detection antibody samples "<>ObjectToString[PickList[resolvedStandardDetectionAntibody,nonOptimalStandardDetectionAntibodyDilutionWarnings,False],Cache->simulatedCache]<>" (used for ELISA experiment of "<>ObjectToString[PickList[ToList[resolvedStandard],nonOptimalStandardDetectionAntibodyDilutionWarnings,False],Cache->simulatedCache]<>") is close to 3.5 Microgram/Milliliter:",True,True]
			];

			failingTest=If[!MemberQ[nonOptimalStandardDetectionAntibodyDilutionWarnings,True],
				Nothing,
				Test["The specified StandardDetectionAntibodyTargetConcentration for the standard detection antibody samples "<>ObjectToString[PickList[resolvedStandardDetectionAntibody,nonOptimalStandardDetectionAntibodyDilutionWarnings],Cache->simulatedCache]<>" (used for ELISA experiment of "<>ObjectToString[PickList[ToList[resolvedStandard],nonOptimalStandardDetectionAntibodyDilutionWarnings],Cache->simulatedCache]<>") is close to 3.5 Microgram/Milliliter:",False,True]
			];

			{failingTest,passingTest}
		],
		{}
	];

	(* Check for incomplete resolved spike concentration errors - in the cases where we cannot find the concentrations. Throw error message for True members *)
	incompleteResolvedSpikeConcentrationOption=If[(Or@@incompleteResolvedSpikeConcentrationErrors)&&messages,
		Message[Error::IncompleteResolvedSpikeConcentration,ObjectToString[PickList[resolvedSpikeSample,incompleteResolvedSpikeConcentrationErrors],Cache->simulatedCache],ObjectToString[PickList[mySamples,incompleteResolvedSpikeConcentrationErrors],Cache->simulatedCache]];{SpikeConcentration},
		{}
	];

	(* Create the corresponding tests for incomplete spike concentration errors *)
	incompleteResolvedSpikeConcentrationTests=If[gatherTests,
		Module[{failingTest,passingTest},

			passingTest=If[!MemberQ[incompleteResolvedSpikeConcentrationErrors,False],
				Nothing,
				Test["The SpikeConcentration of analytes of interest in the SpikeSample is provided for the samples "<>ObjectToString[PickList[mySamples,incompleteResolvedSpikeConcentrationErrors,False],Cache->simulatedCache],True,True]
			];

			failingTest=If[!MemberQ[incompleteResolvedSpikeConcentrationErrors,True],
				Nothing,
				Test["The SpikeConcentration of analytes of interest in the SpikeSample "<>ObjectToString[PickList[resolvedSpikeSample,incompleteResolvedSpikeConcentrationErrors],Cache->simulatedCache]<>" is provided for the samples "<>ObjectToString[PickList[mySamples,incompleteResolvedSpikeConcentrationErrors],Cache->simulatedCache],True,False]
			];

			{failingTest,passingTest}
		],
		{}
	];

	(* Check for non-optional dilutions (higher than recommended minimum dilution factor). Throw warning message for True members *)
	If[(Or@@nonOptimalDilutionWarnings)&&!MatchQ[$ECLApplication,Engine]&&messages,
		Message[Warning::NonOptimalCapillaryELISASampleDilution,ObjectToString[PickList[mySamples,nonOptimalDilutionWarnings],Cache->simulatedCache],ToString[bestMinDilutionFactor]],
		Nothing
	];

	(* Create the corresponding tests for non-optional dilutions *)
	nonOptimalDilutionTests=If[gatherTests,
		Module[{failingTest,passingTest},

			passingTest=If[!MemberQ[nonOptimalDilutionWarnings,False],
				Nothing,
				Test["The samples "<>ObjectToString[PickList[mySamples,nonOptimalDilutionWarnings,False],Cache->simulatedCache]<>" are diluted to at least the recommended dilution factor "<>ToString[bestMinDilutionFactor],True,True]
			];

			failingTest=If[!MemberQ[nonOptimalDilutionWarnings,True],
				Nothing,
				Test["The samples "<>ObjectToString[PickList[mySamples,nonOptimalDilutionWarnings],Cache->simulatedCache]<>" are diluted to at least the recommended dilution factor "<>ToString[bestMinDilutionFactor],True,False]
			];

			{failingTest,passingTest}
		],
		{}
	];

	(* Check for conflicting epitope warnings. Throw warning message for True members *)
	If[(Or@@conflictAntibodyEpitopeWarnings)&&!MatchQ[$ECLApplication,Engine]&&messages,
		Message[Warning::ConflictAntibodyEpitopes,ObjectToString[PickList[mySamples,conflictAntibodyEpitopeWarnings],Cache->simulatedCache]],
		Nothing
	];

	(* Create the corresponding tests for conflict antibody epitopes *)
	conflictAntibodyEpitopeTests=If[gatherTests,
		Module[{failingTest,passingTest},

			passingTest=If[!MemberQ[conflictAntibodyEpitopeWarnings,False],
				Nothing,
				Test["When a customizable capillary ELISA cartridge is used, the CustomCaptureAntibody and CustomDetectionAntibody of the samples "<>ObjectToString[PickList[mySamples,conflictAntibodyEpitopeWarnings,False],Cache->simulatedCache]<>" do not share the same binding epitopes on the analytes:",True,True]
			];

			failingTest=If[!MemberQ[conflictAntibodyEpitopeWarnings,True],
				Nothing,
				Test["When a customizable capillary ELISA cartridge is used, the CustomCaptureAntibody and CustomDetectionAntibody of the samples "<>ObjectToString[PickList[mySamples,conflictAntibodyEpitopeWarnings],Cache->simulatedCache]<>" do not share the same binding epitopes on the analytes:",False,True]
			];

			{failingTest,passingTest}
		],
		{}
	];

	(* Check for unresolved capture antibody errors. Throw error message for True members *)
	missingCaptureAntibodyOptions=If[(Or@@missingCaptureAntibodyErrors)&&messages,
		Message[Error::MustSpecifyCaptureAntibody,ObjectToString[PickList[mySamples,missingCaptureAntibodyErrors],Cache->simulatedCache]];{CustomCaptureAntibody},
		{}
	];

	(* Create the corresponding tests for unresolved capture antibody errors *)
	missingCaptureAntibodyTests=If[gatherTests,
		Module[{failingTest,passingTest},

			passingTest=If[!MemberQ[missingCaptureAntibodyErrors,False],
				Nothing,
				Test["The CustomCaptureAntibody must be specified for the samples "<>ObjectToString[PickList[mySamples,missingCaptureAntibodyErrors,False],Cache->simulatedCache]<>" when the cartridge is customizable:",True,True]
			];

			failingTest=If[!MemberQ[missingCaptureAntibodyErrors,True],
				Nothing,
				Test["The CustomCaptureAntibody must be specified for the samples "<>ObjectToString[PickList[mySamples,missingCaptureAntibodyErrors],Cache->simulatedCache]<>" when the cartridge is customizable:",False,True]
			];

			{failingTest,passingTest}
		],
		{}
	];

	(* Check for unresolved detection antibody errors. Throw error message for True members *)
	missingDetectionAntibodyOptions=If[(Or@@missingDetectionAntibodyErrors)&&messages,
		Message[Error::MustSpecifyDetectionAntibody,ObjectToString[PickList[mySamples,missingDetectionAntibodyErrors],Cache->simulatedCache]];{CustomDetectionAntibody},
		{}
	];

	(* Create the corresponding tests for unresolved detection antibody errors *)
	missingDetectionAntibodyTests=If[gatherTests,
		Module[{failingTest,passingTest},

			passingTest=If[!MemberQ[missingDetectionAntibodyErrors,False],
				Nothing,
				Test["The CustomDetectionAntibody must be specified for the samples "<>ObjectToString[PickList[mySamples,missingDetectionAntibodyErrors,False],Cache->simulatedCache]<>" when the cartridge is customizable:",True,True]
			];

			failingTest=If[!MemberQ[missingDetectionAntibodyErrors,True],
				Nothing,
				Test["The CustomDetectionAntibody must be specified for the samples "<>ObjectToString[PickList[mySamples,missingDetectionAntibodyErrors],Cache->simulatedCache]<>" when the cartridge is customizable:",False,True]
			];

			{failingTest,passingTest}
		],
		{}
	];

	(* Check for unresolved digoxigenin reagent volume errors. This can happen because of unresolvable antibody concentration or unresolvable digoxigenin-NHS concentration. Throw error message for True members *)
	missingDigoxigeninReagentVolumeOptions=If[(Or@@missingDigoxigeninReagentVolumeErrors)&&messages,
		Message[Error::MustSpecifyDigoxigeninReagentVolume,ObjectToString[PickList[mySamples,missingDigoxigeninReagentVolumeErrors],Cache->simulatedCache]];{DigoxigeninReagentVolume},
		{}
	];

	(* Create the corresponding tests for unresolved digoxigenin reagent volume errors *)
	missingDigoxigeninReagentVolumeTests=If[gatherTests,
		Module[{failingTest,passingTest},

			passingTest=If[!MemberQ[missingDigoxigeninReagentVolumeErrors,False],
				Nothing,
				Test["The DigoxigeninReagentVolume must be specified for the samples "<>ObjectToString[PickList[mySamples,missingDigoxigeninReagentVolumeErrors,False],Cache->simulatedCache]<>" to perform bioconjugation when CaptureAntibodyConjugation is True:",True,True]
			];

			failingTest=If[!MemberQ[missingDigoxigeninReagentVolumeErrors,True],
				Nothing,
				Test["The DigoxigeninReagentVolume must be specified for the samples "<>ObjectToString[PickList[mySamples,missingDigoxigeninReagentVolumeErrors],Cache->simulatedCache]<>" to perform bioconjugation when CaptureAntibodyConjugation is True:",False,True]
			];

			{failingTest,passingTest}
		],
		{}
	];

	(* Check for unresolved biotin reagent volume errors. This can happen because of unresolvable antibody concentration or unresolvable biotin-XX concentration. Throw error message for True members *)
	missingBiotinReagentVolumeOptions=If[(Or@@missingBiotinReagentVolumeErrors)&&messages,
		Message[Error::MustSpecifyBiotinReagentVolume,ObjectToString[PickList[mySamples,missingBiotinReagentVolumeErrors],Cache->simulatedCache]];{BiotinReagentVolume},
		{}
	];

	(* Create the corresponding tests for unresolved biotin reagent volume errors *)
	missingBiotinReagentVolumeTests=If[gatherTests,
		Module[{failingTest,passingTest},

			passingTest=If[!MemberQ[missingBiotinReagentVolumeErrors,False],
				Nothing,
				Test["The BiotinReagentVolume must be specified for the samples "<>ObjectToString[PickList[mySamples,missingBiotinReagentVolumeErrors,False],Cache->simulatedCache]<>" to perform bioconjugation when CaptureAntibodyConjugation is True:",True,True]
			];

			failingTest=If[!MemberQ[missingBiotinReagentVolumeErrors,True],
				Nothing,
				Test["The BiotinReagentVolume must be specified for the samples "<>ObjectToString[PickList[mySamples,missingBiotinReagentVolumeErrors],Cache->simulatedCache]<>" to perform bioconjugation when CaptureAntibodyConjugation is True:",False,True]
			];

			{failingTest,passingTest}
		],
		{}
	];

	(* Check for not enough digoxigenin reagent volume. This happens when the amount of digoxigenin is less than amount of antibody. Throw warning message for True members *)
	If[(Or@@notEnoughDigoxigeninReagentVolumeWarnings)&&!MatchQ[$ECLApplication,Engine]&&messages,
		Message[Warning::NotEnoughDigoxigeninReagentVolume,ObjectToString[PickList[resolvedCustomCaptureAntibody,notEnoughDigoxigeninReagentVolumeWarnings],Cache->simulatedCache],ObjectToString[PickList[mySamples,notEnoughDigoxigeninReagentVolumeWarnings],Cache->simulatedCache]],
		Nothing
	];

	(* Create the corresponding tests for not enough digoxigenin reagent volume errors *)
	notEnoughDigoxigeninReagentVolumeTests=If[gatherTests,
		Module[{failingTest,passingTest},

			passingTest=Which[
				!resolvedCustomizableCartridgeQ,
				Test["When a customizable capillary ELISA cartridge is used, the DigoxigeninReagentVolume should provide excess amount of digoxigenin reagent compared to CustomCaptureAntibody in the bioconjugation process to achieve the best conjugation efficiency for capture antibody samples:",True,True],
				!MemberQ[notEnoughDigoxigeninReagentVolumeWarnings,False],
				Nothing,
				True,
				Test["When a customizable capillary ELISA cartridge is used, the DigoxigeninReagentVolume should provide excess amount of digoxigenin reagent compared to CustomCaptureAntibody in the bioconjugation process to achieve the best conjugation efficiency for capture antibody samples "<>ObjectToString[PickList[resolvedCustomCaptureAntibody,notEnoughDigoxigeninReagentVolumeWarnings,False],Cache->simulatedCache]<>" used for ELISA experiment of "<>ObjectToString[PickList[mySamples,notEnoughDigoxigeninReagentVolumeWarnings,False],Cache->simulatedCache],True,True]
			];

			failingTest=If[!MemberQ[notEnoughDigoxigeninReagentVolumeWarnings,True],
				Nothing,
				Test["When a customizable capillary ELISA cartridge is used, the DigoxigeninReagentVolume should provide excess amount of digoxigenin reagent compared to CustomCaptureAntibody in the bioconjugation process to achieve the best conjugation efficiency for capture antibody samples "<>ObjectToString[PickList[resolvedCustomCaptureAntibody,notEnoughDigoxigeninReagentVolumeWarnings],Cache->simulatedCache]<>" used for ELISA experiment of "<>ObjectToString[PickList[mySamples,notEnoughDigoxigeninReagentVolumeWarnings],Cache->simulatedCache],False,True]
			];

			{failingTest,passingTest}
		],
		{}
	];

	(* Check for not enough biotin reagent volume. This happens when the amount of biotin is less than amount of antibody. Throw warning message for True members *)
	If[(Or@@notEnoughBiotinReagentVolumeWarnings)&&!MatchQ[$ECLApplication,Engine]&&messages,
		Message[Warning::NotEnoughBiotinReagentVolume,ObjectToString[PickList[resolvedCustomDetectionAntibody,notEnoughBiotinReagentVolumeWarnings],Cache->simulatedCache],ObjectToString[PickList[mySamples,notEnoughBiotinReagentVolumeWarnings],Cache->simulatedCache]],
		Nothing
	];

	(* Create the corresponding tests for not enough biotin reagent volume errors *)
	notEnoughBiotinReagentVolumeTests=If[gatherTests,
		Module[{failingTest,passingTest},

			passingTest=If[!MemberQ[notEnoughBiotinReagentVolumeWarnings,False],
				Nothing,
				Test["When a customizable capillary ELISA cartridge is used, the BiotinReagentVolume should provide excess amount of biotin reagent compared to CustomDetectionAntibody in the bioconjugation process to achieve the best conjugation efficiency for detection antibody samples "<>ObjectToString[PickList[resolvedCustomDetectionAntibody,notEnoughBiotinReagentVolumeWarnings,False],Cache->simulatedCache]<>" used for ELISA experiment of "<>ObjectToString[PickList[mySamples,notEnoughBiotinReagentVolumeWarnings,False],Cache->simulatedCache],True,True]
			];

			failingTest=If[!MemberQ[notEnoughBiotinReagentVolumeWarnings,True],
				Nothing,
				Test["When a customizable capillary ELISA cartridge is used, the BiotinReagentVolume should provide excess amount of biotin reagent compared to CustomDetectionAntibody in the bioconjugation process to achieve the best conjugation efficiency for detection antibody samples "<>ObjectToString[PickList[resolvedCustomDetectionAntibody,notEnoughBiotinReagentVolumeWarnings],Cache->simulatedCache]<>" used for ELISA experiment of "<>ObjectToString[PickList[mySamples,notEnoughBiotinReagentVolumeWarnings],Cache->simulatedCache],False,True]
			];

			{failingTest,passingTest}
		],
		{}
	];

	(* Check for the errors in cases that the total conjugation preparation volumes are over the MaxVolume of the conjugation container. Throw error message for True members *)
	preferredCaptureAntibodyConjugationContainers=Map[
		PreferredContainer[#]&,
		captureAntibodyConjuationReactionVolumes
	];

	exceedCaptureAntibodyConjugationContainerOption=If[(Or@@exceedCaptureAntibodyConjugationContainerErrors)&&messages,
		Message[Error::ExceedCaptureAntibodyConjugationContainerCapacity,
			ObjectToString[PickList[resolvedCustomCaptureAntibody,exceedCaptureAntibodyConjugationContainerErrors],Cache->simulatedCache],
			ObjectToString[PickList[mySamples,exceedCaptureAntibodyConjugationContainerErrors],Cache->simulatedCache],
			ToString[PickList[captureAntibodyConjugationContainerMaxVolumes,exceedCaptureAntibodyConjugationContainerErrors]],
			ToString[PickList[captureAntibodyConjuationReactionVolumes,exceedCaptureAntibodyConjugationContainerErrors]],
			ObjectToString[preferredCaptureAntibodyConjugationContainers,Cache->simulatedCache]
		];
		{CaptureAntibodyConjugationContainer},
		{}
	];

	(* Create the corresponding tests for exceeding capture antibody conjugation container capacity errors *)
	exceedCaptureAntibodyConjugationContainerTests=If[gatherTests,
		Module[{failingTest,passingTest},

			passingTest=Which[
				!resolvedCustomizableCartridgeQ,
				Test["When a customizable capillary ELISA cartridge is used, the MaxVolume of the specified CaptureAntibodyConjugationContainer must be larger than the total conjugation preparation volume of capture antibody samples:",True,True],
				!MemberQ[exceedCaptureAntibodyConjugationContainerErrors,False],
				Nothing,
				True,
				Test["When a customizable capillary ELISA cartridge is used, the MaxVolume of the specified CaptureAntibodyConjugationContainer must be larger than the total conjugation preparation volume of capture antibody samples "<>ObjectToString[PickList[resolvedCustomCaptureAntibody,exceedCaptureAntibodyConjugationContainerErrors,False],Cache->simulatedCache]<>", used for ELISA assay of "<>ObjectToString[PickList[mySamples,exceedCaptureAntibodyConjugationContainerErrors,False],Cache->simulatedCache],True,True]
			];

			failingTest=If[!MemberQ[exceedCaptureAntibodyConjugationContainerErrors,True],
				Nothing,
				Test["When a customizable capillary ELISA cartridge is used, the MaxVolume of the specified CaptureAntibodyConjugationContainer must be larger than the total conjugation preparation volume of capture antibody samples "<>ObjectToString[PickList[resolvedCustomCaptureAntibody,exceedCaptureAntibodyConjugationContainerErrors],Cache->simulatedCache]<>", used for ELISA assay of "<>ObjectToString[PickList[mySamples,exceedCaptureAntibodyConjugationContainerErrors],Cache->simulatedCache],False,True]
			];

			{failingTest,passingTest}
		],
		{}
	];

	(* Check for the errors in cases that the total conjugation preparation volumes are over the MaxVolume of the conjugation container. Throw error message for True members *)
	preferredDetectionAntibodyConjugationContainers=Map[
		PreferredContainer[#]&,
		detectionAntibodyConjuationReactionVolumes
	];

	exceedDetectionAntibodyConjugationContainerOption=If[(Or@@exceedDetectionAntibodyConjugationContainerErrors)&&messages,
		Message[Error::ExceedDetectionAntibodyConjugationContainerCapacity,
			ObjectToString[PickList[resolvedCustomDetectionAntibody,exceedDetectionAntibodyConjugationContainerErrors],Cache->simulatedCache],
			ObjectToString[PickList[mySamples,exceedDetectionAntibodyConjugationContainerErrors],Cache->simulatedCache],
			ToString[PickList[detectionAntibodyConjugationContainerMaxVolumes,exceedDetectionAntibodyConjugationContainerErrors]],
			ToString[PickList[detectionAntibodyConjuationReactionVolumes,exceedDetectionAntibodyConjugationContainerErrors]],
			ObjectToString[preferredDetectionAntibodyConjugationContainers,Cache->simulatedCache]
		];
		{DetectionAntibodyConjugationContainer},
		{}
	];

	(* Create the corresponding tests for exceeding detection antibody conjugation capacity errors *)
	exceedDetectionAntibodyConjugationContainerTests=If[gatherTests,
		Module[{failingTest,passingTest},

			passingTest=If[!MemberQ[exceedDetectionAntibodyConjugationContainerErrors,False],
				Nothing,
				Test["When a customizable capillary ELISA cartridge is used, the MaxVolume of the specified DetectionAntibodyConjugationContainer must be larger than the total conjugation preparation volume of detection antibody samples "<>ObjectToString[PickList[resolvedCustomDetectionAntibody,exceedDetectionAntibodyConjugationContainerErrors,False],Cache->simulatedCache]<>", used for ELISA assay of "<>ObjectToString[PickList[mySamples,exceedDetectionAntibodyConjugationContainerErrors,False],Cache->simulatedCache],True,True]
			];

			failingTest=If[!MemberQ[exceedDetectionAntibodyConjugationContainerErrors,True],
				Nothing,
				Test["When a customizable capillary ELISA cartridge is used, the MaxVolume of the specified DetectionAntibodyConjugationContainer must be larger than the total conjugation preparation volume of detection antibody samples "<>ObjectToString[PickList[resolvedCustomDetectionAntibody,exceedDetectionAntibodyConjugationContainerErrors],Cache->simulatedCache]<>", used for ELISA assay of "<>ObjectToString[PickList[mySamples,exceedDetectionAntibodyConjugationContainerErrors],Cache->simulatedCache],False,True]
			];

			{failingTest,passingTest}
		],
		{}
	];

	(* Check for the errors in cases that the total conjugation preparation volumes are over the MaxVolume of the purification column. Throw error message for True members *)
	exceedCaptureAntibodyPurificationColumnOption=If[(Or@@exceedCaptureAntibodyPurificationColumnErrors)&&messages,
		Message[Error::ExceedCaptureAntibodyPurificationColumnCapacity,
			ObjectToString[PickList[resolvedCustomCaptureAntibody,exceedCaptureAntibodyPurificationColumnErrors],Cache->simulatedCache],
			ObjectToString[PickList[mySamples,exceedCaptureAntibodyPurificationColumnErrors],Cache->simulatedCache],
			ToString[PickList[captureAntibodyPurificationColumnMaxVolumes,exceedCaptureAntibodyPurificationColumnErrors]],
			ToString[PickList[captureAntibodyConjuationReactionVolumes,exceedCaptureAntibodyPurificationColumnErrors]],
			ObjectToString[PickList[preferredCaptureAntibodyPurificationColumns,exceedCaptureAntibodyPurificationColumnErrors],Cache->simulatedCache]
		];
		{CaptureAntibodyPurificationColumn},
		{}
	];

	(* Create the corresponding tests for exceeding capture antibody purification column errors *)
	exceedCaptureAntibodyPurificationColumnTests=If[gatherTests,
		Module[{failingTest,passingTest},

			passingTest=Which[
				!resolvedCustomizableCartridgeQ,
				Test["When a customizable capillary ELISA cartridge is used, the MaxVolume of the specified CaptureAntibodyPurificationColumn must be larger than the total conjugation preparation volume of capture antibody samples:",True,True],
				!MemberQ[exceedCaptureAntibodyPurificationColumnErrors,False],
				Nothing,
				True,
				Test["When a customizable capillary ELISA cartridge is used, the MaxVolume of the specified CaptureAntibodyPurificationColumn must be larger than the total conjugation preparation volume of capture antibody samples "<>ObjectToString[PickList[resolvedCustomCaptureAntibody,exceedCaptureAntibodyPurificationColumnErrors,False],Cache->simulatedCache]<>", used for ELISA assay of "<>ObjectToString[PickList[mySamples,exceedCaptureAntibodyPurificationColumnErrors,False],Cache->simulatedCache],True,True]
			];

			failingTest=If[!MemberQ[exceedCaptureAntibodyPurificationColumnErrors,True],
				Nothing,
				Test["When a customizable capillary ELISA cartridge is used, the MaxVolume of the specified CaptureAntibodyPurificationColumn must be larger than the total conjugation preparation volume of capture antibody samples "<>ObjectToString[PickList[resolvedCustomCaptureAntibody,exceedCaptureAntibodyPurificationColumnErrors],Cache->simulatedCache]<>", used for ELISA assay of "<>ObjectToString[PickList[mySamples,exceedCaptureAntibodyPurificationColumnErrors],Cache->simulatedCache],False,True]
			];

			{failingTest,passingTest}
		],
		{}
	];

	(* Check for the errors in cases that the total conjugation preparation volumes are over the MaxVolume of the purification column. Throw error message for True members *)
	exceedDetectionAntibodyPurificationColumnOption=If[(Or@@exceedDetectionAntibodyPurificationColumnErrors)&&messages,
		Message[Error::ExceedDetectionAntibodyPurificationColumnCapacity,
			ObjectToString[PickList[resolvedCustomDetectionAntibody,exceedDetectionAntibodyPurificationColumnErrors],Cache->simulatedCache],
			ObjectToString[PickList[mySamples,exceedDetectionAntibodyPurificationColumnErrors],Cache->simulatedCache],
			ToString[PickList[detectionAntibodyPurificationColumnMaxVolumes,exceedDetectionAntibodyPurificationColumnErrors]],
			ToString[PickList[detectionAntibodyConjuationReactionVolumes,exceedDetectionAntibodyPurificationColumnErrors]],
			ObjectToString[PickList[preferredDetectionAntibodyPurificationColumns,exceedDetectionAntibodyPurificationColumnErrors],Cache->simulatedCache]
		];
		{DetectionAntibodyPurificationColumn},
		{}
	];

	(* Create the corresponding tests for exceeding stanadrd detection antibody purification column errors *)
	exceedDetectionAntibodyPurificationColumnTests=If[gatherTests,
		Module[{failingTest,passingTest},

			passingTest=If[!MemberQ[exceedDetectionAntibodyPurificationColumnErrors,False],
				Nothing,
				Test["When a customizable capillary ELISA cartridge is used, the MaxVolume of the specified DetectionAntibodyPurificationColumn must be larger than the total conjugation preparation volume of detection antibody samples "<>ObjectToString[PickList[resolvedCustomDetectionAntibody,exceedDetectionAntibodyPurificationColumnErrors,False],Cache->simulatedCache]<>", used for ELISA assay of "<>ObjectToString[PickList[mySamples,exceedDetectionAntibodyPurificationColumnErrors,False],Cache->simulatedCache],True,True]
			];

			failingTest=If[!MemberQ[exceedDetectionAntibodyPurificationColumnErrors,True],
				Nothing,
				Test["When a customizable capillary ELISA cartridge is used, the MaxVolume of the specified DetectionAntibodyPurificationColumn must be larger than the total conjugation preparation volume of detection antibody samples "<>ObjectToString[PickList[resolvedCustomDetectionAntibody,exceedDetectionAntibodyPurificationColumnErrors],Cache->simulatedCache]<>", used for ELISA assay of "<>ObjectToString[PickList[mySamples,exceedDetectionAntibodyPurificationColumnErrors],Cache->simulatedCache],False,True]
			];

			{failingTest,passingTest}
		],
		{}
	];

	(* Check for the too high dilution concentration errors that are over the resuspension concentrations of the capture antibody samples. Throw error message for True members *)
	tooHighCaptureAntibodyDilutionOption=If[(Or@@invalidCaptureAntibodyDilutionErrors)&&messages,
		Message[Error::TooHighCaptureAntibodyDilution,ObjectToString[PickList[resolvedCustomCaptureAntibody,invalidCaptureAntibodyDilutionErrors],Cache->simulatedCache],ObjectToString[PickList[mySamples,invalidCaptureAntibodyDilutionErrors],Cache->simulatedCache]];{CaptureAntibodyDilution},
		{}
	];

	(* Create the corresponding tests for too high dilution concentration errors *)
	tooHighCaptureAntibodyDilutionTests=If[gatherTests,
		Module[{failingTest,passingTest},

			passingTest=Which[
				!resolvedCustomizableCartridgeQ,
				Test["The specified CaptureAntibodyTargetConcentration for the capture antibody samples is not higher than its resuspension/ conjugation concentration:",True,True],
				!MemberQ[invalidCaptureAntibodyDilutionErrors,False],
				Nothing,
				True,
				Test["The specified CaptureAntibodyTargetConcentration for the capture antibody samples "<>ObjectToString[PickList[resolvedCustomCaptureAntibody,invalidCaptureAntibodyDilutionErrors,False],Cache->simulatedCache]<>" (used for ELISA assay of "<>ObjectToString[PickList[mySamples,invalidCaptureAntibodyDilutionErrors,False],Cache->simulatedCache]<>") is not too high and can achieved after the resuspension and/or conjugation processes of the samples:",True,True]
			];

			failingTest=If[!MemberQ[invalidCaptureAntibodyDilutionErrors,True],
				Nothing,
				Test["The specified CaptureAntibodyTargetConcentration for the capture antibody samples "<>ObjectToString[PickList[resolvedCustomCaptureAntibody,invalidCaptureAntibodyDilutionErrors],Cache->simulatedCache]<>" (used for ELISA assay of "<>ObjectToString[PickList[mySamples,invalidCaptureAntibodyDilutionErrors],Cache->simulatedCache]<>") is not too high and can achieved after the resuspension and/or conjugation processes of the samples:",False,True]
			];

			{failingTest,passingTest}
		],
		{}
	];

	(* Check for the too high dilution concentration errors that are over the resuspension concentrations of the detection antibody samples. Throw error message for True members *)
	tooHighDetectionAntibodyDilutionOption=If[(Or@@invalidDetectionAntibodyDilutionErrors)&&messages,
		Message[Error::TooHighDetectionAntibodyDilution,ObjectToString[PickList[resolvedCustomDetectionAntibody,invalidDetectionAntibodyDilutionErrors],Cache->simulatedCache],ObjectToString[PickList[mySamples,invalidDetectionAntibodyDilutionErrors],Cache->simulatedCache]];{DetectionAntibodyDilution},
		{}
	];

	(* Create the corresponding tests for too high dilution concentration errors *)
	tooHighDetectionAntibodyDilutionTests=If[gatherTests,
		Module[{failingTest,passingTest},

			passingTest=Which[
				!resolvedCustomizableCartridgeQ,
				Test["The specified DetectionAntibodyTargetConcentration for the detection antibody samples is not higher than its resuspension/ conjugation concentration:",True,True],
				!MemberQ[invalidDetectionAntibodyDilutionErrors,False],
				Nothing,
				True,
				Test["The specified DetectionAntibodyTargetConcentration for the detection antibody samples "<>ObjectToString[PickList[resolvedCustomDetectionAntibody,invalidDetectionAntibodyDilutionErrors,False],Cache->simulatedCache]<>" (used for ELISA assay of "<>ObjectToString[PickList[mySamples,invalidDetectionAntibodyDilutionErrors,False],Cache->simulatedCache]<>") is too high and cannot be achieved after the resuspension and/or conjugation processes of the samples.",True,True]
			];

			failingTest=If[!MemberQ[invalidDetectionAntibodyDilutionErrors,True],
				Nothing,
				Test["The specified DetectionAntibodyTargetConcentration for the detection antibody samples "<>ObjectToString[PickList[resolvedCustomDetectionAntibody,invalidDetectionAntibodyDilutionErrors],Cache->simulatedCache]<>" (used for ELISA assay of "<>ObjectToString[PickList[mySamples,invalidDetectionAntibodyDilutionErrors],Cache->simulatedCache]<>") is too high and cannot be achieved after the resuspension and/or conjugation processes of the samples.",False,True]
			];

			{failingTest,passingTest}
		],
		{}
	];

	(* Check for non-optimal antibody dilution warnings - higher than 50Microgram/Milliliter. Throw warning message for True members *)
	If[(Or@@nonOptimalCaptureAntibodyDilutionWarnings)&&!MatchQ[$ECLApplication,Engine]&&messages,
		Message[Warning::NonOptimalCaptureAntibodyDilution,ObjectToString[PickList[resolvedCustomDetectionAntibody,nonOptimalCaptureAntibodyDilutionWarnings],Cache->simulatedCache],ObjectToString[PickList[mySamples,nonOptimalCaptureAntibodyDilutionWarnings],Cache->simulatedCache]],
		Nothing
	];

	(* Create the corresponding tests for not enough biotin reagent volume errors *)
	nonOptimalCaptureAntibodyDilutionTests=If[gatherTests,
		Module[{failingTest,passingTest},

			passingTest=Which[
				!resolvedCustomizableCartridgeQ,
				Test["The specified CaptureAntibodyTargetConcentration for the capture antibody samples is close to 3.5 Microgram/Milliliter:",True,True],
				!MemberQ[nonOptimalCaptureAntibodyDilutionWarnings,False],
				Nothing,
				True,
				Test["The specified CaptureAntibodyTargetConcentration for the capture antibody samples "<>ObjectToString[PickList[resolvedCustomDetectionAntibody,nonOptimalCaptureAntibodyDilutionWarnings,False],Cache->simulatedCache]<>" (used for ELISA experiment of "<>ObjectToString[PickList[mySamples,nonOptimalCaptureAntibodyDilutionWarnings,False],Cache->simulatedCache]<>") is close to 3.5 Microgram/Milliliter:",True,True]
			];

			failingTest=If[!MemberQ[nonOptimalCaptureAntibodyDilutionWarnings,True],
				Nothing,
				Test["The specified CaptureAntibodyTargetConcentration for the capture antibody samples "<>ObjectToString[PickList[resolvedCustomDetectionAntibody,nonOptimalCaptureAntibodyDilutionWarnings],Cache->simulatedCache]<>" (used for ELISA experiment of "<>ObjectToString[PickList[mySamples,nonOptimalCaptureAntibodyDilutionWarnings],Cache->simulatedCache]<>") is close to 3.5 Microgram/Milliliter:",False,True]
			];

			{failingTest,passingTest}
		],
		{}
	];

	(* Check for non-optimal antibody dilution warnings - higher than 50Microgram/Milliliter. Throw warning message for True members *)
	If[(Or@@nonOptimalDetectionAntibodyDilutionWarnings)&&!MatchQ[$ECLApplication,Engine]&&messages,
		Message[Warning::NonOptimalDetectionAntibodyDilution,ObjectToString[PickList[resolvedCustomDetectionAntibody,nonOptimalDetectionAntibodyDilutionWarnings],Cache->simulatedCache],ObjectToString[PickList[mySamples,nonOptimalDetectionAntibodyDilutionWarnings],Cache->simulatedCache]],
		Nothing
	];

	(* Create the corresponding tests for not enough biotin reagent volume errors *)
	nonOptimalDetectionAntibodyDilutionTests=If[gatherTests,
		Module[{failingTest,passingTest},

			passingTest=Which[
				!resolvedCustomizableCartridgeQ,
				Test["The specified DetectionAntibodyTargetConcentration for the detection antibody samples is close to 3.5 Microgram/Milliliter:",True,True],
				!MemberQ[nonOptimalDetectionAntibodyDilutionWarnings,False],
				Nothing,
				True,
				Test["The specified DetectionAntibodyTargetConcentration for the detection antibody samples "<>ObjectToString[PickList[resolvedCustomDetectionAntibody,nonOptimalDetectionAntibodyDilutionWarnings,False],Cache->simulatedCache]<>" (used for ELISA experiment of "<>ObjectToString[PickList[mySamples,nonOptimalDetectionAntibodyDilutionWarnings,False],Cache->simulatedCache]<>") is close to 3.5 Microgram/Milliliter:",True,True]
			];

			failingTest=If[!MemberQ[nonOptimalDetectionAntibodyDilutionWarnings,True],
				Nothing,
				Test["The specified DetectionAntibodyTargetConcentration for the detection antibody samples "<>ObjectToString[PickList[resolvedCustomDetectionAntibody,nonOptimalDetectionAntibodyDilutionWarnings],Cache->simulatedCache]<>" (used for ELISA experiment of "<>ObjectToString[PickList[mySamples,nonOptimalDetectionAntibodyDilutionWarnings],Cache->simulatedCache]<>") is close to 3.5 Microgram/Milliliter:",False,True]
			];

			{failingTest,passingTest}
		],
		{}
	];


    (* Check the SamplesIn storage condition validation *)
    (* For our antibody samples, we already did the checks earlier to make sure we are not doing different processing for the same objects. When different processings are required, we get separate resources in resource packets *)
    (* Get all samples - SamplesIn, Standard and SpikeSample together with their storage conditiond *)
    allSamples=Join[
      simulatedSamples,
      ToList[resolvedStandard/.Null->{}],
      resolvedSpikeSample
    ];
    allStorageConditions=Join[
      Lookup[roundedCapillaryELISAOptionsAssociation,SamplesInStorageCondition],
      If[MatchQ[resolvedStandard,Null],
        {},
        resolvedStandardStorageCondition
      ],
      resolvedSpikeSampleStorageCondition
    ];

    allSamplesWithStorageConditions=GatherBy[Transpose[{allSamples,allStorageConditions}],First];
    uniqueSamplesWithStorageConditions=DeleteDuplicates[DeleteCases[#,{Null,_}|{ObjectP[Model],_}]]&/@allSamplesWithStorageConditions;

    conflictSamplesWithStorageConditions=Map[
      If[Length[#]>1,
        #[[1,1]],
        Nothing
      ]&,
      uniqueSamplesWithStorageConditions
    ];

    (* Throw an error message when we find the storage condition conflict and add the related options *)
    conflictSampleStorageOptions={
      If[MatchQ[Intersection[simulatedSamples,conflictSamplesWithStorageConditions],{}],
        Nothing,
        SamplesInStorageCondition
      ],
      If[MatchQ[Intersection[ToList[resolvedStandard],conflictSamplesWithStorageConditions],{}],
        Nothing,
        StandardStorageCondition
      ],
      If[MatchQ[Intersection[resolvedSpikeSample,conflictSamplesWithStorageConditions],{}],
        Nothing,
        SpikeSampleStorageCondition
      ]
    };

    If[Length[conflictSamplesWithStorageConditions]>0,
      Message[Error::CapillaryELISAConflictingStorageConditions,ObjectToString[conflictSamplesWithStorageConditions,Cache->simulatedCache],ToString[conflictSampleStorageOptions]]
    ];

    (* Generate the tests *)
    conflictSampleStorageConditionTest=Test["The same sample object should not be given different storage conditions in SamplesInStorageCondition, StandardStorageCondition and SpikeSampleStorageCondition if it is used more than once.",MatchQ[conflictSampleStorageOptions,{}],True];

    (* Also check if the samples share the same plate, they should have the same storage conditions as well *)
    (* Here we call the shared function ValidContainerStorageConditionQ. It will throw its own error messages *)
    uniqueSamplesForContainerCheck=DeleteCases[Flatten[uniqueSamplesWithStorageConditions,1],{_,Null}][[All,1]];
    uniqueStorageConditionsForContainerCheck=DeleteCases[Flatten[uniqueSamplesWithStorageConditions,1],{_,Null}][[All,2]];
    {validContainerStorageConditionResult,validContainerStorageConditionTests}=Which[
      !gatherTests&&!MatchQ[uniqueSamplesForContainerCheck,{}],
      {ValidContainerStorageConditionQ[uniqueSamplesForContainerCheck,uniqueStorageConditionsForContainerCheck,Output->Result,Cache->simulatedCache],{}},
      gatherTests&&!MatchQ[uniqueSamplesForContainerCheck,{}],
      ValidContainerStorageConditionQ[uniqueSamplesForContainerCheck,uniqueStorageConditionsForContainerCheck,Output->{Result,Tests},Cache->simulatedCache],
      True,{{},{}}
    ];

    (* Track if we get invalid storage conditions. The invalid options may be too many but the user should check. *)
    invalidContainerStorageOptions=If[MemberQ[validContainerStorageConditionResult,False],
      {
        SamplesInStorageCondition,
        If[NullQ[resolvedStandard],
          Nothing,
          StandardStorageCondition
        ],
        If[MemberQ[resolvedSpikeSample,Except[Null]],
          SpikeSampleStorageCondition,
          Nothing
        ]
      },
      {}
    ];



    (* SUMMARY *)
	(* Check our invalid input and invalid option variables and throw Error::InvalidInput or Error::InvalidOption if necessary. *)
    invalidInputs=DeleteDuplicates[Flatten[{{discardedInvalidInputs,tooManyInvalidInputs,invalidSpikeOptionInputs,missingSpikeOptionInputs}}]];

    invalidOptions=DeleteDuplicates[Flatten[{
		tooManyInvalidOption,
		nameInvalidOption,
		instrumentInvalidOption,
		discardedCartridgeInvalidOption,
		tooManyLoadingSamplesOptions,
		exceedCartridgeCapacityOption,
		invalidCustomizableCartridgeTypeOptions,
		conflictCartridgeTypeOptions,
		conflictCartridgeAndAnalytesOptions,
		conflictPreLoadedAnalytesOptions,
		exceedLengthAnalytesOptions,
		conflictMultiPlexCartridgeTypeOptions,
		duplicatedAnalytesOption,
		tooManyAnalytesOption,
		tooManyAnalytesForSampleNumberOption,
		unsupportedAnalytesOption,
		wrongSpeciesAnalytesOption,
		wrongCartridgeTypeAnalytesOption,
		incompatibleAnalyteDiluentOption,
		incompatibleAnalyteMinDilutionFactorOption,
		incompatibleAnalytesOption,
		invalidSpikeOptions,
		nonLiquidSpikeOption,
		missingSpikeOptions,
		wrongAnalyteSpikeConcentrationOption,
		notEnoughSampleSpikeVolumeOptions,
		conflictDilutionCurveOptions,
		exceedDilutionLoadingVolumeOptions,
		invalidDilutionCurveOption,
        invalidDilutionMixVolumeOption,
		invalidAntibodyRelatedOptions,
		solidCaptureAntibodyResuspensionInvalidOption,
		liquidCaptureAntibodyResuspensionInvalidOption,
		invalidCaptureAntibodyResuspensionOptions,
		missingCaptureAntibodyResuspensionOptions,
		invalidCaptureAntibodyConjugationOptions,
		missingCaptureAntibodyConjugationOptions,
		captureAntibodyConjugationConflictOptions,
		unsupportedCaptureAntibodyPurificationColumnOption,
		invalidCaptureAntibodyDilutionOptions,
		missingCaptureAntibodyDilutionOptions,
		captureAntibodyDilutionConflictOptions,
		missingCaptureAntibodyLoadingVolumeOption,
		solidDetectionAntibodyResuspensionInvalidOption,
		liquidDetectionAntibodyResuspensionInvalidOption,
		invalidDetectionAntibodyResuspensionOptions,
		missingDetectionAntibodyResuspensionOptions,
		invalidDetectionAntibodyConjugationOptions,
		missingDetectionAntibodyConjugationOptions,
		detectionAntibodyConjugationConflictOptions,
		unsupportedDetectionAntibodyPurificationColumnOption,
		invalidDetectionAntibodyDilutionOptions,
		missingDetectionAntibodyDilutionOptions,
		detectionAntibodyDilutionConflictOptions,
		missingDetectionAntibodyLoadingVolumeOption,
		nullStandardMemberOption,
		invalidStandardOptions,
		solidStandardResuspensionInvalidOption,
		liquidStandardResuspensionInvalidOption,
		invalidStandardResuspensionOptions,
		missingStandardResuspensionOptions,
		missingStandardRelatedOptions,
		conflictStandardDilutionCurveOptions,
		exceedStandardDilutionLoadingVolumeOptions,
		invalidStandardDilutionCurveOption,
        invalidStandardDilutionMixVolumeOption,
		exceedStandardStandardCompositionOption,
		wrongAnalyteStandardCompositionOption,
		invalidStandardAntibodyRelatedOptions,
		solidStandardCaptureAntibodyResuspensionInvalidOption,
		liquidStandardCaptureAntibodyResuspensionInvalidOption,
		invalidStandardCaptureAntibodyResuspensionOptions,
		missingStandardCaptureAntibodyResuspensionOptions,
		invalidStandardCaptureAntibodyConjugationOptions,
		missingStandardCaptureAntibodyConjugationOptions,
		standardCaptureAntibodyConjugationConflictOptions,
		unsupportedStandardCaptureAntibodyPurificationColumnOption,
		invalidStandardCaptureAntibodyDilutionOptions,
		missingStandardCaptureAntibodyDilutionOptions,
		standardCaptureAntibodyDilutionConflictOptions,
		missingStandardCaptureAntibodyLoadingVolumeOption,
		solidStandardDetectionAntibodyResuspensionInvalidOption,
		liquidStandardDetectionAntibodyResuspensionInvalidOption,
		invalidStandardDetectionAntibodyResuspensionOptions,
		missingStandardDetectionAntibodyResuspensionOptions,
		invalidStandardDetectionAntibodyConjugationOptions,
		missingStandardDetectionAntibodyConjugationOptions,
		standardDetectionAntibodyConjugationConflictOptions,
		unsupportedStandardDetectionAntibodyPurificationColumnOption,
		invalidStandardDetectionAntibodyDilutionOptions,
		missingStandardDetectionAntibodyDilutionOptions,
		standardDetectionAntibodyDilutionConflictOptions,
		missingStandardDetectionAntibodyLoadingVolumeOption,
		conflictAntibodyObjectSampleOptions,
		conflictOptionValueAntibodyOptions,
		missingPreLoadedAnalytesOption,
		standardOptionLengthInvalidOptions,
		incompleteResolvedStandardCompositionOption,
		missingStandardCaptureAntibodyOptions,
		missingStandardDetectionAntibodyOptions,
		missingStandardDigoxigeninReagentVolumeOptions,
		missingStandardBiotinReagentVolumeOptions,
		exceedStandardCaptureAntibodyConjugationContainerOption,
		exceedStandardDetectionAntibodyConjugationContainerOption,
		exceedStandardCaptureAntibodyPurificationColumnOption,
		exceedStandardDetectionAntibodyPurificationColumnOption,
		tooHighStandardCaptureAntibodyDilutionOption,
		tooHighStandardDetectionAntibodyDilutionOption,
		incompleteResolvedSpikeConcentrationOption,
		missingCaptureAntibodyOptions,
		missingDetectionAntibodyOptions,
		missingDigoxigeninReagentVolumeOptions,
		missingBiotinReagentVolumeOptions,
		exceedCaptureAntibodyConjugationContainerOption,
		exceedDetectionAntibodyConjugationContainerOption,
		exceedCaptureAntibodyPurificationColumnOption,
		exceedDetectionAntibodyPurificationColumnOption,
		tooHighCaptureAntibodyDilutionOption,
		tooHighDetectionAntibodyDilutionOption,
      conflictSampleStorageOptions,
      invalidContainerStorageOptions
	}]];

    (* Throw Error::InvalidInput if there are invalid inputs. *)
    If[Length[invalidInputs]>0&&!gatherTests,
        Message[Error::InvalidInput,ObjectToString[invalidInputs,Cache->simulatedCache]]
    ];

    (* Throw Error::InvalidOption if there are invalid options. *)
    If[Length[invalidOptions]>0&&!gatherTests,
        Message[Error::InvalidOption,invalidOptions]
    ];

    (*-- CONTAINER GROUPING RESOLUTION --*)
    (* Resolve RequiredAliquotContainers *)
    (* targetContainers is in the form {(Null|ObjectP[Model[Container]])..} and is index-matched to simulatedSamples. *)
    (* When you do not want an aliquot to happen for the corresponding simulated sample, make the corresponding index of targetContainers Null. *)
    (* Otherwise, make it the Model[Container] that you want to transfer the sample into. *)
    (* Here we only want our samples to be in a hamilton liquid handler compatible container before starting the dilution or spiking process. Then they are transferred out of the aliquot liquid handling compatible containers for dilution or spiking. *)
    (* Note that there is no way that the sample is already in a capillary ELISA cartridge or dilution happens directly in the capillary ELISA cartridge! *)

    (* Check the total required volume of the simulated samples *)
    requiredSampleVolumes=MapThread[
        If[MatchQ[#1,GreaterEqualP[0Microliter]],

            (* Use user defined sample volume. We only require this when Spike is specified so there are cases that it is Null. *)
            #1,

            (* After resolver, neither of DilutionCurve and SerialDilutionCurve should be Automatic. We can safely set default volume to 0 Microliter as it is not used. *)
			resolveRequiredSampleVolumeForDilution[#2,#3,0Microliter]
        ]&,
        {resolvedSampleVolume,resolvedDilutionCurve,resolvedSerialDilutionCurve}
    ];

    (* Determine the target container of each sample. If it is already in a liquid handler compatible container, then we don't need to transfer the sample. If not, transfer to a hamilton compatible container depending on the volume of the sample. There is very low chance that the required volume is larger than 2 Milliliter because of the volume limitation of the capillary ELISA cartridge. 2 Milliliter here is for the high centrifuge speed we need *)
    targetContainers=MapThread[
        Function[{sample,packet,container,volume},
            Which[
				(* Do not transfer a solid sample. An error will be thrown in resolveAliquotOptions. We can try to avoid more errors here *)
				MatchQ[Lookup[packet,State],Solid],Null,
				(* No need to transfer if already in a 2mL Tube or the preferred container of the volume *)
				MatchQ[container,PreferredContainer[Max[volume,1.9 Milliliter]]],Null,
				True,PreferredContainer[Max[volume,1.9 Milliliter]]
            ]
        ],
        {simulatedSamples,simulatedSamplePackets,simulatedSampleContainerModels,requiredSampleVolumes}
    ];

    (* Resolve Aliquot Options *)

    (* Resolve our aliquot options. *)
    {resolvedAliquotOptions,aliquotTests}=If[gatherTests,
        resolveAliquotOptions[
            ExperimentCapillaryELISA,
            mySamples,
            simulatedSamples,
            ReplaceRule[myOptions,resolvedSamplePrepOptions],
            Cache->simulatedCache,
            RequiredAliquotAmounts->requiredSampleVolumes,
            RequiredAliquotContainers->targetContainers,
            Output->{Result,Tests}
        ],
        {
            resolveAliquotOptions[
                ExperimentCapillaryELISA,
                mySamples,
                simulatedSamples,
                ReplaceRule[myOptions,resolvedSamplePrepOptions],
                Cache->simulatedCache,
                RequiredAliquotAmounts->requiredSampleVolumes,
                RequiredAliquotContainers->targetContainers,
                Output->Result
            ],
            {}
        }
    ];

	(* Post Process the aliquot options *)
	(* Define the aliquot options to be rounded *)
	aliquotOptionsToBeRounded = {
		AssayVolume,
		AliquotAmount
	};

	(* Define the aliquot precisions *)
	aliquotPrecisions = {10^-1 Microliter,10^-1 Microliter};

	(* Round the aliquot options *)
	roundedAliquotOptions = Normal[RoundOptionPrecision[Association@resolvedAliquotOptions,aliquotOptionsToBeRounded,aliquotPrecisions],Association];

    (* We don't have incompatible materials for Capillary ELISA instrument *)

    (* Resolve Post Processing Options *)
    resolvedPostProcessingOptions=resolvePostProcessingOptions[myOptions];

    (* Return our resolved options and/or tests. *)
    resolvedOptions={
		Instrument->resolvedInstrument,
		CartridgeType->resolvedCartridgeType,
		Cartridge->resolvedCartridge,
		Species->resolvedSpecies,
		Analytes->resolvedAnalytes,
		SampleVolume->resolvedSampleVolume,
		SpikeSample->resolvedSpikeSample,
		SpikeVolume->resolvedSpikeVolume,
		SpikeSampleStorageCondition->resolvedSpikeSampleStorageCondition,
		DilutionCurve->resolvedDilutionCurve,
		SerialDilutionCurve->resolvedSerialDilutionCurve,
		Diluent->resolvedDiluent,
		DilutionMixVolume->resolvedDilutionMixVolume,
		DilutionNumberOfMixes->resolvedDilutionNumberOfMixes,
		DilutionMixRate->resolvedDilutionMixRate,
		CustomCaptureAntibody->resolvedCustomCaptureAntibody,
		CaptureAntibodyResuspension->resolvedCaptureAntibodyResuspension,
		CaptureAntibodyResuspensionConcentration->resolvedCaptureAntibodyResuspensionConcentration,
		CaptureAntibodyResuspensionDiluent->resolvedCaptureAntibodyResuspensionDiluent,
		CaptureAntibodyStorageCondition->resolvedCaptureAntibodyStorageCondition,
		CaptureAntibodyConjugation->resolvedCaptureAntibodyConjugation,
		CaptureAntibodyVolume->resolvedCaptureAntibodyVolume,
		DigoxigeninReagent->resolvedDigoxigeninReagent,
		DigoxigeninReagentVolume->resolvedDigoxigeninReagentVolume,
		CaptureAntibodyConjugationBuffer->resolvedCaptureAntibodyConjugationBuffer,
		CaptureAntibodyConjugationBufferVolume->resolvedCaptureAntibodyConjugationBufferVolume,
		CaptureAntibodyConjugationContainer->resolvedCaptureAntibodyConjugationContainer,
		CaptureAntibodyConjugationTime->resolvedCaptureAntibodyConjugationTime,
		CaptureAntibodyConjugationTemperature->resolvedCaptureAntibodyConjugationTemperature,
		CaptureAntibodyPurificationColumn->resolvedCaptureAntibodyPurificationColumn,
		CaptureAntibodyColumnWashBuffer->resolvedCaptureAntibodyColumnWashBuffer,
		CaptureAntibodyConjugationStorageCondition->resolvedCaptureAntibodyConjugationStorageCondition,
		CaptureAntibodyDilution->resolvedCaptureAntibodyDilution,
		CaptureAntibodyTargetConcentration->resolvedCaptureAntibodyTargetConcentration,
		CaptureAntibodyDiluent->resolvedCaptureAntibodyDiluent,
		CustomDetectionAntibody->resolvedCustomDetectionAntibody,
		DetectionAntibodyResuspension->resolvedDetectionAntibodyResuspension,
		DetectionAntibodyResuspensionConcentration->resolvedDetectionAntibodyResuspensionConcentration,
		DetectionAntibodyResuspensionDiluent->resolvedDetectionAntibodyResuspensionDiluent,
		DetectionAntibodyStorageCondition->resolvedDetectionAntibodyStorageCondition,
		DetectionAntibodyConjugation->resolvedDetectionAntibodyConjugation,
		DetectionAntibodyVolume->resolvedDetectionAntibodyVolume,
		BiotinReagent->resolvedBiotinReagent,
		BiotinReagentVolume->resolvedBiotinReagentVolume,
		DetectionAntibodyConjugationBuffer->resolvedDetectionAntibodyConjugationBuffer,
		DetectionAntibodyConjugationBufferVolume->resolvedDetectionAntibodyConjugationBufferVolume,
		DetectionAntibodyConjugationContainer->resolvedDetectionAntibodyConjugationContainer,
		DetectionAntibodyConjugationTime->resolvedDetectionAntibodyConjugationTime,
		DetectionAntibodyConjugationTemperature->resolvedDetectionAntibodyConjugationTemperature,
		DetectionAntibodyPurificationColumn->resolvedDetectionAntibodyPurificationColumn,
		DetectionAntibodyColumnWashBuffer->resolvedDetectionAntibodyColumnWashBuffer,
		DetectionAntibodyConjugationStorageCondition->resolvedDetectionAntibodyConjugationStorageCondition,
		DetectionAntibodyDilution->resolvedDetectionAntibodyDilution,
		DetectionAntibodyTargetConcentration->resolvedDetectionAntibodyTargetConcentration,
		DetectionAntibodyDiluent->resolvedDetectionAntibodyDiluent,
		Standard->resolvedStandard,
		StandardResuspension->resolvedStandardResuspension,
		StandardResuspensionConcentration->resolvedStandardResuspensionConcentration,
		StandardResuspensionDiluent->resolvedStandardResuspensionDiluent,
		StandardStorageCondition->resolvedStandardStorageCondition,
		StandardDilutionCurve->resolvedStandardDilutionCurve,
		StandardSerialDilutionCurve->resolvedStandardSerialDilutionCurve,
		StandardDiluent->resolvedStandardDiluent,
		StandardDilutionMixVolume->resolvedStandardDilutionMixVolume,
		StandardDilutionNumberOfMixes->resolvedStandardDilutionNumberOfMixes,
		StandardDilutionMixRate->resolvedStandardDilutionMixRate,
		StandardCaptureAntibody->resolvedStandardCaptureAntibody,
		StandardCaptureAntibodyResuspension->resolvedStandardCaptureAntibodyResuspension,
		StandardCaptureAntibodyResuspensionConcentration->resolvedStandardCaptureAntibodyResuspensionConcentration,
		StandardCaptureAntibodyResuspensionDiluent->resolvedStandardCaptureAntibodyResuspensionDiluent,
		StandardCaptureAntibodyStorageCondition->resolvedStandardCaptureAntibodyStorageCondition,
		StandardCaptureAntibodyConjugation->resolvedStandardCaptureAntibodyConjugation,
		StandardCaptureAntibodyVolume->resolvedStandardCaptureAntibodyVolume,
		StandardDigoxigeninReagent->resolvedStandardDigoxigeninReagent,
		StandardDigoxigeninReagentVolume->resolvedStandardDigoxigeninReagentVolume,
		StandardCaptureAntibodyConjugationBuffer->resolvedStandardCaptureAntibodyConjugationBuffer,
		StandardCaptureAntibodyConjugationBufferVolume->resolvedStandardCaptureAntibodyConjugationBufferVolume,
		StandardCaptureAntibodyConjugationContainer->resolvedStandardCaptureAntibodyConjugationContainer,
		StandardCaptureAntibodyConjugationTime->resolvedStandardCaptureAntibodyConjugationTime,
		StandardCaptureAntibodyConjugationTemperature->resolvedStandardCaptureAntibodyConjugationTemperature,
		StandardCaptureAntibodyPurificationColumn->resolvedStandardCaptureAntibodyPurificationColumn,
		StandardCaptureAntibodyColumnWashBuffer->resolvedStandardCaptureAntibodyColumnWashBuffer,
		StandardCaptureAntibodyConjugationStorageCondition->resolvedStandardCaptureAntibodyConjugationStorageCondition,
		StandardCaptureAntibodyDilution->resolvedStandardCaptureAntibodyDilution,
		StandardCaptureAntibodyTargetConcentration->resolvedStandardCaptureAntibodyTargetConcentration,
		StandardCaptureAntibodyDiluent->resolvedStandardCaptureAntibodyDiluent,
		StandardDetectionAntibody->resolvedStandardDetectionAntibody,
		StandardDetectionAntibodyResuspension->resolvedStandardDetectionAntibodyResuspension,
		StandardDetectionAntibodyResuspensionConcentration->resolvedStandardDetectionAntibodyResuspensionConcentration,
		StandardDetectionAntibodyResuspensionDiluent->resolvedStandardDetectionAntibodyResuspensionDiluent,
		StandardDetectionAntibodyStorageCondition->resolvedStandardDetectionAntibodyStorageCondition,
		StandardDetectionAntibodyConjugation->resolvedStandardDetectionAntibodyConjugation,
		StandardDetectionAntibodyVolume->resolvedStandardDetectionAntibodyVolume,
		StandardBiotinReagent->resolvedStandardBiotinReagent,
		StandardBiotinReagentVolume->resolvedStandardBiotinReagentVolume,
		StandardDetectionAntibodyConjugationBuffer->resolvedStandardDetectionAntibodyConjugationBuffer,
		StandardDetectionAntibodyConjugationBufferVolume->resolvedStandardDetectionAntibodyConjugationBufferVolume,
		StandardDetectionAntibodyConjugationContainer->resolvedStandardDetectionAntibodyConjugationContainer,
		StandardDetectionAntibodyConjugationTime->resolvedStandardDetectionAntibodyConjugationTime,
		StandardDetectionAntibodyConjugationTemperature->resolvedStandardDetectionAntibodyConjugationTemperature,
		StandardDetectionAntibodyPurificationColumn->resolvedStandardDetectionAntibodyPurificationColumn,
		StandardDetectionAntibodyColumnWashBuffer->resolvedStandardDetectionAntibodyColumnWashBuffer,
		StandardDetectionAntibodyConjugationStorageCondition->resolvedStandardDetectionAntibodyConjugationStorageCondition,
		StandardDetectionAntibodyDilution->resolvedStandardDetectionAntibodyDilution,
		StandardDetectionAntibodyTargetConcentration->resolvedStandardDetectionAntibodyTargetConcentration,
		StandardDetectionAntibodyDiluent->resolvedStandardDetectionAntibodyDiluent,
		WashBuffer->resolvedWashBuffer,
		LoadingVolume->resolvedLoadingVolume,
		CaptureAntibodyLoadingVolume->resolvedCaptureAntibodyLoadingVolume,
		DetectionAntibodyLoadingVolume->resolvedDetectionAntibodyLoadingVolume,
		StandardLoadingVolume->resolvedStandardLoadingVolume,
		StandardCaptureAntibodyLoadingVolume->resolvedStandardCaptureAntibodyLoadingVolume,
		StandardDetectionAntibodyLoadingVolume->resolvedStandardDetectionAntibodyLoadingVolume,
		StandardComposition->resolvedStandardComposition,
		SpikeConcentration->resolvedSpikeConcentration,
		SamplesInStorageCondition->resolvedSamplesInStorageCondition,
		Confirm->resolvedConfirm,
        Name->resolvedName,
        Template->resolvedTemplate,
        SamplesInStorageCondition->resolvedSamplesInStorageCondition,
        Cache->resolvedCache,
        FastTrack->resolvedFastTrack,
        Operator->resolvedOperator,
        Output->resolvedOutput,
        ParentProtocol->resolvedParentProtocol,
        Upload->resolvedUpload,
		PreparatoryUnitOperations->resolvedPreparatoryPrimitives,
      PreparatoryPrimitives->Lookup[roundedCapillaryELISAOptionsAssociation, PreparatoryPrimitives],
		NumberOfReplicates->resolvedNumberOfReplicates
    };

    allOptions=Flatten[Join[resolvedOptions,resolvedSamplePrepOptions,roundedAliquotOptions,resolvedPostProcessingOptions]];

    allTests=Flatten[
		{
			samplePrepTests,
			aliquotTests,
			discardedTest,tooManyInputsTests,allRoundingTests,
			validNameTest,notRetiredInstrumentTests,notDeprecatedInstrumentTests, discardedCartridgeInvalidTest,tooManyLoadingSamplesTests,exceedCartridgeCapacityTests,invalidCustomizableCartridgeTypeTests,conflictCartridgeTypeTests,conflictCartridgeAndAnalytesTests,conflictPreLoadedAnalytesTests,exceedLengthAnalytesTests, conflictMultiPlexCartridgeTypeTests,duplicatedAnalytesTests,tooManyAnalytesTests,tooManyAnalytesForSampleNumberTests,unsupportedAnalytesTests,wrongSpeciesAnalytesTests, wrongCartridgeTypeAnalytesTests,incompatibleAnalyteDiluentTests,incompatibleAnalyteDilutionFactorTests,incompatibleAnalytesTests,
			invalidSpikeTests,nonLiquidSpikeTests,missingSpikeOptionTests,wrongAnalyteSpikeConcentrationTests,notEnoughSampleSpikeVolumeTests,conflictDilutionCurveTests,mandatoryDilutionTests,nonOptimalLoadingVolumeTests,exceedDilutionLoadingVolumeTests,invalidDilutionCurveTests,invalidDilutionMixVolumeTests,
			invalidAntibodyRelatedTests,
			captureAntibodyResuspensionInvalidTests,invalidCaptureAntibodyResuspensionTests,missingCaptureAntibodyResuspensionTests,invalidCaptureAntibodyConjugationTests,missingCaptureAntibodyConjugationTests,captureAntibodyConjugationOptionConflictTests,unsupportedCaptureAntibodyPurificationColumnTests,nonOptimalCaptureAntibodyPurificationColumnTests,invalidCaptureAntibodyDilutionTests,missingRecommendedCaptureAntibodyDilutionTests,missingCaptureAntibodyDilutionOptionTests,captureAntibodyDilutionOptionConflictTests,nonOptimalCaptureAntibodyDiluentTests,missingCaptureAntibodyLoadingVolumeTests,
			detectionAntibodyResuspensionInvalidTests,invalidDetectionAntibodyResuspensionTests,missingDetectionAntibodyResuspensionTests,invalidDetectionAntibodyConjugationTests,missingDetectionAntibodyConjugationTests,detectionAntibodyConjugationOptionConflictTests, unsupportedDetectionAntibodyPurificationColumnTests,nonOptimalDetectionAntibodyPurificationColumnTests,invalidDetectionAntibodyDilutionTests,missingRecommendedDetectionAntibodyDilutionTests,missingDetectionAntibodyDilutionOptionTests,detectionAntibodyDilutionOptionConflictTests,nonOptimalDetectionAntibodyDiluentTests,missingDetectionAntibodyLoadingVolumeTests, nullStandardMemberTests,
			invalidStandardTests,standardResuspensionInvalidTests,invalidStandardResuspensionTests,missingStandardResuspensionTests,missingStandardRelatedOptionsTests,conflictStandardDilutionCurveTests,mandatoryStandardDilutionTests,nonOptimalStandardDilutionCurveTests,nonOptimalStandardLoadingVolumeTests,exceedStandardDilutionLoadingVolumeTests,invalidStandardDilutionCurveTests,invalidStandardDilutionMixVolumeTests,conflictStandardCompositionTests,exceedStandardStandardCompositionTests,wrongAnalyteStandardCompositionOption,wrongAnalyteStandardCompositionTests,
			invalidStandardAntibodyRelatedTests,
			standardCaptureAntibodyResuspensionInvalidTests,invalidStandardCaptureAntibodyResuspensionTests,missingStandardCaptureAntibodyResuspensionTests,invalidStandardCaptureAntibodyConjugationTests, missingStandardCaptureAntibodyConjugationTests,standardCaptureAntibodyConjugationOptionConflictTests,unsupportedStandardCaptureAntibodyPurificationColumnTests,nonOptimalStandardCaptureAntibodyPurificationColumnTests,invalidStandardCaptureAntibodyDilutionTests,missingRecommendedStandardCaptureAntibodyDilutionTests,missingStandardCaptureAntibodyDilutionOptionTests,standardCaptureAntibodyDilutionOptionConflictTests,nonOptimalStandardCaptureAntibodyDiluentTests,missingStandardCaptureAntibodyLoadingVolumeTests,
			standardDetectionAntibodyResuspensionInvalidTests,invalidStandardDetectionAntibodyResuspensionTests,missingStandardDetectionAntibodyResuspensionTests,invalidStandardDetectionAntibodyConjugationTests,missingStandardDetectionAntibodyConjugationTests,standardDetectionAntibodyConjugationOptionConflictTests,unsupportedStandardDetectionAntibodyPurificationColumnTests, nonOptimalStandardDetectionAntibodyPurificationColumnTests,invalidStandardDetectionAntibodyDilutionTests,missingRecommendedStandardDetectionAntibodyDilutionTests,missingStandardDetectionAntibodyDilutionOptionTests,standardDetectionAntibodyDilutionOptionConflictTests,nonOptimalStandardDetectionAntibodyDiluentTests,missingStandardDetectionAntibodyLoadingVolumeTests,
			nonOptimalWashBufferTests,conflictAntibodyObjectSampleTests,conflictOptionValueAntibodyTests,longLeadTimeCartridgeTests,missingPreLoadedAnalytesTests,emptyCartridgeChannelTests,standardOptionLengthInvalidTests,
			nonOptimalStandardResuspensionTests,incompleteResolvedStandardCompositionTests,nonOptimalStandardDiluentTests,conflictStandardAntibodyEpitopeTests,antibodyAssayTypeQualificationTests,missingStandardCaptureAntibodyTests,missingStandardDetectionAntibodyTests,missingStandardDigoxigeninReagentVolumeTests,missingStandardBiotinReagentVolumeTests,notEnoughStandardDigoxigeninReagentVolumeTests,notEnoughStandardBiotinReagentVolumeTests,exceedStandardCaptureAntibodyConjugationContainerTests,exceedStandardDetectionAntibodyConjugationContainerTests,exceedStandardCaptureAntibodyPurificationColumnTests,exceedStandardDetectionAntibodyPurificationColumnTests,tooHighStandardCaptureAntibodyDilutionTests,tooHighStandardDetectionAntibodyDilutionTests,nonOptimalStandardCaptureAntibodyDilutionTests,nonOptimalStandardDetectionAntibodyDilutionTests,
			incompleteResolvedSpikeConcentrationTests,nonOptimalDilutionTests,conflictAntibodyEpitopeTests,missingCaptureAntibodyTests,missingDetectionAntibodyTests,missingDigoxigeninReagentVolumeTests,missingBiotinReagentVolumeTests,notEnoughDigoxigeninReagentVolumeTests,notEnoughBiotinReagentVolumeTests,exceedCaptureAntibodyConjugationContainerTests,exceedDetectionAntibodyConjugationContainerTests,exceedCaptureAntibodyPurificationColumnTests,exceedDetectionAntibodyPurificationColumnTests,tooHighCaptureAntibodyDilutionTests,tooHighDetectionAntibodyDilutionTests,nonOptimalCaptureAntibodyDilutionTests,nonOptimalDetectionAntibodyDilutionTests,conflictSampleStorageConditionTest,validContainerStorageConditionTests
		}
    ];

    outputSpecification/.{
        Result->allOptions,
        Tests->allTests
    }
];


(* ::Subsubsection::Closed:: *)
(* Private Helper Functions for resolveExperimentCapillaryELISAOptions *)


(* ::Subsubsubsection::Closed:: *)
(* selectCapillaryELISAAnalyteFromSample *)

(* A private helper function find what analytes to work on for the samples in capillary ELISA experiment through downloading information from the samples.
The function is similar to Experiment`Private`selectAnalyteFromSample in ExperimentAbsorbanceSpectroscopy but changed to select only the possible pre-loaded cartridge analytes and the analytes with identity model of Model[Molecule,Protein] or Model[Molecule,Protein,Antibody]. *)

(* findPreLoadedCartridgeAnalytes - Find Analytes that are available for pre-loaded cartridge from ProteinSimple, reflected in Type Object[ManufacturingSpecification,CapillaryELISACartridge]. This is an updating list. *)

DefineOptions[findPreLoadedCartridgeAnalytes,
    Options:>{
        CacheOption
    }
];

findPreLoadedCartridgeAnalytes[ops:OptionsPattern[]]:=Module[

    {safeOps,cache,allAnalytes},

    (* Get the Cache option *)
    safeOps=SafeOptions[findPreLoadedCartridgeAnalytes,ToList[ops]];
    cache=Lookup[safeOps,Cache];

	allAnalytes=DeleteDuplicates[
        (* Delete Null from the available Analytes, just in case this happens *)
        DeleteCases[

            (* Get all identity models from Analyte field in Object[ManufacturingSpecification,CapillaryELISACartridge]. *)
            Download[Search[Object[ManufacturingSpecification,CapillaryELISACartridge]],AnalyteMolecule[Object],Cache->cache,Date->Now],
            Null
        ]
    ]
];

DefineOptions[selectCapillaryELISAAnalyteFromSample,
    Options:>{
        CacheOption
    }
];

selectCapillaryELISAAnalyteFromSample[mySample:ObjectP[{Object[Sample], Model[Sample]}],ops:OptionsPattern[]]:=selectCapillaryELISAAnalyteFromSample[{mySample}, ops];
selectCapillaryELISAAnalyteFromSample[mySamples:{ObjectP[{Object[Sample], Model[Sample]}]..},ops:OptionsPattern[]]:=Module[
    {
        safeOps,cache,fastCacheLookup,
        proteinAnalyteP,preLoadedCartridgeAnalytes,preLoadedCartridgeAnalyteP,allPackets,analyteObjs,compositionObjs,
        preLoadedAnalytesToUse,customizableAnalytesToUse
    },

    (* Get the Cache option *)
    safeOps=SafeOptions[selectCapillaryELISAAnalyteFromSample,ToList[ops]];
    cache=Lookup[safeOps,Cache];
    fastCacheLookup=makeFastAssocFromCache[cache];

    (* Identity model of Model[Molecule,Protein] or Model[Molecule,Protein,Antibody] to be used for Customizable cartridge analytes - so that we can automatically resolve its Antibodies. If other types of identity models are somehow analyzed in capillary ELISA, we cannot resolve the antibodies as there is not Antibodies/SecondaryAntibodies field. *)
    proteinAnalyteP=ObjectP[{Model[Molecule,Protein],Model[Molecule,Protein,Antibody]}];

    (* Pattern for preLoadedCartridgeAnalytes *)
    preLoadedCartridgeAnalytes=findPreLoadedCartridgeAnalytes[Cache->cache];
    preLoadedCartridgeAnalyteP=ObjectP[preLoadedCartridgeAnalytes];

    (* Get the composition and analytes fields from all the input samples or models *)
    allPackets=Experiment`Private`fetchPacketFromFastAssoc[#,fastCacheLookup]&/@mySamples;

    (* Get the analyte objects and the composition objects *)
    analyteObjs=Download[Lookup[#,Analytes],Object]&/@allPackets;
    compositionObjs=Download[Lookup[#,Composition][[All,2]],Object]&/@allPackets;

    (* If Analytes field and/or Composition field is populated, pick all pre-loaded cartridge analyte from it *)
    preLoadedAnalytesToUse=Flatten[
        MapThread[
            Function[{composition,analytes},
                DeleteDuplicates[
                    Join[
                        Cases[composition,preLoadedCartridgeAnalyteP],
                        Cases[analytes,preLoadedCartridgeAnalyteP]
                    ]
                ]
            ],
            {compositionObjs,analyteObjs}
        ]
    ];

    (* For customizable cartridge, pick an analyte that matches proteinAnalyteP *)
    (* If Analytes field is populated, pick the first value that matches proteinAnalyteP if available *)
    (* If no qualified member is available from Analytes field, pick the first prteinAnalyteP identity model in the Composition field *)
    (* Otherwise, pick Null *)

    (* Parse the Analytes and Composition fields to find the correct analytes to use *)
    customizableAnalytesToUse=MapThread[
        Function[{composition, analytes},
            Which[
                MemberQ[analytes,proteinAnalyteP],FirstCase[analytes,proteinAnalyteP],
                MemberQ[composition,proteinAnalyteP],FirstCase[composition,proteinAnalyteP],
                True,Null
            ]
        ],
        {compositionObjs, analyteObjs}
    ];

    (* Pass the results back to the main function. Here the pre-loaded analytes is a single list with a length of any possible value. The customizable cartridge list is 1 per sample. *)
    {preLoadedAnalytesToUse,customizableAnalytesToUse}

];


(* ::Subsubsubsection::Closed:: *)
(* resolveCapillaryELISACartridge *)

resolveCapillaryELISACartridge[myAnalytes:{ObjectP[Model[Molecule]]...},myNumberOfSamples_Integer,suppliedCartridgeType_,suppliedAnalytes_]:=Module[
    {
        requiredPreLoadedCartridgeType,qualifiedStockedCartridges,qualifiedModelCartridges,qualifiedSinglePlexModelCartridges,bestCartridge
    },

    requiredPreLoadedCartridgeType=Which[

        (* When user selected Customizable for CartridgeType, we do search for all pre-loaded cartridges. When set to Customizable, we will return Customizable model later *)
        MatchQ[suppliedCartridgeType,Customizable],Complement[List@@ELISACartridgeTypeP,{Customizable}],

        (* When user selected Automatic for CartridgeType, we do search depending on the number of analytes *)
        MatchQ[suppliedCartridgeType,Automatic]&&Length[suppliedAnalytes]>4,{MultiPlex32X8},
        MatchQ[suppliedCartridgeType,Automatic]&&Length[suppliedAnalytes]>1,{MultiAnalyte32X4,MultiAnalyte16X4,MultiPlex32X8},

        MatchQ[suppliedCartridgeType,Automatic],Complement[List@@ELISACartridgeTypeP,{Customizable}],

        True,suppliedCartridgeType
    ];

    (* Do a search to find all stocked cartridge objects that qualified with user-defined analytes or myAnalytes and provides the capacity over myNumberOfSamples with other user-defined requirements satisfied *)
    qualifiedStockedCartridges=If[MatchQ[suppliedAnalytes,Automatic|Null|{}],

        (* Search using resolved analytes if no analytes have been specified by the user. An error message for setting analytes to Null is thrown in the main resolver function *)
        (* A cartridge is considered qualified if it shares with 1 analyte in the resolved list *)
        Flatten[
            Map[

                (* search for each analyte *)
                Search[

                    (* search type - capillaryELISA cartridge object*)
                    Object[Container,Plate,Irregular,CapillaryELISA],

                    (* stocked, provides the capacity over myNumberOfSamples, contains at least one of the analytes*)
                    Status=={Stocked,Available}&&Model[CartridgeType]==requiredPreLoadedCartridgeType&&Model[MaxNumberOfSamples]>=myNumberOfSamples&&Model[AnalyteMolecules]==#
                ]&,
                myAnalytes
            ]
        ],

        (* Search using user-defined analytes. The cartridge must hold all the analytes *)
        Intersection@@
            Map[
                (* search for each analyte *)
                Search[

                    (* search type - capillaryELISA cartridge object*)
                    Object[Container,Plate,Irregular,CapillaryELISA],

                    (* stocked/available, provides the capacity over myNumberOfSamples, contains at least one of the analytes*)
                    Status=={Stocked,Available}&&Model[CartridgeType]==requiredPreLoadedCartridgeType&&Model[MaxNumberOfSamples]>=myNumberOfSamples&&Model[AnalyteMolecules]==#
                ]&,
                suppliedAnalytes
            ]
    ];

    (* If the user has required a certain CartridgeType or certain Analytes, we should try to find a model for them if no in-stock cartridge is available *)
    qualifiedModelCartridges=Which[
		!MatchQ[suppliedCartridgeType,Customizable|Automatic]&&MatchQ[qualifiedStockedCartridges,{}]&&!MatchQ[suppliedAnalytes,Automatic],
        Intersection@@Map[
            (* search for each analyte *)
            Search[

                (* search type - capillaryELISA cartridge object*)
                Model[Container,Plate,Irregular,CapillaryELISA],

                (* provides the capacity over myNumberOfSamples, contains at least one of the analytes*)
                CartridgeType==requiredPreLoadedCartridgeType&&MaxNumberOfSamples>=myNumberOfSamples&&AnalyteMolecules==#
            ]&,
            suppliedAnalytes
        ],
		(* If we have more than 1 analyte, we can try to get a multiplex cartridge *)
		MatchQ[suppliedCartridgeType,Automatic]&&MatchQ[qualifiedStockedCartridges,{}]&&Length[suppliedAnalytes]>1,
		Intersection@@Map[
			(* search for each analyte *)
			Search[

				(* search type - capillaryELISA cartridge object*)
				Model[Container,Plate,Irregular,CapillaryELISA],

				(* provides the capacity over myNumberOfSamples, contains at least one of the analytes*)
				CartridgeType==requiredPreLoadedCartridgeType&&MaxNumberOfSamples>=myNumberOfSamples&&AnalyteMolecules==#
			]&,
			suppliedAnalytes
		],
		True,
        {}
    ];

    (* Do another search to find the SinglePlex72X1 model cartridges that qualified with user-defined analytes or myAnalytes in the case that the capacity of Customizable cartridge 48 is not enough for all the samples. This only applies when user-defined analytes has only 1 member *)
    qualifiedSinglePlexModelCartridges=Which[
        MatchQ[qualifiedStockedCartridges,{}]&&myNumberOfSamples>48&&MatchQ[suppliedAnalytes,Automatic|Null|{}]&&MatchQ[suppliedCartridgeType,Automatic],
        Flatten[
            Map[

                (* search for each analyte *)
                Search[

                    (* search type - capillaryELISA cartridge model*)
                    Model[Container,Plate,Irregular,CapillaryELISA],

                    (* type SinglePlex72X1, contains at least one of the analytes*)
                    CartridgeType==SinglePlex72X1&&AnalyteMolecules==#
                ]&,
                myAnalytes
            ]
        ],
        MatchQ[qualifiedStockedCartridges,{}]&&myNumberOfSamples>48&&Length[suppliedAnalytes]==1&&MatchQ[suppliedCartridgeType,Automatic],
        Search[

            (* search type - capillaryELISA cartridge model *)
            Model[Container,Plate,Irregular,CapillaryELISA],

            (* type SinglePlex72X1, contains user-defined analytes *)
            CartridgeType==SinglePlex72X1&&AnalyteMolecules==suppliedAnalytes
        ],
        True,{}
    ];

    (* Return the best cartridge *)
    bestCartridge=Which[

        (* If user has asked for Customizable cartridge, return it *)
        MatchQ[suppliedCartridgeType,Customizable],Model[Container, Plate, Irregular, CapillaryELISA, "id:3em6ZvLneGBW"], (* Model[Container,Plate,Irregular,CapillaryELISA,"Human 48-Digoxigenin Cartridge"] *)

        (* If there are stocked cartridges sharing analytes with the input samples and qualify for user-defined options, then find the one that shares most analytes with the input samples *)
        !MatchQ[qualifiedStockedCartridges,{}],ReverseSortBy[Tally[qualifiedStockedCartridges],Last][[1,1]],

        (* If the user has asked for a certain CartridgeType other than Customizable or specified more than 1 analytes, find a model for them *)
        !MatchQ[suppliedCartridgeType,Customizable]&&!MatchQ[qualifiedModelCartridges,{}],qualifiedModelCartridges[[1]],

        (* If the user has asked for a certain CartridgeType other than Customizable or Automatic but we cannot find a model *)
        !MatchQ[suppliedCartridgeType,Customizable|Automatic]&&MatchQ[qualifiedModelCartridges,{}],Null,

        (* If there are more than 1 analytes specified, go with Null for multi-analyte cartridges *)
        TrueQ[Length[suppliedAnalytes]>1],Null,

        (* If there are less than or equal to 48 samples *)
        TrueQ[myNumberOfSamples<=48],Model[Container, Plate, Irregular, CapillaryELISA, "id:3em6ZvLneGBW"], (* Model[Container,Plate,Irregular,CapillaryELISA,"Human 48-Digoxigenin Cartridge"] *)

        (* If there are more than 48 samples and there is one model cartridge that can be used for the analytes of interest, get the first one as our myAnalytes is ranked with the frequency of analytes in the input samples*)
        !MatchQ[qualifiedSinglePlexModelCartridges,{}],qualifiedSinglePlexModelCartridges[[1]],

		(* In a very rare case that there are more than 72 samples but we still do not have a pre-loaded model/object, we can set it to the customizable cartridge. An error message was already thrown earlier *)
		TrueQ[myNumberOfSamples>72],Model[Container, Plate, Irregular, CapillaryELISA, "id:3em6ZvLneGBW"], (* Model[Container,Plate,Irregular,CapillaryELISA,"Human 48-Digoxigenin Cartridge"] *)

        (* Otherwise set the best cartridge to Null and let the user input new cartridge information *)
        True,Null
    ]
];



(* ::Subsubsubsection::Closed:: *)
(* resolveDilutedSampleNumber *)

(* A helper function to determine the number of samples to run in the experiment depending on the DilutionCurve and SerialDilutionCurve specified by the user. This applies to both Standard sample and simulated input sample *)
(* A default dilution number is also given and used when both dilution curve options are set to Automatic *)
resolveDilutedSampleNumber[
    myDilutionCurve:{{VolumeP,VolumeP}...}|{{VolumeP,_Real}...}|{VolumeP,{VolumeP,VolumeP},_Integer}|{VolumeP,{_Real,_Real},_Integer}|Automatic|Null,
    mySerialDilutionCurve:{VolumeP,VolumeP,_Integer}|{VolumeP,{_Real,_Integer}}|{VolumeP,{_Real..}}|Automatic|Null,
    myDefaultDilutionNumber_Integer
]:=Module[
    {
        numberOfDilutionCurve,numberOfSerialDilutionCurve,dilutedSampleNumber
    },

    (* Resolve the number of samples from DilutionCurve option *)
    numberOfDilutionCurve=Which[
        MatchQ[myDilutionCurve,Automatic],Automatic,
        MatchQ[myDilutionCurve,Null],Null,
		MatchQ[myDilutionCurve,{VolumeP,{_,_},_Integer}],Last[myDilutionCurve],
        True,Length[myDilutionCurve]
    ];

    (* Resolve the number of samples from SerialDilutionCurve option *)
    numberOfSerialDilutionCurve=Which[
        MatchQ[mySerialDilutionCurve,Automatic],Automatic,
        MatchQ[mySerialDilutionCurve,Null],Null,
        MatchQ[mySerialDilutionCurve,{VolumeP,VolumeP,_Integer}],mySerialDilutionCurve[[3]],
        MatchQ[mySerialDilutionCurve,{VolumeP,{_Real,_Integer}}],mySerialDilutionCurve[[2]][[2]],
        MatchQ[mySerialDilutionCurve,{VolumeP,{_Real..}}],Length[mySerialDilutionCurve[[2]]]
    ];

    (* Pick the larger number of samples from the two dilution curve options or keep the default number if both are automatic *)
    dilutedSampleNumber=Which[
        (* In case Null/Null error happens, use the default number as the sample number *)
        MatchQ[numberOfDilutionCurve,Null]&&MatchQ[numberOfSerialDilutionCurve,Null],myDefaultDilutionNumber,
        MatchQ[numberOfDilutionCurve,Automatic]&&MatchQ[numberOfSerialDilutionCurve,Automatic],myDefaultDilutionNumber,
        MatchQ[numberOfDilutionCurve,Null]&&MatchQ[numberOfSerialDilutionCurve,Automatic],myDefaultDilutionNumber,
        MatchQ[numberOfDilutionCurve,Automatic]&&MatchQ[numberOfSerialDilutionCurve,Null],myDefaultDilutionNumber,
        MatchQ[numberOfDilutionCurve,Automatic|Null]&&!MatchQ[numberOfSerialDilutionCurve,Automatic|Null],numberOfSerialDilutionCurve,
        !MatchQ[numberOfDilutionCurve,Automatic|Null]&&MatchQ[numberOfSerialDilutionCurve,Automatic|Null],numberOfDilutionCurve,
        True,Max[numberOfDilutionCurve,numberOfSerialDilutionCurve]
    ]
];


(* ::Subsubsubsection::Closed:: *)
(* resolveMaxDilutedSamplePreparationVolume *)

(* A helper function to determine the preparation volume of each diluted sample to run in the experiment depending on the DilutionCurve and SerialDilutionCurve specified by the user. This applies to both Standard sample and simulated input sample. It is important to get this number so that we can check whether it fits into the container. *)
(* A default volume number is also given and used when both dilution curve options are set to Automatic *)
resolveMaxDilutedSamplePreparationVolume[
    myDilutionCurve:{{VolumeP,VolumeP}...}|{{VolumeP,_Real}...}|{VolumeP,{VolumeP,VolumeP},_Integer}|{VolumeP,{_Real,_Real},_Integer}|Automatic|Null,
    mySerialDilutionCurve:{VolumeP,VolumeP,_Integer}|{VolumeP,{_Real,_Integer}}|{VolumeP,{_Real..}}|Automatic|Null,
    myDefaultVolume:GreaterEqualP[0Microliter]
]:=Module[
    {
        volumeOfDilutionCurve,volumeOfSerialDilutionCurve,dilutedSamplePreparationVolume
    },

    (* Resolve the maximum preparation volume of diluted samples from DilutionCurve option *)
    volumeOfDilutionCurve=Which[
        MatchQ[myDilutionCurve,Automatic],Automatic,
        MatchQ[myDilutionCurve,Null],Null,
		MatchQ[myDilutionCurve,{VolumeP,{_,_},_Integer}],First[myDilutionCurve],
        MatchQ[myDilutionCurve,{{VolumeP,VolumeP}...}],Max[Total[#]&/@myDilutionCurve],
        MatchQ[myDilutionCurve,{{VolumeP,_Real}...}],Max[myDilutionCurve[[All,1]]]
    ];

    (* Resolve the maximum preparation volume of diluted samples from SerialDilutionCurve option *)
    volumeOfSerialDilutionCurve=Which[
        MatchQ[mySerialDilutionCurve,Automatic],Automatic,
        MatchQ[mySerialDilutionCurve,Null],Null,
        MatchQ[mySerialDilutionCurve,{VolumeP,VolumeP,_Integer}],(mySerialDilutionCurve[[1]]+mySerialDilutionCurve[[2]]),
        MatchQ[mySerialDilutionCurve,{VolumeP,{_Real,_Integer}}|{VolumeP,{_Real..}}],mySerialDilutionCurve[[1]]
    ];

    (* Pick the max number of samples from the two dilution curve options or keep the default number if both are automatic *)
    dilutedSamplePreparationVolume=Which[
        MatchQ[volumeOfDilutionCurve,Automatic]&&MatchQ[volumeOfSerialDilutionCurve,Automatic],myDefaultVolume,
        MatchQ[volumeOfDilutionCurve,Automatic]&&MatchQ[volumeOfSerialDilutionCurve,Null],myDefaultVolume,
        MatchQ[volumeOfDilutionCurve,Null]&&MatchQ[volumeOfSerialDilutionCurve,Automatic],myDefaultVolume,
        MatchQ[volumeOfDilutionCurve,Null]&&MatchQ[volumeOfSerialDilutionCurve,Null],0Microliter,
        MatchQ[volumeOfDilutionCurve,Automatic|Null]&&!MatchQ[volumeOfSerialDilutionCurve,Automatic|Null],volumeOfSerialDilutionCurve,
        !MatchQ[volumeOfDilutionCurve,Automatic|Null]&&MatchQ[volumeOfSerialDilutionCurve,Automatic|Null],volumeOfDilutionCurve,
        True,Max[volumeOfDilutionCurve,volumeOfSerialDilutionCurve]
    ]
];


(* ::Subsubsubsection::Closed:: *)
(* serialDilutionCurveVolumesforCapillaryELISA *)

(* A helper function to turn serial dilution into volume/volume format *)
serialDilutionCurveVolumesforCapillaryELISA[mySerialDilutionCurve:{VolumeP,{_Real,_Integer}}|{VolumeP,{(_Real|EqualP[1])..}}]:=Module[
	{
		expandedDilutionFactors,transferVolumeList,diluentVolumeList,allDilutionVolumePairs
	},

	(* Expand the dilution factors into a list for a number of dilution factors *)
	expandedDilutionFactors=If[MatchQ[mySerialDilutionCurve,{VolumeP,{(_Real|EqualP[1])..}}],
		Last[mySerialDilutionCurve],
		ConstantArray[mySerialDilutionCurve[[2,1]],mySerialDilutionCurve[[2,2]]]
	];

	(* Get the transfer volume. The first volume of this list is actually the initial sample volume *)
	transferVolumeList=Map[
		Function[{start},
			SafeRound[
				Times[
					First[mySerialDilutionCurve],
					Total[
						FoldList[Times[##]&,expandedDilutionFactors[[start;;]]]
					]
				],
				10^-1Microliter
			]
		],
		(* Get the total number of dilution factors *)
		Range[Length[expandedDilutionFactors]]
	];

	(* Get the diluent volume at each step *)
	diluentVolumeList=MapThread[
		SafeRound[(1-#1)/#1*#2,10^-1Microliter]&,
		{expandedDilutionFactors,transferVolumeList}
	];

	(* Transpose to pair transfer volume with diluent volume *)
	allDilutionVolumePairs=Transpose[{transferVolumeList,diluentVolumeList}]

];


(* ::Subsubsubsection::Closed:: *)
(* resolveRequiredSampleVolumeForDilution *)

(* A helper function to determine the required volume of each sample to prepare the specified dilutions depending on the DilutionCurve and SerialDilutionCurve specified by the user. This applies to both Standard sample and simulated input sample (plus Spike, if applicable). It is important to get this number so that we can check whether we have enough sample volume, either in option resolver or in resource packets. *)
(* A default volume number is also given and used when both dilution curve options are set to Automatic *)
resolveRequiredSampleVolumeForDilution[
    myDilutionCurve:{{VolumeP,VolumeP}...}|{{VolumeP,_Real}...}|{VolumeP,{VolumeP,VolumeP},_Integer}|{VolumeP,{_Real,_Real},_Integer}|Automatic|Null,
    mySerialDilutionCurve:{VolumeP,VolumeP,_Integer}|{VolumeP,{_Real,_Integer}}|{VolumeP,{(_Real|EqualP[1])..}}|Automatic|Null,
    myDefaultVolume:GreaterEqualP[0Microliter]
]:=Module[
    {
        sampleVolumeOfDilutionCurve,sampleVolumeOfSerialDilutionCurve,requiredSampleVolumeForDilution
    },

    (* Resolve the required sample volume from DilutionCurve option *)
    sampleVolumeOfDilutionCurve=Which[
        MatchQ[myDilutionCurve,Automatic],Automatic,
        MatchQ[myDilutionCurve,Null],Null,
        MatchQ[myDilutionCurve,{{VolumeP,VolumeP}...}],Total[myDilutionCurve[[All,1]]],
        MatchQ[myDilutionCurve,{{VolumeP,_Real}...}],Total[myDilutionCurve[[All,1]]*myDilutionCurve[[All,2]]],
		MatchQ[myDilutionCurve,{VolumeP,{VolumeP,VolumeP},_Integer}],(Last[myDilutionCurve]*myDilutionCurve[[2,1]]+Last[myDilutionCurve]*(Last[myDilutionCurve]-1)*myDilutionCurve[[2,2]]/2),
		MatchQ[myDilutionCurve,{VolumeP,{_Real,_Real},_Integer}],First[myDilutionCurve]*(Last[myDilutionCurve]*myDilutionCurve[[2,1]]+Last[myDilutionCurve]*(Last[myDilutionCurve]-1)*myDilutionCurve[[2,2]]/2)
    ];

    (* Resolve the required sample volume from SerialDilutionCurve option *)
    sampleVolumeOfSerialDilutionCurve=Which[
        MatchQ[mySerialDilutionCurve,Automatic],Automatic,
        MatchQ[mySerialDilutionCurve,Null],Null,
        MatchQ[mySerialDilutionCurve,{VolumeP,VolumeP,_Integer}],mySerialDilutionCurve[[1]],
        MatchQ[mySerialDilutionCurve,{VolumeP,{_Real,_Integer}}|{VolumeP,{(_Real|EqualP[1])..}}],First[First[serialDilutionCurveVolumesforCapillaryELISA[mySerialDilutionCurve]]]
    ];

    (* Pick the max number of samples from the two dilution curve options or keep the default number if both are automatic *)
    requiredSampleVolumeForDilution=Which[
        MatchQ[sampleVolumeOfDilutionCurve,Automatic]&&MatchQ[sampleVolumeOfSerialDilutionCurve,Automatic],myDefaultVolume,
        MatchQ[sampleVolumeOfDilutionCurve,Automatic]&&MatchQ[sampleVolumeOfSerialDilutionCurve,Null],myDefaultVolume,
        MatchQ[sampleVolumeOfDilutionCurve,Null]&&MatchQ[sampleVolumeOfSerialDilutionCurve,Automatic],myDefaultVolume,
        MatchQ[sampleVolumeOfDilutionCurve,Null]&&MatchQ[sampleVolumeOfSerialDilutionCurve,Null],0Microliter,
        MatchQ[sampleVolumeOfDilutionCurve,Automatic|Null]&&!MatchQ[sampleVolumeOfSerialDilutionCurve,Automatic|Null],sampleVolumeOfSerialDilutionCurve,
        !MatchQ[sampleVolumeOfDilutionCurve,Automatic|Null]&&MatchQ[sampleVolumeOfSerialDilutionCurve,Automatic|Null],sampleVolumeOfDilutionCurve,
        True,Max[sampleVolumeOfDilutionCurve,sampleVolumeOfSerialDilutionCurve]
    ];

	(* Use 0.1Microliter as a guideline since we need at least 0.1 uL for transfer/aliquot *)
	Max[requiredSampleVolumeForDilution,0.1Microliter]
];


(* ::Subsubsubsection::Closed:: *)
(* resolveRequiredDiluentVolumeForDilution *)

(* A helper function to determine the required volume of the diluent to prepare the specified dilutions for each sample depending on the DilutionCurve and SerialDilutionCurve specified by the user. This applies to both Standard sample and simulated input sample (plus Spike, if applicable). This number is only used in resource packets to get the resources for diluents. There is no need to consider the situation with options set to Automatic as our options are set after resolver. *)
resolveRequiredDiluentVolumeForDilution[
    myDilutionCurve:{{VolumeP,VolumeP}...}|{{VolumeP,_Real}...}|{VolumeP,{VolumeP,VolumeP},_Integer}|{VolumeP,{_Real,_Real},_Integer}|Null,
    mySerialDilutionCurve:{VolumeP,VolumeP,_Integer}|{VolumeP,{_Real,_Integer}}|{VolumeP,{(_Real|EqualP[1])..}}|Null
]:=Module[
    {
        sampleVolumeOfDilutionCurve,sampleVolumeOfSerialDilutionCurve,requiredSampleVolumeForDilution
    },

    (* Resolve the required sample volume from DilutionCurve option *)
    sampleVolumeOfDilutionCurve=Which[
        MatchQ[myDilutionCurve,Null],0Microliter,
        MatchQ[myDilutionCurve,{{VolumeP,VolumeP}...}],Total[myDilutionCurve[[All,2]]],
        MatchQ[myDilutionCurve,{{VolumeP,_Real}...}],Total[myDilutionCurve[[All,1]]*(1-myDilutionCurve[[All,2]])],
		MatchQ[myDilutionCurve,{VolumeP,{VolumeP,VolumeP},_Integer}],(Last[myDilutionCurve]*First[myDilutionCurve]-Last[myDilutionCurve]*myDilutionCurve[[2,1]]-Last[myDilutionCurve]*(Last[myDilutionCurve]-1)*myDilutionCurve[[2,2]]/2),
		MatchQ[myDilutionCurve,{VolumeP,{_Real,_Real},_Integer}],First[myDilutionCurve]*(Last[myDilutionCurve]-Last[myDilutionCurve]*myDilutionCurve[[2,1]]-Last[myDilutionCurve]*(Last[myDilutionCurve]-1)*myDilutionCurve[[2,2]]/2)
    ];

    (* Resolve the required sample volume from SerialDilutionCurve option *)
    sampleVolumeOfSerialDilutionCurve=Which[
        MatchQ[mySerialDilutionCurve,Null],0Microliter,
        MatchQ[mySerialDilutionCurve,{VolumeP,VolumeP,_Integer}],mySerialDilutionCurve[[2]]*mySerialDilutionCurve[[3]],
        MatchQ[mySerialDilutionCurve,{VolumeP,{_Real,_Integer}}|{VolumeP,{(_Real|EqualP[1])..}}],Total[(serialDilutionCurveVolumesforCapillaryELISA[mySerialDilutionCurve])[[All, 2]]]
    ];

    (* Pick the max number of samples from the two dilution curve options or keep the default number if both are automatic *)
    requiredSampleVolumeForDilution=Max[sampleVolumeOfDilutionCurve,sampleVolumeOfSerialDilutionCurve]

];

(* ::Subsubsubsection::Closed:: *)
(* resolveMinDilutedSamplePreparationVolume *)

(* A helper function to determine the preparation volume of each diluted sample to run in the experiment depending on the DilutionCurve and SerialDilutionCurve specified by the user. This applies to both Standard sample and simulated input sample. It is important to get this number so that we can check whether enough volumes have been prepared for loading. *)
(* A default volume number is also given and used when both dilution curve options are set to Automatic *)
resolveMinDilutedSamplePreparationVolume[
    myDilutionCurve:{{VolumeP,VolumeP}...}|{{VolumeP,_Real}...}|{VolumeP,{VolumeP,VolumeP},_Integer}|{VolumeP,{_Real,_Real},_Integer}|Automatic|Null,
    mySerialDilutionCurve:{VolumeP,VolumeP,_Integer}|{VolumeP,{_Real,_Integer}}|{VolumeP,{_Real..}}|Automatic|Null,
    myDefaultVolume:GreaterEqualP[0Microliter]
]:=Module[
    {
        volumeOfDilutionCurve,volumeOfSerialDilutionCurve,dilutedSamplePreparationVolume
    },

    (* Resolve the minimum preparation volume of diluted samples from DilutionCurve option *)
    volumeOfDilutionCurve=Which[
        MatchQ[myDilutionCurve,Automatic],Automatic,
        MatchQ[myDilutionCurve,Null],Null,
		MatchQ[myDilutionCurve,{VolumeP,{_,_},_Integer}],First[myDilutionCurve],
        MatchQ[myDilutionCurve,{{VolumeP,VolumeP}...}],Min[Total[#]&/@myDilutionCurve],
        MatchQ[myDilutionCurve,{{VolumeP,_Real}...}],Min[myDilutionCurve[[All,1]]]
    ];

    (* Resolve the minimum preparation volume of diluted samples from SerialDilutionCurve option *)
    volumeOfSerialDilutionCurve=Which[
        MatchQ[mySerialDilutionCurve,Automatic],Automatic,
        MatchQ[mySerialDilutionCurve,Null],Null,
        MatchQ[mySerialDilutionCurve,{VolumeP,VolumeP,_Integer}],mySerialDilutionCurve[[2]],
        MatchQ[mySerialDilutionCurve,{VolumeP,{_Real,_Integer}}|{VolumeP,{_Real..}}],mySerialDilutionCurve[[1]]
    ];

    (* Pick the min number of samples from the two dilution curve options or keep the default number if both are automatic. *)
    dilutedSamplePreparationVolume=Which[
        MatchQ[volumeOfDilutionCurve,Automatic|Null]&&MatchQ[volumeOfSerialDilutionCurve,Automatic|Null],myDefaultVolume,
        (* We have an error message for both Null. We can set to DefaultVolume here *)
        MatchQ[volumeOfDilutionCurve,Automatic|Null]&&!MatchQ[volumeOfSerialDilutionCurve,Automatic|Null],volumeOfSerialDilutionCurve,
        !MatchQ[volumeOfDilutionCurve|Null,Automatic]&&MatchQ[volumeOfSerialDilutionCurve,Automatic|Null],volumeOfDilutionCurve,
        True,Min[volumeOfDilutionCurve,volumeOfSerialDilutionCurve]
    ]
];



(* ::Subsubsubsection::Closed:: *)
(* findMostConcentrationDilutionFactor *)

(* A helper function to determine the largest dilution factor. This number is only used after resolver so no Automatic option value is possible. *)
findMostConcentrationDilutionFactor[
	myDilutionCurve:{{VolumeP,VolumeP}...}|{{VolumeP,_Real}...}|{VolumeP,{VolumeP,VolumeP},_Integer}|{VolumeP,{_Real,_Real},_Integer}|Null,
	mySerialDilutionCurve:{VolumeP,VolumeP,_Integer}|{VolumeP,{_Real,_Integer}}|{VolumeP,{_Real..}}|Null
]:=Module[
	{
		dilutionFactorsOfDilutionCurve,highestDilutionFactorOfDilutionCurve,highestDilutionFactorOfSerialDilutionCurve,highestDilutionFactor
	},

	(* Resolve the largest dilution factor from DilutionCurve option *)
	dilutionFactorsOfDilutionCurve=Which[
		MatchQ[myDilutionCurve,Null],Null,
		MatchQ[myDilutionCurve,{VolumeP,{_Real,_Real},_Integer}],NestList[#+myDilutionCurve[[2,2]]&,myDilutionCurve[[2,1]],Last[myDilutionCurve]-1],
		MatchQ[myDilutionCurve,{VolumeP,{VolumeP,VolumeP},_Integer}],NestList[#+myDilutionCurve[[2,2]]&,myDilutionCurve[[2,1]],Last[myDilutionCurve]-1]/First[myDilutionCurve],
		MatchQ[myDilutionCurve,{{VolumeP,VolumeP}...}],Map[#[[1]]/(#[[1]]+#[[2]])&,myDilutionCurve],
		MatchQ[myDilutionCurve,{{VolumeP,_Real}...}],myDilutionCurve[[All,2]]
	];

	highestDilutionFactorOfDilutionCurve=If[!MatchQ[dilutionFactorsOfDilutionCurve,{}|Null],
		Max[dilutionFactorsOfDilutionCurve],
		Null
	];

	(* Resolve the largest dilution factor from SerialDilutionCurve option *)
	highestDilutionFactorOfSerialDilutionCurve=Which[
		MatchQ[mySerialDilutionCurve,Null],Null,
		MatchQ[mySerialDilutionCurve,{VolumeP,VolumeP,_Integer}],mySerialDilutionCurve[[1]]/(mySerialDilutionCurve[[1]]+mySerialDilutionCurve[[2]]),
		MatchQ[mySerialDilutionCurve,{VolumeP,{_Real,_Integer}}|{VolumeP,{_Real..}}],mySerialDilutionCurve[[2,1]]
	];

	(* Pick the min number of samples from the two dilution curve options or keep the default number if both are automatic. *)
	highestDilutionFactor=Which[
		MatchQ[highestDilutionFactorOfDilutionCurve,Null]&&MatchQ[highestDilutionFactorOfSerialDilutionCurve,Null],0,
		(* We have an error message for both Null. We can set to DefaultVolume here *)
		MatchQ[highestDilutionFactorOfDilutionCurve,Null]&&!MatchQ[highestDilutionFactorOfSerialDilutionCurve,Null],highestDilutionFactorOfSerialDilutionCurve,
		!MatchQ[highestDilutionFactorOfDilutionCurve,Null]&&MatchQ[highestDilutionFactorOfSerialDilutionCurve,Null],highestDilutionFactorOfDilutionCurve,
		True,Max[highestDilutionFactorOfDilutionCurve,highestDilutionFactorOfSerialDilutionCurve]
	]
];



(* ::Subsubsubsection::Closed:: *)
(* cartridgeCapacity *)

(* For a specific type of cartridge, determine its maximum number of analytes and samples *)
cartridgeCapacity[cartridgeType:ELISACartridgeTypeP]:=Module[
    {analytesCapacity,samplesCapacity},
    analytesCapacity=Switch[cartridgeType,
        SinglePlex72X1,1,
        MultiAnalyte32X4,4,
        MultiAnalyte16X4,4,
        MultiPlex32X8,8,
        Customizable,48
    ];
    samplesCapacity=Switch[cartridgeType,
        SinglePlex72X1,72,
        MultiAnalyte32X4,32,
        MultiAnalyte16X4,16,
        MultiPlex32X8,32,
        Customizable,48
    ];
    {analytesCapacity,samplesCapacity}
];


(* ::Subsubsubsection::Closed:: *)
(* deleteIncompatibleMemberQ *)

(* Helper function to provide boolean about whether to delete a member from workingList due to its incompatiblilty shown in incompatibleList *)
(* workingList is a list of members like {a,b,c,..}. incompatibleList is a list of list like {{z,y},{x},{},..}. This means that a cannot be in the same list as z and y, etc. Either of each pair must be deleted. *)

deleteIncompatibleMemberQ[workingList_List,incompatibleList_List]:=Module[
    {
        lengthIncompatibleList,expandedWorkingList,incompatiblePairs,rankingRule,rankedIncompatiblePairs,deleteMember,deletememberQ
    },

    (* get the length of each incompatible list *)
    lengthIncompatibleList=Length/@incompatibleList;

    (* generate a list of working members to match the length of incompatible list *)
    expandedWorkingList=MapThread[
        If[#2==0,
            {},
            ConstantArray[#1,#2]
        ]&,
        {workingList,lengthIncompatibleList}
    ];

    (* recombine the working list with incompatible list to get the pairs of incompatible members *)
    incompatiblePairs=Transpose[{Flatten[expandedWorkingList],Flatten[incompatibleList]}];

    (* get a list of ranking rule in which the most popular member in the incompatible list is shown first *)
    rankingRule=ReverseSortBy[Tally[Flatten[incompatibleList]],Last][[All,1]];

    (* rank incompatible pairs to always allow more popular incompatible member to be at front *)
    rankedIncompatiblePairs=Map[
        Function[{list},
            SortBy[list,Position[rankingRule,#]&]
        ],
        incompatiblePairs
    ];

    (* the first member of each incompatible pair is to be deleted. Because the first member is always the one that occurs most, this method minimizes the number of members to delete *)
    deleteMember=DeleteDuplicates[rankedIncompatiblePairs[[All,1]]];

    (* return a boolean to indicate whether a member should be deleted *)
    deletememberQ=Map[MemberQ[deleteMember,#]&,workingList]

];



(* ::Subsubsubsection::Closed:: *)
(* resolvePreLoadedCartridgeAnalytes *)

DefineOptions[resolvePreLoadedCartridgeAnalytes,
    Options:>{
        CacheOption
    }
];


(* Single-analyte overload *)
resolvePreLoadedCartridgeAnalytes[cartridgeType:ELISACartridgeTypeP,species:ELISASpeciesP,analyte:ObjectP[Model[Molecule]],ops:OptionsPattern[]]:=resolvePreLoadedCartridgeAnalytes[cartridgeType,species,{analyte},ops];

resolvePreLoadedCartridgeAnalytes[cartridgeType:ELISACartridgeTypeP,species:ELISASpeciesP,analytes:{ObjectP[Model[Molecule]]...},ops:OptionsPattern[]]:=Module[
    {
        safeOps,cache,
        analyteSpecs,analytesCartridgeTypes,analyteQualifyCartridgeTypeQ,analyteSpecies,analyteSpeciesQ,analyteQualifyQ,qualifiedAnalyteSpecs,maxNumberOfAnalytes,analyteDiluents,analytesMinDilutionFactor,analyteInformationMatrix,gatheredAnalyteInformation,gatheredAnalyteSpecs,gatheredAnalyteSpecObjects,incompatibleAnalyteSpecs,deleteAnalyteSpecQ,compatibleGatheredAnalyteInformation,compatibleGatheredAnalyteMoleculeInformation,noDuplicateCompatibleGatheredAnalyteMoleculeInformation,bestAnalytesInformation,bestAnalyteSpecs,bestAnalytes,finalAnalyteSpecs,finalAnalytes,finalAnalyteNames
    },

    (* get the Cache option *)
    safeOps=SafeOptions[resolvePreLoadedCartridgeAnalytes, ToList[ops]];
    cache=Lookup[safeOps,Cache];

    (* get all the manufacturing specifications from cache. We can flatten them into a list so we can easily operate. *)
    analyteSpecs=DeleteDuplicates[Flatten[Cases[cache,KeyValuePattern[{Type->Object[ManufacturingSpecification,CapillaryELISACartridge],AnalyteMolecule->LinkP[#]}]]&/@analytes]];

    (* Get the available cartridge types for each analyte *)
    analytesCartridgeTypes=Lookup[#,CartridgeType,{}]&/@analyteSpecs;

    analyteQualifyCartridgeTypeQ=Map[
        MemberQ[#,cartridgeType]&,
        analytesCartridgeTypes
    ];

    (* Get the available species for each analyte *)
    analyteSpecies=Lookup[#,Species]&/@analyteSpecs;

    analyteSpeciesQ=Map[
        MatchQ[#,species]&,
        analyteSpecies
    ];

    (* Check whether each analyte failed to qualify either CartridgeType or Species *)
    analyteQualifyQ=MapThread[
        And[#1,#2]&,
        {analyteQualifyCartridgeTypeQ,analyteSpeciesQ}
    ];

    (* get rid of the analyte manufacturing specifications that are not qualified *)
    qualifiedAnalyteSpecs=PickList[analyteSpecs,analyteQualifyQ,True];

    (* Get the available diluents for each analyte *)
    analyteDiluents=Map[
		Download[#,RecommendedDiluent[Object],Cache->cache,Date->Now]&,
		qualifiedAnalyteSpecs
    ];

    (* Get the available minimum dilution factors for each analyte *)
    analytesMinDilutionFactor=Lookup[#,RecommendedMinDilutionFactor,Null]&/@qualifiedAnalyteSpecs;

    (* Put the Diluents and MinDilutionFactor information together with the specific analyte spec *)
    analyteInformationMatrix=Transpose[{qualifiedAnalyteSpecs,analyteDiluents,analytesMinDilutionFactor}];

    (* Gather by pairs of diluent and minimum dilution factor *)
    gatheredAnalyteInformation=GatherBy[analyteInformationMatrix,Rest];
    gatheredAnalyteSpecs=Map[First[#]&,gatheredAnalyteInformation,{2}];

    (* Get the list without links *)
    gatheredAnalyteSpecObjects=Map[Lookup[#,Object]&,gatheredAnalyteSpecs,{2}];

    (* Get the incompatible analyte list for each analyte spec. *)
    incompatibleAnalyteSpecs=Map[
		Download[#,IncompatibleAnalytes[Object],Date->Now]&,
		gatheredAnalyteSpecs,
		{2}
	];

    (* Call helper function deleteIncompatibleMemberQ to get a BooleanP list about whether to delete a certain member from the analyte spec list *)
    deleteAnalyteSpecQ=MapThread[
        deleteIncompatibleMemberQ[#1,#2]&,
        {gatheredAnalyteSpecObjects,incompatibleAnalyteSpecs}
    ];

    (* Use PickList to delete all the incompatible members from gatheredAnalyteInformation *)
    compatibleGatheredAnalyteInformation=MapThread[
        PickList[#1,#2,False]&,
        {gatheredAnalyteInformation,deleteAnalyteSpecQ}
    ];

	(* Turn the manufacturing specification into analyte molecules so that we can delete duplicates *)
	compatibleGatheredAnalyteMoleculeInformation=Map[
		Function[
			{infoList},
			Module[
				{analyteSpec,analyteMoleculeModel,joinedInfoList,noDuplicateInfoList},
				analyteSpec=First[infoList];
				analyteMoleculeModel=Download[analyteSpec,AnalyteMolecule[Object],Cache->cache,Date->Now];
				joinedInfoList=Join[{analyteMoleculeModel},infoList]
			]
		],
		compatibleGatheredAnalyteInformation,
		{2}
	];

	noDuplicateCompatibleGatheredAnalyteMoleculeInformation=Map[
		Function[
			{infoList},
			DeleteDuplicatesBy[
				infoList,
				First[#]&
			]
		],
		compatibleGatheredAnalyteMoleculeInformation
	];

    (* Get the most common pairs of diluent and minimum dilution factor, with the corresponding analytes *)
    bestAnalytesInformation=If[!MatchQ[noDuplicateCompatibleGatheredAnalyteMoleculeInformation,{}],
        ReverseSortBy[noDuplicateCompatibleGatheredAnalyteMoleculeInformation,Length][[1]],
        {}
    ];

    (* Get the list of analytes, the diluent and the minimum dilution factor *)
    {bestAnalyteSpecs,bestAnalytes}=If[!MatchQ[bestAnalytesInformation,{}],
        {bestAnalytesInformation[[All,2]],bestAnalytesInformation[[All,1]]},
        {{},{}}
    ];

    (* get the number of analytes that can be fit into the resolved CartridgeType *)
    maxNumberOfAnalytes=First[cartridgeCapacity[cartridgeType]];

    (* get the list of analytes with number smaller than or equal to maxNumberOfAnalytes *)
	finalAnalyteSpecs=Take[bestAnalyteSpecs,Min[Length[bestAnalytes],maxNumberOfAnalytes]];
    finalAnalytes=Take[bestAnalytes,Min[Length[bestAnalytes],maxNumberOfAnalytes]];

	(* get the analyte names *)
	finalAnalyteNames=DeleteCases[Lookup[finalAnalyteSpecs,AnalyteName,Null],Null];

    (* Return analytes, diluent, minDilutionFactor and possibleAnalyteAssayGeneration to the main function *)
    {finalAnalyteNames,finalAnalytes}

];



(* ::Subsubsubsection::Closed:: *)
(* mustNullOptionCheck *)

(* For a specific parent option with the value pattern of interest, and a specific list of options, check whether the options are all Null|Automatic|{} when the specific parent option is giving the value pattern of interest. For example, if when StandardResuspension is False, we expect StandardResuspensionCentrifugeIntensity etc to be Null, our inputs are StandardResuspension, False, {... options} and the option association. Return a boolean matrix indicating whether a sample's specific option qualifies. When a certain value in the parent option is not pattern of interest, return all True. Then we summarize the positions that are showing invalid values. *)
(* Because our parent function has the association expanded, we don't need to worry that the options are not of same length. *)
mustNullOptionCheck[myParentOption_,myTargetParentOptionValue_,myChildOptions_List,myOptionAssociation_Association]:=Module[
    {
        myParentOptionValues,myChildOptionValues,allOptionValueChecks,invalidParentOptionCheck,invalidChildOptionsCheck,invalidParentOptionPositions,invalidChildOptions
    },

    (* Get all the values for the parent option *)
    myParentOptionValues=ToList[Lookup[myOptionAssociation,myParentOption]];

    (* Get all the values for the options of interest *)
    myChildOptionValues=ToList[Lookup[myOptionAssociation,#]]&/@myChildOptions;

    (* Map to check whether every option is Null|Automatic *)
    allOptionValueChecks=Map[
        Function[optionValues,
            MapThread[
                MatchQ[{#1,#2},{myTargetParentOptionValue,Null|Automatic}|{Except[myTargetParentOptionValue],_}]&,
                {myParentOptionValues,optionValues}
            ]
        ],
        myChildOptionValues
    ];

    (* Check for the positions of parent option that are not all Null - this will go back as the invalid samples, as a list of booleans *)
    invalidParentOptionCheck=And @@ # & /@Transpose[allOptionValueChecks];

    (* Check for the options that are not all Null *)
    invalidChildOptionsCheck=And @@ # & /@allOptionValueChecks;

    (* Pick the options that are not all Null *)
    invalidChildOptions=PickList[myChildOptions,invalidChildOptionsCheck,False];

    {invalidParentOptionCheck,invalidChildOptions}

];


(* ::Subsubsubsection::Closed:: *)
(* mustNotNullOptionCheck *)

(* For a specific parent option with the value pattern of interest, and a specific list of options, check whether the options are not Null|Automatic when the specific parent option is giving the value pattern of interest. Same idea as mustNullOptionCheck but opposite. *)
(* Because our parent function has the association expanded, we don't need to worry that the options are not of same length. *)
mustNotNullOptionCheck[myParentOption_,myTargetParentOptionValue_,myChildOptions_List,myOptionAssociation_Association]:=Module[
    {
        myParentOptionValues,myChildOptionValues,allOptionValueChecks,invalidParentOptionCheck,invalidChildOptionsCheck,invalidParentOptionPositions,invalidChildOptions
    },

    (* Get all the values for the parent option *)
    myParentOptionValues=ToList[Lookup[myOptionAssociation,myParentOption]];

    (* Get all the values for the options of interest *)
    myChildOptionValues=ToList[Lookup[myOptionAssociation,#]]&/@myChildOptions;

    (* Map to check whether every option is not Null|Automatic *)
    allOptionValueChecks=Map[
        Function[optionValues,
            MapThread[
                MatchQ[{#1,#2},{myTargetParentOptionValue,Except[Null]}|{Except[myTargetParentOptionValue],_}]&,
                {myParentOptionValues,optionValues}
            ]
        ],
        myChildOptionValues
    ];

    (* Check for the positions of parent option that are not all Null - this will go back as the invalid samples, returned as a list of booleans *)
    invalidParentOptionCheck=And @@ # & /@Transpose[allOptionValueChecks];

    (* Check for the options that are not all Null *)
    invalidChildOptionsCheck=And @@ # & /@allOptionValueChecks;

    (* Pick the options that are not all Null *)
    invalidChildOptions=PickList[myChildOptions,invalidChildOptionsCheck,False];

    {invalidParentOptionCheck,invalidChildOptions}

];



(* ::Subsubsubsection::Closed:: *)
(* userDefinedOrDefault *)

(* a small helper function to quickly set values of options to default *)
userDefinedOrDefault[myOpsValues_List,myDefaults_]:=Module[{expandedDefaults,processedOps},
    expandedDefaults=Which[

        (* expand the option values if given a single value *)
        !MatchQ[myDefaults,_List],ConstantArray[myDefaults,Length[myOpsValues]],

        (* expand the option values if given a list of single value *)
        MatchQ[Length[myDefaults],1],ConstantArray[First[myDefaults],Length[myOpsValues]],

        (* no need to expand if given a list of same length *)
        MatchQ[Length[myOpsValues],Length[myDefaults]],myDefaults,

        (* return failed if given a list of random length *)
        True,Return[$Failed]
    ];

    (* Keep user-defined options and change automatic options to default value. Return the processed options *)
    processedOps=MapThread[
        If[MatchQ[#1,Automatic],
            #2,
            #1
        ]&,
        {myOpsValues,expandedDefaults}
    ]

];


(* ::Subsubsubsection::Closed:: *)
(* findAntibodyEpitopePosition *)

(* Given an antibody and its target, find the interval position range that this antibody binds to on the target, with 10 amino acids expansion *)
findAntibodyEpitopePosition[myAnalyte:ObjectReferenceP[Model[Molecule]],myAntibody:PacketP[Model[Molecule]]]:=Module[
    {
        antibodyPacket,antibodyEpitopes,antibodyBindingPositions,antibodyBindingArea
    },

    (* get the antibody information packets *)
    antibodyPacket=Lookup[myAntibody,{Targets,Epitopes}];

    (* transpose the antibody targets to match their epitopes if both target and epitopes are populated *)
    antibodyEpitopes=If[MatchQ[antibodyPacket,{{},_}|{_,{}}],
        {},
        Transpose[antibodyPacket]
    ];

    (* select the epitope information for myAnalyte and extract only the position information. The entire variable is like {{1,3},{5,8}} *)
    antibodyBindingPositions=Flatten[Select[antibodyEpitopes,MatchQ[First[#],ObjectP[myAnalyte]]&][[All,2,All,{2,3}]],1];

    (* expand the positions by 10 amino acids in case the antibodies are too close with each other and the binding efficiency is affected. Also union the intervals to combine all positions for each antibody. Return this Interval for comparison *)
    antibodyBindingArea=IntervalUnion@@Map[Interval[{First[#]-10,Last[#]+10}] &,antibodyBindingPositions]

];


(* ::Subsubsubsection::Closed:: *)
(* findBestCandidateForCapillaryELISAAntibodies *)

(* a short helper function to find the best candidate out of a list given lists of booleans to consider. The first boolean list is most important and the last boolean list is least important *)
findBestCandidateForCapillaryELISAAntibodies[myBooleanRules:{{BooleanP...}...}]:=Module[
    {numberOfRules,weightRule,weighedBoolean,weight,bestCandidatePosition,bestWeight},

    numberOfRules=Length[myBooleanRules];
    weightRule=Reverse[Range[1,10*numberOfRules,10]];

    (* change boolean into numbers. for high-weight rule, we get a larger number *)
    weighedBoolean=MapThread[
        ReplaceAll[#1,{True->#2,False->0}]&,
        {myBooleanRules,weightRule}
    ];

    (* find the weight of each candidate *)
    weight=Total[#]&/@Transpose[weighedBoolean];

    (* return the position of the best member and the weight. Because in our experiment, we always have modification, clonity and epitope overlapping to consider. The weight value can be directly used for cross comparison. *)
    bestCandidatePosition=If[MatchQ[weight,{}],
        {},
        Ordering[weight,-1]
    ];
    bestWeight=Take[weight,ToList[bestCandidatePosition]];

    {bestCandidatePosition,bestWeight}

];


(* ::Subsubsubsection::Closed:: *)
(* findAntibodyPairs *)

DefineOptions[findAntibodyPairs,
    Options:>{
        CacheOption
    }
];

(* Overloads *)

(* TODO Combine some of the overloads to make the entire function simpler. *)
(* return user-defined value when it is not automatic. a quick check of epitopes is done. *)
findAntibodyPairs[myAnalyte:ObjectP[Model[Molecule]],myCaptureAntibody:ObjectP[{Model[Sample],Object[Sample]}]|Null,myDetectionAntibody:ObjectP[{Model[Sample],Object[Sample]}]|Null,ops:OptionsPattern[]]:=Module[

    {
        safeOps,cache,
        captureAntibodyIdentityModel,detectionAntibodyIdentityModel,captureAntibodyPacket,detectionAntibodyPacket,captureAntibodyIdentityModelPackets,detectionAntibodyIdentityModelPackets,captureAntibodyBindingAreas,detectionAntibodyBindingAreas,antibodyEpitopeWarning,captureAntibodyAssayTypeWarning,detectionAntibodyAssayTypeWarning
    },

    (* get the Cache option *)
    safeOps=SafeOptions[findAntibodyPairs, ToList[ops]];
    cache=Lookup[safeOps,Cache];

    (* get the antibody identity models and packets *)
    captureAntibodyIdentityModel=Cases[Download[myCaptureAntibody,Composition[[All,2]][Object],Cache->cache,Date->Now],ObjectP[Model[Molecule,Protein,Antibody]]];
    captureAntibodyIdentityModelPackets=Download[captureAntibodyIdentityModel,Packet[Targets,Epitopes,AssayTypes],Cache->cache,Date->Now];

    detectionAntibodyIdentityModel=Cases[Download[myDetectionAntibody,Composition[[All,2]][Object],Cache->cache,Date->Now],ObjectP[Model[Molecule,Protein,Antibody]]];
    detectionAntibodyIdentityModelPackets=Download[detectionAntibodyIdentityModel,Packet[Targets,Epitopes,AssayTypes],Cache->cache,Date->Now];

    (* call helper function to find binding area for each antibody identity model and union them together*)
    captureAntibodyBindingAreas=IntervalUnion@@Map[
        findAntibodyEpitopePosition[myAnalyte,#]&,
        captureAntibodyIdentityModelPackets
    ];

    detectionAntibodyBindingAreas=IntervalUnion@@Map[
        findAntibodyEpitopePosition[myAnalyte,#]&,
        detectionAntibodyIdentityModelPackets
    ];

	(* Check whether the supplied antibodies are compatible with ELISA assay types *)
	captureAntibodyAssayTypeWarning=!MemberQ[Flatten[Lookup[captureAntibodyIdentityModelPackets,AssayTypes,{}]],ELISA];

	detectionAntibodyAssayTypeWarning=!MemberQ[Flatten[Lookup[detectionAntibodyIdentityModelPackets,AssayTypes,{}]],ELISA];

    (* check whether the positions overlap and give warning if necessary. A special case is that the two antibody samples share the same identity model - even if epitops are not populated, they must be the same *)
    antibodyEpitopeWarning=Which[
        !MatchQ[IntervalIntersection[captureAntibodyBindingAreas,detectionAntibodyBindingAreas],Interval[]],True,
        MatchQ[captureAntibodyIdentityModel,{}]||MatchQ[detectionAntibodyIdentityModel,{}],False,
		MatchQ[myCaptureAntibody,ObjectP[myDetectionAntibody]],True,
        ContainsExactly[captureAntibodyIdentityModel,detectionAntibodyIdentityModel],True,
        True,False
    ];

    (* return the user-defined antibodies and warning boolean *)
    {myCaptureAntibody,myDetectionAntibody,captureAntibodyAssayTypeWarning,detectionAntibodyAssayTypeWarning,antibodyEpitopeWarning}

];


(* resolve capture antibody when detection antibody is populated or Null  *)
findAntibodyPairs[myAnalyte:ObjectP[Model[Molecule]],myCaptureAntibody:Automatic,myDetectionAntibody:ObjectP[{Model[Sample],Object[Sample]}]|Null,ops:OptionsPattern[]]:=Module[
	{
		safeOps,cache,
		detectionAntibodyIdentityModel,detectionAntibodyIdentityModelPackets,detectionAntibodyBindingArea,
		analytePacket,possibleAntibodies,compatibleAntibodies,compatibleAntibodyDefaultModels,compatibleAntibodyBindingAreas,epitopeOverlapQ,digoxigeninModifiedQ,polyclonalQ,
		bestAntibodyPosition,bestCaptureAntibodyIdentityModelPacket,bestCaptureAntibody,captureAntibodyAssayTypeWarning,detectionAntibodyAssayTypeWarning,antibodyEpitopeWarning
	},

	(* get the Cache option *)
	safeOps=SafeOptions[findAntibodyPairs, ToList[ops]];
	cache=Lookup[safeOps,Cache];

	(* get the detection antibody identity models *)
	detectionAntibodyIdentityModel=Cases[Download[myDetectionAntibody,Composition[[All,2]][Object],Cache->cache,Date->Now],ObjectP[Model[Molecule,Protein,Antibody]]];
	detectionAntibodyIdentityModelPackets=Download[detectionAntibodyIdentityModel,Packet[Targets,Epitopes,SecondaryAntibodies,AssayTypes],Cache->cache,Date->Now];

	(* call helper function to find binding area for each antibody identity model and union them together. Even if myDetectionAntibody is Null, this will work as the helper function should return Interval[] regardless *)
	detectionAntibodyBindingArea=IntervalUnion@@Map[
		findAntibodyEpitopePosition[myAnalyte,#]&,
		detectionAntibodyIdentityModelPackets
	];

	(* get the analyte packet with information of interest *)
	analytePacket=Which[
		MatchQ[myAnalyte,ObjectP[Model[Molecule,Protein,Antibody]]],Download[myAnalyte,{Packet[SecondaryAntibodies],Packet[SecondaryAntibodies[{AssayTypes,Clonality,Epitopes,Molecule,DefaultSampleModel,Targets,SecondaryAntibodies}]]},Cache->cache,Date->Now],
		MatchQ[myAnalyte,ObjectP[Model[Molecule,Protein]]],Download[myAnalyte,{Packet[Antibodies],Packet[Antibodies[{AssayTypes,Clonality,Epitopes,Molecule,DefaultSampleModel,Targets,SecondaryAntibodies}]]},Cache->cache,Date->Now],
		True,{}
	];

	(* get a list of possible antibodies for this analyte *)
	possibleAntibodies=If[MatchQ[analytePacket,{}],
		{},
		analytePacket[[2]]
	];

	(* find a sublist of antibodies that are compatibly with ELISA *)
	(* We use this in resolver as a firm restriction. However, if the user selects a sample that is not compatible with ELISA, we only throw a warning. *)
	compatibleAntibodies=Select[possibleAntibodies,MemberQ[Lookup[#,AssayTypes],ELISA]&];

	(* get the default sample models for all the compatible antibodies *)
	compatibleAntibodyDefaultModels=If[MatchQ[compatibleAntibodies,{}],
		Download[possibleAntibodies,DefaultSampleModel[Object],Cache->cache,Date->Now],
		Download[compatibleAntibodies,DefaultSampleModel[Object],Cache->cache,Date->Now]
	];

	(* get the epitope binding position information for every member of compatibleAntibodies *)
	compatibleAntibodyBindingAreas=If[MatchQ[compatibleAntibodies,{}],
		Map[
			findAntibodyEpitopePosition[myAnalyte,#]&,
			possibleAntibodies
		],
		Map[
			findAntibodyEpitopePosition[myAnalyte,#]&,
			compatibleAntibodies
		]
	];

	(* check whether every member of compatible antibody has overlapping epitopes with our detection antibody. A special case is about using the same identity model of antibody for both capture antibody and detection antibody *)
	(* We set no-overlapping as True because it is our preferred case *)
	epitopeOverlapQ=If[MatchQ[compatibleAntibodies,{}],
		MapThread[
			(MatchQ[IntervalIntersection[#1,detectionAntibodyBindingArea],Interval[]])&&(!MemberQ[Lookup[detectionAntibodyIdentityModelPackets,Object,{}],#2])&,
			{compatibleAntibodyBindingAreas,Lookup[possibleAntibodies,Object,{}]}
		],
		MapThread[
			(MatchQ[IntervalIntersection[#1,detectionAntibodyBindingArea],Interval[]])&&(!MemberQ[Lookup[detectionAntibodyIdentityModelPackets,Object,{}],#2])&,
			{compatibleAntibodyBindingAreas,Lookup[compatibleAntibodies,Object,{}]}
		]
	];

	(* check whether any of compatibleAntibodies is already modified by Digoxigenin *)
	digoxigeninModifiedQ=If[!MatchQ[compatibleAntibodies,{}],
		Map[
			MemberQ[Lookup[#,SecondaryAntibodies,{}],ObjectP[Model[Molecule, Protein, Antibody, "id:E8zoYvN9m4aA"]]]&, (* Model[Molecule,Protein,Antibody,"Anti-Digoxigenin Antibody"] *)
			compatibleAntibodies
		],
		Map[
			MemberQ[Lookup[#,SecondaryAntibodies,{}],ObjectP[Model[Molecule, Protein, Antibody, "id:E8zoYvN9m4aA"]]]&, (* Model[Molecule,Protein,Antibody,"Anti-Digoxigenin Antibody"] *)
			possibleAntibodies
		]
	];

	(* check for all polyclonal antibodies, It is preferred for capture antibody *)
	polyclonalQ=If[!MatchQ[compatibleAntibodies,{}],
		Map[
			MatchQ[Lookup[#,Clonality],PolyClonal]&,
			compatibleAntibodies
		],
		Map[
			MatchQ[Lookup[#,Clonality],PolyClonal]&,
			possibleAntibodies
		]
	];

	(* find the best antibody using the three rules with digoxigenin modification as the most important rule and clonality as the least important rule *)
	bestAntibodyPosition=findBestCandidateForCapillaryELISAAntibodies[{digoxigeninModifiedQ,epitopeOverlapQ,polyclonalQ}][[1]];

	(* get the best capture antibody and return warning message if epitopes are shared *)

	bestCaptureAntibodyIdentityModelPacket=If[!MatchQ[compatibleAntibodies,{}],
		Take[compatibleAntibodies,ToList[bestAntibodyPosition]],
		Take[possibleAntibodies,ToList[bestAntibodyPosition]]
	];

	bestCaptureAntibody=Take[compatibleAntibodyDefaultModels,ToList[bestAntibodyPosition]];

	(* Check whether the supplied antibodies are compatible with ELISA assay types *)
	captureAntibodyAssayTypeWarning=!MemberQ[Flatten[Lookup[bestCaptureAntibodyIdentityModelPacket,AssayTypes,{}]],ELISA];

	detectionAntibodyAssayTypeWarning=!MemberQ[Flatten[Lookup[detectionAntibodyIdentityModelPackets,AssayTypes,{}]],ELISA];

	(* check whether this best capture antibody has overlapping epitopes *)
	antibodyEpitopeWarning=Map[
		!#&,
		Take[epitopeOverlapQ,ToList[bestAntibodyPosition]]
	];

	{FirstOrDefault[bestCaptureAntibody,Null],myDetectionAntibody,captureAntibodyAssayTypeWarning,detectionAntibodyAssayTypeWarning,FirstOrDefault[antibodyEpitopeWarning,Null]}

];

(* resolve Detection Antibody when myCaptureAntibody is not Automatic *)
findAntibodyPairs[myAnalyte:ObjectP[Model[Molecule]],myCaptureAntibody:ObjectP[{Model[Sample],Object[Sample]}]|Null,myDetectionAntibody:Automatic,ops:OptionsPattern[]]:=Module[
	{
		safeOps,cache,
		captureAntibodyIdentityModel,captureAntibodyIdentityModelPackets,captureAntibodyBindingArea,
		analytePacket,possibleAntibodies,compatibleAntibodies,compatibleAntibodyDefaultModels,compatibleAntibodyBindingAreas,epitopeOverlapQ,biotinModifiedQ,monoclonalQ,
		bestAntibodyPosition,bestDetectionAntibodyIdentityModelPacket,bestDetectionAntibody,captureAntibodyAssayTypeWarning,detectionAntibodyAssayTypeWarning,antibodyEpitopeWarning
	},

	(* get the Cache option *)
	safeOps=SafeOptions[findAntibodyPairs, ToList[ops]];
	cache=Lookup[safeOps,Cache];

	(* get the capture antibody identity models *)
	captureAntibodyIdentityModel=Cases[Download[myCaptureAntibody,Composition[[All,2]][Object],Cache->cache,Date->Now],ObjectP[Model[Molecule,Protein,Antibody]]];
	captureAntibodyIdentityModelPackets=Download[captureAntibodyIdentityModel,Packet[Targets,Epitopes,SecondaryAntibodies,AssayTypes],Cache->cache,Date->Now];

	(* call helper function to find binding area for each antibody identity model and union them together. Even if myDetectionAntibody is Null, this will work as the helper function should return Interval[] regardless *)
	captureAntibodyBindingArea=IntervalUnion@@Map[
		findAntibodyEpitopePosition[myAnalyte,#]&,
		captureAntibodyIdentityModelPackets
	];

	(* get the analyte packet with information of interest *)
	analytePacket=Which[
		MatchQ[myAnalyte,ObjectP[Model[Molecule,Protein,Antibody]]],Download[myAnalyte,{Packet[SecondaryAntibodies],Packet[SecondaryAntibodies[{AssayTypes,Clonality,Epitopes,Molecule,DefaultSampleModel,Targets,SecondaryAntibodies}]]},Cache->cache,Date->Now],
		MatchQ[myAnalyte,ObjectP[Model[Molecule,Protein]]],Download[myAnalyte,{Packet[Antibodies],Packet[Antibodies[{AssayTypes,Clonality,Epitopes,Molecule,DefaultSampleModel,Targets,SecondaryAntibodies}]]},Cache->cache,Date->Now],
		True,{}
	];

	(* get a list of possible antibodies for this analyte *)
	possibleAntibodies=If[MatchQ[analytePacket,{}],
		{},
		analytePacket[[2]]
	];

	(* We use this in resolver as a firm restriction. However, if the user selects a sample that is not compatible with ELISA, we only throw a warning. *)
	compatibleAntibodies=Select[possibleAntibodies,MemberQ[Lookup[#,AssayTypes],ELISA]&];

	(* get the default sample models for all the compatible antibodies *)
	compatibleAntibodyDefaultModels=If[MatchQ[compatibleAntibodies,{}],
		Download[possibleAntibodies,DefaultSampleModel[Object],Cache->cache,Date->Now],
		Download[compatibleAntibodies,DefaultSampleModel[Object],Cache->cache,Date->Now]
	];

	(* get the epitope binding position information for every member of compatibleAntibodies *)
	compatibleAntibodyBindingAreas=If[MatchQ[compatibleAntibodies,{}],
		Map[
			findAntibodyEpitopePosition[myAnalyte,#]&,
			possibleAntibodies
		],
		Map[
			findAntibodyEpitopePosition[myAnalyte,#]&,
			compatibleAntibodies
		]
	];

	(* check whether every member of compatible antibody has overlapping epitopes with our capture antibody *)
	(* We set no-overlapping as True because it is our preferred case *)
	epitopeOverlapQ=If[MatchQ[compatibleAntibodies,{}],
		MapThread[
			(MatchQ[IntervalIntersection[#1,captureAntibodyBindingArea],Interval[]])&&(!MemberQ[Lookup[captureAntibodyIdentityModelPackets,Object,{}],#2])&,
			{compatibleAntibodyBindingAreas,Lookup[possibleAntibodies,Object,{}]}
		],
		MapThread[
			(MatchQ[IntervalIntersection[#1,captureAntibodyBindingArea],Interval[]])&&(!MemberQ[Lookup[captureAntibodyIdentityModelPackets,Object,{}],#2])&,
			{compatibleAntibodyBindingAreas,Lookup[compatibleAntibodies,Object,{}]}
		]
	];

	(* check whether any of compatibleAntibodies is already modified by Digoxigenin *)
	biotinModifiedQ=If[!MatchQ[compatibleAntibodies,{}],
		Map[
			MemberQ[Lookup[#,Targets,{}],ObjectP[Model[Molecule, Protein, "id:4pO6dM507ZMz"]]]&, (* Model[Molecule,Protein,"Streptavidin"] *)
			compatibleAntibodies
		],
		Map[
			MemberQ[Lookup[#,Targets,{}],ObjectP[Model[Molecule, Protein, "id:4pO6dM507ZMz"]]]&, (* Model[Molecule,Protein,"Streptavidin"] *)
			possibleAntibodies
		]
	];

	(* check for all monoclonal antibodies, It is preferred for detection antibody *)
	monoclonalQ=If[!MatchQ[compatibleAntibodies,{}],
		Map[
			MatchQ[Lookup[#,Clonality],Monoclonal]&,
			compatibleAntibodies
		],
		Map[
			MatchQ[Lookup[#,Clonality],Monoclonal]&,
			possibleAntibodies
		]
	];

	(* find the best antibody using the three rules with digoxigenin modification as the most important rule and clonality as the least important rule *)
	bestAntibodyPosition=findBestCandidateForCapillaryELISAAntibodies[{biotinModifiedQ,epitopeOverlapQ,monoclonalQ}][[1]];

	(* get the best capture antibody and return warning message if epitopes are shared *)

	bestDetectionAntibodyIdentityModelPacket=If[!MatchQ[compatibleAntibodies,{}],
		Take[compatibleAntibodies,ToList[bestAntibodyPosition]],
		Take[possibleAntibodies,ToList[bestAntibodyPosition]]
	];

	bestDetectionAntibody=Take[compatibleAntibodyDefaultModels,ToList[bestAntibodyPosition]];

	(* Check whether the supplied antibodies are compatible with ELISA assay types *)
	captureAntibodyAssayTypeWarning=!MemberQ[Flatten[Lookup[captureAntibodyIdentityModelPackets,AssayTypes,{}]],ELISA];

	detectionAntibodyAssayTypeWarning=!MemberQ[Flatten[Lookup[bestDetectionAntibodyIdentityModelPacket,AssayTypes,{}]],ELISA];

	(* check whether this best capture antibody has overlapping epitopes *)
	antibodyEpitopeWarning=Map[
		!#&,
		Take[epitopeOverlapQ,ToList[bestAntibodyPosition]]
	];

	{myCaptureAntibody,FirstOrDefault[bestDetectionAntibody,Null],captureAntibodyAssayTypeWarning,detectionAntibodyAssayTypeWarning,FirstOrDefault[antibodyEpitopeWarning,Null]}

];


(* when both capture antibody and detection antibody are automatic *)
findAntibodyPairs[myAnalyte:ObjectP[Model[Molecule]],myCaptureAntibody:Automatic,myDetectionAntibody:Automatic,ops:OptionsPattern[]]:=Module[
	{
		safeOps,cache,
		analytePacket,possibleAntibodies,compatibleAntibodies,digoxigeninModifiedQ,biotinModifiedQ,polyclonalQ,monoclonalQ,
		bestCaptureAntibody,bestDetectionAntibody,antibodyEpitopeWarning,captureAntibodyAssayTypeWarning,detectionAntibodyAssayTypeWarning
	},

	(* get the Cache option *)
	safeOps=SafeOptions[findAntibodyPairs,ToList[ops]];
	cache=Lookup[safeOps,Cache];

	(* get the analyte packet with information of interest *)
	analytePacket=Which[
		MatchQ[myAnalyte,ObjectP[Model[Molecule,Protein,Antibody]]],Download[myAnalyte,{Packet[SecondaryAntibodies],Packet[SecondaryAntibodies[{SecondaryAntibodies,AssayTypes,Clonality,Epitopes,Molecule,Targets,DefaultSampleModel}]]},Cache->cache,Date->Now],
		MatchQ[myAnalyte,ObjectP[Model[Molecule,Protein]]],Download[myAnalyte,{Packet[Antibodies],Packet[Antibodies[{SecondaryAntibodies,AssayTypes,Clonality,Epitopes,Molecule,Targets,DefaultSampleModel}]]},Cache->cache,Date->Now],
		True,{}
	];

	(* get a list of possible antibodies for this analyte *)
	possibleAntibodies=If[MatchQ[analytePacket,{}],
		{},
		analytePacket[[2]]
	];

	(* find a sublist of antibodies that are compatibly with ELISA *)
	(* We use this in resolver as a restriction. However, if we end up with an antibody sample that is not compatible with ELISA, we only throw a warning. *)
	compatibleAntibodies=Select[possibleAntibodies,MemberQ[Lookup[#,AssayTypes],ELISA]&];

	(* check whether the antibody molecules are modified or not *)
	digoxigeninModifiedQ=If[!MatchQ[compatibleAntibodies,{}],
		Map[
			MemberQ[Lookup[#,SecondaryAntibodies,{}],ObjectP[Model[Molecule, Protein, Antibody, "id:E8zoYvN9m4aA"]]]&, (* Model[Molecule,Protein,Antibody,"Anti-Digoxigenin Antibody"] *)
			compatibleAntibodies
		],
		Map[
			MemberQ[Lookup[#,SecondaryAntibodies,{}],ObjectP[Model[Molecule, Protein, Antibody, "id:E8zoYvN9m4aA"]]]&, (* Model[Molecule,Protein,Antibody,"Anti-Digoxigenin Antibody"] *)
			possibleAntibodies
		]
	];

	biotinModifiedQ=If[!MatchQ[compatibleAntibodies,{}],
		Map[
			MemberQ[Lookup[#,Targets,{}],ObjectP[Model[Molecule, Protein, "id:4pO6dM507ZMz"]]]&, (* Model[Molecule,Protein,"Streptavidin"] *)
			compatibleAntibodies
		],
		Map[
			MemberQ[Lookup[#,Targets,{}],ObjectP[Model[Molecule, Protein, "id:4pO6dM507ZMz"]]]&, (* Model[Molecule,Protein,"Streptavidin"] *)
			possibleAntibodies
		]
	];

	(* check for all Polyclonal antibodies, It is preferred for capture antibody *)
	polyclonalQ=If[!MatchQ[compatibleAntibodies,{}],
		Map[
			MatchQ[Lookup[#,Clonality],PolyClonal]&,
			compatibleAntibodies
		],
		Map[
			MatchQ[Lookup[#,Clonality],PolyClonal]&,
			possibleAntibodies
		]
	];

	(* check for all Monoclonal antibodies, It is preferred for detection antibody *)
	monoclonalQ=If[!MatchQ[compatibleAntibodies,{}],
		Map[
			MatchQ[Lookup[#,Clonality],Monoclonal]&,
			compatibleAntibodies
		],
		Map[
			MatchQ[Lookup[#,Clonality],Monoclonal]&,
			possibleAntibodies
		]
	];

	(* do a big which to find the best capture antibody and detection antibody pair depending on how many modified antibody we have found. *)
	(* We have 2 helper functions to check when capture antibody or detection antibody is pre-selected as a list of equivalent options - like same modifications, etc *)
	{bestCaptureAntibody,bestDetectionAntibody,captureAntibodyAssayTypeWarning,detectionAntibodyAssayTypeWarning,antibodyEpitopeWarning}=Which[

		(* If we don't have any possibleAntibodies, just return Null *)
		TrueQ[Length[possibleAntibodies]==0],{Null,Null,False,False,False},

		(* All the following cases are actually over-complicated. These may take some time to evaluate. However, we should expect this list to be fairly short so the running time is not very long. We are calling the list version of the function that has capture antibody/ detection antibody fixed, which has the weight value transferred for comparison. *)
		(* If we have digoxigenin-modified antibody, assign it as the capture antibody and the problem becomes similar to the overload above with one defined by the user. Map through all digoxigenin-modified antibody. *)
		TrueQ[Count[digoxigeninModifiedQ,True]>=1]&&!MatchQ[compatibleAntibodies,{}],findAntibodyPairsFromListCaptureAntibodyOptions[myAnalyte,PickList[compatibleAntibodies,digoxigeninModifiedQ],PickList[compatibleAntibodies,digoxigeninModifiedQ,False],Cache->cache],

		(* Same for biotin-modified antibody *)
		TrueQ[Count[biotinModifiedQ,True]>=1]&&!MatchQ[compatibleAntibodies,{}],findAntibodyPairsFromListDetectionAntibodyOptions[myAnalyte,PickList[compatibleAntibodies,biotinModifiedQ,False],PickList[compatibleAntibodies,biotinModifiedQ],Cache->cache],

		(* Then we can check clonality *)
		TrueQ[Count[polyclonalQ,True]>=1]&&!MatchQ[compatibleAntibodies,{}],findAntibodyPairsFromListCaptureAntibodyOptions[myAnalyte,PickList[compatibleAntibodies,polyclonalQ],compatibleAntibodies,Cache->cache],
		TrueQ[Count[monoclonalQ,True]>=1]&&!MatchQ[compatibleAntibodies,{}],findAntibodyPairsFromListCaptureAntibodyOptions[myAnalyte,compatibleAntibodies,PickList[compatibleAntibodies,monoclonalQ],Cache->cache],

		(* Finally we are going to randomly choose a combination. *)
		!MatchQ[compatibleAntibodies,{}],findAntibodyPairsFromListCaptureAntibodyOptions[myAnalyte,compatibleAntibodies,compatibleAntibodies,Cache->cache],

		(* Repeat the checks when we don't have assay types populated *)
		TrueQ[Count[digoxigeninModifiedQ,True]>=1]&&!MatchQ[possibleAntibodies,{}],findAntibodyPairsFromListCaptureAntibodyOptions[myAnalyte,PickList[possibleAntibodies,digoxigeninModifiedQ],PickList[possibleAntibodies,digoxigeninModifiedQ,False],Cache->cache],

		(* Same for biotin-modified antibody *)
		TrueQ[Count[biotinModifiedQ,True]>=1]&&!MatchQ[possibleAntibodies,{}],findAntibodyPairsFromListDetectionAntibodyOptions[myAnalyte,PickList[possibleAntibodies,biotinModifiedQ,False],PickList[possibleAntibodies,biotinModifiedQ],Cache->cache],

		(* Then we can check clonality *)
		TrueQ[Count[polyclonalQ,True]>=1]&&!MatchQ[possibleAntibodies,{}],findAntibodyPairsFromListCaptureAntibodyOptions[myAnalyte,PickList[possibleAntibodies,polyclonalQ],possibleAntibodies,Cache->cache],
		TrueQ[Count[monoclonalQ,True]>=1]&&!MatchQ[possibleAntibodies,{}],findAntibodyPairsFromListCaptureAntibodyOptions[myAnalyte,possibleAntibodies,PickList[possibleAntibodies,monoclonalQ],Cache->cache],

		True,findAntibodyPairsFromListCaptureAntibodyOptions[myAnalyte,possibleAntibodies,possibleAntibodies,Cache->cache]

	];

	(* Return the information *)
	{bestCaptureAntibody,bestDetectionAntibody,captureAntibodyAssayTypeWarning,detectionAntibodyAssayTypeWarning,antibodyEpitopeWarning}
];


(* resolve the best Capture Antibody when myDetectionAntibody has a list of equivalent options to choose from *)
findAntibodyPairsFromListDetectionAntibodyOptions[myAnalyte:ObjectP[Model[Molecule]],myCaptureAntibody:{PacketP[Model[Molecule]]..},myDetectionAntibody:{PacketP[Model[Molecule]]..},ops:OptionsPattern[]]:=Module[
    {
        safeOps,cache,detectionAntibodyBindingArea,captureAntibodyDefaultModels,detectionAntibodyDefaultModels,captureAntibodyBindingAreas,
        epitopeOverlapQ,digoxigeninModifiedQ,expandedDigoxigeninModifiedQ,polyclonalQ,expandedPolyclonalQ,
        bestAntibodyPositionForAllDetectionAntibody,bestAntibodyPosition,bestDetectionAntibody,bestCaptureAntibody,bestCaptureAntibodyIdentityModelPacket,bestDetectionAntibodyIdentityModelPacket,antibodyEpitopeWarning,captureAntibodyAssayTypeWarning,detectionAntibodyAssayTypeWarning
    },

    (* get the Cache option *)
    safeOps=SafeOptions[findAntibodyPairs, ToList[ops]];
    cache=Lookup[safeOps,Cache];

    (* call helper function to find binding area for each antibody identity model and union them together. Even if myDetectionAntibody is Null, this will work as the helper function should return Interval[] regardless *)
    detectionAntibodyBindingArea=Map[
        IntervalUnion[#]&,
        Map[
            findAntibodyEpitopePosition[myAnalyte,#]&,
            myDetectionAntibody
        ]
    ];

    (* get the default sample models for all the possible capture and detection antibodies *)
    captureAntibodyDefaultModels=Download[myCaptureAntibody,DefaultSampleModel[Object],Cache->cache,Date->Now];
    detectionAntibodyDefaultModels=Download[myDetectionAntibody,DefaultSampleModel[Object],Cache->cache,Date->Now];

    (* get the epitope binding position information for every member of myCaptureAntibody *)
    captureAntibodyBindingAreas=Map[
        findAntibodyEpitopePosition[myAnalyte,#]&,
        myCaptureAntibody
    ];

    (* check whether every member of compatible antibody has overlapping epitopes with every detection antibody *)
	(* We set no-overlapping as True because it is our preferred case *)
    epitopeOverlapQ=MapThread[
        Function[{singleDetectionAntibodyBindingArea,detectionAntibodyIdentityModel},
			MapThread[
				(MatchQ[IntervalIntersection[#1,singleDetectionAntibodyBindingArea],Interval[]])&&(!MatchQ[#2,detectionAntibodyIdentityModel])&,
                {captureAntibodyBindingAreas,myCaptureAntibody}
            ]
        ],
        {detectionAntibodyBindingArea,myDetectionAntibody}
    ];

    (* check whether any of myCaptureAntibody is already modified by Digoxigenin *)
    digoxigeninModifiedQ=Map[
		MemberQ[Lookup[#,SecondaryAntibodies,{}],ObjectP[Model[Molecule, Protein, Antibody, "id:E8zoYvN9m4aA"]]]&, (* Model[Molecule,Protein,Antibody,"Anti-Digoxigenin Antibody"] *)
        myCaptureAntibody
    ];

    (* expand the boolean list to match the length of possible detection antibody *)
    expandedDigoxigeninModifiedQ=ConstantArray[digoxigeninModifiedQ,Length[myDetectionAntibody]];

    (* check for all polyclonal antibodies, It is preferred for capture antibody *)
    polyclonalQ=Map[
        MatchQ[Lookup[#,Clonality],PolyClonal]&,
        myCaptureAntibody
    ];

    (* expand the boolean list to match the length of possible detection antibody *)
    expandedPolyclonalQ=ConstantArray[polyclonalQ,Length[myDetectionAntibody]];

    (* find the best antibody for each detection antibody using the three rules with digoxigenin modification as the most important rule and clonality as the least important rule *)
    bestAntibodyPositionForAllDetectionAntibody=MapThread[
        findBestCandidateForCapillaryELISAAntibodies[{#1,#2,#3}]&,
        {expandedDigoxigeninModifiedQ,epitopeOverlapQ,expandedPolyclonalQ}
    ];

    (* find the best of all possible cases. *)
    bestAntibodyPosition=Ordering[bestAntibodyPositionForAllDetectionAntibody[[All,2]],-1];

    (* find the best detection antibody from the list *)
	bestDetectionAntibodyIdentityModelPacket=Take[myDetectionAntibody,bestAntibodyPosition];
    bestDetectionAntibody=Take[detectionAntibodyDefaultModels,bestAntibodyPosition];

    (* find the best capture antibody from the list *)
	bestCaptureAntibodyIdentityModelPacket=Take[myCaptureAntibody,Take[bestAntibodyPositionForAllDetectionAntibody,bestAntibodyPosition][[All,1,1]]];
    bestCaptureAntibody=Take[captureAntibodyDefaultModels,Take[bestAntibodyPositionForAllDetectionAntibody,bestAntibodyPosition][[All,1,1]]];

	(* Check whether the supplied antibodies are compatible with ELISA assay types *)
	captureAntibodyAssayTypeWarning=!MemberQ[Flatten[Lookup[bestCaptureAntibodyIdentityModelPacket,AssayTypes,{}]],ELISA];

	detectionAntibodyAssayTypeWarning=!MemberQ[Flatten[Lookup[bestDetectionAntibodyIdentityModelPacket,AssayTypes,{}]],ELISA];

    (* check whether this best capture antibody has overlapping epitopes *)
    antibodyEpitopeWarning=Map[
		!#&,
		Take[Take[epitopeOverlapQ,bestAntibodyPosition][[1]],Take[bestAntibodyPositionForAllDetectionAntibody,bestAntibodyPosition][[All,1,1]]]
	];

    (* return the antibody pairs and warning *)
    {FirstOrDefault[bestCaptureAntibody,Null],FirstOrDefault[bestDetectionAntibody,Null],captureAntibodyAssayTypeWarning,detectionAntibodyAssayTypeWarning,FirstOrDefault[antibodyEpitopeWarning,Null]}

];


(* resolve the best Detection Antibody when myCaptureAntibody has a list of equivalent options to choose from *)
findAntibodyPairsFromListCaptureAntibodyOptions[myAnalyte:ObjectP[Model[Molecule]],myCaptureAntibody:{PacketP[Model[Molecule]]..},myDetectionAntibody:{PacketP[Model[Molecule]]..},ops:OptionsPattern[]]:=Module[
    {
        safeOps,cache,captureAntibodyBindingArea,captureAntibodyDefaultModels,detectionAntibodyDefaultModels,detectionAntibodyBindingAreas,
        epitopeOverlapQ,biotinModifiedQ,expandedBiotinModifiedQ,monoclonalQ,expandedMonoclonalQ,
        bestAntibodyPositionForAllCaptureAntibody,bestAntibodyPosition,bestDetectionAntibody,bestCaptureAntibody,bestCaptureAntibodyIdentityModelPacket,bestDetectionAntibodyIdentityModelPacket,antibodyEpitopeWarning,captureAntibodyAssayTypeWarning,detectionAntibodyAssayTypeWarning

    },

    (* get the Cache option *)
    safeOps=SafeOptions[findAntibodyPairs, ToList[ops]];
    cache=Lookup[safeOps,Cache];

    (* call helper function to find binding area for each antibody identity model and union them together. Even if myDetectionAntibody is Null, this will work as the helper function should return Interval[] regardless *)
    captureAntibodyBindingArea=Map[
        IntervalUnion[#]&,
        Map[
            findAntibodyEpitopePosition[myAnalyte,#]&,
            myCaptureAntibody
        ]
    ];

    (* get the default sample models for all the possible capture antibodies *)
	captureAntibodyDefaultModels=Download[myCaptureAntibody,DefaultSampleModel[Object],Cache->cache,Date->Now];
	detectionAntibodyDefaultModels=Download[myDetectionAntibody,DefaultSampleModel[Object],Cache->cache,Date->Now];

    (* get the epitope binding position information for every member of myDetectionAntibody *)
    detectionAntibodyBindingAreas=Map[
        findAntibodyEpitopePosition[myAnalyte,#]&,
        myDetectionAntibody
    ];

    (* check whether every member of detection antibody has overlapping epitopes with every capture antibody *)
    epitopeOverlapQ=MapThread[
        Function[{singleCaptureAntibodyBindingArea,captureAntibodyIdentityModel},
            MapThread[
				(MatchQ[IntervalIntersection[#1,singleCaptureAntibodyBindingArea],Interval[]])&&(!MatchQ[#2,captureAntibodyIdentityModel])&,
                {detectionAntibodyBindingAreas,myDetectionAntibody}
            ]
        ],
        {captureAntibodyBindingArea,myCaptureAntibody}
    ];

    (* check whether any of myDetectionAntibody is already modified by Biotin *)
    biotinModifiedQ=Map[
		MemberQ[Lookup[#,Targets,{}],ObjectP[Model[Molecule, Protein, "id:4pO6dM507ZMz"]]]&, (* Model[Molecule,Protein,"Streptavidin"] *)
        myDetectionAntibody
    ];

    (* expand the boolean list to match the length of possible capture antibody *)
    expandedBiotinModifiedQ=ConstantArray[biotinModifiedQ,Length[myCaptureAntibody]];

    (* check for all monoclonal antibodies, It is preferred for detection antibody *)
    monoclonalQ=Map[
        MatchQ[Lookup[#,Clonality],PolyClonal]&,
        myDetectionAntibody
    ];

    (* expand the boolean list to match the length of possible detection antibody *)
    expandedMonoclonalQ=ConstantArray[monoclonalQ,Length[myCaptureAntibody]];

    (* find the best antibody for each detection antibody using the three rules with digoxigenin modification as the most important rule and clonality as the least important rule *)
    bestAntibodyPositionForAllCaptureAntibody=MapThread[
        findBestCandidateForCapillaryELISAAntibodies[{#1,#2,#3}]&,
        {expandedBiotinModifiedQ,epitopeOverlapQ,expandedMonoclonalQ}
    ];

    (* find the best of all possible cases. *)
    bestAntibodyPosition=Ordering[bestAntibodyPositionForAllCaptureAntibody[[All,2]],-1];

    (* find the best capture antibody from the list *)
	bestCaptureAntibodyIdentityModelPacket=Take[myCaptureAntibody,bestAntibodyPosition];
    bestCaptureAntibody=Take[captureAntibodyDefaultModels,bestAntibodyPosition];

    (* find the best capture antibody from the list *)
	bestDetectionAntibodyIdentityModelPacket=Take[myDetectionAntibody,Take[bestAntibodyPositionForAllCaptureAntibody,bestAntibodyPosition][[All,1,1]]];
    bestDetectionAntibody=Take[detectionAntibodyDefaultModels,Take[bestAntibodyPositionForAllCaptureAntibody,bestAntibodyPosition][[All,1,1]]];

	(* Check whether the supplied antibodies are compatible with ELISA assay types *)
	captureAntibodyAssayTypeWarning=!MemberQ[Flatten[Lookup[bestCaptureAntibodyIdentityModelPacket,AssayTypes,{}]],ELISA];

	detectionAntibodyAssayTypeWarning=!MemberQ[Flatten[Lookup[bestDetectionAntibodyIdentityModelPacket,AssayTypes,{}]],ELISA];

    (* check whether this best capture antibody has overlapping epitopes *)
    antibodyEpitopeWarning=Map[
		!#&,
		Take[Take[epitopeOverlapQ,bestAntibodyPosition][[1]],Take[bestAntibodyPositionForAllCaptureAntibody,bestAntibodyPosition][[All,1,1]]]
	];

    (* return the antibody pairs and warning *)
    {FirstOrDefault[bestCaptureAntibody,Null],FirstOrDefault[bestDetectionAntibody,Null],captureAntibodyAssayTypeWarning,detectionAntibodyAssayTypeWarning,FirstOrDefault[antibodyEpitopeWarning,Null]}

];


(* ::Subsubsubsection::Closed:: *)
(* calculateDigoxigeninVolume *)

calculateDigoxigeninVolume[molecularWeight:GreaterEqualP[0Dalton],digoxigeninMolecularWeight:GreaterEqualP[0Dalton],antibodyVolume:GreaterEqualP[0Microliter],antibodyConcentration:GreaterEqualP[0Milligram/Milliliter]|GreaterEqualP[0Molar],digoxigeninConcentration:GreaterEqualP[0Milligram/Milliliter]|GreaterEqualP[0Molar]]:=Module[
    {
        digoxigeninMolarConcentration,antibodyMolarConcentration,digoxigeninReagentVolume
    },

    (* Covert to molar concentration *)
    digoxigeninMolarConcentration=If[MatchQ[digoxigeninConcentration,GreaterEqualP[0Milligram/Milliliter]],
        digoxigeninConcentration/digoxigeninMolecularWeight,
        digoxigeninConcentration
    ];
    antibodyMolarConcentration=If[MatchQ[antibodyConcentration,GreaterEqualP[0Milligram/Milliliter]],
        antibodyConcentration/molecularWeight,
        antibodyConcentration
    ];

    (* Return the volume with unit converted to Microliter*)
    digoxigeninReagentVolume=UnitConvert[5*antibodyMolarConcentration*antibodyVolume/digoxigeninMolarConcentration,Microliter]

];


(* ::Subsubsubsection::Closed:: *)
(* calculateBiotinVolume *)

calculateBiotinVolume[molecularWeight:GreaterEqualP[0Dalton],biotinMolecularWeight:GreaterEqualP[0Dalton],antibodyVolume:GreaterEqualP[0Microliter],antibodyConcentration:GreaterEqualP[0Milligram/Milliliter]|GreaterEqualP[0Molar],biotinConcentration:GreaterEqualP[0Milligram/Milliliter]|GreaterEqualP[0Molar]]:=Module[
    {
        biotinMolarConcentration,antibodyMolarConcentration,biotinReagentVolume
    },

    (* Covert to molar concentration *)
    biotinMolarConcentration=If[MatchQ[digoxigeninConcentration,GreaterEqualP[0Milligram/Milliliter]],
        biotinConcentration/biotinMolecularWeight,
        biotinConcentration
    ];
    antibodyMolarConcentration=If[MatchQ[antibodyConcentration,GreaterEqualP[0Milligram/Milliliter]],
        antibodyConcentration/molecularWeight,
        antibodyConcentration
    ];

    (* Return the volume with unit converted to Microliter*)
    biotinReagentVolume=UnitConvert[10*antibodyMolarConcentration*antibodyVolume/biotinMolarConcentration,Microliter]

];




(* ::Subsubsection::Closed:: *)
(* ExperimentCapillaryELISA Resource Packets *)


DefineOptions[
	capillaryELISAResourcePackets,
	Options:>{HelperOutputOption,CacheOption}
];


capillaryELISAResourcePackets[mySamples:{ObjectP[Object[Sample]]..}, myUnresolvedOptions:{___Rule}, myResolvedOptions:{___Rule},ops:OptionsPattern[]]:=Module[
    {
        (* General variables *)
        expandedInputs, expandedResolvedOptions,resolvedOptionsNoHidden,outputSpecification,output,gatherTests,messages,inheritedCache,
        liquidHandlerCompatibleContainers,potentialSpinColumns,numberOfReplicates,samplesWithReplicates,optionsWithReplicates, inheritedFastAssoc,

        (* Cartridge *)
        cartridge,cartridgeType,species,analytes,preLoadedAnalytes,preLoadedAnalyteNames,preLoadedAnalyteMolecules,customizableAnalyteMolecules,requiredCartridge,cartridgeResource,requiredCartridgePacket,multiplex,analyteMolecules,analyteNames,multiplexAnalyteMolecules,multiplexAnalyteNames,preaLoadedAnalyteManufacturingSpecifications,manufacturingSpecifications,upperQuantitationLimits,lowerQuantitationLimits,

        (* Sample *)
        sampleVolume,dilutionCurve,serialDilutionCurve,requiredSampleVolumes,samplesInResources,containersInObjects,containersInResources,

        (* Standard *)
        standard,standardDilutionCurve,standardSerialDilutionCurve,requiredStandardVolumes,standardResuspension,standardResuspensionConcentration,requiredStandardAmounts,standardPackets,standardIdentityModels,standardMolecularWeights,standardAverageMolecularWeight,standardContainers,standardTargetContainers,standardResources,

        (* Spike *)
		spikeSample,spikeVolume,spikePackets,spikeOriginalContainers,spikeTargetContainers,spikeResources,

        numberOfInputSamples,numberOfstandardSamples,joinedNumberOfSamples,

        (* Capture Antibody *)
		customCaptureAntibody,captureAntibodyResuspension,captureAntibodyResuspensionConcentration,captureAntibodyResuspensionDiluent,captureAntibodyStorageCondition,captureAntibodyConjugation,captureAntibodyVolume,digoxigeninReagent,digoxigeninReagentVolume,captureAntibodyConjugationBuffer,captureAntibodyConjugationBufferVolume,captureAntibodyConjugationContainer,captureAntibodyConjugationTime,captureAntibodyConjugationTemperature,captureAntibodyPurificationColumn,captureAntibodyColumnWashBuffer,captureAntibodyConjugationStorageCondition,captureAntibodyDilution,captureAntibodyTargetConcentration,captureAntibodyDiluent,
		standardCaptureAntibody,standardCaptureAntibodyResuspension,standardCaptureAntibodyResuspensionConcentration,standardCaptureAntibodyResuspensionDiluent,standardCaptureAntibodyStorageCondition,standardCaptureAntibodyConjugation,standardCaptureAntibodyVolume,standardDigoxigeninReagent,standardDigoxigeninReagentVolume,standardCaptureAntibodyConjugationBuffer,standardCaptureAntibodyConjugationBufferVolume,standardCaptureAntibodyConjugationContainer,standardCaptureAntibodyConjugationTime,standardCaptureAntibodyConjugationTemperature,standardCaptureAntibodyPurificationColumn,standardCaptureAntibodyColumnWashBuffer,standardCaptureAntibodyConjugationStorageCondition,standardCaptureAntibodyDilution,standardCaptureAntibodyTargetConcentration,standardCaptureAntibodyDiluent,
		captureAntibodyLoadingVolume,standardCaptureAntibodyLoadingVolume,
		joinedCaptureAntibody,joinedCaptureAntibodyResuspension,joinedCaptureAntibodyResuspensionConcentration,joinedCaptureAntibodyResuspensionDiluent,joinedCaptureAntibodyStorageCondition,joinedCaptureAntibodyConjugation,joinedCaptureAntibodyVolume,joinedDigoxigeninReagent,joinedDigoxigeninReagentVolume,joinedCaptureAntibodyConjugationBuffer,joinedCaptureAntibodyConjugationBufferVolume,joinedCaptureAntibodyConjugationContainer,joinedCaptureAntibodyConjugationTime,joinedCaptureAntibodyConjugationTemperature,joinedCaptureAntibodyPurificationColumn,joinedCaptureAntibodyColumnWashBuffer,joinedCaptureAntibodyConjugationStorageCondition,joinedCaptureAntibodyDilution,joinedCaptureAntibodyTargetConcentration,joinedCaptureAntibodyDiluent,
		joinedCaptureAntibodyLoadingVolume,

        joinedCaptureAntibodyPackets,joinedCaptureAntibodyIdentityModels,jointCaptureAntibodyMolecularWeights,jointCaptureAntibodyAverageMolecularWeight,joinedCaptureAntibodyConcentration,joinedCaptureAntibodyContainers,requiredCaptureAntibodyLoadingVolumes,requiredCaptureAntibodyDilutionVolumes,requiredCaptureAntibodyConjugationVolumes,totalCaptureAntibodyPreparationVolumes,standardCaptureAntibodyOptions,captureAntibodyOptions,joinedCaptureAntibodyOptions,joinedCaptureAntibodyOptionsRuleList,pairedCaptureAntibodyOptionAndLoadingVolumes,uniqueRequiredCaptureAntibodyLoadingVolumes,uniqueRequiredCaptureAntibodyNumbers,uniqueRequiredCaptureAntibodyVolumes,uniqueRequiredCaptureAntibodyAmounts,uniqueCaptureAntibodyTargetContainers,uniqueCaptureAntibodyResources,uniqueCaptureAntibodyResourcesRules,customCaptureAntibodyResources,standardCaptureAntibodyResources,

        (* Detection Antibody *)
		customDetectionAntibody,detectionAntibodyResuspension,detectionAntibodyResuspensionConcentration,detectionAntibodyResuspensionDiluent,detectionAntibodyStorageCondition,detectionAntibodyConjugation,detectionAntibodyVolume,biotinReagent,biotinReagentVolume,detectionAntibodyConjugationBuffer,detectionAntibodyConjugationBufferVolume,detectionAntibodyConjugationContainer,detectionAntibodyConjugationTime,detectionAntibodyConjugationTemperature,detectionAntibodyPurificationColumn,detectionAntibodyColumnWashBuffer,detectionAntibodyConjugationStorageCondition,detectionAntibodyDilution,detectionAntibodyTargetConcentration,detectionAntibodyDiluent,
		standardDetectionAntibody,standardDetectionAntibodyResuspension,standardDetectionAntibodyResuspensionConcentration,standardDetectionAntibodyResuspensionDiluent,standardDetectionAntibodyStorageCondition,standardDetectionAntibodyConjugation,standardDetectionAntibodyVolume,standardBiotinReagent,standardBiotinReagentVolume,standardDetectionAntibodyConjugationBuffer,standardDetectionAntibodyConjugationBufferVolume,standardDetectionAntibodyConjugationContainer,standardDetectionAntibodyConjugationTime,standardDetectionAntibodyConjugationTemperature,standardDetectionAntibodyPurificationColumn,standardDetectionAntibodyColumnWashBuffer,standardDetectionAntibodyConjugationStorageCondition,standardDetectionAntibodyDilution,standardDetectionAntibodyTargetConcentration,standardDetectionAntibodyDiluent,
		detectionAntibodyLoadingVolume,standardDetectionAntibodyLoadingVolume,
		joinedDetectionAntibody,joinedDetectionAntibodyResuspension,joinedDetectionAntibodyResuspensionConcentration,joinedDetectionAntibodyResuspensionDiluent,joinedDetectionAntibodyStorageCondition,joinedDetectionAntibodyConjugation,joinedDetectionAntibodyVolume,joinedBiotinReagent,joinedBiotinReagentVolume,joinedDetectionAntibodyConjugationBuffer,joinedDetectionAntibodyConjugationBufferVolume,joinedDetectionAntibodyConjugationContainer,joinedDetectionAntibodyConjugationTime,joinedDetectionAntibodyConjugationTemperature,joinedDetectionAntibodyPurificationColumn,joinedDetectionAntibodyColumnWashBuffer,joinedDetectionAntibodyConjugationStorageCondition,joinedDetectionAntibodyDilution,joinedDetectionAntibodyTargetConcentration,joinedDetectionAntibodyDiluent,
		joinedDetectionAntibodyLoadingVolume,
		joinedDetectionAntibodyPackets,joinedDetectionAntibodyIdentityModels,jointDetectionAntibodyMolecularWeights,jointDetectionAntibodyAverageMolecularWeight,joinedDetectionAntibodyConcentration,joinedDetectionAntibodyContainers,requiredDetectionAntibodyLoadingVolumes,requiredDetectionAntibodyDilutionVolumes,requiredDetectionAntibodyConjugationVolumes,totalDetectionAntibodyPreparationVolumes,standardDetectionAntibodyOptions,detectionAntibodyOptions,joinedDetectionAntibodyOptions,joinedDetectionAntibodyOptionsRuleList,pairedDetectionAntibodyOptionAndLoadingVolumes,uniqueRequiredDetectionAntibodyLoadingVolumes,uniqueRequiredDetectionAntibodyNumbers,uniqueRequiredDetectionAntibodyVolumes,uniqueRequiredDetectionAntibodyAmounts,uniqueDetectionAntibodyTargetContainers,uniqueDetectionAntibodyResources,uniqueDetectionAntibodyResourcesRules,customDetectionAntibodyResources,standardDetectionAntibodyResources,

        (* Conjugation Reagents *)
        allDigoxigeninReagents,allDigoxigeninReagentVolumes,pairedDigoxigeninReagentAndVolumes,digoxigeninVolumeRules,uniqueDigoxigeninResources,uniqueDigoxigeninReagentObjects,uniqueDigoxigeninResourceReplaceRules,digoxigeninReagentResources,standardDigoxigeninReagentResources,
        allBiotinReagents,allBiotinReagentVolumes,pairedBiotinReagentAndVolumes,biotinVolumeRules,uniqueBiotinResources,uniqueBiotinReagentObjects,uniqueBiotinResourceReplaceRules,biotinReagentResources,standardBiotinReagentResources,
        allAntibodyConjugationBuffers,allAntibodyConjugationBufferVolumes,pairedConjugationBuffersAndVolumes,conjugationBufferVolumeRules,uniqueConjugationBufferResources,uniqueConjugationBufferObjects,uniqueConjugationBufferResourceReplaceRules,captureAntibodyConjugationBufferResources,standardCaptureAntibodyConjugationBufferResources,detectionAntibodyConjugationBufferResources,standardDetectionAntibodyConjugationBufferResources,

        (* Diluents and Buffers *)
        requiredStandardDiluentVolumes,pairedStandardDiluentsAndVolumes,requiredDiluentVolumes,pairedDiluentsAndVolumes,allAntibodyDiluents,allAntibodyDiluentVolumes,pairedAntibodyDiluentsAndVolumes,extraDiluent,totalNumberOfSamples,numberOfEmptyWells,extraDiluentVolume,pairedExtraDiluentAndVolume,diluentVolumeRules,uniqueDiluentResources,uniqueDiluentObjects,uniqueDiluentReplaceRules,standardDiluentResources,diluentResources,captureAntibodyDiluentResources,standardCaptureAntibodyDiluentResources,detectionAntibodyDiluentResources,standardDetectionAntibodyDiluentResources,extraDiluentResource,
        allAntibodyColumnWashBuffers,allAntibodyColumnWashBufferVolumes,pairedAntibodyColumnWashBuffersAndVolumes,antibodyDilutionInitialConcentrations,missingAntibodyAbsorbanceBlank,extraAntibodyAbsorbanceBlank,extraAntibodyAbsorbanceBlanksAndVolumes,bufferVolumeRules,uniqueBufferResources,uniqueBufferObjects,uniqueBufferReplaceRules,captureAntibodyColumnWashBufferResources,standardCaptureAntibodyColumnWashBufferResources,detectionAntibodyColumnWashBufferResources,standardDetectionAntibodyColumnWashBufferResources,captureAntibodyAbsorbanceBlank,standardCaptureAntibodyAbsorbanceBlank,detectionAntibodyAbsorbanceBlank,standardDetectionAntibodyAbsorbanceBlank,captureAntibodyAbsorbanceBlankResources,standardCaptureAntibodyAbsorbanceBlankResources,detectionAntibodyAbsorbanceBlankResources,standardDetectionAntibodyAbsorbanceBlankResources,
        requiredWashBufferVolume,washBufferResource,

        (* Containers *)
        spikeContainer,spikeContainerResource,
		dilutionContainer,dilutionContainerResource,
        uniqueCaptureAntibodyConjugationContainers,uniqueCaptureAntibodyPurificationColumns,uniqueCaptureAntibodyDilutionContainers,uniqueDetectionAntibodyConjugationContainers,uniqueDetectionAntibodyPurificationColumns,uniqueDetectionAntibodyDilutionContainers,uniqueCaptureAntibodyConjugationContainerResources,uniqueCaptureAntibodyPurificationColumnResources,uniqueCaptureAntibodyDilutionContainerResources,uniqueDetectionAntibodyConjugationContainerResources,uniqueDetectionAntibodyPurificationColumnResources,uniqueDetectionAntibodyDilutionContainerResources,uniqueCaptureAntibodyConjugationContainerReplaceRules,uniqueDetectionAntibodyConjugationContainerReplaceRules,uniqueCaptureAntibodyPurificationColumnReplaceRules,uniqueDetectionAntibodyPurificationColumnReplaceRules,uniqueCaptureAntibodyDilutionContainerReplaceRules,uniqueDetectionAntibodyDilutionContainerReplaceRules,captureAntibodyConjugationContainerResources,standardCaptureAntibodyConjugationContainerResources,detectionAntibodyConjugationContainerResources,standardDetectionAntibodyConjugationContainerResources,captureAntibodyPurificationColumnResources,standardCaptureAntibodyPurificationColumnResources,detectionAntibodyPurificationColumnResources,standardDetectionAntibodyPurificationColumnResources,captureAntibodyDilutionContainerResources,standardCaptureAntibodyDilutionContainerResources,detectionAntibodyDilutionContainerResources,standardDetectionAntibodyDilutionContainerResources,
		uniqueCaptureAntibodyPurificationColumnPackets,uniqueDetectionAntibodyPurificationColumnModels,uniqueCaptureAntibodyPurificationColumnModels,uniqueDetectionAntibodyPurificationColumnPackets,

		uniqueCaptureAntibodyPurificationColumnCollectionVials,uniqueDetectionAntibodyPurificationColumnCollectionVials,uniqueCaptureAntibodyPurificationColumnWashContainers,uniqueDetectionAntibodyPurificationColumnWashContainers,uniqueCaptureAntibodyPurificationColumnCollectionVialResources,uniqueDetectionAntibodyPurificationColumnCollectionVialResources,uniqueCaptureAntibodyPurificationColumnWashContainerResources,uniqueDetectionAntibodyPurificationColumnWashContainerResources,uniqueCaptureAntibodyPurificationWasteContainers,uniqueDetectionAntibodyPurificationWasteContainers,uniqueCaptureAntibodyPurificationWasteContainerResources,uniqueDetectionAntibodyPurificationWasteContainerResources,uniqueCaptureAntibodyPurificationColumnCollectionVialReplaceRules,uniqueDetectionAntibodyPurificationColumnCollectionVialReplaceRules,uniqueCaptureAntibodyPurificationColumnWashContainerReplaceRules,uniqueDetectionAntibodyPurificationColumnWashContainerReplaceRules,uniqueCaptureAntibodyPurificationWasteContainerReplaceRules,uniqueDetectionAntibodyPurificationWasteContainerReplaceRules,captureAntibodyPurificationColumnCollectionVialResources,standardCaptureAntibodyPurificationColumnCollectionVialResources,detectionAntibodyPurificationColumnCollectionVialResources,standardDetectionAntibodyPurificationColumnCollectionVialResources,captureAntibodyPurificationColumnWashContainerResources,standardCaptureAntibodyPurificationColumnWashContainerResources,		detectionAntibodyPurificationColumnWashContainerResources,standardDetectionAntibodyPurificationColumnWashContainerResources,captureAntibodyPurificationWasteContainerResources,standardCaptureAntibodyPurificationWasteContainerResources,detectionAntibodyPurificationWasteContainerResources,standardDetectionAntibodyPurificationWasteContainerResources,
		captureAntibodyAbsorbanceContainer,detectionAntibodyAbsorbanceContainer,captureAntibodyAbsorbanceContainerResource,detectionAntibodyAbsorbanceContainerResource,

        (* Instrument *)
        instrument,instrumentResource,

        (* Field Preparation *)
		requiredSpikeResources,requiredSpikeVolumes,requiredSpikeSampleStorageCondtion,serialDilutionBooleans,dilutionAssayVolumes,startingDilutionFactors,dilutionFactorIncrements,numberOfDilutions,requiredDilutionCurves,serialDilutionAssayVolumes,serialDilutionFactors,numberOfSerialDilutions,requiredSerialDilutionCurves,standardResuspensions,standardResuspensionConcentrations,standardResuspensionDiluents,standardStorageConditions,standardSerialDilutionBooleans,standardDilutionAssayVolumes,standardStartingDilutionFactors,standardDilutionFactorIncrements,standardNumberOfDilutions,requiredStandardDilutionCurves,standardSerialDilutionAssayVolumes,standardSerialDilutionFactors,numberOfStandardSerialDilutions,requiredStandardSerialDilutionCurves,requiredStandardDiluents,standardDilutionMixVolumes,standardDilutionNumberOfMixes,standardDilutionMixRates,requiredStandardCaptureAntibodies,requiredStandardDetectionAntibodies,
		captureAntibodyResuspensions,captureAntibodyResuspensionConcentrations,captureAntibodyResuspensionDiluents,captureAntibodyStorageConditions,captureAntibodyConjugations,captureAntibodyVolumes,requiredDigoxigeninReagents,digoxigeninReagentVolumes,requiredCaptureAntibodyConjugationBuffers,captureAntibodyConjugationBufferVolumes,requiredCaptureAntibodyConjugationContainers,captureAntibodyConjugationTimes,captureAntibodyConjugationTemperatures,requiredCaptureAntibodyPurificationColumns,requiredCaptureAntibodyColumnWashBuffers,requiredCaptureAntibodyColumnWashContainers,requiredCaptureAntibodyColumnWasteContainers,requiredCaptureAntibodyConjugationCollectionVials,captureAntibodyConjugationStorageConditions,captureAntibodyDilutions,requiredCaptureAntibodyAbsorbanceBlanks,captureAntibodyTargetConcentrations,requiredCaptureAntibodyDiluents,requiredCaptureAntibodyDilutionContainers,
		detectionAntibodyResuspensions,detectionAntibodyResuspensionConcentrations,detectionAntibodyResuspensionDiluents,detectionAntibodyStorageConditions,detectionAntibodyConjugations,detectionAntibodyVolumes,requiredBiotinReagents,biotinReagentVolumes,requiredDetectionAntibodyConjugationBuffers,detectionAntibodyConjugationBufferVolumes,requiredDetectionAntibodyConjugationContainers,detectionAntibodyConjugationTimes,detectionAntibodyConjugationTemperatures,requiredDetectionAntibodyPurificationColumns,requiredDetectionAntibodyColumnWashBuffers,requiredDetectionAntibodyColumnWashContainers,requiredDetectionAntibodyColumnWasteContainers,requiredDetectionAntibodyConjugationCollectionVials,detectionAntibodyConjugationStorageConditions,detectionAntibodyDilutions,requiredDetectionAntibodyAbsorbanceBlanks,detectionAntibodyTargetConcentrations,requiredDetectionAntibodyDiluents,requiredDetectionAntibodyDilutionContainers,
		standardCaptureAntibodyResuspensions,standardCaptureAntibodyResuspensionConcentrations,standardCaptureAntibodyResuspensionDiluents,standardCaptureAntibodyStorageConditions,standardCaptureAntibodyConjugations,standardCaptureAntibodyVolumes,requiredStandardDigoxigeninReagents,standardDigoxigeninReagentVolumes,requiredStandardCaptureAntibodyConjugationBuffers,standardCaptureAntibodyConjugationBufferVolumes,requiredStandardCaptureAntibodyConjugationContainers,standardCaptureAntibodyConjugationTimes,standardCaptureAntibodyConjugationTemperatures,requiredStandardCaptureAntibodyPurificationColumns,requiredStandardCaptureAntibodyColumnWashBuffers,requiredStandardCaptureAntibodyColumnWashContainers,requiredStandardCaptureAntibodyColumnWasteContainers,requiredStandardCaptureAntibodyConjugationCollectionVials,standardCaptureAntibodyConjugationStorageConditions,standardCaptureAntibodyDilutions,requiredStandardCaptureAntibodyAbsorbanceBlanks,standardCaptureAntibodyTargetConcentrations,requiredStandardCaptureAntibodyDiluents,requiredStandardCaptureAntibodyDilutionContainers,
		standardDetectionAntibodyResuspensions,standardDetectionAntibodyResuspensionConcentrations,standardDetectionAntibodyResuspensionDiluents,standardDetectionAntibodyStorageConditions,standardDetectionAntibodyConjugations,standardDetectionAntibodyVolumes,requiredStandardBiotinReagents,standardBiotinReagentVolumes,requiredStandardDetectionAntibodyConjugationBuffers,standardDetectionAntibodyConjugationBufferVolumes,requiredStandardDetectionAntibodyConjugationContainers,standardDetectionAntibodyConjugationTimes,standardDetectionAntibodyConjugationTemperatures,requiredStandardDetectionAntibodyPurificationColumns,requiredStandardDetectionAntibodyColumnWashBuffers,requiredStandardDetectionAntibodyColumnWashContainers,requiredStandardDetectionAntibodyColumnWasteContainers,requiredStandardDetectionAntibodyConjugationCollectionVials,standardDetectionAntibodyConjugationStorageConditions,standardDetectionAntibodyDilutions,requiredStandardDetectionAntibodyAbsorbanceBlanks,standardDetectionAntibodyTargetConcentrations,requiredStandardDetectionAntibodyDiluents,requiredStandardDetectionAntibodyDilutionContainers,
		standardLoadingVolumes,captureAntibodyLoadingVolumes,detectionAntibodyLoadingVolumes,standardCaptureAntibodyLoadingVolumes,standardDetectionAntibodyLoadingVolumes,allCaptureAntibodyDilutionInitialConcentrations,allDetectionAntibodyDilutionInitialConcentrations,uniqueCaptureAntibodyDilutionInitialConcentrationReplaceRules,uniqueDetectionAntibodyDilutionInitialConcentrationReplaceRules,captureAntibodyDilutionInitialConcentrations,standardCaptureAntibodyDilutionInitialConcentrations,detectionAntibodyDilutionInitialConcentrations,standardDetectionAntibodyDilutionInitialConcentrations,standardComposition,spikeConcentration,

        (* Time Estimation *)
        customizableCartridgeQ,standardQ,pickingResourcesTime,returningResourcesTime,sampleManipulationTime,samplePreparationTime,standardPreparationTime,antibodyResuspensionTime,antibodyConjugationIncubationTime,antibodyConjugationTime,standardResuspensionTime,antibodyDilutionTime,samplePreparationTotalTime,sampleManipulationTotalTime,

        (* Output *)
        protocolPacket,sharedFieldPacket,finalizedPacket,allResourceBlobs,fulfillable,frqTests,testsRule,resultRule
    },

    (* Expand the resolved options if they weren't expanded already. This also covers the other index matching options. We always want to look up from expendedResolvedOptions *)
    {expandedInputs,expandedResolvedOptions}=ExpandIndexMatchedInputs[ExperimentCapillaryELISA,{mySamples},myResolvedOptions];

    (* Get the resolved collapsed index matching options that don't include hidden options *)
    resolvedOptionsNoHidden=CollapseIndexMatchedOptions[
        ExperimentCapillaryELISA,
        RemoveHiddenOptions[ExperimentCapillaryELISA,myResolvedOptions],
        Ignore->myUnresolvedOptions,
        Messages->False
    ];

    (* Determine the requested return value from the function *)
    outputSpecification=OptionDefault[OptionValue[Output]];
    output=ToList[outputSpecification];

    (* Determine if we should keep a running list of tests to return to the user. *)
    gatherTests = MemberQ[output,Tests];
    messages = Not[gatherTests];

    (* Get the inherited cache *)
    inheritedCache = Lookup[ToList[ops],Cache];

	(* make a fast association to quickly pull stuff out of the inherited cache *)
	inheritedFastAssoc = makeFastAssocFromCache[inheritedCache];

    (* PREPARATION *)

    (* Get all containers which can fit on the liquid handler and download their volume capacities *)
    (* In case we need to prepare the resource add different containers to the beginning of the list (Engine uses the first requested container if it has to transfer or make a stock solution). We join the list of preferred container to make sure they appear at the beginning of the list. *)
    liquidHandlerCompatibleContainers=Experiment`Private`hamiltonAliquotContainers["Memoization"];

	(* Get the information about potential spin columns *)
	potentialSpinColumns=Search[Model[Container,Vessel,Filter],MembraneMaterial==ZebaDesaltingResin];

	(* Get the NumberOfReplicates to expand our index matching options *)
	numberOfReplicates=If[NullQ[Lookup[expandedResolvedOptions,NumberOfReplicates]],
		1,
		Lookup[expandedResolvedOptions,NumberOfReplicates]
	];

	(* -- Expand inputs and index-matched options to take into account the NumberOfReplicates option -- *)
	(* - Expand the index-matched inputs for the NumberOfReplicates - *)
	{samplesWithReplicates,optionsWithReplicates}=expandNumberOfReplicates[ExperimentCapillaryELISA,mySamples,expandedResolvedOptions];


	(* -- Generate cartridge resources -- *)
    (* Get the cartridge specified by the user *)
    {cartridge,cartridgeType,species}=Lookup[optionsWithReplicates,{Cartridge,CartridgeType,Species}];

	(* One special step here is that the Customizable cartridge may be expanded in the wrong way. For example, the Analytes may be {analyte1,analyte2} before expansion. The Analytes is expanded to {{analyte1,analyte2},{analyte1,analyte2}}. Then after NumberOfReplicates is taken into consideration, it may even be expanded into {{analyte1,analyte2},{analyte1,analyte2},{analyte1,analyte2},{analyte1,analyte2}}. This is not correct. *)
	analytes=Which[
		(* Keep the analytes as they are for pre-loaded cartridge. We will get the first element in the next step *)
		!MatchQ[cartridgeType,Customizable],Lookup[optionsWithReplicates,Analytes],

		(* Samples not equal to analytes *)
		Length[First[Lookup[optionsWithReplicates,Analytes]]]!=Length[mySamples],
		Lookup[optionsWithReplicates,Analytes],

		(* each one element is not a list *)
		!MatchQ[Lookup[optionsWithReplicates,Analytes],{_List...}],
		Lookup[optionsWithReplicates,Analytes],

		(* different element in the option *)
		Length[DeleteDuplicates[Lookup[optionsWithReplicates,Analytes]]]>1,
		Lookup[optionsWithReplicates,Analytes],

		True,Flatten[ConstantArray[#,numberOfReplicates]&/@First[Lookup[optionsWithReplicates,Analytes]]]
	];

	(* Because Analytes is expanded due to index matching, get its first member for UploadCapillaryELISACartridge *)
	preLoadedAnalytes=If[MatchQ[cartridgeType,Customizable],
		{},
		Flatten[DeleteDuplicates[analytes]]
	];

	(* Call Upload function to get the new cartridge model if necessary. *)
	requiredCartridge=If[!MatchQ[cartridge,Null],
		cartridge,

		(* Because we check the options in our resolver, our options should get a new model from the Upload function. It can also return $Failed and we should already have thrown an error message for the issue in our resolver *)
		Quiet[UploadCapillaryELISACartridge[preLoadedAnalytes,CartridgeType->cartridgeType,Species->species],{Warning::EmptyCartridgeChannel}]
	];

    (* Make the capillary ELISA cartridge resource *)
    cartridgeResource=If[MatchQ[requiredCartridge,$Failed],
		Null,
		Link[Resource[Sample->requiredCartridge,Name->ToString[Unique[]]]]
    ];
	
	(* Get the packet of cartridge if it is provided. For the newly created cartridge, we don't have it in the cache and we will not download from it *)
	customizableCartridgeQ=MatchQ[cartridgeType,Customizable];
	requiredCartridgePacket=If[!MatchQ[cartridge,Null]&&!customizableCartridgeQ,
		Experiment`Private`fetchPacketFromFastAssoc[cartridge,inheritedFastAssoc],
		<||>
	];

	(* Turn AnalyteMolecules to AnalyteNames to download manufacturing specifications for protocol update *)
	preLoadedAnalyteNames=Which[
		!MatchQ[requiredCartridgePacket,<||>],
		Lookup[requiredCartridgePacket,AnalyteNames,{}],
		MatchQ[preLoadedAnalytes,{}],
		{},
		MatchQ[preLoadedAnalytes,ListableP[CapillaryELISAAnalyteP]],
		ToList[preLoadedAnalytes],
		True,
		(* Call our helper function to find a suitable combination of analyte molecules *)
		First[resolvePreLoadedCartridgeAnalytes[cartridgeType,species,preLoadedAnalytes,Cache->inheritedCache]]
	];


	(* Get the analyte manufacturing specification *)
	preaLoadedAnalyteManufacturingSpecifications=Map[
		FirstCase[
			inheritedCache,
			KeyValuePattern[{Type->Object[ManufacturingSpecification,CapillaryELISACartridge],AnalyteName->#}],
			Null
		]&,
		preLoadedAnalyteNames
	];

	preLoadedAnalyteMolecules=Which[
		!MatchQ[requiredCartridgePacket,<||>],
		Lookup[requiredCartridgePacket,AnalyteMolecules,{}],
		MatchQ[preLoadedAnalytes,{}],
		{},
		True,
		Lookup[preaLoadedAnalyteManufacturingSpecifications,AnalyteMolecule,Null]
	];

	(* Turn the CapillaryELISAAnalyteP into Model[Molecule] for customizable cartridge *)
	customizableAnalyteMolecules=Map[
		If[MatchQ[First[ToList[#]],ObjectP[Model[Molecule]]],
			First[ToList[#]],
			Download[
				Lookup[
					FirstCase[
						inheritedCache,
						KeyValuePattern[{Type->Object[ManufacturingSpecification,CapillaryELISACartridge],AnalyteName->First[ToList[#]]}],
						<||>
					],
					AnalyteMolecule,
					Null
				],
				Object,
				Cache->inheritedCache
			]
		]&,
		analytes
	];

	(* Prepare information of the protocol fields *)
	multiplex=MatchQ[cartridgeType,MultiPlex32X8|MultiAnalyte32X4|MultiAnalyte16X4];
	analyteMolecules=Which[
		customizableCartridgeQ,
		Map[
			Link[#]&,
			customizableAnalyteMolecules
		],
		MatchQ[cartridgeType,SinglePlex72X1],
		ConstantArray[Link[First[preLoadedAnalyteMolecules]],Length[mySamples]],
		True,
		{}
	];

	analyteNames=If[MatchQ[cartridgeType,SinglePlex72X1],
		ConstantArray[First[preLoadedAnalyteNames],Length[mySamples]],
		{}
	];

	multiplexAnalyteMolecules=If[multiplex,
		Map[Link[#]&,preLoadedAnalyteMolecules],
		{}
	];
	multiplexAnalyteNames=preLoadedAnalyteNames;

	manufacturingSpecifications=Link[#]&/@(Download[preaLoadedAnalyteManufacturingSpecifications,Object,Cache->inheritedCache]);

	upperQuantitationLimits=Map[
    Lookup[
      Experiment`Private`fetchPacketFromFastAssoc[#,inheritedFastAssoc],
      {AnalyteName,UpperQuantitationLimit}]&,
		manufacturingSpecifications
	];

	lowerQuantitationLimits=Map[
    Lookup[
      Experiment`Private`fetchPacketFromFastAssoc[#,inheritedFastAssoc],
          {AnalyteName, LowerQuantitationLimit}]&,
		manufacturingSpecifications
	];

    (* -- Generate resources for the SamplesIn -- *)
    (* Get the information about sample volume, dilution curve and serial dilution curve to calculate the volume of each sample needed *)
    {sampleVolume,dilutionCurve,serialDilutionCurve}=Lookup[optionsWithReplicates,{SampleVolume,DilutionCurve,SerialDilutionCurve}];

    (* Determine the volume of samples needed. The input of capillaryELISAResourcePackets is already simulated samples so we don't need to worry about simulation here *)
    requiredSampleVolumes=MapThread[
        If[MatchQ[#1,GreaterEqualP[0Microliter]],

            (* Use user defined sample volume. We only require this when Spike is specified so there are cases that it is Null. *)
            #1,

            (* After resolver, neither of DilutionCurve and SerialDilutionCurve should be Automatic. We can safely set default volume to 0 Microliter as it is not used. Call the helper function here *)
			resolveRequiredSampleVolumeForDilution[#2,#3,0Microliter]
        ]&,
        {sampleVolume,dilutionCurve,serialDilutionCurve}
    ];

    (* The simulated samples are already in hamilton compatible containers after resolver because we specify the target aliquoting containers there. There is no reason to do aliquoting again here *)
    samplesInResources=MapThread[
        Link[Resource[Sample->#1,Name->ToString[Unique[]],Amount->#2],Protocols]&,
        {samplesWithReplicates,requiredSampleVolumes}
    ];

    (* Extract the container objects from the downloaded cache. Create the resources of the containers in. *)
    containersInObjects=DeleteDuplicates[
      Map[
        Module[{samplePacket,container},
          samplePacket=Experiment`Private`fetchPacketFromFastAssoc[#,inheritedFastAssoc];
          container=Lookup[samplePacket,Container,Null];
          If[MatchQ[container,Null],
            Null,
            Experiment`Private`fastAssocLookup[inheritedFastAssoc,container,Object]
          ]
        ]&,
        samplesWithReplicates
      ]
    ];

    containersInResources=Map[
        Link[Resource[Sample->#],Protocols]&,
        containersInObjects
    ];

    (* -- Generate resources for the Standard -- *)
    standard=Lookup[optionsWithReplicates,Standard];

	standardPackets=If[!MatchQ[standard,Null|{}],
		Experiment`Private`fetchPacketFromFastAssoc[#,inheritedFastAssoc]&/@standard,
		{}
	];

	(* Find all identity models of the standard sample *)
	standardIdentityModels=Map[
		Function[
			{singleStandardPacket},
			Select[Lookup[singleStandardPacket,Composition,{}],MatchQ[#,{_,ObjectP[Model[Molecule,Protein,Antibody]]}]&]
		],
		standardPackets
	];
	(* Find all molecular weights of all identity models *)
	standardMolecularWeights=Map[

    DeleteCases[
      Module[{links},
        links=#[[All,2]];
        Map[
          Function[{standard},
            Experiment`Private`fastAssocLookup[inheritedFastAssoc,standard,MolecularWeight]
          ],
          links
        ]
      ],
      Null
    ]&,

		standardIdentityModels
	];

	(* Use the average molecular weight or 150000 Dalton for caculation *)
	standardAverageMolecularWeight=Map[
		If[MatchQ[#,{}],
			150000Dalton,
			Mean[#]
		]&,
		standardMolecularWeights
	];

    (* Get the information about standard dilution curve and standard serial dilution curve to calculate the volume of each standard sample needed *)
    {standardDilutionCurve,standardSerialDilutionCurve}=Lookup[optionsWithReplicates,{StandardDilutionCurve,StandardSerialDilutionCurve}];

    (* Determine the volume of standard samples needed. This is the volume requirement after resuspension. We can convert it back to solid mass if resuspension is required *)
    requiredStandardVolumes=If[!MatchQ[standard,Null|{}],
        MapThread[

            (* After resolver, neither of StandardDilutionCurve and StandardSerialDilutionCurve should be Automatic. We can safely set default volume to 0 Microliter as it is not used. Call the helper function here *)
			resolveRequiredSampleVolumeForDilution[#1,#2,0Microliter]&,
            {standardDilutionCurve,standardSerialDilutionCurve}
        ],
        {}
    ];

    (* Convert the requirement of volume into mass if needed *)
    (* Get the resuspension information *)
    {standardResuspension,standardResuspensionConcentration}=Lookup[optionsWithReplicates,{StandardResuspension,StandardResuspensionConcentration}];

    (* Convert the volume to mass if StandardResuspension is True *)
    requiredStandardAmounts=If[!MatchQ[standard,Null|{}],
        MapThread[
            Which[
                (* If resuspension is required and we have a resuspension concentration, use the concentration and volume to get the required mass *)
                MatchQ[#2,True]&&MatchQ[#3,GreaterEqualP[0Microgram/Milliliter]],#1*#3,

				MatchQ[#2,True]&&MatchQ[#3,GreaterEqualP[0Molar]],#1*#3*#4,

                (* If resuspension is required but we don't have a resuspension concentration, give 0 Microgram. An error should have been thrown in resolver *)
                MatchQ[#2,True],0Microgram,

                (* Otherwise keep the required volume *)
                True,#1
            ]&,
            {requiredStandardVolumes,standardResuspension,standardResuspensionConcentration,standardAverageMolecularWeight}
        ],
        {}
    ];

    (* We also need to check what containers the standard samples are in if they are in liquid state. The containers must be liquid handler compatible so that we can perform the follow-up dilutions *)

    (* Get information about the container models of the standard samples *)
    standardContainers=If[!MatchQ[standard,Null|{}],
      Map[
        If[MatchQ[Lookup[#,Container,Null],ObjectP[Model[Container]]],
          Download[Lookup[#,Container,Null],Object,Cache->inheritedCache,Date->Now],
          If[MatchQ[Lookup[#,Container,Null],Null],
            Null,
            Experiment`Private`fastAssocLookup[inheritedFastAssoc,Lookup[#,Container,Null],{Model,Object}]
          ]
        ]&,
        standardPackets
      ],
      {}
    ];

    (* If a standard sample is not already in a liquid handler compatible container, we can move it into a liquid handler compatible container. This is also true for any liquid Model[Sample] case. If we have a solid state sample, we do not move it. We can move a certain amount out to a compatible container after resuspension in Procedure. *)
    (* Note that our Standard should never have a Null member. *)

    standardTargetContainers=If[!MatchQ[standard,Null|{}],
        MapThread[
            Function[{resuspension,container,volume},
                Which[
                    MatchQ[resuspension,True],Null,
                    MemberQ[liquidHandlerCompatibleContainers,container],Null,
                    True,PreferredContainer[volume]
                ]
            ],
            {standardResuspension,standardContainers,requiredStandardVolumes}
        ],
        {}
    ];

    (* Put all the information about Standard together to make Standard resources. Set to Null if we don't have Standard. *)
    standardResources=If[!MatchQ[standard,Null|{}],
        MapThread[
            Which[
                MatchQ[#3,Null],Link[Resource[Sample->#1,Name->ToString[Unique[]],Amount->#2]],
                !MatchQ[#3,Null],Link[Resource[Sample->#1,Name->ToString[Unique[]],Amount->#2,Container->#3]]
            ]&,
            {standard,requiredStandardAmounts,standardTargetContainers}
        ],
        {}
    ];


    (* -- Generate resources for the Spike -- *)
    spikeSample=Lookup[optionsWithReplicates,SpikeSample];

    (* Determine the amount of Spike from SpikeVolume option. It should not be Null when Spike is not Null *)
    spikeVolume=Lookup[optionsWithReplicates,SpikeVolume];

    (* We also need to check what containers the Spike samples are in. The containers must be liquid handler compatible so that we can perform the mixing steps *)
    spikePackets=Experiment`Private`fetchPacketFromFastAssoc[#,inheritedFastAssoc]&/@spikeSample;

    (* Get information about the containers of the spike samples *)
    standardContainers=If[!MatchQ[standard,Null|{}],
      Map[
        If[MatchQ[Lookup[#,Container,Null],ObjectP[Model[Container]]],
          Download[Lookup[#,Container,Null],Object,Cache->inheritedCache,Date->Now],
          If[MatchQ[Lookup[#,Container,Null],Null],
            Null,
            Experiment`Private`fastAssocLookup[inheritedFastAssoc,Lookup[#,Container,Null],{Model,Object}]
          ]
        ]&,
        standardPackets
      ],
      {}
    ];

    spikeOriginalContainers=Map[
      Which[
        MatchQ[#,Null],
        Null,
        MatchQ[Lookup[#,Container,Null],ObjectP[Model[Container]]],
        Download[Lookup[#,Container,Null],Object,Cache->inheritedCache,Date->Now],
        True,
        If[MatchQ[Lookup[#,Container,Null],Null],
          Null,
          Experiment`Private`fastAssocLookup[inheritedFastAssoc,Lookup[#,Container,Null],{Model,Object}]
        ]
      ]&,
      spikePackets
    ];

    (* If a spike sample is not already in a liquid handler compatible container, we can move it into a liquid handler compatible container. This is also true for any Model[Sample] case. *)
    spikeTargetContainers=MapThread[
        Function[{spike,container,volume},
            Which[
                MatchQ[spike,Null],Null,
                MemberQ[liquidHandlerCompatibleContainers,container],Null,
                True,PreferredContainer[volume]
            ]
        ],
        {spikeSample,spikeOriginalContainers,spikeVolume}
    ];

    (* Put all the information about Spike together to make Spike resources. Set to Null for the samples with Null Spike. *)
    spikeResources=MapThread[
        Which[
            MatchQ[#1,Null],Null,
            MatchQ[#3,Null],Link[Resource[Sample->#1,Name->ToString[Unique[]],Amount->#2]],
            !MatchQ[#3,Null],Link[Resource[Sample->#1,Name->ToString[Unique[]],Amount->#2,Container->#3]]
        ]&,
        {spikeSample,spikeVolume,spikeTargetContainers}
    ];


    (* -- Generate resources for the Antibodies *)
    (* The resources for antibodies is a little complicated. Each antibody can go through at most 3 steps - resuspension, conjugation and dilution. We can prepare the antibody resources together when the preparation options are exactly the same. Also, standard antibodies can be prepared together with input sample antibodies. *)
    (* Note that in the best case - to save money for the user, we can potentially do the preparation together if the upstream options are the same. For example, if resuspension options are the same, we can prepare the samples together and separate them for different conjugation steps, if needed. Same for dilution steps. However, it can be really rare that happens but can make resource packets quite complicated to calculate the amounts needed. In our option descriptions, we only mentioned that the resources are pooled together for preparation when all options are the same. It is reasonable to do it this way here. The users are always given the options to save the antibody samples they prepare and the samples can be used to use in the future. *)

    (* Get the number of diluted samples so we can decide how many volumes to prepare for antibody dilution *)
    numberOfInputSamples=MapThread[

        (* call helper function to figure out the number of samples *)
        resolveDilutedSampleNumber[#1,#2,0]&,
        {dilutionCurve,serialDilutionCurve}
    ];

    (* Get the number of diluted standard sample *)
    numberOfstandardSamples=If[!MatchQ[standard,Null|{}],

        (* Repeat for every standard sample *)
        MapThread[

            (* call helper function to figure out the number of samples. Our options can no longer be automatic after resolver. We can safely default it to 0 *)
            resolveDilutedSampleNumber[#1,#2,0]&,
            {standardDilutionCurve,standardSerialDilutionCurve}
        ],

        (* give empty list if no standard sample *)
        {}
    ];

    joinedNumberOfSamples=Join[numberOfInputSamples,numberOfstandardSamples];

    (* Capture Antibody *)
    (* We can start with getting all the option values. *)

	{customCaptureAntibody,captureAntibodyResuspension,captureAntibodyResuspensionConcentration,captureAntibodyResuspensionDiluent,captureAntibodyStorageCondition,captureAntibodyConjugation,captureAntibodyVolume,digoxigeninReagent,digoxigeninReagentVolume,captureAntibodyConjugationBuffer,captureAntibodyConjugationBufferVolume,captureAntibodyConjugationContainer,captureAntibodyConjugationTime,captureAntibodyConjugationTemperature,captureAntibodyPurificationColumn,captureAntibodyColumnWashBuffer,captureAntibodyConjugationStorageCondition,captureAntibodyDilution,captureAntibodyTargetConcentration,captureAntibodyDiluent,captureAntibodyLoadingVolume}=Lookup[
		optionsWithReplicates,
		{CustomCaptureAntibody,CaptureAntibodyResuspension,CaptureAntibodyResuspensionConcentration,CaptureAntibodyResuspensionDiluent,CaptureAntibodyStorageCondition,CaptureAntibodyConjugation,CaptureAntibodyVolume,DigoxigeninReagent,DigoxigeninReagentVolume,CaptureAntibodyConjugationBuffer,CaptureAntibodyConjugationBufferVolume,CaptureAntibodyConjugationContainer,CaptureAntibodyConjugationTime,CaptureAntibodyConjugationTemperature,CaptureAntibodyPurificationColumn,CaptureAntibodyColumnWashBuffer,CaptureAntibodyConjugationStorageCondition,CaptureAntibodyDilution,CaptureAntibodyTargetConcentration,CaptureAntibodyDiluent,CaptureAntibodyLoadingVolume}
	];

    {standardCaptureAntibody,standardCaptureAntibodyResuspension,standardCaptureAntibodyResuspensionConcentration,standardCaptureAntibodyResuspensionDiluent,standardCaptureAntibodyStorageCondition,standardCaptureAntibodyConjugation,standardCaptureAntibodyVolume,standardDigoxigeninReagent,standardDigoxigeninReagentVolume,standardCaptureAntibodyConjugationBuffer,standardCaptureAntibodyConjugationBufferVolume,standardCaptureAntibodyConjugationContainer,standardCaptureAntibodyConjugationTime,standardCaptureAntibodyConjugationTemperature,standardCaptureAntibodyPurificationColumn,standardCaptureAntibodyColumnWashBuffer,standardCaptureAntibodyConjugationStorageCondition,standardCaptureAntibodyDilution,standardCaptureAntibodyTargetConcentration,standardCaptureAntibodyDiluent,standardCaptureAntibodyLoadingVolume}=Lookup[
        optionsWithReplicates,
        {StandardCaptureAntibody,StandardCaptureAntibodyResuspension,StandardCaptureAntibodyResuspensionConcentration,StandardCaptureAntibodyResuspensionDiluent,StandardCaptureAntibodyStorageCondition,StandardCaptureAntibodyConjugation,StandardCaptureAntibodyVolume,StandardDigoxigeninReagent,StandardDigoxigeninReagentVolume,StandardCaptureAntibodyConjugationBuffer,StandardCaptureAntibodyConjugationBufferVolume,StandardCaptureAntibodyConjugationContainer,StandardCaptureAntibodyConjugationTime,StandardCaptureAntibodyConjugationTemperature,StandardCaptureAntibodyPurificationColumn,StandardCaptureAntibodyColumnWashBuffer,StandardCaptureAntibodyConjugationStorageCondition,StandardCaptureAntibodyDilution,StandardCaptureAntibodyTargetConcentration,StandardCaptureAntibodyDiluent,StandardCaptureAntibodyLoadingVolume}
    ];

    (* Join the standard capture antibody options together with input sample capture antibody options when Standard is not Null *)
    {joinedCaptureAntibody,joinedCaptureAntibodyResuspension,joinedCaptureAntibodyResuspensionConcentration,joinedCaptureAntibodyResuspensionDiluent,joinedCaptureAntibodyStorageCondition,joinedCaptureAntibodyConjugation,joinedCaptureAntibodyVolume,joinedDigoxigeninReagent,joinedDigoxigeninReagentVolume,joinedCaptureAntibodyConjugationBuffer,joinedCaptureAntibodyConjugationBufferVolume,joinedCaptureAntibodyConjugationContainer,joinedCaptureAntibodyConjugationTime,joinedCaptureAntibodyConjugationTemperature,joinedCaptureAntibodyPurificationColumn,joinedCaptureAntibodyColumnWashBuffer,joinedCaptureAntibodyConjugationStorageCondition,joinedCaptureAntibodyDilution,joinedCaptureAntibodyTargetConcentration,joinedCaptureAntibodyDiluent,joinedCaptureAntibodyLoadingVolume}=MapThread[
        If[MatchQ[standard,Null],
            #1,
            Join[#1,#2]
        ]&,
        {{customCaptureAntibody,captureAntibodyResuspension,captureAntibodyResuspensionConcentration,captureAntibodyResuspensionDiluent,captureAntibodyStorageCondition,captureAntibodyConjugation,captureAntibodyVolume,digoxigeninReagent,digoxigeninReagentVolume,captureAntibodyConjugationBuffer,captureAntibodyConjugationBufferVolume,captureAntibodyConjugationContainer,captureAntibodyConjugationTime,captureAntibodyConjugationTemperature,captureAntibodyPurificationColumn,captureAntibodyColumnWashBuffer,captureAntibodyConjugationStorageCondition,captureAntibodyDilution,captureAntibodyTargetConcentration,captureAntibodyDiluent,captureAntibodyLoadingVolume},
            {standardCaptureAntibody,standardCaptureAntibodyResuspension,standardCaptureAntibodyResuspensionConcentration,standardCaptureAntibodyResuspensionDiluent,standardCaptureAntibodyStorageCondition,standardCaptureAntibodyConjugation,standardCaptureAntibodyVolume,standardDigoxigeninReagent,standardDigoxigeninReagentVolume,standardCaptureAntibodyConjugationBuffer,standardCaptureAntibodyConjugationBufferVolume,standardCaptureAntibodyConjugationContainer,standardCaptureAntibodyConjugationTime,standardCaptureAntibodyConjugationTemperature,standardCaptureAntibodyPurificationColumn,standardCaptureAntibodyColumnWashBuffer,standardCaptureAntibodyConjugationStorageCondition,standardCaptureAntibodyDilution,standardCaptureAntibodyTargetConcentration,standardCaptureAntibodyDiluent,standardCaptureAntibodyLoadingVolume}}
    ];

    (* Download capture antibody packets to get its concentration *)
    joinedCaptureAntibodyPackets=Experiment`Private`fetchPacketFromFastAssoc[#,inheritedFastAssoc]&/@joinedCaptureAntibody;

    (* Look up for the antibody identity model in the composition of the sample for concentration *)
	(* Find all identity models of the capture antibody *)
	joinedCaptureAntibodyIdentityModels=Map[
		Function[
			{singleAntibodyPacket},
			If[NullQ[singleAntibodyPacket],
				{},
				Select[Lookup[singleAntibodyPacket,Composition,{}],MatchQ[#,{_,ObjectP[Model[Molecule,Protein,Antibody]]}]&]
			]
		],
		joinedCaptureAntibodyPackets
	];

	(* Find all molecular weights of all identity models *)
	jointCaptureAntibodyMolecularWeights=Map[
    DeleteCases[
      Module[{links},
        links=#[[All,2]];
        Map[
          Function[{antibody},
            Experiment`Private`fastAssocLookup[inheritedFastAssoc,antibody,MolecularWeight]
          ],
          links
        ]
      ],
      Null
    ]&,
    (*)DeleteCases[Download[#[[All,2]],MolecularWeight,Cache->inheritedCache,Date->Now],Null]&,*)
		joinedCaptureAntibodyIdentityModels
	];

	(* Use the first molecular weight - consistent with the concentration value origin or 150000 Dalton for caculation *)
	jointCaptureAntibodyAverageMolecularWeight=Map[
		FirstOrDefault[#,150000Dalton]&,
		jointCaptureAntibodyMolecularWeights
	];

    joinedCaptureAntibodyConcentration=MapThread[
        Which[
			(* Set to Null if we don't have a packet or we don't have any protein identity model*)
			MatchQ[#2,{}],Null,
			(* Set to Null if we get a solid *)
			MatchQ[Lookup[#1,State,Null],Solid],Null,
			(* Get the concentration if the antibody identity model composition is available *)
			MatchQ[#2[[1,1]],GreaterEqualP[0Milligram/Milliliter]|GreaterEqualP[0Molar]],#2[[1,1]],
			True,Null
        ]&,
		{joinedCaptureAntibodyPackets,joinedCaptureAntibodyIdentityModels}
    ];
    (* We also need to check what containers the capture antibody samples are in if they are in liquid state. The containers must be liquid handler compatible so that we can perform the follow-up steps including conjugation, dilution and cartridge loading *)
    (* Get information about the containers of the capture antibody samples *)
    joinedCaptureAntibodyContainers=Map[
      Which[
        MatchQ[#,Null],Null,

        MatchQ[Lookup[#,Container,Null],ObjectP[Model[Container]]],
        Download[Lookup[#,Container,Null],Object,Cache->inheritedCache,Date->Now],

        True,
        If[MatchQ[Lookup[#,Container,Null],Null],
          Null,
          Experiment`Private`fastAssocLookup[inheritedFastAssoc,Lookup[#,Container,Null],{Model,Object}]
        ]
      ]&,
      joinedCaptureAntibodyPackets
    ];

    (* Get the volume needed for each step. If a step if not performed, use Null for the volume. The first non-Null volume is the volume required from the resource. *)
    (* Note that resuspension step is not included as that is the step to turn Solid into Liquid *)

    (* Get the total loading volume with the number of diluted samples considered *)
    requiredCaptureAntibodyLoadingVolumes=MapThread[
        If[MatchQ[#1,Null],
			Null,
			(#1*#2)
		]&,
        {joinedCaptureAntibodyLoadingVolume,joinedNumberOfSamples}
    ];
    requiredCaptureAntibodyDilutionVolumes=MapThread[
        Which[
            MatchQ[#1,Null|False],Null,

            (* If we have done conjugation and resuspension, we can use 1/2 of the resuspension concentration for estimation of the required volume. This 1/2 takes the loss in conjugation and purification process into concern. *)
			(* Add 5 Microliter to loading volume to make sure enough volume can be loaded *)
            MatchQ[#3,True]&&MatchQ[#4,True],#2*(#7+10Microliter)*2/#5,

            (* If we have done resuspension but not conjugation, we can directly use the resuspension concentration *)
            MatchQ[#4,True]&&!MatchQ[#3,True],#2*(#7+10Microliter)/#5,

			(* If we have done conjugation only, we can use the concentration from composition for calculation of volume - Take in 1/2 loss*)
			!MatchQ[#4,True]&&MatchQ[#3,True]&&!MatchQ[#6,Null],#2*(#7+10Microliter)*2/#6,

            (* If we have not done resuspension or conjugation, we can use the concentration from composition for calculation of volume *)
            !MatchQ[#3,True]&&!MatchQ[#4,True]&&!MatchQ[#6,Null],#2*(#7+10Microliter)/#6,

            (* For all other cases, we should stay safe and use 1/50 total required volume as the resource required volume for antibody samples. It is an estimation. Usually the resource of the sample is much higher than the final concentration. *)
            True,(#7+10Microliter)/50
        ]&,
        {joinedCaptureAntibodyDilution,joinedCaptureAntibodyTargetConcentration,joinedCaptureAntibodyConjugation,joinedCaptureAntibodyResuspension,joinedCaptureAntibodyResuspensionConcentration,joinedCaptureAntibodyConcentration,requiredCaptureAntibodyLoadingVolumes}
    ];

    requiredCaptureAntibodyConjugationVolumes=joinedCaptureAntibodyVolume;

	(* The loaded capture antibody sample is from the prepared sample after dilution and/or conjugation. We can decide the total prepared volume. *)
	(* Note that because our dilution preparation volume is directly from the loading volumes, we do not care about it *)
	totalCaptureAntibodyPreparationVolumes=MapThread[
		Which[
			MatchQ[#1,True],Null,

			(* If we have done conjugation only, use the total prepared volume *)
			MatchQ[#2,True],#3+#4+#5,

			(* If we have done only resuspension or none of the processing steps, we can directly set preparation volumes to Null *)
			True,Null
		]&,
		{joinedCaptureAntibodyDilution,joinedCaptureAntibodyConjugation,joinedCaptureAntibodyVolume,joinedDigoxigeninReagentVolume,joinedCaptureAntibodyConjugationBufferVolume}
	];

    (* Now we need to check whether we can get some of the resources prepared together *)

    (* Transpose the options to put the options for each sample together *)
    (* We do not include loading volume here as it doesn't have to be the same for the antibody sample to be prepared together *)
	captureAntibodyOptions=Transpose@{customCaptureAntibody,captureAntibodyResuspension,captureAntibodyResuspensionConcentration,captureAntibodyResuspensionDiluent,captureAntibodyStorageCondition,captureAntibodyConjugation,captureAntibodyVolume,digoxigeninReagent,digoxigeninReagentVolume,captureAntibodyConjugationBuffer,captureAntibodyConjugationBufferVolume,captureAntibodyConjugationContainer,captureAntibodyConjugationTime,captureAntibodyConjugationTemperature,captureAntibodyPurificationColumn,captureAntibodyColumnWashBuffer,captureAntibodyConjugationStorageCondition,captureAntibodyDilution,captureAntibodyTargetConcentration,captureAntibodyDiluent};

	standardCaptureAntibodyOptions=If[!MatchQ[standard,Null],
        Transpose@{standardCaptureAntibody,standardCaptureAntibodyResuspension,standardCaptureAntibodyResuspensionConcentration,standardCaptureAntibodyResuspensionDiluent,standardCaptureAntibodyStorageCondition,standardCaptureAntibodyConjugation,standardCaptureAntibodyVolume,standardDigoxigeninReagent,standardDigoxigeninReagentVolume,standardCaptureAntibodyConjugationBuffer,standardCaptureAntibodyConjugationBufferVolume,standardCaptureAntibodyConjugationContainer,standardCaptureAntibodyConjugationTime,standardCaptureAntibodyConjugationTemperature,standardCaptureAntibodyPurificationColumn,standardCaptureAntibodyColumnWashBuffer,standardCaptureAntibodyConjugationStorageCondition,standardCaptureAntibodyDilution,standardCaptureAntibodyTargetConcentration,standardCaptureAntibodyDiluent},
        {}
    ];

    joinedCaptureAntibodyOptions=Transpose@{joinedCaptureAntibody,joinedCaptureAntibodyResuspension,joinedCaptureAntibodyResuspensionConcentration,joinedCaptureAntibodyResuspensionDiluent,joinedCaptureAntibodyStorageCondition,joinedCaptureAntibodyConjugation,joinedCaptureAntibodyVolume,joinedDigoxigeninReagent,joinedDigoxigeninReagentVolume,joinedCaptureAntibodyConjugationBuffer,joinedCaptureAntibodyConjugationBufferVolume,joinedCaptureAntibodyConjugationContainer,joinedCaptureAntibodyConjugationTime,joinedCaptureAntibodyConjugationTemperature,joinedCaptureAntibodyPurificationColumn,joinedCaptureAntibodyColumnWashBuffer,joinedCaptureAntibodyConjugationStorageCondition,joinedCaptureAntibodyDilution,joinedCaptureAntibodyTargetConcentration,joinedCaptureAntibodyDiluent};

	(* Turn joinedCaptureAntibodyOptions into a list of rules so we can easily look up *)
	joinedCaptureAntibodyOptionsRuleList=Map[
		Function[
			{captureAntibodyOptions},
			MapThread[
				(#1->#2)&,
				{{CaptureAntibody,CaptureAntibodyResuspension,CaptureAntibodyResuspensionConcentration,CaptureAntibodyResuspensionDiluent,CaptureAntibodyStorageCondition,CaptureAntibodyConjugation,CaptureAntibodyVolume,DigoxigeninReagent,DigoxigeninReagentVolume,CaptureAntibodyConjugationBuffer,CaptureAntibodyConjugationBufferVolume,CaptureAntibodyConjugationContainer,CaptureAntibodyConjugationTime,CaptureAntibodyConjugationTemperature,CaptureAntibodyPurificationColumn,CaptureAntibodyColumnWashBuffer,CaptureAntibodyConjugationStorageCondition,CaptureAntibodyDilution,CaptureAntibodyTargetConcentration,CaptureAntibodyDiluent},captureAntibodyOptions}
			]
		],
		joinedCaptureAntibodyOptions
	];

    (* Make the association pointing from the option sets to the loading volumes. Then we will be able to merge based on the key. *)
    (* By default, we only need to prepare 1 copy of the antibody sample when they share the same options. However, we need to check whether we get enough volume for loading. If not, we need to prepare more than 1 set. For example, if the user specified that a conjugation total preparation volume of 100 Microliter is needed and a loading volume of 50 Microliter for 3 samples, we have to prepare 2 * 100 Microliter as our resource *)
    (* Note that the joinedCaptureAntibodyContainers, requiredCaptureAntibodyDilutionVolumes and requiredCaptureAntibodyConjugationVolumes are guaranteed to be the same when the preparation options are the same *)
	(* Molecular Weight and Concentration information are added for easy lookup in the later steps *)
	(* Because our dilution volumes are directly related to the loading volume, it is not necessary to be the same. Put it to the same side of the rule *)
    pairedCaptureAntibodyOptionAndLoadingVolumes=MapThread[
        ({#1,#2,#3,#4,#5,#6}->{#7,#8})&,
        {joinedCaptureAntibodyOptionsRuleList,joinedCaptureAntibodyContainers,requiredCaptureAntibodyConjugationVolumes,totalCaptureAntibodyPreparationVolumes,jointCaptureAntibodyAverageMolecularWeight,joinedCaptureAntibodyConcentration,requiredCaptureAntibodyDilutionVolumes,requiredCaptureAntibodyLoadingVolumes}
    ];

    (* If we get the same options, merge the total volume *)
    (* We drop the association when the loading volume is Null. This is the case when cartridge is not customizable *)
	(* Note that this Merge may lead to n*Null for the first value key - this happens when antibody sample is not diluted. We should not have a+Null because if they can merge, they must all dilute or not dilute *)
    uniqueRequiredCaptureAntibodyLoadingVolumes=Merge[
        Select[
            pairedCaptureAntibodyOptionAndLoadingVolumes,
			!MatchQ[#[[2,2]],Null]&
        ],
        Total
    ];

    (* Now we can check whether we have enough volume prepared in dilution and conjugation. If not, we have to increase the amount. *)
    (* Define a variable to determine how many sets of reagents we need to prepare *)
    uniqueRequiredCaptureAntibodyNumbers=KeyValueMap[
        Quotient[
            #2[[2]],
            Which[
                (* If we get a preparation volume from Conjugation or Dilution, use that for calculation of how many sets we need *)
                !MatchQ[#1[[4]],Null],#1[[4]],
                (* If we don't do conjugation or dilution, we only prepare 1 set of sample from resuspension or directly from the source. *)
                True,Infinity*Microliter
            ]
        ]+1&,
        uniqueRequiredCaptureAntibodyLoadingVolumes
    ];

    (* Determine the volume of capture antibody samples needed. This is still after resuspension, if applicable *)
    (* This is the volume from the last processing step - conjugation, dilution or loading steps *)

    uniqueRequiredCaptureAntibodyVolumes=MapThread[
        (* Get the first non-Null volume. Multiply that number by the required set number for conjugation and dilution *)
        Which[
			(* Conjugation required *)
            !MatchQ[#1,Null],#1*#4,
			(* Dilution required *)
            !MatchQ[#2,Null|(_*Null)],#2*#4,
			(* Direct loading - Add 10 Microliter to make sure we have enough volume*)
            True,#3+10Microliter
        ]&,
        {Keys[uniqueRequiredCaptureAntibodyLoadingVolumes][[All,3]],Values[uniqueRequiredCaptureAntibodyLoadingVolumes][[All,1]],Values[uniqueRequiredCaptureAntibodyLoadingVolumes][[All,2]],uniqueRequiredCaptureAntibodyNumbers}
    ];

    (* Turn volume into mass if resuspension is performed. Get the molecular weight information into the MapThread *)
    uniqueRequiredCaptureAntibodyAmounts=MapThread[
        (* The second option value is CaptureAntibodyResuspension, which is a Boolean *)
        Which[
			(* If not resuspended - use the volume directly *)
			MatchQ[Lookup[#1,CaptureAntibodyResuspension],Except[True]],#2,
            (* Depending on the unit of resuspension concentration - get the mass*)
            MatchQ[Lookup[#1,CaptureAntibodyResuspensionConcentration],GreaterEqualP[0Microgram/Milliliter]],
			Lookup[#1,CaptureAntibodyResuspensionConcentration]*#2,
			MatchQ[Lookup[#1,CaptureAntibodyResuspensionConcentration],GreaterEqualP[0Molar]],
			Lookup[#1,CaptureAntibodyResuspensionConcentration]*#2*#3
        ]&,
        {Keys[uniqueRequiredCaptureAntibodyLoadingVolumes][[All,1]],uniqueRequiredCaptureAntibodyVolumes,Keys[uniqueRequiredCaptureAntibodyLoadingVolumes][[All,5]]}
    ];

    (* If a unique capture antibody sample is not already in a liquid handler compatible container, we can move it into a liquid handler compatible container. This is also true for any liquid Model[Sample] case. Model[Sample] container is returning Null. If we have a solid state sample, we do not move it. We can move a certain amount out to a compatible container after resuspension in Procedure. *)

    uniqueCaptureAntibodyTargetContainers=MapThread[
        Function[{container,amount},
            Which[
                (* Not moving the sample if it is in solid state *)
                MatchQ[amount,GreaterEqualP[0Gram]],Null,
                (* Not moving if it is already in a liquid handler compatible container *)
                MemberQ[liquidHandlerCompatibleContainers,container],Null,
                (* Otherwise find a container with volume larger than required *)
                True,PreferredContainer[amount]
            ]
        ],
        {Keys[uniqueRequiredCaptureAntibodyLoadingVolumes][[All,2]],uniqueRequiredCaptureAntibodyAmounts}
    ];

    (* Create the unique capture antibody resources with the options listed so that we can replace rule later to point from an antibody to its correct resource. *)
    (* Note that we are not worried about Sample being Null here as we have deleted the cases with loading volume set to Null. *)
    uniqueCaptureAntibodyResourcesRules=MapThread[
        Function[{options,amount,container},
            Which[
                MatchQ[container,Null],(options->Link[Resource[Sample->Lookup[options,CaptureAntibody],Name->ToString[Unique[]],Amount->amount]]),
                !MatchQ[container,Null],(options->Link[Resource[Sample->Lookup[options,CaptureAntibody],Name->ToString[Unique[]],Amount->amount,Container->container]])
            ]
        ],
        {Keys[uniqueRequiredCaptureAntibodyLoadingVolumes][[All,1]],uniqueRequiredCaptureAntibodyAmounts,uniqueCaptureAntibodyTargetContainers}
    ];

	(* Get the option values only resources - pointing from list of options to the unique resources - this is the replacement rule *)
	uniqueCaptureAntibodyResources=Map[
		(Values[Keys[#]]->Values[#])&,
		uniqueCaptureAntibodyResourcesRules
	];

	(* Replace the capture antibodies with their resources *)
	{
		customCaptureAntibodyResources,standardCaptureAntibodyResources
	}=If[customizableCartridgeQ,
		Map[
			Replace[#,uniqueCaptureAntibodyResources,{1}]&,
			{captureAntibodyOptions,standardCaptureAntibodyOptions}
		],
		{{},{}}
	];


    (* Detection Antibody *)
    (* We can start with getting all the option values. *)
	{customDetectionAntibody,detectionAntibodyResuspension,detectionAntibodyResuspensionConcentration,detectionAntibodyResuspensionDiluent,detectionAntibodyStorageCondition,detectionAntibodyConjugation,detectionAntibodyVolume,biotinReagent,biotinReagentVolume,detectionAntibodyConjugationBuffer,detectionAntibodyConjugationBufferVolume,detectionAntibodyConjugationContainer,detectionAntibodyConjugationTime,detectionAntibodyConjugationTemperature,detectionAntibodyPurificationColumn,detectionAntibodyColumnWashBuffer,detectionAntibodyConjugationStorageCondition,detectionAntibodyDilution,detectionAntibodyTargetConcentration,detectionAntibodyDiluent,detectionAntibodyLoadingVolume}=Lookup[
		optionsWithReplicates,
		{CustomDetectionAntibody,DetectionAntibodyResuspension,DetectionAntibodyResuspensionConcentration,DetectionAntibodyResuspensionDiluent,DetectionAntibodyStorageCondition,DetectionAntibodyConjugation,DetectionAntibodyVolume,BiotinReagent,BiotinReagentVolume,DetectionAntibodyConjugationBuffer,DetectionAntibodyConjugationBufferVolume,DetectionAntibodyConjugationContainer,DetectionAntibodyConjugationTime,DetectionAntibodyConjugationTemperature,DetectionAntibodyPurificationColumn,DetectionAntibodyColumnWashBuffer,DetectionAntibodyConjugationStorageCondition,DetectionAntibodyDilution,DetectionAntibodyTargetConcentration,DetectionAntibodyDiluent,DetectionAntibodyLoadingVolume}
	];

	{standardDetectionAntibody,standardDetectionAntibodyResuspension,standardDetectionAntibodyResuspensionConcentration,standardDetectionAntibodyResuspensionDiluent,standardDetectionAntibodyStorageCondition,standardDetectionAntibodyConjugation,standardDetectionAntibodyVolume,standardBiotinReagent,standardBiotinReagentVolume,standardDetectionAntibodyConjugationBuffer,standardDetectionAntibodyConjugationBufferVolume,standardDetectionAntibodyConjugationContainer,standardDetectionAntibodyConjugationTime,standardDetectionAntibodyConjugationTemperature,standardDetectionAntibodyPurificationColumn,standardDetectionAntibodyColumnWashBuffer,standardDetectionAntibodyConjugationStorageCondition,standardDetectionAntibodyDilution,standardDetectionAntibodyTargetConcentration,standardDetectionAntibodyDiluent,standardDetectionAntibodyLoadingVolume}=Lookup[
		optionsWithReplicates,
		{StandardDetectionAntibody,StandardDetectionAntibodyResuspension,StandardDetectionAntibodyResuspensionConcentration,StandardDetectionAntibodyResuspensionDiluent,StandardDetectionAntibodyStorageCondition,StandardDetectionAntibodyConjugation,StandardDetectionAntibodyVolume,StandardBiotinReagent,StandardBiotinReagentVolume,StandardDetectionAntibodyConjugationBuffer,StandardDetectionAntibodyConjugationBufferVolume,StandardDetectionAntibodyConjugationContainer,StandardDetectionAntibodyConjugationTime,StandardDetectionAntibodyConjugationTemperature,StandardDetectionAntibodyPurificationColumn,StandardDetectionAntibodyColumnWashBuffer,StandardDetectionAntibodyConjugationStorageCondition,StandardDetectionAntibodyDilution,StandardDetectionAntibodyTargetConcentration,StandardDetectionAntibodyDiluent,StandardDetectionAntibodyLoadingVolume}
	];

	(* Join the standard detection antibody options together with input sample detection antibody options when Standard is not Null *)
	{joinedDetectionAntibody,joinedDetectionAntibodyResuspension,joinedDetectionAntibodyResuspensionConcentration,joinedDetectionAntibodyResuspensionDiluent,joinedDetectionAntibodyStorageCondition,joinedDetectionAntibodyConjugation,joinedDetectionAntibodyVolume,joinedBiotinReagent,joinedBiotinReagentVolume,joinedDetectionAntibodyConjugationBuffer,joinedDetectionAntibodyConjugationBufferVolume,joinedDetectionAntibodyConjugationContainer,joinedDetectionAntibodyConjugationTime,joinedDetectionAntibodyConjugationTemperature,joinedDetectionAntibodyPurificationColumn,joinedDetectionAntibodyColumnWashBuffer,joinedDetectionAntibodyConjugationStorageCondition,joinedDetectionAntibodyDilution,joinedDetectionAntibodyTargetConcentration,joinedDetectionAntibodyDiluent,joinedDetectionAntibodyLoadingVolume}=MapThread[
		If[MatchQ[standard,Null],
			#1,
			Join[#1,#2]
		]&,
		{{customDetectionAntibody,detectionAntibodyResuspension,detectionAntibodyResuspensionConcentration,detectionAntibodyResuspensionDiluent,detectionAntibodyStorageCondition,detectionAntibodyConjugation,detectionAntibodyVolume,biotinReagent,biotinReagentVolume,detectionAntibodyConjugationBuffer,detectionAntibodyConjugationBufferVolume,detectionAntibodyConjugationContainer,detectionAntibodyConjugationTime,detectionAntibodyConjugationTemperature,detectionAntibodyPurificationColumn,detectionAntibodyColumnWashBuffer,detectionAntibodyConjugationStorageCondition,detectionAntibodyDilution,detectionAntibodyTargetConcentration,detectionAntibodyDiluent,detectionAntibodyLoadingVolume},
			{standardDetectionAntibody,standardDetectionAntibodyResuspension,standardDetectionAntibodyResuspensionConcentration,standardDetectionAntibodyResuspensionDiluent,standardDetectionAntibodyStorageCondition,standardDetectionAntibodyConjugation,standardDetectionAntibodyVolume,standardBiotinReagent,standardBiotinReagentVolume,standardDetectionAntibodyConjugationBuffer,standardDetectionAntibodyConjugationBufferVolume,standardDetectionAntibodyConjugationContainer,standardDetectionAntibodyConjugationTime,standardDetectionAntibodyConjugationTemperature,standardDetectionAntibodyPurificationColumn,standardDetectionAntibodyColumnWashBuffer,standardDetectionAntibodyConjugationStorageCondition,standardDetectionAntibodyDilution,standardDetectionAntibodyTargetConcentration,standardDetectionAntibodyDiluent,standardDetectionAntibodyLoadingVolume}}
	];

    (* Download detection antibody packets to get its concentration *)
    joinedDetectionAntibodyPackets=Experiment`Private`fetchPacketFromFastAssoc[#,inheritedFastAssoc]&/@joinedDetectionAntibody;

	(* Look up for the antibody identity model in the composition of the sample for concentration *)
	(* Find all identity models of the detection antibody *)
	joinedDetectionAntibodyIdentityModels=Map[
		Function[
			{singleAntibodyPacket},
			If[NullQ[singleAntibodyPacket],
				{},
				Select[Lookup[singleAntibodyPacket,Composition,{}],MatchQ[#,{_,ObjectP[Model[Molecule,Protein,Antibody]]}]&]
			]
		],
		joinedDetectionAntibodyPackets
	];
	(* Find all molecular weights of all identity models *)
	jointDetectionAntibodyMolecularWeights=Map[
    DeleteCases[
      Module[{links},
        links = #[[All, 2]];
        Map[
          Function[{antibody},
            Experiment`Private`fastAssocLookup[inheritedFastAssoc,antibody,MolecularWeight]
          ],
          links
        ]
      ],
      Null
    ]&,

    (*)DeleteCases[Download[#[[All,2]],MolecularWeight,Cache->inheritedCache,Date->Now],Null]&,*)
    joinedDetectionAntibodyIdentityModels
  ];

	(* Use the first molecular weight - consistent with the concentration value origin or 150000 Dalton for caculation *)
	jointDetectionAntibodyAverageMolecularWeight=Map[
		FirstOrDefault[#,150000Dalton]&,
		jointDetectionAntibodyMolecularWeights
	];

	joinedDetectionAntibodyConcentration=MapThread[
		Which[
			(* Set to Null if we don't have a packet or we don't have any protein identity model*)
			MatchQ[#2,{}],Null,
			(* Set to Null if we get a solid *)
			MatchQ[Lookup[#1,State,Null],Solid],Null,
			(* Get the concentration if the antibody identity model composition is available *)
			MatchQ[#2[[1,1]],GreaterEqualP[0Milligram/Milliliter]|GreaterEqualP[0Molar]],#2[[1,1]],
			True,Null
		]&,
		{joinedDetectionAntibodyPackets,joinedDetectionAntibodyIdentityModels}
	];

    (* We also need to check what containers the detection antibody samples are in if they are in liquid state. The containers must be liquid handler compatible so that we can perform the follow-up steps including conjugation, dilution and cartridge loading *)
    (* Get information about the containers of the detection antibody samples *)
    joinedDetectionAntibodyContainers=Map[
      Which[
        MatchQ[#,Null],Null,
        MatchQ[Lookup[#,Container,Null],ObjectP[Model[Container]]],
        Download[Lookup[#,Container,Null],Object,Cache->inheritedCache,Date->Now],
        True,
        If[MatchQ[Lookup[#,Container,Null],Null],
          Null,
          Experiment`Private`fastAssocLookup[inheritedFastAssoc,Lookup[#,Container,Null],{Model,Object}]
        ]
      ]&,
      joinedDetectionAntibodyPackets
    ];

	(* Get the volume needed for each step. If a step if not performed, use Null for the volume. The first non-Null volume is the volume required from the resource. *)
	(* Note that resuspension step is not included as that is the step to turn Solid into Liquid *)

    (* Get the total loading volume with the number of diluted samples considered *)
    requiredDetectionAntibodyLoadingVolumes=MapThread[
		If[MatchQ[#1,Null],
			Null,
			(#1*#2)
		]&,
        {joinedDetectionAntibodyLoadingVolume,joinedNumberOfSamples}
    ];

	requiredDetectionAntibodyDilutionVolumes=MapThread[
		Which[
			MatchQ[#1,Null|False],Null,

			(* If we have done conjugation and resuspension, we can use 1/2 of the resuspension concentration for estimation of the required volume. This 1/2 takes the loss in conjugation and purification process into concern. *)
			(* Add 5 Microliter to loading volume to make sure enough volume can be loaded *)
			MatchQ[#3,True]&&MatchQ[#4,True],#2*(#7+10Microliter)*2/#5,

			(* If we have done resuspension but not conjugation, we can directly use the resuspension concentration *)
			MatchQ[#4,True]&&!MatchQ[#3,True],#2*(#7+10Microliter)/#5,

			(* If we have done conjugation only, we can use the concentration from composition for calculation of volume - Take in 1/2 loss*)
			!MatchQ[#4,True]&&MatchQ[#3,True]&&!MatchQ[#6,Null],#2*(#7+10Microliter)*2/#6,

			(* If we have not done resuspension or conjugation, we can use the concentration from composition for calculation of volume *)
			!MatchQ[#3,True]&&!MatchQ[#4,True]&&!MatchQ[#6,Null],#2*(#7+10Microliter)/#6,

			(* For all other cases, we should stay safe and use 1/50 total required volume as the resource required volume for antibody samples. It is an estimation. Usually the resource of the sample is much higher than the final concentration. *)
			True,(#7+10Microliter)/50
		]&,
		{joinedDetectionAntibodyDilution,joinedDetectionAntibodyTargetConcentration,joinedDetectionAntibodyConjugation,joinedDetectionAntibodyResuspension,joinedDetectionAntibodyResuspensionConcentration,joinedDetectionAntibodyConcentration,requiredDetectionAntibodyLoadingVolumes}
	];

	requiredDetectionAntibodyConjugationVolumes=joinedDetectionAntibodyVolume;

	(* The loaded detection antibody sample is from the prepared sample after dilution and/or conjugation. We can decide the total prepared volume. *)
	totalDetectionAntibodyPreparationVolumes=MapThread[
		Which[
			MatchQ[#1,True],Null,

			(* If we have done conjugation only, use the total prepared volume *)
			MatchQ[#2,True],#3+#4+#5,

			(* If we have done only resuspension or none of the processing steps, we can directly set preparation volumes to Null *)
			True,Null
		]&,
		{joinedDetectionAntibodyDilution,joinedDetectionAntibodyConjugation,joinedDetectionAntibodyVolume,joinedBiotinReagentVolume,joinedDetectionAntibodyConjugationBufferVolume}
	];

    (* Now we need to check whether we can get some of the resources prepared together *)

    (* Transpose the options to put the options for each sample together *)
    (* We do not include loading volume here as it doesn't have to be the same for the antibody sample to be prepared together *)

	detectionAntibodyOptions=Transpose@{customDetectionAntibody,detectionAntibodyResuspension,detectionAntibodyResuspensionConcentration,detectionAntibodyResuspensionDiluent,detectionAntibodyStorageCondition,detectionAntibodyConjugation,detectionAntibodyVolume,biotinReagent,biotinReagentVolume,detectionAntibodyConjugationBuffer,detectionAntibodyConjugationBufferVolume,detectionAntibodyConjugationContainer,detectionAntibodyConjugationTime,detectionAntibodyConjugationTemperature,detectionAntibodyPurificationColumn,detectionAntibodyColumnWashBuffer,detectionAntibodyConjugationStorageCondition,detectionAntibodyDilution,detectionAntibodyTargetConcentration,detectionAntibodyDiluent};

	standardDetectionAntibodyOptions=If[!MatchQ[standard,Null],
		Transpose@{standardDetectionAntibody,standardDetectionAntibodyResuspension,standardDetectionAntibodyResuspensionConcentration,standardDetectionAntibodyResuspensionDiluent,standardDetectionAntibodyStorageCondition,standardDetectionAntibodyConjugation,standardDetectionAntibodyVolume,standardBiotinReagent,standardBiotinReagentVolume,standardDetectionAntibodyConjugationBuffer,standardDetectionAntibodyConjugationBufferVolume,standardDetectionAntibodyConjugationContainer,standardDetectionAntibodyConjugationTime,standardDetectionAntibodyConjugationTemperature,standardDetectionAntibodyPurificationColumn,standardDetectionAntibodyColumnWashBuffer,standardDetectionAntibodyConjugationStorageCondition,standardDetectionAntibodyDilution,standardDetectionAntibodyTargetConcentration,standardDetectionAntibodyDiluent},
		{}
	];

	joinedDetectionAntibodyOptions=Transpose@{joinedDetectionAntibody,joinedDetectionAntibodyResuspension,joinedDetectionAntibodyResuspensionConcentration,joinedDetectionAntibodyResuspensionDiluent,joinedDetectionAntibodyStorageCondition,joinedDetectionAntibodyConjugation,joinedDetectionAntibodyVolume,joinedBiotinReagent,joinedBiotinReagentVolume,joinedDetectionAntibodyConjugationBuffer,joinedDetectionAntibodyConjugationBufferVolume,joinedDetectionAntibodyConjugationContainer,joinedDetectionAntibodyConjugationTime,joinedDetectionAntibodyConjugationTemperature,joinedDetectionAntibodyPurificationColumn,joinedDetectionAntibodyColumnWashBuffer,joinedDetectionAntibodyConjugationStorageCondition,joinedDetectionAntibodyDilution,joinedDetectionAntibodyTargetConcentration,joinedDetectionAntibodyDiluent};

	(* Turn joinedDetectionAntibodyOptions into a list of rules so we can easily look up *)
	joinedDetectionAntibodyOptionsRuleList=Map[
		Function[
			{detectionAntibodyOptions},
			MapThread[
				(#1->#2)&,
				{{DetectionAntibody,DetectionAntibodyResuspension,DetectionAntibodyResuspensionConcentration,DetectionAntibodyResuspensionDiluent,DetectionAntibodyStorageCondition,DetectionAntibodyConjugation,DetectionAntibodyVolume,BiotinReagent,BiotinReagentVolume,DetectionAntibodyConjugationBuffer,DetectionAntibodyConjugationBufferVolume,DetectionAntibodyConjugationContainer,DetectionAntibodyConjugationTime,DetectionAntibodyConjugationTemperature,DetectionAntibodyPurificationColumn,DetectionAntibodyColumnWashBuffer,DetectionAntibodyConjugationStorageCondition,DetectionAntibodyDilution,DetectionAntibodyTargetConcentration,DetectionAntibodyDiluent},detectionAntibodyOptions}
			]
		],
		joinedDetectionAntibodyOptions
	];

	(* Make the association pointing from the option sets and preparation volumes to the loading volumes. Then we will be able to merge based on the key. *)
	(* By default, we only need to prepare 1 copy of the antibody sample when they share the same options. However, we need to check whether we get enough volume for loading. If not, we need to prepare more than 1 set. For example, if the user specified that a conjugation total preparation volume of 100 Microliter is needed and a loading volume of 50 Microliter for 3 samples, we have to prepare 2 * 100 Microliter as our resource *)
    (* Note that the joinedDetectionAntibodyContainers, requiredDetectionAntibodyDilutionVolumes and requiredDetectionAntibodyConjugationVolumes are guaranteed to be the same when the preparation options are the same *)
	(* Molecular Weight and Concentration information are added for easy lookup in the later steps *)
	(* Because our dilution volumes are directly related to the loading volume, it is not necessary to be the same. Put it to the same side of the rule *)
    pairedDetectionAntibodyOptionAndLoadingVolumes=MapThread[
		({#1,#2,#3,#4,#5,#6}->{#7,#8})&,
        {joinedDetectionAntibodyOptionsRuleList,joinedDetectionAntibodyContainers,requiredDetectionAntibodyConjugationVolumes,totalDetectionAntibodyPreparationVolumes,jointDetectionAntibodyAverageMolecularWeight,joinedDetectionAntibodyConcentration,requiredDetectionAntibodyDilutionVolumes,requiredDetectionAntibodyLoadingVolumes}
    ];

    (* If we get the same options, merge the total volume *)
    (* We drop the association when the loading volume is Null. This is the case when cartridge is not customizable *)
    uniqueRequiredDetectionAntibodyLoadingVolumes=Merge[
        Select[
            pairedDetectionAntibodyOptionAndLoadingVolumes,
            !MatchQ[#[[2,2]],Null]&
        ],
        Total
    ];

    (* Now we can check whether we have enough volume prepared in dilution and conjugation. If not, we have to increase the amount. *)
    (* Define a variable to determine how many sets of reagents we need to prepare *)
    uniqueRequiredDetectionAntibodyNumbers=KeyValueMap[
        Quotient[
			#2[[2]],
            Which[
				(* If we get a preparation volume from Conjugation or Dilution, use that for calculation of how many sets we need *)
				!MatchQ[#1[[4]],Null],#1[[4]],
				(* If we don't do conjugation or dilution, we only prepare 1 set of sample from resuspension or directly from the source. *)
				True,Infinity*Microliter
            ]
        ]+1&,
        uniqueRequiredDetectionAntibodyLoadingVolumes
    ];

    (* Determine the volume of detection antibody samples needed. This is still after resuspension, if applicable *)
    (* This is the volume from the last processing step - conjugation, dilution or loading steps *)

    uniqueRequiredDetectionAntibodyVolumes=MapThread[
        (* Get the first non-Null volume. Multiply that number by the required set number for conjugation and dilution *)
        Which[
			(* Conjugation required *)
			!MatchQ[#1,Null],#1*#4,
			(* Dilution required *)
			!MatchQ[#2,Null|(_*Null)],#2*#4,
			(* Direct loading - Add 10 Microliter to make sure we have enough volume*)
			True,#3+10Microliter
        ]&,
        {Keys[uniqueRequiredDetectionAntibodyLoadingVolumes][[All,3]],Values[uniqueRequiredDetectionAntibodyLoadingVolumes][[All,1]],Values[uniqueRequiredDetectionAntibodyLoadingVolumes][[All,2]],uniqueRequiredDetectionAntibodyNumbers}
    ];

	(* Turn volume into mass if resuspension is performed. Get the molecular weight information into the MapThread *)
	uniqueRequiredDetectionAntibodyAmounts=MapThread[
		(* The second option value is DetectionAntibodyResuspension, which is a Boolean *)
		Which[
			(* If not resuspended - use the volume directly *)
			MatchQ[Lookup[#1,DetectionAntibodyResuspension],Except[True]],#2,
			(* Depending on the unit of resuspension concentration - get the mass*)
			MatchQ[Lookup[#1,DetectionAntibodyResuspensionConcentration],GreaterEqualP[0Microgram/Milliliter]],
			Lookup[#1,DetectionAntibodyResuspensionConcentration]*#2,
			MatchQ[Lookup[#1,DetectionAntibodyResuspensionConcentration],GreaterEqualP[0Molar]],
			Lookup[#1,DetectionAntibodyResuspensionConcentration]*#2*#3
		]&,
		{Keys[uniqueRequiredDetectionAntibodyLoadingVolumes][[All,1]],uniqueRequiredDetectionAntibodyVolumes,Keys[uniqueRequiredDetectionAntibodyLoadingVolumes][[All,5]]}
	];

    (* If a unique detection antibody sample is not already in a liquid handler compatible container, we can move it into a liquid handler compatible container. This is also true for any liquid Model[Sample] case. Model[Sample] container is returning Null. If we have a solid state sample, we do not move it. We can move a certain amount out to a compatible container after resuspension in Procedure. *)

    uniqueDetectionAntibodyTargetContainers=MapThread[
        Function[{container,amount},
            Which[
                (* Not moving the sample if it is in solid state *)
                MatchQ[amount,GreaterEqualP[0Gram]],Null,
                (* Not moving if it is already in a liquid handler compatible container *)
                MemberQ[liquidHandlerCompatibleContainers,container],Null,
                (* Otherwise find a container with volume larger than required *)
                True,PreferredContainer[amount]
            ]
        ],
        {Keys[uniqueRequiredDetectionAntibodyLoadingVolumes][[All,2]],uniqueRequiredDetectionAntibodyAmounts}
    ];

    (* Create the unique detection antibody resources with the options listed so that we can replace rule later to point from an antibody to its correct resource. *)
    uniqueDetectionAntibodyResourcesRules=MapThread[
        Function[{options,amount,container},
            Which[
                MatchQ[container,Null],(options->Link[Resource[Sample->Lookup[options,DetectionAntibody],Name->ToString[Unique[]],Amount->amount]]),
                !MatchQ[container,Null],(options->Link[Resource[Sample->Lookup[options,DetectionAntibody],Name->ToString[Unique[]],Amount->amount,Container->container]])
            ]
        ],
        {Keys[uniqueRequiredDetectionAntibodyLoadingVolumes][[All,1]],uniqueRequiredDetectionAntibodyAmounts,uniqueDetectionAntibodyTargetContainers}
    ];

	(* Get the option values only resources - pointing from list of options to the unique resources - this is the replacement rule *)
	uniqueDetectionAntibodyResources=Map[
		(Values[Keys[#]]->Values[#])&,
		uniqueDetectionAntibodyResourcesRules
	];

	(* Replace the detection antibodies with their resources *)
	{
		customDetectionAntibodyResources,standardDetectionAntibodyResources
	}=If[customizableCartridgeQ,
		Map[
			Replace[#,uniqueDetectionAntibodyResources,{1}]&,
			{detectionAntibodyOptions,standardDetectionAntibodyOptions}
		],
		{{},{}}
	];

    (* -- Generate resources for the Bioconjugation Reagents -- *)
    (* Download the Digoxigenin reagents and the volumes from uniqueRequiredCaptureAntibodyLoadingVolumes, counting in uniqueRequiredCaptureAntibodyNumbers for the same reason as above *)
    (* We use the unique capture antibody volumes above because when antibody samples are prepared together, we only need uniqueRequiredCaptureAntibodyNumbers copy of the digoxigenin reagent *)

    (* The 17th option of the list is StandardDigoxigeninReagent or DigoxigeninReagent. Get all possible reagents *)
    allDigoxigeninReagents=Lookup[#,DigoxigeninReagent]&/@Keys[uniqueRequiredCaptureAntibodyLoadingVolumes][[All,1]];

    (* The 18th option of the list is StandardDigoxigeninReagentVolume or DigoxigeninReagentVolume. Get all volumes, multiplied by the copy number of reagents required. If we don't have a volume, due to the fact that capture antibody itself is Null, or conjugation is not required, or we cannot resolve the volume. Use 0 Microliter. *)
    allDigoxigeninReagentVolumes=MapThread[
        If[MatchQ[#1,Null],
            0Microliter,
            #1*#2
        ]&,
        {Lookup[Keys[uniqueRequiredCaptureAntibodyLoadingVolumes][[All,1]],DigoxigeninReagentVolume,{}],uniqueRequiredCaptureAntibodyNumbers}
    ];

    (* Pair the Digoxigenin reagents and their volumes *)
    pairedDigoxigeninReagentAndVolumes=MapThread[
        (#1->#2)&,
        {allDigoxigeninReagents,allDigoxigeninReagentVolumes}
    ];

    (* Merge the Digoxigenin reagents volumes together to get the total volume of each reagent's resource *)
    (* Get a list of volume rules, getting rid of any rules with the pattern Null->__ or __->0Microliter *)
    digoxigeninVolumeRules=DeleteCases[
        KeyDrop[
            Merge[pairedDigoxigeninReagentAndVolumes,Total],
            Null
        ],
        0Microliter
    ];

    (* Use the volume rules association to make resources for each unique Object or Model. Transfer it to a Hamilton compatible container *)
    uniqueDigoxigeninResources=KeyValueMap[
        Module[{amount,containers},
            amount=#2;
			containers=PreferredContainer[amount];
			Link[Resource[Sample->#1,Name->ToString[Unique[]],Amount->amount,Container->containers]]
        ]&,
        digoxigeninVolumeRules
    ];

    (* Construct a list of replace rules to point from the digoxigenin reagent object to its resource *)
    uniqueDigoxigeninReagentObjects=Keys[digoxigeninVolumeRules];
    uniqueDigoxigeninResourceReplaceRules=MapThread[
        (#1->#2)&,
        {uniqueDigoxigeninReagentObjects,uniqueDigoxigeninResources}
    ];

    (* Use the unique digoxigenin reagent object replace rules to make lists of the resources of the digoxigenin reagent options. We prepare all the same object/model together so it's safe to just use ID to replace the original object *)
	{
		digoxigeninReagentResources,standardDigoxigeninReagentResources
	}=If[customizableCartridgeQ,
		Map[
			Replace[#,uniqueDigoxigeninResourceReplaceRules,{1}]&,
			{digoxigeninReagent,standardDigoxigeninReagent}
		],
		{{},{}}
	];

    (* Download the Biotin reagents and the volumes from uniqueRequiredDetectionAntibodyLoadingVolumes, counting in uniqueRequiredDetectionAntibodyNumbers for the same reason as above *)
    (* We use the unique detection antibody volumes above because when antibody samples are prepared together, we only need uniqueRequiredDetectionAntibodyNumbers copy of the biotin reagent *)

    (* The 17th option of the list is StandardBiotinReagent or BiotinReagent. Get all possible reagents *)
    allBiotinReagents=Lookup[#,BiotinReagent]&/@Keys[uniqueRequiredDetectionAntibodyLoadingVolumes][[All,1]];

    (* The 18th option of the list is StandardBiotinReagentVolume or BiotinReagentVolume. Get all volumes, multiplied by the copy number of reagents required. If we don't have a volume, due to the fact that detection antibody itself is Null, or conjugation is not required, or we cannot resolve the volume. Use 0 Microliter. *)
    allBiotinReagentVolumes=MapThread[
        If[MatchQ[#1,Null],
            0Microliter,
            #1*#2
        ]&,
        {Lookup[Keys[uniqueRequiredDetectionAntibodyLoadingVolumes][[All,1]],BiotinReagentVolume,{}],uniqueRequiredDetectionAntibodyNumbers}
    ];

    (* Pair the Biotin reagents and their volumes *)
    pairedBiotinReagentAndVolumes=MapThread[
        (#1->#2)&,
        {allBiotinReagents,allBiotinReagentVolumes}
    ];

    (* Merge the Biotin reagents volumes together to get the total volume of each reagent's resource *)
    (* Get a list of volume rules, getting rid of any rules with the pattern Null->__ or __->0Microliter *)
    biotinVolumeRules=DeleteCases[
        KeyDrop[
            Merge[pairedBiotinReagentAndVolumes,Total],
            Null
        ],
        0Microliter
    ];

    (* Use the volume rules association to make resources for each unique Object or Model. Transfer it to a Hamilton compatible container *)
    uniqueBiotinResources=KeyValueMap[
		Module[{amount,containers},
			amount=#2;
			containers=PreferredContainer[amount];
			Link[Resource[Sample->#1,Name->ToString[Unique[]],Amount->amount,Container->containers]]
		]&,
        biotinVolumeRules
    ];

    (* Construct a list of replace rules to point from the biotin reagent object to its resource *)
    uniqueBiotinReagentObjects=Keys[biotinVolumeRules];
    uniqueBiotinResourceReplaceRules=MapThread[
        (#1->#2)&,
        {uniqueBiotinReagentObjects,uniqueBiotinResources}
    ];

	(* Use the unique biotin reagent object replace rules to make lists of the resources of the biotin reagent options. We prepare all the same object/model together so it's safe to just use ID to replace the original object *)
	{
		biotinReagentResources,standardBiotinReagentResources
	}=If[customizableCartridgeQ,
		Map[
			Replace[#,uniqueBiotinResourceReplaceRules,{1}]&,
			{biotinReagent,standardBiotinReagent}
		],
		{{},{}}
	];



    (* -- Generate resources for the Bioconjugation Buffers -- *)

    (* Download the Bioconjugation buffers and the volumes from uniqueRequiredCaptureAntibodyLoadingVolumes, uniqueRequiredDetectionAntibodyLoadingVolumes, counting in uniqueRequiredCaptureAntibodyNumbers, uniqueRequiredDetectionAntibodyNumbers for the same reason as above *)
    (* We use the unique antibody volumes above because when antibody samples are prepared together, we only need uniqueRequiredCaptureAntibodyNumbers or uniqueRequiredDetectionAntibodyNumbers copy of the bioconjugation buffer *)

    (* The 19th option of the list is StandardCaptureAntibodyConjugationBuffer, CaptureAntibodyConjugationBuffer, StandardDetectionAntibodyConjugationBuffer or DetectionAntibodyConjugationBuffer. Get all possible buffers *)
    allAntibodyConjugationBuffers=Join[Lookup[Keys[uniqueRequiredCaptureAntibodyLoadingVolumes][[All,1]],CaptureAntibodyConjugationBuffer,{}],Lookup[Keys[uniqueRequiredDetectionAntibodyLoadingVolumes][[All,1]],DetectionAntibodyConjugationBuffer,{}]];

    (* The 20th option of the list is StandardCaptureAntibodyConjugationBufferVolume, CaptureAntibodyConjugationBufferVolume, StandardDetectionAntibodyConjugationBufferVolume or DetectionAntibodyConjugationBufferVolume. Get all volumes, multiplied by the copy number of reagents required. If we don't have a volume, due to the fact that antibody itself is Null, or conjugation is not required, or we cannot resolve the volume. Use 0 Microliter. *)
    allAntibodyConjugationBufferVolumes=MapThread[
        If[MatchQ[#1,Null],
            0Microliter,
            #1*#2
        ]&,
        {Join[Lookup[Keys[uniqueRequiredCaptureAntibodyLoadingVolumes][[All,1]],CaptureAntibodyConjugationBufferVolume,{}],Lookup[Keys[uniqueRequiredDetectionAntibodyLoadingVolumes][[All,1]],DetectionAntibodyConjugationBufferVolume,{}]],Join[uniqueRequiredCaptureAntibodyNumbers,uniqueRequiredDetectionAntibodyNumbers]}
    ];

    (* Pair the conjugation buffers and their volumes *)
    pairedConjugationBuffersAndVolumes=MapThread[
        (#1->#2)&,
        {allAntibodyConjugationBuffers,allAntibodyConjugationBufferVolumes}
    ];

    (* Merge the conjugation buffers volumes together to get the total volume of each buffer's resource *)
    (* Get a list of volume rules, getting rid of any rules with the pattern Null->__ or __->0Microliter *)
    conjugationBufferVolumeRules=DeleteCases[
        KeyDrop[
            Merge[pairedConjugationBuffersAndVolumes,Total],
            Null
        ],
        0Microliter
    ];

    (* Use the volume rules association to make resources for each unique Object or Model. Transfer it to a Hamilton compatible container *)
    uniqueConjugationBufferResources=KeyValueMap[
        Module[{amount,containers},
            amount=#2;
			containers=PreferredContainer[amount];
			Link[Resource[Sample->#1,Name->ToString[Unique[]],Amount->amount,Container->containers]]

        ]&,
        conjugationBufferVolumeRules
    ];

    (* Construct a list of replace rules to point from the conjugation buffer object to its resource *)
    uniqueConjugationBufferObjects=Keys[conjugationBufferVolumeRules];
    uniqueConjugationBufferResourceReplaceRules=MapThread[
        (#1->#2)&,
        {uniqueConjugationBufferObjects,uniqueConjugationBufferResources}
    ];

    (* Use the unique conjugation buffer object replace rules to make lists of the resources of the conjugation buffer options *)
    {
        captureAntibodyConjugationBufferResources,standardCaptureAntibodyConjugationBufferResources,detectionAntibodyConjugationBufferResources,standardDetectionAntibodyConjugationBufferResources
    }=Map[
        Replace[#,uniqueConjugationBufferResourceReplaceRules,{1}]&,
        {captureAntibodyConjugationBuffer,standardCaptureAntibodyConjugationBuffer,detectionAntibodyConjugationBuffer,standardDetectionAntibodyConjugationBuffer}
    ];

    (* -- Generate resources for all the diluents and buffers -- *)
    (* Here we do NOT consider resuspension diluents including StandardResuspensionDiluent, StandardCaptureAntibodyResuspensionDiluent, StandardDetectionAntibodyResuspensionDiluent, CaptureAntibodyResuspensionDiluent and DetectionAntibodyResuspensionDiluent. This is because we cannot know the volume of these resuspension diluents until we get the objects with mass values we can use. *)
    (* We include the following options StandardDiluent, Diluent, StandardCaptureAntibodyColumnWashBuffer, StandardCaptureAntibodyDiluent, StandardDetectionAntibodyColumnWashBuffer, StandardDetectionAntibodyDiluent, CaptureAntibodyColumnWashBuffer, CaptureAntibodyDiluent, DetectionAntibodyColumnWashBuffer and DetectionAntibodyDiluent. *)
	(* We include the fake absorbance blank samples as well because that part is done by default. We use column wash buffer if conjugation is performed or use PBS as default. We can prepare the resources together with column wash buffer. *)

    (* StandardDiluent and Diluent *)

	(* Get the volume of diluent required *)
	requiredDiluentVolumes=MapThread[
		(* Call the helper function to calculate the volume of diluent required for each sample from its dilution curve or serial dilution curve *)
		resolveRequiredDiluentVolumeForDilution[#1,#2]&,
		{dilutionCurve,serialDilutionCurve}
	];

	(* Pair the diluents with volume *)
	pairedDiluentsAndVolumes=MapThread[
		#1->#2&,
		{Lookup[optionsWithReplicates,Diluent],requiredDiluentVolumes}
	];

    (* Get the volume of standard diluent required *)
    requiredStandardDiluentVolumes=If[!MatchQ[standard,Null],
        MapThread[
            (* Call the helper function to calculate the volume of diluent required for each standard sample from its dilution curve or serial dilution curve *)
            resolveRequiredDiluentVolumeForDilution[#1,#2]&,
            {standardDilutionCurve,standardSerialDilutionCurve}
        ],
        {}
    ];

    (* Pair the diluent with volume *)
    pairedStandardDiluentsAndVolumes=If[!MatchQ[standard,Null],
        MapThread[
            #1->#2&,
            {Lookup[optionsWithReplicates,StandardDiluent],requiredStandardDiluentVolumes}
        ],
        {}
    ];

    (* StandardCaptureAntibodyDiluent, StandardDetectionAntibodyDiluent, CaptureAntibodyDiluent, DetectionAntibodyDiluent *)

    (* The 46th option of the list is StandardCaptureAntibodyDiluent, StandardDetectionAntibodyDiluent, CaptureAntibodyDiluent or DetectionAntibodyDiluent. Get all possible buffers *)
    allAntibodyDiluents=Join[Lookup[Keys[uniqueRequiredCaptureAntibodyLoadingVolumes][[All,1]],CaptureAntibodyDiluent,{}],Lookup[Keys[uniqueRequiredDetectionAntibodyLoadingVolumes][[All,1]],DetectionAntibodyDiluent,{}]];

    (* The 38th option of the list is StandardCaptureAntibodyDilution, StandardDetectionAntibodyDilution, CaptureAntibodyDilution or DetectionAntibodyDilution, which contains the volume requirement for the diluent. Get all volumes, multiplied by the copy number of reagents required. If we don't have a dilution, use 0 Microliter. *)
    allAntibodyDiluentVolumes=MapThread[
        If[MatchQ[#1,Null|False],
			0Microliter,
            (* For fixed concentration dilution, we do not bother checking the concentration of the antibody to calculate the amount of the diluent. This is generally accurate because usually these dilutions is more than 20-fold. Using the loading volume as the diluent volume is not far off. The antibody diluent, if they follow our suggestion, is not as expensive. The loading volume is very low. We don't add 5 Microliter to the volume *)
            #2*#3
        ]&,
        {Join[Lookup[Keys[uniqueRequiredCaptureAntibodyLoadingVolumes][[All,1]],CaptureAntibodyDilution,{}],Lookup[Keys[uniqueRequiredDetectionAntibodyLoadingVolumes][[All,1]],DetectionAntibodyDilution,{}]],Join[Values[uniqueRequiredCaptureAntibodyLoadingVolumes][[All,2]],Values[uniqueRequiredDetectionAntibodyLoadingVolumes][[All,2]]],Join[uniqueRequiredCaptureAntibodyNumbers,uniqueRequiredDetectionAntibodyNumbers]}
    ];

    (* Pair the antibody diluents and their volumes *)
    pairedAntibodyDiluentsAndVolumes=MapThread[
        (#1->#2)&,
        {allAntibodyDiluents,allAntibodyDiluentVolumes}
    ];

    (* Get the extra diluent required to fill in all the wells in the capillary ELISA cartridge *)
	extraDiluent=Model[Sample, "id:eGakldJEGX4o"]; (* Model[Sample,"Simple Plex Sample Diluent 13"] *)

    (* Get the volume required for the extra diluent. We need to get the cartridge type and also the number of samples. For each empty well, we need 50Microliter of the diluent *)
    totalNumberOfSamples=Total[{
		Join[

            (* Count the number of standard samples if not Null *)
            If[!MatchQ[standard,Null|{}],

                (* Repeat for every standard sample *)
                MapThread[

                    (* call helper function to figure out the number of samples. Our options can no longer be automatic after resolver. We can safely default it to 0 *)
                    resolveDilutedSampleNumber[#1,#2,0]&,
                    {standardDilutionCurve,standardSerialDilutionCurve}
                ],

                (* give 0 if no standard sample *)
                {0}
            ],

            (* Repeat for every simulated sample *)
            MapThread[

                (* call helper function to figure out the number of samples *)
                resolveDilutedSampleNumber[#1,#2,0]&,
                {dilutionCurve,serialDilutionCurve}
            ]
        ]
    }];

    (* Count the number of empty wells based on cartridge type *)
    numberOfEmptyWells=Which[
        MatchQ[cartridgeType,Customizable],3*(48-totalNumberOfSamples),
        MatchQ[cartridgeType,SinglePlex72X1],72-totalNumberOfSamples,
        MatchQ[cartridgeType,MultiAnalyte32X4|MultiPlex32X8],32-totalNumberOfSamples,
        MatchQ[cartridgeType,MultiAnalyte16X4],16-totalNumberOfSamples
    ];

    (* Get the amount of diluent needed. Note that we change negative amount to 0Microliter. This happens when the total number of samples exceeds the allowed number of the cartridge. An error message has been thrown in our resolver. *)
    extraDiluentVolume=Max[numberOfEmptyWells,0]*50Microliter;

    pairedExtraDiluentAndVolume=(extraDiluent->extraDiluentVolume);

    (* Merge the diluent volumes together to get the total volume of each diluent's resource *)
    (* Get a list of volume rules, getting rid of any rules with the pattern Null->__ or __->0Microliter *)
    diluentVolumeRules=KeyDrop[
        Merge[Join[pairedDiluentsAndVolumes,pairedStandardDiluentsAndVolumes,pairedAntibodyDiluentsAndVolumes,{pairedExtraDiluentAndVolume}],Total],
        Null
    ];

    (* Use the volume rules association to make resources for each unique Object or Model. We always transfer the diluents to a liquid handler compatible container *)
    uniqueDiluentResources=KeyValueMap[
        If[MatchQ[#2,0Microliter],
            Null,
            Module[{amount,containers},
                amount=#2;
                containers=PreferredContainer[amount];
                Link[Resource[Sample->#1,Name->ToString[Unique[]],Amount->amount,Container->containers]]
            ]
        ]&,
        diluentVolumeRules
    ];

    (* Construct a list of replace rules to point from the diluent object to its resource *)
    uniqueDiluentObjects=Keys[diluentVolumeRules];
    uniqueDiluentReplaceRules=MapThread[
        (#1->#2)&,
        {uniqueDiluentObjects,uniqueDiluentResources}
    ];

    (* Use the diluent object replace rules to make lists of the resources of the diluent options *)
    {
		diluentResources,standardDiluentResources,captureAntibodyDiluentResources,standardCaptureAntibodyDiluentResources,detectionAntibodyDiluentResources,standardDetectionAntibodyDiluentResources
    }=Map[
        Replace[#,uniqueDiluentReplaceRules,{1}]&,
        {Lookup[optionsWithReplicates,Diluent],Lookup[optionsWithReplicates,StandardDiluent],captureAntibodyDiluent,standardCaptureAntibodyDiluent,detectionAntibodyDiluent,standardDetectionAntibodyDiluent}
    ];

    (* Get the extra diluent resource *)
    extraDiluentResource=Replace[extraDiluent,uniqueDiluentReplaceRules];

    (* StandardCaptureAntibodyColumnWashBuffer, StandardDetectionAntibodyColumnWashBuffer, CaptureAntibodyColumnWashBuffer, DetectionAntibodyColumnWashBuffer *)
    (* The 30th option of the list is StandardCaptureAntibodyColumnWashBuffer, StandardDetectionAntibodyColumnWashBuffer, CaptureAntibodyColumnWashBuffer or DetectionAntibodyColumnWashBuffer. Get all possible buffers *)
    allAntibodyColumnWashBuffers=Join[Lookup[Keys[uniqueRequiredCaptureAntibodyLoadingVolumes][[All,1]],CaptureAntibodyColumnWashBuffer,{}],Lookup[Keys[uniqueRequiredDetectionAntibodyLoadingVolumes][[All,1]],DetectionAntibodyColumnWashBuffer,{}]];

    (* Depending on the type of spin column used, we need to get different volumes of the wash buffer by default. - Get the purification column model *)
	uniqueCaptureAntibodyPurificationColumns=Lookup[Keys[uniqueRequiredCaptureAntibodyLoadingVolumes][[All,1]],CaptureAntibodyPurificationColumn,{}];
	uniqueDetectionAntibodyPurificationColumns=Lookup[Keys[uniqueRequiredDetectionAntibodyLoadingVolumes][[All,1]],DetectionAntibodyPurificationColumn,{}];

	(* First get the packets of the purification columns *)
	uniqueCaptureAntibodyPurificationColumnPackets=Experiment`Private`fetchPacketFromFastAssoc[#,inheritedFastAssoc]&/@uniqueCaptureAntibodyPurificationColumns;
	uniqueDetectionAntibodyPurificationColumnPackets=Experiment`Private`fetchPacketFromFastAssoc[#,inheritedFastAssoc]&/@uniqueDetectionAntibodyPurificationColumns;

	(* Get the Models of the purification columns *)
	uniqueCaptureAntibodyPurificationColumnModels=Map[
		Which[
			MatchQ[#,Null],Null,
			MatchQ[Lookup[#,Object,Null],ObjectP[Model[Container]]],
			Lookup[#,Object,Null],
			True,
      If[MatchQ[Lookup[#,Container,Null],Null],
        Null,
        Experiment`Private`fastAssocLookup[inheritedFastAssoc,Lookup[#,Object,Null],{Model,Object}]
      ]
		]&,
		uniqueCaptureAntibodyPurificationColumnPackets
	];
	uniqueDetectionAntibodyPurificationColumnModels=Map[
		Which[
			MatchQ[#,Null],Null,
			MatchQ[Lookup[#,Object,Null],ObjectP[Model[Container]]],
			Lookup[#,Object,Null],
			True,
      If[MatchQ[Lookup[#,Container,Null],Null],
        Null,
        Experiment`Private`fastAssocLookup[inheritedFastAssoc,Lookup[#,Object,Null],{Model,Object}]
      ]
		]&,
		uniqueDetectionAntibodyPurificationColumnPackets
	];

	(* Depending on the model of the purification column, get different amounts of wash buffers *)
    allAntibodyColumnWashBufferVolumes=Map[
        Times[
			If[NullQ[#],
				0Microliter,
				Lookup[
					Experiment`Private`fetchPacketFromFastAssoc[#,inheritedFastAssoc],
					MaxVolume,
					0Microliter
				]
			],
			3
		]&,
        Join[uniqueCaptureAntibodyPurificationColumnModels,uniqueDetectionAntibodyPurificationColumnModels]
    ];

    (* Pair the column wash buffers and their volumes *)
    pairedAntibodyColumnWashBuffersAndVolumes=MapThread[
        (#1->#2)&,
        {allAntibodyColumnWashBuffers,allAntibodyColumnWashBufferVolumes}
    ];

    (* Check whether we don't have a column wash buffer, dilution is required and no concentration of antibody can be found in the composition - if that is the case, we need to add PBS - Samples can share the same blank *)

	(* For all antibodies, try to find the initial concentrations *)
	antibodyDilutionInitialConcentrations=MapThread[
		Which[
			(* If conjugation is performed, we must measure concentration by absorbance *)
			MatchQ[#2,True],Null,
			(* Use resuspension concentration if available *)
			MatchQ[#1,GreaterEqualP[0Milligram/Milliliter]],#1,
			(* Convert molar concentration into mass concentration *)
			MatchQ[#1,GreaterEqualP[0Molar]],#1*#4,
			(* Use concentration from the antibody sample's composition *)
			MatchQ[#3,GreaterEqualP[0Milligram/Milliliter]],#3,
			(* Convert molar concentration into mass concentration *)
			MatchQ[#3,GreaterEqualP[0Molar]],#3*#4,
			True,Null
		]&,
		{Join[Lookup[Keys[uniqueRequiredCaptureAntibodyLoadingVolumes][[All,1]],CaptureAntibodyResuspensionConcentration,{}],Lookup[Keys[uniqueRequiredDetectionAntibodyLoadingVolumes][[All,1]],DetectionAntibodyResuspensionConcentration,{}]],Join[Lookup[Keys[uniqueRequiredCaptureAntibodyLoadingVolumes][[All,1]],CaptureAntibodyConjugation,{}],Lookup[Keys[uniqueRequiredDetectionAntibodyLoadingVolumes][[All,1]],DetectionAntibodyConjugation,{}]],Join[Keys[uniqueRequiredCaptureAntibodyLoadingVolumes][[All,6]],Keys[uniqueRequiredDetectionAntibodyLoadingVolumes][[All,6]]],Join[Keys[uniqueRequiredCaptureAntibodyLoadingVolumes][[All,5]],Keys[uniqueRequiredDetectionAntibodyLoadingVolumes][[All,5]]]}
	];

	(* TODO Add this part of resources back if we want to add ReadPlates primitives *)
	(*
	(* We only need to add additional blank when we need to do dilution, no concentration can be found and no wash buffer is available from conjugation process *)
	(* This only happens when a liquid antibody is provided but no concentration is available *)
    missingAntibodyAbsorbanceBlank=MapThread[
		MatchQ[{#1,#2,#3},{True,Null,Null}]&,
		{Join[Lookup[Keys[uniqueRequiredCaptureAntibodyLoadingVolumes][[All,1]],CaptureAntibodyDilution,{}],Lookup[Keys[uniqueRequiredDetectionAntibodyLoadingVolumes][[All,1]],DetectionAntibodyDilution,{}]],Join[Lookup[Keys[uniqueRequiredCaptureAntibodyLoadingVolumes][[All,1]],CaptureAntibodyColumnWashBuffer,{}],Lookup[Keys[uniqueRequiredDetectionAntibodyLoadingVolumes][[All,1]],DetectionAntibodyColumnWashBuffer,{}]],antibodyDilutionInitialConcentrations}
	];

	extraAntibodyAbsorbanceBlank=If[MemberQ[missingAntibodyAbsorbanceBlank,True],
		Model[Sample,StockSolution,"Filtered PBS, Sterile"],
		Null
	];

    (* Pair the extra absorbance blank and the default volume - 200 Microliter - 100 Microliter for capture antibody and 200 Microliter for detection antibody*)
    extraAntibodyAbsorbanceBlanksAndVolumes=If[MemberQ[missingAntibodyAbsorbanceBlank,True],
		{extraAntibodyAbsorbanceBlank->100Microliter},
		{Null->0Microliter}
	];
	*)

	extraAntibodyAbsorbanceBlanksAndVolumes={};

    (* Merge the column wash buffer and absorbance blank volumes together to get the total volume of each buffer's resource *)
    (* Get a list of volume rules, getting rid of any rules with the pattern Null->__ or __->0Microliter *)
    bufferVolumeRules=DeleteCases[
        KeyDrop[
            Merge[Join[pairedAntibodyColumnWashBuffersAndVolumes,extraAntibodyAbsorbanceBlanksAndVolumes],Total],
            Null
        ],
        0Microliter
    ];

    (* Use the volume rules association to make resources for each unique Object or Model. Transfer into a Hamilton liquid handler compatible container *)
	(* TODO Get more buffer when absorbance blanks are required *)
	(* For each wash buffer, add 200 Microliter for absorbance blank - one for capture antibody and one for detection antibody *)
    uniqueBufferResources=KeyValueMap[
        Module[{amount,containers},
            amount=#2;
			containers=PreferredContainer[(amount+100Microliter)];
			Link[Resource[Sample->#1,Name->ToString[Unique[]],Amount->(amount+100Microliter),Container->containers]]
        ]&,
        bufferVolumeRules
    ];

    (* Construct a list of replace rules to point from the buffer object to its resource *)
    uniqueBufferObjects=Keys[bufferVolumeRules];
    uniqueBufferReplaceRules=MapThread[
        (#1->#2)&,
        {uniqueBufferObjects,uniqueBufferResources}
    ];

    (* Use the buffer object replace rules to make lists of the resources of the column wash buffer options *)
    {
        captureAntibodyColumnWashBufferResources,standardCaptureAntibodyColumnWashBufferResources,detectionAntibodyColumnWashBufferResources,standardDetectionAntibodyColumnWashBufferResources
    }=Map[
        Replace[#,uniqueBufferReplaceRules,{1}]&,
        {captureAntibodyColumnWashBuffer,ToList[standardCaptureAntibodyColumnWashBuffer],detectionAntibodyColumnWashBuffer,ToList[standardDetectionAntibodyColumnWashBuffer]}
    ];

	(*
	(* Prepare the resource for absorbance blanks *)
	(* The absorbance blank may be populated for the cases that dilution is required but we get the initial concentration from the composition of the sample - It will not cause issues *)
	{
		captureAntibodyAbsorbanceBlank,standardCaptureAntibodyAbsorbanceBlank,detectionAntibodyAbsorbanceBlank,standardDetectionAntibodyAbsorbanceBlank
	}=MapThread[
		Which[
			NullQ[#1],Null,
			NullQ[#2],Model[Sample,StockSolution,"Filtered PBS, Sterile"],
			True,#2
		]&,
		{{captureAntibodyDilution,ToList[standardCaptureAntibodyDilution],detectionAntibodyDilution,ToList[standardDetectionAntibodyDilution]},{captureAntibodyColumnWashBuffer,ToList[standardCaptureAntibodyColumnWashBuffer],detectionAntibodyColumnWashBuffer,ToList[standardDetectionAntibodyColumnWashBuffer]}},
		2
	];

	(* Use the buffer object replace rules to make lists of the resources of the absorbance blank options *)
	{
		captureAntibodyAbsorbanceBlankResources,standardCaptureAntibodyAbsorbanceBlankResources,detectionAntibodyAbsorbanceBlankResources,standardDetectionAntibodyAbsorbanceBlankResources
	}=Map[
		Replace[#,uniqueBufferReplaceRules,{1}]&,
		{captureAntibodyAbsorbanceBlank,ToList[standardCaptureAntibodyAbsorbanceBlank],detectionAntibodyAbsorbanceBlank,ToList[standardDetectionAntibodyAbsorbanceBlank]}
	];
	*)

    (* -- Generate resources for the WashBuffer *)
    (* Decide the amount of WashBuffer required based on the cartridge type *)
    requiredWashBufferVolume=Which[
        MatchQ[cartridgeType,MultiAnalyte16X4],8Milliliter,
		MatchQ[cartridgeType,SinglePlex72X1],10Milliliter,
        MatchQ[cartridgeType,MultiAnalyte32X4|MultiPlex32X8],16Milliliter,
        MatchQ[cartridgeType,Customizable],6Milliliter
    ];

    (* Make resource for wash buffer. Always transfer the wash buffer into 50 mL tube, which is liquid handler compatible *)
    washBufferResource=Link[Resource[Sample->Lookup[optionsWithReplicates,WashBuffer],Name->ToString[Unique[]],Amount->(requiredWashBufferVolume+0.5Milliliter),Container->PreferredContainer[requiredWashBufferVolume+0.5Milliliter]]];


    (* -- Generate resources for the Containers *)
    (* SpikeContainer and DilutionContainer *)
    (* We allow grouping of different samples into the same container based on the indices. *)
	(* SpikeContainer *)
	(* ExperimentCapillaryELISA only allows up to 72 samples - one SpikeContainer of 96-well is enough *)
	spikeContainer=If[MemberQ[spikeSample,Except[Null]],
		PreferredContainer[0Microliter,Type->Plate],
		Null
	];

	spikeContainerResource=If[NullQ[spikeContainer],
		Null,
		Link[Resource[Sample->spikeContainer,Name->ToString[Unique[]]]]
	];

	(* DilutionContainer *)
	(* ExperimentCapillaryELISA only allows up to 72 samples - one SpikeContainer of 96-well is enough for all samples and standard samples - Pick one plate as our resrouce *)
	dilutionContainer=PreferredContainer[0Microliter,Type->Plate];

	dilutionContainerResource=Link[Resource[Sample->dilutionContainer,Name->ToString[Unique[]]]];

    (* Antibody Preparation Related Containers *)
    (* The antibody preparation containers are all in the uniqueRequiredCaptureAntibodyLoadingVolumes and uniqueRequiredDetectionAntibodyLoadingVolumes *)
    (* StandardCaptureAntibodyConjugationContainer, StandardCaptureAntibodyPurificationColumn, StandardDetectionAntibodyConjugationContainer, StandardDetectionAntibodyPurificationColumn, CaptureAntibodyConjugationContainer, CaptureAntibodyPurificationColumn, DetectionAntibodyConjugationContainer, DetectionAntibodyPurificationColumn *)
    (* These options will not group together and don't need other resources. We just need to get the information from our options and prepare unique resources. *)
    {
		uniqueCaptureAntibodyConjugationContainers, uniqueDetectionAntibodyConjugationContainers
    }={
        Lookup[Keys[uniqueRequiredCaptureAntibodyLoadingVolumes][[All,1]],CaptureAntibodyConjugationContainer,{}],
		Lookup[Keys[uniqueRequiredDetectionAntibodyLoadingVolumes][[All,1]],DetectionAntibodyConjugationContainer,{}]
    };

    (* Create Resources for these containers *)
    {
        uniqueCaptureAntibodyConjugationContainerResources,uniqueDetectionAntibodyConjugationContainerResources,uniqueCaptureAntibodyPurificationColumnResources,uniqueDetectionAntibodyPurificationColumnResources
    }=Map[
        If[MatchQ[#,Null],
			Null,
			Link[Resource[Sample->#,Name->ToString[Unique[]]]]
		]&,
        {uniqueCaptureAntibodyConjugationContainers,uniqueDetectionAntibodyConjugationContainers,uniqueCaptureAntibodyPurificationColumns,uniqueDetectionAntibodyPurificationColumns},
        {2}
    ];

	(* Replace the containers to with their resources *)
	(* Get the replace rule - from the list of options to their resources *)
	uniqueCaptureAntibodyConjugationContainerReplaceRules=MapThread[
		(Values[#1]->#2)&,
		{Keys[uniqueRequiredCaptureAntibodyLoadingVolumes][[All,1]],uniqueCaptureAntibodyConjugationContainerResources}
	];

	uniqueDetectionAntibodyConjugationContainerReplaceRules=MapThread[
		(Values[#1]->#2)&,
		{Keys[uniqueRequiredDetectionAntibodyLoadingVolumes][[All,1]],uniqueDetectionAntibodyConjugationContainerResources}
	];

	uniqueCaptureAntibodyPurificationColumnReplaceRules=MapThread[
		(Values[#1]->#2)&,
		{Keys[uniqueRequiredCaptureAntibodyLoadingVolumes][[All,1]],uniqueCaptureAntibodyPurificationColumnResources}
	];

	uniqueDetectionAntibodyPurificationColumnReplaceRules=MapThread[
		(Values[#1]->#2)&,
		{Keys[uniqueRequiredDetectionAntibodyLoadingVolumes][[All,1]],uniqueDetectionAntibodyPurificationColumnResources}
	];

	(* Use the replace rule to get the resources *)
	{
		captureAntibodyConjugationContainerResources,standardCaptureAntibodyConjugationContainerResources
	}=If[customizableCartridgeQ,
		Map[
			Replace[#,uniqueCaptureAntibodyConjugationContainerReplaceRules,{1}]&,
			{captureAntibodyOptions,standardCaptureAntibodyOptions}
		],
		{{},{}}
	];

	{
		detectionAntibodyConjugationContainerResources,standardDetectionAntibodyConjugationContainerResources
	}=If[customizableCartridgeQ,
		Map[
			Replace[#,uniqueDetectionAntibodyConjugationContainerReplaceRules,{1}]&,
			{detectionAntibodyOptions,standardDetectionAntibodyOptions}
		],
		{{},{}}
	];

	{
		captureAntibodyPurificationColumnResources,standardCaptureAntibodyPurificationColumnResources
	}=If[customizableCartridgeQ,
		Map[
			Replace[#,uniqueCaptureAntibodyPurificationColumnReplaceRules,{1}]&,
			{captureAntibodyOptions,standardCaptureAntibodyOptions}
		],
		{{},{}}
	];

	{
		detectionAntibodyPurificationColumnResources,standardDetectionAntibodyPurificationColumnResources
	}=If[customizableCartridgeQ,
		Map[
			Replace[#,uniqueDetectionAntibodyPurificationColumnReplaceRules,{1}]&,
			{detectionAntibodyOptions,standardDetectionAntibodyOptions}
		],
		{{},{}}
	];


	(* Get the dilution containers *)
	(* The only requirement for dilution container is that it is in a Hamilton compatible container - Select the first one from the list *)
	{uniqueCaptureAntibodyDilutionContainers,uniqueDetectionAntibodyDilutionContainers}=Map[
        PreferredContainer[(#+100Microliter)]&,
		{Values[uniqueRequiredCaptureAntibodyLoadingVolumes][[All,2]],Values[uniqueRequiredDetectionAntibodyLoadingVolumes][[All,2]]},
		{2}
	];

	uniqueCaptureAntibodyDilutionContainerResources=Map[
		If[NullQ[#],
			Null,
			Link[Resource[Sample->#,Name->ToString[Unique[]]]]
		]&,
		uniqueCaptureAntibodyDilutionContainers
	];
	uniqueDetectionAntibodyDilutionContainerResources=Map[
		If[NullQ[#],
			Null,
			Link[Resource[Sample->#,Name->ToString[Unique[]]]]
		]&,
		uniqueDetectionAntibodyDilutionContainers
	];

	uniqueCaptureAntibodyDilutionContainerReplaceRules=MapThread[
		(Values[#1]->#2)&,
		{Keys[uniqueRequiredCaptureAntibodyLoadingVolumes][[All,1]],uniqueCaptureAntibodyDilutionContainerResources}
	];

	uniqueDetectionAntibodyDilutionContainerReplaceRules=MapThread[
		(Values[#1]->#2)&,
		{Keys[uniqueRequiredDetectionAntibodyLoadingVolumes][[All,1]],uniqueDetectionAntibodyDilutionContainerResources}
	];

	{
		captureAntibodyDilutionContainerResources,standardCaptureAntibodyDilutionContainerResources
	}=If[customizableCartridgeQ,
		Map[
			Replace[#,uniqueCaptureAntibodyDilutionContainerReplaceRules,{1}]&,
			{captureAntibodyOptions,standardCaptureAntibodyOptions}
		],
		{{},{}}
	];

	{
		detectionAntibodyDilutionContainerResources,standardDetectionAntibodyDilutionContainerResources
	}=If[customizableCartridgeQ,
		Map[
			Replace[#,uniqueDetectionAntibodyDilutionContainerReplaceRules,{1}]&,
			{detectionAntibodyOptions,standardDetectionAntibodyOptions}
		],
		{{},{}}
	];

	(* Get the wash container, collection vial and waste container for the spin column *)
  uniqueCaptureAntibodyPurificationColumnCollectionVials=(Experiment`Private`fastAssocLookup[inheritedFastAssoc,#,{DestinationContainerModel,Object}])&/@uniqueCaptureAntibodyPurificationColumnModels;
  uniqueDetectionAntibodyPurificationColumnCollectionVials=(Experiment`Private`fastAssocLookup[inheritedFastAssoc,#,{DestinationContainerModel,Object}])&/@uniqueDetectionAntibodyPurificationColumnModels;

  uniqueCaptureAntibodyPurificationColumnWashContainers=(Experiment`Private`fastAssocLookup[inheritedFastAssoc,#,{DestinationContainerModel,Object}])&/@uniqueCaptureAntibodyPurificationColumnModels;
  uniqueDetectionAntibodyPurificationColumnWashContainers=(Experiment`Private`fastAssocLookup[inheritedFastAssoc,#,{DestinationContainerModel,Object}])&/@uniqueDetectionAntibodyPurificationColumnModels;
	(* Create the resources for these containers *)
	uniqueCaptureAntibodyPurificationColumnCollectionVialResources=Map[
		If[MatchQ[#,Null|$Failed],
			Null,
			Link[Resource[Sample->#,Name->ToString[Unique[]]]]
		]&,
		uniqueCaptureAntibodyPurificationColumnCollectionVials
	];
	uniqueDetectionAntibodyPurificationColumnCollectionVialResources=Map[
		If[MatchQ[#,Null|$Failed],
			Null,
			Link[Resource[Sample->#,Name->ToString[Unique[]]]]
		]&,
		uniqueDetectionAntibodyPurificationColumnCollectionVials
	];

	uniqueCaptureAntibodyPurificationColumnWashContainerResources=Map[
		If[MatchQ[#,Null|$Failed],
			Null,
			Link[Resource[Sample->#,Name->ToString[Unique[]]]]
		]&,
		uniqueCaptureAntibodyPurificationColumnWashContainers
	];
	uniqueDetectionAntibodyPurificationColumnWashContainerResources=Map[
		If[MatchQ[#,Null|$Failed],
			Null,
			Link[Resource[Sample->#,Name->ToString[Unique[]]]]
		]&,
		uniqueDetectionAntibodyPurificationColumnWashContainers
	];


	(* We also need waste containers to hold the waste temporarily before end of the protocol. For 0.5 mL spin column, a total of 1.2 mL waste buffers is generated per sample. For 2 mL/5 mL spin column, 4 mL/ 10 mL is generated. A 2 mL Tube or 50 mL Tube is selected as they are Hamilton compatible *)
	uniqueCaptureAntibodyPurificationWasteContainers=Map[
		Module[
			{packet,singleWasteVolume,totalWasteVolume,preferredContainer},
			packet=If[NullQ[#],
				<||>,
				Experiment`Private`fetchPacketFromFastAssoc[#,inheritedFastAssoc]
			];
			singleWasteVolume=Lookup[packet,MaxVolume,0Microliter];
			totalWasteVolume=singleWasteVolume*3;
			preferredContainer=If[MatchQ[#,Null],
				Null,
				PreferredContainer[totalWasteVolume]
			]
		]&,
		uniqueCaptureAntibodyPurificationColumnModels
	];
	uniqueDetectionAntibodyPurificationWasteContainers=Map[
		Module[
			{packet,singleWasteVolume,totalWasteVolume,preferredContainer},
			packet=If[NullQ[#],
				<||>,
				Experiment`Private`fetchPacketFromFastAssoc[#,inheritedFastAssoc]
			];
			singleWasteVolume=Lookup[packet,MaxVolume,0Microliter];
			totalWasteVolume=singleWasteVolume*3;
			preferredContainer=If[MatchQ[#,Null],
				Null,
				PreferredContainer[totalWasteVolume]
			]
		]&,
		uniqueDetectionAntibodyPurificationColumnModels
	];

	uniqueCaptureAntibodyPurificationWasteContainerResources=Map[
		If[NullQ[#],
			Null,
			Link[Resource[Sample->#,Name->ToString[Unique[]]]]
		]&,
		uniqueCaptureAntibodyPurificationWasteContainers
	];
	uniqueDetectionAntibodyPurificationWasteContainerResources=Map[
		If[NullQ[#],
			Null,
			Link[Resource[Sample->#,Name->ToString[Unique[]]]]
		]&,
		uniqueDetectionAntibodyPurificationWasteContainers
	];


	(* Replace the containers to with their resources *)
	(* Get the replace rule - from the list of options to their resources *)
	uniqueCaptureAntibodyPurificationColumnCollectionVialReplaceRules=MapThread[
		(Values[#1]->#2)&,
		{Keys[uniqueRequiredCaptureAntibodyLoadingVolumes][[All,1]],uniqueCaptureAntibodyPurificationColumnCollectionVialResources}
	];

	uniqueDetectionAntibodyPurificationColumnCollectionVialReplaceRules=MapThread[
		(Values[#1]->#2)&,
		{Keys[uniqueRequiredDetectionAntibodyLoadingVolumes][[All,1]],uniqueDetectionAntibodyPurificationColumnCollectionVialResources}
	];

	uniqueCaptureAntibodyPurificationColumnWashContainerReplaceRules=MapThread[
		(Values[#1]->#2)&,
		{Keys[uniqueRequiredCaptureAntibodyLoadingVolumes][[All,1]],uniqueCaptureAntibodyPurificationColumnWashContainerResources}
	];

	uniqueDetectionAntibodyPurificationColumnWashContainerReplaceRules=MapThread[
		(Values[#1]->#2)&,
		{Keys[uniqueRequiredDetectionAntibodyLoadingVolumes][[All,1]],uniqueDetectionAntibodyPurificationColumnWashContainerResources}
	];

	uniqueCaptureAntibodyPurificationWasteContainerReplaceRules=MapThread[
		(Values[#1]->#2)&,
		{Keys[uniqueRequiredCaptureAntibodyLoadingVolumes][[All,1]],uniqueCaptureAntibodyPurificationWasteContainerResources}
	];

	uniqueDetectionAntibodyPurificationWasteContainerReplaceRules=MapThread[
		(Values[#1]->#2)&,
		{Keys[uniqueRequiredDetectionAntibodyLoadingVolumes][[All,1]],uniqueDetectionAntibodyPurificationWasteContainerResources}
	];

	(* Use the replace rule to get the resources *)
	{
		captureAntibodyPurificationColumnCollectionVialResources,standardCaptureAntibodyPurificationColumnCollectionVialResources
	}=If[customizableCartridgeQ,
		Map[
			Replace[#,uniqueCaptureAntibodyPurificationColumnCollectionVialReplaceRules,{1}]&,
			{captureAntibodyOptions,standardCaptureAntibodyOptions}
		],
		{{},{}}
	];

	{
		detectionAntibodyPurificationColumnCollectionVialResources,standardDetectionAntibodyPurificationColumnCollectionVialResources
	}=If[customizableCartridgeQ,
		Map[
			Replace[#,uniqueDetectionAntibodyPurificationColumnCollectionVialReplaceRules,{1}]&,
			{detectionAntibodyOptions,standardDetectionAntibodyOptions}
		],
		{{},{}}
	];

	{
		captureAntibodyPurificationColumnWashContainerResources,standardCaptureAntibodyPurificationColumnWashContainerResources
	}=If[customizableCartridgeQ,
		Map[
			Replace[#,uniqueCaptureAntibodyPurificationColumnWashContainerReplaceRules,{1}]&,
			{captureAntibodyOptions,standardCaptureAntibodyOptions}
		],
		{{},{}}
	];

	{
		detectionAntibodyPurificationColumnWashContainerResources,standardDetectionAntibodyPurificationColumnWashContainerResources
	}=If[customizableCartridgeQ,
		Map[
			Replace[#,uniqueDetectionAntibodyPurificationColumnWashContainerReplaceRules,{1}]&,
			{detectionAntibodyOptions,standardDetectionAntibodyOptions}
		],
		{{},{}}
	];

	{
		captureAntibodyPurificationWasteContainerResources,standardCaptureAntibodyPurificationWasteContainerResources
	}=If[customizableCartridgeQ,
		Map[
			Replace[#,uniqueCaptureAntibodyPurificationWasteContainerReplaceRules,{1}]&,
			{captureAntibodyOptions,standardCaptureAntibodyOptions}
		],
		{{},{}}
	];

	{
		detectionAntibodyPurificationWasteContainerResources,standardDetectionAntibodyPurificationWasteContainerResources
	}=If[customizableCartridgeQ,
		Map[
			Replace[#,uniqueDetectionAntibodyPurificationWasteContainerReplaceRules,{1}]&,
			{detectionAntibodyOptions,standardDetectionAntibodyOptions}
		],
		{{},{}}
	];


	(* No need for abosrbance measurement containers *)
	(* TODO When absorbance measurement is back into the experiment, remember to add Round Bottom Plate into Download list via a non-hard-coded way *)
	(*
	(* AbsorbanceMeasurementContainer *)
    (* Only 2 96-well plates - one for capture antibody and one for detection antibody - is required for any absorbance measurement as up to 48 samples can be tested in one protocol - Blanks take up the wells of container too *)
    captureAntibodyAbsorbanceContainer=If[MemberQ[Join[captureAntibodyDilution,standardCaptureAntibodyDilution],True],
		Model[Container,Plate,"96-well Round Bottom Plate"],
		Null
	];

	detectionAntibodyAbsorbanceContainer=If[MemberQ[Join[detectionAntibodyDilution,standardDetectionAntibodyDilution],True],
		Model[Container,Plate,"96-well Round Bottom Plate"],
		Null
	];

	captureAntibodyAbsorbanceContainerResource=If[NullQ[captureAntibodyAbsorbanceContainer],
		Null,
		Link[Resource[Sample->captureAntibodyAbsorbanceContainer,Name->ToString[Unique[]]]]
	];

	detectionAntibodyAbsorbanceContainerResource=If[NullQ[detectionAntibodyAbsorbanceContainer],
		Null,
		Link[Resource[Sample->detectionAntibodyAbsorbanceContainer,Name->ToString[Unique[]]]]
	];
	*)


    (* -- Generate resource for the instrument -- *)
    (* Make the capillary ELISA instrument resource *)
    (* Template Note: The time in instrument resources is used to charge customers for the instrument time so it's important that this estimate is accurate. This will probably look like set-up time + time/sample + tear-down time *)
    (* Set-up time for the instrument is approximately 15 Minute for the operator to scan the cartridge, import the method file, set up the data file path, etc. The run time is usually 75-80 minutes, which varies from case to case. We make it 90 minutes here to be safe. The tear-down is another 15 Minute to export the data file and dispose the cartridge. *)
    instrument=Lookup[optionsWithReplicates,Instrument];
    instrumentResource=Link[Resource[Instrument->instrument,Time->2.5Hour]];

    (* Note that all the other instruments are resource picked in the Procedure. These instruments include centrifuge instruments, incubation instruments (vortex, shaker, roller, heat block), absorbance intensity measurement plate reader instruments. *)


    (* -- Gather the information for protocol fields -- *)
	(* Try to hide the spike related options when all of them are Null *)
	requiredSpikeResources=If[MemberQ[spikeResources,Except[Null]],
		spikeResources,
		{}
	];

	requiredSpikeVolumes=If[MemberQ[Lookup[optionsWithReplicates,SpikeVolume],Except[Null]],
		Lookup[optionsWithReplicates,SpikeVolume],
		{}
	];

	requiredSpikeSampleStorageCondtion=If[MemberQ[Lookup[optionsWithReplicates,SpikeSampleStorageCondition],Except[Null]],
		Lookup[optionsWithReplicates,SpikeSampleStorageCondition],
		{}
	];

	(* Sample Dilution Options *)
	serialDilutionBooleans=Map[
		!MatchQ[#,Null]&,
		Lookup[optionsWithReplicates,SerialDilutionCurve]
	];

	(* Regular Dilution - including special linear dilutions *)
	dilutionAssayVolumes=Map[
		Which[
			(* Linear dilution *)
			MatchQ[#,{VolumeP,{VolumeP,VolumeP},_Integer}|{VolumeP,{_Real,_Real},_Integer}],First[#],
			(* Only 1 dilution *)
			MatchQ[#,{{VolumeP,VolumeP}}|{{VolumeP,_Real}}],#[[1,1]],
			True,Null
		]&,
		dilutionCurve
	];

	startingDilutionFactors=Map[
		Which[
			(* Linear dilution *)
			MatchQ[#,{VolumeP,{_Real,_Real},_Integer}],#[[2,1]],
			MatchQ[#,{VolumeP,{VolumeP,VolumeP},_Integer}],#[[2,1]]/(#[[1]]),
			(* Only 1 dilution *)
			MatchQ[#,{{VolumeP,_Real}}],#[[1,2]],
			MatchQ[#,{{VolumeP,VolumeP}}],#[[1,1]]/(#[[1,1]]+#[[1,2]]),
			True,Null
		]&,
		dilutionCurve
	];

	dilutionFactorIncrements=Map[
		Which[
			(* Linear dilution *)
			MatchQ[#,{VolumeP,{_Real,_Real},_Integer}],#[[2,2]],
			MatchQ[#,{VolumeP,{VolumeP,VolumeP},_Integer}],#[[2,2]]/(#[[1]]),
			(* Only 1 dilution *)
			MatchQ[#,{{VolumeP,_Real}}],#[[1,2]],
			MatchQ[#,{{VolumeP,VolumeP}}],#[[1,1]]/(#[[1,1]]+#[[1,2]]),
			True,Null
		]&,
		dilutionCurve
	];

	numberOfDilutions=Map[
		Which[
			(* Linear dilution *)
			MatchQ[#,{VolumeP,{VolumeP,VolumeP},_Integer}|{VolumeP,{_Real,_Real},_Integer}],Last[#],
			(* Only 1 dilution *)
			MatchQ[#,{{VolumeP,_Real}}|{{VolumeP,VolumeP}}],1,
			True,Null
		]&,
		dilutionCurve
	];

    (* Convert the dilution curve options into volumes to fit in the pattern of DilutionCurve in protocol object *)
	requiredDilutionCurves=Map[
		Function[
			{dilution},
			Which[
				MatchQ[dilution,{VolumeP,{VolumeP,VolumeP},_Integer}],
				Array[{dilution[[2,1]]+dilution[[2,2]]*(#-1),dilution[[1]]-dilution[[2,1]]-dilution[[2,2]]*(#-1)}&,Last[dilution]],
				MatchQ[dilution,{VolumeP,{_Real,_Real},_Integer}],
				Array[dilution[[1]]*{dilution[[2,1]]+dilution[[2,2]]*(#-1),1-dilution[[2,1]]-dilution[[2,2]]*(#-1)}&,Last[dilution]],
				MatchQ[dilution,{{VolumeP,_Real}..}],
				Map[{#[[1]]*#[[2]],#[[1]]*(1-#[[2]])}&,dilution],
				True,
				dilution
			]
		],
		dilutionCurve
	];

	(* Serial Dilution *)
	serialDilutionAssayVolumes=Map[
		Which[
			MatchQ[#,{VolumeP,VolumeP,_Integer}],#[[1]]+#[[2]],
			MatchQ[#,{VolumeP,{_Real,_Integer}}],#[[1]],
			True,Null
		]&,
		serialDilutionCurve
	];

	serialDilutionFactors=Map[
		Which[
			MatchQ[#,{VolumeP,VolumeP,_Integer}],#[[1]]/(#[[1]]+#[[2]]),
			MatchQ[#,{VolumeP,{_Real,_Integer}}],#[[2,1]],
			True,Null
		]&,
		serialDilutionCurve
	];

	numberOfSerialDilutions=Map[
		Which[
			MatchQ[#,{VolumeP,VolumeP,_Integer}],Last[#],
			MatchQ[#,{VolumeP,{_Real,_Integer}}],#[[2,2]],
			True,Null
		]&,
		serialDilutionCurve
	];

	(* Convert the dilution curve options into volumes to fit in the pattern of DilutionCurve in protocol object *)
	requiredSerialDilutionCurves=Map[
		Function[
			{serialDilution},
			Which[
				MatchQ[serialDilution,{VolumeP,VolumeP,_Integer}],ConstantArray[Most[serialDilution],Last[serialDilution]],
				MatchQ[serialDilution,{VolumeP,{_Real,_Integer}}|{VolumeP,{_Real..}}],serialDilutionCurveVolumesforCapillaryELISA[serialDilution],
				True,Null
			]
		],
		serialDilutionCurve
	];

	(* Standard Options *)
	standardResuspensions=If[!MatchQ[standard,{}|Null],
		Lookup[optionsWithReplicates,StandardResuspension],
		{}
	];

	standardResuspensionConcentrations=If[MemberQ[ToList[Lookup[optionsWithReplicates,StandardResuspensionConcentration]],Except[Null]],
		Lookup[optionsWithReplicates,StandardResuspensionConcentration],
		{}
	];

	standardResuspensionDiluents=If[MemberQ[ToList[Lookup[optionsWithReplicates,StandardResuspension]],True],
		Map[
			If[MatchQ[#,ObjectP[{Model[Sample],Object[Sample]}]],
				Link[Download[#,Object]],
				#
			]&,
			Lookup[optionsWithReplicates,StandardResuspensionDiluent]
		],
		{}
	];

	standardStorageConditions=If[MemberQ[ToList[Lookup[optionsWithReplicates,StandardResuspension]],Except[Null]],
		Lookup[optionsWithReplicates,StandardStorageCondition],
		{}
	];

	(* Standard Dilution Options *)
	standardSerialDilutionBooleans=Map[
		!MatchQ[#,Null]&,
		Lookup[optionsWithReplicates,StandardSerialDilutionCurve]
	];

	(* Regular Dilution - including special linear dilutions *)
	standardDilutionAssayVolumes=Map[
		Which[
			(* Linear dilution *)
			MatchQ[#,{VolumeP,{VolumeP,VolumeP},_Integer}|{VolumeP,{_Real,_Real},_Integer}],First[#],
			(* Only 1 dilution *)
			MatchQ[#,{{VolumeP,VolumeP}}|{{VolumeP,_Real}}],#[[1,1]],
			True,Null
		]&,
		standardDilutionCurve
	];

	standardStartingDilutionFactors=Map[
		Which[
			(* Linear dilution *)
			MatchQ[#,{VolumeP,{_Real,_Real},_Integer}],#[[2,1]],
			MatchQ[#,{VolumeP,{VolumeP,VolumeP},_Integer}],#[[2,1]]/(#[[1]]),
			(* Only 1 dilution *)
			MatchQ[#,{{VolumeP,_Real}}],#[[1,2]],
			MatchQ[#,{{VolumeP,VolumeP}}],#[[1,1]]/(#[[1,1]]+#[[1,2]]),
			True,Null
		]&,
		standardDilutionCurve
	];

	standardDilutionFactorIncrements=Map[
		Which[
			(* Linear dilution *)
			MatchQ[#,{VolumeP,{_Real,_Real},_Integer}],#[[2,2]],
			MatchQ[#,{VolumeP,{VolumeP,VolumeP},_Integer}],#[[2,2]]/(#[[1]]),
			(* Only 1 dilution *)
			MatchQ[#,{{VolumeP,_Real}}],#[[1,2]],
			MatchQ[#,{{VolumeP,VolumeP}}],#[[1,1]]/(#[[1,1]]+#[[1,2]]),
			True,Null
		]&,
		standardDilutionCurve
	];

	standardNumberOfDilutions=Map[
		Which[
			(* Linear dilution *)
			MatchQ[#,{VolumeP,{VolumeP,VolumeP},_Integer}|{VolumeP,{_Real,_Real},_Integer}],Last[#],
			(* Only 1 dilution *)
			MatchQ[#,{{VolumeP,_Real}}|{{VolumeP,VolumeP}}],1,
			True,Null
		]&,
		standardDilutionCurve
	];

	(* Convert the dilution curve options into volumes to fit in the pattern of StandardDilutionCurves in protocol object *)
	requiredStandardDilutionCurves=Map[
		Function[
			{dilution},
			Which[
				MatchQ[dilution,{VolumeP,{VolumeP,VolumeP},_Integer}],
				Array[{dilution[[2,1]]+dilution[[2,2]]*(#-1),dilution[[1]]-dilution[[2,1]]-dilution[[2,2]]*(#-1)}&,Last[dilution]],
				MatchQ[dilution,{VolumeP,{_Real,_Real},_Integer}],
				Array[dilution[[1]]*{dilution[[2,1]]+dilution[[2,2]]*(#-1),1-dilution[[2,1]]-dilution[[2,2]]*(#-1)}&,Last[dilution]],
				MatchQ[dilution,{{VolumeP,_Real}..}],
				Map[{#[[1]]*#[[2]],#[[1]]*(1-#[[2]])}&,dilution],
				True,
				dilution
			]
		],
		standardDilutionCurve
	];

	(* Serial Dilution *)
	standardSerialDilutionAssayVolumes=Map[
		Which[
			MatchQ[#,{VolumeP,VolumeP,_Integer}],#[[1]]+#[[2]],
			MatchQ[#,{VolumeP,{_Real,_Integer}}],#[[1]],
			True,Null
		]&,
		standardSerialDilutionCurve
	];

	standardSerialDilutionFactors=Map[
		Which[
			MatchQ[#,{VolumeP,VolumeP,_Integer}],#[[1]]/(#[[1]]+#[[2]]),
			MatchQ[#,{VolumeP,{_Real,_Integer}}],#[[2,1]],
			True,Null
		]&,
		standardSerialDilutionCurve
	];

	numberOfStandardSerialDilutions=Map[
		Which[
			MatchQ[#,{VolumeP,VolumeP,_Integer}],Last[#],
			MatchQ[#,{VolumeP,{_Real,_Integer}}],#[[2,2]],
			True,Null
		]&,
		standardSerialDilutionCurve
	];

	(* Convert the dilution curve options into volumes to fit in the pattern of DilutionCurve in protocol object *)
	requiredStandardSerialDilutionCurves=Map[
		Function[
			{serialDilution},
			Which[
				MatchQ[serialDilution,{VolumeP,VolumeP,_Integer}],ConstantArray[Most[serialDilution],Last[serialDilution]],
				MatchQ[serialDilution,{VolumeP,{_Real,_Integer}}|{VolumeP,{_Real..}}],serialDilutionCurveVolumesforCapillaryELISA[serialDilution],
				True,Null
			]
		],
		standardSerialDilutionCurve
	];

	(* Other Dilution Related Options *)
	requiredStandardDiluents=If[MatchQ[standard,{}|Null],
		{},
		standardDiluentResources
	];

	standardDilutionMixVolumes=If[MatchQ[standard,{}|Null],
		{},
		Lookup[optionsWithReplicates,StandardDilutionMixVolume]
	];

	standardDilutionNumberOfMixes=If[MatchQ[standard,{}|Null],
		{},
		Lookup[optionsWithReplicates,StandardDilutionNumberOfMixes]
	];

	standardDilutionMixRates=If[MatchQ[standard,{}|Null],
		{},
		Lookup[optionsWithReplicates,StandardDilutionMixRate]
	];

	(* Antibody Options for standard samples *)
	requiredStandardCaptureAntibodies=If[MatchQ[standard,{}|Null],
		{},
		standardCaptureAntibodyResources
	];

	requiredStandardDetectionAntibodies=If[MatchQ[standard,{}|Null],
		{},
		standardDetectionAntibodyResources
	];

	(* Antibody Options *)
	(* Antibody Resuspension Options *)
	captureAntibodyResuspensions=If[customizableCartridgeQ,
		Lookup[optionsWithReplicates,CaptureAntibodyResuspension],
		{}
	];

	captureAntibodyResuspensionConcentrations=If[MemberQ[Lookup[optionsWithReplicates,CaptureAntibodyResuspension],True],
		Lookup[optionsWithReplicates,CaptureAntibodyResuspensionConcentration],
		{}
	];

	captureAntibodyResuspensionDiluents=If[MemberQ[Lookup[optionsWithReplicates,CaptureAntibodyResuspension],True],
		Map[
			If[MatchQ[#,ObjectP[{Model[Sample],Object[Sample]}]],
				Link[Download[#,Object]],
				#
			]&,
			Lookup[optionsWithReplicates,CaptureAntibodyResuspensionDiluent]
		],
		{}
	];

	captureAntibodyStorageConditions=If[MemberQ[Lookup[optionsWithReplicates,CaptureAntibodyResuspension],True],
		Lookup[optionsWithReplicates,CaptureAntibodyStorageCondition],
		{}
	];

	detectionAntibodyResuspensions=If[customizableCartridgeQ,
		Lookup[optionsWithReplicates,DetectionAntibodyResuspension],
		{}
	];

	detectionAntibodyResuspensionConcentrations=If[MemberQ[Lookup[optionsWithReplicates,DetectionAntibodyResuspension],True],
		Lookup[optionsWithReplicates,DetectionAntibodyResuspensionConcentration],
		{}
	];

	detectionAntibodyResuspensionDiluents=If[MemberQ[Lookup[optionsWithReplicates,DetectionAntibodyResuspension],True],
		Map[
			If[MatchQ[#,ObjectP[{Model[Sample],Object[Sample]}]],
				Link[Download[#,Object]],
				#
			]&,
			Lookup[optionsWithReplicates,DetectionAntibodyResuspensionDiluent]
		],
		{}
	];

	detectionAntibodyStorageConditions=If[MemberQ[Lookup[optionsWithReplicates,DetectionAntibodyResuspension],True],
		Lookup[optionsWithReplicates,DetectionAntibodyStorageCondition],
		{}
	];

	standardCaptureAntibodyResuspensions=If[customizableCartridgeQ&&!MatchQ[standard,{}|Null],
		Lookup[optionsWithReplicates,StandardCaptureAntibodyResuspension],
		{}
	];

	standardCaptureAntibodyResuspensionConcentrations=If[MemberQ[ToList[Lookup[optionsWithReplicates,StandardCaptureAntibodyResuspension]],True],
		Lookup[optionsWithReplicates,StandardCaptureAntibodyResuspensionConcentration],
		{}
	];

	standardCaptureAntibodyResuspensionDiluents=If[MemberQ[ToList[Lookup[optionsWithReplicates,StandardCaptureAntibodyResuspension]],True],
		Map[
			If[MatchQ[#,ObjectP[{Model[Sample],Object[Sample]}]],
				Link[Download[#,Object]],
				#
			]&,
			Lookup[optionsWithReplicates,StandardCaptureAntibodyResuspensionDiluent]
		],
		{}
	];

	standardCaptureAntibodyStorageConditions=If[MemberQ[ToList[Lookup[optionsWithReplicates,StandardCaptureAntibodyResuspension]],True],
		Lookup[optionsWithReplicates,StandardCaptureAntibodyStorageCondition],
		{}
	];

	standardDetectionAntibodyResuspensions=If[customizableCartridgeQ&&!MatchQ[standard,{}|Null],
		Lookup[optionsWithReplicates,StandardDetectionAntibodyResuspension],
		{}
	];

	standardDetectionAntibodyResuspensionConcentrations=If[MemberQ[ToList[Lookup[optionsWithReplicates,StandardDetectionAntibodyResuspension]],True],
		Lookup[optionsWithReplicates,StandardDetectionAntibodyResuspensionConcentration],
		{}
	];

	standardDetectionAntibodyResuspensionDiluents=If[MemberQ[ToList[Lookup[optionsWithReplicates,StandardDetectionAntibodyResuspension]],True],
		Map[
			If[MatchQ[#,ObjectP[{Model[Sample],Object[Sample]}]],
				Link[Download[#,Object]],
				#
			]&,
			Lookup[optionsWithReplicates,StandardDetectionAntibodyResuspensionDiluent]
		],
		{}
	];

	standardDetectionAntibodyStorageConditions=If[MemberQ[ToList[Lookup[optionsWithReplicates,StandardDetectionAntibodyResuspension]],True],
		Lookup[optionsWithReplicates,StandardDetectionAntibodyStorageCondition],
		{}
	];

	(* Antibody Conjugation Options *)
	captureAntibodyConjugations=If[customizableCartridgeQ,
		Lookup[optionsWithReplicates,CaptureAntibodyConjugation],
		{}
	];

	captureAntibodyVolumes=If[MemberQ[Lookup[optionsWithReplicates,CaptureAntibodyConjugation],True],
		Lookup[optionsWithReplicates,CaptureAntibodyVolume],
		{}
	];

	requiredDigoxigeninReagents=If[MemberQ[Lookup[optionsWithReplicates,CaptureAntibodyConjugation],True],
		digoxigeninReagentResources,
		{}
	];

	digoxigeninReagentVolumes=If[MemberQ[Lookup[optionsWithReplicates,CaptureAntibodyConjugation],True],
		Lookup[optionsWithReplicates,DigoxigeninReagentVolume],
		{}
	];

	requiredCaptureAntibodyConjugationBuffers=If[MemberQ[Lookup[optionsWithReplicates,CaptureAntibodyConjugation],True],
		captureAntibodyConjugationBufferResources,
		{}
	];

	captureAntibodyConjugationBufferVolumes=If[MemberQ[Lookup[optionsWithReplicates,CaptureAntibodyConjugation],True],
		Lookup[optionsWithReplicates,CaptureAntibodyConjugationBufferVolume],
		{}
	];

	requiredCaptureAntibodyConjugationContainers=If[MemberQ[Lookup[optionsWithReplicates,CaptureAntibodyConjugation],True],
		captureAntibodyConjugationContainerResources,
		{}
	];

	captureAntibodyConjugationTimes=If[MemberQ[Lookup[optionsWithReplicates,CaptureAntibodyConjugation],True],
		Lookup[optionsWithReplicates,CaptureAntibodyConjugationTime],
		{}
	];

	(* In the temperature field, change Ambient to Null to match the storage pattern of the protocol field *)
	captureAntibodyConjugationTemperatures=If[MemberQ[Lookup[optionsWithReplicates,CaptureAntibodyConjugation],True],
		Map[
			If[MatchQ[#,Ambient],
				Null,
				#
			]&,
			Lookup[optionsWithReplicates,CaptureAntibodyConjugationTemperature]
		],
		{}
	];

	requiredCaptureAntibodyPurificationColumns=If[MemberQ[Lookup[optionsWithReplicates,CaptureAntibodyConjugation],True],
		captureAntibodyPurificationColumnResources,
		{}
	];

	requiredCaptureAntibodyColumnWashBuffers=If[MemberQ[Lookup[optionsWithReplicates,CaptureAntibodyConjugation],True],
		captureAntibodyColumnWashBufferResources,
		{}
	];

	requiredCaptureAntibodyColumnWashContainers=If[MemberQ[Lookup[optionsWithReplicates,CaptureAntibodyConjugation],True],
		captureAntibodyPurificationColumnWashContainerResources,
		{}
	];

	requiredCaptureAntibodyColumnWasteContainers=If[MemberQ[Lookup[optionsWithReplicates,CaptureAntibodyConjugation],True],
		captureAntibodyPurificationWasteContainerResources,
		{}
	];

	requiredCaptureAntibodyConjugationCollectionVials=If[MemberQ[Lookup[optionsWithReplicates,CaptureAntibodyConjugation],True],
		captureAntibodyPurificationColumnCollectionVialResources,
		{}
	];

	captureAntibodyConjugationStorageConditions=If[MemberQ[Lookup[optionsWithReplicates,CaptureAntibodyConjugation],True],
		Lookup[optionsWithReplicates,CaptureAntibodyConjugationStorageCondition],
		{}
	];

	detectionAntibodyConjugations=If[customizableCartridgeQ,
		Lookup[optionsWithReplicates,DetectionAntibodyConjugation],
		{}
	];

	detectionAntibodyVolumes=If[MemberQ[Lookup[optionsWithReplicates,DetectionAntibodyConjugation],True],
		Lookup[optionsWithReplicates,DetectionAntibodyVolume],
		{}
	];

	requiredBiotinReagents=If[MemberQ[Lookup[optionsWithReplicates,DetectionAntibodyConjugation],True],
		biotinReagentResources,
		{}
	];

	biotinReagentVolumes=If[MemberQ[Lookup[optionsWithReplicates,DetectionAntibodyConjugation],True],
		Lookup[optionsWithReplicates,BiotinReagentVolume],
		{}
	];

	requiredDetectionAntibodyConjugationBuffers=If[MemberQ[Lookup[optionsWithReplicates,DetectionAntibodyConjugation],True],
		detectionAntibodyConjugationBufferResources,
		{}
	];

	detectionAntibodyConjugationBufferVolumes=If[MemberQ[Lookup[optionsWithReplicates,DetectionAntibodyConjugation],True],
		Lookup[optionsWithReplicates,DetectionAntibodyConjugationBufferVolume],
		{}
	];

	requiredDetectionAntibodyConjugationContainers=If[MemberQ[Lookup[optionsWithReplicates,DetectionAntibodyConjugation],True],
		detectionAntibodyConjugationContainerResources,
		{}
	];

	detectionAntibodyConjugationTimes=If[MemberQ[Lookup[optionsWithReplicates,DetectionAntibodyConjugation],True],
		Lookup[optionsWithReplicates,DetectionAntibodyConjugationTime],
		{}
	];

	(* In the temperature field, change Ambient to Null to match the storage pattern of the protocol field *)
	detectionAntibodyConjugationTemperatures=If[MemberQ[Lookup[optionsWithReplicates,DetectionAntibodyConjugation],True],
		Map[
			If[MatchQ[#,Ambient],
				Null,
				#
			]&,
			Lookup[optionsWithReplicates,DetectionAntibodyConjugationTemperature]
		],
		{}
	];

	requiredDetectionAntibodyPurificationColumns=If[MemberQ[Lookup[optionsWithReplicates,DetectionAntibodyConjugation],True],
		detectionAntibodyPurificationColumnResources,
		{}
	];

	requiredDetectionAntibodyColumnWashBuffers=If[MemberQ[Lookup[optionsWithReplicates,DetectionAntibodyConjugation],True],
		detectionAntibodyColumnWashBufferResources,
		{}
	];

	requiredDetectionAntibodyColumnWashContainers=If[MemberQ[Lookup[optionsWithReplicates,DetectionAntibodyConjugation],True],
		detectionAntibodyPurificationColumnWashContainerResources,
		{}
	];

	requiredDetectionAntibodyColumnWasteContainers=If[MemberQ[Lookup[optionsWithReplicates,DetectionAntibodyConjugation],True],
		detectionAntibodyPurificationWasteContainerResources,
		{}
	];

	requiredDetectionAntibodyConjugationCollectionVials=If[MemberQ[Lookup[optionsWithReplicates,DetectionAntibodyConjugation],True],
		detectionAntibodyPurificationColumnCollectionVialResources,
		{}
	];

	detectionAntibodyConjugationStorageConditions=If[MemberQ[Lookup[optionsWithReplicates,DetectionAntibodyConjugation],True],
		Lookup[optionsWithReplicates,DetectionAntibodyConjugationStorageCondition],
		{}
	];

	standardCaptureAntibodyConjugations=If[customizableCartridgeQ&&!MatchQ[standard,{}|Null],
		Lookup[optionsWithReplicates,StandardCaptureAntibodyConjugation],
		{}
	];

	standardCaptureAntibodyVolumes=If[MemberQ[ToList[Lookup[optionsWithReplicates,StandardCaptureAntibodyConjugation]],True],
		Lookup[optionsWithReplicates,StandardCaptureAntibodyVolume],
		{}
	];

	requiredStandardDigoxigeninReagents=If[MemberQ[ToList[Lookup[optionsWithReplicates,StandardCaptureAntibodyConjugation]],True],
		standardDigoxigeninReagentResources,
		{}
	];

	standardDigoxigeninReagentVolumes=If[MemberQ[ToList[Lookup[optionsWithReplicates,StandardCaptureAntibodyConjugation]],True],
		Lookup[optionsWithReplicates,StandardDigoxigeninReagentVolume],
		{}
	];

	requiredStandardCaptureAntibodyConjugationBuffers=If[MemberQ[ToList[Lookup[optionsWithReplicates,StandardCaptureAntibodyConjugation]],True],
		standardCaptureAntibodyConjugationBufferResources,
		{}
	];

	standardCaptureAntibodyConjugationBufferVolumes=If[MemberQ[ToList[Lookup[optionsWithReplicates,StandardCaptureAntibodyConjugation]],True],
		Lookup[optionsWithReplicates,StandardCaptureAntibodyConjugationBufferVolume],
		{}
	];

	requiredStandardCaptureAntibodyConjugationContainers=If[MemberQ[ToList[Lookup[optionsWithReplicates,StandardCaptureAntibodyConjugation]],True],
		standardCaptureAntibodyConjugationContainerResources,
		{}
	];

	standardCaptureAntibodyConjugationTimes=If[MemberQ[ToList[Lookup[optionsWithReplicates,StandardCaptureAntibodyConjugation]],True],
		Lookup[optionsWithReplicates,StandardCaptureAntibodyConjugationTime],
		{}
	];

	(* In the temperature field, change Ambient to Null to match the storage pattern of the protocol field *)
	standardCaptureAntibodyConjugationTemperatures=If[MemberQ[ToList[Lookup[optionsWithReplicates,StandardCaptureAntibodyConjugation]],True],
		Map[
			If[MatchQ[#,Ambient],
				Null,
				#
			]&,
			Lookup[optionsWithReplicates,StandardCaptureAntibodyConjugationTemperature]
		],
		{}
	];

	requiredStandardCaptureAntibodyPurificationColumns=If[MemberQ[ToList[Lookup[optionsWithReplicates,StandardCaptureAntibodyConjugation]],True],
		standardCaptureAntibodyPurificationColumnResources,
		{}
	];

	requiredStandardCaptureAntibodyColumnWashBuffers=If[MemberQ[ToList[Lookup[optionsWithReplicates,StandardCaptureAntibodyConjugation]],True],
		standardCaptureAntibodyColumnWashBufferResources,
		{}
	];

	requiredStandardCaptureAntibodyColumnWashContainers=If[MemberQ[ToList[Lookup[optionsWithReplicates,StandardCaptureAntibodyConjugation]],True],
		standardCaptureAntibodyPurificationColumnWashContainerResources,
		{}
	];

	requiredStandardCaptureAntibodyColumnWasteContainers=If[MemberQ[ToList[Lookup[optionsWithReplicates,StandardCaptureAntibodyConjugation]],True],
		standardCaptureAntibodyPurificationWasteContainerResources,
		{}
	];

	requiredStandardCaptureAntibodyConjugationCollectionVials=If[MemberQ[ToList[Lookup[optionsWithReplicates,StandardCaptureAntibodyConjugation]],True],
		standardCaptureAntibodyPurificationColumnCollectionVialResources,
		{}
	];

	standardCaptureAntibodyConjugationStorageConditions=If[MemberQ[ToList[Lookup[optionsWithReplicates,StandardCaptureAntibodyConjugation]],True],
		Lookup[optionsWithReplicates,StandardCaptureAntibodyConjugationStorageCondition],
		{}
	];

	standardDetectionAntibodyConjugations=If[customizableCartridgeQ&&!MatchQ[standard,{}|Null],
		Lookup[optionsWithReplicates,StandardDetectionAntibodyConjugation],
		{}
	];

	standardDetectionAntibodyVolumes=If[MemberQ[ToList[Lookup[optionsWithReplicates,StandardDetectionAntibodyConjugation]],True],
		Lookup[optionsWithReplicates,StandardDetectionAntibodyVolume],
		{}
	];

	requiredStandardBiotinReagents=If[MemberQ[ToList[Lookup[optionsWithReplicates,StandardDetectionAntibodyConjugation]],True],
		standardBiotinReagentResources,
		{}
	];

	standardBiotinReagentVolumes=If[MemberQ[ToList[Lookup[optionsWithReplicates,StandardDetectionAntibodyConjugation]],True],
		Lookup[optionsWithReplicates,StandardBiotinReagentVolume],
		{}
	];

	requiredStandardDetectionAntibodyConjugationBuffers=If[MemberQ[ToList[Lookup[optionsWithReplicates,StandardDetectionAntibodyConjugation]],True],
		standardDetectionAntibodyConjugationBufferResources,
		{}
	];

	standardDetectionAntibodyConjugationBufferVolumes=If[MemberQ[ToList[Lookup[optionsWithReplicates,StandardDetectionAntibodyConjugation]],True],
		Lookup[optionsWithReplicates,StandardDetectionAntibodyConjugationBufferVolume],
		{}
	];

	requiredStandardDetectionAntibodyConjugationContainers=If[MemberQ[ToList[Lookup[optionsWithReplicates,StandardDetectionAntibodyConjugation]],True],
		standardDetectionAntibodyConjugationContainerResources,
		{}
	];

	standardDetectionAntibodyConjugationTimes=If[MemberQ[ToList[Lookup[optionsWithReplicates,StandardDetectionAntibodyConjugation]],True],
		Lookup[optionsWithReplicates,StandardDetectionAntibodyConjugationTime],
		{}
	];

	(* In the temperature field, change Ambient to Null to match the storage pattern of the protocol field *)
	standardDetectionAntibodyConjugationTemperatures=If[MemberQ[ToList[Lookup[optionsWithReplicates,StandardDetectionAntibodyConjugation]],True],
		Map[
			If[MatchQ[#,Ambient],
				Null,
				#
			]&,
			Lookup[optionsWithReplicates,StandardDetectionAntibodyConjugationTemperature]
		],
		{}
	];

	requiredStandardDetectionAntibodyPurificationColumns=If[MemberQ[ToList[Lookup[optionsWithReplicates,StandardDetectionAntibodyConjugation]],True],
		standardDetectionAntibodyPurificationColumnResources,
		{}
	];

	requiredStandardDetectionAntibodyColumnWashBuffers=If[MemberQ[ToList[Lookup[optionsWithReplicates,StandardDetectionAntibodyConjugation]],True],
		standardDetectionAntibodyColumnWashBufferResources,
		{}
	];

	requiredStandardDetectionAntibodyColumnWashContainers=If[MemberQ[ToList[Lookup[optionsWithReplicates,StandardDetectionAntibodyConjugation]],True],
		standardDetectionAntibodyPurificationColumnWashContainerResources,
		{}
	];

	requiredStandardDetectionAntibodyColumnWasteContainers=If[MemberQ[ToList[Lookup[optionsWithReplicates,StandardDetectionAntibodyConjugation]],True],
		standardDetectionAntibodyPurificationWasteContainerResources,
		{}
	];

	requiredStandardDetectionAntibodyConjugationCollectionVials=If[MemberQ[ToList[Lookup[optionsWithReplicates,StandardDetectionAntibodyConjugation]],True],
		standardDetectionAntibodyPurificationColumnCollectionVialResources,
		{}
	];

	standardDetectionAntibodyConjugationStorageConditions=If[MemberQ[ToList[Lookup[optionsWithReplicates,StandardDetectionAntibodyConjugation]],True],
		Lookup[optionsWithReplicates,StandardDetectionAntibodyConjugationStorageCondition],
		{}
	];

	(* Antibody Dilution Options *)
	captureAntibodyDilutions=If[customizableCartridgeQ,
		Lookup[optionsWithReplicates,CaptureAntibodyDilution],
		{}
	];

	requiredCaptureAntibodyAbsorbanceBlanks={};

	(*
	requiredCaptureAntibodyAbsorbanceBlanks=If[MemberQ[Lookup[optionsWithReplicates,CaptureAntibodyDilution],True],
		captureAntibodyAbsorbanceBlankResources,
		{}
	];
	*)

	captureAntibodyTargetConcentrations=If[MemberQ[Lookup[optionsWithReplicates,CaptureAntibodyDilution],True],
		Lookup[optionsWithReplicates,CaptureAntibodyTargetConcentration],
		{}
	];

	requiredCaptureAntibodyDiluents=If[MemberQ[Lookup[optionsWithReplicates,CaptureAntibodyDilution],True],
		captureAntibodyDiluentResources,
		{}
	];

	requiredCaptureAntibodyDilutionContainers=If[MemberQ[Lookup[optionsWithReplicates,CaptureAntibodyDilution],True],
		captureAntibodyDilutionContainerResources,
		{}
	];

	detectionAntibodyDilutions=If[customizableCartridgeQ,
		Lookup[optionsWithReplicates,DetectionAntibodyDilution],
		{}
	];

	requiredDetectionAntibodyAbsorbanceBlanks={};

	(*
	requiredDetectionAntibodyAbsorbanceBlanks=If[MemberQ[Lookup[optionsWithReplicates,DetectionAntibodyDilution],True],
		detectionAntibodyAbsorbanceBlankResources,
		{}
	];
	*)

	detectionAntibodyTargetConcentrations=If[MemberQ[Lookup[optionsWithReplicates,DetectionAntibodyDilution],True],
		Lookup[optionsWithReplicates,DetectionAntibodyTargetConcentration],
		{}
	];

	requiredDetectionAntibodyDiluents=If[MemberQ[Lookup[optionsWithReplicates,DetectionAntibodyDilution],True],
		detectionAntibodyDiluentResources,
		{}
	];

	requiredDetectionAntibodyDilutionContainers=If[MemberQ[Lookup[optionsWithReplicates,DetectionAntibodyDilution],True],
		detectionAntibodyDilutionContainerResources,
		{}
	];

	standardCaptureAntibodyDilutions=If[customizableCartridgeQ&&!MatchQ[standard,Null|{}],
		Lookup[optionsWithReplicates,StandardCaptureAntibodyDilution],
		{}
	];

	requiredStandardCaptureAntibodyAbsorbanceBlanks={};

	(*
	requiredStandardCaptureAntibodyAbsorbanceBlanks=If[MemberQ[ToList[Lookup[optionsWithReplicates,StandardCaptureAntibodyDilution]],True],
		standardCaptureAntibodyAbsorbanceBlankResources,
		{}
	];
	*)

	standardCaptureAntibodyTargetConcentrations=If[MemberQ[ToList[Lookup[optionsWithReplicates,StandardCaptureAntibodyDilution]],True],
		Lookup[optionsWithReplicates,StandardCaptureAntibodyTargetConcentration],
		{}
	];

	requiredStandardCaptureAntibodyDiluents=If[MemberQ[ToList[Lookup[optionsWithReplicates,StandardCaptureAntibodyDilution]],True],
		standardCaptureAntibodyDiluentResources,
		{}
	];

	requiredStandardCaptureAntibodyDilutionContainers=If[MemberQ[ToList[Lookup[optionsWithReplicates,StandardCaptureAntibodyDilution]],True],
		standardCaptureAntibodyDilutionContainerResources,
		{}
	];

	standardDetectionAntibodyDilutions=If[customizableCartridgeQ&&!MatchQ[standard,Null|{}],
		Lookup[optionsWithReplicates,StandardDetectionAntibodyDilution],
		{}
	];

	requiredStandardDetectionAntibodyAbsorbanceBlanks={};

	(*
	requiredStandardDetectionAntibodyAbsorbanceBlanks=If[MemberQ[ToList[Lookup[optionsWithReplicates,StandardDetectionAntibodyDilution]],True],
		standardDetectionAntibodyAbsorbanceBlankResources,
		{}
	];
	*)

	standardDetectionAntibodyTargetConcentrations=If[MemberQ[ToList[Lookup[optionsWithReplicates,StandardDetectionAntibodyDilution]],True],
		Lookup[optionsWithReplicates,StandardDetectionAntibodyTargetConcentration],
		{}
	];

	requiredStandardDetectionAntibodyDiluents=If[MemberQ[ToList[Lookup[optionsWithReplicates,StandardDetectionAntibodyDilution]],True],
		standardDetectionAntibodyDiluentResources,
		{}
	];

	requiredStandardDetectionAntibodyDilutionContainers=If[MemberQ[ToList[Lookup[optionsWithReplicates,StandardDetectionAntibodyDilution]],True],
		standardDetectionAntibodyDilutionContainerResources,
		{}
	];

	(* CartridgeLoading *)
	(* Only thing to consider is whether standard samples are added or cartridge is customizable *)
	captureAntibodyLoadingVolumes=If[customizableCartridgeQ,
		Lookup[optionsWithReplicates,CaptureAntibodyLoadingVolume],
		{}
	];

	detectionAntibodyLoadingVolumes=If[customizableCartridgeQ,
		Lookup[optionsWithReplicates,DetectionAntibodyLoadingVolume],
		{}
	];

	standardLoadingVolumes=If[MatchQ[standard,Null|{}],
		{},
		Lookup[optionsWithReplicates,StandardLoadingVolume]
	];

	standardCaptureAntibodyLoadingVolumes=If[customizableCartridgeQ&&!MatchQ[standard,Null|{}],
		Lookup[optionsWithReplicates,StandardCaptureAntibodyLoadingVolume],
		{}
	];

	standardDetectionAntibodyLoadingVolumes=If[customizableCartridgeQ&&!MatchQ[standard,Null|{}],
		Lookup[optionsWithReplicates,StandardDetectionAntibodyLoadingVolume],
		{}
	];


	(* Antibody Dilution Initial Concentration *)
	(* Put the antibody dilution initial concentrations back into its original pattern *)
	(* antibodyDilutionInitialConcentrations are already available for the unique antibodies *)
	allCaptureAntibodyDilutionInitialConcentrations=Take[
		antibodyDilutionInitialConcentrations,
		Length[uniqueRequiredCaptureAntibodyLoadingVolumes]
	];
	allDetectionAntibodyDilutionInitialConcentrations=Take[
		antibodyDilutionInitialConcentrations,
		-Length[uniqueRequiredDetectionAntibodyLoadingVolumes]
	];

	uniqueCaptureAntibodyDilutionInitialConcentrationReplaceRules=MapThread[
		(Values[#1]->#2)&,
		{Keys[uniqueRequiredCaptureAntibodyLoadingVolumes][[All,1]],allCaptureAntibodyDilutionInitialConcentrations}
	];

	uniqueDetectionAntibodyDilutionInitialConcentrationReplaceRules=MapThread[
		(Values[#1]->#2)&,
		{Keys[uniqueRequiredDetectionAntibodyLoadingVolumes][[All,1]],allDetectionAntibodyDilutionInitialConcentrations}
	];

	(* Use the replace rule to get the resources *)
	{
		captureAntibodyDilutionInitialConcentrations,standardCaptureAntibodyDilutionInitialConcentrations
	}=If[customizableCartridgeQ&&MemberQ[Lookup[optionsWithReplicates,CaptureAntibodyDilution],True],
		Map[
			Replace[#,uniqueCaptureAntibodyDilutionInitialConcentrationReplaceRules,{1}]&,
			{captureAntibodyOptions,standardCaptureAntibodyOptions}
		],
		{{},{}}
	];

	{
		detectionAntibodyDilutionInitialConcentrations,standardDetectionAntibodyDilutionInitialConcentrations
	}=If[customizableCartridgeQ&&MemberQ[Lookup[optionsWithReplicates,DetectionAntibodyDilution],True],
		Map[
			Replace[#,uniqueDetectionAntibodyDilutionInitialConcentrationReplaceRules,{1}]&,
			{detectionAntibodyOptions,standardDetectionAntibodyOptions}
		],
		{{},{}}
	];


	(* StandardComposition *)
	(* Turn the provided StandardComposition into Protocol field *)
	standardComposition=If[MatchQ[standard,Null|{}],
		{},
		Map[
			{First[#],Link[Download[Last[#],Object]]}&,
			Lookup[optionsWithReplicates,StandardComposition],
			{2}
		]
	];

	(* SpikeConcentration *)
	(* Turn the provided SpikeConcentration into Protocol field *)
	(* Only provide this information when we have a spike sample *)
	spikeConcentration=If[MemberQ[Flatten[Lookup[optionsWithReplicates,SpikeConcentration]],Except[Null]],
		Map[
			Function[
				{spikeConc},
				If[MatchQ[spikeConc,Null|{}],
					spikeConc,
					Map[
						{First[#],Link[Download[Last[#],Object]]}&,
						spikeConc
					]
				]
			],
			Lookup[optionsWithReplicates,SpikeConcentration]
		],
		{}
	];

    (* Estimate Time *)
    (* TODO Get a better estimation of all the times after an example run is finished. May also play with the other experiments/ subprotocols in Procedure to help determine the times *)
    (* Set up some booleans to help organize the time estimation *)
    standardQ=!MatchQ[standard,Null|{}];

    (* Picking Resources *)
    (* We estimate 45 Minute for input samples, containers and cartridge. Add another 30 Minute if we get Standard samples. Add another 1 Hour for antibody samples and containers if Cartridge is Customizable. *)
    pickingResourcesTime=Total[
        {
            45Minute,
            If[customizableCartridgeQ,1Hour,0Minute],
            If[standardQ,30Minute,0Minute]
        }
    ];

    (* Returning Resources *)
    (* Returning resources should be faster than picking resources. We estimate 30 Minute for input samples. Add another 15 Minute if we get Standard samples. Add another 30 Minute for antibody samples, because we allow storing all the prepared samples. *)
    returningResourcesTime=Total[
        {
            30Minute,
            If[customizableCartridgeQ,30Minute,0Minute],
            If[standardQ,15Minute,0Minute]
        }
    ];


    (* Protein Preparation - Sample Preparation including antibody and standard sample *)
    (* Get the resuspension incubation time option *)
    antibodyResuspensionTime=Which[
        !customizableCartridgeQ,0Minute,
        (* If not Null, add 1 Hour for the preparation of the samples *)
        MemberQ[Join[captureAntibodyResuspensions,detectionAntibodyResuspensions,standardCaptureAntibodyResuspensions,standardDetectionAntibodyResuspensions],True],1Hour,
        True,0Minute
    ];

    (* Get the conjugation incubation time option *)
    antibodyConjugationIncubationTime=Join[captureAntibodyConjugationTimes,detectionAntibodyConjugationTimes,standardCaptureAntibodyConjugationTimes,standardDetectionAntibodyConjugationTimes];
    antibodyConjugationTime=Which[
        !customizableCartridgeQ,0Minute,
        (* If not Null, add 1.5Hour to the incubation time for the preparation of samples and the purification of samples through spin column *)
        MemberQ[antibodyConjugationIncubationTime,Except[Null]],Max[DeleteCases[antibodyConjugationIncubationTime,Null]]+90Minute,
        True,0Minute
    ];

	(* Standard Sample Resuspension *)
	standardResuspensionTime=If[MemberQ[standardResuspensions,True],
		1Hour,
		0Minute
	];

	(* Total time Estimation *)
	(* Our first step is antibody preparation - resuspension and conjugation *)
	samplePreparationTotalTime=antibodyResuspensionTime+antibodyConjugationTime+standardResuspensionTime;

	(* Sample Manipulation *)
	(* Get the antibody dilution time *)
	antibodyDilutionTime=Which[
		!customizableCartridgeQ,0Minute,
		(* If any of the antibody sample is to be diluted, we must measure absorbance intensity for it. Add 2 Hour for that and 30Minute for sample manipulation *)
		MemberQ[Join[captureAntibodyDilutions,detectionAntibodyDilutions,standardCaptureAntibodyDilutions,standardDetectionAntibodyDilutions],True],1Hour,
		True,0Minute
	];

	sampleManipulationTime=Total[
		{
			antibodyDilutionTime,
			1Hour,
			(* If any of the sample needs to be spiked, add 1 Hour *)
			If[!ContainsOnly[spikeSample,{Null}],1Hour,0Minute],
			(* Add time for standard sample preparation *)
			If[MatchQ[standard,Null|{}],
				0Minute,
				(* Additional 1 Hour is added for sample dilution. *)
				1Hour
			]
		}
	];

	(* Antibody and Sample Dilution + 1 Hour of Cartridge Loading *)
	sampleManipulationTotalTime=1Hour+antibodyDilutionTime+sampleManipulationTime;

    (* --- Generate the protocol packet --- *)
    protocolPacket=<|
		Type->Object[Protocol,CapillaryELISA],
		Object->CreateID[Object[Protocol,CapillaryELISA]],
		UnresolvedOptions->myUnresolvedOptions,
		ResolvedOptions->myResolvedOptions,
		NumberOfReplicates->Lookup[expandedResolvedOptions,NumberOfReplicates],
		Replace[SamplesIn]->samplesInResources,
		Replace[ContainersIn]->containersInResources,

		(* General fields in Protocol *)
		Instrument->instrumentResource,
		Cartridge->cartridgeResource,
		CartridgeType->cartridgeType,
		Species->species,
		Multiplex->multiplex,
		Replace[AnalyteMolecules]->analyteMolecules,
		Replace[AnalyteNames]->analyteNames,
		Replace[MultiplexAnalyteMolecules]->multiplexAnalyteMolecules,
		Replace[MultiplexAnalyteNames]->multiplexAnalyteNames,
		Replace[ManufacturingSpecifications]->manufacturingSpecifications,
		Replace[UpperQuantitationLimits]->upperQuantitationLimits,
		Replace[LowerQuantitationLimits]->lowerQuantitationLimits,

		(* Sample Preparation *)
		Replace[SampleVolumes]->requiredSampleVolumes,
		Replace[SpikeSamples]->requiredSpikeResources,
		Replace[SpikeVolumes]->requiredSpikeVolumes,
		Replace[SpikeSampleStorageConditions]->requiredSpikeSampleStorageCondtion,
		SpikeContainer->spikeContainerResource,
		Replace[SerialDilution]->serialDilutionBooleans,
		Replace[DilutionAssayVolumes]->dilutionAssayVolumes,
		Replace[StartingDilutionFactors]->startingDilutionFactors,
		Replace[DilutionFactorIncrements]->dilutionFactorIncrements,
		Replace[NumberOfDilutions]->numberOfDilutions,
		Replace[DilutionCurves]->requiredDilutionCurves,
		Replace[SerialDilutionAssayVolumes]->serialDilutionAssayVolumes,
		Replace[SerialDilutionFactors]->serialDilutionFactors,
		Replace[NumberOfSerialDilutions]->numberOfSerialDilutions,
		Replace[SerialDilutionCurves]->requiredSerialDilutionCurves,
		Replace[Diluents]->diluentResources,
		DilutionContainer->dilutionContainerResource,
		Replace[DilutionMixVolumes]->Lookup[optionsWithReplicates,DilutionMixVolume],
		Replace[DilutionNumberOfMixes]->Lookup[optionsWithReplicates,DilutionNumberOfMixes],
		Replace[DilutionMixRates]->Lookup[optionsWithReplicates,DilutionMixRate],

		(* Antibody fields in Protocol *)
		Replace[CustomCaptureAntibodies]->customCaptureAntibodyResources,
		Replace[CaptureAntibodyResuspensions]->captureAntibodyResuspensions,
		Replace[CaptureAntibodyResuspensionConcentrations]->captureAntibodyResuspensionConcentrations,
		Replace[CaptureAntibodyResuspensionDiluents]->captureAntibodyResuspensionDiluents,
		Replace[CaptureAntibodyStorageConditions]->captureAntibodyStorageConditions,
		Replace[CaptureAntibodyConjugations]->captureAntibodyConjugations,
		Replace[CaptureAntibodyVolumes]->captureAntibodyVolumes,
		Replace[DigoxigeninReagents]->requiredDigoxigeninReagents,
		Replace[DigoxigeninReagentVolumes]->digoxigeninReagentVolumes,
		Replace[CaptureAntibodyConjugationBuffers]->requiredCaptureAntibodyConjugationBuffers,
		Replace[CaptureAntibodyConjugationBufferVolumes]->captureAntibodyConjugationBufferVolumes,
		Replace[CaptureAntibodyConjugationContainers]->requiredCaptureAntibodyConjugationContainers,
		Replace[CaptureAntibodyConjugationTimes]->captureAntibodyConjugationTimes,
		Replace[CaptureAntibodyConjugationTemperatures]->captureAntibodyConjugationTemperatures,
		Replace[CaptureAntibodyPurificationColumns]->requiredCaptureAntibodyPurificationColumns,
		Replace[CaptureAntibodyColumnWashBuffers]->requiredCaptureAntibodyColumnWashBuffers,
		Replace[CaptureAntibodyColumnWashContainers]->requiredCaptureAntibodyColumnWashContainers,
		Replace[CaptureAntibodyColumnWasteContainers]->requiredCaptureAntibodyColumnWasteContainers,
		Replace[CaptureAntibodyConjugationCollectionVials]->requiredCaptureAntibodyConjugationCollectionVials,
		Replace[CaptureAntibodyConjugationStorageConditions]->captureAntibodyConjugationStorageConditions,
		Replace[CaptureAntibodyDilutions]->captureAntibodyDilutions,
		Replace[CaptureAntibodyAbsorbanceBlanks]->requiredCaptureAntibodyAbsorbanceBlanks,
		Replace[CaptureAntibodyInitialConcentrations]->captureAntibodyDilutionInitialConcentrations,
		Replace[CaptureAntibodyTargetConcentrations]->captureAntibodyTargetConcentrations,
		Replace[CaptureAntibodyDiluents]->requiredCaptureAntibodyDiluents,
		Replace[CaptureAntibodyDilutionContainers]->requiredCaptureAntibodyDilutionContainers,

		Replace[CustomDetectionAntibodies]->customDetectionAntibodyResources,
		Replace[DetectionAntibodyResuspensions]->detectionAntibodyResuspensions,
		Replace[DetectionAntibodyResuspensionConcentrations]->detectionAntibodyResuspensionConcentrations,
		Replace[DetectionAntibodyResuspensionDiluents]->detectionAntibodyResuspensionDiluents,
		Replace[DetectionAntibodyStorageConditions]->detectionAntibodyStorageConditions,
		Replace[DetectionAntibodyConjugations]->detectionAntibodyConjugations,
		Replace[DetectionAntibodyVolumes]->detectionAntibodyVolumes,
		Replace[BiotinReagents]->requiredBiotinReagents,
		Replace[BiotinReagentVolumes]->biotinReagentVolumes,
		Replace[DetectionAntibodyConjugationBuffers]->requiredDetectionAntibodyConjugationBuffers,
		Replace[DetectionAntibodyConjugationBufferVolumes]->detectionAntibodyConjugationBufferVolumes,
		Replace[DetectionAntibodyConjugationContainers]->requiredDetectionAntibodyConjugationContainers,
		Replace[DetectionAntibodyConjugationTimes]->detectionAntibodyConjugationTimes,
		Replace[DetectionAntibodyConjugationTemperatures]->detectionAntibodyConjugationTemperatures,
		Replace[DetectionAntibodyPurificationColumns]->requiredDetectionAntibodyPurificationColumns,
		Replace[DetectionAntibodyColumnWashBuffers]->requiredDetectionAntibodyColumnWashBuffers,
		Replace[DetectionAntibodyColumnWashContainers]->requiredDetectionAntibodyColumnWashContainers,
		Replace[DetectionAntibodyColumnWasteContainers]->requiredDetectionAntibodyColumnWasteContainers,
		Replace[DetectionAntibodyConjugationCollectionVials]->requiredDetectionAntibodyConjugationCollectionVials,
		Replace[DetectionAntibodyConjugationStorageConditions]->detectionAntibodyConjugationStorageConditions,
		Replace[DetectionAntibodyDilutions]->detectionAntibodyDilutions,
		Replace[DetectionAntibodyAbsorbanceBlanks]->requiredDetectionAntibodyAbsorbanceBlanks,
		Replace[DetectionAntibodyInitialConcentrations]->detectionAntibodyDilutionInitialConcentrations,
		Replace[DetectionAntibodyTargetConcentrations]->detectionAntibodyTargetConcentrations,
		Replace[DetectionAntibodyDiluents]->requiredDetectionAntibodyDiluents,
		Replace[DetectionAntibodyDilutionContainers]->requiredDetectionAntibodyDilutionContainers,

		(* Standard *)
		Replace[Standards]->standardResources,
		Replace[StandardResuspensions]->standardResuspensions,
		Replace[StandardResuspensionConcentrations]->standardResuspensionConcentrations,
		Replace[StandardResuspensionDiluents]->standardResuspensionDiluents,
		Replace[StandardStorageConditions]->standardStorageConditions,
		Replace[StandardSerialDilution]->standardSerialDilutionBooleans,
		Replace[StandardDilutionAssayVolumes]->standardDilutionAssayVolumes,
		Replace[StandardStartingDilutionFactors]->standardStartingDilutionFactors,
		Replace[StandardDilutionFactorIncrements]->standardDilutionFactorIncrements,
		Replace[StandardNumberOfDilutions]->standardNumberOfDilutions,
		Replace[StandardDilutionCurves]->requiredStandardDilutionCurves,
		Replace[StandardSerialDilutionAssayVolumes]->standardSerialDilutionAssayVolumes,
		Replace[StandardSerialDilutionFactors]->standardSerialDilutionFactors,
		Replace[StandardNumberOfSerialDilutions]->numberOfStandardSerialDilutions,
		Replace[StandardSerialDilutionCurves]->requiredStandardSerialDilutionCurves,
		Replace[StandardDiluents]->requiredStandardDiluents,
		Replace[StandardDilutionMixVolumes]->standardDilutionMixVolumes,
		Replace[StandardDilutionNumberOfMixes]->standardDilutionNumberOfMixes,
		Replace[StandardDilutionMixRates]->standardDilutionMixRates,

		(* Standard Antibody fields in Protocol *)
		Replace[StandardCaptureAntibodies]->requiredStandardCaptureAntibodies,
		Replace[StandardCaptureAntibodyResuspensions]->standardCaptureAntibodyResuspensions,
		Replace[StandardCaptureAntibodyResuspensionConcentrations]->standardCaptureAntibodyResuspensionConcentrations,
		Replace[StandardCaptureAntibodyResuspensionDiluents]->standardCaptureAntibodyResuspensionDiluents,
		Replace[StandardCaptureAntibodyStorageConditions]->standardCaptureAntibodyStorageConditions,
		Replace[StandardCaptureAntibodyConjugations]->standardCaptureAntibodyConjugations,
		Replace[StandardCaptureAntibodyVolumes]->standardCaptureAntibodyVolumes,
		Replace[StandardDigoxigeninReagents]->requiredStandardDigoxigeninReagents,
		Replace[StandardDigoxigeninReagentVolumes]->standardDigoxigeninReagentVolumes,
		Replace[StandardCaptureAntibodyConjugationBuffers]->requiredStandardCaptureAntibodyConjugationBuffers,
		Replace[StandardCaptureAntibodyConjugationBufferVolumes]->standardCaptureAntibodyConjugationBufferVolumes,
		Replace[StandardCaptureAntibodyConjugationContainers]->requiredStandardCaptureAntibodyConjugationContainers,
		Replace[StandardCaptureAntibodyConjugationTimes]->standardCaptureAntibodyConjugationTimes,
		Replace[StandardCaptureAntibodyConjugationTemperatures]->standardCaptureAntibodyConjugationTemperatures,
		Replace[StandardCaptureAntibodyPurificationColumns]->requiredStandardCaptureAntibodyPurificationColumns,
		Replace[StandardCaptureAntibodyColumnWashBuffers]->requiredStandardCaptureAntibodyColumnWashBuffers,
		Replace[StandardCaptureAntibodyColumnWashContainers]->requiredStandardCaptureAntibodyColumnWashContainers,
		Replace[StandardCaptureAntibodyColumnWasteContainers]->requiredStandardCaptureAntibodyColumnWasteContainers,
		Replace[StandardCaptureAntibodyConjugationCollectionVials]->requiredStandardCaptureAntibodyConjugationCollectionVials,
		Replace[StandardCaptureAntibodyConjugationStorageConditions]->standardCaptureAntibodyConjugationStorageConditions,
		Replace[StandardCaptureAntibodyDilutions]->standardCaptureAntibodyDilutions,
		Replace[StandardCaptureAntibodyAbsorbanceBlanks]->requiredStandardCaptureAntibodyAbsorbanceBlanks,
		Replace[StandardCaptureAntibodyInitialConcentrations]->standardCaptureAntibodyDilutionInitialConcentrations,
		Replace[StandardCaptureAntibodyTargetConcentrations]->standardCaptureAntibodyTargetConcentrations,
		Replace[StandardCaptureAntibodyDiluents]->requiredStandardCaptureAntibodyDiluents,
		Replace[StandardCaptureAntibodyDilutionContainers]->requiredStandardCaptureAntibodyDilutionContainers,

		Replace[StandardDetectionAntibodies]->requiredStandardDetectionAntibodies,
		Replace[StandardDetectionAntibodyResuspensions]->standardDetectionAntibodyResuspensions,
		Replace[StandardDetectionAntibodyResuspensionConcentrations]->standardDetectionAntibodyResuspensionConcentrations,
		Replace[StandardDetectionAntibodyResuspensionDiluents]->standardDetectionAntibodyResuspensionDiluents,
		Replace[StandardDetectionAntibodyStorageConditions]->standardDetectionAntibodyStorageConditions,
		Replace[StandardDetectionAntibodyConjugations]->standardDetectionAntibodyConjugations,
		Replace[StandardDetectionAntibodyVolumes]->standardDetectionAntibodyVolumes,
		Replace[StandardBiotinReagents]->requiredStandardBiotinReagents,
		Replace[StandardBiotinReagentVolumes]->standardBiotinReagentVolumes,
		Replace[StandardDetectionAntibodyConjugationBuffers]->requiredStandardDetectionAntibodyConjugationBuffers,
		Replace[StandardDetectionAntibodyConjugationBufferVolumes]->standardDetectionAntibodyConjugationBufferVolumes,
		Replace[StandardDetectionAntibodyConjugationContainers]->requiredStandardDetectionAntibodyConjugationContainers,
		Replace[StandardDetectionAntibodyConjugationTimes]->standardDetectionAntibodyConjugationTimes,
		Replace[StandardDetectionAntibodyConjugationTemperatures]->standardDetectionAntibodyConjugationTemperatures,
		Replace[StandardDetectionAntibodyPurificationColumns]->requiredStandardDetectionAntibodyPurificationColumns,
		Replace[StandardDetectionAntibodyColumnWashBuffers]->requiredStandardDetectionAntibodyColumnWashBuffers,
		Replace[StandardDetectionAntibodyColumnWashContainers]->requiredStandardDetectionAntibodyColumnWashContainers,
		Replace[StandardDetectionAntibodyColumnWasteContainers]->requiredStandardDetectionAntibodyColumnWasteContainers,
		Replace[StandardDetectionAntibodyConjugationCollectionVials]->requiredStandardDetectionAntibodyConjugationCollectionVials,
		Replace[StandardDetectionAntibodyConjugationStorageConditions]->standardDetectionAntibodyConjugationStorageConditions,
		Replace[StandardDetectionAntibodyDilutions]->standardDetectionAntibodyDilutions,
		Replace[StandardDetectionAntibodyAbsorbanceBlanks]->requiredStandardDetectionAntibodyAbsorbanceBlanks,
		Replace[StandardDetectionAntibodyInitialConcentrations]->standardDetectionAntibodyDilutionInitialConcentrations,
		Replace[StandardDetectionAntibodyTargetConcentrations]->standardDetectionAntibodyTargetConcentrations,
		Replace[StandardDetectionAntibodyDiluents]->requiredStandardDetectionAntibodyDiluents,
		Replace[StandardDetectionAntibodyDilutionContainers]->requiredStandardDetectionAntibodyDilutionContainers,

		(* Cartridge Loading *)
		Replace[LoadingVolumes]->Lookup[optionsWithReplicates,LoadingVolume],
		Replace[StandardLoadingVolumes]->standardLoadingVolumes,
		Replace[CaptureAntibodyLoadingVolumes]->captureAntibodyLoadingVolumes,
		Replace[DetectionAntibodyLoadingVolumes]->detectionAntibodyLoadingVolumes,
		Replace[StandardCaptureAntibodyLoadingVolumes]->standardCaptureAntibodyLoadingVolumes,
		Replace[StandardDetectionAntibodyLoadingVolumes]->standardDetectionAntibodyLoadingVolumes,

		PlaceHolderDiluent->extraDiluentResource,
		WashBuffer->washBufferResource,
		(*
		CaptureAntibodyAbsorbanceMeasurementContainer->captureAntibodyAbsorbanceContainerResource,
		DetectionAntibodyAbsorbanceMeasurementContainer->detectionAntibodyAbsorbanceContainerResource,
		*)

		Replace[StandardCompositions]->standardComposition,
		Replace[SpikeConcentrations]->spikeConcentration,

		Replace[Checkpoints]->{
			{"Preparing Samples",45 Minute,"Preprocessing, such as incubation, mixing, centrifuging, and aliquoting, is performed.",Link[Resource[Operator->Model[User,Emerald,Operator,"Trainee"],Time->45 Minute]]},
			{"Picking Resources",pickingResourcesTime,"Samples and containers required to execute this protocol are gathered from storage.",Link[Resource[Operator->Model[User,Emerald,Operator,"Trainee"],Time->pickingResourcesTime]]},
			{"Sample Preparation",samplePreparationTotalTime,"The antibody samples are resuspended and conjugated and the standard samples are resuspended.",Link[Resource[Operator->Model[User,Emerald,Operator,"Trainee"],Time->samplePreparationTotalTime]]},
			{"Cartridge Loading",sampleManipulationTotalTime,"The experiment samples are mixed with spike samples and then diluted. The standard samples and the antibody samples are diluted. The samples and antibodies are loaded in the capillary ELISA cartridge.",Link[Resource[Operator->Model[User,Emerald,Operator,"Trainee"],Time->sampleManipulationTotalTime]]},
			(* This will be put as part of the maintanence or qualifiaction. *)
			(*
			{"Capillary ELISA Instrument Self Test",1 Hour,"The self test of capillary ELISA instrument is performed with a verification cartridge, provided by ProteinSimple, the manufacturer of the instrument.",Link[Resource[Operator->Model[User,Emerald,Operator,"Trainee"],Time->1Hour]]},
			*)
			{"Capillary ELISA Run",2.5 Hour,"The capillary ELISA experiment is run on the cartridge, loaded with experiment samples.",Link[Resource[Operator->Model[User,Emerald,Operator,"Trainee"],Time->2Hour]]},
			{"Returning Materials",returningResourcesTime,"Samples are returned to storage.",Link[Resource[Operator->Model[User,Emerald,Operator,"Trainee"], Time->returningResourcesTime]]}
		}
	|>;

    (* generate a packet with the shared fields *)
    sharedFieldPacket=populateSamplePrepFields[mySamples,myResolvedOptions,Cache->inheritedCache];

    (* Merge the shared fields with the specific fields *)
    finalizedPacket=Join[sharedFieldPacket, protocolPacket];

    (* get all the resource symbolic representations *)
    (* need to pull these at infinite depth because otherwise all resources with Link wrapped around them won't be grabbed *)
    allResourceBlobs=DeleteDuplicates[Cases[Flatten[Values[finalizedPacket]],_Resource,Infinity]];


	(* call fulfillableResourceQ on all the resources we created *)
    {fulfillable,frqTests}=Which[
      MatchQ[$ECLApplication,Engine],{True,{}},
      gatherTests,Resources`Private`fulfillableResourceQ[allResourceBlobs,Output->{Result,Tests},FastTrack->Lookup[myResolvedOptions,FastTrack],Site->Lookup[myResolvedOptions,Site],Cache->inheritedCache],
      True,{Resources`Private`fulfillableResourceQ[allResourceBlobs,FastTrack->Lookup[myResolvedOptions,FastTrack],Site->Lookup[myResolvedOptions,Site],Messages->messages,Cache->inheritedCache],Null}
    ];


    (* generate the tests rule *)
    testsRule=Tests->If[gatherTests,
      frqTests,
      Null
    ];

    (* generate the Result output rule *)
    (* if not returning Result, or the resources are not fulfillable, Results rule is just $Failed *)
    resultRule=Result->If[MemberQ[output,Result]&&TrueQ[fulfillable],
      finalizedPacket,
      $Failed
    ];

    (* return the output as we desire it *)
    outputSpecification /.{resultRule,testsRule}
];


(* ::Subsection::Closed:: *)
(*Sister Functions*)


(* ::Subsection::Closed:: *)
(*ExperimentCapillaryELISAOptions*)


DefineOptions[ExperimentCapillaryELISAOptions,
	Options:>{
		{
			OptionName->OutputFormat,
			Default->Table,
			AllowNull->False,
			Widget->Widget[Type->Enumeration,Pattern:>Alternatives[Table,List]],
			Description->"Indicates whether the function returns a table or a list of the options.",
			Category->"Protocol"
		}
	},
	SharedOptions:>{ExperimentCapillaryELISA}
];


(*---Main function accepting sample/container objects as sample inputs and sample objects or Nulls as primer pair inputs---*)
ExperimentCapillaryELISAOptions[
	mySamples:ListableP[ObjectP[Object[Container]]]|ListableP[(ObjectP[Object[Sample]]|_String)],
	myOptions:OptionsPattern[ExperimentCapillaryELISAOptions]
]:=Module[
	{listedOptions,preparedOptions,resolvedOptions},

	(*Get the options as a list*)
	listedOptions=ToList[myOptions];

	(*Send in the correct Output option and remove the OutputFormat option*)
	preparedOptions=Normal@KeyDrop[Append[listedOptions,Output->Options],{OutputFormat}];

	resolvedOptions=ExperimentCapillaryELISA[mySamples,preparedOptions];

	(* If options fail, return failure *)
	If[MatchQ[resolvedOptions,$Failed],
		Return[$Failed]
	];

	(*Return the option as a list or table*)
	If[MatchQ[Lookup[listedOptions,OutputFormat,Table],Table],
		LegacySLL`Private`optionsToTable[resolvedOptions,ExperimentCapillaryELISA],
		resolvedOptions
	]
];


(* ::Subsection::Closed:: *)
(*ValidExperimentCapillaryELISAQ*)


DefineOptions[ValidExperimentCapillaryELISAQ,
	Options:>{VerboseOption,OutputFormatOption},
	SharedOptions:>{ExperimentCapillaryELISA}
];

ValidExperimentCapillaryELISAQ[mySamples:ListableP[ObjectP[{Object[Container],Object[Sample]}]|_String],myOptions:OptionsPattern[ValidExperimentCapillaryELISAQ]]:=Module[
	{listedOptions,preparedOptions,capillaryELISATests,initialTestDescription,allTests,verbose,outputFormat},

	(* Get the options as a list *)
	listedOptions=ToList[myOptions];

	(* Remove the output option before passing to the core function because it doesn't make sense here *)
	preparedOptions=DeleteCases[listedOptions,(Output|Verbose|OutputFormat)->_];

	(* Return only the tests for ExperimentCapillaryELISA *)
	capillaryELISATests=ExperimentCapillaryELISA[mySamples,Append[preparedOptions,Output->Tests]];

	(* Define the general test description *)
	initialTestDescription="All provided options and inputs match their provided patterns (no further testing can proceed if this test fails).";

	(*Make a list of all of the tests, including the blanket test *)
	allTests=If[MatchQ[capillaryELISATests,$Failed],
		{Test[initialTestDescription,False,True]},
		Module[
			{initialTest,validObjectBooleans,voqWarnings,testResults},

			(* Generate the initial test, which we know will pass if we got this far (hopefully) *)
			initialTest=Test[initialTestDescription,True,True];

			(* Create warnings for invalid objects *)
			validObjectBooleans=ValidObjectQ[DeleteCases[ToList[mySamples],_String],OutputFormat->Boolean];

			voqWarnings=MapThread[
				Warning[StringJoin[ToString[#1,InputForm]," is valid (run ValidObjectQ for more detailed information):"],
					#2,
					True
				]&,
				{DeleteCases[ToList[mySamples],_String],validObjectBooleans}
			];

			(* Get all the tests/warnings *)
			Flatten[{initialTest,capillaryELISATests,voqWarnings}]
		]
	];

	(* Determine the Verbose and OutputFormat options; quiet the OptionValue::nodef message in case someone just passed nonsense *)
	{verbose,outputFormat}=Quiet[OptionDefault[OptionValue[{Verbose,OutputFormat}]],OptionValue::nodef];

	(* Run all the tests as requested *)
	Lookup[RunUnitTest[<|"ValidExperimentCapillaryELISAQ"->allTests|>,OutputFormat->outputFormat,Verbose->verbose],"ValidExperimentCapillaryELISAQ"]

];


(* ::Subsection:: *)
(*ExperimentCapillaryELISAPreview*)

DefineOptions[ExperimentCapillaryELISAPreview,
	SharedOptions:>{ExperimentCapillaryELISA}
];

ExperimentCapillaryELISAPreview[mySamples:ListableP[ObjectP[{Object[Container],Object[Sample]}]|_String],myOptions:OptionsPattern[ExperimentCapillaryELISAPreview]]:=Module[
	{listedOptions},

	listedOptions=ToList[myOptions];

	ExperimentCapillaryELISA[mySamples,ReplaceRule[listedOptions,Output->Preview]]
];
