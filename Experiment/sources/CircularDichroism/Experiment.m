(* ::Package:: *)

(* ::Text:: *)
(*\[Copyright] 2011-2023 Emerald Cloud Lab, Inc.*)


(* ::Section:: *)
(*Source Code*)


(* ::Subsection:: *)
(*ExperimentCircularDichroism*)


(* ::Subsubsection:: *)
(*Options*)


DefineOptions[ExperimentCircularDichroism,
	Options :> {

		(* Option for manual primitives. *)
		IndexMatching[
			IndexMatchingInput -> "experiment samples",
			{
				OptionName -> SampleLabel,
				Default -> Automatic,
				Description -> "A user defined word or phrase used to identify the samples that are being studied in ExperimentCircularDichroism, for use in downstream unit operations.",
				AllowNull -> False,
				Category -> "General",
				Widget -> Widget[
					Type -> String,
					Pattern :> _String,
					Size -> Line
				],
				UnitOperation -> True
			},
			{
				OptionName -> SampleContainerLabel,
				Default -> Automatic,
				Description -> "A user defined word or phrase used to identify the containers of the samples that are being studied in ExperimentCircularDichroism, for use in downstream unit operations.",
				AllowNull -> False,
				Category -> "General",
				Widget -> Widget[
					Type -> String,
					Pattern :> _String,
					Size -> Line
				],
				UnitOperation -> True
			}
		],
		{
			OptionName -> Instrument,
			Default -> Model[Instrument, PlateReader, "Ekko"], (* "id:mnk9jORmGjEw" *)
			Description -> "The plate reader that is used for measuring circular dichroism spectroscopy or circular dichroism intensity at specific wavelengths.",
			AllowNull -> False,
			Widget -> Widget[
				Type -> Object,
				Pattern :> ObjectP[{Model[Instrument, PlateReader], Object[Instrument, PlateReader]}]
			]
		},
		{
			OptionName -> PreparedPlate,
			Default -> False,
			Description -> "Indicates if the plate containing the samples for the CircularDichroism experiment has been previously prepared that does not need to run sample preparation steps.",
			AllowNull -> False,
			Widget -> Widget[Type -> Enumeration, Pattern :> BooleanP]
		},
		{
			OptionName -> RetainCover,
			Default -> False,
			Description -> "Indicates if the plate seal or lid on the assay container is left on during measurement to decrease evaporation. It is strongly recommended not to retain a cover because Circular Dichroism can only read from top.",
			AllowNull -> False,
			Widget -> Widget[Type -> Enumeration, Pattern :> BooleanP],
			Category -> "Optics"
		},
		{
			OptionName -> ReadPlate,
			Default -> Automatic,
			Description -> "The plate that is loaded with input samples then inserted into the CircularDichroism plater reader instrument.",
			AllowNull -> False,
			Widget -> Widget[
				Type -> Object,
				Pattern :> ObjectP[{Model[Container, Plate], Object[Container, Plate]}]
			],
			Category -> "Sample Preparation",
			ResolutionDescription -> "Is automatically set to Model[Container, Plate, \"Hellma Black Quartz Microplate\"]."    (*  "id:KBL5DvwJ0q4k"  *)
		},
		{
			OptionName -> NitrogenPurge,
			Default -> True,
			Description -> "Indicates if the experiment is run under purge with dry nitrogen gas to avoid condensation of ozone generated by the light source.",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Enumeration,
				Pattern :> BooleanP
			],
			Category -> "Data Processing"
		},
		{
			OptionName -> EmptyAbsorbance,
			Default -> False,
			Description -> "Indicates if a empty well will be scan to check the container's backgound signal at the begining of the experiment.",
			AllowNull -> False,
			Widget -> Widget[Type -> Enumeration, Pattern :> BooleanP],
			Category -> "Data Processing"
		},
		{
			OptionName -> BlankAbsorbance,
			Default -> True,
			Description -> "Indicates if blank samples are prepared to account for the background signal when reading absorbance of the assay samples.",
			AllowNull -> False,
			Widget -> Widget[Type -> Enumeration, Pattern :> BooleanP],
			Category -> "Data Processing"
		},
		IndexMatching[
			{
				OptionName -> Blanks,
				Default -> Automatic,
				AllowNull -> True,
				Widget -> Widget[Type -> Object, Pattern :> ObjectP[{Model[Sample], Object[Sample]}]],
				Description -> "The source used to generate a blank sample whose absorbance is subtracted as background from the absorbance readings of the input sample.",
				ResolutionDescription -> "Automatically set to Null if BlankAbsorbance is False, otherwise set to Model[Sample, \"Milli-Q water\"].",
				Category -> "Data Processing"
			},
			{
				OptionName -> BlankVolumes,
				Default -> Automatic,
				AllowNull -> True,
				Widget -> Widget[Type -> Quantity, Pattern :> RangeP[1 Microliter, 300 Microliter], Units -> {Microliter, {Microliter, Milliliter}}],
				Description -> "The volume of the blank that should be transferred out and used for blank measurements. Set BlankVolumes to Null to indicate blanks should be read inside their current containers.",
				ResolutionDescription -> "Automatically set to Null if BlankAbsorbance is False or to the SampleVolume of the samples if BlankAbsorbance is True.",
				Category -> "Data Processing"
			},
			IndexMatchingInput -> "experiment samples"
		],
		{
			OptionName -> ReadDirection,
			Default -> Row,
			Description -> "Indicate the plate path the instrument will follow as it measures circular dichroism absorbance in each well, for instance reading all wells in a row before continuing on to the next row (Row).",
			AllowNull -> True,
			Widget -> Widget[Type -> Enumeration, Pattern :> ReadDirectionP],
			Category -> "Data Processing"
		},
		{
			OptionName -> NumberOfReplicates,
			Default -> Automatic,
			Description -> "The number of times to repeat absorbance reading on each provided sample. If Aliquot -> True, this also indicates the number of times each provided sample will be aliquoted.",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Number,
				Pattern :> GreaterEqualP[1, 1]
			],
			Category -> "Sample Preparation"
		},
		{
			OptionName -> MoatSize,
			Default -> Automatic,
			Description -> "Indicates the number of concentric perimeters of wells to leave as empty or filled with MoatBuffer. Quartz plates have high birefringence in the outer ring of wells. So the circular dichroism data collected in the outer ring of wells have noise levels. With MoatSize == 2 (default value), the protocol will ignore the outer ring of wells in the plate.",
			AllowNull -> False,
			Widget -> Widget[Type -> Number, Pattern :> GreaterEqualP[0, 1]],
			Category -> "Sample Preparation",
			ResolutionDescription -> "Automatically set to 2 if ReadPlate is made by quartz (e.g. Model[Container, Plate, \"Hellma Black Quartz Microplate\"] and Object[Container,Plate] with this Model). Otherwise will resolve to 0."
		},
		{
			OptionName -> MoatBuffer,
			Default -> Automatic,
			Description -> "Indicates the sample to use to fill each moat well. If the moat well is intended to be empty, specify this option as Null.",
			ResolutionDescription -> "Automatically set to Null if RetainCover is False. Otherwise resolve to automatically Milli-Q water.",
			AllowNull -> True,
			Widget -> Widget[Type -> Object, Pattern :> ObjectP[{Object[Sample], Model[Sample]}]],
			Category -> "Sample Preparation"
		},
		{
			OptionName -> MoatVolume,
			Default -> Automatic,
			Description -> "Indicates the volume to add to to each moat well.",
			ResolutionDescription -> "Automatically set to the minimum volume of the assay plate if MoatBuffer is specified. Otherwise resolves to 0.",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Quantity,
				Pattern :> RangeP[1 Microliter, 300 Microliter],
				Units -> Microliter
			],
			Category -> "Sample Preparation"
		},
		{
			OptionName -> AverageTime,
			Default -> 1 Second,
			Description -> "The time on data collection for each measurment points. The collected data are averaged for this period of time and export as the result data point for this wavelength.",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Quantity,
				Pattern :> RangeP[0.06 Second, 18 Second],
				Units -> {Second, {Millisecond, Second}}
			],
			Category -> "Data Processing"
		},

		(*Enatiomeric Excess*)
		{
			OptionName -> EnantiomericExcessMeasurement,
			Default -> Automatic,
			Description -> "Indicates if the experiment will be used to determined enantiomeric excess of SamplesIn.",
			ResolutionDescription -> "Automatically set to False. Unless EnantiomericExcessWavelength or EnantiomericExcessStandards is specified by users.",
			AllowNull -> False,
			Widget -> Widget[Type -> Enumeration, Pattern :> BooleanP],
			Category -> "Enatiomeric Excess Measurement"
		},
		{
			OptionName -> EnantiomericExcessWavelength,
			Default -> Automatic,
			Description -> "Indicates if the wavelength will be used to determined enantiomeric excess of SamplesIn.",
			AllowNull -> True,
			Widget -> Alternatives[
					"Single" -> Widget[
						Type -> Quantity,
						Pattern :> RangeP[185 Nanometer, 850 Nanometer],
						Units -> Alternatives[Nanometer]
					],
					"Multiple" -> Adder[
						Widget[
							Type -> Quantity,
							Pattern :> RangeP[185 Nanometer, 850 Nanometer],
							Units -> Alternatives[Nanometer]
						],
						Orientation -> Vertical
					]
				],
			Category -> "Enatiomeric Excess Measurement",
			ResolutionDescription -> "Automatically set to Null if EnantiomericExcessMeasurement is set to False. For EnantiomericExcessMeasurement is True, If DetectionWavelength is specified as a list of single wavelengths, automatically set to the samme as DetectionWavelengh. Else, automatically set to the shortest wavelength specified in the input samples' ExtinctionCoefficients field, and 260 Nanometer if that field is not populated."
		},
		{
			OptionName -> EnantiomericExcessStandards,
			Default -> Automatic,
			Description -> "Indicate samples with a known EnantiomericExcess values and the corresponding value. Preferrable to have optical pure isomers (with +100% and -100% in enantiomeric excess) and one racemic sample (0% in enantiomeric excess). The blank sample can be used as the racemic sample. Will throw an error message if not enough sample (<=3) is specified as SamplesIn.",
			AllowNull -> True,
			Widget -> Adder[
				{
					"Sample" -> Alternatives[
						Widget[
							Type -> Object,
							Pattern :> ObjectP[{Object[Sample], Model[Sample]}],
							ObjectTypes -> {Object[Sample]}
						],
						Widget[
							Type -> Enumeration,
							Pattern :> Alternatives[Automatic]
						]
					],
					"Enantiomeric Excess Value" -> Alternatives[
						Widget[
							Type -> Quantity,
							Pattern :> RangeP[-100Percent, 100Percent],
							Units -> Alternatives[Percent]
						],
						Widget[
							Type -> Enumeration,
							Pattern :> Alternatives[Automatic]
						]
					]
				},
				Orientation -> Horizontal
			],
			Category -> "Enatiomeric Excess Measurement",
			ResolutionDescription -> "Automatically set to Null if EnantiomericExcessMeasurement is set to False. If EnantiomericExcessMeasurement is True, the first two SamplesIn will be set as Sample, with -100% and 100% Enantiomeric Excess Value, respectively. The blank sample (if any) or the 3rd SamplesIn will be set as the Sample with 0% Enantiomeric Excess Value."
		},

		IndexMatching[
			{
				OptionName -> SampleVolume,
				Default -> Automatic,
				Description -> "The volume that is taken from each input sample and aliquoted onto the read plate.",
				AllowNull -> False,
				Category -> "Sample Preparation",
				Widget -> Widget[
					Type -> Quantity,
					Pattern :> RangeP[50 Microliter, 2000 Microliter],
					Units -> {Microliter, {Microliter, Milliliter}}
				],
				ResolutionDescription -> "Is automatically set based on the smallest volume value of all SamplesIn and the RecommendedFillVolume of the ReadPlate, whichever is smaller."
			},
			{
				OptionName -> CalculatingMolarEllipticitySpectrum,
				Default -> Automatic,
				AllowNull -> False,
				Description -> "Decide if the data will be transfered to molar ellipticity after the protocol is finished. If True, the Analyte and AnalyteConcentration option will set a single value for each of SamplesIn.",
				ResolutionDescription -> "If the analyte concentration is specified, this option resolved to True, otherwise resolve to False.",
				Widget -> Widget[Type -> Enumeration, Pattern :> BooleanP],
				Category -> "Sample Preparation"
			},
			{
				OptionName -> Analyte,
				Default -> Automatic,
				Description -> "The compound of interest that is present in the given samples, will be used to determine the other settings for the plate reader (e.g. DetectionWavelength) and will be used to caluclate the molar epplicity.",
				ResolutionDescription -> "If populated, will set to the fist user-specified Analyte field in the Object[Sample]. Otherwise, will set to the fist larger compounds in the sample, in the order of Proteins, Peptides, Oligomers, then other small molecules. Otherwise, set Null.",
				AllowNull -> True,
				Widget -> Widget[Type -> Object, Pattern :> ObjectP[IdentityModelTypes]],
				Category -> "Sample Information"
			},
			{
				OptionName -> AnalyteConcentrations,
				Default -> Automatic,
				Description -> "The known concentration of the Analyte for each of the SamplesIn.",
				ResolutionDescription -> "Automatically set to the based on the concentration of Analyte, if any.",
				AllowNull -> True,
				Widget -> Widget[Type -> Quantity,
					Pattern :> GreaterP[0 Molar],
					Units -> Alternatives[Micromolar, Millimolar, Molar]
				],
				Category -> "Sample Information"
			},
			{
				OptionName -> DetectionWavelength,
				Default -> Automatic,
				Description -> "The specific wavelength(s) which should be used to measure absorbance in the samples.",
				AllowNull -> False,
				Widget -> Alternatives[
					"Single" -> Widget[
						Type -> Quantity,
						Pattern :> RangeP[185 Nanometer, 850 Nanometer],
						Units -> Alternatives[Nanometer]
					],
					"Range"  -> Span[
						Widget[
							Type -> Quantity,
							Pattern :> RangeP[185 Nanometer, 850 Nanometer],
							Units -> Alternatives[Nanometer]
						],
						Widget[
							Type -> Quantity,
							Pattern :> RangeP[185 Nanometer, 850 Nanometer],
							Units -> Alternatives[Nanometer]
						]
					],
					"Multiple" -> Adder[
						Widget[
							Type -> Quantity,
							Pattern :> RangeP[185 Nanometer, 850 Nanometer],
							Units -> Alternatives[Nanometer]
						],
						Orientation -> Vertical
					]
				],
				Category -> "Optics",
				ResolutionDescription -> "Automatically resolves based on the EnantiomericExcessWavelength first: If EnantiomericExcessWavelength is specified, resolved to be the same as EnantiomericExcessWavelength. If EnantiomericExcessWavelength is blank, this option resolves based on Analytes option: if Analytes are specified as biomacromolecules (Proteins, Peptides, Oligomers), resolves this option to Span[200 Nanometer, 400 Nanometer]; Else resolved to Span[300 Nanometer, 800 Nanometer]."
			},
			{
				OptionName -> StepSize,
				Default -> Automatic,
				Description -> "This option determines how often the spectrophotometer will record an circular dichroism absorbance measurement, if the sample was scanned in a range of wavelength. For example, a step size of 2 nanometer indicates that the spectrophotometer will collect circular dichroism absorbance data for every 2 nanometer within the wavelength range.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Quantity,
					Pattern :> RangeP[0.5 Nanometer, 5 Nanometer],
					Units -> Alternatives[Nanometer]
				],
				Category -> "Optics",
				ResolutionDescription -> "Automatically resolves to 1 Nanomer if the DetectionWavelength is resolved as a range values. Otherwise will resove to Null."
			},
			IndexMatchingInput -> "experiment samples"
		],
		{
			OptionName -> ContainerOut,
			Default -> Automatic,
			Description -> "The container in which the samples in the read plate are transferred into after the experiment.",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Object,
				Pattern :> ObjectP[{Model[Container], Object[Container]}],
				ObjectTypes -> {Model[Container], Object[Container]}
			],
			ResolutionDescription -> "Is automatically set to Null if the SamplesOutStorageCondition is set to Disposal. If the SamplesOutStorageCondition is not Disposal, this option resolves based on the reusability of the ReadPlate: if the ReadPlate is reusable (Reusability->True for its Model), this option resolved to be Null, otherwise is resolved to Model[Container,Plate,\"96-well 1mL Deep Well Plate\"].",
			Category -> "Post Experiment"
		},
		FuntopiaSharedOptions,
		SimulationOption,
		SamplesInStorageOptions,
		SamplesOutStorageOptions
	}
];


(* ::Subsubsection::Closed:: *)
(*ExperimentCircularDichroism Error Messages*)
Error::IncompatibleInstrumentForCircularDichroism = "The specified instrument `1` doesn't have the compatibility to measure circular dichroism. Please set an instrument with the model: `2`, or leave this option as default.";
Error::IncompatibleReadPlateForCircularDichroism = "The `1` will be used as the ReadPlate to be inserted into the plate reader for the measurement. However, its model is not compatible with circular dichroism measurement. Please choose a plate with one of these models, `2`, as the ReadPlate or for the prepared plate. Otherwise, please leave both ReadPlate and PreparedPlate as automatic.";
Error::CircularDichroismQuartzPlateCannotRetainCover = "The experiment will be conducted on `1`, which is a quartz plate, for now there is not a compatible lid for this type of plate for this experiment.";
Error::CircularDichroismDuplicateDestinationWell = "For ExperimentCircularDichroism, the specified DestinationWell cannot have duplicated members or constant member `1`. Please specify different DestinationWell for each input sample or allow this option to resolve automatically.";
Error::CircularDichroismInvalidDestinationWellLength = "For ExperimentCircularDichroism, the specified DestinationWell must be the same length as the number of all aliquots `1` (the number of input samples multipled by the specified NumberOfReplicates). Please change DestinationWell option to the correct length or allow this option to resolve automatically.";
Error::CircularDichroismContainerOutStorageConditionMismatch = "For samples `1`, their storage condition (SamplesOutStorageCondition) after the experiment are all Disposal, thereby the ContainerOut option can only be set to Null, for now it's  `2`.";
Error::CircularDichroismNeedMoreEnatiomericExcessStandards = "For ExperimentCircularDichroism, at least 2 EnantiomeritExcessStandards need to be specified to calculate the EnantiomericExcess results of sample. For now only `1` EnantiomeritExcessStandard is specified.";
Error::CircularDichroismUnknownEnatiomericExcessStandards = "For ExperimentCircularDichroism, the EnantiomericExcessStandards `1` are not existing in samples to be measured in this experiment `2`, please specify a sample that will be measured in this experiment.";
Error::CircularDichroismNeedMoreSamplesForEnantiomericExcessMeasurement = "For ExperimentCircularDichroism, to measure enantiomeric excess values, the SamplesIn needs at least 3 samples (2 standards, at lease 1 sample to be measure) to start the experiment.";
Error::CircularDichroismInvalidDetectionWavelength = "For ExperimentCircularDichroism, samples (`1`) can only be scanned in a wavelength ranges from a smaller wavelength to a larger wavelength, please switch these inputs `2` or leave this option as Automatic.";
Error::CircularDichroismDetectionWavelengthIncompatibleForReadPlate = "If using `1` as the ReadPlate, the data collected under 400 nanometer will be invalid due to very high signal. Please use a plate with model: Model[Container, Plate, \"Hellma Black Quartz Microplate\"] as the ReadPlate, or leave this option as Automatic.";
Error::CircularDichroismSampleVolumeNotValid = "For samples `1`, their volumes `2` are not in the range of allowed volumes for the ReadPlate (between `3` and `4`).";
Error::CircularDirchroismQuartzPlateNeedMoat = "If `1` is used as the ReadPlate, since it's a quartz plate, the outer layer wells suffer high birefringence leading to very high noise for circular dichroism measurement. Set MoatSize to `2` will use outer layer wells for the experiment, which will fail the data collection. Please set MoatSize >= 2 to avoid using those wells, or leave MoatSize to Automatic. ";
Error::CircularDichroismTooManySamples = "The experiment will scan `1` sample wells, `2` unique blank wells and `3` empty well. The total number of wells to be scanned, `4`, exceeded the allowed wells `5` on the plate when MoatSize is `6`. Please reduce the number of samples and set EmptyAbsorbance to False to reduce the total number of wells that need to be scanned and/or use the same blank for every scan. For blank sample, the experiment will run blanks with unique {Blanks, BlankVolumes, DetectionWavelength, StepSize} sets. Setting these parameters to be the same will reduce the number of Blanks run during the experiment. If MoatSize >2, consider setting MoatSize to 2 to allow more wells to be used for each experiment.";
Error::CircularDichroismUnNeededBlankOption = "For samples `1`, the options `2` can only be true if blanks scan are not desired (BlankAbsorbance->False). Please leave these options to Automatic.";
Error::CircularDichroismRequiredBlankOption = "For samples `1`, if blank scans are desired (BlankAbsorbance->True), options `2` cannot be Null. Please please specify these options with proper values or leave these options to Automatic.";
Warning::NeedConcentrationForMolarEllipticity = "For samples `1`, if calculating the molar ellipticity at every detection wavelength is desired, valid AnalyteConcentrations needs to be specified for the sample, the concentration `2` cannot be used to calculate molar ellipticity. ";
Warning::CircularDirchroismUnknownAnalytes = "For samples `1`, the analyte `2` are not present in sample models composition. Please make sure the specified Analyte is desired.";
Warning::CircularDichroismEnantiomericExcessWavelengthsNotCovered = "For samples `1`, its detection wavelengths `2` cannot fully cover its specified wavelengths for EnantiomericExcessWavelengths (`3`). Please use wavelengths that will be detected during the experiment (in the range of DetectionWavelength).";
Warning::CircularDichroismInconsistentAnalyteConcentration = "For samples `1`, the specified AnalyteConcentration `2` are not same as the concentrations `3` that are stored in samples' composition. Please double-check to make sure correct concentrations are specified.";

(* ::Subsubsection::Closed:: *)
(*ExperimentCircularDichroism (sample input)*)


(* --- Core Function --- *)
ExperimentCircularDichroism[mySamples: ListableP[ObjectP[Object[Sample]]], myOptions: OptionsPattern[ExperimentCircularDichroism]] := Module[
	{
		listedOptions, outputSpecification, output, gatherTests, messages, safeOptions, safeOptionTests, upload,
		updatedSimulation, protocolObject, confirm, fastTrack, parentProt, unresolvedOptions, unresolvedOptionsTests,
		combinedOptions, resolveOptionsResult, simulatedProtocol, simulation,	resolvedOptionsNoHidden, resourcePacket,
		frqTests, allTests, validQ, previewRule, optionsRule, testsRule, performSimulationQ, resolvedOptions, resolutionTests,
		returnEarlyQ, validLengths, validLengthTests, expandedCombinedOptions, cache, cacheBall, allPackets, listedSamples,
		validSamplePreparationResult, mySamplesWithPreparedSamples, myOptionsWithPreparedSamples, simulatedSamplesFields,
		simulatedSampleModelFields, simulatedSampleIdentityModelFields, uniqueBlankSamples, possibleAliquotContainers,
		allInstrumentModels, allSampleObjects, allSampleModels, allContainerObjects, allContainerModels,
		simulatedContainerFields, simulatedContainerModelFields
	},

	(* determine the requested return value from the function *)
	outputSpecification = Quiet[OptionDefault[OptionValue[Output]], OptionValue::nodef];
	output = ToList[outputSpecification];

	(* determine if we should keep a running list of tests; if True, then silence messages *)
	gatherTests = MemberQ[output, Tests];
	messages = Not[gatherTests];

	(* make sure we're working with a list of options and samples, and remove all temporal links *)
	{listedSamples, listedOptions} = sanitizeInputs[ToList[mySamples], ToList[myOptions]];


	(* Simulate our sample preparation. *)
	validSamplePreparationResult = Check[
		(* Simulate sample preparation. *)
		{mySamplesWithPreparedSamples, myOptionsWithPreparedSamples, updatedSimulation} = simulateSamplePreparationPacketsNew[
			ExperimentCircularDichroism,
			listedSamples,
			listedOptions
		],
		$Failed,
		{Error::MissingDefineNames, Error::InvalidInput, Error::InvalidOption}
	];

	(* If we are given an invalid define name, return early. *)
	If[MatchQ[validSamplePreparationResult, $Failed],
		(* Return early. *)
		(* Note: We've already thrown a message above in simulateSamplePreparationPackets. *)
		Return[$Failed]
	];

	(* call SafeOptions to make sure all options match pattern *)
	{safeOptions, safeOptionTests} = If[gatherTests,
		SafeOptions[ExperimentCircularDichroism, myOptionsWithPreparedSamples, Output -> {Result, Tests}, AutoCorrect -> False],
		{SafeOptions[ExperimentCircularDichroism, myOptionsWithPreparedSamples, AutoCorrect -> False], Null}
	];

	(* If the specified options don't match their patterns or if the option lengths are invalid, return $Failed*)
	If[MatchQ[safeOptions, $Failed],
		Return[outputSpecification /. {
			Result -> $Failed,
			Tests -> safeOptionTests,
			Options -> $Failed,
			Preview -> Null
		}]
	];

	(* call ValidInputLengthsQ to make sure all the options are the right length *)
	{validLengths, validLengthTests} = If[gatherTests,
		ValidInputLengthsQ[ExperimentCircularDichroism, {listedSamples}, listedOptions, Output -> {Result, Tests}],
		{ValidInputLengthsQ[ExperimentCircularDichroism, {listedSamples}, listedOptions], Null}
	];

	(* If option lengths are invalid return $Failed (or the tests up to this point) *)
	If[Not[validLengths],
		Return[outputSpecification /. {
			Result -> $Failed,
			Tests -> Flatten[{safeOptionTests, validLengthTests}],
			Options -> $Failed,
			Preview -> Null
		}]
	];

	(* get assorted hidden options *)
	{upload, confirm, fastTrack, parentProt, cache} = Lookup[safeOptions, {Upload, Confirm, FastTrack, ParentProtocol, Cache}];

	(* apply the template options *)
	(* need to specify the definition number (we are number 1 for samples at this point) *)
	{unresolvedOptions, unresolvedOptionsTests} = If[gatherTests,
		ApplyTemplateOptions[ExperimentCircularDichroism, {mySamplesWithPreparedSamples}, myOptionsWithPreparedSamples, 1, Output -> {Result, Tests}],
		{ApplyTemplateOptions[ExperimentCircularDichroism, {mySamplesWithPreparedSamples}, myOptionsWithPreparedSamples, 1, Output -> Result], Null}
	];

	(* If couldn't apply the template, return $Failed (or the tests up to this point) *)
	If[MatchQ[unresolvedOptions, $Failed],
		Return[outputSpecification /. {
			Result -> $Failed,
			Tests -> Flatten[{safeOptionTests, validLengthTests, unresolvedOptionsTests}],
			Options -> $Failed,
			Preview -> Null
		}]
	];

	(* combine the safe options with what we got from the template options *)
	combinedOptions = ReplaceRule[safeOptions, unresolvedOptions];

	(* expand the combined options *)
	expandedCombinedOptions = Last[ExpandIndexMatchedInputs[ExperimentCircularDichroism, {mySamplesWithPreparedSamples}, combinedOptions]];
	
	(* --- Get any options that will need to be used in the download call --- *)
	(* --- For now the only plate reader we can use is Model[Instrument, PlateReader, "Ekko"],"id:mnk9jORmGjEw" *)
	{$AllCDInstrumentModels, $AllCDPlateModels} = Search[
		{
			Model[Instrument,PlateReader],
			Model[Container, Plate]
		},
		{
			Deprecated != True && PlateReaderMode == CircularDichroism && DeveloperObject != True,
			Deprecated != True && WellBottom == FlatBottom && WellColor ==Clear && (Dimensions[[1]] < 0.13 Meter) && (Dimensions[[2]] < 0.09 Meter) && (Dimensions[[3]] < 0.015 Meter) && (ContainerMaterials == (Polystyrene | Quartz | Glass)) && CrossSectionalShape == Rectangle && (NumberOfWells == 96)
		}
	];
	
	(*Create download packet fields for simulatedSamples and the composition*)
	simulatedSamplesFields = Packet@@Flatten[{OpticalComposition, SamplePreparationCacheFields[Object[Sample]]}];
	simulatedSampleModelFields = Flatten[{StandardComponents, Acid, Base, Structure, PolymerType, Composition, OpticalComposition, SamplePreparationCacheFields[Model[Sample]]}];
	simulatedContainerFields = Flatten[{SamplePreparationCacheFields[Object[Container]]}];
	simulatedContainerModelFields = Flatten[{Reusability, SamplePreparationCacheFields[Model[Container]]}];
	simulatedSampleIdentityModelFields = {Molecule, MolecularWeight, StandardComponents, PolymerType, ExtinctionCoefficients, Chiral, Racemic, EnantiomerForms, RacemicForm, EnantiomerPair};
	
	(*Unique Blanks*)
	uniqueBlankSamples = DeleteDuplicates[Download[Cases[Lookup[listedOptions, Blanks], ObjectP[Object]], Object]];
	
	(* Get the container we'll use for any aliquots - either the user's or we'll default to first compatible *)
	possibleAliquotContainers = DeleteDuplicates[Cases[Flatten[Lookup[listedOptions, AliquotContainer], 1], ObjectP[]]];
	
	(*Reorganize Download Packet*)
	
	{
		allInstrumentModels,
		allSampleObjects,
		allSampleModels,
		allContainerObjects,
		allContainerModels
	} = Cases[DeleteDuplicates[Flatten[{
		(*1*)listedSamples,
		(*2*)$AllCDInstrumentModels,
		(*3*)$AllCDPlateModels,
		(*4*)ToList[Lookup[safeOptions, Instrument]/.Automatic -> {}],
		(*5*)ToList[Lookup[safeOptions, ReadPlate]/.Automatic -> {}],
		(*6*)uniqueBlankSamples,
		(*7*)possibleAliquotContainers
	}]], #]& /@ {
		ObjectP[Model[Instrument]],
		ObjectP[Object[Sample]],
		ObjectP[Model[Sample]],
		ObjectP[Object[Container]],
		ObjectP[Model[Container]]
	};
	

	allPackets = Check[
		Quiet[
			Download[
				{
					allSampleObjects,
					allSampleModels,
					allInstrumentModels,
					allContainerObjects,
					allContainerModels
				},
				{
					{(*1*)
						simulatedSamplesFields,
						Packet[Model[simulatedSampleModelFields]],
						Packet[Container[simulatedContainerFields]],
						Packet[Container[Model][simulatedContainerModelFields]],
						Packet[Composition[[All, 2]][simulatedSampleIdentityModelFields]],
						Composition[[All, 1]]
					},
					{(*2*)
						Packet@@simulatedSampleModelFields
					},
					(*3*){Packet[Object, Model, WettedMaterials, PlateReaderMode, Objects]},
					(*4*){Evaluate[Packet@@Flatten[{SamplePreparationCacheFields[Object[Container]]}]]},
					(*5*){Evaluate[Packet@@Flatten[{Reusability, SamplePreparationCacheFields[Model[Container]]}]]}
				},
				Date -> Now,
				Cache -> cache,
				Simulation -> updatedSimulation
			],
			{Download::FieldDoesntExist}
		],
		$Failed,
		{Download::ObjectDoesNotExist}
	];
	
	
	(* Return early if objects do not exist *)
	If[MatchQ[allPackets, $Failed],
		Return[$Failed]
	];

	(* Download information we need in both the Options and ResourcePackets functions *)
	cacheBall = FlattenCachePackets[{cache, allPackets}];

	(* resolve all options; if we throw InvalidOption or InvalidInput, we're also getting $Failed and we will return early *)
	resolveOptionsResult = Check[
		{resolvedOptions, resolutionTests} = If[gatherTests,
			resolveCircularDichroismOptions[mySamplesWithPreparedSamples, expandedCombinedOptions, Output -> {Result, Tests},Simulation -> updatedSimulation, Cache -> cacheBall],
			{resolveCircularDichroismOptions[mySamplesWithPreparedSamples, expandedCombinedOptions, Output -> Result, Simulation -> updatedSimulation, Cache -> cacheBall], Null}
		],
		$Failed,
		{Error::IncompatibleReadPlateForCircularDichroism, Error::InvalidInput, Error::InvalidOption}
	];

	(* remove the hidden options and collapse the expanded options if necessary *)
	(* need to do this at this level only because resolveAbsorbanceOptions doesn't have access to listedOptions *)
	resolvedOptionsNoHidden = CollapseIndexMatchedOptions[
		ExperimentCircularDichroism,
		RemoveHiddenOptions[ExperimentCircularDichroism, resolvedOptions],
		Ignore -> listedOptions,
		Messages -> False
	];

	(* run all the tests from the resolution; if any of them were False, then we should return early here *)
	(* need to do this becasue if we are collecting tests then the Check wouldn't have caught it *)
	(* basically, if _not_ all the tests are passing, then we do need to return early *)
	returnEarlyQ = Which[
		MatchQ[resolveOptionsResult, $Failed], True,
		gatherTests, Not[RunUnitTest[<|"Tests" -> resolutionTests|>, Verbose -> False, OutputFormat -> SingleBoolean]],
		True, False
	];

	(* Figure out if we need to perform our simulation. If so, we can't return early even though we want to because we *)
	(* need to return some type of simulation to our parent function that called us. *)
	performSimulationQ = MemberQ[output, Simulation] || MatchQ[$CurrentSimulation, SimulationP];

	(* if resolveOptionsResult is $Failed, return early; messages would have been thrown already *)
	(* If option resolution failed and we aren't asked for the simulation or output, return early. *)
	If[returnEarlyQ && !performSimulationQ,
		Return[outputSpecification/.{
			Result -> $Failed,
			Tests -> Join[safeOptionTests, validLengthTests, unresolvedOptionsTests, resolutionTests],
			Options -> RemoveHiddenOptions[ExperimentCircularDichroism, resolvedOptionsNoHidden],
			Preview -> Null,
			Simulation -> Simulation[]
		}]
	];

	(* call the circularDichroismResourcePackets function to create the protocol packets with resources in them *)
	(* if we're gathering tests, make sure the function spits out both the result and the tests; if we are not gathering tests, the result is enough, and the other can be Null *)
	{resourcePacket, frqTests} = If[returnEarlyQ,
		{$Failed, {}},
		If[gatherTests,
			circularDichroismResourcePackets[Download[mySamplesWithPreparedSamples, Object], unresolvedOptions, ReplaceRule[resolvedOptions, {Output -> {Result, Tests}, Simulation -> updatedSimulation}], Cache -> cacheBall],
			{circularDichroismResourcePackets[Download[mySamplesWithPreparedSamples, Object], unresolvedOptions, ReplaceRule[resolvedOptions, {Output -> Result, Simulation -> updatedSimulation}], Cache -> cacheBall], Null}
		]
	];

	(* If we were asked for a simulation, also return a simulation. *)
	(* should we use resolvedOptions or expandedCombinedOptions *)
	{simulatedProtocol, simulation} = If[performSimulationQ,
		simulateExperimentCircularDichroism[resourcePacket, ToList[mySamplesWithPreparedSamples], resolvedOptions, Cache -> cacheBall, Simulation -> updatedSimulation],
		{Null, Null}
	];

	(* --- Packaging the return value --- *)

	(* get all the tests together *)
	allTests = Cases[Flatten[{safeOptionTests, validLengthTests, unresolvedOptionsTests, resolutionTests, frqTests}], _EmeraldTest];

	(* figure out if we are returning $Failed for the Result option *)
	(* the tricky part is that if the Output option includes Tests _and_ Result, messages will be suppressed.
		Because of this, the Check won't catch the messages and go to $Failed, and so we need a different way to figure out if the Result call should be $Failed
		Doing this by doing RunUnitTest on the Tests; if it is False, Result MUST be $Failed *)
	validQ = Which[
		MatchQ[resourcePacket, $Failed], False,
		gatherTests && MemberQ[output, Result], RunUnitTest[<|"Tests" -> allTests|>, OutputFormat -> SingleBoolean, Verbose -> False],
		True, True
	];

	(* generate the Preview option; that is always Null *)
	previewRule = Preview -> Null;

	(* generate the options output rule *)
	optionsRule = Options -> If[MemberQ[output, Options],
		resolvedOptionsNoHidden,
		Null
	];

	(* generate the tests rule *)
	testsRule = Tests -> If[gatherTests,
		allTests,
		Null
	];

	(* If Result does not exist in the output, return everything without uploading *)
	If[!MemberQ[output, Result],
		Return[outputSpecification/.{
			Result -> Null,
			Tests -> allTests,
			Options -> RemoveHiddenOptions[ExperimentCircularDichroism, resolvedOptionsNoHidden],
			Preview -> Null,
			Simulation -> simulation
		}]
	];

	(* We have to return our result. Either return a protocol with a simulated procedure if SimulateProcedure\[Rule]True or return a real protocol that's ready to be run. *)
	protocolObject = Which[
		(* If there was a problem with our resource packets function or option resolver, we can't return a protocol. *)
		MatchQ[resourcePacket, $Failed] || MatchQ[resolveOptionsResult, $Failed],
		$Failed,

		(* Were we asked to simulate the procedure? *)
		MatchQ[Lookup[safeOptions, SimulateProcedure], True],
		circularDichroismResourcePackets[
			resourcePacket,
			Upload -> Lookup[safeOptions, Upload],
			Cache -> cacheBall,
			Simulation -> updatedSimulation
		],

		(* Otherwise, upload a real protocol that's ready to be run. *)
		True,
		UploadProtocol[
			resourcePacket,
			Upload -> Lookup[safeOptions, Upload],
			Confirm -> Lookup[safeOptions, Confirm],
			ParentProtocol -> Lookup[safeOptions, ParentProtocol],
			ConstellationMessage -> Object[Protocol, CircularDichroism],
			Priority -> Lookup[safeOptions, Priority],
			StartDate -> Lookup[safeOptions, StartDate],
			HoldOrder -> Lookup[safeOptions, HoldOrder],
			QueuePosition -> Lookup[safeOptions, QueuePosition],
			Simulation -> updatedSimulation
		]
	];
	(* Return requested output *)
	outputSpecification/.{
		Result -> protocolObject,
		Tests -> allTests,
		Options -> RemoveHiddenOptions[ExperimentCircularDichroism,resolvedOptionsNoHidden],
		Preview -> Null
	}
];



(* ::Subsubsection::Closed:: *)
(* ExperimentCircularDichroism (container input) *)


ExperimentCircularDichroism[myContainers: ListableP[ObjectP[{Object[Container], Object[Sample]}] | _String|{LocationPositionP, _String|ObjectP[Object[Container]]}], myOptions: OptionsPattern[ExperimentCircularDichroism]] := Module[
	{
		listedOptions, outputSpecification, output, gatherTests, containerToSampleResult, updatedSimulation, containerToSampleSimulation,
		containerToSampleTests, messages, listedContainers, validSamplePreparationResult, mySamplesWithPreparedSamples,
		myOptionsWithPreparedSamples, samples, sampleOptions, containerToSampleOutput
	},

	(* make sure we're working with a list of options *)
	listedOptions = ToList[myOptions];
	listedContainers = ToList[myContainers];

	(* determine the requested return value from the function *)
	outputSpecification = Quiet[OptionDefault[OptionValue[Output]], OptionValue::nodef];
	output = ToList[outputSpecification];

	(* deterimine if we should keep a running list of tests; if True, then silence messages *)
	gatherTests = MemberQ[output, Tests];
	messages = Not[gatherTests];
	
	
	(* First, simulate our sample preparation. *)
	validSamplePreparationResult = Check[
		(* Simulate sample preparation. *)
		{mySamplesWithPreparedSamples, myOptionsWithPreparedSamples, updatedSimulation} = simulateSamplePreparationPacketsNew[
			ExperimentCircularDichroism,
			ToList[myContainers],
			ToList[myOptions]
		],
		$Failed,
		{Error::MissingDefineNames, Error::InvalidInput, Error::InvalidOption}
	];

	(* If we are given an invalid define name, return early. *)
	If[MatchQ[validSamplePreparationResult, $Failed],
		(* Return early. *)
		(* Note: We've already thrown a message above in simulateSamplePreparationPackets. *)
		Return[$Failed]
	];

	(* Convert our given containers into samples and sample index-matched options. *)
	containerToSampleResult = If[gatherTests,
		(* We are gathering tests. This silences any messages being thrown. *)
		{containerToSampleOutput, containerToSampleTests, containerToSampleSimulation} = containerToSampleOptions[
			ExperimentCircularDichroism,
			mySamplesWithPreparedSamples,
			myOptionsWithPreparedSamples,
			Output -> {Result, Tests, Simulation},
			Simulation -> updatedSimulation
		];

		(* Therefore, we have to run the tests to see if we encountered a failure. *)
		If[RunUnitTest[<|"Tests"->containerToSampleTests|>, OutputFormat -> SingleBoolean, Verbose -> False],
			Null,
			$Failed
		],

		(* We are not gathering tests. Simply check for Error::InvalidInput and Error::InvalidOption. *)
		Check[
			{containerToSampleOutput,containerToSampleSimulation} = containerToSampleOptions[
				ExperimentCircularDichroism,
				mySamplesWithPreparedSamples,
				myOptionsWithPreparedSamples,
				Output-> {Result,Simulation},
				Simulation -> updatedSimulation
			],
			$Failed,
			{Error::EmptyContainer}
		]
	];

	(* If we were given an empty container, return early. *)
	If[MatchQ[containerToSampleResult,$Failed],
		(* containerToSampleOptions failed - return $Failed *)
		outputSpecification/.{
			Result -> $Failed,
			Tests -> containerToSampleTests,
			Options -> $Failed,
			Preview -> Null
		},
		(* Split up our containerToSample result into the samples and sampleOptions. *)
		{samples,sampleOptions} = containerToSampleOutput;

		(* Call our main function with our samples and converted options. *)
		ExperimentCircularDichroism[samples, ReplaceRule[sampleOptions, {Simulation -> containerToSampleSimulation}]]
	]
];


(* ::Subsubsection:: *)
(* resolveCircularDichroism Options *)

DefineOptions[resolveCircularDichroismOptions,
	Options :> {HelperOutputOption, CacheOption}
];

(* Main option resolve function *)
resolveCircularDichroismOptions[mySamples: {ObjectP[Object[Sample]]...}, myExperimentOptions: {_Rule...}, myResolutionOptions: OptionsPattern[resolveCircularDichroismOptions]] := Module[
	{
		aliquotConflictBooleans, aliquotContainerModelPacket, aliquotContainerPackets, aliquotContainerTest, aliquotRequired,
		aliquotWarningMessage, allAllowedInstrumentModelPackets, allAllowedPlateDownloadFields, allAllowedPlateDownloads,
		allAllowedPlatePackets, allBlankPacket, allPlatesDownloadFields, allTests, automaticAliquotingBooleans, automaticAliquotingQ,
		averageTime, blankAbsorbance, blankObjects, allSampleVolumes, blankSamplePackets,blanksInvalidOptions, blanksInvalidTest,
		cache, cannotalculatingMolarEllipticityBools,cannotalculatingMolarEllipticityTests, circularDichroismOptionAssoc,
		compatibleMaterialsBool, compatibleMaterialsInvalidOption, compatibleMaterialsTests, containersOutMismatchQ,
		containersOutMismatchInvalidOptions, containersOutStorageConditionTests, detectionWavelengthReadPlateIncompatibleBools,
		detectionWavelengthReadPlateIncompatibleTests, discardedInvalidInputs, discardedSamplePackets, discardedTests,
		duplicateDestinationWellOption, duplicateDestinationWells, duplicateDestinationWellTest, duplicateSampleError,
		eeStandardSamples, eeStandardValues, email, emptyAbsorbance, firstAliquotContainer, firstAliquotContainerModel,
		gatherTests, incompatibleMoatSizeForQuartzPlateOptions, inconsistentConcentrationBools, instrument, instrumentDownloadField,
		instrumentModel, instrumentModelPacket, instrumentPacket, invalidAliquotContainerOption, invalidAnalytBools,
		invalidAnalyteTests, invalidDestinationWellLengthOption, invalidDestinationWellLengthQ, invalidDestinationWellLengthTest,
		invalidDetectionWavelengthBools, invalidDetectionWavelengthOptions, invalidDetectionWavelengthTests,
		invalidEEstandardsOptions, invalidInputs, invalidInstrumentOptions, invalidInstrumentTest, invalidMoatOptions, invalidOptions,
		invalidReadPlateOptions, invalidReadPlateTest, invalidRepeatSamples, invalidRetainCoverOption, invalidSampleVolumeBools,
		invalidSampleVolumeOptions, invalidSampleVolumeTests, liquidSampleBooleanlist, messages, moatTests, moatWells, name,
		nameInvalidOptions, needMoreEEStandardsQ, needMoreEEStandardsTest, needMoreSamplesForEEOptions, needMoreSamplesForEETests,
		needMoreSamplesQ, nitrogenPurge, nonLiquidSampleInputs, tooManySampleTests, nonLiquidSamplePackets, notQuratzReadPlateQ,
		numberOfAliquotContainers, availableAssayWells, numberOfSamplesToRun, numOfEmpty, numOfUniqueBlanks, optionPrecisionTests,
		output, outputSpecification, outsideEngine, parentProt, plateWells, possibleAliquotContainers, preparedPlate,
		preresolvedAliquotOptions, quartzPlateNeedMoatQ, quartzPlateNeedMoatTests, quartzPlateRecommendMoatSize,
		quartzPlateRetainCoverIncompatibleQ, quartzPlateRetainCoverTests, readDirection, readPlateDownloadField,
		readPlateMaterial, readPlateMaxVolume, readPlateMinVolume, readPlateRecommendedFillVolume, readPlateRecommendedFillVolumeNotNull,
		readplateReusability, requiredAliquotAmounts, requiredAliquotContainers, requiredBlankBools, requiredBlankOptionList,
		requiredBlankOptions, requiredBlankTests, resolveAliquotOptionsTests, resolvedAliquotBooleans, resolvedAliquotOptions,
		resolvedAnalytes, resolvedAnalytesConcentrations, resolvedBlanks, resolvedBlankVolumes,analyteKnownCleanedConcentrations,
		resolvedCalculatingMolarEllipticitySpectrums, resolvedConsolidateAliquots, resolvedContainerOut, resolvedDestinationWells,
		resolvedDetectionWavelengths, resolvedEEStandardSamples, resolvedEnantiomericExcessMeasurement, resolvedEnantiomericExcessStandards,
		resolvedEnantiomericExcessWavelength, resolvedMoatBuffer, resolvedMoatSize, resolvedMoatVolume, resolvedNumReplicates,
		resolvedOptions, resolvedPostProcessingOptions, resolvedPrepOptions, resolvedReadPlate, resolvedReadPlateModel,
		resolvedReadPlateModelPacket, resolvedSampleVolumes, resolvedStepSizes, resultRule, retainCover,
		roundCircularDichroismOptions, sampleDownloadPacket, sampleEEList, sampleEEPacket, samplePlateModel, samplePrepTests,
		samplesOutStorageCondition, separateSamplesAndBlanksQ, simulatedSampleContainerModels, simulatedSampleContainerObjects,
		simulatedSampleContainerPackets, simulatedSampleEEList, simulatedSampleIdentityConcentrations, simulatedSampleIdentityModelFields,
		simulatedSampleIdentityPacket, simulatedSampleModelEEList, simulatedSampleModelFields, simulatedSampleModelPackets,
		simulatedSampleObject, simulatedSamplePackets, simulatedSamples, simulatedSamplesFields, stepSizeWavelengthIncompatibleBools,
		suppliedAliquotBooleans, suppliedAliquotContainers, suppliedAliquotVolumes, suppliedAnalyte, suppliedAnalyteConcentrations,
		suppliedAssayBuffers, suppliedAssayVolumes, suppliedBlanks, suppliedBlankVolumes, suppliedCalculatingMolarEllipticitySpectrum,
		suppliedConsolidateAliquots, suppliedContainerOut, suppliedDestinationWells, suppliedDetectionWavelength,
		suppliedEnantiomericExcessMeasurement, suppliedEnantiomericExcessStandards, suppliedEnantiomericExcessWavelength,
		suppliedMoatBuffer, suppliedMoatSize, suppliedMoatVolume, suppliedNumberOfReplicates, suppliedReadPlate,
		suppliedReadPlateModel, suppliedReadPlatePacket, suppliedSampleVolume, suppliedStepSize, suppliedTargetConcentrationAnalytes,
		suppliedTargetConcentrations, testsRule, tooManyAliquotContainers, tooManySamplesQ, tooManySourceContainersQ,
		totalNumSamples, transferredResolvedDestinationWells, truncatedEEList, uniqueBlankSamples, uniqueBlankTuples,
		uniqueContainers, unknownEEStandardsQ, unknownEEStandardsTest, unNeededBlankBools, unNeededBlankOptionList, unNeededBlankOptions,
		unNeededBlankTests, unresolvedExperimentOptions, unresolvedPrepOptions, validAliquotPlateQ, validEEValuePacket,
		validInstrumentQ, validNameQ, validNameTest, validReadPlateQ, preresolvedAliquots, simulation, tooManySamplesInvalidOptions,
		inValidEEWavelengthWarningQs, inconsistentConcentrationTests, updatedSimulation, resolvedSampleLabel, resolvedSampleContainerLabel
	},


	(* --- Setup our user specified options and cache --- *)

	(* determine the requested return value from the function *)
	outputSpecification = Quiet[OptionDefault[OptionValue[Output]], OptionValue::nodef];
	output = ToList[outputSpecification];


	(* determine if we should keep a running list of tests; if True, then silence messages *)
	gatherTests = MemberQ[output, Tests];
	messages = Not[gatherTests];

	(* Check if we are in Engine front end *)
	outsideEngine = !MatchQ[$ECLApplication, Engine];

	(* Fetch our options cache from the parent function *)
	cache = Lookup[ToList[myResolutionOptions], Cache, {}];

	(* Fetch our simulation from the parent function *)
	simulation = Lookup[ToList[myResolutionOptions],Simulation];

	(* --- Resolving Shared Options --- *)
	{unresolvedPrepOptions, unresolvedExperimentOptions} = splitPrepOptions[myExperimentOptions];

	(* Make sure the experiment function option is a list*)
	circularDichroismOptionAssoc = Association[unresolvedExperimentOptions];

	(* Stash the parent protocol if there is one *)
	parentProt = Lookup[circularDichroismOptionAssoc, ParentProtocol, Null];

	(* Round all number input options*)
	{roundCircularDichroismOptions, optionPrecisionTests} = If[gatherTests,
		RoundOptionPrecision[
			circularDichroismOptionAssoc,
			{
				(*1*)BlankVolumes,
				(*2*)MoatVolume,
				(*3*)AverageTime,
				(* Gain,*)
				(*5*)EnantiomericExcessWavelength,
				(*6*)SampleVolume,
				(*7*)DetectionWavelength,
				(*8*)StepSize,
				(*9*)AnalyteConcentrations
			},
			{
				(*1*)0.1Microliter,
				(*2*)0.1Microliter,
				(*3*)0.1Second,
				(* 0.1Volt, *)
				(*5*)1Nanometer,
				(*6*)0.1Microliter,
				(*7*)1Nanometer,
				(*8*)1Nanometer,
				(*9*)0.1Microliter
			}, Output -> {Result, Tests}],
		{
			RoundOptionPrecision[
				circularDichroismOptionAssoc,
				{
					(*1*)BlankVolumes,
					(*2*)MoatVolume,
					(*3*)AverageTime,
					(* Gain,*)
					(*5*)EnantiomericExcessWavelength,
					(*6*)SampleVolume,
					(*7*)DetectionWavelength,
					(*8*)StepSize,
					(*9*)AnalyteConcentrations
				},
				{
					(*1*)0.1 Microliter,
					(*2*)0.1Microliter,
					(*3*)0.1Second,
					(* 0.1Volt, *)
					(*5*)1Nanometer,
					(*6*)0.1Microliter,
					(*7*)1Nanometer,
					(*8*)1Nanometer,
					(*9*)0.1Microliter
				}
			],
			Null
		}
	];

	(* Lookup aliquot relevant options *)
	{
		(*1*)suppliedAliquotBooleans,
		(*2*)suppliedAliquotVolumes,
		(*3*)suppliedAssayVolumes,
		(*4*)suppliedTargetConcentrations,
		(*5*)suppliedAssayBuffers,
		(*6*)suppliedAliquotContainers,
		(*7*)suppliedConsolidateAliquots,
		(*8*)suppliedTargetConcentrationAnalytes,
		(*9*)suppliedDestinationWells
	} = Lookup[
		unresolvedPrepOptions,
		{
			(*1*)Aliquot,
			(*2*)AliquotAmount,
			(*3*)AssayVolume,
			(*4*)TargetConcentration,
			(*5*)AssayBuffer,
			(*6*)AliquotContainer,
			(*7*)ConsolidateAliquots,
			(*8*)TargetConcentrationAnalyte,
			(*9*)DestinationWell
		}
	];
	(* ---Extract options to variables---*)

	(* Extract the experiment functions that needs to be resolved *)
	{
		(*1*)suppliedReadPlate,
		(*2*)suppliedContainerOut,
		(*3*)suppliedBlanks,
		(*4*)suppliedBlankVolumes,
		(*5*)suppliedNumberOfReplicates,
		(*6*)suppliedMoatSize,
		(*7*)suppliedMoatBuffer,
		(*8*)suppliedMoatVolume,
		(*9*)suppliedEnantiomericExcessMeasurement,
		(*10*)suppliedEnantiomericExcessWavelength,
		(*11*)suppliedEnantiomericExcessStandards,
		(*12*)suppliedSampleVolume,
		(*13*)suppliedCalculatingMolarEllipticitySpectrum,
		(*14*)suppliedAnalyte,
		(*15*)suppliedAnalyteConcentrations,
		(*16*)suppliedDetectionWavelength,
		(*17*)suppliedStepSize
	} = Lookup[roundCircularDichroismOptions,
		{
			(*1*)ReadPlate,
			(*2*)ContainerOut,
			(*3*)Blanks,
			(*4*)BlankVolumes,
			(*5*)NumberOfReplicates,
			(*6*)MoatSize,
			(*7*)MoatBuffer,
			(*8*)MoatVolume,
			(*9*)EnantiomericExcessMeasurement,
			(*10*)EnantiomericExcessWavelength,
			(*11*)EnantiomericExcessStandards,
			(*12*)SampleVolume,
			(*13*)CalculatingMolarEllipticitySpectrum,
			(*14*)Analyte,
			(*15*)AnalyteConcentrations,
			(*16*)DetectionWavelength,
			(*17*)StepSize
		}
	];

	(* Extract the experiment functions that don't need to be resolved *)
	{
		(*1*)instrument,
		(*2*)preparedPlate,
		(*3*)retainCover,
		(*4*)nitrogenPurge,
		(*5*)emptyAbsorbance,
		(*6*)blankAbsorbance,
		(*7*)readDirection,
		(*8*)averageTime,
		(*9*)samplesOutStorageCondition,
		(*10*)name
	} = Lookup[roundCircularDichroismOptions,
		{
			(*1*)Instrument,
			(*2*)PreparedPlate,
			(*3*)RetainCover,
			(*4*)NitrogenPurge,
			(*5*)EmptyAbsorbance,
			(*6*)BlankAbsorbance,
			(*7*)ReadDirection,
			(*8*)AverageTime,
			(*9*)SamplesOutStorageCondition,
			(*10*)Name
		}
	];

	(* --- Resolve Sample Prep Options --- *)
	{{simulatedSamples, resolvedPrepOptions, updatedSimulation}, samplePrepTests} = If[gatherTests,
		resolveSamplePrepOptionsNew[ExperimentCircularDichroism, mySamples, unresolvedPrepOptions, Cache -> cache, Simulation -> simulation, Output -> {Result, Tests}],
		{resolveSamplePrepOptionsNew[ExperimentCircularDichroism, mySamples, unresolvedPrepOptions, Cache -> cache, Simulation -> simulation, Output -> Result], {}}
	];

	(*Create download packet fields for simulatedSamples and the composition*)
	simulatedSamplesFields = Packet@@Flatten[{OpticalComposition, SamplePreparationCacheFields[Object[Sample]]}];
	simulatedSampleModelFields = Flatten[{StandardComponents, Acid, Base, Structure, PolymerType, Composition, OpticalComposition, SamplePreparationCacheFields[Model[Sample]]}];
	simulatedSampleIdentityModelFields = {Molecule, MolecularWeight, StandardComponents, PolymerType, ExtinctionCoefficients, Chiral, Racemic, EnantiomerForms, RacemicForm, EnantiomerPair};

	(*Create a download fields for allowed plates*)
	allPlatesDownloadFields = {ContainerMaterials, MaxVolume};

	(*Generate download content to find out the instrument model*)
	instrumentDownloadField = If[MatchQ[instrument, ObjectP[Model[Instrument]]], Object, Model[Object]];

	(*Generate download content to find out the ReadPlate model*)
	readPlateDownloadField = If[MatchQ[suppliedReadPlate, ObjectP[Model[Container, Plate]]], Object, Model[Object]];

	(*Generate download field for all allowed plate*)
	allAllowedPlateDownloadFields = {Object, ContainerMaterials, MinVolume ,MaxVolume, RecommendedFillVolume, NumberOfWells, AspectRatio, Reusability};

	(*Unique Blanks*)
	uniqueBlankSamples = DeleteDuplicates[Download[Cases[Lookup[roundCircularDichroismOptions, Blanks], ObjectP[Object]] ,Object]];

	(* Get the container we'll use for any aliquots - either the user's or we'll default to first compatible *)
	possibleAliquotContainers = DeleteDuplicates[Cases[Flatten[Lookup[unresolvedPrepOptions, AliquotContainer], 1], ObjectP[]]];

	(* --- Assemble the download call --- *)

	{
		(*1*)sampleDownloadPacket,
		(*2*)allAllowedInstrumentModelPackets,
		(*3*)allAllowedPlateDownloads,
		(*4*)instrumentModelPacket,
		(*5*)suppliedReadPlatePacket,
		(*6*)allBlankPacket,
		(*7*)aliquotContainerPackets
	} = Quiet[
		Download[
			{
				(*1*)simulatedSamples,
				(*2*)$AllCDInstrumentModels,
				(*3*)$AllCDPlateModels,
				(*4*)ToList[instrument],
				(*5*)ToList[suppliedReadPlate/.Automatic->{}],
				(*6*)uniqueBlankSamples,
				(*7*)possibleAliquotContainers
			},
			{
				{(*1*)
					simulatedSamplesFields,
					Packet[Model[simulatedSampleModelFields]],
					Packet[Container[Model]],
					Packet[Composition[[All, 2]][simulatedSampleIdentityModelFields]],
					Composition[[All, 1]]
				},
				(*2*){Packet[PlateReaderMode,Objects]},
				(*3*){Packet[Object, ContainerMaterials, MinVolume, MaxVolume, RecommendedFillVolume, NumberOfWells, AspectRatio, Reusability]},
				(*4*){Packet[Object, Model]},
				(*5*){Packet[Object, Model]},
				(*6*){Packet[Container], Packet[Container[{Model}]], Packet[Container[Model][{MaxVolume}]]},
				(*7*){Evaluate[Packet @@ Flatten[{SamplePreparationCacheFields[Model[Container]], Model}]]}
			},
			Date -> Now,
			Cache -> FlattenCachePackets[{cache}],
			Simulation -> updatedSimulation
		],
		{Download::FieldDoesntExist, Download::NotLinkField}
	];

	(* Extract the information from the download packet*)
	simulatedSamplePackets=sampleDownloadPacket[[All,1]];
	simulatedSampleModelPackets=sampleDownloadPacket[[All,2]];

	(* Sample Container Model*)
	simulatedSampleContainerPackets=sampleDownloadPacket[[All,3]];

	(*Sample Identity packet*)
	simulatedSampleIdentityPacket=sampleDownloadPacket[[All,4]];
	simulatedSampleIdentityConcentrations=sampleDownloadPacket[[All,5]];

	(* Collet the plate model info, will check if user-specified plate is compatible*)
	samplePlateModel=Lookup[sampleDownloadPacket[[All,3]],Model];

	(* Flatten all allowed plate packet and extract all allowed plate model object *)
	allAllowedPlatePackets=Flatten[allAllowedPlateDownloads];

	(*Extract blank sample*)
	blankSamplePackets=allBlankPacket[[All,1]];

	(* extract aliquot model container packet *)
	aliquotContainerModelPacket = aliquotContainerPackets[[All,1]];

	(* Fetch instrument model *)
	instrumentModel=If[MatchQ[instrument,ObjectP[Model[Instrument]]],
		Download[instrument,Object],
		Download[Lookup[fetchPacketFromCache[Download[instrument,Object],Flatten[instrumentModelPacket]],Model],Object]
	];

	(*Simulated Sample Containers*)
	simulatedSampleContainerObjects=Lookup[simulatedSampleContainerPackets,Object];
	simulatedSampleContainerModels=Download[Lookup[simulatedSampleContainerPackets,Model],Object];


	(* --- Check if input is valid. ---*)

	(*--- DISCARDED SAMPLES ARE NOT OK ---*)

	(* Get the samples from samplePackets that are discarded. *)
	discardedSamplePackets=Cases[simulatedSamplePackets,KeyValuePattern[Status->Discarded]];

	(* Set discardedInvalidInputs to the input objects whose statuses are Discarded *)
	discardedInvalidInputs=If[MatchQ[discardedSamplePackets,{}],{},Lookup[discardedSamplePackets,Object]];

	(* If there are invalid inputs and we are throwing messages,throw an error message and keep track of the invalid inputs.*)
	If[Length[discardedInvalidInputs]>0&&messages,
		Message[Error::DiscardedSamples,ObjectToString[discardedInvalidInputs,Cache->cache]]
	];

	(* Create a test for the valid samples and one for the invalid samples *)
	discardedTests=sampleTests[gatherTests,Test,simulatedSamplePackets,discardedSamplePackets,"The input samples `1` are not discarded:",cache];

	(*--- Check if we have solid samples, throw warning to them*)
	(* Get the samples that are not liquids, we can't do mass spec on those *)

	liquidSampleBooleanlist=Map[
		MatchQ[Lookup[#1,State],Alternatives[Liquid,Null]]&,
		simulatedSamplePackets
	];

	(* Check the non liquid sample packets*)
	nonLiquidSamplePackets= PickList[simulatedSamplePackets,liquidSampleBooleanlist,False];
	(* Keep track of samples that are not liquid *)
	nonLiquidSampleInputs=PickList[simulatedSamples,liquidSampleBooleanlist,False];

	(*--- Check if instrument is compatible for Cicrular Dichroism ---*)
	validInstrumentQ=MemberQ[$AllCDInstrumentModels,instrumentModel];

	(* Throw an error message if user specified incompatible instrument*)
	If[!validInstrumentQ&&messages,
		Message[Error::IncompatibleInstrumentForCircularDichroism,ToString[instrument],ToString[$AllCDInstrumentModels]]
	];
	(*Return Instrument as invalid option if the supplied Instrument is incompatible*)
	invalidInstrumentOptions=If[!validInstrumentQ,{Instrument},{}];

	(*Build a test for Instrument*)
	invalidInstrumentTest=If[gatherTests,
		Test["The Instrument is compatible for measureing circular dichroism :",validInstrumentQ,True]
	];

	(*Collect intrument packetet*)
	instrumentPacket = fetchPacketFromCache[instrumentModel,Flatten[allAllowedInstrumentModelPackets]];

	(* --- Check to make sure there are no input samples in the Blanks field *)

	(* make sure there are no blanks that are also samples *)
	(* note that in this case I am deliberately NOT using simulated samples since this depends on what the user specifies for the blanks vis a vis the samples they specify *)
	separateSamplesAndBlanksQ = If[MatchQ[Lookup[roundCircularDichroismOptions, Blanks], ListableP[Null | Automatic] | {}],
		True,
		ContainsNone[Lookup[blankSamplePackets,Object,{}], Lookup[simulatedSamplePackets, Object]]
	];

	(* generate tests for cases where some of the specified samples are also the specified blanks *)
	blanksInvalidTest = If[gatherTests,
		{Test["None of the provided samples are also provided as Blanks:",
			separateSamplesAndBlanksQ,
			True
		]},
		Null
	];

	(* throw an error if SamplesIn are also appearing in Blanks *)
	(* note that we are returning $Failed below because we need _something_ for the resolved options *)
	blanksInvalidOptions = If[Not[separateSamplesAndBlanksQ] && messages,
		(
			Message[Error::BlanksContainSamplesIn, ObjectToString[Select[Lookup[samplePackets, Object], MemberQ[Lookup[blankSamplePackets, Object], #]&], Cache -> cache]];
			{Blanks}
		),
		{}
	];

	(* Convert any links/names to objects for fair comparison *)
	numberOfAliquotContainers = Length[
		DeleteCases[
			DeleteDuplicates[
				Replace[suppliedAliquotContainers, {{id_Integer, object: ObjectP[]} :> {id, Download[object, Object]}, object: ObjectP[] :> Download[object, Object]}, {1}]
			],
			Automatic
		]
	];

	(* If we're aliquoting some samples we can go wrong is if:
		Aliquot->False for some samples, Aliquot->True for others (or something like AliquotAmount->Null, but we'll ignore and use error thrown by resolveAliquotOptions when we send in Aliquot->True)
		If AliquotContainer -> multiple distinct containers
		If there are multiple unique containers and Aliquot->False in some cases
	*)
	tooManyAliquotContainers = Or[
		(* If user is specifying aliquots they can only request a single unique container *)
		numberOfAliquotContainers > 1,

		(* Can't request some sample be aliquoted and others not *)
		MemberQ[suppliedAliquotBooleans, True] && MemberQ[suppliedAliquotBooleans, False],

		(* If we have more than one container in play then somethings are set to be aliquoted or there are multiple sources *)
		(* In either case these then means everything must be aliquotted *)
		MemberQ[suppliedAliquotBooleans, False] && Length[uniqueContainers] > 1
	];

	(*Throw error messages if user specified too many aliquot containers*)
	If[messages && tooManyAliquotContainers, Message[Error::SinglePlateRequired]];

	(* Create tests but wait to throw our messages until we've done some final error checking post resolution *)
	aliquotContainerTest = If[gatherTests,
		Test["All samples are in a single supported container or are set to be aliquoted into a single supported container:", tooManyAliquotContainers, False]
	];

	(*invalidOptions*)
	invalidAliquotContainerOption = If[tooManyAliquotContainers, AliquotContainer, {}];

	firstAliquotContainer = FirstOrDefault[suppliedAliquotContainers, {}];

	(* Here since we only allowed one aliquot container (plate) so for checking aliquot container model, we will only use the first one. *)
	firstAliquotContainerModel = If[MatchQ[firstAliquotContainer, ObjectP[Model[Container, Plate]]],
		Download[firstAliquotContainer, Object],
		Download[Lookup[fetchPacketFromCache[Download[firstAliquotContainer, Object], Flatten[{sampleDownloadPacket, suppliedReadPlatePacket, aliquotContainerPackets, cache}]], Model], Object]
	];


	(* Check if user-aliquot container model can be use *)
	validAliquotPlateQ = If[And[MatchQ[suppliedReadPlate, Automatic], (!tooManyAliquotContainers), MatchQ[firstAliquotContainer, Except[Automatic|{}]]],
		MemberQ[$AllCDPlateModels, firstAliquotContainerModel],
		True
	];

	(* Now check aliquot container is allowed by our function *)

	(* --- Resolve non-index match options*)
	(* 1. ReadPlate*)

	resolvedReadPlate = If[MatchQ[suppliedReadPlate, Except[Automatic]],
		(*If user specified a read plate, we use what user specified*)
		suppliedReadPlate,

		If[preparedPlate,

			(*if ReadPlate-> Automatic, but PreparedPlate is True, then ReadPlate will be exactly the sample container*)
			FirstOrDefault[simulatedSampleContainerObjects],

			(*Else we ask the user to use the quartz plate ast the read plate*)
			If[
				Length[aliquotContainerModelPacket]>0,

				(*else we check if the aliquotContainer is specified as the read plate *)
				firstAliquotContainer,

				Model[Container, Plate, "Hellma Black Quartz Microplate"]
			] (*"id:KBL5DvwJ0q4k"*)
		]

	];


	(* Get the supplied ReadPlate Model*)
	suppliedReadPlateModel = If[MatchQ[suppliedReadPlate, Except[Automatic]],
		Lookup[FirstOrDefault[Flatten[suppliedReadPlatePacket]], Object],
		{}
	];

	(* Select which plate model we want to check for error *)
	(* Use the model instead of resolvedReadPlate since it could be Object *)
	resolvedReadPlateModel = If[MatchQ[resolvedReadPlate, ObjectP[Model[Container, Plate]]],
		Download[resolvedReadPlate, Object],
		Download[Lookup[fetchPacketFromCache[Download[resolvedReadPlate, Object], Flatten[{sampleDownloadPacket, suppliedReadPlatePacket, aliquotContainerPackets, cache}]], Model], Object]
	];

	(* Check if user-specified plate model can be use *)
	validReadPlateQ = MemberQ[$AllCDPlateModels, resolvedReadPlateModel];


	(* Throw a error message here for both aliquotContainer and ReadPlate, here we resolved as if read plate aliquot Container is filled (*Use the first one*), use resolvedReadPlate here since it could be model or Object *)
	Which[
		!validReadPlateQ && messages, Message[Error::IncompatibleReadPlateForCircularDichroism, ToString[resolvedReadPlate], ToString[$AllCDPlateModels]],
		!validAliquotPlateQ && (!preparedPlate )&& messages, Message[Error::IncompatibleReadPlateForCircularDichroism, ToString[firstAliquotContainer], ToString[$AllCDPlateModels]]

	];
	(* Return Instrument as invalid option if the supplied Instrument is incompatible *)
	invalidReadPlateOptions = If[!validReadPlateQ, {ReadPlate}, {}];

	(* Build a test for Instrument*)
	invalidReadPlateTest = If[gatherTests,
		Test["The ReadPlate is compatible for measureing circular dichroism :", validReadPlateQ, True]
	];

	resolvedReadPlateModelPacket = fetchPacketFromCache[resolvedReadPlateModel, allAllowedPlatePackets];

	(* Retrieved the information (MaxVolume, MinVolume, ContainerMaterials for use in the option resolver) *)
	{readPlateMaterial, readPlateMinVolume, readPlateMaxVolume, readPlateRecommendedFillVolume, readplateReusability} = If[validReadPlateQ,
		 Lookup[fetchPacketFromCache[resolvedReadPlateModel, allAllowedPlatePackets], {ContainerMaterials, MinVolume, MaxVolume, RecommendedFillVolume, Reusability}],
		 {{}, {}, {}, {}, True}
	 ];

	readPlateRecommendedFillVolumeNotNull = readPlateRecommendedFillVolume/.Null -> Round[(readPlateMaxVolume*0.75), 0.1Microliter];

	(* Build a short hand for read plate is not quartz *)
	notQuratzReadPlateQ = (!MemberQ[readPlateMaterial, Quartz]);

	(* For now since we cannot buy plate cover for quartz plate, throw a error if user use qurtz plate and retainCover==True *)
	quartzPlateRetainCoverIncompatibleQ = (And[MemberQ[readPlateMaterial, Quartz], retainCover]);

	(* --- Start to resolve index matching options --- *)

	(* Get volumes for all samples *)
	allSampleVolumes = Lookup[simulatedSamplePackets, Volume];
	
	(* Resolve master switches *)
	{
		(*1*)resolvedSampleVolumes,
		(*2*)resolvedCalculatingMolarEllipticitySpectrums,
		(*3*)resolvedAnalytes,
		(*4*)resolvedAnalytesConcentrations,
		(*5*)resolvedDetectionWavelengths,
		(*6*)resolvedStepSizes,
		(*7*)invalidSampleVolumeBools,
		(*8*)invalidAnalytBools,
		(*9*)cannotalculatingMolarEllipticityBools,
		(*10*)invalidDetectionWavelengthBools,
		(*11*)stepSizeWavelengthIncompatibleBools,
		(*12*)inconsistentConcentrationBools,
		(*14*)detectionWavelengthReadPlateIncompatibleBools,
		(*15*)resolvedBlanks,
		(*16*)resolvedBlankVolumes,
		(*17*)unNeededBlankOptionList,
		(*18*)requiredBlankOptionList,
		(*19*)unNeededBlankBools,
		(*20*)requiredBlankBools,
		(*21*)analyteKnownCleanedConcentrations
	} = Transpose[
		MapThread[
			Function[
				{
					(*1*)eachSimulatedSamplePackets,
					(*2*)eachSimulatedSampleIdentityPacket,
					(*3*)eachSimulatedSampleIdentityConcentrations,
					(*4*)eachSampleVolume,
					(*5*)eachCalculatingMolarEllipticitySpectrum,
					(*6*)eachAnalyte,
					(*7*)eachAnalyteConcentrations,
					(*8*)eachDetectionWavelength,
					(*9*)eachStepSize,
					(*10*)eachBlanks,
					(*11*)eachBlankVolumes,
					(*12*)eachSuppliedAliquotVolumes,
					(*13*)eachSuppliedAssayVolumes,
					(*14*)eachSuppliedTargetConcentrations,
					(*15*)eachSuppliedTargetConcentrationAnalytes
				},
				Module[
					{
						resolvedSampleVolume, resolvedCalculatingMolarEllipticitySpectrum, resolvedAnalyte, resolvedAnalytesConcentration,
						resolvedDetectionWavelength, resolvedStepSize,eachSimulatedSampleVolume, invalidSampleVolumeBool, eachSimulatedAnalyte,
						sampleAnalytes, sampleCompositionIdentities, sampleIdentityConcentrationPackets, analytePolymerList, firstPolymerIdentity,
						firstIdentityWithConcentration, allAnalyteList, invalidAnalytBool, inconsistentConcentrationBool,
						cannotalculatingMolarEllipticityBool, extinctionWavelengths, invalidDetectionWavelengthBool,
						detectionWavelengthReadPlateIncompatibleBool, minDetectionWavelength, rangedWavelengthQ, stepSizeWavelengthIncompatibleBool,
						resolvedBlank, resolvedBlankVolume, blankOptions, unNeededBlankOptions, requiredBlankOptions, unNeededBlankBool,
						requiredBlankBool, analyteKnownConcentration, analyteKnownCleanedConcentration, eachSimSampleIdenPcktNoNull
					},
					(*--- Resolve sample volume for each SamplesIn---*)

					(* First retrive the sample volume from simulated sample packet *)
					eachSimulatedSampleVolume = Lookup[eachSimulatedSamplePackets, Volume];

					(* Resolve sampleVolue for each sample *)
					resolvedSampleVolume = If[MatchQ[eachSampleVolume, Except[Automatic]],
						(* Use what user specified *)
						eachSampleVolume,
						(* else we resolved based on aliquot volume and other options *)
						If[preparedPlate,
							(*If user specified PreparedPlate use the sample volume in that plate*)
							SafeRound[eachSimulatedSampleVolume, 0.1 Microliter, AvoidZero -> True],
							(* Else resolve based on the min*)
							Which[
								(* First resolved based on aliquot options *)
								MatchQ[eachSuppliedAssayVolumes, VolumP], SafeRound[eachSuppliedAssayVolumes, 0.1 Microliter, AvoidZero -> True],
								MatchQ[eachSuppliedAliquotVolumes, VolumP], SafeRound[eachSuppliedAliquotVolumes, 0.1 Microliter, AvoidZero -> True],
								(* if user supplied a valid read plate, check if  *)
								validReadPlateQ, SafeRound[Min[Flatten[{allSampleVolumes, readPlateRecommendedFillVolumeNotNull}]], 0.1 Microliter, AvoidZero -> True],
								True, SafeRound[Min[allSampleVolumes], 0.1 Microliter, AvoidZero -> True]
							]
						]
					];

					(* For user specified Sample Volume, check if it's within the range of the ReadPlate Allowed Volume*)
					invalidSampleVolumeBool = If[MatchQ[resolvedSampleVolume, UnitsP[Microliter]] && validReadPlateQ,
						!(MatchQ[resolvedSampleVolume, RangeP[readPlateMinVolume, readPlateMaxVolume]]),
						False
					];

					(* The SampleIdentityPacket can have Null, which will block the function, replace the Null to an empty list *)
					eachSimSampleIdenPcktNoNull = (eachSimulatedSampleIdentityPacket/.Null -> {});

					(* Extract samples' analyte and composition identities *)
					sampleAnalytes = Lookup[eachSimulatedSamplePackets, Analytes];
					sampleCompositionIdentities = Lookup[eachSimSampleIdenPcktNoNull, Object, Null];

					(* Build a composition concentration packet *)
					sampleIdentityConcentrationPackets = MapThread[
						<|#1 -> #2|>&,
						{sampleCompositionIdentities, eachSimulatedSampleIdentityConcentrations}
					];

					(* Resolve Analyte for each SamplesIn *)
					eachSimulatedAnalyte=If[!MatchQ[sampleAnalytes,{}|Null],
						sampleAnalytes,
						sampleCompositionIdentities
					];

					(* Define the polymer type we want to use *)
					analytePolymerList = {Model[Molecule, cDNA], Model[Molecule, Oligomer], Model[Molecule, Polymer], Model[Molecule, Protein], Model[Molecule, Transcript]};

					(* Check identity packet has polymer based molecules *)
					firstPolymerIdentity = FirstCase[eachSimulatedAnalyte, ObjectP[analytePolymerList], {}];

					(* Check the compositions that has a valid concentration *)
					firstIdentityWithConcentration = FirstOrDefault[Keys[FirstCase[sampleIdentityConcentrationPackets, KeyValuePattern[{x_ -> y_: ConcentrationP}], {}]]];

					(*---Resolve Analyte---*)
					resolvedAnalyte = If[
						MatchQ[eachAnalyte, Except[Automatic]],

						(*If user specified something, we use user specified analyte*)
						eachAnalyte,

						(*Resolve Automatic*)
						Which[
							(* The Object Sample has the concentration specified *)
							MatchQ[FirstOrDefault[sampleAnalytes], IdentityModelP], FirstOrDefault[sampleAnalytes],

							(* Else we choose the first polymer we gonna use in the composition *)
							MatchQ[firstPolymerIdentity, Object[]], firstPolymerIdentity,

							(* or we use the first one with a know concentration, the firstIdentityWithConcentration itself will default to Null *)
							True, firstIdentityWithConcentration
						]
					];

					(* Join all the analyte from the Object[Sample]'s Analyte field and *)
					allAnalyteList = DeleteDuplicates[Flatten[({sampleAnalytes, sampleCompositionIdentities}/.Null -> {})]];

					(*--- Check user specified Analyte has a conflict ---*)
					invalidAnalytBool = If[MatchQ[eachAnalyte, ObjectP[Model[Molecule]]] && Length[allAnalyteList] > 0,
						(* Check if user specified molecules and total analytes we can fine in Object[Sample] and Compositions *)
						!MemberQ[allAnalyteList, eachAnalyte],
						False
					];


					(* Merge all the analyte concentration together so we have only one association, besides, if user specified same analyte multiple times, they will be combined (sum up) together *)
					analyteKnownConcentration = Lookup[Merge[sampleIdentityConcentrationPackets, Total], resolvedAnalyte];

					(* For now we will upload the concentration as molar or gram/mL, so we need to check the concentration first *)
					analyteKnownCleanedConcentration = Switch[analyteKnownConcentration,

						(* if the concentration from the composition is specified by molar, we use this value*)
						ConcentrationP, analyteKnownConcentration,

						(* if the concentration is in gram/mole if so transfer it to molar *)
						UnitsP[Gram/Liter], Convert[(analyteKnownConcentration/MolecularWeight[resolvedAnalyte]), Micromolar],

						(* else resolve to null*)
						_, Null
					];

					(*--- Resolve AnalyteConcentration ---*)
					resolvedAnalytesConcentration = If[
						(*If user specified something, we use user specified Value*)
						MatchQ[eachAnalyteConcentrations, Except[Automatic]],
						(*If user specified something, we use user specified analyteConcentration*)
						eachAnalyteConcentrations,
						(*Resolve Automatic:Check if we could find the concentration from the compositions, if not, return Null *)
						If[MatchQ[eachSuppliedTargetConcentrations, ConcentrationP],
							SafeRound[suppliedTargetConcentrations, 0.1 Micromolar, AvoidZero -> True],
							SafeRound[analyteKnownCleanedConcentration, 0.1 Micromolar, AvoidZero -> True]
						]
					];


					(*--- Conflict warning for AnalyteConcentration: Throw a warning if user-specified concentration is different from the concentration from the compositions ---*)
					inconsistentConcentrationBool = If[MatchQ[eachAnalyteConcentrations, ConcentrationP] && (!NullQ[analyteKnownCleanedConcentration]),
						(*If user specified a analyteConcentration and the concentration extracted for the resolvedAnalyte is not null*)
						(*check if the two concentration are the same, Round them to 0.01 mM*)
						!(Round[eachAnalyteConcentrations, 0.01] == Round[analyteKnownCleanedConcentration, 0.01]),
						(*Else return False*)
						False
					];

					(*--- Resolve CalculatingMolarEllipticitySpectrum ---*)
					resolvedCalculatingMolarEllipticitySpectrum = If[MatchQ[eachCalculatingMolarEllipticitySpectrum, Except[Automatic]],

						(* if user specified yes or no, we go with what user specified *)
						eachCalculatingMolarEllipticitySpectrum,

						(* Resolve Automatic: calculate MolarEllipticity requires concentration, so if user specified that values, we resolve this option to True, else resolve it to False. *)
						MatchQ[resolvedAnalytesConcentration, ConcentrationP]
					];

					(*--- CalculatingMolarEllipticitySpectrum Conflict ---*)
					(* First check if there are any Extinction field specified in the identity packet *)
					extinctionWavelengths = (Lookup[Flatten[Lookup[eachSimSampleIdenPcktNoNull, ExtinctionCoefficients, {}]], Wavelength, {}]);

					(* if user-specified CalculatingMolarEllipticitySpectrum, but AnalyteConcentration is not provide, throw a error*)
					cannotalculatingMolarEllipticityBool = If[TrueQ[eachCalculatingMolarEllipticitySpectrum], !MatchQ[resolvedAnalytesConcentration, ConcentrationP], False];

					(*--- Resolve DetectionWavelength ---*)

					resolvedDetectionWavelength = If[MatchQ[eachDetectionWavelength, Except[Automatic]],

						(* If user specified a value, we use what user specified*)
						eachDetectionWavelength,

						(*Resolve Automatic*)
						Which[

							(* If the analyte is resolved to DNA or Protein or other bio macromolecules, set the range to UV-Region*)
							MatchQ[resolvedAnalyte, ObjectP[analytePolymerList]], Span[200Nanometer, 400Nanometer],

							(* Else if we are not using Quartz plate, we will first check if identity models has extinction values fill, if so we scan in range of the (Min[extinctionWavelengths-100Nanometer],Max[extinctionWavelength+150Nanometer])*)
							(* But not still within the range of (350Nanometer, 800 Nanomter) *)
							(notQuratzReadPlateQ) && Length[extinctionWavelengths] > 0, Span[Max[(Min[extinctionWavelengths]-100Nanometer), 350Nanometer], Min[(Min[extinctionWavelengths]+150Nanometer), 850 Nanometer]],

							(* Else if not using Quartz plate, scn 350 nm to 800 nm *)
							(notQuratzReadPlateQ), Span[350Nanometer, 800 Nanometer],

							(* For using Quartz plate, we first resolve based on Extinction Wavelength *)
							Length[extinctionWavelengths]>0, Span[Max[(Min[extinctionWavelengths]-100Nanometer), 185Nanometer], Min[(Min[extinctionWavelengths]+150Nanometer), 850 Nanometer]],

							(* Catch all for a full range scan*)
							True, Span[200Nanometer, 400 Nanometer]
						]

					];


					(*--- DetectionWavelength Conflict check---*)
					(*--- For a span input check if the min values < Max values*)
					invalidDetectionWavelengthBool=If[
						MatchQ[eachDetectionWavelength,_Span],
						First[List@@eachDetectionWavelength]>=Last[List@@eachDetectionWavelength],
						False
					];

					(*Retrive the min detection wavelength*)
					minDetectionWavelength=Switch[eachDetectionWavelength,
						_Span, First[List@@eachDetectionWavelength],
						ListableP[UnitsP[Nanometer]],Min[Sort[ToList[eachDetectionWavelength]]],
						_,185Nanometer
					];

					(*If user specified a non-quartz plate and specify a detection wavelenght < 400 nm. throw a warning*)
					detectionWavelengthReadPlateIncompatibleBool=And[minDetectionWavelength<400 Nanometer,notQuratzReadPlateQ,validReadPlateQ];

					rangedWavelengthQ=MatchQ[resolvedDetectionWavelength,_Span];

					(*---Resolve stepsize---*)
					resolvedStepSize=If[
						MatchQ[eachStepSize,Except[Automatic]],
						eachStepSize,

						(*Resolve Automatic*)
						If[rangedWavelengthQ,
							(*set to 1 nm if scan in range else resolve to Null*)
							1 Nanometer,
							Null
						]
					];

					(*--- Stepsize Conflicts Checking ---*)
					stepSizeWavelengthIncompatibleBool=!Xor[MatchQ[eachStepSize,UnitsP[Nanometer]], rangedWavelengthQ];


					(*--- Resolve Blanks and BlankVolumes---*)
					blankOptions={Blanks,BlankVolumes};

					resolvedBlank=If[MatchQ[eachBlanks,Except[Automatic]],
						eachBlanks,
						If[blankAbsorbance,Model[Sample, "Milli-Q water"],Null]
					];

					resolvedBlankVolume=If[MatchQ[eachBlankVolumes,Except[Automatic]],
						eachBlankVolumes,
						If[blankAbsorbance,resolvedSampleVolume,Null]
					];

					(*--- Blank Unneeded Option checks--- *)
					{unNeededBlankOptions,requiredBlankOptions}=If[blankAbsorbance,
						{
							{},
							Module[{nullList,nullOptions},
								nullList=NullQ/@{resolvedBlank,resolvedBlankVolume};
								nullOptions=PickList[blankOptions,nullList]
							]
						},
						{
							Module[{filledList,filledOptions},
								filledList=MatchQ[#,Except[Null|Automatic]]&/@{eachBlanks,eachBlankVolumes};
								filledOptions=PickList[blankOptions,filledList]
							],
							{}
						}
					];

					unNeededBlankBool=(Length[unNeededBlankOptions])>0;
					requiredBlankBool=(Length[requiredBlankOptions])>0;

					(*Return resolved single value from big mapthread*)
					{
						(*1*)resolvedSampleVolume,
						(*2*)resolvedCalculatingMolarEllipticitySpectrum,
						(*3*)resolvedAnalyte,
						(*4*)resolvedAnalytesConcentration,
						(*5*)resolvedDetectionWavelength,
						(*6*)resolvedStepSize,
						(*7*)invalidSampleVolumeBool,
						(*8*)invalidAnalytBool,
						(*9*)cannotalculatingMolarEllipticityBool,
						(*10*)invalidDetectionWavelengthBool,
						(*11*)stepSizeWavelengthIncompatibleBool,
						(*12*)inconsistentConcentrationBool,
						(*14*)detectionWavelengthReadPlateIncompatibleBool,
						(*15*)resolvedBlank,
						(*16*)resolvedBlankVolume,
						(*17*)unNeededBlankOptions,
						(*18*)requiredBlankOptions,
						(*19*)unNeededBlankBool,
						(*20*)requiredBlankBool,
						(*21*)analyteKnownCleanedConcentration
					}
				]
			],
			{
				(*1*)simulatedSamplePackets,
				(*2*)simulatedSampleIdentityPacket,
				(*3*)simulatedSampleIdentityConcentrations,
				(*4*)suppliedSampleVolume,
				(*5*)suppliedCalculatingMolarEllipticitySpectrum,
				(*6*)suppliedAnalyte,
				(*7*)suppliedAnalyteConcentrations,
				(*8*)suppliedDetectionWavelength,
				(*9*)suppliedStepSize,
				(*10*)suppliedBlanks,
				(*11*)suppliedBlankVolumes,
				(*12*)suppliedAliquotVolumes,
				(*13*)suppliedAssayVolumes,
				(*14*)suppliedTargetConcentrations,
				(*15*)suppliedTargetConcentrationAnalytes
			}
		]
	];
	


	(*Resolve NumberOfReplicates*)
	(* We'll assume this for now but resolve to 3 for quantification runs if we find we have enough space after blank resolution *)
	resolvedNumReplicates=suppliedNumberOfReplicates/.{(Null|Automatic)->1};

	(*Calculate total number of samples (SamplesIn*Replicates+Blank+Empty scans)*)
	blankObjects=Download[resolvedBlanks,Object];

	(* For blanks with same Object, Volume, DetectionWavelengths and StepSize, means they will be scaned in the same manner, we will only run one blank for them. *)
	uniqueBlankTuples=DeleteDuplicates[Transpose[{blankObjects,resolvedBlankVolumes,resolvedDetectionWavelengths,resolvedStepSizes}]];

	numOfUniqueBlanks=Length[uniqueBlankTuples];
	numOfEmpty=If[emptyAbsorbance,1,0];

	(* Figure out if the combination of (NumberOfReplicates * number of samples) + (2* number of blanks) (if we're blanking), or NumberOfReplicates * Number of samples if we are not *)
	(* Note Moat sample space gets checked below by validMoat *)
	totalNumSamples=((resolvedNumReplicates*Length[simulatedSamples])+numOfUniqueBlanks+numOfEmpty); (* Lunatic doesn't make replicate blanks *)

	(*use validMoat helper function to check the option conflicts*)
	(* Do all the checks to make sure our moat options are valid *)
	{invalidMoatOptions,moatTests} =If[validReadPlateQ,
		If[gatherTests,
			validMoat[totalNumSamples,resolvedReadPlateModelPacket,Join[circularDichroismOptionAssoc,Association[unresolvedPrepOptions]],Output->{Options,Tests},EmptyMoat->True],
			{validMoat[totalNumSamples,resolvedReadPlateModelPacket,Join[circularDichroismOptionAssoc,Association[unresolvedPrepOptions]],Output->Options,EmptyMoat->True],{}}
		],
		{{},{}}
	];

	(*--- Resolve Moat Options ---*)

	(*Use helper function to resolve the moat functions*)
	{resolvedMoatBuffer,resolvedMoatVolume,resolvedMoatSize}=resolveMoatOptions[
		Object[Protocol,CircularDichroism],
		resolvedReadPlateModelPacket,
		suppliedMoatBuffer,
		suppliedMoatVolume,
		suppliedMoatSize
	];

	(*quartzPlateRecommendMoatSize is set to be 2*)
	quartzPlateRecommendMoatSize=2;

	(*--- Moat Option conflict check---*)
	(*Throw a warning if the readPlate is quartz but the moat size > recommend number*)
	quartzPlateNeedMoatQ=If[notQuratzReadPlateQ,False,!(resolvedMoatSize>=quartzPlateRecommendMoatSize)];

	(*Throw warning if the MoatBuffer and MoatVolume are not compatible, they needs to be both Null or both a reasonable value*)

	(*
	moatBufferMoatVolumeIncompatibleQ=!Or[

		(*Can be both Null*)
		And[NullQ[resolvedMoatBuffer],NullQ[resolvedMoatVolume]],

		(*Or both of them are valid value*)
		And[MatchQ[resolvedMoatBuffer,ObjectP[{Model[Sample],Object[Sample]}]],MatchQ[resolvedMoatVolume,UnitsP[Milliliter]]]
	];
	*)

	(*--- Resolve EnantiomericExcessOptions ---*)
	(* Resolved EnantiomericExcess Measurement*)
	resolvedEnantiomericExcessMeasurement = If[MatchQ[suppliedEnantiomericExcessMeasurement, Except[Automatic]],

		suppliedEnantiomericExcessMeasurement,

		(*Resolved based on if any EE related option is filled, if both of them are Automatic|Null, resolved to False*)
		Or[MatchQ[suppliedEnantiomericExcessWavelength, Except[(Automatic|Null)]], MatchQ[suppliedEnantiomericExcessStandards, Except[Automatic|Null]]]
	];

	(* Resolve EnantiomericExcessWavelength*)
	resolvedEnantiomericExcessWavelength = If[MatchQ[suppliedEnantiomericExcessWavelength, Except[Automatic]],

		suppliedEnantiomericExcessWavelength,

		(*Resolved based on if any EE related option is filled, if both of them are Automatic|Null, resolved to False*)
		If[
			TrueQ[resolvedEnantiomericExcessMeasurement],

			(* If resolvedEnantiomericExcessMeasurement is True, we then resolve the EEWavelengths based on each resolved DetectionWavelength *)
			Take[
				DeleteDuplicates[
					Flatten[
						Map[
							If[
								MatchQ[#, _Span],

								(*For DetectionWavelength is a range, we used the average of the max ane min value*)
								Round[Mean[List @@ #], 1],

								(* For list value, we will use that directly *)
								#
							]&,
							resolvedDetectionWavelengths
						]
					]
				],

				(*If we have too many of them, we only use the first 10*)
				UpTo[10]
			],
			Null
		]
	];

	(* since the EE standards is a list of list we will collect the subvalues of each of them *)
	(* Extract SampleObject *)
	simulatedSampleObject = Lookup[simulatedSamplePackets, Object];

	(* Now run helper function to calculate EE from the simulateSample and Model packets, respectively *)
	simulatedSampleEEList = calculateEEFromPacket[simulatedSamplePackets];
	simulatedSampleModelEEList = calculateEEFromPacket[simulatedSampleModelPackets];

	(* Clean the final results: if null in Object[Sample], try to see if the Model[Sample] specify this value *)
	sampleEEList = If[resolvedEnantiomericExcessMeasurement,
		Which[
			(Length[simulatedSampleEEList] == Length[simulatedSampleModelEEList]),
			MapThread[
				If[MatchQ[#1, UnitsP[Percent]],
					#1,
					#2
				]&,
				{simulatedSampleEEList, simulatedSampleModelEEList}
			]
		]/.(Null -> 100Percent),
		{}
	];

	(* Build a packet for all samples' ee value (If any) *)
	sampleEEPacket = If[resolvedEnantiomericExcessMeasurement,
			Association/@(DeleteDuplicates[
			Flatten[
				MapThread[
					{#1 -> #2}&,
					{Lookup[simulatedSamplePackets, Object], ToList[sampleEEList]}
				]
			]
		]),
		{}
	];

	(* Collect those with a valid percent value *)
	validEEValuePacket = (Cases[sampleEEPacket, KeyValuePattern[x_ -> y: UnitsP[Percent]]]);

	(* Check if the specified EE wavelength are within the range of resolvedDetectionWavelength *)
	inValidEEWavelengthWarningQs = If[
		MatchQ[suppliedEnantiomericExcessWavelength, Except[Automatic]],
		Map[
			Function[{eachDetectionWavelength},
				If[
					MatchQ[eachDetectionWavelength, _Span],
					!And@@(MatchQ[#, RangeP@@eachDetectionWavelength]& /@ ToList[suppliedEnantiomericExcessWavelength]),
					!And@@(MemberQ[eachDetectionWavelength, #]& /@ ToList[suppliedEnantiomericExcessWavelength])

				]
			],
			resolvedDetectionWavelengths
		],
		False
	];

	(* We first check if we have enough samples, we need more than 3 samples: 2 for standards one for measurement *)
	needMoreSamplesQ = If[resolvedEnantiomericExcessMeasurement,
		Length[simulatedSamplePackets] < 3,
		False
	];


	(* If we measure EnantiomericExcess, we need more than two standards, otherwise we cannot proceeds *)
	needMoreEEStandardsQ = If[resolvedEnantiomericExcessMeasurement && MatchQ[suppliedEnantiomericExcessStandards, Except[(Null|Automatic)]],
		Length[suppliedEnantiomericExcessStandards] < 2,
		False
	];


	(* Truncate the validEEValuePacket to make sure we can mapthread it with EE standards *)
	truncatedEEList = If[Length[validEEValuePacket] > 0,
		PadRight[validEEValuePacket,Length[suppliedEnantiomericExcessStandards], First[validEEValuePacket]], ConstantArray[Null, Length[resolvedEEStandardSamples]]];

	(* Resolve the EE standard Option*)
	resolvedEnantiomericExcessStandards = If[

		MatchQ[suppliedEnantiomericExcessStandards, Except[Automatic]],

		(*If user specified values, we further go deep into the packet to resolve the automatic options *)
		If[(!needMoreEEStandardsQ),

			(*Extract eeStandardSamples,eeStandardValues*)
			{eeStandardSamples, eeStandardValues} = Transpose[suppliedEnantiomericExcessStandards];

			MapThread[
				Function[{eachEEStandardSamples, eachEEStandardValues, eachTruncatedEEList},
					Module[
						{eachResolvedEEStandardSamples, eachResolvedEEStandardValues, eeValueforEachResolvedSample},

						(*check if the EE standard is Automatic*)
						eachResolvedEEStandardSamples = If[MatchQ[eachEEStandardSamples, Except[Automatic]],
							eachEEStandardSamples,
							FirstOrDefualt[Keys[eachTruncatedEEList]]
						];

						(* Check if this sample has its EE value we can retrieved from the download packet*)
						eeValueforEachResolvedSample = Lookup[validEEValuePacket, eachResolvedEEStandardSamples]/.{_Missing -> 100Percent};

						(* check if the EE standard is Automatic *)
						eachResolvedEEStandardValues = If[MatchQ[eachEEStandardValues, Except[Automatic]],
							eachEEStandardValues,
							FirstOrDefault[eeValueforEachResolvedSample];
						];
						(* Return well resolved options *)
						{eachResolvedEEStandardSamples,	eachResolvedEEStandardValues}
					]
				],
				{eeStandardSamples, eeStandardValues, truncatedEEList}
			],
			{{}, {}}
		],

		(* Resolve Automatic EEStandards options *)
		If[resolvedEnantiomericExcessMeasurement && (!needMoreSamplesQ),
			Transpose@{Take[simulatedSampleObject, 2], {100Percent, -100Percent}},
			Null
		]
	];

	(* Check if all user specified EE Standards are members of our SamplesIn *)
	unknownEEStandardsQ = If[
		MatchQ[suppliedEnantiomericExcessStandards, Except[(Automatic|Null)]],
		!ContainsAll[simulatedSampleObject, Cases[eeStandardSamples, ObjectP[{Model[Sample], Object[Sample]}]]],
		False
	];

	(* resolve AliquotOptions *)
	(* - Pre-resolve Aliquot Options - *)

	(* Determine if all the core aliquot options are left automatic for a given sample (note that although we pulled out ConsolidateAliquots above, that does NOT count as a core aliquot option and isn't checked here) *)
	(* If no aliquot options are specified for a sample we want to be able to warn that it will be aliquoted if that comes up *)
	automaticAliquotingBooleans=MapThread[
		Function[{aliquot,aliquotVolume,assayVolume,targetConcentration,assayBuffer,aliquotContainer,targetConcentrationAnalytes},
			MatchQ[{aliquot,assayVolume,aliquotVolume,targetConcentration,assayBuffer,aliquotContainer,targetConcentrationAnalytes},{Automatic..}]
		],
		{suppliedAliquotBooleans,suppliedAliquotVolumes,suppliedAssayVolumes,suppliedTargetConcentrations,suppliedAssayBuffers,suppliedAliquotContainers,suppliedTargetConcentrationAnalytes}
	];

	automaticAliquotingQ=MatchQ[automaticAliquotingBooleans,{True..}];

	(* -- Gather potential errors, then throw a single message -- *)

	(* - Check source container count - *)

	(* Number of simulated sample containers *)
	uniqueContainers=DeleteDuplicates[aliquotContainerPackets];

	(* Since the Circular Dichroism won't do any sample manipulation before put the sample into the instrument. Everything should be directly aliquoted to the desired read plate.*)
	(* There by we can only run one plate per experiment.*)
	tooManySourceContainersQ=Length[uniqueContainers]>1;


	(* Set Aliquot->True if some other action was requested that will require aliquots *)

	aliquotRequired=Or[
		Length[uniqueContainers]>1,
		!DuplicateFreeQ[Lookup[simulatedSamplePackets,Object]],
		MatchQ[resolvedMoatBuffer,ObjectP[]],
		!preparedPlate
	];

	(* Resolve Aliquot, AliquotVolume and AliquotContainer *)
	preresolvedAliquots=Map[
		Function[{aliquot},
			Module[{resolvedAliquot,aliquotConflict},

				(* Resolve Aliquot->True if current container won't fit in plate reader *)
				resolvedAliquot=If[MatchQ[aliquot,BooleanP],
					aliquot,
					aliquotRequired
				];

				(* If we need to aliquot, we must complain if user set this to False *)
				aliquotConflict=aliquotRequired&&!MatchQ[resolvedAliquot,True];


				{aliquotConflict,resolvedAliquot}
			]
		],
		suppliedAliquotBooleans
	];

	(* Assign variables *)
	{aliquotConflictBooleans,resolvedAliquotBooleans}=Transpose[preresolvedAliquots];


	(* resolve ConsolidateAliquots to False, resolve it to true will blocking the NumberOfReplicate is too high *)
	resolvedConsolidateAliquots = suppliedConsolidateAliquots/. (Null|Automatic)->False;


	(* resolve the RequiredAliquotContainers to read plate but give an error if the aliquot container and resolvedReadPlate is to be the same *)
	(* here we have resolved and throw all checks so we weill directly use read plate*)
	(* also we want to resolve everything to the same plate *)
	requiredAliquotContainers=If[preparedPlate,Null,ConstantArray[{1,Download[resolvedReadPlate,Object]},Length[simulatedSamples]]];

	(* Since we won't do any further manipulations for these samples, we will use the sample volumes as teh aliquot volue directly*)
	(* Round this down following the same rounding rule of Aliquot *)
	requiredAliquotAmounts=RoundOptionPrecision[resolvedSampleVolumes,10^-1*Microliter,Round->Down];

	(* - Resolve DestinationWells - *)

	numberOfSamplesToRun=resolvedNumReplicates*Length[simulatedSamples];

	(* Get all wells in the plate *)
	plateWells=AllWells[resolvedReadPlateModelPacket];

	(* Get the moat wells *)
	moatWells=getMoatWells[AllWells[resolvedReadPlateModelPacket],(resolvedMoatSize/.Null->0)];

	(* - Validate DestinationWell Option - *)
	(* Check whether the supplied DestinationWell have duplicated members. PlateReader experiment only allows one plate so we should not aliquot two samples into the same well. *)
	duplicateDestinationWells=DeleteDuplicates[
		Select[DeleteCases[ToList[suppliedDestinationWells],Automatic],Count[DeleteCases[ToList[suppliedDestinationWells],Automatic],#]>1&]
	];
	duplicateDestinationWellOption=If[!MatchQ[duplicateDestinationWells,{}]&&!gatherTests,
		Message[Error::CircularDichroismDuplicateDestinationWell,ToString[DeleteDuplicates[duplicateDestinationWells]]];{DestinationWell},
		{}
	];
	duplicateDestinationWellTest=If[gatherTests,
		Test["The specified DestinationWell should not have duplicated members:",MatchQ[duplicateDestinationWells,{}],True],
		{}
	];

	(* Check whether the supplied DestinationWell is the same length as samples with replicates. We cannot aliquot to the same well for duplicates. *)
	invalidDestinationWellLengthQ=If[!MatchQ[suppliedDestinationWells,{Automatic..}]&&MatchQ[resolvedAliquotBooleans,{True..}],
		TrueQ[Length[suppliedDestinationWells]!=numberOfSamplesToRun],
		False
	];
	invalidDestinationWellLengthOption=If[invalidDestinationWellLengthQ,
		Message[Error::CircularDichroismInvalidDestinationWellLength,ToString[numberOfSamplesToRun]];{DestinationWell},
		{}
	];
	invalidDestinationWellLengthTest=If[gatherTests,
		Test["The specified DestinationWell must be the same length as the number of all aliquots (the number of input samples multiplied by the specified NumberOfReplicates.",invalidDestinationWellLengthQ,False],
		{}
	];

	(* Try to resolve destination wells unless we know there's not enough room or we've detected overlap *)
	{resolvedDestinationWells,tooManySamplesQ}=If[MatchQ[suppliedDestinationWells,{Automatic..}]&&MatchQ[resolvedAliquotBooleans,{True..}],
		Module[{orderedWells,outputWells,outputTooManySamples},

			(* Re-order the wells based on read direction *)
			orderedWells=Switch[readDirection,
				Row, Flatten[plateWells],
				Column,	Flatten[Transpose[plateWells]],
				SerpentineRow, Flatten[MapThread[
					If[OddQ[#2],#1,Reverse[#1]]&,
					{plateWells,Range[Length[plateWells]]}
				]],
				SerpentineColumn, Flatten[MapThread[
					If[OddQ[#2],#1,Reverse[#1]]&,
					{Transpose[plateWells],Range[Length[Transpose[plateWells]]]}
				]]
			];

			(* Remove any moat wells from our possible wells - use DeleteCases to avoid rearranging *)
			availableAssayWells=DeleteCases[orderedWells,Alternatives@@moatWells];

			outputTooManySamples=(Length[availableAssayWells]>=totalNumSamples);

			(* Use the first n wells *)
			outputWells=If[Length[availableAssayWells]>=totalNumSamples,
				Take[availableAssayWells,numberOfSamplesToRun],
				suppliedDestinationWells
			];
			{outputWells, !outputTooManySamples}
		],
		{suppliedDestinationWells,False}
	];

	(* To avoid breaking aliquot resolver with invalid DestinationWell length, here we replace the resolvedDestinationWell with Automatic before enterining aliquot resolver. *)
	transferredResolvedDestinationWells=If[invalidDestinationWellLengthQ,
		ConstantArray[Automatic,Length[mySamples]],
		resolvedDestinationWells
	];

	(* - Determine if any of the samples have an aliquot issue - *)

	(* If given the same sample multiple times, we have to aliquot everything *)
	duplicateSampleError=MemberQ[Lookup[unresolvedPrepOptions,Aliquot],False]&&!DuplicateFreeQ[Lookup[simulatedSamplePackets,Object]];

	(* Track invalid input error *)
	invalidRepeatSamples=If[duplicateSampleError,
		Cases[Tally[Lookup[simulatedSamplePackets,Object]],{_,GreaterP[1]}][[All,1]],
		{}
	];


	(* make the AliquotWarningMessage value.  This sends the message indicating why we need to use specific kinds of containers *)
	aliquotWarningMessage="because the given samples are in containers that are not compatible with the Ekko plate readers. You may set how much volume you wish to be aliquoted using the AliquotAmount option.";

	(* Further generate pre-resolved aliquot options*)
	preresolvedAliquotOptions=ReplaceRule[ToList[myExperimentOptions],
		Join[
			{
				Aliquot->resolvedAliquotBooleans,
				DestinationWell->resolvedDestinationWells,
				NumberOfReplicates->resolvedNumReplicates,
				ConsolidateAliquots -> resolvedConsolidateAliquots
			},
			resolvedPrepOptions
		]
	];

	(* resolve the aliquot options *)
	{resolvedAliquotOptions,resolveAliquotOptionsTests} = If[validReadPlateQ,
		If[
			gatherTests,
			resolveAliquotOptions[ExperimentCircularDichroism, Download[mySamples, Object], simulatedSamples, preresolvedAliquotOptions, Cache -> cache, Simulation -> updatedSimulation, RequiredAliquotContainers -> requiredAliquotContainers, RequiredAliquotAmounts -> requiredAliquotAmounts, AliquotWarningMessage -> aliquotWarningMessage, Output -> {Result, Tests}],
			{resolveAliquotOptions[ExperimentCircularDichroism, Download[mySamples, Object], simulatedSamples, preresolvedAliquotOptions, Cache -> cache, Simulation -> updatedSimulation, RequiredAliquotContainers -> requiredAliquotContainers, RequiredAliquotAmounts -> requiredAliquotAmounts, AliquotWarningMessage -> aliquotWarningMessage, Output -> Result],{}}
		],
		{{},{}}
	];

	(* Resolve Post Processing Options *)
	resolvedPostProcessingOptions = resolvePostProcessingOptions[myExperimentOptions];

	(* Finally resolve ContainersOut options *)
	resolvedContainerOut = If[MatchQ[suppliedContainerOut, Except[Automatic]],

		(* Use what user specified *)
		suppliedContainerOut,

		(* Else if we used prepared plate, *)
		Which[

			(* resolve the container to Null if the samples out storage condition is null*)
			MatchQ[samplesOutStorageCondition, {Disposal ..}], Null,

			(* If prepared plate or the read plate cannot be reuse we set the output containers out to the read plate *)
			Or[Not[readplateReusability], preparedPlate], Null,

			(* If prepared plate or the read plate cannot be reuse we set the output containers out to the read plate *)
			True, Model[Container, Plate, "96-well 2mL Deep Well Plate"]

		]

	];

	(* check the ContainersOut is conflict with the SamplesOutStorageConditions *)
	(*If any of the samplesOutStorage is disposal, the container out need to  be Null*)
	containersOutMismatchQ = And[MatchQ[samplesOutStorageCondition, {Disposal ..}], MatchQ[resolvedContainerOut, Except[Null]]];

	(* If there are invalid options and we are throwing messages, throw an error message and keep track of our invalid options for Error::InvalidOptions. *)
	containersOutMismatchInvalidOptions = If[containersOutMismatchQ && messages,
		{SamplesOutStorageCondition, ContainerOut},
		{}
	];

	If[Or@@containersOutMismatchQ && messages && outsideEngine,
		Message[Error::CircularDichroismContainerOutStorageConditionMismatch,
			ObjectToString[simulatedSamples, Cache -> cache],
			ObjectToString[resolvedContainerOut, Cache -> cache]
		]
	];

	(* Create a test for the valid samples and one for the invalid samples *)
	containersOutStorageConditionTests = sampleTests[
		gatherTests,
		Test,
		simulatedSamplePackets,
		PickList[simulatedSamplePackets, samplesOutStorageCondition, Disposal],
		"If the ContainerOut is not Null, the samplesOutStorageCondition cannot be Null",
		cache
	];

	containersOutMismatchInvalidOptions = If[containersOutMismatchQ, {SamplesOutStorageCondition, ContainerOut}];

	(* --- Resolving Options and Perform Initial Error Checks --- *)

	
	(* It's often helpful to first resolve with the "highest level" options, ones whose values dictates the ranges/limitations of many other option values *)
	(* As you're resolving the options return any error messages relevant to just the current option (or current set of options you're considering) *)

	(* --- Combination Error Checking --- *)
	(* Call CompatibleMaterialsQ to check for chemical incompatibilities (samples which will degrade container/instrument material) and throw any needed messages *)

	(* --- Call CompatibleMaterialsQ to determine if the samples are chemically compatible with the instrument --- *)

	(* call CompatibleMaterialsQ and figure out if materials are compatible *)
	{compatibleMaterialsBool, compatibleMaterialsTests} = If[gatherTests,
		CompatibleMaterialsQ[instrument, simulatedSamples, Output -> {Result, Tests}, Cache -> cache, Simulation -> updatedSimulation],
		{CompatibleMaterialsQ[instrument, simulatedSamples, Messages -> messages, Cache -> cache, Simulation -> updatedSimulation], {}}
	];

	(* if the materials are incompatible, then the Instrument is invalid *)
	compatibleMaterialsInvalidOption = If[Not[compatibleMaterialsBool] && messages,
		{SamplesIn},
		{}
	];

	(* Check for thermal incompatibilities (containers that can't withstand given temperatures) *)
	(* Check for physical incompatibilities (containers that won't fit in given instruments) *)
	(* Check for samples not provided as inputs/options that will be impacted by performing the experiment *)

	(* Return all resolved options *)
	(* --- pull out all the shared options from the input options --- *)

	(* --- Check to see if the Name option is properly specified --- *)

	(* If the specified Name is not in the database, it is valid *)
	validNameQ = If[MatchQ[name, _String],
		Not[DatabaseMemberQ[Object[Protocol,CircularDichroism,name]]],
		True
	];

	(* if validNameQ is False AND we are throwing messages (or, equivalently, not gathering tests), then throw the message and make nameInvalidOptions = {Name}; otherwise, {} is fine *)
	nameInvalidOptions = If[Not[validNameQ] && messages,
		(
			Message[Error::DuplicateName, ToString[CircularDichroism <> " protocol"]];{Name}
		),
		{}
	];

	(* Generate Test for Name check *)
	validNameTest = If[gatherTests && MatchQ[name, _String],
		Test["If specified, Name is not already an "<>ToString[Object[Protocol, CircularDichroism]]<>" object name:",
			validNameQ,
			True
		],
		Null
	];

	(* get the resolved Email option; for this experiment, the default is True *)
	email=If[MatchQ[Lookup[circularDichroismOptionAssoc,Email],Automatic],
		True,
		Lookup[circularDichroismOptionAssoc,Email]
	];
	
	(*Throwing all the error messages*)

	(* Check for quartzPlateRetainCoverIncompatibleQ and throw the corresponding Error if we're throwing messages *)
	(* we only throw this if we're not on Engine since we only want this warning displayed to the user, but not upset Engine *)
	If[Or@@quartzPlateRetainCoverIncompatibleQ && messages && outsideEngine,
		Message[Error::CircularDichroismQuartzPlateCannotRetainCover,
			ObjectToString[resolvedReadPlate,Cache->cache]
		]
	];

	(* Create a test for the valid samples and one for the invalid samples *)
	quartzPlateRetainCoverTests=If[gatherTests,
		Test["If using quartz plate, cannot set RetainCover->True:",!quartzPlateRetainCoverIncompatibleQ,True],
		{}
	];
	invalidRetainCoverOption=If[quartzPlateRetainCoverIncompatibleQ,RetainCover];

	(* Check for needMoreEEStandardsQ and throw the corresponding Error if we're throwing messages *)
	(* we only throw this if we're not on Engine since we only want this warning displayed to the user, but not upset Engine *)
	If[Or@@needMoreEEStandardsQ && messages && outsideEngine,
		Message[Error::CircularDichroismNeedMoreEnatiomericExcessStandards,
			ToString[Length[suppliedEnantiomericExcessStandards]]
		]
	];

	(* Create a test for the valid samples and one for the invalid samples *)
	needMoreEEStandardsTest=If[gatherTests,
		Test["2 or more enatiomeric excess standards are specified:",!needMoreEEStandardsQ,True],
		{}
	];


	(* Check for unknownEEStandardsQ and throw the corresponding Error if we're throwing messages *)
	(* we only throw this if we're not on Engine since we only want this warning displayed to the user, but not upset Engine *)
	If[Or@@unknownEEStandardsQ && messages && outsideEngine,
		Message[Error::CircularDichroismUnknownEnatiomericExcessStandards,
			ObjectToString[Complement[suppliedEnantiomericExcessStandards[[All,1]],simulatedSampleObject],Cache->cache],
			ObjectToString[simulatedSampleObject,Cache->cache]
		]
	];

	(* Create a test for the valid samples and one for the invalid samples *)
	unknownEEStandardsTest=If[gatherTests,
		Test["2 or more enatiomeric excess standards are specified:",!unknownEEStandardsQ,True],
		{}
	];

	invalidEEstandardsOptions=If[Or@@Flatten[{unknownEEStandardsQ,needMoreEEStandardsQ}],EnantiomericExcessStandards];


	(* Check for quartzPlateNeedMoatQ and throw the corresponding Error if we're throwing messages *)
	(* we only throw this if we're not on Engine since we only want this warning displayed to the user, but not upset Engine *)
	If[Or@@needMoreSamplesQ && messages && outsideEngine,
		Message[Error::CircularDichroismNeedMoreSamplesForEnantiomericExcessMeasurement],
		ToString[Length[simulatedSamples]]
	];

	(* Create a test for the valid samples and one for the invalid samples *)
	needMoreSamplesForEETests=If[
		gatherTests,
		Test["Have more than 3 samples (2 for standards and at lease 1 for unknown) to measure the enantiomeric access:",!needMoreSamplesQ,True],
		{}
	];

	(*Throw a invalid Option tests*)
	needMoreSamplesForEEOptions=If[Or@@Flatten[{needMoreSamplesQ}],EnantiomericExcessMeasurement];


	(* Check for invalidDetectionWavelengthBools and throw the corresponding Error if we're throwing messages *)
	(* we only throw this if we're not on Engine since we only want this warning displayed to the user, but not upset Engine *)
	If[Or@@invalidDetectionWavelengthBools && messages && outsideEngine,
		Message[Error::CircularDichroismInvalidDetectionWavelength,
			ObjectToString[PickList[simulatedSamples,invalidDetectionWavelengthBools],Cache->cache],
			ObjectToString[PickList[resolvedDetectionWavelengths,invalidDetectionWavelengthBools],Cache->cache]
		]
	];

	(* Create a test for the valid samples and one for the invalid samples *)
	invalidDetectionWavelengthTests=sampleTests[
		gatherTests,
		Test,
		simulatedSamplePackets,
		PickList[simulatedSamplePackets,invalidDetectionWavelengthBools],
		"The DetectionWavelength is valid:",
		cache
	];

	(* Check for detectionWavelengthReadPlateIncompatibleBools and throw the corresponding Error if we're throwing messages *)
	(* we only throw this if we're not on Engine since we only want this warning displayed to the user, but not upset Engine *)
	If[Or@@detectionWavelengthReadPlateIncompatibleBools && messages && outsideEngine,
		Message[Error::CircularDichroismDetectionWavelengthIncompatibleForReadPlate,
			ObjectToString[resolvedReadPlateModel,Cache->cache]
		]
	];

	(* Create a test for the valid samples and one for the invalid samples *)
	detectionWavelengthReadPlateIncompatibleTests=sampleTests[
		gatherTests,
		Test,
		simulatedSamplePackets,
		PickList[simulatedSamplePackets,detectionWavelengthReadPlateIncompatibleBools],
		"The DetectionWavelength is can be used for the read plate:",
		cache
	];

	(*Throw a invalid Option tests*)
	invalidDetectionWavelengthOptions=If[Or@@Flatten[{invalidDetectionWavelengthBools,detectionWavelengthReadPlateIncompatibleBools}],ReadPlate];

	(* Check for invalidSampleVolumeBools and throw the corresponding Error if we're throwing messages *)
	(* we only throw this if we're not on Engine since we only want this warning displayed to the user, but not upset Engine *)
	If[Or@@invalidSampleVolumeBools && messages && outsideEngine,
		Message[Error::CircularDichroismSampleVolumeNotValid,
			ObjectToString[PickList[simulatedSamples,invalidSampleVolumeBools],Cache->cache],
			ObjectToString[Convert[PickList[Lookup[simulatedSamplePackets,Volume],invalidSampleVolumeBools],Microliter],Cache->cache],
			ObjectToString[Convert[readPlateMinVolume,Microliter],Cache->cache],
			ObjectToString[Convert[readPlateMaxVolume,Microliter],Cache->cache]
		]
	];

	(* Create a test for the valid samples and one for the invalid samples *)
	invalidSampleVolumeTests=sampleTests[
		gatherTests,
		Test,
		simulatedSamplePackets,
		PickList[simulatedSamplePackets,invalidSampleVolumeBools],
		"The DetectionWavelength is can be used for the read plate:",
		cache
	];

	(*Throw a invalid Option tests*)
	invalidSampleVolumeOptions=If[Or@@Flatten[{invalidSampleVolumeBools}],SampleVolume];



	(* Check for quartzPlateNeedMoatQ and throw the corresponding Error if we're throwing messages *)
	(* we only throw this if we're not on Engine since we only want this warning displayed to the user, but not upset Engine *)
	If[Or@@quartzPlateNeedMoatQ && messages && outsideEngine,
		Message[Error::CircularDirchroismQuartzPlateNeedMoat,
			ObjectToString[resolvedReadPlate,Cache->cache],
			ToString[resolvedMoatSize]
		]
	];

	(* Create a test for the valid samples and one for the invalid samples *)
	quartzPlateNeedMoatTests=If[
		gatherTests,
		Test["Both moat buffer and buffer volume are both Null or both valid values:",!quartzPlateNeedMoatQ,True],
		{}
	];

	(*Throw a invalid Option tests*)
	incompatibleMoatSizeForQuartzPlateOptions=If[Or@@Flatten[{quartzPlateNeedMoatQ}],{MoatSize},{}];


	(* Check for tooManySamplesQ and throw the corresponding Error if we're throwing messages *)
	(* we only throw this if we're not on Engine since we only want this warning displayed to the user, but not upset Engine *)
	If[Or@@tooManySamplesQ && messages && outsideEngine,
			Message[
				Error::CircularDichroismTooManySamples,
				ToString[(resolvedNumReplicates*Length[simulatedSamples])],
				ToString[numOfUniqueBlanks],
				ToString[numOfEmpty],
				ToString[totalNumSamples],
				ToString[Length[availableAssayWells]],
				ToString[resolvedMoatSize]
		]
	];

	(* Create a test for the valid samples and one for the invalid samples *)
	tooManySampleTests=If[
		gatherTests,
		Test["The ReadPlate has enough wells for all samples (SamplesIn + Blank + EmptyScan):",!tooManySamplesQ,True],
		{}
	];

	(*Throw a invalid Option tests*)
	tooManySamplesInvalidOptions=If[Or@@Flatten[{tooManySamplesQ}],{SamplesIn,BlankAbsorbance,Blanks,BlankVolumes,EmptyAbsorbance},{}];



	(* Check for unNeededBlankBools and throw the corresponding Error if we're throwing messages *)
	(* we only throw this if we're not on Engine since we only want this warning displayed to the user, but not upset Engine *)
	If[Or@@unNeededBlankBools && messages && outsideEngine,
		Message[
			Error::CircularDichroismUnNeededBlankOption,
			ObjectToString[PickList[simulatedSamples,unNeededBlankBools],Cache->cache],
			ObjectToString[PickList[unNeededBlankOptionList,unNeededBlankBools],Cache->cache]
		]
	];

	(* Create a test for the valid samples and one for the invalid samples *)
	unNeededBlankTests=sampleTests[
		gatherTests,
		Test,
		simulatedSamplePackets,
		PickList[simulatedSamplePackets,unNeededBlankBools],
		"If BlankAbsorbance is True, all related options cannot be specified to Null:",
		cache
	];

	(*Throw a invalid Option tests*)
	unNeededBlankOptions=DeleteDuplicates[Flatten[unNeededBlankOptionList]];

	(* Check for requiredBlankBools and throw the corresponding Error if we're throwing messages *)
	(* we only throw this if we're not on Engine since we only want this warning displayed to the user, but not upset Engine *)
	If[Or@@requiredBlankBools && messages && outsideEngine,
		Message[
			Error::CircularDichroismRequiredBlankOption,
			ObjectToString[PickList[simulatedSamples,requiredBlankBools],Cache->cache],
			ObjectToString[PickList[requiredBlankOptionList,requiredBlankBools],Cache->cache]
		]
	];

	(* Create a test for the valid samples and one for the invalid samples *)
	requiredBlankTests=sampleTests[
		gatherTests,
		Test,
		simulatedSamplePackets,
		PickList[simulatedSamplePackets,requiredBlankBools],
		"If BlankAbsorbance is False, all related options can be specified to Null:",
		cache
	];

	(*Throw a invalid Option tests*)
	requiredBlankOptions=DeleteDuplicates[Flatten[requiredBlankOptionList]];

	(* --- All Warnings ---*)
	(* Check for cannotalculatingMolarEllipticityBools and throw the corresponding Warning if we're throwing messages *)
	(* we only throw this if we're not on Engine since we only want this warning displayed to the user, but not upset Engine *)
	If[Or@@cannotalculatingMolarEllipticityBools && messages && outsideEngine,
		Message[Warning::NeedConcentrationForMolarEllipticity,
			ObjectToString[PickList[simulatedSamples,cannotalculatingMolarEllipticityBools],Cache->cache],
			ObjectToString[PickList[resolvedAnalytesConcentrations,cannotalculatingMolarEllipticityBools],Cache->cache]
		]
	];

	(* Create a test for the valid samples and one for the invalid samples *)
	cannotalculatingMolarEllipticityTests=sampleTests[
		gatherTests,
		Warning,
		simulatedSamplePackets,
		PickList[simulatedSamplePackets,cannotalculatingMolarEllipticityBools],
		"The AnalyteConcentration is valid to calculate Molar Ellipticity:",
		cache
	];

	(* Check for invalidAnalytBools and throw the corresponding Warning if we're throwing messages *)
	(* we only throw this if we're not on Engine since we only want this warning displayed to the user, but not upset Engine *)
	If[Or@@invalidAnalytBools && messages && outsideEngine,
		Message[Warning::CircularDirchroismUnknownAnalytes,
			ObjectToString[PickList[simulatedSamples,invalidAnalytBools],Cache->cache],
			ObjectToString[PickList[resolvedAnalytes,invalidAnalytBools],Cache->cache]
		]
	];


	(* Create a test for the valid samples and one for the invalid samples *)
	invalidAnalyteTests=sampleTests[
		gatherTests,
		Warning,
		simulatedSamplePackets,
		PickList[simulatedSamplePackets,invalidAnalytBools],
		"The Analyte is in Object's composition:",
		cache
	];


	(* Check for inconsistentConcentrationBools and throw the corresponding Warning if we're throwing messages *)
	(* we only throw this if we're not on Engine since we only want this warning displayed to the user, but not upset Engine *)
	If[Or@@inconsistentConcentrationBools && messages && outsideEngine,
		Message[Warning::CircularDichroismInconsistentAnalyteConcentration,
			ObjectToString[PickList[simulatedSamples,inconsistentConcentrationBools],Cache->cache],
			ObjectToString[PickList[resolvedAnalytesConcentrations,inconsistentConcentrationBools],Cache->cache],
			ObjectToString[PickList[analyteKnownCleanedConcentrations,inconsistentConcentrationBools],Cache->cache]
		]
	];

	(* Create a test for the valid samples and one for the invalid samples *)
	inconsistentConcentrationTests=sampleTests[
		gatherTests,
		Warning,
		simulatedSamplePackets,
		PickList[simulatedSamplePackets,inconsistentConcentrationBools],
		"The AnalyteConcentration is consistent with the sample's composition:",
		cache
	];


	(* Check for inValidEEWavelengthWarningQs and throw the corresponding Error if we're throwing messages *)
	(* we only throw this if we're not on Engine since we only want this warning displayed to the user, but not upset Engine *)
	If[Or@@inValidEEWavelengthWarningQs && messages && outsideEngine,
		Message[Warning::CircularDichroismEnantiomericExcessWavelengthsNotCovered,
			ObjectToString[PickList[simulatedSamples,inValidEEWavelengthWarningQs],Cache->cache],
			ObjectToString[resolvedEnantiomericExcessWavelength,Cache->cache],
			ObjectToString[PickList[resolvedDetectionWavelengths,inValidEEWavelengthWarningQs],Cache->cache]
		]
	];

	(* Create a test for the valid samples and one for the invalid samples *)
	inValidEEWavelengthWarningQs=detectionWavelengthReadPlateIncompatibleTests=sampleTests[
		gatherTests,
		Warning,
		simulatedSamplePackets,
		PickList[simulatedSamplePackets,inValidEEWavelengthWarningQs],
		"The EnantiomericExcessWavelengths is covered by the DetectionWavelength:",
		cache
	];



	(* Invalid input checks *)
	(* combine all the invalid options together *)
	invalidOptions=DeleteCases[
		DeleteDuplicates[Flatten[{
			invalidInstrumentOptions,
			invalidReadPlateOptions,
			invalidAliquotContainerOption,
			invalidMoatOptions,
			invalidRetainCoverOption,
			invalidEEstandardsOptions,
			invalidDetectionWavelengthOptions,
			incompatibleMoatSizeForQuartzPlateOptions,
			containersOutMismatchInvalidOptions,
			needMoreSamplesForEEOptions,
			unNeededBlankOptions,
			requiredBlankOptions,
			tooManySamplesInvalidOptions,
			duplicateDestinationWellOption,
			invalidDestinationWellLengthOption,
			invalidSampleVolumeOptions
		}]],
		Null
	];

	(* if there are any invalid options, throw Error::InvalidOption *)
	If[Not[MatchQ[invalidOptions,{}]]&&messages,
		Message[Error::InvalidOption,invalidOptions]
	];

	(* combine all the invalid inputs together *)
	invalidInputs=DeleteDuplicates[Flatten[{
		discardedInvalidInputs,
		compatibleMaterialsInvalidOption
	}]];

	(* if there are any invalid inputs, throw Error::InvalidInput *)
	If[Not[MatchQ[invalidInputs,{}]]&&messages,
		Message[Error::InvalidInput,invalidInputs]
	];


	(* - Resolve Remaining Sampling Options - *)

	(* SamplingDistance *)

	(* Figure out the container that will go into the plate reader to determine well diameter *)
	(* If we aren't aliquoting, samples are all required to be in one container *)
	(*assayContainerModelPacket=If[MatchQ[Lookup[resolvedAliquotOptions,Aliquot],{True..}],
		aliquotContainerModelPacket,
		First[sampleContainerModelPackets]
	];
	*)

	(* --- Combine the resolved options and tests together --- *)


	(* --- Resolve Label Options *)
	resolvedSampleLabel=Module[{suppliedSampleObjects, uniqueSamples, preResolvedSampleLabels, preResolvedSampleLabelRules},
		suppliedSampleObjects = Download[simulatedSamples, Object];
		uniqueSamples = DeleteDuplicates[suppliedSampleObjects];
		preResolvedSampleLabels = Table[CreateUniqueLabel["circular dichroism sample"], Length[uniqueSamples]];
		preResolvedSampleLabelRules = MapThread[
			(#1 -> #2)&,
			{uniqueSamples, preResolvedSampleLabels}
		];

		MapThread[
			Function[{object, label},
				Which[
					MatchQ[label, Except[Automatic]],
					label,
					MatchQ[updatedSimulation, SimulationP] && MatchQ[LookupObjectLabel[updatedSimulation, Download[object, Object]], _String],
					LookupObjectLabel[updatedSimulation, Download[object, Object]],
					True,
					Lookup[preResolvedSampleLabelRules, Download[object, Object]]
				]
			],
			{suppliedSampleObjects, Lookup[roundCircularDichroismOptions, SampleLabel]}
		]
	];

	resolvedSampleContainerLabel=Module[
		{suppliedContainerObjects, uniqueContainers, preresolvedSampleContainerLabels, preResolvedContainerLabelRules},
		suppliedContainerObjects = Download[Lookup[simulatedSamplePackets, Container, {}], Object];
		uniqueContainers = DeleteDuplicates[suppliedContainerObjects];
		preresolvedSampleContainerLabels = Table[CreateUniqueLabel["circular dichroism sample container"], Length[uniqueContainers]];
		preResolvedContainerLabelRules = MapThread[
			(#1 -> #2)&,
			{uniqueContainers, preresolvedSampleContainerLabels}
		];

		MapThread[
			Function[{object, label},
				Which[
					MatchQ[label, Except[Automatic]],
					label,
					MatchQ[updatedSimulation, SimulationP] && MatchQ[LookupObjectLabel[updatedSimulation, Download[object, Object]], _String],
					LookupObjectLabel[updatedSimulation, Download[object, Object]],
					True,
					Lookup[preResolvedContainerLabelRules, Download[object, Object]]
				]
			],
			{suppliedContainerObjects, Lookup[roundCircularDichroismOptions, SampleContainerLabel]}
		]
	];


	(* get the final resolved options, pre-collapsed (that is only happening outside this function) *)
	resolvedOptions=ReplaceRule[
		(* Recreate full set of options - necessary since we're using Append->False *)
		Join[Normal[roundCircularDichroismOptions],unresolvedPrepOptions],
		Join[
			{
				Instrument->instrument,
				PreparedPlate->preparedPlate,
				ReadPlate->resolvedReadPlate,
				ContainerOut->resolvedContainerOut,
				Blanks->resolvedBlanks,
				BlankVolumes->resolvedBlankVolumes,
				NumberOfReplicates->resolvedNumReplicates,
				MoatSize->resolvedMoatSize,
				MoatBuffer->resolvedMoatBuffer,
				MoatVolume->resolvedMoatVolume,
				EnantiomericExcessMeasurement->resolvedEnantiomericExcessMeasurement,
				EnantiomericExcessWavelength->resolvedEnantiomericExcessWavelength,
				EnantiomericExcessStandards->resolvedEnantiomericExcessStandards,
				SampleVolume->resolvedSampleVolumes,
				CalculatingMolarEllipticitySpectrum->resolvedCalculatingMolarEllipticitySpectrums,
				Analyte->resolvedAnalytes,
				AnalyteConcentrations->resolvedAnalytesConcentrations,
				DetectionWavelength->resolvedDetectionWavelengths,
				StepSize->resolvedStepSizes,
				RetainCover->retainCover,
				NitrogenPurge->nitrogenPurge,
				EmptyAbsorbance->emptyAbsorbance,
				BlankAbsorbance->blankAbsorbance,
				ReadDirection->readDirection,
				AverageTime->averageTime,
				SamplesOutStorageCondition->samplesOutStorageCondition,
				SampleLabel->resolvedSampleLabel,
				SampleContainerLabel->resolvedSampleContainerLabel,
				(*
				Gain->gain,
				NumberOfReadings->numberOfReadings,
				*)
				Name->name,
				Email->email
			},
			resolvedPrepOptions,
			resolvedAliquotOptions,
			resolvedPostProcessingOptions
		],
		(* If one of our replacements isn't in our original set of options, this means it's experiment specific, so just drop it here by using Append->False *)
		Append->False
	];


	(* combine all the tests together  *)
	allTests=Cases[
		Flatten[{
			invalidInstrumentTest,
			invalidReadPlateTest,
			optionPrecisionTests,
			aliquotContainerTest,
			moatTests,
			resolveAliquotOptionsTests,
			compatibleMaterialsTests,
			quartzPlateRetainCoverTests,
			needMoreEEStandardsTest,
			unknownEEStandardsTest,
			invalidDetectionWavelengthTests,
			detectionWavelengthReadPlateIncompatibleTests,
			cannotalculatingMolarEllipticityTests,
			invalidAnalyteTests,
			containersOutStorageConditionTests,
			quartzPlateNeedMoatTests,
			needMoreSamplesForEETests,
			unNeededBlankTests,
			tooManySampleTests,
			requiredBlankTests,
			inconsistentConcentrationTests,
			duplicateDestinationWellTest,
			invalidDestinationWellLengthTest,
			invalidSampleVolumeTests
		}],
		_EmeraldTest
	];

	(* generate the tests rule *)
	testsRule=Tests->If[gatherTests,
		allTests,
		Null
	];

	(* generate the Result output rule *)
	(* if not returning Result, or the resources are not fulfillable, Results rule is just Null *)
	resultRule=Result->If[MemberQ[output,Result],
		resolvedOptions,
		Null
	];

	(* return the output as we desire it *)
	outputSpecification/.{resultRule,testsRule}

];


(* ::Subsubsection:: *)
(*circularDichroismResourcePackets *)

DefineOptions[
	circularDichroismResourcePackets,
	Options:>{HelperOutputOption,CacheOption,SimulationOption}
];

circularDichroismResourcePackets[mySamples: {ObjectP[Object[Sample]]..}, myUnresolvedOptions: {___Rule}, myResolvedOptions: {___Rule}, ops: OptionsPattern[]] := Module[
	{
		expandedResolvedOptions, outputSpecification, output, gatherTests, messages, numReplicates, samplesInWithReplicates,
		containerOutObj, blankVolumeRules, blankVolumesWithReplicates, uniqueBlankVolumes, emptyWell, blankAbsorbance,
		readDirection, listedInstrumentAndPlatesPackets, instrumentModelPacket, instrumentModel, mergedBlankVolumeRules,
		resolvedOptionsNoHidden, previewRule, optionsRule, testsRule, resultRule, allResourceBlobs, fulfillable, frqTests,
		plateCoverResource, instrumentResource, containerOutModelPacket, expandedInputs, blanksWithReplicates, moatSize,
		blankResources, uniqueBlankObjects, talliedBlankResources, blankPositions, fumeHoodModels, listedReadPlatePackets,
		blankResourceReplaceRules, moatBuffer, moatVolume, sampleVolumes, instrument, readPlateModel, cache, sampleVolumeRules,
		sampleResourceReplaceRules, samplesInResources, sampleVolumeWithReplicates, resourcePacketDownload, containersIn,
		estimatedReadingTime, readPlate, protocolPacket, prepPacket, finalizedPacket, pairedSamplesInAndVolumes, stepSize,
		containersInResources, readPlateMaterials, aliquotQWithReplicates, aliquotVolumeWithReplicates, plateDownloadFields,
		emptyAbsorbance, checkpoints, averageTime, preparedPlate, quartzReadPlateQ, listedSamplePackets, listedSampleContainers,
		samplesInPackets, containerObjs, detectionWavelengths, lengthOfMeasurement, containersOutResourcesLinked,
		optionsWithReplicates, blankWells, remainingWellsAfterBlanks, blankObjectWithReplicates, readPlateModelPacket,
		plateWells, moatWells, orderedWells, availableWells, minWavelengths, maxWavelengths, wavelengthSelections,
		needMoatBufferQ, totalMoatVolume, moatBufferResource, retainCover, enantiomericExcessStandards, samplesInObjectToWellAssoc,
		enantiomericExcessStandardObjects, enantiomericExcessStandardValues, containersOutModel, containerOutInfoPacket,
		uniqueBlankTuples, uniqueBlankObjectsForResource, uniqueBlankVolumesForResource, enantiomericExcessWells,
		blankWellToReference, blankObjectToWellAssoc, containerOut, listedContainerOutPacket, outContainerMaxVolume,
		outContainerNumWells, readPlateNumWells, requiredNumContainerOut, measureLengthOfBlanks, fumeHoodResource,
		handWashReadPlateQ, simulation, updatedSimulation, inheritedCache, cacheBall, destinationWells, samplesInWells,
		preoccupiedWells, simulatedSamples
	},


	(* expand the resolved options if they weren't expanded already *)
	{expandedInputs, expandedResolvedOptions} = ExpandIndexMatchedInputs[ExperimentCircularDichroism, {mySamples}, myResolvedOptions];

	(* get the resolved collapsed index matching options that don't include hidden options *)
	resolvedOptionsNoHidden = CollapseIndexMatchedOptions[
		ExperimentCircularDichroism,
		RemoveHiddenOptions[ExperimentCircularDichroism, myResolvedOptions],
		Ignore -> myUnresolvedOptions,
		Messages -> False
	];

	(* pull out the Output option and make it a list (and also the cache) *)
	outputSpecification = Lookup[ToList[myResolvedOptions], Output];
	output = ToList[outputSpecification];

	(* determine if we should keep a running list of tests; if True, then silence the messages *)
	gatherTests = MemberQ[output, Tests];
	messages = Not[gatherTests];
	
	(* Get the inherited cache *)
	cache = Lookup[ToList[myResolvedOptions], Cache, {}];
	simulation = Lookup[ToList[myResolvedOptions], Simulation, {}];
	
	inheritedCache = Lookup[ToList[ops], Cache];
	
	cacheBall = FlattenCachePackets[{cache, inheritedCache}];
	
	(* pull out the Instrument and ContainerOut to be downloaded option *)
	{instrument, readPlate, containerOut} = Lookup[expandedResolvedOptions, {Instrument, ReadPlate, ContainerOut}];

	(* simulate the samples after they go through all the sample prep *)
	{simulatedSamples, updatedSimulation} = simulateSamplesResourcePacketsNew[ExperimentCircularDichroism, mySamples, myResolvedOptions, Cache -> cacheBall, Simulation -> simulation];

	(* Collect fields we want to download for plates*)
	plateDownloadFields = {MaxVolume, NumberOfWells, AspectRatio};
	
	
	(* make a Download call to get the sample, container, and instrument packets *)
	resourcePacketDownload = Quiet[
		Download[
			{
				mySamples,
				mySamples,
				ToList[readPlate],
				ToList[containerOut],
				ToList[instrument]
			},
			{
				{Packet[Container, Position]},
				{Container[Object]},
				{Packet[ContainerMaterials, Model, Contents], Packet[Model[{ContainerMaterials, AllowedPositions}]]},
				{Packet[MaxVolume, NumberOfWells], Packet[Model[{MaxVolume, NumberOfWells}]], Packet[Model]},
				{Packet[Model]}
			},
			Cache -> cacheBall,
			Simulation -> updatedSimulation,
			Date -> Now
		],
		{Download::FieldDoesntExist, Download::NotLinkField}
	];

	(* Collect all informations into different lists*)
	{listedSamplePackets, listedSampleContainers, listedReadPlatePackets, listedContainerOutPacket, listedInstrumentAndPlatesPackets} = resourcePacketDownload;

	(* extract out the packets *)
	samplesInPackets = Flatten[listedSamplePackets];
	containerObjs = Flatten[listedSampleContainers];
	instrumentModelPacket = listedInstrumentAndPlatesPackets[[All, 1]];
	

	(* Extract all info for the containersOut packet, if the ContainerOut is Null, return an empty list *)
	containerOutInfoPacket = If[NullQ[containerOut], {}, Flatten[({listedContainerOutPacket[[All, 1]], listedContainerOutPacket[[All, 2]]}/.$Failed -> {})]];

	(* Get the instrument model *)
	instrumentModel = If[MatchQ[instrument, ObjectP[Model[Instrument, PlateReader]]],
		Download[instrument, Object],
		Download[Lookup[instrumentModelPacket, Model], Object]
	];

	(* Get the ReadPlate Model *)
	readPlateModel = If[MatchQ[readPlate, ObjectP[Model[Container, Plate]]],
		Download[readPlate, Object],
		Download[FirstOrDefault[Lookup[Flatten[listedReadPlatePackets], Model, Null]], Object]
	];

	(* Get the readplate model packet *)
	readPlateModelPacket = fetchPacketFromCache[readPlateModel, Flatten[listedReadPlatePackets/.$Failed -> {}]];

	(* fetch the readplate material *)
	readPlateMaterials = Lookup[readPlateModelPacket, ContainerMaterials];

	(* Generate a check for if the readplate is quartz if so we need to hand wash the readplate *)
	quartzReadPlateQ = MemberQ[readPlateMaterials, Quartz];

	(* Get the container out model model*)
	containersOutModel = If[NullQ[containerOut],
		Null,
		If[
			MatchQ[containerOut, ObjectP[Model[Container]]],
			Download[containerOut, Object],
			Download[Lookup[Flatten[listedContainerOutPacket[[All, 3]]], Model], Object]
		]
	];

	(* fetch the model packet *)
	containerOutModelPacket = If[NullQ[containerOut], Null, fetchPacketFromCache[FirstOrDefault[ToList[containersOutModel]], containerOutInfoPacket]];

	(* --- Make resources for SamplesIn --- *)
	(* get the number of replicates, this should already to be a not Null number *)
	numReplicates = Lookup[expandedResolvedOptions, NumberOfReplicates];

	(* Expand the function with a helper function *)
	{samplesInWithReplicates,optionsWithReplicates} = expandCircularDichroismReplicates[mySamples, expandedResolvedOptions, numReplicates];

	(* Build a search call for all FumeHood models *)
	fumeHoodModels = Search[Model[Instrument, FumeHood], Deprecated != True];

	(* Extract with all expanded options*)
	{
		(*1*)aliquotQWithReplicates,
		(*2*)aliquotVolumeWithReplicates,
		(*3*)sampleVolumeWithReplicates,
		(*4*)blankAbsorbance,
		(*5*)blanksWithReplicates,
		(*6*)blankVolumesWithReplicates,
		(*8*)readDirection,
		(*9*)emptyAbsorbance,
		(*10*)moatSize,
		(*11*)moatBuffer,
		(*12*)moatVolume,
		(*13*)detectionWavelengths,
		(*14*)retainCover,
		(*15*)averageTime,
		(*16*)stepSize,
		(*17*)enantiomericExcessStandards,
		(*18*)preparedPlate,
		(*19*)destinationWells
	} = Lookup[optionsWithReplicates,
		{
			(*1*)Aliquot,
			(*2*)AliquotAmount,
			(*3*)SampleVolume,
			(*4*)BlankAbsorbance,
			(*5*)Blanks,
			(*6*)BlankVolumes,
			(*8*)ReadDirection,
			(*9*)EmptyAbsorbance,
			(*10*)MoatSize,
			(*11*)MoatBuffer,
			(*12*)MoatVolume,
			(*13*)DetectionWavelength,
			(*14*)RetainCover,
			(*15*)AverageTime,
			(*16*)StepSize,
			(*17*)EnantiomericExcessStandards,
			(*18*)PreparedPlate,
			(*19*)DestinationWell
		}
	];


	(* get the sample volumes we need to reserve with each sample, accounting for the number of replicates, whether we're aliquoting, and whether we're using the lunatic *)
	sampleVolumes = MapThread[
		Function[{eachAliquot, eachAliquotVolume, eachSampleVolume},
			If[eachAliquot, eachAliquotVolume, eachSampleVolume]
		],
		{aliquotQWithReplicates, aliquotVolumeWithReplicates, sampleVolumeWithReplicates}
	];

	(* make rules correlating the volumes with each sample in *)
	(* note that we CANNOT use AssociationThread here because there might be duplicate keys (we will Merge them down below), and so we're going to lose duplicate volumes *)
	pairedSamplesInAndVolumes = MapThread[#1 -> #2&, {samplesInWithReplicates, sampleVolumes}];

	(* merge the SamplesIn volumes together to get the total volume of each sample's resource *)
	(* need to do this with thing with Nulls in our Merge because otherwise we'll end up with Total[{Null, Null}], which would end up being 2*Null, which I don't want *)
	sampleVolumeRules = Merge[pairedSamplesInAndVolumes, If[NullQ[#], Null, Total[DeleteCases[#, Null]]]&];

	(* make replace rules for the samples and its resources *)
	sampleResourceReplaceRules = KeyValueMap[
		Function[{sample, volume},
			If[NullQ[volume],
				sample -> Resource[Sample -> sample, Name -> CreateUUID[]],
				sample -> Resource[Sample -> sample, Name -> CreateUUID[], Amount -> volume]
			]
		],
		sampleVolumeRules
	];

	(* use the replace rules to get the sample resources *)
	samplesInResources = Replace[samplesInWithReplicates, sampleResourceReplaceRules, {1}];

	(* retrieve the total number of wells on the ReadPlate, for now we only accept 96-well plate *)
	readPlateModelPacket = Download[readPlateModel, Packet[MaxVolume, NumberOfWells, AspectRatio], Simulation -> updatedSimulation, Cache -> cacheBall];
	
	(* Get all wells in the plate *)
	plateWells = AllWells[readPlateModelPacket];

	(* Get the moat wells *)
	moatWells = getMoatWells[AllWells[readPlateModelPacket], (moatSize/.Null->0)];

	(* Re-order the wells based on read direction *)
	orderedWells = Switch[readDirection,
		Row, Flatten[plateWells],
		Column,	Flatten[Transpose[plateWells]],
		SerpentineRow,
			Flatten[MapThread[
				If[OddQ[#2], #1,Reverse[#1]]&,
				{plateWells, Range[Length[plateWells]]}
			]],
		SerpentineColumn,
			Flatten[MapThread[
				If[OddQ[#2], #1, Reverse[#1]]&,
				{Transpose[plateWells], Range[Length[Transpose[plateWells]]]}
			]]
	];

	(* If sample is already on a compatible read plate, get the wells, otherwise this will be an empty list *)
	samplesInWells = If[TrueQ[preparedPlate],
		Module[{sampleWellRule},
			(* Association from sample to well *)
			sampleWellRule = Map[
				(Lookup[#, Object] -> Lookup[#, Position])&,
				samplesInPackets
			];
			Download[samplesInWithReplicates, Object] /. sampleWellRule
		],
		{}
	];

	(* check if there are other occupied wells on the read plate already if it is an object, we just cannot use those wells *)
	preoccupiedWells = If[MatchQ[readPlate, ObjectP[Object[Container, Plate]]],
		Module[{readPlatePacket},
			(* Get the read plate's content if it is an object *)
			readPlatePacket = fetchPacketFromCache[readPlate, Flatten[listedReadPlatePackets /. $Failed -> {}]];
			Cases[Lookup[readPlatePacket, Contents][[All, 1]], LocationPositionP]
		],
		{}
	];

	(* Remove any moat wells from our possible wells - use DeleteCases to avoid rearranging, also remove destionation wells which will be the sample wells *)
	availableWells = DeleteCases[orderedWells, Alternatives @@ DeleteDuplicates[Join[moatWells, destinationWells, samplesInWells, preoccupiedWells]]];

	(* --- Generate the resources for blanks --- *)
	(* get the Blanks accounting for the number of replicates and retrieve it with object*)
	blankObjectWithReplicates = Download[blanksWithReplicates, Object];

	(* --- Here we'll resolved all resolved blank, only run the unique blank samples, and link them to the corresponding SamplesIn---*)
	(* get the blanks without dupes *)
	uniqueBlankTuples = DeleteDuplicates[Transpose[{blankObjectWithReplicates, blankVolumesWithReplicates, detectionWavelengths,stepSize}]];
	
	(* extract the unique object and unique volume*)
	{uniqueBlankObjects, uniqueBlankVolumes} = {uniqueBlankTuples[[All, 1]], uniqueBlankTuples[[All, 2]]};
	
	(* need to combine the blanks and how much volume we need for each of them together *)
	(* Remove any duplicate sample-volume pairs since we only need one instance for blanking *)
	blankVolumeRules = DeleteDuplicates[
		MapThread[
			#1 -> #2&,
			{uniqueBlankObjects, uniqueBlankVolumes}
		]
	];

	(* group and sum the volumes where the blank model is the same *)
	(* oh man Hayley look I used Merge all by myself*)
	mergedBlankVolumeRules = Merge[blankVolumeRules, Total];

	(* get the blanks without dupes, this is for resource packet, not for compiler*)
	{uniqueBlankObjectsForResource, uniqueBlankVolumesForResource} = {Keys[mergedBlankVolumeRules], Values[mergedBlankVolumeRules]};

	(* create a resource for each of the different kinds of blanks for each split protocol *)
	talliedBlankResources = KeyValueMap[
		(* doing this With call to ensure that I only have to call AchievableResolution once per loop since it is kind of slow *)
		(* we're going to make as many blanks as replicates so must multiply volume by this amount *)
		With[{achievableResolution = AchievableResolution[#2 * 1.1 * numReplicates, Messages -> False]},
			If[MatchQ[#1,Null],
				#1,
				Resource@@{
					Sample -> #1,
					If[MatchQ[achievableResolution, VolumeP],
						Amount -> achievableResolution,
						Nothing
					],
					If[MatchQ[#1, ObjectP[Model]],
						Container -> PreferredContainer[achievableResolution, LiquidHandlerCompatible -> True],
						Nothing
					],
					Name -> CreateUUID[]
				}
			]
		]&,
		mergedBlankVolumeRules
	];

	(* get the position of each of the models in the list of blanks *)
	blankPositions = Map[
		Position[blankObjectWithReplicates, #]&,
		uniqueBlankObjectsForResource
	];

	(* make replace rules converting the blank models to their resources to be used in ReplacePart below *)
	blankResourceReplaceRules = MapThread[
		#1 -> #2&,
		{blankPositions, talliedBlankResources}
	];

	(* use ReplacePart to return the blank resources *)
	blankResources = ReplacePart[blanksWithReplicates, blankResourceReplaceRules];

	(* Now we assign blank wells*)
	(* Assigned the sample wells from the beginning of the available wells and generate remaining wells for blanks and empty *)
	{blankWells, remainingWellsAfterBlanks} = If[ContainsOnly[uniqueBlankObjects, {Null}], {Null, availableWells}, TakeList[availableWells, {Length[uniqueBlankObjects], All}]];

	(* Finally assign empty well for scan*)
	emptyWell = If[emptyAbsorbance, Take[remainingWellsAfterBlanks, 1], Null];

	(* Now we further assign wells for enantiomeric excess standards and link unique blanks to sample.*)
	samplesInObjectToWellAssoc = Association @@ Flatten[MapThread[{#1 -> #2}&, {Download[samplesInWithReplicates, Object], destinationWells}]];

	(* Lookup the wells *)
	{enantiomericExcessStandardObjects, enantiomericExcessStandardValues} = If[NullQ[enantiomericExcessStandards],
		{{}, {}},
		{enantiomericExcessStandards[[All, 1]],enantiomericExcessStandards[[All, 2]]}
	];

	enantiomericExcessWells = Lookup[samplesInObjectToWellAssoc, #]& /@ (Download[enantiomericExcessStandardObjects, Object]);

	(* build a blank to wells association *)
	blankObjectToWellAssoc = Association @@ Flatten[MapThread[{#1 -> #2}&, {uniqueBlankObjects, ToList[blankWells]}]];

	(* list of reference *)
	blankWellToReference = Lookup[blankObjectToWellAssoc, #]& /@ (Download[blanksWithReplicates, Object]);

	(* ---Generate Moat Resources--- *)
	needMoatBufferQ = And[MatchQ[moatBuffer, ObjectP[{Model[Sample], Object[Sample]}]], MatchQ[moatVolume, VolumeP]];

	(* calculate the total amount of moat buffer I need for this task, collect 1.1* needed volume for room of errors*)
	totalMoatVolume = If[needMoatBufferQ, AchievableResolution[(1.1*Length[Flatten[moatWells]]*moatVolume), Messages -> False], Null];

	(* --- Generate the resource with liquid handler compatible container ---*)
	moatBufferResource = If[needMoatBufferQ,
		Resource[Sample -> moatBuffer, Container -> PreferredContainer[totalMoatVolume, LiquidHandlerCompatible -> True], Name -> CreateUUID[], Amount -> totalMoatVolume, RentContainer -> True],
		Null
	];

	(* --- Generate containers out resources---*)
	(* first calculate how many containers we gonna use as the samples out*)
	(* First retrieve the info for the readplate and  *)
	{outContainerMaxVolume, outContainerNumWells} = If[NullQ[containerOut],
		{Null, Null},
		Flatten[Lookup[containerOutModelPacket, {MaxVolume, NumberOfWells}, Null]]
	];

	(* Retrieve read plate number of wells *)
	readPlateNumWells = Lookup[readPlateModelPacket, NumberOfWells];

	(* calculate how many read plates we gonna need *)
	requiredNumContainerOut = If[NullQ[containerOut],
		1,
		Max[Ceiling[(sampleVolumeWithReplicates/outContainerMaxVolume)]*Ceiling[readPlateNumWells/outContainerNumWells]]
	];

	containerOutObj = Download[containerOut, Object];

	(* Generated containersOutResource*)
	containersOutResourcesLinked = Which[
		NullQ[containerOut], {},
		MatchQ[containerOutObj, ObjectP[Model[Container]]], Link[Resource[Sample -> #, Name -> CreateUUID[]]]& /@ ConstantArray[containerOut, requiredNumContainerOut],
		MatchQ[containerOutObj, ObjectP[Object[Container]]], Link[Resource[Sample -> #, Name -> CreateUUID[]], Protocols]& /@ ConstantArray[containerOut, requiredNumContainerOut]
	];


	(* --- Generate Resources for plate cover ---*)
	plateCoverResource = If[retainCover, Resource[Sample -> Model[Item, Lid, "Universal Black Lid"], Name -> CreateUUID[]], Null];

	(* --- Generate Resources for plate seal, if retainCover is true, won't bother to use plate seal to protect the sample after the sample manipulation ---*)
	(*	plateSealResource=If[retainCover, Null, Resource[Sample->Model[Item, PlateSeal, "id:Vrbp1jKZJ0Rm"],Name->CreateUUID[],Amount->1]];*)

	(* Non-resource upload options *)
	(* Expand DetectionWavelength to *)
	{minWavelengths, maxWavelengths, wavelengthSelections} = Transpose@Map[
		Function[{eachDetectionWavelengths},
			If[MatchQ[eachDetectionWavelengths, _Span],
				{Min[List@@eachDetectionWavelengths], Max[List@@eachDetectionWavelengths], Null},
				{Null, Null, ToList[eachDetectionWavelengths]}
			]
		],
		detectionWavelengths
	];


	(* get the containers in from the sample's containers *)
	containersIn = DeleteDuplicates[containerObjs];

	(* ContainersIn resource*)
	containersInResources = Resource[Sample -> #]& /@ containersIn;

	(* ReadPlate Resource*)

	(* Check how many data point we will measure*)
	lengthOfMeasurement = Length[#/.Span->Range]& /@ detectionWavelengths;

	(* Generate the measure length for the Blank and Empty weills *)
	measureLengthOfBlanks= Length[DeleteDuplicates[Flatten[{detectionWavelengths/.Span -> Range}]]];

	(* get the estimated reading time, add 25 minutes so we will shut down the instrument after this estimatedReadTime*)
	estimatedReadingTime = Convert[

		(*Calculate length of time based on the length of the measurement*AverageTime*)
		(
			Total[(averageTime*lengthOfMeasurement+4Minute)] +

				(* For blank and empty assume they will collect all wavelengths*)
			Total[(averageTime*ConstantArray[measureLengthOfBlanks, (Length[blankWells]+Length[emptyWell])]+4Minute)]
		),
		Minute
			(* Add 20 minute safe time before we turn off the instrument by PDU *)
	]+20Minute;

	(* Generate the instrument resource based on the estimate reading time *)
	instrumentResource = Resource[Instrument -> instrument, Time -> (estimatedReadingTime+20Minute), Name -> CreateUUID[]];

	(* Generate the Resource for fume hood if we are using quartz plate, we will need to handwash the quartz plate in the FumeHood *)
	(* For now we only handwash when readplate is quartz and it's not a prepared plate*)
	handWashReadPlateQ = And[quartzReadPlateQ,!preparedPlate];

	fumeHoodResource = If[handWashReadPlateQ, Resource[Name -> CreateUUID[], Instrument -> fumeHoodModels, Time -> 30 Minute], Null];

	(* generate check point*)
	checkpoints = {
		{"Preparing Samples", 1 Minute, "Preprocessing, such as incubation, mixing, centrifuging, and aliquoting, is performed.", Link[Resource[Operator -> Model[User, Emerald, Operator, "Trainee"], Time -> 1 Minute]]},
		{"Picking Resources", 10 Minute, "Samples required to execute this protocol are gathered from storage.", Link[Resource[Operator -> Model[User, Emerald, Operator, "Trainee"], Time -> 10 Minute]]},
		{"Preparing Read Plate", If[preparedPlate, 1 Minute,20 Minute], "Transfer all samples to read plate, which will be inserted into the instrument.", Link[Resource[Operator -> Model[User, Emerald, Operator, "Trainee"], Time -> 15 * Minute]]},
		{"Measuring Circular Dichroism", estimatedReadingTime, "Samples' circular dichroism and absorbance are measured.", Link[Resource[Operator -> Model[User, Emerald, Operator, "Trainee"], Time -> 15 * Minute]]},
		{"Sample Post-Processing", 1 Hour, "Any measuring of volume, weight, or sample imaging post experiment is performed.", Link[Resource[Operator -> Model[User, Emerald, Operator, "Trainee"], Time -> 5 * Minute]]},
		{"Pre-Washing ReadPlate",If[handWashReadPlateQ,30 Minute,0 Minute], "Pre-wash the quartz read plate in a fume hood.",Link[Resource[Operator -> Model[User, Emerald, Operator, "Trainee"], Time -> 30 * Minute]]},
		{"Returning Materials", 10 Minute, "Samples are returned to storage.", Link[Resource[Operator -> Model[User, Emerald, Operator, "Trainee"], Time -> 10 * Minute]]}
	};

	(* --- Generate our protocol packet --- *)

	(* fill in the protocol packet with all the resources *)
	protocolPacket = <|
		Object -> CreateID[Object[Protocol,CircularDichroism]],
		Template -> If[MatchQ[Lookup[resolvedOptionsNoHidden, Template], FieldReferenceP[]],
			Link[Most[Lookup[resolvedOptionsNoHidden, Template]], ProtocolsTemplated],
			Link[Lookup[resolvedOptionsNoHidden, Template], ProtocolsTemplated]
		],
		UnresolvedOptions -> myUnresolvedOptions,
		ResolvedOptions -> resolvedOptionsNoHidden,
		Replace[Checkpoints] -> checkpoints,

		(*Resources to be upload*)
		Replace[SamplesIn] -> (Link[#, Protocols]& /@ samplesInResources),
		Replace[ContainersIn] -> (Link[#, Protocols]& /@ containersInResources),
		Replace[ContainersOut] -> containersOutResourcesLinked,


		(* will only give the re*)
		ReadPlate -> Link[readPlate],
		Instrument -> Link[instrumentResource],
		MoatBuffer -> Link[moatBufferResource],
		Replace[Blanks] -> Link/@blankResources,

		PlateCover -> Link[plateCoverResource],

		(* Generated values for resolved upload *)
		(* Multiple fields *)
		Replace[MinWavelengths] -> minWavelengths,
		Replace[MaxWavelengths] -> maxWavelengths,
		Replace[Wavelengths] -> wavelengthSelections,
		Replace[StepSizes] -> stepSize,
		Replace[ReadDirection] -> readDirection,
		Replace[RetainCover] -> retainCover,
		Replace[SampleVolumes] -> sampleVolumes,
		Replace[BlankVolumes] -> blankVolumesWithReplicates,
		Replace[UniqueBlanks] -> Link /@ uniqueBlankObjects,
		Replace[UniqueBlankVolumes] -> uniqueBlankVolumes,
		Replace[EnantiomericExcessStandards] -> Link /@ enantiomericExcessStandardObjects,
		AverageTime -> averageTime,
		MoatSize -> moatSize,
		MoatVolume -> moatVolume,
		(*wells*)
		Replace[SamplesInWells] -> If[TrueQ[preparedPlate], samplesInWells, destinationWells],
		Replace[BlankWells] -> blankWells,
		Replace[EnantiomericExcessStandardWells] -> enantiomericExcessWells,
		Replace[BlankWellToReference] -> blankWellToReference,
		Replace[EmptyWells] -> emptyWell,

		(*field use to processing stage*)
		EstimatedProcessingTime -> estimatedReadingTime,

		(* Cleaning Resource*)
		FumeHood -> Link[fumeHoodResource],
		HandWashReadPlate -> handWashReadPlateQ,

		(*Upload the rest options*)
		PreparedPlate -> preparedPlate,
		(*
		Gain->Lookup[optionsWithReplicates,Gain],
		Replace[NumberOfReadings]->Lookup[optionsWithReplicates,NumberOfReadings],
		*)
		NitrogenPurge -> Lookup[optionsWithReplicates, NitrogenPurge],
		EnantiomericExcessMeasurement -> Lookup[optionsWithReplicates, EnantiomericExcessMeasurement],
		Replace[CalculatingMolarEllipticitySpectrum] -> Lookup[optionsWithReplicates, CalculatingMolarEllipticitySpectrum],
		Replace[Analytes] -> Link /@ Lookup[optionsWithReplicates, Analyte],
		Replace[AnalyteConcentrations] -> Lookup[optionsWithReplicates, AnalyteConcentrations],
		Replace[SamplesInStorage] -> Lookup[optionsWithReplicates, SamplesInStorageCondition],
		Replace[SamplesOutStorage] -> Lookup[optionsWithReplicates, SamplesOutStorageCondition],
		Replace[EnantiomericExcessWavelengths] -> Lookup[optionsWithReplicates, EnantiomericExcessWavelength],
		Replace[EnantiomericExcessStandardValues] -> enantiomericExcessStandardValues
	|>;


	(* generate a packet with the shared fields *)
	prepPacket = populateSamplePrepFields[mySamples, expandedResolvedOptions, Cache -> cacheBall, Simulation->updatedSimulation];

	(* Merge the shared fields with the specific fields *)
	finalizedPacket = Association@@(ReplaceRule[Normal[protocolPacket], Normal[prepPacket]]);

	(* get all the resource blo---sorry, "symbolic representations" *)
	(* need to pull these at infinite depth because otherwise all resources with Link wrapped around them won't be grabbed *)
	allResourceBlobs = DeleteDuplicates[Cases[Flatten[Values[finalizedPacket]], _Resource, Infinity]];

	(* call fulfillableResourceQ on all the resources we created *)
	{fulfillable, frqTests} = Which[
		MatchQ[$ECLApplication, Engine], {True, {}},
		gatherTests, Resources`Private`fulfillableResourceQ[allResourceBlobs, Output -> {Result, Tests}, FastTrack -> Lookup[myResolvedOptions, FastTrack], Site -> Lookup[myResolvedOptions,Site], Cache -> cacheBall, Simulation -> updatedSimulation],
		True, {Resources`Private`fulfillableResourceQ[allResourceBlobs, FastTrack -> Lookup[myResolvedOptions, FastTrack], Site -> Lookup[myResolvedOptions, Site], Messages -> messages, Cache -> cacheBall, Simulation -> updatedSimulation], Null}
	];

	(* generate the Preview option; that is always Null *)
	previewRule = Preview -> Null;

	(* generate the options output rule *)
	optionsRule = Options -> If[MemberQ[output, Options],
		resolvedOptionsNoHidden,
		Null
	];

	(* generate the tests rule *)
	testsRule = Tests -> If[gatherTests,
		frqTests,
		Null
	];

	(* generate the Result output rule *)
	(* if not returning Result, or the resources are not fulfillable, Results rule is just $Failed *)
	resultRule = Result -> If[MemberQ[output, Result] && TrueQ[fulfillable],
		finalizedPacket,
		$Failed
	];

	(* return the output as we desire it *)
	outputSpecification /. {previewRule, optionsRule, resultRule, testsRule}

];

(* ::Subsection::Closed:: *)
(*Simulation*)

DefineOptions[
	simulateExperimentCircularDichroism,
	Options :> {CacheOption, SimulationOption}
];

simulateExperimentCircularDichroism[myResourcePacket: (PacketP[Object[Protocol, CircularDichroism], {Object, ResolvedOptions}]|$Failed), mySamples: {ObjectP[Object[Sample]]...}, myResolvedOptions: {_Rule...}, myResolutionOptions: OptionsPattern[simulateExperimentCircularDichroism]] := Module[
	{cache, simulation, samplePackets, protocolObject, fulfillmentSimulation, simulationWithLabels},

	(* Lookup our cache and simulation. *)
	cache = Lookup[ToList[myResolutionOptions], Cache, {}];
	simulation = Lookup[ToList[myResolutionOptions], Simulation, Null];

	(* Download containers from our sample packets. *)
	samplePackets = Download[
		mySamples,
		Packet[Container],
		Cache -> cache,
		Simulation -> simulation
	];

	(* Get our protocol ID. This should already be in our protocol packet, unless the resource packets failed. *)
	protocolObject = If[MatchQ[myResourcePacket, $Failed],
		SimulateCreateID[Object[Protocol, CircularDichroism]],
		Lookup[myResourcePacket, Object]
	];

	(* Simulate the fulfillment of all resources by the procedure. *)
	(* NOTE: We won't actually get back a resource packet if there was a problem during option resolution. In that case, *)
	(* just make a shell of a protocol object so that we can return something back. *)
	fulfillmentSimulation = If[MatchQ[myResourcePacket, $Failed],
		SimulateResources[
			<|
				Object -> protocolObject,
				Replace[SamplesIn] -> (Resource[Sample -> #, Name -> CreateUUID[]]& /@ mySamples),
				ResolvedOptions -> myResolvedOptions
			|>,
			Cache -> cache,
			Simulation -> simulation
		],
		SimulateResources[
			myResourcePacket,
			Cache -> cache,
			Simulation -> simulation
		]
	];

	(* We don't have any SamplesOut for our protocol object, so right now, just tell the simulation where to find the *)
	(* SamplesIn field. *)
	simulationWithLabels = Simulation[
		Labels -> Join[
			Rule @@@ Cases[
				Transpose[{Lookup[myResolvedOptions, SampleLabel], mySamples}],
				{_String, ObjectP[]}
			],
			Rule @@@ Cases[
				Transpose[{Lookup[myResolvedOptions, SampleContainerLabel], Lookup[samplePackets, Container]}],
				{_String, ObjectP[]}
			]
		],
		LabelFields -> Join[
			Rule @@@ Cases[
				Transpose[{Lookup[myResolvedOptions, SampleLabel], (Field[SampleLink[[#]]]&) /@ Range[Length[mySamples]]}],
				{_String, _}
			],
			Rule @@@ Cases[
				Transpose[{Lookup[myResolvedOptions, SampleContainerLabel], (Field[SampleLink[[#]][Container]]&) /@ Range[Length[mySamples]]}],
				{_String, _}
			]
		]
	];

	(* Merge our packets with our labels. *)
	{
		protocolObject,
		UpdateSimulation[fulfillmentSimulation, simulationWithLabels]
	}
];


(* ::Subsection:: *)
(*Helper Functions*)


(* ::Subsubsection::Closed:: *)
(*calculateEEFromPacket*)

(*Function Overload*)
calculateEEFromPacket[<||>] := {};
calculateEEFromPacket[{}] := {};

(*Single Input over load*)
calculateEEFromPacket[singlePacketInput_Association] := calculateEEFromPacket[{singlePacketInput}];

(*Helper function mainbody*)
calculateEEFromPacket[simulateSamplePackets : {_Association ..}]:=Module[
	{listOptions, opticalCompositionPacket, opticalCompositionValueList},

	(*add a safe check to make sure the option is a list*)
	listOptions = ToList[simulateSamplePackets];

	(* collect all the opticalCompositions*)
	opticalCompositionPacket = Lookup[listOptions, OpticalComposition,{}]/.Null->{};

	(* Extract the value from the result *)
	opticalCompositionValueList = #[[All, 1]] & /@ opticalCompositionPacket;

	(* Calculate the EE value, for now, since the inpute value may have trouble to justfity the which one is positive, we will use Max-Min value as the EE value.*)
	Map[
		If[Or[MatchQ[#, ({}|Null)], Length[#] > 2],
			(* Direct throw Null if the OpticalComposition contains more than 2 entris or is blank or Null*)
			Null,
			Max[PadRight[#, 2, 0 Percent]] - Min[PadRight[#, 2, 0 Percent]]
		] &,
		opticalCompositionValueList
	]
];


(* ::Subsection:: *)
(* expand samples/options for replicates *)
expandCircularDichroismReplicates[mySamples: {ObjectP[]...}, options: {(_Rule|_RuleDelayed)..}, numberOfReplicates: (_Integer|Null)] := Module[
	{samplesWithReplicates, mapThreadOptions, optionsWithReplicates},

	(* Repeat the inputs if we have replicates *)
	samplesWithReplicates = duplicateCircularDichroismReplicates[mySamples, numberOfReplicates];

	(* Determine options index-matched to the input *)
	mapThreadOptions = Lookup[Select[OptionDefinition[ExperimentCircularDichroism], MatchQ[Lookup[#, "IndexMatchingInput"], Except[Null]]&], "OptionSymbol"];

	(* Repeat MapThread options if we have replicates *)
	optionsWithReplicates = Map[
		If[MemberQ[mapThreadOptions, First[#]],
			First[#] -> duplicateCircularDichroismReplicates[Last[#], numberOfReplicates],
			First[#] -> Last[#]
		]&,
		options
	];

	{samplesWithReplicates, optionsWithReplicates}
];

(* == duplicateCircularDichroismReplicates HELPER == *)
(* Helper for expandCircularDichroismReplicates. Given non-expanded sample input, and the numberOfReplicate, repeat the inputs if we have replicates *)
duplicateCircularDichroismReplicates[value_, numberOfReplicates_] := Module[{},
	If[MatchQ[numberOfReplicates, Null],
		value,
		Flatten[Map[ConstantArray[#, numberOfReplicates]&, value], 1]
	]
];
