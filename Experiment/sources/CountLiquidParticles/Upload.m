(* ::Package:: *)

(* ::Text:: *)
(*\[Copyright] 2011-2023 Emerald Cloud Lab, Inc.*)


(* ::Section:: *)
(*Source Code*)


(* ::Subsection:: *)
(*UploadCountLiquidParticlesMethod*)

(* ::Subsubsection::Closed:: *)
(*$UploadCountLiquidParticlesAsDeveloperObject*)

(* in order for the tests not to mess up other tests, the unit tests are going to set this to True.  This makes the DeveloperObject field be True so that the created objects won't show up in Search *)
$UploadCountLiquidParticlesAsDeveloperObject = False;

(* ::Subsubsection::Closed:: *)
(*Options and Messages*)


DefineOptions[UploadCountLiquidParticlesMethod,
	Options:>{
		{
			OptionName->Sensor,
			Default->Model[Part,LightObscurationSensor,"2-400 um"],
			AllowNull->False,
			Widget -> Widget[
				Type->Object,
				Pattern:>ObjectP[{Object[Part,LightObscurationSensor],Model[Part,LightObscurationSensor]}](*,
				OpenPaths -> {
					{
						Object[Catalog, "Root"],
						"Instruments","Particle Counters"
					}
				}*)
			],
			Description->"The light obscuration sensor that measures the reduction in light intensity and processes the signal to determine particle size and count. The sensor sets the range of the particle sizes that can be detected.",
			Category->"General"
		},
		{
			OptionName->Syringe,
			Default->Automatic,
			AllowNull->False,
			Widget -> Widget[
				Type->Object,
				Pattern:>ObjectP[{Object[Part,Syringe],Model[Part,Syringe]}](*,
				OpenPaths -> {
					{
						Object[Catalog, "Root"],
						"Experiment Objects","HIAC Liquid Particle Counting", "Syringes"
					}
				}*)
			],
			Description->"The syringe installed on the instrument sampler used to draw the liquid through the light obscuration sensor and out of the system.",
			ResolutionDescription->"Automatically set based on the SyringeSize",
			Category->"General"
		},
		{
			OptionName -> SyringeSize,
			Default -> Automatic,
			AllowNull -> True,
			Widget -> Widget[Type -> Enumeration, Pattern :> HIACSyringeSizeP],
			Description -> "The size of the syringe installed on the instrument sampler used to draw the liquid through the light obscuration sensor and flush it back out.",
			ResolutionDescription -> "Automatically set to the 1 mL syringe if the sample volume is less and equal than 5 mL, and the 10 mL syringe otherwise.",
			Category -> "General" 
		},
		
		(*--- Sample Preparation ---*)
		IndexMatching[
			IndexMatchingInput->"experiment samples",
			{
				OptionName -> Name,
				Default -> Null,
				Description -> "Name to be used as the names of Object[Method, LiquidParticleCounting] generated by the analysis.",
				AllowNull -> True,
				Category -> "General",
				Widget -> Widget[Type->Expression,Pattern:>_String, Size -> Line]
			},
			{
				OptionName->ParticleSizes,
				Default -> Automatic,
				AllowNull->True,
				Widget -> Alternatives[
					Adder[
						Widget[
							Type->Quantity,
							Pattern :> RangeP[1 Micrometer, 600 Micrometer],
							Units -> Micrometer
						]
					],
					Widget[
						Type->Quantity,
						Pattern :> RangeP[1 Micrometer, 600 Micrometer],
						Units -> Micrometer
					]
				],
				Description -> "The collection of ranges (5 Micrometer to 100 Micromter) the different particle sizes that monitored.",
				Category-> "General"
			},
			{
				OptionName -> DilutionCurve,
				Default -> Automatic, 
				Description -> "The collection of dilutions that will be performed on the samples before light obscuration measurements are taken. For Fixed Dilution Volume Dilution Curves, the Sample Amount is the volume of the sample that will be mixed with the Diluent Volume of the Diluent to create the desired concentration. For Fixed Dilution Factor Dilution Curves, the Sample Volume is the volume of the sample that will created after being diluted by the Dilution Factor. For example, a 1M sample with a dilution factor of 0.7 will be diluted to a concentration 0.7M. IMPORTANT: Because the dilution curve does not intrinsically include the original sample, in the case of sample dilution the first diluting factor should be 1 or Diluent Volume should be 0 Microliter to include the original sample. If dilutions and injections are specified, injection samples will be injected into every dilution in the curve corresponding to SamplesIn.",
				ResolutionDescription->"This is automatically set Null if Diluent is set to Null or a SerialDilutionCurve is specified. Otherwise will default to a 0.5 factor dilution.",
				AllowNull -> True,
				Category -> "Sample Preparation",
				Widget->Alternatives[
					"Fixed Dilution Volume"->Adder[
						{
							"Sample Amount"->Widget[Type->Quantity,Pattern:>RangeP[0 Microliter,$MaxTransferVolume],Units->{1,{Microliter,{Liter,Milliliter,Microliter}}}],
							"Diluent Volume"->Widget[Type->Quantity,Pattern:>RangeP[0 Microliter,$MaxTransferVolume],Units->{1,{Microliter,{Liter,Milliliter,Microliter}}}]
						}
					],
					"Fixed Dilution Factor"->Adder[
						{
							"Sample Volume"->Widget[Type->Quantity,Pattern:>RangeP[0 Microliter,$MaxTransferVolume],Units->{1,{Microliter,{Liter,Milliliter,Microliter}}}],
							"Dilution Factors"->Widget[Type->Number,Pattern:>RangeP[0,1]]
						}
					]
				]
			},
			{
				OptionName -> SerialDilutionCurve, (*TODO add option for the mixer DilutionMixer*)
				Default -> Automatic,
				Description -> "The collection of serial dilutions that will be performed on the samples before light obscuration measurements are taken. For Serial Dilution Volumes, the Transfer Volume is taken out of the sample and added to a second well with the Diluent Volume of the Diluent. It is mixed, then the Transfer Volume is taken out of that well to be added to a third well. This is repeated to make Number Of Dilutions diluted samples. For example, if a 100 ug/ ml sample with a Transfer Volume of 20 Microliters, a Diluent Volume of 60 Microliters and a Number of Dilutions of 3 is used, it will create a DilutionCurve of 25 ug/ ml, 6.25 ug/ ml, and 1.5625 ug/ ml with each dilution having a volume of 60 Microliters. For Serial Dilution Factors, the sample will be diluted by the dilution factor at each transfer step. IMPORTANT: Because the dilution curve does not intrinsically include the original sample, in the case of sample dilution the first diluting factor should be 1 or Diluent Volume should be 0 Microliter to include the original sample. If dilutions and injections are specified, injection samples will be injected into every dilution in the curve corresponding to SamplesIn.",
				ResolutionDescription->"This is automatically set to Null if Diluent is set to Null or a non-serial Dilution Curve is specified. In all other cases it is automatically set to TransferVolume as one tenth of smallest of sample volume or container max volume, DiluentVolume as smallest of sample volume or container max volume, and Number of Dilutions as 3.", (*TODO to figure out logic*) (*SampleDilution -> SerialDilution, LinearDilution, None*) (*double check and add master switch*)
				AllowNull -> True,
				Category -> "Sample Preparation",
				Widget->Alternatives[
					"Serial Dilution Volumes"->
						{
							"Transfer Volume"->Widget[Type->Quantity,Pattern:>RangeP[0 Microliter,$MaxTransferVolume],Units->{1,{Microliter,{Liter,Milliliter,Microliter}}}],
							"Diluent Volume"->Widget[Type->Quantity,Pattern:>RangeP[0 Microliter,$MaxTransferVolume],Units->{1,{Microliter,{Liter,Milliliter,Microliter}}}],
							"Number Of Dilutions"->Widget[Type -> Number,Pattern :> RangeP[1,12,1]]
						},
					"Serial Dilution Factor"->
						{
							"Sample Volume"->Widget[Type->Quantity,Pattern:>RangeP[0 Microliter,$MaxTransferVolume
							],Units->{1,{Microliter,{Liter,Milliliter,Microliter}}}],
							"Dilution Factors" ->
								Alternatives[
									"Constant" -> {
										"Constant Dilution Factor" ->
											Widget[Type -> Number, Pattern :> RangeP[0, 1]],
										"Number Of Dilutions" ->
											Widget[Type -> Number, Pattern :> RangeP[1,12,1]]
									},
									"Variable" ->
										Adder[Widget[Type -> Number, Pattern :> RangeP[0, 1]]]]
						}
				]
			},
			{
				OptionName -> Diluent,
				Default -> Automatic,
				AllowNull -> True,
				Widget -> Widget[
					Type -> Object,
					Pattern :> ObjectP[{Model[Sample],Object[Sample]}],
					ObjectTypes->{Model[Sample],Object[Sample]}
				],
				Description -> "The solution that is used to dilute the sample to generate a DilutionCurve or SerialDilutionCurve.",
				ResolutionDescription->"Automatically set to the Solvent of the sample if DilutionCurve or SerialDilutionCurve are specified and if the Solvent field is not informed, Diluent is set to Model[Sample,\"Milli-Q water\"]. Otherwise set to Null.",
				Category -> "Sample Preparation"
			},
			{
				OptionName -> DilutionContainer,
				Default -> Automatic,
				AllowNull -> True,
				Widget->Adder[
					Alternatives[
						Widget[
							Type -> Object,
							Pattern :> ObjectP[{Model[Container]}],
							ObjectTypes -> {Model[Container]}
						],
						Widget[
							Type -> Enumeration,
							Pattern :> Alternatives[Null]
						]
					]
				],
				Description ->"The containers in which each sample is diluted with the Diluent to make the concentration series, with indices indicating specific grouping of samples if desired.",
				ResolutionDescription -> "Automatically set as Model[Container,Plate,\"96-well 2mL Deep Well Plate\"], grouping samples with the same container and DilutionStorageCondition.",
				Category -> "Sample Preparation"
			},
			{
				OptionName -> DilutionStorageCondition,
				Default ->Automatic,
				Description -> "The conditions under which any leftover samples from the DilutionCurve should be stored after the samples are transferred to the measurement plate.",
				ResolutionDescription->"Automatically set Disposal if the sample is diluted and Null otherwise.",
				AllowNull -> True,
				Category -> "Sample Preparation",
				Widget -> Widget[Type->Enumeration,Pattern:>SampleStorageTypeP|Disposal]
			},
			{
				OptionName -> DilutionMixVolume,
				Default ->Automatic,
				AllowNull -> True,
				Widget -> Widget[
					Type->Quantity,
					Pattern:>RangeP[0 Microliter, 900 Microliter],
					Units->{1,{Liter,{Liter,Milliliter,Microliter}}}
				],
				Description -> "The volume that is pipetted out and in of the dilution to mix the sample with the Diluent to make the DilutionCurve.",
				ResolutionDescription->"Automatically set to the smallest dilution volume or half the largest dilution volume, whichever one is smaller.",
				Category -> "Sample Preparation"
			},
			{
				OptionName -> DilutionNumberOfMixes,
				Default ->Automatic,
				AllowNull -> True,
				Widget -> Widget[
					Type -> Number,
					Pattern :> RangeP[0,20,1]
				],
				Description -> "The number of pipette out and in cycles that is used to mix the sample with the Diluent to make the DilutionCurve.",
				ResolutionDescription->"Automatically set 5 if the sample is diluted and Null otherwise.",
				Category -> "Sample Preparation"
			},
			{
				OptionName -> DilutionMixRate,
				Default ->Automatic,
				AllowNull -> True,
				Widget -> Widget[Type -> Quantity, Pattern :> RangeP[0.4 Microliter/Second,500 Microliter/Second], Units->Microliter/Second],
				Description -> "The speed at which the DilutionMixVolume is pipetted out and in of the dilution to mix the sample with the Diluent to make the DilutionCurve.",
				ResolutionDescription->"Automatically set to 100 Microliter/Second if the sample is diluted and Null otherwise.",
				Category -> "Sample Preparation"
			},
			(* --- Measurement --- *)
			{
				OptionName->ReadingVolume,
				Default->Automatic,
				Description->"The volume of sample that is loaded into the instrument and used to determine particle size and count. If the reading volume exceeds the volume of the syringe the instruments will perform multiple strokes to cover the full reading volume.",
				ResolutionDescription -> "Automatically set to 20 Microliters if Syringe size is 1 mL, or 50 Microliter otherwise.",
				AllowNull->False,
				Widget->Widget[
					Type->Quantity,
					Pattern :> RangeP[1 Microliter, $MaxTransferVolume],
					Units -> {1,{Microliter,{Microliter,Milliliter,Liter}}}
				],
				Category->"Particle Size Measurements"
			},
			{
				OptionName -> SampleTemperature,
				Default -> Ambient,
				AllowNull -> False,
				Widget ->Alternatives[
					Widget[
						Type -> Enumeration,
						Pattern :> Alternatives[Ambient]
					],
					Widget[
						Type -> Quantity,
						Pattern :> RangeP[0*Celsius, 80*Celsius],
						Units -> Alternatives[Celsius,Fahrenheit,Kelvin]
					]
				],
				Description -> "The temperature of the instrument's sampler tray where samples are equilibrated just prior to the injection.",
				Category -> "Particle Size Measurements"
			},
			{
				OptionName->EquilibrationTime,
				Default->5 Minute,
				Description->"The length of time for which each sample is incubated at the requested SampleTemperature just prior to being read.",
				AllowNull->True,
				Widget->Widget[
					Type->Quantity,
					Pattern:>RangeP[0 Second, $MaxExperimentTime],
					Units:>{1,{Minute,{Second,Minute,Hour}}}
				],
				Category->"Particle Size Measurements"
			},
			{
				OptionName->NumberOfReadings,
				Default->3,
				AllowNull->False,
				Widget->Widget[
					Type->Number,
					Pattern:>RangeP[1,10,1]
				],
				Description -> "The number of times the liquid particle count is read by passing ReadingVolume through the light obscuration sensor.",
				Category->"Particle Size Measurements"
			},
			{
				OptionName->PreRinseVolume,
				Default->Automatic,
				AllowNull->True,
				Widget->Widget[
					Type->Quantity,
					Pattern :> RangeP[0 Microliter, 10 Milliliter],
					Units ->  {1 Microliter,{Microliter, Milliliter}}
				],
				Description->"The volume of the sample flown into the syringe tubing to rinse out the lines with each new sample before beginning the reading.",
				ResolutionDescription-> "Automatically set to the max volume for the syringe.",
				Category->"Particle Size Measurements"
			},
			{
				OptionName->DiscardFirstRun,
				Default->True,
				AllowNull->False,
				Description->"Indicate during the data collection, the data collection starts from the 2nd reading, the first reading will be discarded. Setting this to true will increase the reproducibility of data collection.",
				Widget-> Widget[Type->Enumeration,Pattern:>BooleanP],
				Category->"Particle Size Measurements"
			},

			{
				OptionName->SamplingHeight,
				Default->Automatic,
				AllowNull->False,
				Description->"Indicate during the data collection, the distance between the tip of the probe and the bottom of the container.",
				ResolutionDescription -> "Automatically set based on the dimension of the container of the SamplesIn and StirBar (if AcquisitionMixType is Stir).",
				Widget-> Widget[
					Type->Quantity,
					Pattern :> RangeP[1 Millimeter, 95Millimeter],
					Units ->  {1 Millimeter,{Millimeter, Centimeter}}
				],
				Category->"Particle Size Measurements"
			},
			(* --- Stirring --- *)
			{
				OptionName->AcquisitionMix,
				Default->True,
				AllowNull->False,
				Description->"Indicates whether the samples should be mixed during data acquisition.",
				Widget-> Widget[Type->Enumeration,Pattern:>BooleanP],
				Category->"Particle Size Measurements"
			},
			{
				OptionName->AcquisitionMixType,
				Default->Automatic,
				AllowNull->True,
				Description->If[$CountLiquidParticlesAllowHandSwirl,
					"Indicates the method used to mix the sample. If this option is set to Stir, a StirBar will be transferred into the sample container and stir the sample during the entire data collection process. If this option is set to Swirl, the sample container will be swirled by hand. The sample container will stand still for WaitTime before the data collection starts, and the sample container will not be further mixed during the data collection.",
					"Indicates the method used to mix the sample. If this option is set to Stir, a StirBar will be transferred into the sample container and stir the sample during the entire data collection process."
				],
				ResolutionDescription->"Automatically set to Stir if AcquisitionMixType is True.",
				Widget-> Widget[Type->Enumeration,Pattern:>If[$CountLiquidParticlesAllowHandSwirl, Alternatives[Stir, Swirl],Alternatives[Stir]]],
				Category->"Particle Size Measurements"
			},
			{
				OptionName->NumberOfMixes,
				Default->Automatic,
				AllowNull->True,
				Description->"Indicate the number of times the sample container will be swirled if the AcquisitionMixType is swirl",
				ResolutionDescription->"Automatically sets to 10 if the AcquisitionMixType is Swirl.",
				Widget->Widget[Type->Number,Pattern:>RangeP[1,40,1]],
				Category->If[$CountLiquidParticlesAllowHandSwirl,"Particle Size Measurements","Hidden"]
			},
			{
				OptionName->WaitTimeBeforeReading,
				Default->Automatic,
				AllowNull->True,
				Description->"The length of time the container will be placed standstill before the reading its particle sizes",
				ResolutionDescription->"Automatically sets to 1 Minute if the AcquisitionMixType is Swirl.",
				Widget->Widget[Type->Quantity,Pattern:>RangeP[0 Minute,10 Minute],Units-> {1 Minute,{Minute,Second}}],
				Category->If[$CountLiquidParticlesAllowHandSwirl,"Particle Size Measurements","Hidden"]
			},
			{
				OptionName->StirBar, (*check with Corinne how to clean them*) (*error  messages one object for each, and one model is fine*)
				Default->Automatic,
				AllowNull->True,
				Description->"Indicates the stir bar used to agitate the sample during acquisition.",
				ResolutionDescription -> "Automatically set based on the volume and the container of the sample if the AcquisitionMixType is Stir.",
				Widget-> Widget[Type->Object,
					Pattern:>ObjectP[{Model[Part, StirBar], Object[Part, StirBar]}](*,
					OpenPaths -> {
						{
							Object[Catalog, "Root"],
							"Instruments","Mixing Devices", "Stir Bars"
						}
					}*)
				],
				Category->"Particle Size Measurements"
			},
			{
				OptionName->AcquisitionMixRate,
				Default->Automatic,
				AllowNull->True,
				Description->"Indicates the rate at which the samples should be mixed with a stir bar during data acquisition.",
				ResolutionDescription -> "Automatically set AcquisitionMixRate 400 RPM.",
				Widget-> Widget[Type->Quantity,Pattern:>RangeP[50 RPM,350 RPM],Units->RPM],
				ResolutionDescription -> "Automatically set 500 RPM if AcquisitionMixType is Stir.",
				Category->"Particle Size Measurements"
			},
			{
				OptionName->AdjustMixRate,
				Default->Automatic,
				AllowNull->True,
				Description->"When using a stir bar, if specified AcquisitionMixRate does not provide a stable or consistent circular rotation of the magnetic bar, indicates if mixing should continue up to MaxStirAttempts in attempts to stir the samples. If stir bar is wiggling, decrease AcquisitionMixRate by AcquisitionMixRateIncrement and check if the stir bar is still wiggling. If it is, decrease by AcquisitionMixRateIncrement again. If still wiggling, repeat decrease until MaxStirAttempts. If the stir bar is not moving/stationary, increase the AcquisitionMixRate by AcquisitionMixRateIncrement and check if the stir bar is still stationary. If it is, increase by AcquisitionMixRateIncrement again. If still stationary, repeat increase until MaxStirAttempts. Mixing will occur during data acquisition. After MaxStirAttempts, if stable stirring was not achieved, StirringError will be set to True in the protocol object.",
				ResolutionDescription -> "Automatically set to True if AcquisitionMixType is Stir.",
				Widget-> Widget[Type->Enumeration,Pattern:>BooleanP],
				Category->"Particle Size Measurements"
			},
			{
				OptionName->MinAcquisitionMixRate,
				Default->Automatic,
				AllowNull->True,
				Description->"Sets the lower limit stirring rate to be decreased to for sample mixing while attempting to mix the samples with a stir bar if AdjustMixRate is True.",
				ResolutionDescription->"Automatically sets to 20% RPM lower than AcquisitionMixRate if AdjustMixRate is True.",
				Widget->Widget[Type->Quantity,Pattern:>RangeP[50 RPM,350 RPM],Units->RPM],
				Category->"Particle Size Measurements"
			},
			{
				OptionName->MaxAcquisitionMixRate,
				Default->Automatic,
				AllowNull->True,
				Description->"Sets the upper limit stirring rate to be increased to for sample mixing while attempting to mix the samples with a stir bar if AdjustMixRate is True.",
				ResolutionDescription -> "Automatically sets to 20% RPM greater than AcquisitionMixRate if AdjustMixRate is True.",
				Widget-> Widget[Type->Quantity,Pattern:>RangeP[50 RPM,350 RPM],Units->RPM],
				Category->"Particle Size Measurements"
			},
			{
				OptionName->AcquisitionMixRateIncrement,
				Default->Automatic,
				AllowNull->True,
				Description->"Indicates the value to increase or decrease the mixing rate by in a stepwise fashion while attempting to mix the samples with a stir bar.",
				ResolutionDescription->"Automatically sets to 50 RPM if AdjustMixRate is True.",
				Widget->Widget[Type->Quantity,Pattern:>RangeP[10 RPM,350 RPM],Units->RPM],
				Category->"Particle Size Measurements"
			},
			{
				OptionName->MaxStirAttempts,
				Default->Automatic,
				AllowNull->True,
				Description->"Indicates the maximum number of attempts to mix the samples with a stir bar. One attempt designates each time AdjustMixRate changes the AcquisitionMixRate (i.e. each decrease/increase is equivalent to 1 attempt.",
				ResolutionDescription->"If AdjustMixRate is True, automatically sets to 10.",
				Widget->Widget[Type->Number,Pattern:>RangeP[1,40]],
				Category->"Particle Size Measurements"
			},
			
			(* --- Wash --- *)
			{
				OptionName->WashSolution,
				Default->Model[Sample, "Milli-Q water"],
				AllowNull->False,
				Widget-> Widget[
					Type->Object,
					Pattern:>ObjectP[{Model[Sample],Object[Sample]}
					](*,
					OpenPaths -> {
						{
							Object[Catalog, "Root"],
							"Experiment Objects","HIAC Liquid Particle Counting","Cleaning Solutions"
						}
					}*)
				],
				Description->"For each member of SamplesIn, the solution pumped through the instrument's flow path to clean it between the loading of each new sample.",
				Category->"Washing"
			},
			{
				OptionName -> WashSolutionTemperature,
				Default -> Ambient,
				AllowNull -> False,
				Widget -> Alternatives[
					Widget[
						Type -> Enumeration,
						Pattern :> Alternatives[Ambient]
					],
					Widget[Type -> Quantity, Pattern :> RangeP[4*Celsius, 40*Celsius], Units -> {Celsius, {Celsius, Fahrenheit, Kelvin}}]
				],
				Category -> "Washing",
				Description -> "For each member of SamplesIn, the temperature to which the WashSolution is preheated before flowing it through the flow path."
			},
			{
				OptionName->WashEquilibrationTime,
				Default->Automatic,
				Description->"For each member of SamplesIn, the length of time for which the wash solution container equilibrate at the requested WashSolutionTemperature in the sample rack before being pumped through the instrument's flow path.",
				ResolutionDescription->"Automatically set to 5 minutes if the WashSolutionTemperature is not Ambient.",
				AllowNull->False,
				Widget->Widget[
					Type->Quantity,
					Pattern:>RangeP[0 Second, $MaxExperimentTime],
					Units:>{1,{Minute,{Second,Minute,Hour}}}
				],
				Category->"Washing"
			},
			
			{
				OptionName -> WashWaitTime,
				Default ->  0 Minute,
				AllowNull -> False,
				Widget ->
					Widget[Type -> Quantity, Pattern :> RangeP[0 Minute,$MaxExperimentTime], Units -> {Second, {Second, Minute, Hour}}],
				Category -> "Washing",
				Description -> "For each member of SamplesIn, the amount of time for which the syringe is allowed to soak with each wash solution before flushing it to the waste."
			},
			{
				OptionName ->NumberOfWash,
				Default -> 1,
				AllowNull -> False,
				Widget ->Widget[
					Type->Number,
					Pattern:>RangeP[1,10,1]
				],
				Category -> "Washing",
				Description -> "For each member SamplesIn, the number of times each wash solution is pumped through the instrument's flow path."
			}
		],
		ExperimentOutputOption,
		SimulationOption,
		UploadOption,
		CacheOption
	}
];


(* ::Subsubsection::Closed:: *)
(* UploadCountLiquidParticlesMethod Error Messages *)

(* Most of the options are shared with ExperimentCountLiquidParticles and those error messages are used. *)
Error::DuplicateCountLiquidParticleMethodName = "The requested names,`1`, is already used for another `2`. Please rename the current object or specify a new unique names.";


(* ::Subsubsection::Closed:: *)
(* UploadCountLiquidParticlesMethod *)

(* Overload - only 1 analyte - change it to our main overload *)
UploadCountLiquidParticlesMethod[mySamples:ListableP[ObjectP[Object[Sample]]|Null],myOptions:OptionsPattern[UploadCountLiquidParticlesMethod]]:=Module[
	{
		listedInputs,listedOptions,outputSpecification,listedOutput,gatherTests,messages,safeOptions,safeOptionTests,simulation,
		upload,cache,names,validNameBools,nameInvalidOption,validNameTest,uniqueMethodPacketLookup,allTests,allTestTestResults,
		previewRule,testsRule,resultRule,resolvedExperimentOptions,resolvedExperimentTests,allMethodPackets,resolvedOptionResults,
		grouedOptionValues,resolvedOptions,mapThreadSafeOptions,optionsRule,expandedSafeOps,expandedResolvedOps
	},

	(* determine the requested return value; careful not to default this as it will throw error; it's Hidden, assume used correctly *)
	outputSpecification=Quiet[OptionDefault[OptionValue[Output]],OptionValue::nodef];
	listedOutput=ToList[outputSpecification];

	(* determine if we should keep a running list of tests. When we are not getting tests, we throw messages *)
	gatherTests=MemberQ[listedOutput,Tests];
	messages=!gatherTests;

	(* Make sure we're working with a list of inputs and options *)
	(* Remove temporal links and named objects. *)
	{listedInputs,listedOptions}=removeLinks[ToList[mySamples],ToList[myOptions]];
	
	(* default all unspecified or incorrectly-specified options *)
	(* call SafeOptions to make sure all options match pattern *)
	{safeOptions,safeOptionTests}=If[gatherTests,
		SafeOptions[UploadCountLiquidParticlesMethod,listedOptions,Output->{Result,Tests},AutoCorrect->False],
		{SafeOptions[UploadCountLiquidParticlesMethod,listedOptions,AutoCorrect->False], {}}
	];
	
	(* Expand safe options *)
	expandedSafeOps=Last[ExpandIndexMatchedInputs[UploadCountLiquidParticlesMethod,{ToList[listedInputs]},safeOptions]];
	
	(* If the specified options don't match their patterns, allowed to return an early hard failure; make sure to hit up tests if asked *)
	If[MatchQ[safeOptions,$Failed],
		Return[
			outputSpecification /. {
				Result->$Failed,
				Tests->safeOptionTests,
				Preview->Null,
				Options->$Failed
			}
		]
	];
	
	(* Look up the provided Cache option. If we are from the ExperimentCountLiquidParticles option, we get the cache and there is no need to download again. *)
	{
		cache,
		simulation,
		upload
	}=Lookup[
		safeOptions,
		{
			Cache,
			Simulation,
			Upload
		}
	];
	
	(* names *)
	names=Lookup[expandedSafeOps, Name];
	
	(* -- Check that the protocol names is unique -- *)
	validNameBools=If[MatchQ[#,_String],
		
		(* If the names was specified, make sure its not a duplicate names *)
		Not[DatabaseMemberQ[Object[Protocol, CountLiquidParticles, #]]],
		
		(* Otherwise, its all good *)
		True
	]&/@names;
	
	(* If validNameQ is False AND we are throwing messages, then throw the message and make nameInvalidOptions = {Name}; otherwise, {} is fine *)
	nameInvalidOption=If[!(Or@@validNameBools)&&messages,
		(
			Message[Error::DuplicateCountLiquidParticleMethodName,PickList[names,validNameBools,False],"CountLiquidParticles Method"];
			{Name}
		),
		{}
	];
	
	(* Generate Test for Name check *)
	validNameTest=If[gatherTests&&MatchQ[ names,_String],
		Test["If specified, Name is not already an CountLiquidParticles protocol object names:",
			(Or@@validNameBools),
			True
		],
		Nothing
	];
	
	(*Call the ExperimentCountLiquidParticle resolvers for resolving the automatic options*)
	resolvedOptionResults=If[
		gatherTests,
		Quiet[ExperimentCountLiquidParticles[
			(* input samples*)
			listedInputs,
			
			(* options *)
			{
				Syringe->Lookup[safeOptions,Syringe],
				SyringeSize->Lookup[safeOptions,SyringeSize],
				ParticleSizes->Lookup[safeOptions,ParticleSizes],
				DilutionCurve->Lookup[safeOptions,DilutionCurve],
				SerialDilutionCurve->Lookup[safeOptions,SerialDilutionCurve],
				Diluent->Lookup[safeOptions,Diluent],
				DilutionContainer->Lookup[safeOptions,DilutionContainer],
				DilutionStorageCondition->Lookup[safeOptions,DilutionStorageCondition],
				DilutionMixVolume->Lookup[safeOptions,DilutionMixVolume],
				DilutionNumberOfMixes->Lookup[safeOptions,DilutionNumberOfMixes],
				DilutionMixRate->Lookup[safeOptions,DilutionMixRate],
				ReadingVolume->Lookup[safeOptions,ReadingVolume],
				SampleTemperature->Lookup[safeOptions,SampleTemperature],
				EquilibrationTime->Lookup[safeOptions,EquilibrationTime],
				NumberOfReadings->Lookup[safeOptions,NumberOfReadings],
				PreRinseVolume->Lookup[safeOptions,PreRinseVolume],
				DiscardFirstRun->Lookup[safeOptions,DiscardFirstRun],
				AcquisitionMix->Lookup[safeOptions,AcquisitionMix],
				AcquisitionMixType->Lookup[safeOptions,AcquisitionMixType],
				If[$CountLiquidParticlesAllowHandSwirl,
					Sequence@@{NumberOfMixes->Lookup[safeOptions,NumberOfMixes],
						WaitTimeBeforeReading->Lookup[safeOptions,WaitTimeBeforeReading]},
					Nothing
				],
				StirBar->Lookup[safeOptions,StirBar],
				AcquisitionMixRate->Lookup[safeOptions,AcquisitionMixRate],
				AdjustMixRate->Lookup[safeOptions,AdjustMixRate],
				MinAcquisitionMixRate->Lookup[safeOptions,MinAcquisitionMixRate],
				MaxAcquisitionMixRate->Lookup[safeOptions,MaxAcquisitionMixRate],
				AcquisitionMixRateIncrement->Lookup[safeOptions,AcquisitionMixRateIncrement],
				MaxStirAttempts->Lookup[safeOptions,MaxStirAttempts],
				WashSolution->Lookup[safeOptions,WashSolution],
				WashSolutionTemperature->Lookup[safeOptions,WashSolutionTemperature],
				WashEquilibrationTime->Lookup[safeOptions,WashEquilibrationTime],
				WashWaitTime->Lookup[safeOptions,WashWaitTime],
				NumberOfWashes->Lookup[safeOptions,NumberOfWash],
				SamplingHeight->Lookup[safeOptions,SamplingHeight],
				Cache->Lookup[safeOptions,Cache],
				Simulation->Lookup[safeOptions,Simulation],
				Output->{Options,Tests}
			}
		],{Warning::CountLiquidParticleDilutions}],
		{
			Quiet[ExperimentCountLiquidParticles[
				(* input samples*)
				listedInputs,
				
				(* options *)
				Sequence@@{
					Syringe->Lookup[safeOptions,Syringe],
					SyringeSize->Lookup[safeOptions,SyringeSize],
					ParticleSizes->Lookup[safeOptions,ParticleSizes],
					DilutionCurve->Lookup[safeOptions,DilutionCurve],
					SerialDilutionCurve->Lookup[safeOptions,SerialDilutionCurve],
					Diluent->Lookup[safeOptions,Diluent],
					DilutionContainer->Lookup[safeOptions,DilutionContainer],
					DilutionStorageCondition->Lookup[safeOptions,DilutionStorageCondition],
					DilutionMixVolume->Lookup[safeOptions,DilutionMixVolume],
					DilutionNumberOfMixes->Lookup[safeOptions,DilutionNumberOfMixes],
					DilutionMixRate->Lookup[safeOptions,DilutionMixRate],
					ReadingVolume->Lookup[safeOptions,ReadingVolume],
					SampleTemperature->Lookup[safeOptions,SampleTemperature],
					EquilibrationTime->Lookup[safeOptions,EquilibrationTime],
					NumberOfReadings->Lookup[safeOptions,NumberOfReadings],
					PreRinseVolume->Lookup[safeOptions,PreRinseVolume],
					DiscardFirstRun->Lookup[safeOptions,DiscardFirstRun],
					AcquisitionMix->Lookup[safeOptions,AcquisitionMix],
					AcquisitionMixType->Lookup[safeOptions,AcquisitionMixType],
					If[$CountLiquidParticlesAllowHandSwirl,
						Sequence@@{NumberOfMixes->Lookup[safeOptions,NumberOfMixes],
						WaitTimeBeforeReading->Lookup[safeOptions,WaitTimeBeforeReading]},
						Nothing
					],
					StirBar->Lookup[safeOptions,StirBar],
					AcquisitionMixRate->Lookup[safeOptions,AcquisitionMixRate],
					AdjustMixRate->Lookup[safeOptions,AdjustMixRate],
					MinAcquisitionMixRate->Lookup[safeOptions,MinAcquisitionMixRate],
					MaxAcquisitionMixRate->Lookup[safeOptions,MaxAcquisitionMixRate],
					AcquisitionMixRateIncrement->Lookup[safeOptions,AcquisitionMixRateIncrement],
					MaxStirAttempts->Lookup[safeOptions,MaxStirAttempts],
					WashSolution->Lookup[safeOptions,WashSolution],
					WashSolutionTemperature->Lookup[safeOptions,WashSolutionTemperature],
					WashEquilibrationTime->Lookup[safeOptions,WashEquilibrationTime],
					WashWaitTime->Lookup[safeOptions,WashWaitTime],
					NumberOfWashes->Lookup[safeOptions,NumberOfWash],
					SamplingHeight->Lookup[safeOptions,SamplingHeight],
					Cache->Lookup[safeOptions,Cache],
					Simulation->Lookup[safeOptions,Simulation],
					Output->Options
				}
			],{Warning::CountLiquidParticleDilutions}],
			{}
		}
	];
	
	(*Separate the option and the tests*)
	{resolvedExperimentOptions, resolvedExperimentTests}=resolvedOptionResults;
	
	(* We will only generate unique method packet,so we grouped by method and   *)
	resolvedOptions=ReplaceRule[
		listedOptions,
		{
			SyringeSize->Lookup[resolvedExperimentOptions,SyringeSize],
			Sensor->Lookup[resolvedExperimentOptions,Sensor],
			Syringe->Lookup[resolvedExperimentOptions,Syringe],
			ParticleSizes->Lookup[resolvedExperimentOptions,ParticleSizes],
			ReadingVolume->Lookup[resolvedExperimentOptions,ReadingVolume],
			NumberOfReadings->Lookup[resolvedExperimentOptions,NumberOfReadings],
			PreRinseVolume->Lookup[resolvedExperimentOptions,PreRinseVolume],
			SampleTemperature->Lookup[resolvedExperimentOptions,SampleTemperature],
			EquilibrationTime->Lookup[resolvedExperimentOptions,EquilibrationTime],
			DiscardFirstRun->Lookup[resolvedExperimentOptions,DiscardFirstRun],
			Diluent->Lookup[resolvedExperimentOptions,Diluent],
			DilutionContainer->Lookup[resolvedExperimentOptions,DilutionContainer],
			DilutionMixVolume->Lookup[resolvedExperimentOptions,DilutionMixVolume],
			DilutionNumberOfMixes->Lookup[resolvedExperimentOptions,DilutionNumberOfMixes],
			DilutionMixRate->Lookup[resolvedExperimentOptions,DilutionMixRate],
			DilutionStorageCondition->Lookup[resolvedExperimentOptions,DilutionStorageCondition],
			AcquisitionMix->Lookup[resolvedExperimentOptions,AcquisitionMix],
			AcquisitionMixType->Lookup[resolvedExperimentOptions,AcquisitionMixType],
			If[$CountLiquidParticlesAllowHandSwirl,
				Sequence@@{NumberOfMixes -> Lookup[resolvedExperimentOptions, NumberOfMixes],
				WaitTimeBeforeReading -> Lookup[resolvedExperimentOptions, WaitTimeBeforeReading]},
				Nothing
			],
			StirBar->Lookup[resolvedExperimentOptions,StirBar],
			DilutionCurve->Lookup[resolvedExperimentOptions,DilutionCurve],
			SerialDilutionCurve->Lookup[resolvedExperimentOptions,SerialDilutionCurve],
			AcquisitionMixRate->Lookup[resolvedExperimentOptions,AcquisitionMixRate],
			AdjustMixRate->Lookup[resolvedExperimentOptions,AdjustMixRate],
			MinAcquisitionMixRate->Lookup[resolvedExperimentOptions,MinAcquisitionMixRate],
			MaxAcquisitionMixRate->Lookup[resolvedExperimentOptions,MaxAcquisitionMixRate],
			AcquisitionMixRateIncrement->Lookup[resolvedExperimentOptions,AcquisitionMixRateIncrement],
			MaxStirAttempts->Lookup[resolvedExperimentOptions,MaxStirAttempts],
			WashSolution->Lookup[resolvedExperimentOptions,WashSolution],
			WashSolutionTemperature->Lookup[resolvedExperimentOptions,WashSolutionTemperature],
			WashEquilibrationTime->Lookup[resolvedExperimentOptions,WashEquilibrationTime],
			WashWaitTime->Lookup[resolvedExperimentOptions,WashWaitTime],
			NumberOfWash->Lookup[resolvedExperimentOptions,NumberOfWashes],
			SamplingHeight->Lookup[resolvedExperimentOptions,SamplingHeight]
		}
	
	];
	
	(* Generate the mapthread safe options *)
	
	expandedResolvedOps=Last[ExpandIndexMatchedInputs[UploadCountLiquidParticlesMethod,{ToList[listedInputs]},resolvedOptions]];
	mapThreadSafeOptions=OptionsHandling`Private`mapThreadOptions[UploadCountLiquidParticlesMethod,expandedResolvedOps];
	
	
	(* Grouped the unique option values sets *)
	grouedOptionValues=GroupBy[Transpose[{Replace[mapThreadSafeOptions,{Name->name}],listedInputs}],First->Last];
	
	
	(* Prepare the product upload packet *)
	uniqueMethodPacketLookup=Flatten@KeyValueMap[
		Function[{valueRules,sampleObjs},
			Module[{eachPacket,eachLookup},

				(* make the packet *)
				eachPacket=<|
					Type->Object[Method, LiquidParticleCounting],
					Object->CreateID[Object[Method, LiquidParticleCounting]],
					SyringeSize->Lookup[valueRules,SyringeSize],
					Sensor->Link[Lookup[valueRules,Sensor]],
					Syringe->Link[Lookup[valueRules,Syringe]],
					Replace[ParticleSizes]->Lookup[valueRules,ParticleSizes],
					ReadingVolume->Lookup[valueRules,ReadingVolume],
					NumberOfReadings->Lookup[valueRules,NumberOfReadings],
					PreRinseVolume->Lookup[valueRules,PreRinseVolume],
					SampleTemperature->Lookup[valueRules,SampleTemperature]/.{Ambient->$AmbientTemperature},
					EquilibrationTime->Lookup[valueRules,EquilibrationTime],
					DiscardFirstRun->Lookup[valueRules,DiscardFirstRun],
					Replace[DilutionCurve]->Lookup[valueRules,DilutionCurve],
					Replace[SerialDilutionCurve]->Lookup[valueRules,SerialDilutionCurve],
					Replace[DilutionContainer]->(Link/@ToList[Lookup[valueRules,DilutionContainer]]),
					Diluent->Link[Lookup[valueRules,Diluent]],
					DilutionMixVolume->Lookup[valueRules,DilutionMixVolume],
					DilutionNumberOfMixes->Lookup[valueRules,DilutionNumberOfMixes],
					DilutionMixRate->Lookup[valueRules,DilutionMixRate],
					DilutionStorageCondition->Lookup[valueRules,DilutionStorageCondition],
					AcquisitionMix->Lookup[valueRules,AcquisitionMix],
					AcquisitionMixType->Lookup[valueRules,AcquisitionMixType],
					If[$CountLiquidParticlesAllowHandSwirl,
						Sequence@@{NumberOfMixes->Lookup[valueRules,NumberOfMixes],
							WaitTimeBeforeReading->Lookup[valueRules,WaitTimeBeforeReading]},
						Nothing
					],
					StirBar->Link[Lookup[valueRules,StirBar]],
					AcquisitionMixRate->Lookup[valueRules,AcquisitionMixRate],
					AdjustMixRate->Lookup[valueRules,AdjustMixRate],
					MinAcquisitionMixRate->Lookup[valueRules,MinAcquisitionMixRate],
					MaxAcquisitionMixRate->Lookup[valueRules,MaxAcquisitionMixRate],
					AcquisitionMixRateIncrement->Lookup[valueRules,AcquisitionMixRateIncrement],
					MaxStirAttempt->Lookup[valueRules,MaxStirAttempts],
					WashSolution->Link[Lookup[valueRules,WashSolution]],
					WashSolutionTemperature->Lookup[valueRules,WashSolutionTemperature]/.{Ambient->$AmbientTemperature},
					WashEquilibrationTime->Lookup[valueRules,WashEquilibrationTime],
					WashWaitTime->Lookup[valueRules,WashWaitTime],
					NumberOfWash->Lookup[valueRules,NumberOfWash],
					SamplingHeight->Lookup[valueRules,SamplingHeight],
					Name->Lookup[valueRules,Name,Null],
					DateCreated->Now
				|>;
				
				(* Build the lookup rules*)
				eachLookup=(#->eachPacket)&/@sampleObjs;
				
				eachLookup
			]
		],
		grouedOptionValues
	];
	
	(* Replace the objects with duplicated method packet *)
	allMethodPackets=Flatten[(listedInputs/.uniqueMethodPacketLookup)];

	(*Collect all tests*)
	allTests=Flatten[{validNameTest, safeOptionTests, resolvedExperimentTests}];

	(* run the tests that we have generated to make sure we can go on *)
	allTestTestResults=If[gatherTests,
		RunUnitTest[<|"Tests" ->allTests|>,OutputFormat->SingleBoolean,Verbose->False],
		MatchQ[resolvedExperimentOptions,Except[$Failed]]
	];

	
	optionsRule=(Options->resolvedOptions);

	(* function doesn't have a preview *)
	previewRule=(Preview->Null);

	(* accrue all of the Tests we generated *)
	testsRule=Tests->If[gatherTests,
		allTests,
		Null
	];

	(* prepare the Result rule if asked; do not bother if we hit a failure on any of our above checks *)
	resultRule=Result->If[MemberQ[listedOutput,Result],
		Which[
			(* If any tests failed returen $Failed *)
			Not[TrueQ[allTestTestResults]], $Failed,
			upload && ValidUploadQ[DeleteDuplicates[allMethodPackets]],Upload[DeleteDuplicates[allMethodPackets]];Lookup[allMethodPackets,Object],
			True, allMethodPackets
		],
		Null
	];

	(* return the requested outputs per the non-listed Output option *)
	outputSpecification /. {optionsRule, previewRule, testsRule, resultRule}

];



(* ::Subsubsection::Closed:: *)
(*UploadCountLiquidParticlesOptions*)


DefineOptions[UploadCountLiquidParticlesOptions,
	Options:>{
		{
			OptionName->OutputFormat,
			Default->Table,
			AllowNull->False,
			Widget->Widget[Type->Enumeration,Pattern:>(Table|List)],
			Description->"Determines whether the function returns a table or a list of the options.",
			Category->"Protocol"
		}
	},
	SharedOptions:>{UploadCountLiquidParticlesMethod}
];


UploadCountLiquidParticlesMethodOptions[mySamples:ListableP[ObjectP[Object[Sample]]|Null],myOptions:OptionsPattern[UploadCountLiquidParticlesOptions]]:=Module[
	{listedOptions,preparedOptions,resolvedOptions},

	(* get the options as a list *)
	listedOptions=ToList[myOptions];

	(*Send in the correct Output option and remove the OutputFormat option*)
	preparedOptions=Normal@KeyDrop[Append[listedOptions,Output->Options],{OutputFormat}];

	resolvedOptions=UploadCountLiquidParticlesMethod[mySamples,preparedOptions];

	(* If options fail, return failure *)
	If[MatchQ[resolvedOptions,$Failed],
		Return[$Failed]
	];

	(*Return the option as a list or table*)
	If[MatchQ[Lookup[listedOptions,OutputFormat,Table],Table],
		LegacySLL`Private`optionsToTable[resolvedOptions,UploadCountLiquidParticlesMethod],
		resolvedOptions
	]
];



(* ::Subsection::Closed:: *)
(*ValidUploadCountLiquidParticlesQ*)


DefineOptions[ValidUploadCountLiquidParticlesQ,
	Options:>{VerboseOption,OutputFormatOption},
	SharedOptions:>{UploadCountLiquidParticlesMethod}
];

ValidUploadCountLiquidParticlesMethodQ[mySamples:ListableP[ObjectP[Object[Sample]]|Null],myOptions:OptionsPattern[ValidUploadCountLiquidParticlesQ]]:=Module[
	{listedOptions,preparedOptions,uploadCartridgeTests,initialTestDescription,allTests,verbose,outputFormat},

	(* Get the options as a list *)
	listedOptions=ToList[myOptions];

	(* Remove the output option before passing to the core function because it doesn't make sense here *)
	preparedOptions=DeleteCases[listedOptions,(Output|Verbose|OutputFormat)->_];

	(* Return only the tests for UploadCountLiquidParticlesMethod *)
	uploadCartridgeTests=UploadCountLiquidParticlesMethod[mySamples,Append[preparedOptions,Output->Tests]];

	(* Define the general test description *)
	initialTestDescription="All provided options and inputs match their provided patterns (no further testing can proceed if this test fails).";

	(*Make a list of all of the tests, including the blanket test *)
	allTests=If[MatchQ[uploadCartridgeTests,$Failed],
		{Test[initialTestDescription,False,True]},
		Module[
			{initialTest,validObjectBooleans,voqWarnings,testResults},

			(* Generate the initial test, which we know will pass if we got this far (hopefully) *)
			initialTest=Test[initialTestDescription,True,True];

			(* Create warnings for invalid objects *)
			validObjectBooleans=ValidObjectQ[DeleteCases[ToList[mySamples],_String],OutputFormat->Boolean];

			voqWarnings=MapThread[
				Warning[StringJoin[ToString[#1,InputForm]," is valid (run ValidObjectQ for more detailed information):"],
					#2,
					True
				]&,
				{DeleteCases[ToList[mySamples],_String],validObjectBooleans}
			];

			(* Get all the tests/warnings *)
			Flatten[{initialTest,uploadCartridgeTests,voqWarnings}]
		]
	];

	(* Determine the Verbose and OutputFormat options; quiet the OptionValue::nodef message in case someone just passed nonsense *)
	{verbose,outputFormat}=Quiet[OptionDefault[OptionValue[{Verbose,OutputFormat}]],OptionValue::nodef];

	(* Run all the tests as requested *)
	Lookup[RunUnitTest[<|"ValidUploadCountLiquidParticlesQ"->allTests|>,OutputFormat->outputFormat,Verbose->verbose],"ValidUploadCountLiquidParticlesQ"]

];



(* ::Subsection:: *)
(*ExperimentCountLiquidParticlesPreview*)

DefineOptions[UploadCountLiquidParticlesPreview,
	SharedOptions:>{UploadCountLiquidParticlesMethod}
];

UploadCountLiquidParticlesMethodPreview[mySamples:ListableP[ObjectP[Object[Sample]]|Null],myOptions:OptionsPattern[UploadCountLiquidParticlesPreview]]:=Module[
	{listedOptions},

	listedOptions=ToList[myOptions];

	UploadCountLiquidParticlesMethod[mySamples,ReplaceRule[listedOptions,Output->Preview]]
];
