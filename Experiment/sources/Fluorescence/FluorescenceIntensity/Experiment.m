(* ::Package:: *)

(* ::Text:: *)
(*\[Copyright] 2011-2023 Emerald Cloud Lab, Inc.*)


(* ::Section:: *)
(*Source Code*)


DefineOptions[ExperimentFluorescenceIntensity,
	Options:>{
		IntensityAndKineticsOptions
	}
];

Error::ReplicateAliquotsRequired="Replicate readings are generated by creating multiple aliquots of each sample. Therefore in order to specify NumberOfReplicates, Aliquot must be set to True. Please consider allowing one of these options to resolve automatically:";
Error::RepeatedPlateReaderSamples="Samples can only be repeated in the input if they are set to be aliquoted since repeat readings are performed by reading aliquots of a sample:";
Warning::PlateReaderStowaways="There are additional samples in the plate being experimented upon. As a result they will also be subjected to the heating and/or mixing done in the plate reader chamber. If you don't wish these samples to be acted on, please set Aliquot->True.";
Error::TooManyPlateReaderSamples="There are not enough available wells in the aliquot container to hold all the requested samples. Please consider splitting this experiment into multiple protocols.";

Error::ModeUnavailable="The provided Instrument option, `1`, cannot support `2` mode experiments. Check the PlateReaderMode field of a plate reader model for a listing of its supported experimental modes.";

Error::IntegrationTimesUnneeded="DelayTime and ReadTime only apply when Mode->TimeResolvedFluorescence. Please update Mode or leave DelayTime and ReadTime unspecified.";
Error::IntegrationTimesRequired="When Mode->TimeResolvedFluorescence DelayTime and ReadTime cannot be set to Null. Please set Mode->Fluorescence if you don't wish to use these times.";
Error::IntegrationTimesRequiredTogether="DelayTime and ReadTime must be specified as a pair. Please set both values to Null or specify times for both values.";
Error::IntegrationTimesUnsupported="DelayTime and ReadTime can only be specified if requested plate reader supports TimeResolvedFluorescence. Please specify a different plate reader or leave these times unspecified.";

Error::UnsupportedWavelengthSelection="The requested plate reader is not capable of selecting wavelengths via `1` as requested. Please choose a different plate reader or allow this option to resolve automatically.";
Error::InvalidWavelengthSelection="When using time-resolved fluorescence wavelength selection can only be done with filters. Please use Mode->Fluorescence or allow WavelengthSelection to resolve automatically.";

Error::EmissionWavelengthUnavailable="The emission wavelengths `1` are not supported by `2`. Please Inspect the provided plate reader model to view the supported emission wavelengths.";
Error::ExcitationWavelengthUnavailable="The excitation wavelengths `1` are not supported by `2`. Please Inspect the provided plate reader model to view the supported excitation wavelengths.";
Error::DualEmissionUnavailable="The requested plate reader does not support dual emission. Please consider allowing Instrument to resolve automatically.";
Error::DualEmissionWavelengthUnavailable="The dual emission wavelength is not supported by `1`. Please Inspect the provided plate reader model to view the supported dual emission wavelengths.";
Error::DualEmissionGainRequired="The dual emission gain cannot be set to Null if a dual emission wavelength is specified. Please supply a gain or remove the wavelength specification";
Error::DualEmissionGainUnneeded="Since the dual emission wavelength was set to Null the provided dual gain option will not be used. Please supply a wavelength or remove the gain specification.";

Error::WavelengthCombinationUnavailable="The requested plate reader, `1`, uses optic modules and as a result the provided wavelength options cannot all be satisfied simultaneously. Please consider allowing some of these wavelengths to be automatically resolved or Inspect the plate reader to view the possible combinations.";
Warning::WavelengthsSwapped="Some of the emission wavelengths are smaller than their corresponding excitation wavelengths. You may wish to double check these specifications.";
Error::MaxWavelengthsExceeded="The plate reader can read at most `1` distinct wavelengths in one run, but `2` have been specified. Please specify fewer wavelengths or consider splitting the wavelengths across two experiment calls.";

Error::WavelengthSelectionRequired="When indicating that the sample's luminescence should be read at specific wavelengths WavelengthSelection must be set to Filters or Monochromators to indicate how these wavelengths should be achieved.";
Error::WavelengthSelectionUnused="If EmissionWavelength->NoFilter, WavelengthSelection must also be set to NoFilter.";

Error::SamplingCombinationUnavailable="SamplingDistance applies to Spiral, Ring and Matrix sampling. SamplingDimension only applies for Matrix sampling. Please verify these options match these requirements or allow some to resolve automatically.";
Error::UnsupportedInstrumentSamplingPattern="The requested instrument cannot perform the type of sampling requested during `1` protocols. Please check the SamplingPatterns of the plate reader models to see the supported sampling types.";
Error::UnsupportedSamplingPattern="There are no instruments which can perform the type of sampling requested (`2`) during `1` protocols. Please check the SamplingPatterns of the plate reader models to see the supported sampling types.";

Error::IncompatibleGains="Gain has been set to `1`, but DualEmissionGain is set to `2`. Gain and DualEmissionGain must either both be raw voltages or both be percentages. Please update one of these values.";
Error::MultipleFocalHeightsRequested="At most one Auto or soecific distance is allowed in FocalHeight option, but it is currently set to `1`. Please modify the excess Auto and/or distance settings.";
Error::FocalHeightUnavailable="The resolved plate reader model to be used, `1`, does not allow direct focal height adjustments. Please specify a different plate reader or leave the focal height unspecified.";
Error::FocalHeightRequired="A focal height must be specified when using `1`. If you don't know the optimal focal height, consider specifying an AdjustmentSample and setting FocalHeight->Auto to allow the instrument to determine the height at which the signal is highest.";
Error::FocalHeightAdjustmentSampleRequired="The focal height can only be automatically adjusted based on the reading for a specific sample. Please provide an AdjustmentSample for each FocalHeight set to Auto, or set FocalHeight to a specific value.";
Error::InvalidAdjustmentSample="The provided AdjustmentSample, `1`, must be a member of the input samples. Please leave AdjustmentSample unspecified or allow the gain/focal height to be set automatically.";
Warning::AmbiguousAdjustmentSample="The provided AdjustmentSample appears multiple times in the input and should be disambiguated to ensure the correct aliquot of the sample is used. By default the first appearance of this sample will be used. Please specify this option in the form {appearance number, sample} if you wish to use another instance.";
Error::AdjustmentSampleIndex="The sample to be used for adjusting appears `1` time(s) however aliquot `2` of the sample was requested for the gain/focal height adjustments. Please check the AdjustmentSample index or specify only a sample to use the first instance.";
Error::AdjustmentSampleUnneeded="The AdjustmentSample is used to determine gain and/or focal height and should not be specified if you wish to directly set gain/focal height. Please leave AdjustmentSample unspecified or allow the gain/focal height to be set automatically.";
Error::AdjustmentSampleRequired="AdjustmentSample cannot be set to Null when gain and/or focal height are being determined automatically. If you don't wish to use an adjustment sample please set gain/focal height to direct values.";
Error::GainAdjustmentSampleRequired="When using Model[Instrument,PlateReader,\"id:mnk9jO3qDzpY\"] the gain can only be automatically adjusted based on the intensity of a specific sample; the FullPlate option is not possible with this plate reader. Please provide a sample, allow AdjustmentSample to resolve automatically or set Gain to a specific value.";
Error::FullPlateUnsupported="None of our current instrumentation supports FullPlate adjustments for `1` readings. Instead we recommend specifying the sample which has the highest expected reading:";

(* Don't mention all specific options since ExperimentFluorescenceKinetics has PlateReaderMixSchedule but ExperimentFluorescenceKinetics does not *)
Error::MixingParametersRequired="When PlateReaderMix->True, plate reader mixing parameters such as PlateReaderMixTime cannot be set to Null. Please set PlateReaderMix->False or allow these options to resolve automatically.";
Error::MixingParametersUnneeded="When PlateReaderMix->False, plate reader mixing parameters such as PlateReaderMixTime cannot be specified. Please set PlateReaderMix->True or allow these options to resolve automatically.";
Error::MixingParametersConflict="When not left Automatic, plate reader mixing parameters must all be set to values or all be set to Null. Please consider allowing some of these options to resolve automatically.";

Error::MissingInjectionInformation="Please ensure you've specified `1` and `2` for the following samples receiving injections: `3`. If you don't wish to inject into these samples, make sure `1` and `2` are both set to Null.";
Error::SingleInjectionSampleRequired="The current plate reader hardware only supports a single injection sample per injection group. Please make sure you've specified only one sample for `1`.";
Error::WellVolumeExceeded="When combined with the existing sample volume, the specified injections are expected to exceed the total well volume. Please check your sample volume and injection volumes for `1`.";
Warning::HighWellVolume="After injections have completed the following samples will have volumes over 250 microliter: `1`. As the well volume approaches the maximum, sample can splash onto the optics. Consider using the lowest injection flow rate and/or lowering the involved volumes.";
Error::TooManyInjectionSamples="The current plate reader hardware only supports up-to two unique injection samples. Please check your specifications for PrimaryInjectionSamples, SecondaryInjectionSamples, TertiaryInjectionSamples and QuaternaryInjectionSample.";
Error::InjectionSampleStateError = "The injection samples (`1`) do not have a state of liquid. The instrument can only inject liquid samples. Please make sure the injection samples have a state of liquid.";
Error::InjectionFlowRateUnneeded="`2` should only be specified if `1` injections are being performed. Please specify the corresponding injection volumes and samples if you wish to inject samples.";
Error::InjectionFlowRateRequired="When `1` injections are occurring `2` cannot be set to Null. Please allow these options to resolve automatically or don't specify any injections.";
Error::InvalidClarioStarFlowRate="When using an instrument of model `1`, the injection flow rate must be greater than or equal to `2`. Please increase the specified flow rate or let it resolve automatically.";
Error::UnneededInjectionStorageCondition="InjectionSampleStorageCondition should only be specified in injections are being performed. If you wish to perform injections please specify the samples and volumes which should be injected.";
Error::InsufficientPrimeVolume="Any samples being injected must have at least the volume needed to prime the injection lines, `1`. Please check the volume of your injection samples.";

Error::MoatAliquotsRequired="In order to create a moat, sample must be aliquoted into a new plate and so Aliquot cannot be set to False. Please consider allowing Aliquot to resolve automatically or turn off all moat options:";
Error::MoatParametersConflict="When not left Automatic, moat parameters must all be set to values or all be set to Null. Please consider allowing some of these options to resolve automatically.";
Error::TooManyMoatWells="The number of wells required to create the requested moat while still allowing room for the assay samples exceeds the number of plate wells. Please decrease the moat size, specify an assay plate with larger number of wells in AliquotContainer option or consider creating multiple protocols.";
Error::WellOverlap="Some of the wells requested as destinations for assay samples are also needed to create the requested moat (`1`). Please decrease the moat size or modify DestinationWell.";
Error::MoatVolumeOverflow="The MoatVolume must be less than the MaxVolume of the aliquot container. Please specify a lower volume or consider allowing this option to resolve automatically.";

Warning::CoveredTopRead="When RetainCover->True bottom reads are recommended to prevent the plate cover from interfering with the readings. Please consider using ReadLocation->Bottom.";
Error::CoveredInjections="No injections are possible when RetainCover->True as it's not possible to inject samples through the cover. Please turn injections off or set RetainCover to False.";

Error::NoPlateReader="There is no plate reader which can provide the requested options. Please Inspect the plate readers to determine their capabilities. Only the CLARIOStar can use monochromators and perform TimeResolved fluorescence measurements. Only the PHERAstar can perform DualEmission experiments. The Omega cannot do FullPlate adjustments or set the FocalHeight.";
Error::SinglePlateRequired="All samples must be in a single supported container or are set to be aliquoted into such a container. Please make sure that the given samples are in a supported plate model (consult the experiment help file) and are contained within a single plate. If you are performing this plate reader experiment Manually, allow the Aliquot options to resolve Automatically.";
Error::BottomReadingAliquotContainerRequired="In order to set ReadLocation to Bottom, samples must be aliquoted into a new plate with WellColor of Clear. Please allow Aliquot and AliquotContainer to resolve automatically or select a different AliquotContainer.";
Error::PlateReaderDuplicateDestinationWell="The specified DestinationWell cannot have duplicated members or constant member `1`. Please specify different DestinationWell for each input sample or allow this option to resolve automatically.";
Error::InvalidDestinationWellLength="The specified DestinationWell must be the same length as the number of all aliquots `1` (the number of input samples multipled by the specified NumberOfReplicates). Please change DestinationWell option to the correct length or allow this option to resolve automatically.";

(* Aliquot Warnings *)
Warning::ReplicateAliquotsRequired="Note that in order to generate replicate readings samples will be aliquoted into a new plate.";
Warning::RepeatedPlateReaderSamples="Note that in order to generate readings of samples repeated multiple times in the input, samples will be aliquoted into a new plate.";
Warning::SinglePlateRequired="Note that all samples will be aliquoted into a single plate supported by the plate reader.";
Warning::MoatAliquotsRequired="Note that in order to create a moat samples will be aliquoted into a new plate.";
Warning::BottomReadingAliquotsRecommended="For the best results, it is recommended to aliquot the samples into a new plate with WellColor of Clear when ReadLocation is set to Bottom.";

(* Experiment Fluorescence Kinetics Specific errors *)
Error::NoSerialCycleMixing="When ReadOrder->Serial, mixing can only occur before any readings begin or after injections. Please allow this option to resolve automatically or set ReadOrder->Parallel.";
Error::NoPostInjectionMixing="PlateReaderMixSchedule can only be set to AfterInjections if injections are specified. Please allow this option to resolve automatically or specify injection samples, volumes and times.";
Error::InjectionTimeOverlap="The difference between injection times must be greater than the mixing time since the next injection can only occur after mixing completes. Please consider decreasing PlateReaderMixTime, increasing the time between injections, or setting injections to occur at the same time.";
Error::InjectionTimeOrder="Secondary injections must occur after primary injections and tertiary injections should occur after secondary injections. Please check your times to make sure injections are appropriately ordered.";
Error::InvalidSimultaneousInjections="If two injection times are the same, the injection samples should be different and the instrument should be PHERAstar or FLUOstar. Please check your injection times, samples and instrument to make sure the requirement is fulfilled.";
Error::InjectionTimeInvalid="Please ensure you've specified some value less than RunTime for `1` to indicate when the specified injections should occur. If you don't want this set of injections to occur, make sure `1` and `2` are both set to Null.";
Error::InjectionTimeUnneeded="There are no injections for this group so `1` should not be specified. If you do want this set of injections to occur, make sure `1` and `2` are both specified.";

Error::NoPostInjectionMixing="PlateReaderMixSchedule can only be set to AfterInjections if injections are specified. Please allow this option to resolve automatically or specify injection samples, volumes and times.";
Error::NoSerialCycleMixing="When ReadOrder->Serial, mixing can only occur before any readings begin or after injections. Please allow this option to resolve automatically or set ReadOrder->Parallel.";

(* Experiment Fluorescence Spectroscopy Specific Errors *)
Error::ExcitationScanOptionsRequired="If an excitation scan is requested, the ExcitationWavelengthRange and EmissionWavelength options must be specified.";
Error::EmissionScanOptionsRequired="If an emission scan is requested, the ExcitationWavelength and EmissionWavelengthRange options must be specified.";
Error::UnneededExcitationScanOptions="If performing only an excitation scan, ExcitationWavelength and EmissionWavelengthRange should not be specified. If you'd like to do an emission scan, please update your SpectralScan option.";
Error::UnneededEmissionScanOptions="If performing only an emission scan, ExcitationWavelengthRange and EmissionWavelength should not be specified. If you'd like to do an excitation scan, please update your SpectralScan option.";
Error::EmissionSpectrumOptionsRequiredTogether="ExcitationWavelength and EmissionWavelengthRange must both be specified or both be Null. Please update one of these options are allow their values to be automatically determined.";
Error::ExcitationSpectrumOptionsRequiredTogether="ExcitationWavelengthRange and EmissionWavelength must both be specified or both be Null. Please update one of these options are allow their values to be automatically determined.";
Error::EmissionWavelengthRangeOverlap="The available instrumentation requires that the starting emission wavelength be at least 25 nanometers larger than the excitation wavelength.";
Error::ExcitationWavelengthRangeOverlap="The available instrumentation requires that the final excitation wavelength be at least 25 nanometers smaller than the emission wavelength.";

Error::ExcitationScanGainRequired="If an excitation scan is requested, the ExcitationScanGain cannot be set to Null.";
Error::EmissionScanGainRequired="If an emission scan is requested, the EmissionScanGain cannot be set to Null.";
Error::ExcitationScanGainUnneeded="No excitation scan is being performed so the corresponding gain is not needed. If you wish to perform an excitation scan, please update the value for SpectralScan.";
Error::EmissionScanGainUnneeded="No emission scan is being performed so the corresponding gain is not needed. If you wish to perform an emission scan, please update the value for SpectralScan.";

Error::AdjustmentExcitationWavelengthRequired="If gain is specified as a percentage of the detector's linear range, then the excitation wavelength at which the gain adjustment should be done must be provided.";
Error::AdjustmentEmissionWavelengthRequired="If gain is specified as a percentage of the detector's linear range, then the emission wavelength at which the gain adjustment should be done must be provided.";
Error::AdjustmentExcitationWavelengthUnneeded="If no excitation scan is being performed or if the gain is specified directly then no excitation wavelength is needed for adjustment. If you wish to determine the gain based on intensity at this wavelength please set gain to a percentage and/or indicate you'd like to perform an excitation scan.";
Error::AdjustmentEmissionWavelengthUnneeded="If no emission scan is being performed or if gain is specified directly then no emission wavelength is needed for adjustment. If you wish to determine the gain based on intensity at this wavelength please set gain to a percentage and/or indicate you'd like to perform an emission scan.";


Error::AdjustmentExcitationWavelengthOutOfRange="The AdjustmentExcitationWavelength must be between the wavelengths specified in ExcitationWavelengthRange. Please double check your adjustment wavelength of consider expanding your range.";
Error::AdjustmentEmissionWavelengthOutOfRange="The AdjustmentEmissionWavelength must be between the wavelengths specified in EmissionWavelengthRange. Please double check your adjustment wavelength of consider expanding your range.";


(* ::Subsubsection:: *)
(*Constants*)


$BMGFlushVolume = 22.5 Milliliter;
$BMGPrimeVolume = 1 Milliliter;


(* this could be different from the Absorbance one so this is defined as well but at the time of this comment writing they were the same*)
BMGCompatiblePlates[Fluorescence] := BMGCompatiblePlates[Fluorescence] = Module[
	{compatiblePlates},

	(* get all the compatible plates; they don't even necessarily need to be liquid handleable *)
	compatiblePlates = Search[
		Model[Container, Plate],
		And[
			(* the 36 well plate is for the weird testing plate; it is treated like a 96 well plate elsewhere so we're just going to do so now too*)
			NumberOfWells == (96 | 384 | 36),
			Dimensions[[3]] <= 2.0 Centimeter,
			Footprint == Plate
		]
	];

	(* for now deleting filter plates because those won't work here, but I don't want to set SubTypes -> False in the Search call because there could in the future be acceptable subtypes *)
	DeleteCases[compatiblePlates, ObjectP[{Model[Container, Plate, Filter], Model[Container, Plate, Irregular]}]]

];
BMGPlateModelLookup[Null]:=Null;
BMGPlateModelLookup[{}]:={};
BMGPlateModelLookup[plateModel:ObjectP[Model[Container, Plate]]]:=First[BMGPlateModelLookup[{plateModel}]];
BMGPlateModelLookup[plateModels:{ObjectP[Model[Container, Plate]]..}]:=Module[
	{platePackets},

	platePackets = Download[plateModels, Packet[BMGLayout, NumberOfWells],Date->Now];

	Map[
		Which[
			StringQ[Lookup[#, BMGLayout]], Lookup[#, BMGLayout],
			MatchQ[Lookup[#, NumberOfWells], 96|36], "GREINER 96 F-BOTTOM",
			MatchQ[Lookup[#, NumberOfWells], 384], "GREINER 384",
			True, Null
		]&,
		platePackets
	]
];
BMGCompatiblePlatesP[Fluorescence] := Alternatives@@BMGCompatiblePlates[Fluorescence];

(* ::Subsubsection:: *)
(*ExperimentFluorescenceIntensity*)


ExperimentFluorescenceIntensity[myContainers:ListableP[ObjectP[{Object[Container],Object[Sample]}]|_String|{LocationPositionP,_String|ObjectP[Object[Container]]}],myOptions:OptionsPattern[]]:=Module[
	{listedContainers,listedOptions,outputSpecification,output,gatherTests,containerToSampleResult,containerToSampleOutput,
		samples,sampleOptions,containerToSampleTests,validSamplePreparationResult,mySamplesWithPreparedSamples,containerToSampleSimulation,
		myOptionsWithPreparedSamples,samplePreparationSimulation},

	(* Determine the requested return value from the function *)
	outputSpecification=Quiet[OptionValue[Output]];
	output=ToList[outputSpecification];

	(* Determine if we should keep a running list of tests *)
	gatherTests=MemberQ[output,Tests];

	(* Remove temporal links and throw warnings *)
	{listedContainers,listedOptions}=removeLinks[ToList[myContainers],ToList[myOptions]];

	(* First, simulate our sample preparation. *)
	validSamplePreparationResult=Check[
		(* Simulate sample preparation. *)
		{mySamplesWithPreparedSamples,myOptionsWithPreparedSamples,samplePreparationSimulation}=simulateSamplePreparationPacketsNew[
			ExperimentFluorescenceIntensity,
			listedContainers,
			listedOptions
		],
		$Failed,
		{Error::MissingDefineNames,Error::InvalidInput,Error::InvalidOption}
	];

	(* If we are given an invalid define name, return early. *)
	If[MatchQ[validSamplePreparationResult,$Failed],
		(* Return early. *)
		(* Note: We've already thrown a message above in simulateSamplePreparationPackets. *)
		ClearMemoization[Experiment`Private`simulateSamplePreparationPackets];Return[$Failed]
	];

	(* Convert our given containers into samples and sample index-matched options. *)
	containerToSampleResult=If[gatherTests,
		(* We are gathering tests. This silences any messages being thrown. *)
		{containerToSampleOutput,containerToSampleTests,containerToSampleSimulation}=containerToSampleOptions[
			ExperimentFluorescenceIntensity,
			mySamplesWithPreparedSamples,
			myOptionsWithPreparedSamples,
			Output->{Result,Tests,Simulation},
			Simulation->samplePreparationSimulation
		];

		(* Therefore, we have to run the tests to see if we encountered a failure. *)
		If[RunUnitTest[<|"Tests"->containerToSampleTests|>,OutputFormat->SingleBoolean,Verbose->False],
			Null,
			$Failed
		],

		(* We are not gathering tests. Simply check for Error::InvalidInput and Error::InvalidOption. *)
		Check[
			{containerToSampleOutput,containerToSampleSimulation}=containerToSampleOptions[
				ExperimentFluorescenceIntensity,
				mySamplesWithPreparedSamples,
				myOptionsWithPreparedSamples,
				Output-> {Result,Simulation},
				Simulation->samplePreparationSimulation
			],
			$Failed,
			{Error::EmptyContainers, Error::ContainerEmptyWells, Error::WellDoesNotExist}
		]
	];

	(* If we were given an empty container, return early. *)
	If[MatchQ[containerToSampleResult,$Failed],
		(* containerToSampleOptions failed - return $Failed *)
		outputSpecification/.{
			Result -> $Failed,
			Tests -> containerToSampleTests,
			Options -> $Failed,
			Preview -> Null
		},
		(* Split up our containerToSample result into the samples and sampleOptions. *)
		{samples,sampleOptions}=containerToSampleOutput;

		(* Call our main function with our samples and converted options. *)
		ExperimentFluorescenceIntensity[samples,ReplaceRule[sampleOptions,{Cache->Lookup[listedOptions,Cache,{}],Simulation->containerToSampleSimulation}]]
	]
];


ExperimentFluorescenceIntensity[mySamples:ListableP[ObjectP[{Object[Sample]}]],myOptions:OptionsPattern[]]:=Module[{
	listedSamples,listedOptions,outputSpecification,output,gatherTestsQ,messagesBoolean,safeOptions,safeOptionTests,
	upload, confirm, fastTrack, parentProt, estimatedRunTime,
	mySamplesWithPreparedSamplesNamed, myOptionsWithPreparedSamplesNamed, safeOptionsNamed,
	validLengthsQ,validLengthTests,templateOptions,templateOptionsTests,inheritedOptions,expandedSafeOps,
	downloadedPackets,sampleObjects,cache,newCache,resolvedOptionsResult,resolvedOptions,resolvedOptionsTests,
	collapsedResolvedOptions,resourcePackets,resourcePacketTests,protocolObject,validSamplePreparationResult,
	mySamplesWithPreparedSamples,myOptionsWithPreparedSamples,samplePreparationSimulation,
	returnEarlyQ,performSimulationQ,simulatedProtocol,simulation
},

	(* Determine the requested return value from the function *)
	outputSpecification=OptionValue[Output];
	output=ToList[outputSpecification];

	(* Determine if we should keep a running list of tests *)
	gatherTestsQ=MemberQ[output,Tests];
	messagesBoolean=!gatherTestsQ;

	(* Remove temporal links and throw warnings *)
	{listedSamples,listedOptions}=removeLinks[ToList[mySamples],ToList[myOptions]];

	(* Simulate our sample preparation. *)
	validSamplePreparationResult=Check[
		(* Simulate sample preparation. *)
		{mySamplesWithPreparedSamplesNamed, myOptionsWithPreparedSamplesNamed, samplePreparationSimulation}=simulateSamplePreparationPacketsNew[
			ExperimentFluorescenceIntensity,
			listedSamples,
			listedOptions
		],
		$Failed,
	 	{Error::MissingDefineNames, Error::InvalidInput, Error::InvalidOption}
	];

	(* If we are given an invalid define name, return early. *)
	If[MatchQ[validSamplePreparationResult,$Failed],
		(* Return early. *)
		(* Note: We've already thrown a message above in simulateSamplePreparationPackets. *)
		ClearMemoization[Experiment`Private`simulateSamplePreparationPackets];Return[$Failed]
	];

	(* --- Downloading Required Information --- *)

	(* Default any unspecified or incorrectly-specified options; assign re-used values to local variables *)
	{safeOptionsNamed,safeOptionTests}=If[gatherTestsQ,
		SafeOptions[ExperimentFluorescenceIntensity,myOptionsWithPreparedSamplesNamed,AutoCorrect->False,Output->{Result,Tests}],
		{SafeOptions[ExperimentFluorescenceIntensity,myOptionsWithPreparedSamplesNamed,AutoCorrect->False],Null}
	];

	(* Sanitize Inputs *)
	{mySamplesWithPreparedSamples, safeOptions, myOptionsWithPreparedSamples} = sanitizeInputs[mySamplesWithPreparedSamplesNamed,safeOptionsNamed, myOptionsWithPreparedSamplesNamed];

	(* If the specified options don't match their patterns or if option lengths are invalid return $Failed *)
	If[MatchQ[safeOptions,$Failed],
		Return[outputSpecification/.{
			Result -> $Failed,
			Tests -> safeOptionTests,
			Options -> $Failed,
			Preview -> Null
		}]
	];

	{validLengthsQ,validLengthTests} = Quiet[
		If[gatherTestsQ,
			ValidInputLengthsQ[ExperimentFluorescenceIntensity,{mySamplesWithPreparedSamples},myOptionsWithPreparedSamples,Output->{Result,Tests}],
			{ValidInputLengthsQ[ExperimentFluorescenceIntensity,{mySamplesWithPreparedSamples},myOptionsWithPreparedSamples],Null}
		],
		Warning::IndexMatchingOptionMissing
	];

	(* If the specified options don't match their patterns or if option lengths are invalid return $Failed *)
	If[!validLengthsQ,
		Return[outputSpecification/.{
			Result -> $Failed,
			Tests -> Join[safeOptionTests,validLengthTests],
			Options -> $Failed,
			Preview -> Null
		}]
	];

	(* get assorted hidden options *)
	{upload, confirm, fastTrack, parentProt, cache} = Lookup[safeOptions, {Upload, Confirm, FastTrack, ParentProtocol, Cache}];

	(* apply the template options - no need to specify the definition number since we only have samples defined as input *)
	{templateOptions, templateOptionsTests} = If[gatherTestsQ,
		ApplyTemplateOptions[ExperimentFluorescenceIntensity, {mySamplesWithPreparedSamples}, myOptionsWithPreparedSamples, Output -> {Result, Tests}],
		{ApplyTemplateOptions[ExperimentFluorescenceIntensity, {mySamplesWithPreparedSamples}, myOptionsWithPreparedSamples, Output -> Result], Null}
	];

	(* Return early if the template cannot be used - will only occur if the template object does not exist. *)
	If[MatchQ[templateOptions,$Failed],
		Return[outputSpecification/.{
			Result -> $Failed,
			Tests -> Join[safeOptionTests,validLengthTests,templateOptionsTests],
			Options -> $Failed,
			Preview -> Null
		}]
	];

	(* combine the two sets of options (the ones specified and the ones from the template protocol) *)
	inheritedOptions=ReplaceRule[safeOptions,templateOptions];

	(* Expand index-matching options *)
	expandedSafeOps = Last[ExpandIndexMatchedInputs[ExperimentFluorescenceIntensity,{mySamplesWithPreparedSamples},inheritedOptions]];

	(* Yell about Confirm->True Upload->False; since UploadProtocolStatus cannot access resources until after upload *)
	(* Safe to return Failed here since Upload is not a user facing option *)
	If[MatchQ[upload,False]&&TrueQ[confirm],
		Message[Error::ConfirmUploadConflict];
		Return[$Failed]
	];

	(* --- Assemble Download --- *)
	downloadedPackets=plateReaderExperimentDownload[Object[Protocol,FluorescenceIntensity],mySamplesWithPreparedSamples,expandedSafeOps,cache,samplePreparationSimulation];

	(* Return early if objects do not exist *)
	If[MatchQ[downloadedPackets,$Failed],
		Return[$Failed]
	];

	sampleObjects=Lookup[fetchPacketFromCache[#,downloadedPackets],Object]&/@mySamplesWithPreparedSamples;

	newCache=FlattenCachePackets[{cache,downloadedPackets}];

	(* Build the resolved options *)
	resolvedOptionsResult=If[gatherTestsQ,
		(* We are gathering tests. This silences any messages being thrown. *)
		{resolvedOptions,resolvedOptionsTests}=resolvePlateReaderOptions[Object[Protocol,FluorescenceIntensity],mySamplesWithPreparedSamples,expandedSafeOps,Cache->newCache,Simulation->samplePreparationSimulation,Output->{Result,Tests}];

		(* Therefore, we have to run the tests to see if we encountered a failure. *)
		If[RunUnitTest[<|"Tests"->resolvedOptionsTests|>,OutputFormat->SingleBoolean,Verbose->False],
			{resolvedOptions,resolvedOptionsTests},
			$Failed
		],

		(* We are not gathering tests. Simply check for Error::InvalidInput and Error::InvalidOption. *)
		Check[
			{resolvedOptions,resolvedOptionsTests}={resolvePlateReaderOptions[Object[Protocol,FluorescenceIntensity],mySamplesWithPreparedSamples,expandedSafeOps,Cache->newCache,Simulation->samplePreparationSimulation],{}},
			$Failed,
			{Error::InvalidInput,Error::InvalidOption}
		]
	];

	(* Collapse the resolved options *)
	collapsedResolvedOptions = CollapseIndexMatchedOptions[
		ExperimentFluorescenceIntensity,
		resolvedOptions,
		Ignore->ToList[myOptions],
		Messages->False
	];

	(* run all the tests from the resolution; if any of them were False, then we should return early here *)
	(* need to do this becasue if we are collecting tests then the Check wouldn't have caught it *)
	(* basically, if _not_ all the tests are passing, then we do need to return early *)
	returnEarlyQ = Which[
		MatchQ[resolveOptionsResult, $Failed], True,
		gatherTests, Not[RunUnitTest[<|"Tests" -> resolutionTests|>, Verbose -> False, OutputFormat -> SingleBoolean]],
		True, False
	];

	(* Figure out if we need to perform our simulation. If so, we can't return early even though we want to because we *)
	(* need to return some type of simulation to our parent function that called us. *)
	performSimulationQ=MemberQ[output, Simulation] || MatchQ[$CurrentSimulation, SimulationP] || MatchQ[Lookup[resolvedOptions, Preparation], Robotic];

	(* if resolveOptionsResult is $Failed, return early; messages would have been thrown already *)
	If[returnEarlyQ && !performSimulationQ,
		Return[outputSpecification /. {
			Result -> $Failed,
			Options -> RemoveHiddenOptions[ExperimentFluorescenceIntensity,collapsedResolvedOptions],
			Preview -> Null,
			Tests -> Join[safeOptionTests,validLengthTests,templateOptionsTests,resolvedOptionsTests],
			Simulation->Simulation[],
			RunTime->0 Minute
		}]
	];

	(* Build packets with resources *)
	{resourcePackets,resourcePacketTests} = Which[
		MatchQ[resolvedOptionsResult, $Failed],
			{$Failed,{}},
		gatherTestsQ,
			plateReaderResourcePackets[Object[Protocol,FluorescenceIntensity],sampleObjects,templateOptions,resolvedOptions,Cache->newCache,Simulation->samplePreparationSimulation,Output->{Result,Tests}],
		True,
			{plateReaderResourcePackets[Object[Protocol,FluorescenceIntensity],sampleObjects,templateOptions,resolvedOptions,Cache->newCache,Simulation->samplePreparationSimulation],{}}
	];

	(* If we were asked for a simulation, also return a simulation. *)
	{simulatedProtocol, simulation} = If[performSimulationQ,
		simulateReadPlateExperiment[
			Object[Protocol, FluorescenceIntensity],
			If[MatchQ[resourcePackets, $Failed],
				$Failed,
				resourcePackets[[1]] (* protocolPacket *)
			],
			If[MatchQ[resourcePackets, $Failed],
				$Failed,
				resourcePackets[[2]] (* unitOperationPackets *)
			],
			ToList[mySamplesWithPreparedSamples],
			resolvedOptions,
			Cache->newCache,
			Simulation->samplePreparationSimulation
		],
		{Null, Null}
	];

	estimatedRunTime = 15 Minute +
		(Lookup[resolvedOptions,PlateReaderMixTime]/.Null->0 Minute) +
		(* Add time needed to clean/prime each each injection line *)
		(If[!MatchQ[Lookup[resolvedOptions,PrimaryInjectionSample],Null|{}],15*Minute,0*Minute]);

	(* If we don't have to return the Result, don't bother calling UploadProtocol[...]. *)
	If[!MemberQ[output,Result],
		Return[outputSpecification/.{
			Result -> Null,
			Tests -> Flatten[{safeOptionTests,validLengthTests,templateOptionsTests,resolvedOptionsTests,resourcePacketTests}],
			Options -> RemoveHiddenOptions[ExperimentFluorescenceIntensity,collapsedResolvedOptions],
			Preview -> Null,
			Simulation -> simulation,
			RunTime -> estimatedRunTime
		}]
	];

	(* We have to return our result. Either return a protocol with a simulated procedure if SimulateProcedure\[Rule]True or return a real protocol that's ready to be run. *)
	protocolObject=Which[

		(* If resource packets could not be generated or options could not be resolved, can't generate a protocol, return $Failed *)
		MatchQ[resourcePackets,$Failed] || MatchQ[resolvedOptionsResult,$Failed],
		$Failed,

		(* If we're doing Preparation->Robotic, return our unit operations packets back without RequireResources called if Upload->False. *)
		MatchQ[Lookup[resolvedOptions,Preparation],Robotic]&&MatchQ[upload,False],
		resourcePackets[[2]], (* unitOperationPackets *)

		(* If we're doing Preparation->Robotic and Upload->True, call RCP or RSP with our primitive. *)
		MatchQ[Lookup[resolvedOptions,Preparation],Robotic],
		Module[{primitive, nonHiddenOptions,experimentFunction},
			(* Create our primitive to feed into RoboticSamplePreparation. *)
			primitive=FluorescenceIntensity@@Join[
				{
					Sample->mySamples
				},
				RemoveHiddenPrimitiveOptions[FluorescenceIntensity,ToList[myOptions]]
			];

			(* Remove any hidden options before returning. *)
			nonHiddenOptions=RemoveHiddenOptions[ExperimentFluorescenceIntensity,collapsedResolvedOptions];

			(* determine which work cell will be used (determined with the readPlateWorkCellResolver) to decide whether to call RSP or RCP *)
			experimentFunction = Lookup[$WorkCellToExperimentFunction, Lookup[resolvedOptions, WorkCell]];

			(* Memoize the value of ExperimentFluorescenceIntensity so the framework doesn't spend time resolving it again. *)
			Internal`InheritedBlock[{ExperimentFluorescenceIntensity, $PrimitiveFrameworkResolverOutputCache},
				$PrimitiveFrameworkResolverOutputCache=<||>;

				DownValues[ExperimentFluorescenceIntensity]={};

				ExperimentFluorescenceIntensity[___, options:OptionsPattern[]]:=Module[{frameworkOutputSpecification},
					(* Lookup the output specification the framework is asking for. *)
					frameworkOutputSpecification=Lookup[ToList[options], Output];

					frameworkOutputSpecification/.{
						Result -> resourcePackets[[2]],
						Options -> nonHiddenOptions,
						Preview -> Null,
						Simulation -> simulation,
						RunTime -> estimatedRunTime
					}
				];

				experimentFunction[
					{primitive},
					Name->Lookup[safeOptions,Name],
					Upload->Lookup[safeOptions,Upload],
					Confirm->Lookup[safeOptions,Confirm],
					ParentProtocol->Lookup[safeOptions,ParentProtocol],
					Priority->Lookup[safeOptions,Priority],
					StartDate->Lookup[safeOptions,StartDate],
					HoldOrder->Lookup[safeOptions,HoldOrder],
					QueuePosition->Lookup[safeOptions,QueuePosition],
					Cache->newCache
				]
			]
		],

		(* Actually upload our protocol object. *)
		True,
		UploadProtocol[
			resourcePackets[[1]], (* protocolPacket *)
			Upload->Lookup[safeOptions,Upload],
			Confirm->Lookup[safeOptions,Confirm],
			ParentProtocol->Lookup[safeOptions,ParentProtocol],
			Priority->Lookup[safeOptions,Priority],
			StartDate->Lookup[safeOptions,StartDate],
			HoldOrder->Lookup[safeOptions,HoldOrder],
			QueuePosition->Lookup[safeOptions,QueuePosition],
			ConstellationMessage->Object[Protocol,FluorescenceIntensity],
			Cache -> newCache,
			Simulation -> samplePreparationSimulation
		]
	];

	(* Return requested output *)
	outputSpecification/.{
		Result -> protocolObject,
		Tests -> Flatten[{safeOptionTests,validLengthTests,templateOptionsTests,resolvedOptionsTests,resourcePacketTests}],
		Options -> RemoveHiddenOptions[ExperimentFluorescenceIntensity,collapsedResolvedOptions],
		Preview -> Null,
		Simulation -> simulation,
		RunTime -> estimatedRunTime
	}
];



DefineOptions[
	resolvePlateReaderOptions,
	Options:>{
		HelperOutputOption,
		CacheOption,
		SimulationOption
	}
];


(*
	No luminescence experiments have ExcitationWavelength
	Mode only applies to FluorescenceIntensity and FluorescenceKinetics
	FluorescenceSpectroscopy handles all wavelengths on its own
*)

resolvePlateReaderOptions[
	type:(Object[Protocol,FluorescenceIntensity]|Object[Protocol,FluorescenceKinetics]|Object[Protocol,FluorescenceSpectroscopy]|Object[Protocol,LuminescenceIntensity]|Object[Protocol,LuminescenceKinetics]|Object[Protocol,LuminescenceSpectroscopy]|Object[Protocol,FluorescencePolarization]|Object[Protocol,FluorescencePolarizationKinetics]),
	mySamples:{ObjectP[Object[Sample]]...},
	myExperimentOptions:{_Rule...},
	myResolverOptions:OptionsPattern[resolvePlateReaderOptions]
]:=Module[{
	experimentFunction,measurementType,experimentType,outputSpecification,output,gatherTestsQ,messagesBoolean,cache,simulation,updatedSimulation,
	samplePrepOptions,experimentOptions,simulatedSamples,resolvedSamplePrepOptions,samplePrepTests,experimentOptionsAssociation,
	injectionObjects,uniqueInjectionSamples,supportedPlateModels,defaultAliquotContainer,allPlateReaderModels,suppliedPlateReader,potentialPolarizationPlateReader,plateReaderToDownload,requestedProtocolName,
	plateReaderModelFields,plateReaderModelPacketSpec,suppliedPlateReaderPacketSpec,possibleAliquotContainers,preparationResult,allowedPreparation,preparationTest,resolvedWorkCell,resolvedPreparation,
	sampleTuples,listedInjectionSamplePackets,plateReaderDownload,plateReaderPacketLists,nameDownload,aliquotDownload,plateReaderModelPacket,plateReaderModelObject,samplePackets,
	sampleContainerPackets,sampleContainerModelPackets,injectionSamplePackets,allPlateReaderModelPackets,aliquotContainerModelPackets,
	aliquotContainerModelPacket,optionPrecisions,filteredOptionPrecisions,
	optionPrecisionTests,suppliedAliquotBooleans,numberOfReplicates,replicatesError,replicatesAliquotTest,invalidReplicatesOptions,
	suppliedMode,neededMode,validPlateReaderMode,plateReaderModeTest,invalidModeOptions,
	suppliedDelayTime,suppliedReadTime,timeResolvedImplied,missingIntegrationTimes,unneededIntegrationTimes,requiredIntegrationTimes,integrationModeTest,conflictingTimes,
	conflictingTimesTest,invalidIntegrationTimeOptions,integrationTimesSupported,integrationTimesSupportedTest,invalidIntegrationPlateReaderOptions,
	suppliedWavelengthSelection,wavelengthSelectionPossibleFunction,wavelengthSelectionPossible,wavelengthSelectionPossibleTest,invalidWavelengthSelectionOptions,
	invalidSelectionForMode,invalidSelectionForModeTest,invalidWavelengthSelectionModeOptions,
	suppliedEmissionWavelength,filteredEmissionWavelengths,filterBandwidth,filtersOnly,validEmissionWavelengthFunction,
	emissionWavelengthsValid,emissionTest,invalidEmissionWavelengthOption,excitationTest,invalidExcitationWavelengthOption,
	suppliedExcitationWavelength,filteredExcitationWavelengths,validExcitationWavelengthFunction,excitationWavelengthsValid,
	suppliedDualEmissionWavelengths,suppliedDualEmissionGains,dualEmissionRequested,validDualEmission,dualEmissionTest,invalidDualEmissionOptions,
	filteredDualEmissionWavelengths,dualEmissionWavelengthsValid,dualEmissionWavelengthTest,invalidDualEmissionWavelengthOptions,
	missingDualEmissionGain,unneededDualEmissionGain,missingDualEmissionGainTest,unneededDualEmissionGainTest,invalidDualEmissionComboOptions,
	opticModuleForWavelengthFunction,validWavelengthCombinationFunction,validWavelengthCombination,validWavelengthCombinationTest,
	suppliedSamplingPattern,suppliedSamplingDistance,suppliedSamplingDimension,samplingRequested,
	validSamplingCombo,validSamplingComboTest,instrumentSupportedSampling,validSamplingInstrumentTest,anyInstrumentSupportsSampling,
	validSamplingModeTest,invalidSamplingOptions,
	invalidWavelengthComboOptions,wavelengthOrderingOk,wavelengthOrderingTest,wavelengthSelectionRequired,wavelengthSelectionUnused,
	wavelengthSelectionRequiredTest,wavelengthSelectionUnusedTest,invalidWavelengthSelectionOption,numberOfMultichromaticsLookup,numberOfMultichromaticsAllowed,
	requestedMultichromatics,sufficientMultichromatics,multichromaticsTest,invalidWavelengthNumberOptions,suppliedGains,
	suppliedExcitationScanGain,suppliedEmissionScanGain,compatibleGains,compatibleGainsTests,invalidGainOptions,
	suppliedFocalHeight,suppliedAdjustmentSample,focalHeightRequested,unneededFocalHeight,requiredFocalHeight,unneededFocalHeightTest,requiredFocalHeightTest,
	invalidFocalHeightOptions,invalidFocalHeightAdjustmentSample,focalHeightAdjustmentTest,invalidFocalHeightAdjustmentSampleOptions,
	adjustmentSampleIndex,adjustmentSampleValue,inputSampleObjects,validAdjustmentSample,adjustmentSampleAppearances,
	ambiguousAdjustmentSample,validAdjustmentIndex,adjusting,adjustmentSampleMissing,adjustmentTest,adjustmentAmbiguousTest,adjustmentIndexTest,requiredAdjustmentTest,
	unusedAdjustmentSampleFunction,unusedAdjustmentSample,unusedAdjustmentTest,invalidAdjustmentOption,
	fullPlateScanRequested,invalidFullPlateScan,fullPlateScanTest,invalidPlateScanOptions,noFullPlateModes,
	invalidFullPlateMode,invalidFullPlateModeOptions,anyInjectionsQ,
	plateReaderMixTests,plateReaderMixOptionInvalidities,numberOfAssaySamples,invalidMoatOptions,moatTests,
	validNameBoolean,nameTest,invalidNameOption,suppliedReadLocation,suppliedRetainCover,topReadIssue,topReadTest,
	validRetainCover,retainCoverTest,invalidCoverOption,possiblePlateReaderPackets,expandedExcitationWavelengths,
	unresolvablePlateReader,plateReaderTest,defaultReaderModelPacket,resolvedPlateReader,resolvedPlateReaderModelPacket,resolvedPlateReaderModelObject,resolvedMode,resolvedWavelengthSelection,
	readerModelPacketForResolution,resolvedWavelengths,resolvedEmissionWavelengths,resolvedExcitationWavelengths,resolvedDualEmissionWavelengths,
	resolvedDelayTime,resolvedReadTime,suppliedPlateReaderMix,suppliedMixParameters,suppliedPlateReaderMixRate,
	suppliedPlateReaderMixTime,suppliedPlateReaderMixMode,suppliedPlateReaderMixSchedule,resolvedPlateReaderMix,
	defaultMixingRate,defaultMixingTime,defaultMixingMode,defaultMixingSchedule,resolvedPlateReaderMixRate,resolvedPlateReaderMixTime,resolvedPlateReaderMixMode,
	resolvedPlateReaderMixSchedule,defaultGainPercentage,defaultGain,resolvedGains,resolvedDualEmissionGains,resolvedFocalHeight,
	relevantGains,resolvedAdjustmentSample,resolvedAdjustmentSampleIndex,resolvedAdjustmentSpecification,suppliedPrimaryFlowRate,suppliedSecondaryFlowRate,suppliedTertiaryFlowRate,suppliedQuaternaryFlowRate,primaryInjectionsQ,secondaryInjectionQ,tertiaryInjectionQ,quaternaryInjectionQ,resolvedPrimaryFlowRate,resolvedSecondaryFlowRate,resolvedTertiaryFlowRate,resolvedQuaternaryFlowRate,
	clarioStarMinFlowRate,invalidFlowRateQ,invalidFlowRateOption,invalidFlowRateTest,
	suppliedMoatSize,suppliedMoatBuffer,suppliedMoatVolume,impliedMoat,resolvedMoatBuffer,resolvedMoatVolume,resolvedMoatSize,resolvedReadLocation,resolvedEquilibrationTime,
	resolvedSamplingPattern,modeForSampling,resolvedSamplingDistance,resolvedSamplingDimension,resolvedExperimentOptions,optionsForSpectroscopyResolvers,resolvedSpectroscopyOptions,
	suppliedAliquotVolumes,suppliedAssayVolumes,suppliedTargetConcentrations,suppliedAssayBuffers,suppliedAliquotContainers,uniqueContainers,containerModels,uniqueContainerWellColor,conflictWellColorAndReadLocation,aliquotRequired,impliedAliquotingBooleans,preresolvedAliquotOptions,
	automaticAliquotingBooleans,aliquotWarningTest,aliquotConflictBooleans,resolvedAliquotBooleans,resolvedAliquotContainers,duplicateSampleError,plateWells,moatWells,suppliedDestinationWells,duplicateDestinationWells,duplicateDestinationWellOption,duplicateDestinationWellTest,invalidDestinationWellLengthQ,invalidDestinationWellLengthOption,invalidDestinationWellLengthTest,resolvedDestinationWells,transferredResolvedDestinationWells,
	invalidRepeatSamples,aliquotContainerObjects,numberOfAliquotContainers,uniqueAliquotContainers,aliquotContainerWellcolor,aliquotContainerWellColorError,singlePlateError,sampleNumberError,invalidNumberSamples,aliquotContainerError,repeatedSampleTest,
	aliquotTest,tooManySamplesTest,aliquotContainerTest,wellColorAliquotTest,invalidAliquotOption,invalidAliquotContainerOption,aliquotContainerPacket,requiredAliquotAmount,invalidPlateReaderResolutionOption,invalidSpectroscopyOptions,spectroscopyTests,
	resolvedPostProcessingOptions,injectionSamples,compatibleMaterials,compatibleMaterialsTests,
	invalidCompatibilityOptions,plateContents,sampleObjects,stowawaysPresentQ,suppliedTemperature,stowawaysDisturbed,stowawayTest,
	assayContainerModelPacket,invalidInjectionOptions,validInjectionTests,invalidOptions,invalidSamples,resolvedAliquotOptions,finalResolvedAliquotOptions,aliquotTests,resolvedOptions,
	samplesInStorageError, samplesInStorageCondition, invalidStorageConditionOptions, invalidStorageConditionTest,
	resolvedTargetPolarization, resolvedSampleLabels, resolvedSampleContainerLabels, resolvedFocalHeightListed, multipleFocalHeightRequested,
	multipleFocalHeightTest, firstResolvedFocalHeight
},

	(* Get the name of the experiment function to send to ExpandIndexMatchedOptions and broadly classify the type of experiment we're doing for downstream checks *)
	{experimentFunction,measurementType,experimentType}=Switch[type,
		Object[Protocol,FluorescencePolarization],{ExperimentFluorescencePolarization,Fluorescence,Intensity},
		Object[Protocol,FluorescencePolarizationKinetics],{ExperimentFluorescencePolarizationKinetics,Fluorescence,Kinetics},
		Object[Protocol,FluorescenceIntensity],{ExperimentFluorescenceIntensity,Fluorescence,Intensity},
		Object[Protocol,FluorescenceKinetics],{ExperimentFluorescenceKinetics,Fluorescence,Kinetics},
		Object[Protocol,FluorescenceSpectroscopy],{ExperimentFluorescenceSpectroscopy,Fluorescence,Spectroscopy},
		Object[Protocol,LuminescenceIntensity],{ExperimentLuminescenceIntensity,Luminescence,Intensity},
		Object[Protocol,LuminescenceKinetics],{ExperimentLuminescenceKinetics,Luminescence,Kinetics},
		Object[Protocol,LuminescenceSpectroscopy],{ExperimentLuminescenceSpectroscopy,Luminescence,Spectroscopy}
	];

	(* Lookup relevant options *)
	(* Default to Null as FluorescencePolarization/FluorescencePolarizationKinetics/FluorescenceSpectroscopy/LuminescenceIntensity/LuminescenceKinetics/LuminescenceSpectroscopy do not have mode option *)
	suppliedMode=Lookup[myExperimentOptions,Mode,Null];

	(* For plate reader support check figure out the mode we're going to need if Mode isn't an option or if user hasn't specified *)
	neededMode=Which[
		MatchQ[type,Object[Protocol,FluorescencePolarization]],FluorescencePolarization,
		MatchQ[type,Object[Protocol,FluorescencePolarizationKinetics]],FluorescencePolarizationKinetics,
		MatchQ[type,Object[Protocol,FluorescenceSpectroscopy]],FluorescenceSpectroscopy,
		MatchQ[type,Object[Protocol,LuminescenceIntensity]],LuminescenceIntensity,
		MatchQ[type,Object[Protocol,LuminescenceKinetics]],LuminescenceKinetics,
		MatchQ[type,Object[Protocol,LuminescenceSpectroscopy]],LuminescenceSpectroscopy,
		(* Fluorescence Intensity/Kinetics have mode option, check this if specified *)
		(* If it's Fluorescence we'll transform to be more specific below *)
		MatchQ[suppliedMode,Except[Fluorescence,PlateReaderModeP]],suppliedMode,
		MatchQ[type,Object[Protocol,FluorescenceIntensity]],FluorescenceIntensity,
		MatchQ[type,Object[Protocol,FluorescenceKinetics]],FluorescenceKinetics
	];

	(* Determine the requested return value from the function *)
	outputSpecification=OptionValue[Output];
	output=ToList[outputSpecification];

	(* Determine if we should keep a running list of tests *)
	gatherTestsQ=MemberQ[output,Tests];
	messagesBoolean=!gatherTestsQ;

	(* The pre-downloaded packets *)
	cache=OptionValue[Cache];
	simulation = OptionValue[Simulation];

	(* Separate out our <Type> options from our Sample Prep options. *)
	{samplePrepOptions,experimentOptions}=splitPrepOptions[myExperimentOptions];

	(* Resolve our sample prep options *)
	{{simulatedSamples,resolvedSamplePrepOptions,updatedSimulation},samplePrepTests}=If[gatherTestsQ,
		resolveSamplePrepOptionsNew[experimentFunction,mySamples,samplePrepOptions,Cache->cache,Simulation->simulation,Output->{Result,Tests}],
		{resolveSamplePrepOptionsNew[experimentFunction,mySamples,samplePrepOptions,Cache->cache,Simulation->simulation,Output->Result],{}}
	];

	(* --- Assemble Download --- *)

	(* Get the samples we're injecting *)
	injectionObjects=DeleteCases[Flatten[Lookup[experimentOptions,{PrimaryInjectionSample,SecondaryInjectionSample,TertiaryInjectionSample,QuaternaryInjectionSample},Null],1],Null];
	uniqueInjectionSamples=Download[Cases[injectionObjects,ObjectP[Object]],Object];

	(* Stash a list of plate models we know our BMG plate readers to be compatible with *)
	supportedPlateModels = BMGCompatiblePlates[Fluorescence];

	defaultAliquotContainer=First[supportedPlateModels];

	(* Search for all plate reader models; we may need this to help resolve options *)
	allPlateReaderModels=Search[Model[Instrument,PlateReader],PlateReaderMode==neededMode&&Deprecated!=True];

	(* Get requested plate reader *)
	suppliedPlateReader=Lookup[experimentOptions,Instrument];

	(* Get the possible Polarization Experiment Plate Reader. If there is only one, we can use that in our resolver for accurate conflict messages *)
	potentialPolarizationPlateReader=Search[Model[Instrument,PlateReader],PlateReaderMode==FluorescencePolarization&&Deprecated!=True];

	(* If Instrument is left Automatic, convert to Null to play nice with Download *)
	(* Note that if we only support one instrument (currently PHERAstar) for Polarization experiments, we can replace Automatic with it for the most accurate conflict messages *)
	plateReaderToDownload=If[MatchQ[type,Object[Protocol,FluorescencePolarization]|Object[Protocol,FluorescencePolarizationKinetics]]&&Length[potentialPolarizationPlateReader]==1,
		Replace[suppliedPlateReader,Automatic->First[potentialPolarizationPlateReader]],
		Replace[suppliedPlateReader,Automatic->Null]
	];

	(* Get requested name *)
	requestedProtocolName=Lookup[experimentOptions,Name];

	(* Fields we need to download from any plate reader models we might use: *)
	plateReaderModelFields={EmissionFilterTypes,ExcitationFilterTypes,PlateReaderMode,OpticModules,MinTemperature,MaxTemperature,MinExcitationWavelength,MaxExcitationWavelength,
		ExcitationFilters,ExcitationWavelengthResolution,MinEmissionWavelength,MaxEmissionWavelength,EmissionFilters,EmissionWavelengthResolution,MaxFilters,WettedMaterials,SamplingPatterns};
	If[MatchQ[type,Object[Protocol,FluorescencePolarization]|Object[Protocol,FluorescencePolarizationKinetics]],
		plateReaderModelFields=Join[plateReaderModelFields,{PolarizationExcitationFilters,PolarizationEmissionFilters}]
	];

	(* Get fields in packet form *)
	plateReaderModelPacketSpec=Packet@@plateReaderModelFields;

	(* Set-up to download model info from the plate reader option *)
	suppliedPlateReaderPacketSpec=Switch[{suppliedPlateReader,type},
		{Automatic,Object[Protocol,FluorescencePolarization]|Object[Protocol,FluorescencePolarizationKinetics]},{plateReaderModelPacketSpec},
		{Automatic,_},{},
		{ObjectP[Object[Instrument,PlateReader]],_},{Packet[Model[plateReaderModelFields]]},
		{ObjectP[Model[Instrument,PlateReader]],_},{plateReaderModelPacketSpec}
	];

	(* Get any user supplied aliquot containers (using Cases since aliquot containers are tagged with integers) and append the our default *)
	(* Note: we use this order later, assuming the first container in this list will be our aliquot container *)
	possibleAliquotContainers=Append[
		DeleteDuplicates[Cases[Lookup[samplePrepOptions,AliquotContainer],ObjectP[]]],
		defaultAliquotContainer
	];

	(* Download required information from the sample and option values if necessary *)
	(* Quiet Download errors thrown if any injections were sent as models and don't have containers *)
	{sampleTuples,listedInjectionSamplePackets,plateReaderDownload,plateReaderPacketLists,nameDownload,aliquotDownload}=Quiet[
		Download[
			{
				simulatedSamples,
				uniqueInjectionSamples,
				{plateReaderToDownload},
				allPlateReaderModels,
				{Append[type,ToString[requestedProtocolName]]},
				possibleAliquotContainers
			},
			{
				{
					Packet[Container,Volume],
					Packet[Container[{Contents,Model}]],
					Packet[Container[Model][{MinVolume,MaxVolume,AspectRatio,NumberOfWells,WellColor,WellDiameter,RecommendedFillVolume, ContainerMaterials}]]
				},
				{Packet[Container,Volume,State]},
				suppliedPlateReaderPacketSpec,
				{plateReaderModelPacketSpec},
				{ID},
				{Packet[MinVolume,MaxVolume,AspectRatio,NumberOfWells,WellColor,WellDiameter,RecommendedFillVolume, ContainerMaterials]}
			},
			Cache->cache,
			Simulation -> updatedSimulation,
			Date->Now
		],
		{Download::FieldDoesntExist,Download::NotLinkField,Download::ObjectDoesNotExist}
	];

	(* Extract info from plate reader option download *)
	{plateReaderModelPacket,plateReaderModelObject}=Which[
		MatchQ[suppliedPlateReader,ObjectP[]],
		{plateReaderDownload[[1,1]],Lookup[plateReaderDownload[[1,1]],Object]},
		MatchQ[type,Object[Protocol,FluorescencePolarization]|Object[Protocol,FluorescencePolarizationKinetics]],
		{plateReaderDownload[[1,1]],Lookup[plateReaderDownload[[1,1]],Object]},
		True,
		{Null,Null}
	];

	(* Extract packets for when the direct inputs were samples *)
	samplePackets=sampleTuples[[All,1]];
	sampleContainerPackets=sampleTuples[[All,2]];
	sampleContainerModelPackets=sampleTuples[[All,3]];

	(* Remove extra list layer resulting from MapThread download *)
	injectionSamplePackets=Flatten[listedInjectionSamplePackets,1];

	(* Get a flat list of packets for every plate reader model; we may have to reference these to resolve options *)
	allPlateReaderModelPackets=Flatten[plateReaderPacketLists,1];

	(* Get info about the container models user wants to aliquot samples into *)
	aliquotContainerModelPackets=aliquotDownload[[All,1]];
	aliquotContainerModelPacket=First[aliquotContainerModelPackets];

	(* -- OPTION PRECISION CHECKS -- *)

	(* Gather precisions for all our options across the board *)
	optionPrecisions={
		{ExcitationWavelength,1 Nanometer},
		{EmissionWavelength,1 Nanometer},
		{DualEmissionWavelength,1 Nanometer},
		{AdjustmentExcitationWavelength,1 Nanometer},
		{AdjustmentEmissionWavelength,1 Nanometer},
		{DelayTime,1 Microsecond},
		{ReadTime,1 Microsecond},
		{Temperature,10^-1 Celsius},
		{EquilibrationTime,1 Second},
		{FocalHeight,10^-1 Millimeter},
		{PrimaryInjectionVolume,1 Microliter},
		{SecondaryInjectionVolume,1 Microliter},
		{TertiaryInjectionVolume,1 Microliter},
		{QuaternaryInjectionVolume,1 Microliter},
		{MoatVolume,1 Microliter},
		{PlateReaderMixTime,1 Second},
		{PlateReaderMixRate, 100 RPM},
		{SamplingDistance, 1 Millimeter},
		{TargetPolarization, 1 PolarizationUnit Milli}
	};

	(* Send RoundOptionPrecision only the options that apply to our current function *)
	filteredOptionPrecisions=Select[optionPrecisions,MemberQ[experimentOptions[[All,1]],First[#]]&];

	(* Verify that the experiment options are not overly precise *)
	{experimentOptionsAssociation,optionPrecisionTests}=If[gatherTestsQ,
		RoundOptionPrecision[Association[experimentOptions],filteredOptionPrecisions[[All,1]],filteredOptionPrecisions[[All,2]],Output->{Result,Tests}],
		{RoundOptionPrecision[Association[experimentOptions],filteredOptionPrecisions[[All,1]],filteredOptionPrecisions[[All,2]]],Null}
	];

	(* Resolve our preparation option. Do this after resolving the instrument option, as the instrument determines whether the experiment can be done robotically or not.*)
	preparationResult=Check[
		{allowedPreparation, preparationTest}=If[MatchQ[gatherTestsQ, False],
			{
				Experiment`Private`resolveReadPlateMethod[mySamples, type, ReplaceRule[Normal@experimentOptionsAssociation, Join[{Cache->cache, Output->Result}]], {Cache -> cache, Output -> Result, Simulation -> simulation}],
				{}
			},
			Experiment`Private`resolveReadPlateMethod[mySamples, type, ReplaceRule[Normal@experimentOptionsAssociation, Join[{Cache->cache, Output->{Result, Tests}}]], {Cache -> cache, Output -> {Result, Tests}, Simulation -> simulation}]
		],
		$Failed
	];

	(* If we have more than one allowable preparation method, just choose the first one. Our function returns multiple *)
	(* options so that OptimizeUnitOperations can perform primitive grouping. *)
	resolvedPreparation=If[MatchQ[allowedPreparation, _List],
		First[allowedPreparation],
		allowedPreparation
	];

	(* Resolve our WorkCell option. Do this after resolving the Preparation option, as this is only relevant if the experiment will be performed robotically.*)
	resolvedWorkCell = If[MatchQ[resolvedPreparation, Robotic]&&!MatchQ[type,Object[Protocol,FluorescencePolarizationKinetics]|Object[Protocol,FluorescencePolarization]],
		FirstOrDefault@Experiment`Private`resolveReadPlateWorkCell[experimentFunction,mySamples,ReplaceRule[Normal@experimentOptionsAssociation, {Cache->cache, Preparation->resolvedPreparation}]],
		Null
	];

	(* -- CONFLICTING OPTIONS CHECKS -- *)

	(* Check SamplesInStorageConditions for a conflict *)
	samplesInStorageCondition=Lookup[myExperimentOptions,SamplesInStorageCondition];

	{samplesInStorageError,invalidStorageConditionTest}=Which[
		!gatherTestsQ&&!MatchQ[samplesInStorageCondition,ListableP[Null]],
		{ValidContainerStorageConditionQ[mySamples,samplesInStorageCondition,Output->Result],{}},
		gatherTestsQ&&!MatchQ[samplesInStorageCondition,ListableP[Null]],
		ValidContainerStorageConditionQ[mySamples,samplesInStorageCondition,Output->{Result,Tests}],
		True,{{},{}}
	];

	(* if the test above passes, there's no invalid option, otherwise, SamplesInStorageCondition will be an invalid option *)
	invalidStorageConditionOptions=If[MemberQ[samplesInStorageError,False],
		{SamplesInStorageCondition},
		{}
	];

	(* Check Aliquot and NumberOfReplicates for a conflict *)
	(* We're interpreting N NumberOfReplicates to mean we should read N aliquots of each sample, so Aliquot->False if we're doing replicates *)

	(* Lookup relevant options *)
	{suppliedAliquotBooleans,numberOfReplicates}=Lookup[myExperimentOptions,{Aliquot,NumberOfReplicates}];

	(* Must be aliquoting if we're doing replicates *)
	replicatesError=MemberQ[suppliedAliquotBooleans,False]&&!MatchQ[numberOfReplicates,Null];

	(* Create test *)
	replicatesAliquotTest=If[gatherTestsQ,
		Test["If replicate readings are to be done, the samples may be aliquoted in order to create replicate samples for these readings:",replicatesError,False]
	];

	(* Throw message *)
	If[messagesBoolean&&replicatesError,
		Message[Error::ReplicateAliquotsRequired]
	];

	(* Track invalid option *)
	invalidReplicatesOptions=If[replicatesError,{Aliquot,NumberOfReplicates}];

	(* - Validate the Mode option - *)

	(* If the plate reader and mode were both specified, make sure the requested plate reader supports the requested mode - else check passes automatically *)
	validPlateReaderMode=If[MatchQ[plateReaderModelPacket,PacketP[]],
		MemberQ[Lookup[plateReaderModelPacket,PlateReaderMode],neededMode],
		True
	];

	(* Create Mode test *)
	plateReaderModeTest=If[gatherTestsQ,
		Test["If a plate reader was specified, it is capable of taking measurements in "<>ToString[neededMode]<>" mode:",validPlateReaderMode,True]
	];

	(* Throw Mode message *)
	If[!validPlateReaderMode&&messagesBoolean,
		Message[Error::ModeUnavailable,suppliedPlateReader,neededMode];
	];

	(* Track that this is a hard error. Because Mode is not an option of Polarization experiments, we don't want to put that into the invalid options*)
	invalidModeOptions=If[!validPlateReaderMode,
		If[MatchQ[type,Object[Protocol,FluorescencePolarization]|Object[Protocol,FluorescencePolarizationKinetics]],
			{Instrument},
			{Mode,Instrument}
		],
		{}
	];

	(* - Validate DelayTime and ReadTime - *)
	(* Lookup relevant options, luminescence experiments, ExperimentFluorescenceSpectroscopy and polarization experiments don't have these options so default to Null *)
	{suppliedDelayTime,suppliedReadTime}=Lookup[experimentOptionsAssociation,{DelayTime,ReadTime},Null];

	(* Check if either option is Null, or if either is specified *)
	timeResolvedImplied=UnitsQ[suppliedDelayTime]||UnitsQ[suppliedReadTime];
	missingIntegrationTimes=MatchQ[suppliedDelayTime,Null]||MatchQ[suppliedReadTime,Null];

	(* If any times are specified, make sure we're doing TimeResolvedFluorescence *)
	unneededIntegrationTimes=MatchQ[suppliedMode,Fluorescence]&&timeResolvedImplied;

	(* If no times are specified, make sure we're doing Fluorescence *)
	requiredIntegrationTimes=MatchQ[suppliedMode,TimeResolvedFluorescence]&&missingIntegrationTimes;

	(* Create one test to indicate times are allowed iff Mode->TimeResolvedFluorescence*)
	integrationModeTest=If[gatherTestsQ,
		Test["DelayTime and ReadTime are supplied if Mode is set to TimeResolvedFluorescence and left unspecified otherwise:",unneededIntegrationTimes||requiredIntegrationTimes,False]
	];

	(* Throw messages if we need times or if we're missing them *)
	If[unneededIntegrationTimes&&messagesBoolean,
		Message[Error::IntegrationTimesUnneeded]
	];
	If[requiredIntegrationTimes&&messagesBoolean,
		Message[Error::IntegrationTimesRequired]
	];

	(* If Mode was not specified, make sure we can resolve it sensibly - need both times, or neither *)
	conflictingTimes=MatchQ[{suppliedDelayTime,suppliedReadTime},{Null,UnitsP[]}|{UnitsP[],Null}]&&MatchQ[suppliedMode,Automatic];

	(* Create test *)
	conflictingTimesTest=If[gatherTestsQ,
		Test["DelayTime and ReadTime are both specified or both set to Null:",conflictingTimes,False]
	];

	(* Throw message *)
	If[conflictingTimes&&messagesBoolean,
		Message[Error::IntegrationTimesRequiredTogether]
	];

	(* Track that this is a hard error *)
	(* Our above checks indicate at least one option is invalid, PickList to determine which ones are causing the problem *)
	invalidIntegrationTimeOptions=Which[
		unneededIntegrationTimes,Append[PickList[{DelayTime,ReadTime},{suppliedDelayTime,suppliedReadTime},UnitsP[]],Mode],
		requiredIntegrationTimes,Append[PickList[{DelayTime,ReadTime},{suppliedDelayTime,suppliedReadTime},Null],Mode],
		conflictingTimes,{DelayTime,ReadTime}
	];

	(* If the plate reader and integration times were specified then it must support time-resolved readings *)
	integrationTimesSupported=If[timeResolvedImplied&&MatchQ[plateReaderModelPacket,PacketP[]],
		MemberQ[Lookup[plateReaderModelPacket,PlateReaderMode],TimeResolvedFluorescence],
		True
	];

	(* Create test *)
	integrationTimesSupportedTest=Test["The plate reader being used is capable of time-resolved fluorescence and so it's possible to set the DelayTime and ReadTime:",integrationTimesSupported,True];

	(* Integration times imply the mode, so only throw message if we haven't already complained about the mode *)
	If[!integrationTimesSupported&&validPlateReaderMode&&messagesBoolean,
		Message[Error::IntegrationTimesUnsupported]
	];

	(* Track that this is a hard error *)
	(* If we don't support time-resolved fluorescence then any specified time is invalid *)
	invalidIntegrationPlateReaderOptions=If[!integrationTimesSupported,
		Append[PickList[{DelayTime,ReadTime},{suppliedDelayTime,suppliedReadTime},UnitsP[]],Instrument]
	];

	(* - Validate the Wavelength Selection option - *)
	(* Lookup relevant options, ExperimentFluorescenceSpectroscopy and polarization experiments don't have this option so default to Automatic to skip check *)
	(* Polarization experiments can only be done with PHERAstar FS so the Wavelength selection must be Filters. They are not provided as options in those experiments *)
	suppliedWavelengthSelection=Lookup[experimentOptionsAssociation,WavelengthSelection,Automatic];

	(* == Define Function: wavelengthSelectionPossibleFunction == *)
	(* Check if the requested wavelengthSelection is possible for a given plate reader *)
	wavelengthSelectionPossibleFunction[readerPacket:(Null|PacketP[])]:=If[MatchQ[{readerPacket,suppliedWavelengthSelection},{PacketP[],PlateReaderWavelengthSelectionTypeP}],
		Or[
			MatchQ[suppliedWavelengthSelection,NoFilter],
			MemberQ[Lookup[readerPacket,EmissionFilterTypes],suppliedWavelengthSelection]&&MemberQ[Lookup[readerPacket,ExcitationFilterTypes],suppliedWavelengthSelection]
		],
		True
	];

	(* Check if the requested plate reader supports this type of selection *)
	wavelengthSelectionPossible=wavelengthSelectionPossibleFunction[plateReaderModelPacket];

	(* Create test *)
	wavelengthSelectionPossibleTest=If[gatherTestsQ,
		Test["If a plate reader was specified, it is capable of providing the requested wavelength selection",wavelengthSelectionPossible,True]
	];

	(* Throw message *)
	If[!wavelengthSelectionPossible&&messagesBoolean,
		Message[Error::UnsupportedWavelengthSelection,suppliedWavelengthSelection]
	];

	(* Track that this is a hard error *)
	invalidWavelengthSelectionOptions=If[!wavelengthSelectionPossible,{WavelengthSelection,Instrument}];

	(* - Validate WavelengthSelection works with Mode - *)
	(* We can only use filters with TimeResolvedFluorescence *)
	invalidSelectionForMode=MatchQ[suppliedWavelengthSelection,Monochromators]&&Or[
		MatchQ[suppliedMode,TimeResolvedFluorescence],
		timeResolvedImplied&&!conflictingTimes
	];

	(* Create test *)
	invalidSelectionForModeTest=If[gatherTestsQ,
		Test["If a plate reader was specified, it is capable of providing the requested wavelength selection",invalidSelectionForMode,False]
	];

	(* Throw message *)
	If[invalidSelectionForMode&&messagesBoolean,
		Message[Error::InvalidWavelengthSelection,suppliedWavelengthSelection]
	];

	(* Track that this is a hard error *)
	invalidWavelengthSelectionModeOptions=If[invalidSelectionForMode,WavelengthSelection];

	(* - Validate the EmissionWavelength option - *)
	(* Lookup relevant options *)
	suppliedEmissionWavelength=Lookup[experimentOptionsAssociation,EmissionWavelength];

	(* Get a list of the actual wavelength specified, filtering out Automatics *)
	filteredEmissionWavelengths=Cases[ToList[suppliedEmissionWavelength],DistanceP];

	(* TODO stop hardcoding *)
	filterBandwidth=10 Nanometer;

	(* If user asked for time-resolved fluorescence, or has clearly implied that they want it, then only filters can be used *)
	filtersOnly=MatchQ[suppliedMode,TimeResolvedFluorescence]||(timeResolvedImplied&&!conflictingTimes)||MatchQ[suppliedWavelengthSelection,Filters];


	(* == Define Function: validEmissionWavelengthFunction == *)
	(* If a plate reader was specified, ensures it could provide the requested emission wavelength, else returns True *)
	validEmissionWavelengthFunction[readerPacket:(PacketP[]|Null),emissionWavelengths:{(DistanceP|Automatic|Null)...}]:=Module[{
		emissionWavelengthBooleans,invalidEmissionWavelengths},

		(* Skip this check if our plate reader is invalid since we've complained earlier *)
		If[!validPlateReaderMode,
			Return[True,Module]
		];

		(* Check if each wavelength is valid *)
		emissionWavelengthBooleans=Map[
			Function[{wavelength},
				Which[
					(* Fine if no plate reader is specified *)
					MatchQ[readerPacket,Null],True,

					(* Fine if no wavelength is specified *)
					MatchQ[wavelength,Automatic|Null],True,

					(* Monochromator - check if wavelength is in the range *)
					!filtersOnly&&MemberQ[Lookup[readerPacket,EmissionFilterTypes],Monochromators],Module[{},
						Between[wavelength,Lookup[readerPacket,{MinEmissionWavelength,MaxEmissionWavelength}]]
					],

					(* Filter-based - check EmissionFilters listing to see if the requested value is in there *)
					MemberQ[Lookup[readerPacket,EmissionFilterTypes],Filters],Module[
						{emissionFilterField,structuredEmissionFilters,emissionFilters,wavelengthSupportedBooleans},

						(* Emission filters are listed as {{primary filter, secondary filter}..} to indicate that the two filters appear together in a single optic module *)
						(* 'secondary filter' will be Null if the instrument doesn't use optic modules *)
						(* If running Polarization grab appropriate PolarizationEmissionFilters field *)
						emissionFilterField=If[MatchQ[type,Object[Protocol,FluorescencePolarization]|Object[Protocol,FluorescencePolarizationKinetics]],
							PolarizationEmissionFilters,
							EmissionFilters
						];

						structuredEmissionFilters=Lookup[readerPacket,emissionFilterField];

						(* Get a flat list of all available emission filters *)
						emissionFilters=DeleteCases[Flatten[structuredEmissionFilters,1],Null];

						(* See if our requested wavelength is covered by any of the filters *)
						wavelengthSupportedBooleans=Between[wavelength,{#-filterBandwidth/2,#+filterBandwidth/2}]&/@emissionFilters;

						(* See if the wavelength is covered by at least one of our filters *)
						Or@@wavelengthSupportedBooleans
					],

					(* If the plate reader doesn't have any wavelength information, return False*)
					True,False
				]
			],
			emissionWavelengths
		];

		(* Get a list of the invalid wavelengths *)
		invalidEmissionWavelengths=PickList[emissionWavelengths,emissionWavelengthBooleans,False];

		(* Determine if all the wavelengths are valid *)
		MatchQ[invalidEmissionWavelengths,{}]
	];

	(* Check if all the wavelengths are valid *)
	emissionWavelengthsValid=validEmissionWavelengthFunction[plateReaderModelPacket,filteredEmissionWavelengths];

	(* Create EmissionWavelength test *)
	emissionTest=If[gatherTestsQ,
		If[MatchQ[suppliedPlateReader,Automatic]&&MatchQ[type,Object[Protocol,FluorescencePolarization]|Object[Protocol,FluorescencePolarizationKinetics]],
			Test["If fluorescence polarization experiment is requested, it is capable of supplying all the requested emission wavelengths:",emissionWavelengthsValid,True],
			Test["If a plate reader was specified, it is capable of supplying all the requested emission wavelengths:",emissionWavelengthsValid,True]
		]
	];

	(* Throw EmissionWavelength message *)
	If[!emissionWavelengthsValid&&messagesBoolean,
		If[MatchQ[suppliedPlateReader,Automatic]&&MatchQ[type,Object[Protocol,FluorescencePolarization]|Object[Protocol,FluorescencePolarizationKinetics]],
			(* Because we only support PHERAstar for Polorization experiments and we use the correct instrument for error checking even when the instrument option is set to Automatic, we want to be accurate with the error message here. *)
			Message[Error::EmissionWavelengthUnavailable,suppliedEmissionWavelength,ToString[neededMode]<>" instrument "<>ObjectToString[Model[Instrument,PlateReader,"PHERAstar FS"],Cache->cache]],
			Message[Error::EmissionWavelengthUnavailable,suppliedEmissionWavelength,suppliedPlateReader]
		]
	];

	(* Track that this is a hard error *)
	invalidEmissionWavelengthOption=Which[
		!emissionWavelengthsValid&&MatchQ[suppliedPlateReader,Automatic],
		{EmissionWavelength},
		!emissionWavelengthsValid,
		{EmissionWavelength,Instrument},
		True,{}
	];

	(* - Validate the ExcitationWavelength option - *)
	(* Lookup relevant option - Since luminescence experiments don't use this, default to Automatic so all our validity checks will still pass *)
	suppliedExcitationWavelength=Lookup[experimentOptionsAssociation,ExcitationWavelength,Automatic];

	(* Get a list of the actual wavelength specified, filtering out Automatics *)
	filteredExcitationWavelengths=Cases[ToList[suppliedExcitationWavelength],DistanceP];

	(* == Define Function: validExcitationWavelengthFunction == *)
	(* If a plate reader was specified, ensures it could provide the requested excitation wavelength, else returns True *)
	validExcitationWavelengthFunction[readerPacket:(PacketP[]|Null),excitationWavelengths:{(DistanceP|Automatic)...}]:=Module[{
		excitationWavelengthBooleans,invalidExcitationWavelengths},

		(*Skip this check if our plate reader is invalid since we've complained earlier*)
		If[!validPlateReaderMode, Return[True, Module]];

		(* Check if each wavelength is valid *)
		excitationWavelengthBooleans=Map[
			Function[{wavelength},
				Which[
					MatchQ[readerPacket,Null],True,

					MatchQ[wavelength,Automatic],True,

					(* Monochromator; is it in the range *)
					!filtersOnly&&MemberQ[Lookup[readerPacket,ExcitationFilterTypes],Monochromators],Between[wavelength,Lookup[readerPacket,{MinExcitationWavelength,MaxExcitationWavelength}]],

					(* Optic module or filter instrument; check EmissionFilters listing to see if the requested value is in there *)
					MemberQ[Lookup[readerPacket,ExcitationFilterTypes],Filters],Module[
						{excitationFilterField,excitationFilters,wavelengthSupportedBooleans},

						(* If running Polarization grab appropriate PolarizationExcitationFilters field *)
						excitationFilterField=If[MatchQ[type,Object[Protocol,FluorescencePolarization]|Object[Protocol,FluorescencePolarizationKinetics]],
							PolarizationExcitationFilters,
							ExcitationFilters
						];

						(* Get a flat list of all available emission filters *)
						excitationFilters=Lookup[readerPacket,excitationFilterField];

						(* See if our requested wavelength is covered by any of the filters *)
						wavelengthSupportedBooleans=Between[wavelength,{#-filterBandwidth/2,#+filterBandwidth/2}]&/@excitationFilters;

						(* See if the wavelength is covered by at least one of our filters *)
						Or@@wavelengthSupportedBooleans
					],

					(* If the plate reader doesn't have any wavelength information, return False*)
					True,False
				]
			],
			excitationWavelengths
		];

		(* Get a list of the invalid wavelengths *)
		invalidExcitationWavelengths=PickList[excitationWavelengths,excitationWavelengthBooleans,False];

		(* Determine if all the wavelengths are valid *)
		MatchQ[invalidExcitationWavelengths,{}]
	];

	(* Check if all the wavelengths are valid *)
	excitationWavelengthsValid=validExcitationWavelengthFunction[plateReaderModelPacket,filteredExcitationWavelengths];

	(* Create ExcitationWavelength test for fluorescence experiments *)
	excitationTest=If[gatherTestsQ&&MatchQ[measurementType,Fluorescence],
		If[MatchQ[suppliedPlateReader,Automatic]&&MatchQ[type,Object[Protocol,FluorescencePolarization]|Object[Protocol,FluorescencePolarizationKinetics]],
			Test["If fluorescence polarization experiment is requested, it is capable of supplying all the requested excitation wavelengths:",excitationWavelengthsValid,True],
			Test["If a plate reader was specified, it is capable of supplying all the requested excitation wavelengths:",excitationWavelengthsValid,True]
		]
	];

	(* Throw ExcitationWavelength message *)
	If[!excitationWavelengthsValid&&messagesBoolean,
		If[MatchQ[suppliedPlateReader,Automatic]&&MatchQ[type,Object[Protocol,FluorescencePolarization]|Object[Protocol,FluorescencePolarizationKinetics]],
			(* Because we only support PHERAstar for Polorization experiments and we use the correct instrument for error checking even when the instrument option is set to Automatic, we want to be accurate with the error message here. *)
			Message[Error::ExcitationWavelengthUnavailable,suppliedExcitationWavelength,ToString[neededMode]<>" instrument "<>ObjectToString[Model[Instrument,PlateReader,"PHERAstar FS"],Cache->cache]],
			Message[Error::ExcitationWavelengthUnavailable,suppliedExcitationWavelength,suppliedPlateReader]
		]
	];

	(* Track that this is a hard error *)
	invalidExcitationWavelengthOption=Which[
		!excitationWavelengthsValid&&MatchQ[suppliedPlateReader,Automatic],
		{ExcitationWavelength},
		!excitationWavelengthsValid,
		{ExcitationWavelength,Instrument},
		True,{}
	];

	{suppliedDualEmissionWavelengths,suppliedDualEmissionGains}=
		ToList/@Lookup[experimentOptionsAssociation,{DualEmissionWavelength,DualEmissionGain},Null];

	(* If either secondary option is set, user is asking for dual emission *)
	dualEmissionRequested=MemberQ[suppliedDualEmissionWavelengths,DistanceP]||MemberQ[suppliedDualEmissionGains,UnitsP[]];

	(* Dual emission is only supported by the PHERAstar - okay if they requested this, or left Automatic (in which case plateReaderModelObject will be Null) *)
	validDualEmission=!dualEmissionRequested||(MatchQ[plateReaderModelObject,Null|Model[Instrument, PlateReader, "id:01G6nvkKr3o7"]]&&dualEmissionRequested);

	(* Create dual emission test *)
	dualEmissionTest=If[gatherTestsQ,
		Test["If DualEmissionWavelength or DualEmissionGain are set and a plate reader is requested, it support dual emission:",validDualEmission,True]
	];

	(* Throw dual emission message *)
	If[!validDualEmission&&messagesBoolean,
		Message[Error::DualEmissionUnavailable]
	];

	(* Track that this is a hard error - include only the specified options in our invalid list *)
	invalidDualEmissionOptions=If[!validDualEmission,
		Join[{Instrument},
			PickList[{DualEmissionWavelength,DualEmissionGain},{suppliedDualEmissionWavelengths,suppliedDualEmissionGains},_?(MemberQ[#,UnitsP[]]&)]
		]
	];

	(* - Validate the DualEmissionWavelength and DualEmissionGain options - *)

	(* Determine if the dual wavelength can be achieved *)
	filteredDualEmissionWavelengths=Cases[suppliedDualEmissionWavelengths,DistanceP];
	dualEmissionWavelengthsValid=validEmissionWavelengthFunction[plateReaderModelPacket,filteredDualEmissionWavelengths];

	(* Create test checking the wavelength can be achieved *)
	dualEmissionWavelengthTest=If[gatherTestsQ,
		If[MatchQ[suppliedPlateReader,Automatic]&&MatchQ[type,Object[Protocol,FluorescencePolarization]|Object[Protocol,FluorescencePolarizationKinetics]],
			Test["If fluorescence polarization experiment is requested, it is capable of supplying all the requested dual emission wavelengths:",dualEmissionWavelengthsValid&&validDualEmission,True],
			Test["If a plate reader was specified, it is capable of supplying all the requested dual emission wavelengths:",dualEmissionWavelengthsValid&&validDualEmission,True]
		]
	];

	(* Only throw message that the wavelength is unsupported if we haven't already indicated dual emission is unavailable for the given plate reader *)
	If[!dualEmissionWavelengthsValid&&validDualEmission&&messagesBoolean,
		If[MatchQ[suppliedPlateReader,Automatic]&&MatchQ[type,Object[Protocol,FluorescencePolarization]|Object[Protocol,FluorescencePolarizationKinetics]],
			(* Because we only support PHERAstar for Polorization experiments and we use the correct instrument for error checking even when the instrument option is set to Automatic, we want to be accurate with the error message here. *)
			Message[Error::DualEmissionWavelengthUnavailable,ToString[neededMode]<>" instrument "<>ObjectToString[Model[Instrument,PlateReader,"PHERAstar FS"],Cache->cache]],
			Message[Error::DualEmissionWavelengthUnavailable,suppliedPlateReader]
		]
	];

	invalidDualEmissionWavelengthOptions=Which[
		!dualEmissionWavelengthsValid&&MatchQ[suppliedPlateReader,Automatic],
		{DualEmissionWavelength},
		!dualEmissionWavelengthsValid,
		{DualEmissionWavelength,Instrument},
		True,{}
	];

	(* Make sure that if one dual emission value is specified, the other has not been set to Null *)
	unneededDualEmissionGain=And@@MapThread[
		MatchQ[#1,Null]&&MatchQ[#2,UnitsP[]]&,
		{suppliedDualEmissionWavelengths,suppliedDualEmissionGains}
	];
	missingDualEmissionGain=And@@MapThread[
		MatchQ[#1,DistanceP]&&MatchQ[#2,Null]&,
		{suppliedDualEmissionWavelengths,suppliedDualEmissionGains}
	];

	(* Create tests for conflicting secondary gain/wavelength options *)
	missingDualEmissionGainTest=If[gatherTestsQ,
		Test["If a dual emission wavelength is specified, the corresponding gain is not set to Null:",missingDualEmissionGain,False]
	];
	unneededDualEmissionGainTest=If[gatherTestsQ,
		Test["If a dual emission gain is specified, the corresponding wavelength is not set to Null:",unneededDualEmissionGain,False]
	];

	(* Throw messages for conflicting secondary gain/wavelength options *)
	If[missingDualEmissionGain&&messagesBoolean,
		Message[Error::DualEmissionGainRequired]
	];
	If[unneededDualEmissionGain&&messagesBoolean,
		Message[Error::DualEmissionGainUnneeded]
	];

	(* Track that this is a hard error *)
	invalidDualEmissionComboOptions=If[missingDualEmissionGain||unneededDualEmissionGain,
		{DualEmissionGain,DualEmissionWavelength}
	];

	(* - Validate the combination of wavelengths - *)

	(* == Define Function:  opticModuleForWavelengthFunction == *)
	opticModuleForWavelengthFunction[emissionFilterTuples_,excitationFilters_,emissionWavelengths_,excitationWavelength_]:=MapThread[
		Function[{emissionFilters,excitationFilter},
			Module[{emissionPattern,emissionWavelengthsPossible,excitationPattern,excitationWavelengthPossible},

				(* Create a pattern describing allowed wavelengths - any emission within the bandwidth of any of our filters is okay *)
				emissionPattern=Apply[Alternatives,RangeP[#-filterBandwidth/2,#+filterBandwidth/2]&/@emissionFilters];

				(* Check if each emission wavelength can be achieved - And@@{} -> True *)
				emissionWavelengthsPossible=Apply[And,MatchQ[#,emissionPattern]&/@emissionWavelengths];

				(* Create a pattern describing allowed wavelengths - any excitation within the bandwidth of any of our filters is okay *)
				excitationPattern=RangeP[excitationFilter-filterBandwidth/2,excitationFilter+filterBandwidth/2];

				(* Check if the excitation wavelengths can be achieved *)
				excitationWavelengthPossible=MatchQ[excitationWavelength,Automatic|excitationPattern];

				(* All wavelengths must be possible with the same optic module *)
				If[emissionWavelengthsPossible&&excitationWavelengthPossible,
					{emissionFilters,excitationFilter},
					Nothing
				]
			]
		],
		{emissionFilterTuples,excitationFilters}
	];

	(* == Define Function: validWavelengthCombinationFunction == *)
	(* Validate that there's an optical module that can provide the requested wavelengths *)
	validWavelengthCombinationFunction[readerPacket_,emissionWavelengths_,dualEmissionWavelengths_,excitationWavelengths_]:=If[
		MatchQ[plateReaderModelPacket,PacketP[]]&&!MatchQ[suppliedPlateReader,Automatic]&&MatchQ[Lookup[plateReaderModelPacket,OpticModules],{ObjectP[Model[Part,OpticModule]]..}],
		Module[{emissionFilterTuples,excitationFilters,triosSupported},

			(* Possible filters made available by all the optic modules *)
			{emissionFilterTuples,excitationFilters}=Lookup[readerPacket,{EmissionFilters,ExcitationFilters}];

			(* For each combo of emission-dual emission-excitation, see if any of the optic modules can provide that combo *)
			triosSupported=MapThread[
				Function[{requestedEmissionWavelength,requestedDualEmissionWavelength,requestedExcitationWavelength},
					Module[{requestedEmissionWavelengths,wavelengthsPossible},
						requestedEmissionWavelengths=Cases[{requestedEmissionWavelength,requestedDualEmissionWavelength},DistanceP];

						(* For each possible set of emission/excitation filters provided by an optic module, check to see if the current combination of wavelengths are possible *)
						wavelengthsPossible=!MatchQ[opticModuleForWavelengthFunction[emissionFilterTuples,excitationFilters,requestedEmissionWavelengths,requestedExcitationWavelength],{}];

						(* Do any of the optic modules supply the requested wavelengths *)
						Or@@wavelengthsPossible
					]
				],
				{emissionWavelengths,dualEmissionWavelengths,excitationWavelengths}
			];

			(**)
			And@@triosSupported
		],
		(* We don't know the plate reader, or modules aren't used, so the combo is fine *)
		True
	];

	(* For each set of wavelengths, validate they are supported *)
	validWavelengthCombination=validWavelengthCombinationFunction[plateReaderModelPacket,ToList[suppliedEmissionWavelength],suppliedDualEmissionWavelengths,ToList[suppliedExcitationWavelength]];

	(* Create test *)
	validWavelengthCombinationTest=If[gatherTestsQ,
		Test["The requested combination of wavelengths is possible given the available optic modules:",validWavelengthCombination,True]
	];

	(* Throw message only if we haven't already indicated that one of the wavelengths isn't possible *)
	If[!validWavelengthCombination&&emissionWavelengthsValid&&excitationWavelengthsValid&&dualEmissionWavelengthsValid&&messagesBoolean,
		Message[Error::WavelengthCombinationUnavailable,suppliedPlateReader]
	];

	(* Track that this is a hard error *)
	(* Again, if we have already indicated one of the wavelengths is invalid don't include the others here too since that's the real problem *)
	invalidWavelengthComboOptions=If[!validWavelengthCombination&&emissionWavelengthsValid&&excitationWavelengthsValid&&dualEmissionWavelengthsValid,
		{EmissionWavelength,ExcitationWavelength,DualEmissionWavelength}
	];

	(* -- Validate Sampling options-- *)
	(* - Check if SamplingDistance, SamplingDimension and SamplingPattern are compatible - *)
	(* Get requested options *)
	{suppliedSamplingPattern,suppliedSamplingDistance,suppliedSamplingDimension}=Lookup[experimentOptionsAssociation,{SamplingPattern,SamplingDistance,SamplingDimension},Null];

	(* Determine if the user set anything suggesting they actually want to do sampling *)
	samplingRequested=MemberQ[{suppliedSamplingPattern,suppliedSamplingDistance,suppliedSamplingDimension},Except[Automatic]];

	(* SamplingDistance must be Null if using Center, can't be Null if using any other pattern *)
	(* SamplingDimension only applies to Matrix scans *)
	(* If at least 2 options are left Automatic then we can resolve the other appropriately *)
	validSamplingCombo=MatchQ[
		{suppliedSamplingPattern,suppliedSamplingDistance,suppliedSamplingDimension},
		Alternatives[
			{Center,Null|Automatic,Null|Automatic},
			{Matrix,DistanceP|Automatic,Automatic|_Integer},
			{Except[Center|Matrix,PlateReaderSamplingP],DistanceP,Automatic|Null},
			{Automatic,DistanceP,_Integer},
			{Automatic,DistanceP,Null},
			_?(Length[Cases[#,Automatic]]>=2&)
		]
	];

	(* Create test *)
	validSamplingComboTest=If[gatherTestsQ,
		Test["A SamplingDistance is provided if and only if the SamplingPattern is set to Matrix, Ring or Spiral and SamplingDimension is only set if using a Matrix sampling pattern:",validSamplingCombo,True]
	];

	(* Throw message only if we haven't already indicated that one of the wavelengths isn't possible *)
	If[!validSamplingCombo&&messagesBoolean,
		Message[Error::SamplingCombinationUnavailable]
	];

	(* Check if sampling patterns are supported by the requested instrument *)

	(* SamplingPattern *)
	(* If SamplingDistance is set to a value resolve to Ring somewhat arbitrarily - this is the first thing in BMG's dropdown *)
	resolvedSamplingPattern=Switch[{suppliedSamplingPattern,suppliedSamplingDistance,suppliedSamplingDimension,type},
		{Except[Automatic],_,_,_},suppliedSamplingPattern,
		{_,_,_Integer,Except[Object[Protocol,FluorescenceSpectroscopy]|Object[Protocol,ExperimentLuminescenceSpectroscopy]]},Matrix,
		{_,DistanceP[],Null|Automatic},Ring,
		_,Center
	];

	modeForSampling=If[MatchQ[{type,suppliedMode},{Object[Protocol,FluorescenceKinetics],TimeResolvedFluorescence}],
		TimeResolvedFluorescenceKinetics,
		neededMode
	];

	instrumentSupportedSampling=If[MatchQ[plateReaderModelPacket,Null],
		True,
		MemberQ[Lookup[Replace[Lookup[plateReaderModelPacket,SamplingPatterns],Null-><||>],modeForSampling],resolvedSamplingPattern]
	];

	(* Create test *)
	validSamplingInstrumentTest=If[gatherTestsQ,
		Test["If an instrument is provided and a sampling pattern is requested, the instrument can support that sampling pattern:",instrumentSupportedSampling,True]
	];

	If[!instrumentSupportedSampling&&messagesBoolean&&samplingRequested,
		Message[Error::UnsupportedInstrumentSamplingPattern,modeForSampling]
	];

	(* Check if sampling patterns are supported for the current type *)
	(* Plate reader models have a named single indicating what they can do today *)
	anyInstrumentSupportsSampling=And[
		MemberQ[Flatten[Lookup[Replace[Lookup[allPlateReaderModelPackets,SamplingPatterns],Null-><||>],modeForSampling],1],resolvedSamplingPattern]
	];

	(* Create test *)
	validSamplingModeTest=If[gatherTestsQ,
		Test["The sampling pattern requested is supported for a "<>ToString[modeForSampling]<> " protocol.",anyInstrumentSupportsSampling,True]
	];

	(* Throw message if there are no instruments that can do the requested sampling pattern *)
	(* Only complain if the plate reader is even appropriate - if not they'll have already received a broader error *)
	If[!anyInstrumentSupportsSampling&&!instrumentSupportedSampling&&samplingRequested&&messagesBoolean,
		Message[Error::UnsupportedSamplingPattern,modeForSampling,resolvedSamplingPattern]
	];

	invalidSamplingOptions=Which[
		!samplingRequested,Null,
		!instrumentSupportedSampling,{SamplingPattern,SamplingDistance,SamplingDimension,Instrument},
		!validSamplingCombo,{SamplingPattern,SamplingDistance,SamplingDimension},
		!anyInstrumentSupportsSampling,{SamplingPattern},
		True,Null
	];

	(* -- Check if EmissionWavelength > ExcitationWavelength -- *)
	wavelengthOrderingOk=Or[
		(* Ordering doesn't apply for FluorescenceSpec *)
		MatchQ[type,Object[Protocol,FluorescenceSpectroscopy]],
		MatchQ[measurementType,Luminescence],
		And@@MapThread[
			(MemberQ[{#1,#2},Automatic]||#1>#2)&,
			{ToList[suppliedEmissionWavelength],ToList[suppliedExcitationWavelength]}
		]
	];

	(* Create test *)
	wavelengthOrderingTest=If[gatherTestsQ&&MatchQ[measurementType,Fluorescence],
		Warning["Each emission wavelength is larger than the corresponding excitation wavelength:",wavelengthOrderingOk,True]
	];

	(* Throw message *)
	If[!wavelengthOrderingOk&&messagesBoolean,
		Message[Warning::WavelengthsSwapped]
	];

	(* - Validate the EmissionWavelength and WavelengthSelection - *)

	(* If emission wavelengths contains any distances but sets WavelengthSelection->NoFilter, must error *)
	wavelengthSelectionRequired=(MemberQ[filteredEmissionWavelengths,DistanceP]||MemberQ[filteredDualEmissionWavelengths,DistanceP])&&MatchQ[suppliedWavelengthSelection,NoFilter];

	(* If emission wavelengths contains only NoFilter and user asks for WavelengthSelection->Filters/Monochromotors must error *)
	wavelengthSelectionUnused=MatchQ[ToList[suppliedEmissionWavelength],{NoFilter}]&&!MatchQ[suppliedWavelengthSelection,NoFilter|Automatic];

	(* Create tests *)
	wavelengthSelectionRequiredTest=If[gatherTestsQ&&MatchQ[measurementType,Luminescence],
		Test["WavelengthSelection is set to Filters or Monochromators when specific emission wavelengths are requested:",wavelengthSelectionRequired,False]
	];
	wavelengthSelectionUnusedTest=If[gatherTestsQ&&MatchQ[measurementType,Luminescence],
		Test["If EmissionWavelength->NoFilter, WavelengthSelection must also be set to NoFilter.",wavelengthSelectionUnused,False]
	];

	(* Throw messages *)
	If[wavelengthSelectionRequired&&messagesBoolean,
		Message[Error::WavelengthSelectionRequired]
	];
	If[wavelengthSelectionUnused&&messagesBoolean,
		Message[Error::WavelengthSelectionUnused]
	];

	(* Track invalid option *)
	invalidWavelengthSelectionOption=If[wavelengthSelectionRequired||wavelengthSelectionUnused,WavelengthSelection];

	(* - Determine how many multichromatics are supported - *)
	numberOfMultichromaticsLookup=Association[
		Model[Instrument,PlateReader,"id:01G6nvkKr3o7"]->5,
		Model[Instrument,PlateReader,"id:mnk9jO3qDzpY"]->8,
		Model[Instrument,PlateReader,"id:E8zoYvNkmwKw"]->5
	];

	(* Determine how many multichromatics our plate reader can read *)
	numberOfMultichromaticsAllowed=Lookup[numberOfMultichromaticsLookup,plateReaderModelObject,Null];

	(* Check that the requested number isn't greater than the number available *)
	requestedMultichromatics=Length[ToList[suppliedEmissionWavelength]];
	sufficientMultichromatics=MatchQ[numberOfMultichromaticsAllowed,Null]||requestedMultichromatics<=numberOfMultichromaticsAllowed;

	(* Create test *)
	multichromaticsTest=If[gatherTestsQ,
		Test["The instrument can read all the requested emission/excitation wavelengths in one run:",sufficientMultichromatics,True]
	];

	(* Throw message *)
	If[!sufficientMultichromatics&&messagesBoolean,
		Message[Error::MaxWavelengthsExceeded,numberOfMultichromaticsAllowed,requestedMultichromatics]
	];

	(* Track that this is a hard error *)
	invalidWavelengthNumberOptions=If[!sufficientMultichromatics,
		{EmissionWavelength,ExcitationWavelength,DualEmissionWavelength}
	];

	(* - Validate the Gain/DualEmissionGain options - *)

	(* Lookup relevant options *)
	(* ExperimentFluorescenceSpectroscopy uses EmissionScanGain/ExcitationScanGain *)
	(* ExperimentLuminescenceIntensity,ExperimentFluorescenceIntensity, ExperimentLuminescenceKinetics and ExperimentFluorescenceKinetics use Gain - index matched to EmissionWavelengths *)
	(* ExperimentLuminescenceSpectroscopy uses Gain but it's singular *)

	suppliedGains=ToList[Lookup[experimentOptionsAssociation,Gain,Automatic]];
	{suppliedExcitationScanGain,suppliedEmissionScanGain}=Lookup[experimentOptionsAssociation,{ExcitationScanGain,EmissionScanGain},Automatic];

	(* Okay if both gains aren't set. If they are both are set, then units must match *)
	compatibleGains=And@@MapThread[
		(!MatchQ[{#1,#2},{UnitsP[]..}]||CompatibleUnitQ[#1,#2])&,
		{suppliedGains,suppliedDualEmissionGains}
	];

	(* Create gain test *)
	compatibleGainsTests=If[gatherTestsQ,
		Test["If dual emission gain is being set its units match those of the gain:",compatibleGains,True]
	];

	(* Throw gain message *)
	If[!compatibleGains&&messagesBoolean,
		Message[Error::IncompatibleGains,suppliedGains,suppliedDualEmissionGains]
	];

	(* Track that this is a hard error *)
	invalidGainOptions=If[!compatibleGains,
		{Gain,DualEmissionGain}
	];

	(* - Check we can do a FullPlate scan - *)

	(* Track which modes don't allow a FullPlate scan *)
	(* FP and FPK exclude FullPlate from the option pattern so this check should never be hit for them *)
	noFullPlateModes={
		FluorescencePolarizationKinetics,
		FluorescencePolarization
	};

	(* If AdjustmentSample is supplied as a single {index, sample} pair, ToList won't be able to correct its format *)
	suppliedAdjustmentSample=If[MatchQ[Lookup[experimentOptionsAssociation,AdjustmentSample], {_Integer, ObjectP[]}],
		{Lookup[experimentOptionsAssociation,AdjustmentSample]},
		ToList[Lookup[experimentOptionsAssociation,AdjustmentSample]]
	];

	invalidFullPlateMode=MemberQ[noFullPlateModes,neededMode]&&MemberQ[suppliedAdjustmentSample,FullPlate];

	(* Create test *)
	fullPlateScanTest=If[gatherTestsQ,
		Test["If using"<>ToString[neededMode]<>" FullPlate is not specified:",invalidFullPlateMode,False]
	];

	(* Throw message *)
	If[invalidFullPlateMode&&messagesBoolean,
		Message[Error::FullPlateUnsupported,neededMode]
	];

	(* Track that this is a hard error *)
	invalidFullPlateModeOptions=If[invalidFullPlateMode,
		{AdjustmentSample}
	];

	(* - Validate the FocalHeight option - *)
	(* Lookup relevant options *)
	suppliedFocalHeight=ToList[Lookup[experimentOptionsAssociation,FocalHeight]];

	(* Determine if the user wants to manipulate the focal height *)
	focalHeightRequested=MemberQ[suppliedFocalHeight,DistanceP|Auto];

	(* We only allow one non-Null, non-Automatic entry of FocalHeight *)
	multipleFocalHeightRequested = Length[DeleteDuplicates[DeleteCases[suppliedFocalHeight, Null|Automatic]]]>1 || Count[suppliedFocalHeight, Auto]>1;

	(* Focal height can only be set if we're not using the Omega (has a fixed focal height) *)
	unneededFocalHeight=focalHeightRequested&&MatchQ[plateReaderModelObject,Model[Instrument,PlateReader,"id:mnk9jO3qDzpY"]];

	(* If we're not using the Omega, we need a focal height *)
	requiredFocalHeight=MemberQ[suppliedFocalHeight,Null]&&!MatchQ[plateReaderModelObject,Automatic|Model[Instrument,PlateReader,"id:mnk9jO3qDzpY"]];

	(* Create FocalHeight test *)

	multipleFocalHeightTest = If[gatherTestsQ,
		Test["FocalHeight was set to Auto or specific distance for at most one emission wavelength:", multipleFocalHeightRequested, False];
	];

	unneededFocalHeightTest=If[gatherTestsQ,
		Test["If a plate reader was specified, it is capable of setting the value requested in the FocalHeight option:",unneededFocalHeight,False]
	];

	requiredFocalHeightTest=If[gatherTestsQ,
		Test["A focal height is provided if the plate reader does not use a fixed height:",requiredFocalHeight,False]
	];

	(* Throw FocalHeight messages *)
	If[multipleFocalHeightRequested&&messagesBoolean,
		Message[Error::MultipleFocalHeightsRequested, suppliedFocalHeight]
	];
	If[unneededFocalHeight&&messagesBoolean,
		Message[Error::FocalHeightUnavailable,suppliedPlateReader]
	];
	If[requiredFocalHeight&&messagesBoolean,
		If[MatchQ[suppliedPlateReader,Automatic]&&MatchQ[type,Object[Protocol,FluorescencePolarization]|Object[Protocol,FluorescencePolarizationKinetics]],
			(* Because we only support PHERAstar for Polorization experiments and we use the correct instrument for error checking even when the instrument option is set to Automatic, we want to be accurate with the error message here. *)
			Message[Error::FocalHeightRequired,ToString[neededMode]<>" instrument "<>ObjectToString[Model[Instrument,PlateReader,"PHERAstar FS"],Cache->cache]],
			Message[Error::FocalHeightRequired,suppliedPlateReader]
		]
	];

	(* Track that this is a hard error *)
	invalidFocalHeightOptions=Which[
		(requiredFocalHeight&&MatchQ[suppliedPlateReader,Automatic])||multipleFocalHeightRequested,
		{FocalHeight},
		unneededFocalHeight||requiredFocalHeight,
		{FocalHeight,Instrument},
		True,{}
	];

	{adjustmentSampleIndex,adjustmentSampleValue}=Transpose[Map[
		Switch[#,
			ObjectP[],{Automatic,#},
			{_Integer,ObjectP[]},#,
			FullPlate,{Null,FullPlate},
			(* Null | Automatic *)
			_,{#,#}
		]&,
		suppliedAdjustmentSample
	]];

	(* Can only determine focal height automatically if there's an adjustment sample object (i.e. FullPlate is not possible) *)
	invalidFocalHeightAdjustmentSample=MapThread[MatchQ[#1,Auto]&&MatchQ[#2,FullPlate]&, {suppliedFocalHeight, adjustmentSampleValue}];

	(* Create test for FocalHeight x AdjustmentSample *)
	focalHeightAdjustmentTest=If[gatherTestsQ,
		Test["For each FocalHeight value set to Auto, a sample is provided for AdjustmentSample:", invalidFocalHeightAdjustmentSample, {False..}]
	];

	(* Throw message *)
	(* If we've already yelled about FocalPlate being entirely unavailable don't give the more specific message here *)
	If[MemberQ[invalidFocalHeightAdjustmentSample, True]&&!invalidFullPlateMode&&messagesBoolean,
		Message[Error::FocalHeightAdjustmentSampleRequired]
	];

	(* Track that this is a hard error *)
	invalidFocalHeightAdjustmentSampleOptions=If[MemberQ[invalidFocalHeightAdjustmentSample, True],
		{FocalHeight,AdjustmentSample}
	];

	(* -- Validate the AdjustmentSample option -- *)

	(* - Member of input sample - *)
	(* If a sample is specified, it must be a member of the input samples *)


	inputSampleObjects=Download[mySamples,Object,Cache->cache,Simulation->updatedSimulation];

	validAdjustmentSample=Or[
		MatchQ[#,Null|Automatic|FullPlate],
		MemberQ[inputSampleObjects,Download[#,Object]]
	]&/@adjustmentSampleValue;

	(* - Non Ambiguous - *)
	adjustmentSampleAppearances=Lookup[Counts[inputSampleObjects],Download[#,Object],Null]&/@adjustmentSampleValue;

	(* If adjustment sample is given multiple times, must supply an index *)
	ambiguousAdjustmentSample=Or@@MapThread[
		MatchQ[#1,ObjectP[]]&&#2>1&&!IntegerQ[#3]&,
		{adjustmentSampleValue, adjustmentSampleAppearances, adjustmentSampleIndex}
	];

	(* - Valid Index - *)
	validAdjustmentIndex=And@@MapThread[!IntegerQ[#1]||#2>=#1&, {adjustmentSampleIndex, adjustmentSampleAppearances}];

	(* Determine if user explicitly requested that we make adjustments *)
	adjusting = MapThread[
		Or[
			MatchQ[#1, Auto],
			MatchQ[type,Object[Protocol,FluorescenceIntensity]|Object[Protocol,FluorescenceKinetics]|Object[Protocol,FluorescencePolarization]|Object[Protocol,FluorescencePolarizationKinetics]|Object[Protocol,LuminescenceIntensity]|Object[Protocol,LuminescenceKinetics]]&&MemberQ[Flatten[{#2, #3}],PercentP],
			MatchQ[type,Object[Protocol,FluorescenceSpectroscopy]]&&MemberQ[{suppliedExcitationScanGain,suppliedEmissionScanGain},{PercentP..}],
			MatchQ[type,Object[Protocol,LuminescenceSpectroscopy]]&&MemberQ[suppliedGains,{PercentP..}]
		]&,
		{suppliedFocalHeight, suppliedGains, suppliedDualEmissionGains}
	];
	
	adjustmentSampleMissing=Or@@MapThread[#1&&MatchQ[#2, Null]&, {adjusting, adjustmentSampleValue}];

	(* == Define Function: unusedAdjustmentSampleFunction == *)
	(* It user sets an adjustment sample, but also sets the gains and the focal height (or isn't using these values), then there's nothing to adjust *)
	unusedAdjustmentSampleFunction[readerObject:Null|ObjectP[Model]]:=And[
		(Or@@MapThread[MatchQ[{#1, #2}, {DistanceP | Null, ObjectP[]|FullPlate}]&,{suppliedFocalHeight, adjustmentSampleValue}]||(MemberQ[suppliedFocalHeight, Automatic]&&MatchQ[readerObject,Model[Instrument, PlateReader, "id:mnk9jO3qDzpY"]])),
		(* If the user hasn't tried to set any percentages, but has set at least on of the gains to a voltage, then we'll want to resolve the other to a voltage and so we need to complain *)
		(* If they've set a percentage and a voltage they'll get the IncompatibleGains message *)
		Or[
			MatchQ[type,Object[Protocol,FluorescenceIntensity]|Object[Protocol,FluorescenceKinetics]|Object[Protocol,FluorescencePolarization]|Object[Protocol,FluorescencePolarizationKinetics]|Object[Protocol,LuminescenceIntensity]|Object[Protocol,LuminescenceKinetics]]&&And@@MapThread[
				(MatchQ[{#1, #2, #3},{VoltageP,VoltageP|Null|Automatic,ObjectP[]|FullPlate}]||MatchQ[{#1, #2, #3},{Automatic,VoltageP,ObjectP[]|FullPlate}])&,
				{suppliedGains,suppliedDualEmissionGains, adjustmentSampleValue}
			],
			MatchQ[type,Object[Protocol,FluorescenceSpectroscopy]]&&Module[{scans},
				(* Determine the scans we're going to be doing. If all their gains are voltages we need to throw an error *)
				scans=ToList[resolveSpectralScan[experimentOptionsAssociation]];
				relevantGains={
					If[MemberQ[scans,Excitation],suppliedExcitationScanGain,Nothing],
					If[MemberQ[scans,Emission],suppliedEmissionScanGain,Nothing]
				};
				MatchQ[relevantGains,{VoltageP..}] && MemberQ[adjustmentSampleValue,ObjectP[]|FullPlate]
			],
			MatchQ[type,Object[Protocol,LuminescenceSpectroscopy]]&&MatchQ[suppliedGains,{VoltageP..}]&&MemberQ[adjustmentSampleValue,ObjectP[]|FullPlate]
		]
	];


	unusedAdjustmentSample=unusedAdjustmentSampleFunction[plateReaderModelObject];

	(* - Create tests for all adjustment checks -*)
	adjustmentTest=If[gatherTestsQ,
		Module[{failingOptions, passingOptions},
			passingOptions = PickList[suppliedAdjustmentSample, validAdjustmentSample, True];
			failingOptions = PickList[suppliedAdjustmentSample, validAdjustmentSample, False];
			If[Length[failingOptions] == 0,
				Test["If AdjustmentSample objects were specified, they are all members of the input samples sent to the experiment:",True,True],
				Test["The AdjustmentSamples: "<>ObjectToString[failingOptions]<>", are members of the input samples sent to the experiment:",True,False]
			]
		]
	];

	adjustmentAmbiguousTest=If[gatherTestsQ,
		Warning["If AdjustmentSample was specified, it's clear which aliquot of the sample is to be used:",ambiguousAdjustmentSample,False]
	];

	adjustmentIndexTest=If[gatherTestsQ,
		Test["If AdjustmentSample was specified with an index N, the sample appears at least N times:",validAdjustmentIndex,True]
	];

	requiredAdjustmentTest=If[gatherTestsQ,
		Test["AdjustmentSample must be specified if Gain, DualEmissionGain or FocalHeight is to be determined by the plate reader:",adjustmentSampleMissing,False]
	];

	unusedAdjustmentTest=If[gatherTestsQ,
		Test["AdjustmentSample is only specified if Gain, DualEmissionGain or FocalHeight is to be determined by the plate reader:",unusedAdjustmentSample,False]
	];

	(* Throw messages for all adjustment checks *)
	If[MemberQ[validAdjustmentSample, False]&&messagesBoolean,
		Message[Error::InvalidAdjustmentSample,PickList[suppliedAdjustmentSample, validAdjustmentSample, False]]
	];

	If[(And@@validAdjustmentSample)&&ambiguousAdjustmentSample&&messagesBoolean,
		Message[Warning::AmbiguousAdjustmentSample]
	];

	If[(And@@validAdjustmentSample)&&!validAdjustmentIndex&&messagesBoolean,
		Message[Error::AdjustmentSampleIndex,adjustmentSampleAppearances,adjustmentSampleIndex]
	];

	If[adjustmentSampleMissing&&messagesBoolean,
		Message[Error::AdjustmentSampleRequired]
	];

	If[unusedAdjustmentSample&&messagesBoolean,
		Message[Error::AdjustmentSampleUnneeded]
	];

	(* Track that this is a hard error *)
	invalidAdjustmentOption=If[MemberQ[validAdjustmentSample, False]||!validAdjustmentIndex||adjustmentSampleMissing||unusedAdjustmentSample,AdjustmentSample];

	(* Must have an adjustment sample object to set Gain if using Omega (can't scan full plate) *)
	fullPlateScanRequested=MemberQ[suppliedAdjustmentSample,FullPlate]&&MemberQ[suppliedGains,PercentP];
	invalidFullPlateScan=fullPlateScanRequested&&MatchQ[plateReaderModelObject,Model[Instrument, PlateReader, "id:mnk9jO3qDzpY"]];

	(* Create test *)
	fullPlateScanTest=If[gatherTestsQ,
		Test["AdjustmentSample is specified as an object if using Model[Instrument,PlateReader,\"id:mnk9jO3qDzpY\"] and if Gain has not been set directly:",invalidFullPlateScan,False]
	];

	(* Throw message *)
	If[invalidFullPlateScan&&messagesBoolean,
		Message[Error::GainAdjustmentSampleRequired]
	];

	(* Track that this is a hard error *)
	invalidPlateScanOptions=If[invalidFullPlateScan,
		{Instrument,AdjustmentSample,Gain}
	];

	(* Do all the checks to make sure our plate reader mixing options are valid *)
	{plateReaderMixOptionInvalidities,plateReaderMixTests}=If[gatherTestsQ,
		validPlateReaderMixing[experimentFunction,experimentOptionsAssociation,Output->{Options,Tests}],
		{validPlateReaderMixing[experimentFunction,experimentOptionsAssociation,Output->Options],{}}
	];

	(* Determine how many actual samples we have *)
	numberOfAssaySamples=Replace[numberOfReplicates,Null->1]*Length[mySamples];

	(* Do all the checks to make sure our moat options are valid *)
	{invalidMoatOptions,moatTests}=If[gatherTestsQ,
		validMoat[numberOfAssaySamples,aliquotContainerModelPacket,Join[experimentOptionsAssociation,Association[samplePrepOptions]],Output->{Options,Tests}],
		{validMoat[numberOfAssaySamples,aliquotContainerModelPacket,Join[experimentOptionsAssociation,Association[samplePrepOptions]],Output->Options],{}}
	];

	(* - Validate the Name option - *)
	(* If user actually set Name and an object with that name was found, indicate name can't be used *)
	validNameBoolean=MatchQ[requestedProtocolName,Null]||MatchQ[nameDownload,{{$Failed}}];

	(* Create Name test *)
	nameTest=If[gatherTestsQ,
		Test["The requested name is not already in use:",validNameBoolean,True]
	];

	(* Throw Name message *)
	If[!validNameBoolean&&messagesBoolean,
		Message[Error::NonUniqueName,Object[Protocol,FluorescenceIntensity],requestedProtocolName]
	];

	(* Track that this is a hard error *)
	invalidNameOption=If[!validNameBoolean,Name];

	(* - Validate ReadLocation x RetainCover - *)
	{suppliedReadLocation,suppliedRetainCover}=Lookup[experimentOptionsAssociation,{ReadLocation,RetainCover}];

	(* If user requested ReadLocation->Top and RetainCover->True, warn users that readings will happen through the lid *)
	topReadIssue=MatchQ[{suppliedReadLocation,suppliedRetainCover},{Top,True}];

	(* Create test *)
	topReadTest=If[gatherTestsQ,
		Warning["If RetainCover is set to True, ReadLocation is set to Bottom to prevent the plate cover from interfering with the readings:",topReadIssue,False]
	];

	(* Throw message *)
	If[topReadIssue&&messagesBoolean,
		Message[Warning::CoveredTopRead]
	];

	(* - Validate Injections x RetainCover - *)
	(* If there are any injections, RetainCover must be set to False - otherwise it can be set to anything *)
	anyInjectionsQ=MemberQ[Flatten[Lookup[experimentOptionsAssociation,{PrimaryInjectionVolume,SecondaryInjectionVolume,TertiaryInjectionVolume,QuaternaryInjectionVolume}]],VolumeP];
	validRetainCover=(anyInjectionsQ&&MatchQ[suppliedRetainCover,False])||(!anyInjectionsQ);

	(* Create test *)
	retainCoverTest=If[gatherTestsQ,
		Test["If RetainCover is set to True, injections cannot be specified:",validRetainCover,True]
	];

	(* Throw message *)
	If[!validRetainCover&&messagesBoolean,
		Message[Error::CoveredInjections]
	];

	(* Track invalid option *)
	invalidCoverOption=If[!validRetainCover,RetainCover];

	(* -- Plate Reader can be resolved -- *)
	possiblePlateReaderPackets=If[MatchQ[suppliedPlateReader,Automatic],
		Module[{plateReadersForMode,plateReadersForWavelengthSelection,plateReadersForExcitationWavelength,plateReadersForEmissionWavelength,plateReadersForDualEmissionWavelength,
			plateReadersForWavelengthCombo,plateReadersForMultichromatics,plateReadersForTR,plateReadersForDualEmission,plateReadersForFocalHeight,
			plateReadersForAdjustment,plateReaderForFullPlateScan,plateReaderForSampling},

			(* If mode specified or implied by experiment type, see which plate readers support it *)
			plateReadersForMode=If[MatchQ[neededMode,PlateReaderModeP],
				Select[allPlateReaderModelPackets,MemberQ[Lookup[#,PlateReaderMode],neededMode]&],
				allPlateReaderModelPackets
			];

			(* See which plate readers support the desired wavelength selection *)
			plateReadersForWavelengthSelection=Select[allPlateReaderModelPackets,wavelengthSelectionPossibleFunction];

			(* If time-resolved is indirectly requested by DelayTime/ReadTime, see which plate readers support it *)
			plateReadersForTR=If[timeResolvedImplied&&!unneededIntegrationTimes,
				Select[allPlateReaderModelPackets,MemberQ[Lookup[#,PlateReaderMode],TimeResolvedFluorescence]&],
				allPlateReaderModelPackets
			];

			(* See which plate readers can provide the requested wavelengths *)
			plateReadersForExcitationWavelength=Select[allPlateReaderModelPackets,validExcitationWavelengthFunction[#,filteredExcitationWavelengths]&];
			plateReadersForEmissionWavelength=Select[allPlateReaderModelPackets,validEmissionWavelengthFunction[#,filteredEmissionWavelengths]&];
			plateReadersForDualEmissionWavelength=Select[allPlateReaderModelPackets,validEmissionWavelengthFunction[#,filteredDualEmissionWavelengths]&];
			plateReadersForWavelengthCombo=Select[allPlateReaderModelPackets,validWavelengthCombinationFunction[#,ToList[suppliedEmissionWavelength],suppliedDualEmissionWavelengths,ToList[suppliedExcitationWavelength]]&];

			(*  See which plate readers can support the desired number of different wavelength readings *)
			plateReadersForMultichromatics=Select[allPlateReaderModelPackets,Lookup[numberOfMultichromaticsLookup,Lookup[#,Object]]>=Length[ToList[suppliedEmissionWavelength]]&];

			(* See which plate readers can do dual emission - indicated by second entry in EmissionFilters being populated *)
			plateReadersForDualEmission=If[dualEmissionRequested,
				Select[allPlateReaderModelPackets,MemberQ[Lookup[#,EmissionFilters][[All,2]],DistanceP]&],
				allPlateReaderModelPackets
			];

			(* If focal height is directly requested, see which plate readers support it *)
			plateReadersForFocalHeight=If[focalHeightRequested,
				Select[allPlateReaderModelPackets,!MatchQ[Lookup[#,Object],Model[Instrument,PlateReader,"id:mnk9jO3qDzpY"]]&],
				allPlateReaderModelPackets
			];

			(* In the weird scenario where the user has specified gains and an adjustment sample, but left focal height automatic,
			we want to be able to adjust the FocalHeight using the adjustment sample so we must use an instrument which can change FocalHeight *)
			plateReadersForAdjustment=If[unusedAdjustmentSample,
				(* If there's an issue regardless of the plate reader, don't throw another error *)
				allPlateReaderModelPackets,
				Select[allPlateReaderModelPackets,!unusedAdjustmentSampleFunction[Lookup[#,Object]]&]
			];

			(* If we're trying to determine gain without an adjustment sample object, see which plate readers support it *)
			plateReaderForFullPlateScan=If[fullPlateScanRequested,
				Select[allPlateReaderModelPackets,!MatchQ[Lookup[#,Object],Model[Instrument,PlateReader,"id:mnk9jO3qDzpY"]]&],
				allPlateReaderModelPackets
			];

			(* Find a plate reader which can do the requested sampling pattern *)
			(* PHERAstar, Omega: FluorescencePolarization, all Absorbance, FluorescenceSpectroscopy, LuminescenceSpectroscopy can't do any sampling at all *)
			(* CLARIOStar: FluorescenceSpectroscopy, LuminescenceSpectroscopy, Time Resolved can't do any sampling *)
			plateReaderForSampling=Select[allPlateReaderModelPackets,MemberQ[Lookup[Lookup[#,SamplingPatterns],neededMode],resolvedSamplingPattern]&];

			(* Sort by preferred plate readers - use clariostar if possible since we have most instrument, then omega *)
			SortBy[
				Intersection[plateReadersForMode,plateReadersForWavelengthSelection,plateReadersForTR,plateReadersForExcitationWavelength,plateReadersForEmissionWavelength,
					plateReadersForDualEmissionWavelength,plateReadersForWavelengthCombo,plateReadersForMultichromatics,
					plateReadersForDualEmission,plateReadersForFocalHeight,plateReadersForAdjustment,plateReaderForFullPlateScan,plateReaderForSampling
				],
				FirstPosition[
					(* always prioritze the clariostar over the omegas *)
					(* we used to only prioritze for bio/microbioSTAR, but in the modern era we have more clariostars anyway and more liquid handlers with integrated clariostars *)
					(* importantly, as of writing this comment, _none_ of the CMU liquid handlers have integrated omegas, so definitely don't want to default there *)
					{
						Model[Instrument, PlateReader, "id:E8zoYvNkmwKw"], (* Model[Instrument, PlateReader, "CLARIOstar"] *)
						Model[Instrument, PlateReader, "id:mnk9jO3qDzpY"], (* Model[Instrument, PlateReader, "FLUOstar Omega"] *)
						Model[Instrument, PlateReader, "id:01G6nvkKr3o7"] (* Model[Instrument, PlateReader, "PHERAstar FS"] *)
					},
					Lookup[#,Object]
				]&
			]
		],
		{plateReaderModelPacket}
	];

	unresolvablePlateReader=MatchQ[possiblePlateReaderPackets,{}];

	(* Create test *)
	plateReaderTest=If[gatherTestsQ,
		Test["There is a plate reader which can support all the requested options",unresolvablePlateReader,False]
	];

	(* Throw message *)
	If[unresolvablePlateReader&&messagesBoolean,
		Message[Error::NoPlateReader]
	];

	(* Track hard error  *)
	invalidPlateReaderResolutionOption=If[unresolvablePlateReader,Instrument];

	(* -- Validate Fluorescence Spectroscopy Options -- *)
	{invalidSpectroscopyOptions,spectroscopyTests}=Switch[type,
		Object[Protocol,FluorescenceSpectroscopy],validateFluorescenceSpectroscopyOptions[experimentOptionsAssociation,plateReaderModelPacket,gatherTestsQ],
		Object[Protocol,LuminescenceSpectroscopy],validateLuminescenceSpectroscopyOptions[experimentOptionsAssociation,plateReaderModelPacket,gatherTestsQ],
		_,{{},{}}
	];

	(*-- RESOLVE EXPERIMENT OPTIONS --*)

	(* - Resolve Instrument - *)

	(* In case we've been given an invalid reader or we can't resolve and satisfy all options, set a default reader which supports our mode and can be used for resolving downstream options *)
	defaultReaderModelPacket=SelectFirst[allPlateReaderModelPackets,MemberQ[Lookup[#,PlateReaderMode],neededMode]&,Null];

	(* Use the first plate reader which will satisfy all requests *)
	(* Get modelPacket and modelObject too for any additional checks *)
	{resolvedPlateReader,resolvedPlateReaderModelPacket,resolvedPlateReaderModelObject}=Which[
		MatchQ[suppliedPlateReader,ObjectP[]],{suppliedPlateReader,plateReaderModelPacket,plateReaderModelObject},
		!unresolvablePlateReader,{Lookup[First[possiblePlateReaderPackets],Object],First[possiblePlateReaderPackets],Lookup[First[possiblePlateReaderPackets],Object]},
		True,{Lookup[defaultReaderModelPacket,Object],defaultReaderModelPacket,Lookup[defaultReaderModelPacket,Object]}
	];

	(* - Resolve Mode - *)
	resolvedMode=Which[
		(* We don't have Mode option in Polarization experiments. Apply Fluorescence as resolvedMode for the follow-up option resolving *)
		MatchQ[type,Object[Protocol,FluorescencePolarization]|Object[Protocol,FluorescencePolarizationKinetics]],
		Fluorescence,
		MatchQ[suppliedMode,Automatic],
		If[timeResolvedImplied,
			TimeResolvedFluorescence,
			Fluorescence
		],
		True,
		suppliedMode
	];
	

	(* - Resolve WavelengthSelection - *)
	resolvedWavelengthSelection=If[MatchQ[suppliedWavelengthSelection,Automatic],
		Module[{},
			Which[
				(* Measure all the light for luminescence experiments unless any wavelengths were requested *)
				MatchQ[measurementType,Luminescence]&&MatchQ[Join[filteredEmissionWavelengths,filteredDualEmissionWavelengths],Except[{DistanceP..}]],NoFilter,

				(* With BMG hardware, only Filters are allowed for TR *)
				MatchQ[resolvedMode,TimeResolvedFluorescence],Filters,

				(* With BMG hardware, only Filters are allowed for FP *)
				(* This line isn't necessary with current PHERAstar because EmissionFIlter types doesn't contain Monochromator,
				so value defaults to True,Filters *)
				MatchQ[type,Object[Protocol,FluorescencePolarization]|Object[Protocol,FluorescencePolarizationKinetics]],Filters,

				(* We're not doing TR and we've picked an instrument with a monochromator,
				our past wavelength validation has assumed we're using the monochromator, so stick with this *)
				MemberQ[Lookup[resolvedPlateReaderModelPacket,EmissionFilterTypes],Monochromators],Monochromators,

				(* If we don't have a monochromator, we have to use filters *)
				True,Filters
			]
		],
		suppliedWavelengthSelection
	];

	(* - Resolve Wavelengths - *)

	(* Luminescence experiments don't have an ExcitationWavelength option, so set to a list of Automatics to keep proper index-matching *)
	expandedExcitationWavelengths=If[MatchQ[measurementType,Luminescence],
		ConstantArray[Automatic,Length[ToList[suppliedEmissionWavelength]]],
		ToList[suppliedExcitationWavelength]
	];

	(* If the supplied plate reader can't support the requested mode, resolve wavelengths assuming a valid plate reader was provided
	- otherwise unexpected errors will be thrown because fields needed in the plate reader might not be filled out (e.g. EmissionFilters,ExcitationFilters) *)
	readerModelPacketForResolution=If[!validPlateReaderMode,
		defaultReaderModelPacket,
		resolvedPlateReaderModelPacket
	];

	resolvedWavelengths=Which[
		MatchQ[resolvedWavelengthSelection,Filters|NoFilter]&&MatchQ[experimentType,Intensity|Kinetics],MapThread[
			Function[{excitationWavelength,emissionWavelength,dualEmissionWavelength},
				Module[{
					filterFields,emissionFilterTuples,excitationFilters,possibleEmissionWavelengths,sortedEmissionFilters,sortedExcitationFilters,
					opticModulesUsed,requestedEmissionWavelengths,moduleWavelengths,
					excitationPattern,emissionPattern,
					resolvedExcitationWavelength,resolvedEmissionWavelength,resolvedDualEmissionWavelength},

					(* Lookup appropriate filter fields if running ExperimentFluorescencePolarization *)
					filterFields=If[MatchQ[type,Object[Protocol,FluorescencePolarization]|Object[Protocol,FluorescencePolarizationKinetics]],
						{PolarizationEmissionFilters,PolarizationExcitationFilters},
						{EmissionFilters,ExcitationFilters}
					];

					(* Get available filters *)
					{emissionFilterTuples,excitationFilters}=Lookup[readerModelPacketForResolution,filterFields];

					(* Get all possible emission wavelengths *)
					possibleEmissionWavelengths=DeleteCases[Flatten[emissionFilterTuples,1],Null];

					(* Sort our wavelengths *)
					{sortedEmissionFilters,sortedExcitationFilters}=Sort/@{possibleEmissionWavelengths,excitationFilters};

					(* We're working with an optic module based instrument if there are secondary filters *) 
					opticModulesUsed=MemberQ[emissionFilterTuples[[All,2]],DistanceP];

					(* If we are using an optic module instrument, determine which modules can support our wavelengths *)
					requestedEmissionWavelengths=Cases[{emissionWavelength,dualEmissionWavelength},DistanceP];
					moduleWavelengths=FirstOrDefault@If[opticModulesUsed,
						opticModuleForWavelengthFunction[emissionFilterTuples,excitationFilters,requestedEmissionWavelengths,excitationWavelength]
					];

					(* Define our Excitation filter pattern with the bandwidth considered *)
					excitationPattern=Apply[Alternatives,RangeP[#-filterBandwidth/2,#+filterBandwidth/2]&/@excitationFilters];

					(* Resolve the excitation wavelength *)
					(* If we're doing a luminescence experiment, this will always be Automatic so we'll just set it a value which works with emission wavelengths *)
					resolvedExcitationWavelength=Which[
						(* Our wavelength might be slightly off (within bandpass) get actual value that will be used *)
						MatchQ[excitationWavelength,excitationPattern],First[Nearest[excitationFilters,excitationWavelength]],

						(* Otherwise just go with the supplied wavelength *)
						MatchQ[excitationWavelength,DistanceP],excitationWavelength,

						(* Using optic modules - use whatever will work with what's been requested *)
						(* If we don't have anything, we will have already complained, so just resolve to what's available *)
						opticModulesUsed,If[MatchQ[moduleWavelengths,Null],
							First[sortedExcitationFilters],
							Last[moduleWavelengths]
						],

						(* No wavelength specifications - use lowest available *)
						MatchQ[{emissionWavelength,dualEmissionWavelength},{Automatic,Automatic|Null}],First[sortedExcitationFilters],

						(* If wavelengths aren't all automatic and we aren't using optic modules (which also means no DualEmission) then use the first lower wavelength *)
						True,FirstCase[sortedExcitationFilters,LessP[emissionWavelength]]
					];

					(* Define our Excitation filter pattern with the bandwidth considered *)
					emissionPattern=Apply[Alternatives,RangeP[#-filterBandwidth/2,#+filterBandwidth/2]&/@sortedEmissionFilters];

					resolvedEmissionWavelength=Which[
						(* For luminescence which have already indicated they want all light set to NoFilter *)
						MatchQ[resolvedWavelengthSelection,NoFilter],NoFilter,

						(* Our wavelength might be slightly off (within bandpass) get actual value that will be used *)
						MatchQ[emissionWavelength,emissionPattern],First[Nearest[sortedEmissionFilters,emissionWavelength]],

						(* Otherwise just go with the supplied wavelength *)
						MatchQ[emissionWavelength,DistanceP],emissionWavelength,

						(* Using optic modules - use whatever will work with what's been requested *)
						!MatchQ[emissionWavelength,NoFilter]&&opticModulesUsed,
						If[MatchQ[moduleWavelengths,Null],
							emissionFilterTuples[[1,1]],
							If[MatchQ[dualEmissionWavelength,DistanceP],
								(* Usually we should make sure Dual Emission and Emission wavalengths are far apart. However, our current only Dual Emission instrument and optic module - PHERAstar - has both wavelengths at 520 nm. We should give a default for the case that we cannot really get two wavelengths apart. *)
								SelectFirst[moduleWavelengths[[1]],!Between[dualEmissionWavelength,{#-filterBandwidth/2,#+filterBandwidth/2}]&,moduleWavelengths[[1,1]]],
								moduleWavelengths[[1,1]]
							]
						],

						(* For fluorescence experiments, default to using something above our excitation wavelength *)
						MatchQ[measurementType,Fluorescence],FirstCase[sortedEmissionFilters,GreaterP[resolvedExcitationWavelength]],

						(* For luminescence experiments, default to measuring all emitted light *)
						True,NoFilter
					];

					resolvedDualEmissionWavelength=Which[
						(* Our wavelength might be slightly off (within bandpass) get actual value that will be used *)
						MatchQ[dualEmissionWavelength,emissionPattern],First[Nearest[sortedEmissionFilters,dualEmissionWavelength]],

						(* Otherwise just go with the supplied wavelength *)
						MatchQ[dualEmissionWavelength,DistanceP],dualEmissionWavelength,

						(* If it's Null, leave it Null *)
						MatchQ[dualEmissionWavelength,Null],Null,

						(* Using optic modules so dual emission is possible *)
						(* Resolve Automatic to a wavelength as long as user didn't explicitly set corresponding gain to Null *)
						!MatchQ[emissionWavelength,NoFilter]&&!MatchQ[dualEmissionWavelength,Null]&&opticModulesUsed,
							If[MatchQ[moduleWavelengths,Null]||MatchQ[experimentFunction,ExperimentFluorescencePolarization|ExperimentFluorescencePolarizationKinetics],
								emissionFilterTuples[[1,2]],
								SelectFirst[moduleWavelengths[[1]],!Between[resolvedEmissionWavelength,{#-filterBandwidth/2,#+filterBandwidth/2}]&,Null]
						],

						(* If no optic modules, dual emission is not supported *)
						True,Null
					];

					{resolvedExcitationWavelength,resolvedEmissionWavelength,resolvedDualEmissionWavelength}
				]
			],
			{expandedExcitationWavelengths,ToList[suppliedEmissionWavelength],suppliedDualEmissionWavelengths}
		],
		MatchQ[resolvedWavelengthSelection,Monochromators]&&MatchQ[experimentType,Intensity|Kinetics],MapThread[
			Function[{excitationWavelength,emissionWavelength,dualEmissionWavelength},
				Module[{minEmissionWavelength,maxEmissionWavelength,minExcitationWavelength,maxExcitationWavelength,
					defaultWavelengthDifference,resolvedExcitationWavelength,resolvedEmissionWavelength,resolvedDualEmissionWavelength},

					(* Lookup min/max wavelengths the monochromator can provide *)
					{minEmissionWavelength,maxEmissionWavelength,minExcitationWavelength,maxExcitationWavelength}=Lookup[
						readerModelPacketForResolution,
						{MinEmissionWavelength,MaxEmissionWavelength,MinExcitationWavelength,MaxExcitationWavelength}
					];

					(* If we need to resolve a wavelength arbitrarily enforce a difference of 100nm between emission and excitation *)
					defaultWavelengthDifference=100 Nanometer;

					(* Resolve excitation if it's not been specified *)
					(* Note - if we're doing a luminescence experiment ExcitationWavelength is not an option so don't try to resolve *)
					resolvedExcitationWavelength=If[MatchQ[excitationWavelength,DistanceP]||MatchQ[measurementType,Luminescence],
						excitationWavelength,
						If[MatchQ[emissionWavelength,DistanceP],
							(* Go 100 below requested emission, but make sure not to go lower than min possible *)
							Max[minExcitationWavelength,emissionWavelength-defaultWavelengthDifference],
							(* No wavelengths, just use lowest possible *)
							minExcitationWavelength
						]
					];

					(* Resolve emission if it's not been specified *)
					resolvedEmissionWavelength=Which[
						MatchQ[emissionWavelength,DistanceP|NoFilter],emissionWavelength,

						(* For fluorescence experiments go 100 above requested excitation, but make sure not to go higher than max possible *)
						MatchQ[measurementType,Fluorescence],Min[resolvedExcitationWavelength+defaultWavelengthDifference,maxEmissionWavelength],

						(* For luminescence experiments, default to measuring all emitted light *)
						True,NoFilter
					];

					(* No dual emission is possible so resolve Automatic to Null, but leave user value alone *)
					resolvedDualEmissionWavelength=If[MatchQ[dualEmissionWavelength,DistanceP],
						dualEmissionWavelength,
						Null
					];

					{resolvedExcitationWavelength,resolvedEmissionWavelength,resolvedDualEmissionWavelength}
				]
			],
			{expandedExcitationWavelengths,ToList[suppliedEmissionWavelength],suppliedDualEmissionWavelengths}
		],
		(* Don't resolve wavelengths for our spectroscopy experiments - these will get resolved separately in resolveFluorescenceSpectroscopyOptions/resolveLuminescenceSpectroscopyOptions *)
		(* We're going to drop these 'resolved' wavelengths before calling those resolvers so just set to something that won't upset the transpose *)
		True,{{Null,Null,Null}}
	];

	{resolvedExcitationWavelengths,resolvedEmissionWavelengths,resolvedDualEmissionWavelengths}=Transpose[resolvedWavelengths];

	(* - Resolve DelayTime - *)
	resolvedDelayTime=Which[
		MatchQ[suppliedDelayTime,TimeP],suppliedDelayTime,
		MatchQ[resolvedMode,TimeResolvedFluorescence],50 Microsecond,
		True,Null
	];

	(* - Resolve ReadTime - *)
	resolvedReadTime=Which[
		MatchQ[suppliedReadTime,TimeP],suppliedReadTime,
		MatchQ[resolvedMode,TimeResolvedFluorescence],400 Microsecond,
		True,Null
	];

	(* - Resolve PlateReaderMix - *)
	suppliedPlateReaderMix=Lookup[experimentOptionsAssociation,PlateReaderMix];
	suppliedMixParameters=Lookup[experimentOptionsAssociation,{PlateReaderMixRate,PlateReaderMixTime,PlateReaderMixMode,PlateReaderMixSchedule},Automatic];
	{suppliedPlateReaderMixRate,suppliedPlateReaderMixTime,suppliedPlateReaderMixMode,suppliedPlateReaderMixSchedule}=suppliedMixParameters;

	resolvedPlateReaderMix=Which[
		MatchQ[suppliedPlateReaderMix,BooleanP],suppliedPlateReaderMix,
		MemberQ[suppliedMixParameters,Except[Automatic|Null]],True,
		True,False
	];

	(* - Resolve PlateReaderMix Parameters - *)

	(* Mixing defaults for automatic resolution *)
	defaultMixingRate=700 RPM;
	defaultMixingTime=30 Second;
	defaultMixingMode=DoubleOrbital;
	defaultMixingSchedule=If[anyInjectionsQ,
		AfterInjections,
		If[MatchQ[Lookup[experimentOptionsAssociation,ReadOrder],Serial],
			BeforeReadings, (* In Serial mode mixing is only allowed before reads begin *)
			BetweenReadings
		]
	];

	(* If we're mixing replace Automatics with defaults, otherwise replace with Null *)
	{resolvedPlateReaderMixRate,resolvedPlateReaderMixTime,resolvedPlateReaderMixMode,resolvedPlateReaderMixSchedule}=If[resolvedPlateReaderMix,
		{
			Replace[suppliedPlateReaderMixRate,Automatic->defaultMixingRate],
			Replace[suppliedPlateReaderMixTime,Automatic->defaultMixingTime],
			Replace[suppliedPlateReaderMixMode,Automatic->defaultMixingMode],
			Replace[suppliedPlateReaderMixSchedule,Automatic->defaultMixingSchedule]
		},
		{
			Replace[suppliedPlateReaderMixRate,Automatic->Null],
			Replace[suppliedPlateReaderMixTime,Automatic->Null],
			Replace[suppliedPlateReaderMixMode,Automatic->Null],
			Replace[suppliedPlateReaderMixSchedule,Automatic->Null]
		}
	];

	(* - Resolve Gain - *)
	defaultGainPercentage=90 Percent;
	defaultGain=2500 Microvolt;

	resolvedGains=MapThread[
		Function[{suppliedGain,suppliedDualEmissionGain, adjSampleValue},
			Which[
				(* Use user value *)
				MatchQ[suppliedGain,Except[Automatic]],suppliedGain,

				(* If user didn't set gain, match dual emission gain if one was provided *)
				MatchQ[suppliedDualEmissionGain,UnitsP[]],suppliedDualEmissionGain,

				(* Set as a percentage of the AdjustmentSample if one is provided (or if we can pick one) *)
				MatchQ[adjSampleValue,Automatic|FullPlate|ObjectP[]],defaultGainPercentage,

				(* If AdjustmentSample is explicitly set to Null we can't do any adjustment so set to a specific value *)
				True,defaultGain
			]
		],
		{suppliedGains,suppliedDualEmissionGains, adjustmentSampleValue}
	];

	(* - Resolve DualEmissionGain - *)
	resolvedDualEmissionGains=MapThread[
		Function[{resolvedGain,resolvedDualEmissionWavelength,suppliedDualEmissionGain},
			Which[
				(* Use user value *)
				MatchQ[suppliedDualEmissionGain,Except[Automatic]],suppliedDualEmissionGain,

				(* If we have a corresponding wavelength, set to match primary gain*)
				MatchQ[resolvedDualEmissionWavelength,DistanceP],resolvedGain,

				(* No dual emission wavelength, don't need corresponding gain *)
				True,Null
			]
		],
		{resolvedGains,resolvedDualEmissionWavelengths,suppliedDualEmissionGains}
	];

	(* - Resolve FocalHeight - *)

	(* FocalHeight is a bit tricky, since we will only either set it once, or adjust once *)
	(* Define the following variable to try resolving FocalHeight to Auto or distance value *)
	firstResolvedFocalHeight = Which[
		(* If user setting contains any specific distance value, use it *)
		MemberQ[suppliedFocalHeight, DistanceP], FirstCase[suppliedFocalHeight, DistanceP],
		(* If user setting contains auto, use Auto *)
		MemberQ[suppliedFocalHeight, Auto], Auto,
		(* If user setting contains only Null and Automatic, and for at least one Automatic setting *)
		(* The corresponding Adjustment sample is provided (or if we can pick one), set to Automatic *)
		Or@@MapThread[MatchQ[{#1, #2}, {Automatic, Automatic|ObjectP[]}]&, {suppliedFocalHeight, adjustmentSampleValue}], Automatic,
		(* Any other cases set to Null *)
		True, Null
	];

	resolvedFocalHeightListed=MapThread[
		Which[
			(* Use user value *)
			MatchQ[#1,Except[Automatic]],#1,

			(* If we're using the Omega, we can't set the focal height *)
			MatchQ[resolvedPlateReaderModelObject,Model[Instrument, PlateReader, "id:mnk9jO3qDzpY"]],Null,

			(* If user's setting contains any distance, replace all Automatic settings with that value *)
			MatchQ[firstResolvedFocalHeight, DistanceP], firstResolvedFocalHeight,

			(* If user's setting contains any Auto, replace all Automatic settings with Null *)
			MatchQ[firstResolvedFocalHeight, Auto], Null,

			(* Set based on the AdjustmentSample if one is provided (or if we can pick one), and if there's no other Auto's *)
			(* After that set the firstResolvedFocalHeight to Auto so other Automatic will be converted to Null *)
			MatchQ[#2,Automatic|ObjectP[]] && MatchQ[firstResolvedFocalHeight, Automatic], firstResolvedFocalHeight = Auto; Auto,

			(* If we will resolve an Automatic to Auto later, resolve all Automatics before that to Null *)
			MatchQ[firstResolvedFocalHeight, Automatic], Null,

			(* AdjustmentSample = Null|FullPlate, set to some default *)
			True, 7 Millimeter
		]&,
		{suppliedFocalHeight, adjustmentSampleValue}
	];

	resolvedFocalHeight = If[MatchQ[type, Object[Protocol, LuminescenceSpectroscopy]|Object[Protocol, FluorescenceSpectroscopy]],
		First@resolvedFocalHeightListed,
		resolvedFocalHeightListed
	];

	(* - Resolve TargetPolarization for FluorescencePolarization/FluorescencePolarizationKinetics protocol - *)
	resolvedTargetPolarization=If[
		MatchQ[type,(Object[Protocol,FluorescencePolarization]|Object[Protocol,FluorescencePolarizationKinetics])],
			Switch[Lookup[experimentOptionsAssociation,TargetPolarization],
				RangeP[0 PolarizationUnit,0.5 PolarizationUnit],Lookup[experimentOptionsAssociation,TargetPolarization],
				Automatic, 0.035 PolarizationUnit
			],
			Nothing
	];

	(* - Resolve InjectionFlowRate - *)

	(* Get user value *)
	(* Defaults to Null as Thertiary/Quaternary injections are not available for non-kinetics experiments. *)
	{suppliedPrimaryFlowRate,suppliedSecondaryFlowRate,suppliedTertiaryFlowRate,suppliedQuaternaryFlowRate}=Lookup[experimentOptionsAssociation,{PrimaryInjectionFlowRate,SecondaryInjectionFlowRate,TertiaryInjectionFlowRate,QuaternaryInjectionFlowRate},Null];

	{primaryInjectionsQ,secondaryInjectionQ,tertiaryInjectionQ,quaternaryInjectionQ}=Map[
		MemberQ[Lookup[experimentOptionsAssociation,#,{}],VolumeP]&,
		{PrimaryInjectionVolume,SecondaryInjectionVolume,TertiaryInjectionVolume,QuaternaryInjectionVolume}
	];

	(* Default to 300uL/s if we're injecting, Null if we're not *)
	{resolvedPrimaryFlowRate,resolvedSecondaryFlowRate,resolvedTertiaryFlowRate,resolvedQuaternaryFlowRate}=MapThread[
		Which[
			MatchQ[#1,Automatic]&&TrueQ[#2],300 Microliter/Second,
			MatchQ[#1,Automatic]&&!TrueQ[#2],Null,
			True,#1
		]&,
		{{suppliedPrimaryFlowRate,suppliedSecondaryFlowRate,suppliedTertiaryFlowRate,suppliedQuaternaryFlowRate},{primaryInjectionsQ,secondaryInjectionQ,tertiaryInjectionQ,quaternaryInjectionQ}}
	];

	(* The minimum injection flow rate supported by the ClarioStars *)
	clarioStarMinFlowRate=100 Microliter/Second;

	(* Flip a boolean if we are using a ClarioStar and any of the specified flow rates are less than the minimum flow rate *)
	invalidFlowRateQ=And[
		MatchQ[resolvedPlateReaderModelObject,Model[Instrument,PlateReader,"id:E8zoYvNkmwKw"]],
		MemberQ[
			Map[
				#<clarioStarMinFlowRate&,
				{suppliedPrimaryFlowRate,suppliedSecondaryFlowRate,suppliedTertiaryFlowRate,suppliedQuaternaryFlowRate}
			],
			True
		]
	];

	(* Throw an error if we are using the ClarioStar and we have specified a flow rate that is too low *)
	invalidFlowRateOption=If[invalidFlowRateQ&&!gatherTestsQ,
		Message[Error::InvalidClarioStarFlowRate,
			ObjectToString[resolvedPlateReaderModelObject,Cache->cache],
			ToString[clarioStarMinFlowRate]
		];
		{PrimaryInjectionFlowRate},
		{}
	];
	invalidFlowRateTest=If[gatherTestsQ,
		Test["All injection flow rates are within the instrument's allowed values:",invalidFlowRateQ,False],
		{}
	];

	(* - Resolve Moat Options - *)

	(* grab the supplied Moat parameters *)
	{suppliedMoatSize,suppliedMoatBuffer,suppliedMoatVolume}=Lookup[experimentOptionsAssociation,{MoatSize,MoatBuffer,MoatVolume}];

	(* call moat resolver *)
	{resolvedMoatBuffer,resolvedMoatVolume,resolvedMoatSize} = resolveMoatOptions[
		type,
		aliquotContainerModelPacket,
		suppliedMoatBuffer,
		suppliedMoatVolume,
		suppliedMoatSize];

	(* this will be used later for error-checking *)
	impliedMoat=MatchQ[invalidMoatOptions,{}]&&MemberQ[{suppliedMoatSize,suppliedMoatBuffer,suppliedMoatVolume},Except[Null|Automatic]];

	(* - Resolve ReadLocation - *)
	(* Set to bottom only if we're keeping the cover on*)
	resolvedReadLocation=If[MatchQ[suppliedReadLocation,Automatic],
		If[suppliedRetainCover,
			Bottom,
			Top
		],
		suppliedReadLocation
	];

	(* - Resolve EquilibrationTime - *)
	resolvedEquilibrationTime=Which[
		!MatchQ[Lookup[experimentOptionsAssociation,EquilibrationTime],Automatic],Lookup[experimentOptionsAssociation,EquilibrationTime],
		!MatchQ[Lookup[experimentOptionsAssociation,Temperature],Ambient],5Minute,
		True,0Second
	];

	(* Gather up all our resolved options *)
	resolvedExperimentOptions={
		Instrument->resolvedPlateReader,
		Mode->resolvedMode,
		WavelengthSelection->resolvedWavelengthSelection,
		EmissionWavelength->resolvedEmissionWavelengths,
		ExcitationWavelength->resolvedExcitationWavelengths,
		DualEmissionWavelength->resolvedDualEmissionWavelengths,
		DelayTime->resolvedDelayTime,
		ReadTime->resolvedReadTime,
		PlateReaderMix->resolvedPlateReaderMix,
		PlateReaderMixRate->resolvedPlateReaderMixRate,
		PlateReaderMixTime->resolvedPlateReaderMixTime,
		PlateReaderMixMode->resolvedPlateReaderMixMode,
		PlateReaderMixSchedule->resolvedPlateReaderMixSchedule,
		MoatBuffer->resolvedMoatBuffer,
		MoatVolume->resolvedMoatVolume,
		MoatSize->resolvedMoatSize,
		ReadLocation->resolvedReadLocation,
		Gain->resolvedGains,
		DualEmissionGain->resolvedDualEmissionGains,
		FocalHeight->resolvedFocalHeight,
		PrimaryInjectionFlowRate->resolvedPrimaryFlowRate,
		SecondaryInjectionFlowRate->resolvedSecondaryFlowRate,
		TertiaryInjectionFlowRate->resolvedTertiaryFlowRate,
		QuaternaryInjectionFlowRate->resolvedQuaternaryFlowRate,
		If[
			MatchQ[type,(Object[Protocol,FluorescencePolarization]|Object[Protocol,FluorescencePolarizationKinetics])],
			TargetPolarization->resolvedTargetPolarization,
			Nothing
		],
		EquilibrationTime->resolvedEquilibrationTime
	};


	(* -- Resolve Fluorescence Spectroscopy Specific Options -- *)

	(* We want to do our own gain and wavelength resolution for spectroscopy *)
	optionsForSpectroscopyResolvers=Association[ReplaceRule[Normal[experimentOptionsAssociation],Normal[KeyDrop[resolvedExperimentOptions,{Gain,EmissionWavelength,DualEmissionWavelength,ExcitationWavelength}]]]];
	resolvedSpectroscopyOptions=Switch[type,
		Object[Protocol,FluorescenceSpectroscopy],resolveFluorescenceSpectroscopyOptions[optionsForSpectroscopyResolvers,readerModelPacketForResolution,gatherTestsQ],
		Object[Protocol,LuminescenceSpectroscopy],resolveLuminescenceSpectroscopyOptions[optionsForSpectroscopyResolvers,readerModelPacketForResolution,gatherTestsQ],
		_,{}
	];

	(* - Resolve AdjustmentSample - *)
	(* Resolve this after resolving spectroscopy options since we need to look at resolved gains *)
	relevantGains=Switch[experimentType,
		Intensity|Kinetics,resolvedGains,
		Spectroscopy,Lookup[resolvedSpectroscopyOptions,{ExcitationScanGain,EmissionScanGain}]
	];

	resolvedAdjustmentSample=If[MatchQ[experimentType, Intensity|Kinetics],
		MapThread[
			Which[
				MatchQ[#1,Except[Automatic]],#1,
				MemberQ[#2,PercentP]||MatchQ[#3,Auto],First[mySamples],
				True,Null
			]&,
			{adjustmentSampleValue, relevantGains, resolvedFocalHeight}
		],
		Which[
			MatchQ[First@adjustmentSampleValue,Except[Automatic]],First@adjustmentSampleValue,
			MemberQ[ToList[relevantGains],PercentP]||MatchQ[resolvedFocalHeight,Auto],First[mySamples],
			True,Null
		]
	];

	(* Default to first appearance of the sample *)
	resolvedAdjustmentSampleIndex=If[MatchQ[#,Except[Automatic]],
		#,
		1
	]&/@adjustmentSampleIndex;

	resolvedAdjustmentSpecification=MapThread[
		If[MatchQ[#2,Null|FullPlate],
			#2,
			{#1,#2}
		]&,
		{resolvedAdjustmentSampleIndex,ToList[resolvedAdjustmentSample]}
	];

	(* For spectroscopy type experiments, AdjustmentSample is a single option *)
	resolvedAdjustmentSpecification = If[MatchQ[type, Object[Protocol, FluorescenceSpectroscopy]|Object[Protocol, LuminescenceSpectroscopy]],
		First[resolvedAdjustmentSpecification],
		resolvedAdjustmentSpecification
	];

	(* - Pre-resolve Aliquot Options - *)

	(* Lookup relevant options *)
	{suppliedAliquotVolumes,suppliedAssayVolumes,suppliedTargetConcentrations,suppliedAssayBuffers,suppliedAliquotContainers}=Lookup[
		samplePrepOptions,
		{AliquotAmount,AssayVolume,TargetConcentration,AssayBuffer,AliquotContainer}
	];

	(* Get the unique containers and their models *)
	uniqueContainers=DeleteDuplicates[sampleContainerPackets];
	containerModels=Download[Lookup[uniqueContainers,Model],Object];

	(* Check the well color of the unique container. If ReadLocation -> Bottom and WellColor is OpaqueBlack or OpaqueWhite, we suggest Aliquot->True. *)
	uniqueContainerWellColor=Lookup[
		FirstOrDefault[ToList[fetchPacketFromCache[Lookup[FirstOrDefault[uniqueContainers,<||>],Model,Null],FlattenCachePackets[{cache, Lookup[updatedSimulation[[1]], Packets]}]]],<||>],
		WellColor,
		Null
	];
	conflictWellColorAndReadLocation=MatchQ[resolvedReadLocation,Bottom]&&MatchQ[uniqueContainerWellColor,OpaqueBlack|OpaqueWhite];

	(* Determine if all the core aliquot options are left automatic *)

	automaticAliquotingBooleans=MapThread[
		Function[{aliquot,aliquotVolume,assayVolume,targetConcentration,assayBuffer,aliquotContainer},
			MatchQ[{aliquot,assayVolume,aliquotVolume,targetConcentration,assayBuffer,aliquotContainer},{Automatic..}]
		],
		{suppliedAliquotBooleans,suppliedAliquotVolumes,suppliedAssayVolumes,suppliedTargetConcentrations,suppliedAssayBuffers,suppliedAliquotContainers}
	];

	(* Throw warnings if we're going to aliquot for any of our aliquot required reasons *)
	(* Note that a special case here is that we don't force users to aliquot when the well color is OpaqueWhite or OpaqueBlack. However, a Warning message can be thrown to suggest the user to do Aliquoting. *)
	aliquotWarningTest = If[MemberQ[automaticAliquotingBooleans,True]&&MatchQ[resolvedPreparation, Manual],
		Which[
			Length[uniqueContainers]>1||!SubsetQ[supportedPlateModels,containerModels],If[!gatherTestsQ,
				Message[Warning::SinglePlateRequired],
				Warning["All the samples are requested to be aliquoted into a single plate supported by the plate reader or they are already in such a plate:.",True,False]
			],
			!DuplicateFreeQ[Lookup[samplePackets,Object]],If[!gatherTestsQ,
				Message[Warning::RepeatedPlateReaderSamples],
				Warning["All the samples are requested to be aliquoted so that samples repeated multiple times in the input can be read a multiple aliquots:",True,False]
			],
			!MatchQ[numberOfReplicates,Null],If[!gatherTestsQ,
				Message[Warning::ReplicateAliquotsRequired],
				Warning["All the samples are requested to be aliquoted in order to perform replicate readings:",True,False]
			],
			impliedMoat,If[!gatherTestsQ,
				Message[Warning::MoatAliquotsRequired],
				Warning["All the samples are requested to be aliquoted in order to create a plate with a moat:",True,False]
			],
			conflictWellColorAndReadLocation,If[!gatherTestsQ,
				Message[Warning::BottomReadingAliquotsRecommended],
				Warning["The samples are in a plate with WellColor of Clear when ReadLocation is set to Bottom:",True,False]
			]
		]
	];

	(* Since we can only put one container into the plate reader everything must be in a single supported plate or we will need to aliquot all samples *)
	(* Moat and replicates also require aliquots *)
	aliquotRequired=Or[
		Length[uniqueContainers]>1,
		!SubsetQ[supportedPlateModels,containerModels],
		!DuplicateFreeQ[Lookup[samplePackets,Object]],
		!MatchQ[numberOfReplicates,Null],
		impliedMoat
	];

	(* Also we need to check if any of the aliquot options are given to us *)
	impliedAliquotingBooleans=MapThread[
		Function[{aliquot,aliquotVolume,assayVolume,targetConcentration,assayBuffer,aliquotContainer},
			!MatchQ[{aliquot,assayVolume,aliquotVolume,targetConcentration,assayBuffer,aliquotContainer},{(Automatic|Null)..}]
		],
		{suppliedAliquotBooleans,suppliedAliquotVolumes,suppliedAssayVolumes,suppliedTargetConcentrations,suppliedAssayBuffers,suppliedAliquotContainers}
	];

	(* Resolve Aliquot, AliquotVolume and AliquotContainer *)
	preresolvedAliquotOptions=MapThread[
		Function[{aliquot,impliedAliquot,aliquotContainer},
			Module[{resolvedAliquot,aliquotConflict,resolvedAliquotContainer},

				(* Resolve Aliquot->True if current container won't fit in plate reader *)
				resolvedAliquot=Which[
					MatchQ[aliquot,BooleanP],
						aliquot,
					MatchQ[resolvedPreparation, Robotic],
						False,
					True,
						aliquotRequired||impliedAliquot
				];

				(* If we need to aliquot, we must complain if user set this to False *)
				aliquotConflict=aliquotRequired&&!MatchQ[resolvedAliquot,True];

				(* Resolve the aliquot container *)
				resolvedAliquotContainer=Which[
					MatchQ[aliquotContainer,Automatic]&&MatchQ[resolvedAliquot,True],defaultAliquotContainer,
					MatchQ[aliquotContainer,Automatic]&&MatchQ[resolvedAliquot,False],Null,
					True,aliquotContainer
				];

				{aliquotConflict,resolvedAliquot,resolvedAliquotContainer}
			]
		],
		{suppliedAliquotBooleans,impliedAliquotingBooleans,suppliedAliquotContainers}
	];

	(* Assign variables *)
	{aliquotConflictBooleans,resolvedAliquotBooleans,resolvedAliquotContainers}=Transpose[preresolvedAliquotOptions];

	(* - Resolve Remaining Sampling Options - *)
	(* SamplingDistance *)

	(* Figure out the container that will go into the plate reader to determine well diameter *)
	(* If we aren't aliquoting, samples are all required to be in one container *)
	assayContainerModelPacket=If[MatchQ[resolvedAliquotBooleans,{True..}],
		aliquotContainerModelPacket,
		First[sampleContainerModelPackets]
	];

	(* Resolve to Null if SamplingPattern->Center, else to 80% of the well diameter *)
	resolvedSamplingDistance=Switch[{resolvedSamplingPattern,suppliedSamplingDistance},
		{_,Except[Automatic]},suppliedSamplingDistance,
		{Center,_},Null,
		(* Use 80% of the well diameter, but make sure that's within the bounds allowed by BMG *)
		_,Clip[SafeRound[Lookup[assayContainerModelPacket,WellDiameter]*.8,1 Millimeter],{1 Millimeter,6 Millimeter}]
	];

	(* Use BMG's default if we're doing Matrix scanning otherwise this should be Null *)
	resolvedSamplingDimension=Switch[{resolvedSamplingPattern,suppliedSamplingDimension},
		{_,Except[Automatic]},suppliedSamplingDimension,
		{Matrix,_},3,
		_,Null
	];

	(* - Resolve DestinationWells - *)

	(* Get all wells in the plate *)
	plateWells=AllWells[aliquotContainerModelPacket];

	(* Get the moat wells *)
	moatWells=If[impliedMoat,
		getMoatWells[plateWells,resolvedMoatSize],
		{}
	];

	suppliedDestinationWells=Lookup[samplePrepOptions,DestinationWell];

	(* - Validate DestinationWell Option - *)
	(* Check whether the supplied DestinationWell have duplicated members. PlateReader experiment only allows one plate so we should not aliquot two samples into the same well. *)
	duplicateDestinationWells=DeleteDuplicates[
		Select[DeleteCases[ToList[suppliedDestinationWells],Automatic],Count[DeleteCases[ToList[suppliedDestinationWells],Automatic],#]>1&]
	];
	duplicateDestinationWellOption=If[!MatchQ[duplicateDestinationWells,{}]&&!gatherTestsQ,
		Message[Error::PlateReaderDuplicateDestinationWell,ToString[DeleteDuplicates[duplicateDestinationWells]]];{DestinationWell},
		{}
	];
	duplicateDestinationWellTest=If[gatherTestsQ,
		Test["The specified DestinationWell should not have duplicated members:",MatchQ[duplicateDestinationWells,{}],True],
		{}
	];

	(* Check whether the supplied DestinationWell is the same length as samples with replicates. We cannot aliquot to the same well for duplicates. *)
	invalidDestinationWellLengthQ=If[!MatchQ[suppliedDestinationWells,{Automatic..}]&&MatchQ[resolvedAliquotBooleans,{True..}],
		TrueQ[Length[suppliedDestinationWells]!=numberOfAssaySamples],
		False
	];
	invalidDestinationWellLengthOption=If[invalidDestinationWellLengthQ,
		Message[Error::InvalidDestinationWellLength,ToString[numberOfAssaySamples]];{DestinationWell},
		{}
	];
	invalidDestinationWellLengthTest=If[gatherTestsQ,
		Test["The specified DestinationWell must be the same length as the number of all aliquots (the number of input samples multiplied by the specified NumberOfReplicates.",invalidDestinationWellLengthQ,False],
		{}
	];

	(* Try to resolve destination wells unless we know there's not enough room or we've detected overlap *)
	resolvedDestinationWells=If[MatchQ[suppliedDestinationWells,{Automatic..}]&&MatchQ[resolvedAliquotBooleans,{True..}]&&!sampleNumberError,
		Module[{readDirection,orderedWells,availableAssayWells},

			(* Re-order the wells based on read direction *)
			readDirection=Lookup[experimentOptionsAssociation,ReadDirection];
			orderedWells=Which[
				MatchQ[readDirection,Row],
				Flatten[plateWells],
				MatchQ[readDirection,Column],
				Flatten[Transpose[plateWells]],
				MatchQ[readDirection,SerpentineRow],
				Flatten[MapThread[
					If[OddQ[#2],#1,Reverse[#1]]&,
					{plateWells,Range[Length[plateWells]]}
				]],
				MatchQ[readDirection,SerpentineColumn],
				Flatten[MapThread[
					If[OddQ[#2],#1,Reverse[#1]]&,
					{Transpose[plateWells],Range[Length[Transpose[plateWells]]]}
				]]
			];

			(* Remove any moat wells from our possible wells - use DeleteCases to avoid rearranging *)
			availableAssayWells=DeleteCases[orderedWells,Alternatives@@moatWells];

			(* Use the first n wells *)
			If[Length[availableAssayWells]>=numberOfAssaySamples,
				Take[availableAssayWells,numberOfAssaySamples],
				suppliedDestinationWells
			]
		],
		suppliedDestinationWells
	];

	(* To avoid breaking aliquot resolver with invalid DestinationWell length, here we replace the resolvedDestinationWell with Automatic before enterining aliquot resolver. *)
	transferredResolvedDestinationWells=If[invalidDestinationWellLengthQ,
		ConstantArray[Automatic,Length[mySamples]],
		resolvedDestinationWells
	];

	(* - Determine if any of the samples have an aliquot issue - *)

	(* If given the same sample multiple times, we have to aliquot everything *)
	duplicateSampleError=MemberQ[Lookup[samplePrepOptions,Aliquot],False]&&!DuplicateFreeQ[Lookup[samplePackets,Object]];

	(* Track invalid input error *)
	invalidRepeatSamples=If[duplicateSampleError,
		Cases[Tally[Lookup[samplePackets,Object]],{_,GreaterP[1]}][[All,1]],
		{}
	];

	(* Convert aliquot container specifications so everything is in object format *)
	aliquotContainerObjects=Replace[resolvedAliquotContainers,{{id_Integer,object:ObjectP[]}:>{id,Download[object,Object]},object:ObjectP[]:>Download[object,Object]},{1}];

	(* Get the number of unique containers requested *)
	numberOfAliquotContainers=Length[DeleteDuplicates[aliquotContainerObjects]];

	(* Get a sanitized list of just the actual objects requested for aliquot containers *)
	uniqueAliquotContainers=Replace[aliquotContainerObjects,{id_Integer,object:ObjectP[]}:>Download[object,Object],{1}];

	(* Get the packet associated with the aliquot container packet - we should only have one unique container here or we will have thrown another error *)
	aliquotContainerPacket=SelectFirst[aliquotContainerModelPackets,MatchQ[Lookup[#,Object],ObjectP[First[uniqueAliquotContainers]]]&,<||>];

	(* Also Check the well color of the aliquot container to make sure we are not reading from the bottom for a OpaqueBlack container. When we resolve the aliquot container, it is Clear as our default container is the UV-Star. *)
	aliquotContainerWellcolor=Lookup[aliquotContainerPacket,WellColor,Null];

	aliquotContainerWellColorError=MatchQ[aliquotContainerWellcolor,OpaqueBlack|OpaqueWhite]&&MatchQ[resolvedReadLocation,Bottom];

	(* Determine if all samples will end up in the one plate supported by the plate reader *)
	(* replicatesError and duplicateSampleError are specific cases of an aliquot conflict which already have messages - so don't complain again here *)
	singlePlateError=!replicatesError&&!duplicateSampleError&&(MemberQ[aliquotConflictBooleans,True]||numberOfAliquotContainers>1);

	(* If we're aliquoting and don't have another error determine if there are enough wells in one aliquot container to hold all the input samples *)
	sampleNumberError=If[!singlePlateError && MatchQ[resolvedAliquotBooleans,{True..}],
		numberOfAssaySamples>Lookup[aliquotContainerModelPacket,NumberOfWells],
		False
	];

	invalidNumberSamples=If[sampleNumberError,Lookup[samplePackets,Object],{}];

	(* Make sure aliquot container is supported *)
	aliquotContainerError=!MatchQ[uniqueAliquotContainers,{Null..}]&&!SubsetQ[supportedPlateModels,uniqueAliquotContainers];

	(* Create tests *)
	repeatedSampleTest=If[gatherTestsQ,
		Test["If any samples are repeated in the input then they are set to be aliquoted since repeat readings are performed on aliquots of the input samples:",duplicateSampleError,False]
	];
	aliquotTest=If[gatherTestsQ,
		Test["All samples are in a single supported container or are set to be aliquoted into a single supported container:",singlePlateError,False]
	];
	tooManySamplesTest=If[gatherTestsQ,
		Test["All samples will fit in a single plate supported by the plate reader:",sampleNumberError,False]
	];
	aliquotContainerTest=If[gatherTestsQ,
		Test["The requested aliquot containers are supported by the plate reader",aliquotContainerError,False]
	];
	wellColorAliquotTest=If[gatherTestsQ,
		Test["Samples must be aliquoted into a plate with WellColor of Clear in order to set ReadLocation to Bottom",aliquotContainerWellColorError,False]
	];

	(* Throw aliquoting messages *)
	If[messagesBoolean&&duplicateSampleError,
		Message[Error::RepeatedPlateReaderSamples]
	];
	If[singlePlateError&&messagesBoolean&&MatchQ[resolvedPreparation, Manual],
		Message[Error::SinglePlateRequired]
	];
	If[sampleNumberError&&messagesBoolean&&MatchQ[resolvedPreparation, Manual],
		Message[Error::TooManyPlateReaderSamples]
	];
	If[aliquotContainerError&&messagesBoolean&&MatchQ[resolvedPreparation, Manual],
		Message[Error::InvalidAliquotContainer,resolvedPlateReader,supportedPlateModels]
	];
	If[aliquotContainerWellColorError&&messagesBoolean,
		Message[Error::BottomReadingAliquotContainerRequired]
	];

	(* Track that these are hard errors *)
	invalidAliquotOption=If[singlePlateError&&MatchQ[resolvedPreparation, Manual],Aliquot];
	invalidAliquotContainerOption=If[aliquotContainerError||aliquotContainerWellColorError,AliquotContainer];

	(* We need enough of each aliquot to cover the bottom of the well *)
	requiredAliquotAmount=ConstantArray[Lookup[aliquotContainerPacket,MinVolume,Null],Length[mySamples]];

	(* Resolve Aliquot Options *)
	(* We must throw our own warnings since sending in DestinationWell will make resolveAliquotOptions think that the user asked aliquot *)
	{resolvedAliquotOptions,aliquotTests}=If[gatherTestsQ,
		resolveAliquotOptions[
			experimentFunction,
			mySamples,
			simulatedSamples,
			ReplaceRule[myExperimentOptions,Prepend[resolvedSamplePrepOptions,DestinationWell->transferredResolvedDestinationWells]],
			Cache->cache,
			Simulation -> updatedSimulation,
			RequiredAliquotContainers->resolvedAliquotContainers,
			RequiredAliquotAmounts->requiredAliquotAmount,
			AliquotWarningMessage->Null,
			Output->{Result,Tests}
		],
		{
			resolveAliquotOptions[
				experimentFunction,
				mySamples,
				simulatedSamples,
				ReplaceRule[myExperimentOptions,Prepend[resolvedSamplePrepOptions,DestinationWell->transferredResolvedDestinationWells]],
				Cache->cache,
				Simulation -> updatedSimulation,
				RequiredAliquotContainers->resolvedAliquotContainers,
				RequiredAliquotAmounts->requiredAliquotAmount,
				AliquotWarningMessage->Null,
				Output->Result
			],
			{}
		}
	];

	finalResolvedAliquotOptions=ReplaceRule[resolvedAliquotOptions,{DestinationWell->resolvedDestinationWells}];

	(* -- Resolve label options -- *)
	resolvedSampleLabels=Module[
		{suppliedSampleObjects, uniqueSamples, preResolvedSampleLabels, preResolvedSampleLabelRules},
		suppliedSampleObjects = Download[mySamples, Object];
		uniqueSamples = DeleteDuplicates[suppliedSampleObjects];
		preResolvedSampleLabels = Table[CreateUniqueLabel["absorbance sample"], Length[uniqueSamples]];
		preResolvedSampleLabelRules = MapThread[
			(#1 -> #2)&,
			{uniqueSamples, preResolvedSampleLabels}
		];

		MapThread[
			Function[{object, label},
				Which[
					MatchQ[label, Except[Automatic]],
					label,
					MatchQ[simulation, SimulationP] && MatchQ[LookupObjectLabel[simulation, Download[object, Object]], _String],
					LookupObjectLabel[simulation, Download[object, Object]],
					True,
					Lookup[preResolvedSampleLabelRules, Download[object, Object]]
				]
			],
			{suppliedSampleObjects, Lookup[experimentOptionsAssociation, SampleLabel]}
		]
	];

	resolvedSampleContainerLabels=Module[
		{suppliedContainerObjects, uniqueContainers, preresolvedSampleContainerLabels, preResolvedContainerLabelRules},
		suppliedContainerObjects = Download[Lookup[samplePackets, Container, {}], Object];
		uniqueContainers = DeleteDuplicates[suppliedContainerObjects];
		preresolvedSampleContainerLabels = Table[CreateUniqueLabel["absorbance sample container"], Length[uniqueContainers]];
		preResolvedContainerLabelRules = MapThread[
			(#1 -> #2)&,
			{uniqueContainers, preresolvedSampleContainerLabels}
		];

		MapThread[
			Function[{object, label},
				Which[
					MatchQ[label, Except[Automatic]],
					label,
					MatchQ[simulation, SimulationP] && MatchQ[LookupObjectLabel[simulation, Download[object, Object]], _String],
					LookupObjectLabel[simulation, Download[object, Object]],
					True,
					Lookup[preResolvedContainerLabelRules, Download[object, Object]]
				]
			],
			{suppliedContainerObjects, Lookup[experimentOptionsAssociation, SampleContainerLabel]}
		]
	];

	(* Resolve Post Processing Options *)
	resolvedPostProcessingOptions=resolvePostProcessingOptions[myExperimentOptions];

	(* --- Final Post Resolution Error Checking --- *)

	(* - Compatibility Test - *)

	(* Get the samples which will come into contact with the tubing *)
	injectionSamples=DeleteCases[
		Join@@Lookup[experimentOptionsAssociation,{PrimaryInjectionSample,SecondaryInjectionSample,TertiaryInjectionSample,QuaternaryInjectionSample},Nothing],
		Null
	];
	
	(* Determine if injection samples will harm the instrument *)
	{compatibleMaterials,compatibleMaterialsTests}=If[gatherTestsQ,
		CompatibleMaterialsQ[resolvedPlateReader,injectionSamples,Cache->cache,Simulation -> updatedSimulation,Output->{Result,Tests}],
		{CompatibleMaterialsQ[resolvedPlateReader,injectionSamples,Cache->cache,Simulation -> updatedSimulation],Null}
	];

	(* Track that compatibility issues are a hard error *)
	invalidCompatibilityOptions=If[!compatibleMaterials,
		{PrimaryInjectionSample,SecondaryInjectionSample,TertiaryInjectionSample,QuaternaryInjectionSample}
	];

	(* - Check for heating/shaking of stowaways - *)
	(* Get everything in the plates at the time of reading (may be looking at simulated containers) *)
	plateContents=Download[Flatten[Lookup[sampleContainerPackets,Contents][[All,All,2]],1],Object];

	(* Get the samples sent into the experiment (may be looking at simulated samples) *)
	sampleObjects=Lookup[samplePackets,Object];

	(* Determine if there are samples which are in the plates, but which weren't sent in as inputs *)
	(* If we're aliquoting then they're won't be stowaways since everything is in a new plate *)
	stowawaysPresentQ=If[MatchQ[resolvedAliquotBooleans,{True..}],
		False,
		!ContainsExactly[plateContents,sampleObjects]
	];

	(* Get user options related to plate mixing, heating (anything which will also happen to stowaways) *)
	suppliedTemperature=Lookup[experimentOptionsAssociation,Temperature];

	(* We only need to throw a message about stowaways if we're going to be heating or shaking the plate *)
	stowawaysDisturbed=resolvedPlateReaderMix||TemperatureQ[suppliedTemperature];

	(* Create test *)
	stowawayTest=If[gatherTestsQ,
		Warning[
			"If any heating or mixing is set to occur, all samples in the experimental plate were supplied as inputs to the experiment so no additional samples will be heated/mixed:",
			stowawaysPresentQ&&stowawaysDisturbed,
			False
		]
	];

	(* Throw message *)
	If[messagesBoolean&&stowawaysPresentQ&&stowawaysDisturbed,
		Message[Warning::PlateReaderStowaways,ObjectToString[Complement[plateContents,sampleObjects],Cache->cache]]
	];

	(* - Validate the injection samples - *)
	(* These checks must be done after aliquot options are resolved because we need to know AssayVolume *)
	(* Run a series of tests to make sure our injection options are properly specified *)

	{invalidInjectionOptions,validInjectionTests}=If[gatherTestsQ,
		validPlateReaderInjections[type,samplePackets,injectionSamplePackets,assayContainerModelPacket,ReplaceRule[Normal[experimentOptionsAssociation],resolvedAliquotOptions],Output->{Result,Tests}],
		{validPlateReaderInjections[type,samplePackets,injectionSamplePackets,assayContainerModelPacket,ReplaceRule[Normal[experimentOptionsAssociation],resolvedAliquotOptions]],{}}
	];

	(*-- UNRESOLVABLE OPTION CHECKS --*)

	(* Check our invalid input and invalid option variables and throw Error::InvalidInput or Error::InvalidOption if necessary. *)
	invalidOptions=DeleteDuplicates[DeleteCases[Flatten[{invalidReplicatesOptions,invalidModeOptions,invalidIntegrationTimeOptions,
		invalidIntegrationPlateReaderOptions,invalidWavelengthSelectionOptions,invalidWavelengthSelectionModeOptions,invalidEmissionWavelengthOption,invalidExcitationWavelengthOption,
		invalidDualEmissionOptions,invalidDualEmissionWavelengthOptions,invalidDualEmissionComboOptions,invalidWavelengthComboOptions,invalidWavelengthSelectionOption,
		invalidWavelengthNumberOptions,invalidSamplingOptions,invalidGainOptions,invalidFocalHeightOptions,invalidFocalHeightAdjustmentSampleOptions,
		invalidAdjustmentOption,invalidPlateScanOptions,invalidFullPlateModeOptions,plateReaderMixOptionInvalidities,
		invalidMoatOptions,invalidCoverOption,invalidNameOption,invalidInjectionOptions,invalidPlateReaderResolutionOption,invalidSpectroscopyOptions,duplicateDestinationWellOption,invalidFlowRateOption,invalidDestinationWellLengthOption,
		invalidAliquotOption,invalidAliquotContainerOption,invalidCompatibilityOptions,
		invalidStorageConditionOptions,If[MatchQ[preparationResult, $Failed], {Preparation}, {}]}],Null]];

	(* Throw Error::InvalidOption if there are invalid options. *)
	If[Length[invalidOptions]>0&&messagesBoolean,
		Message[Error::InvalidOption,invalidOptions]
	];

	(* Throw Error::InvalidOption if there are too many samples *)
	invalidSamples=DeleteDuplicates[Join[invalidRepeatSamples,invalidNumberSamples]];
	If[!MatchQ[invalidSamples,{}]&&messagesBoolean,
		Message[Error::InvalidInput,ObjectToString[invalidSamples,Cache->cache]]
	];

	(* Update our option set with newly resolved values *)
	resolvedOptions=ReplaceRule[
		myExperimentOptions,
		(* In case of ExperimentFluorescenceSpectroscopy/LuminescenceSpectroscopy, resolvedSpectroscopyOptions and resolvedExperimentOptions contain wavelength options. Use this order so spectroscopy options are used *)
		Join[
			{AdjustmentSample->resolvedAdjustmentSpecification},
			{
				SamplingDistance -> resolvedSamplingDistance,
				SamplingPattern -> resolvedSamplingPattern,
				SamplingDimension -> resolvedSamplingDimension
			},
			resolvedSpectroscopyOptions,
			resolvedSamplePrepOptions,
			finalResolvedAliquotOptions,
			resolvedExperimentOptions,
			resolvedPostProcessingOptions,
			{
				Preparation -> resolvedPreparation,
				WorkCell->resolvedWorkCell,
				SampleLabel->resolvedSampleLabels,
				SampleContainerLabel->resolvedSampleContainerLabels
			},
			(* Add in any options that got rounded but didn't need resolution *)
			Normal[experimentOptionsAssociation]
		],
		(* If one of our replacements isn't in our original set of options, this means it's experiment specific, so just drop it here by using Append->False *)
		Append->False
	];

	(* Return our resolved options and/or tests. *)
	outputSpecification/.{
		Result -> resolvedOptions,
		Tests -> DeleteCases[
			Flatten[{
				samplePrepTests,replicatesAliquotTest,plateReaderModeTest,integrationModeTest,conflictingTimesTest,
				integrationTimesSupportedTest,wavelengthSelectionPossibleTest,invalidSelectionForModeTest,preparationTest,
				aliquotWarningTest,emissionTest,excitationTest,dualEmissionTest,dualEmissionWavelengthTest,missingDualEmissionGainTest,
				unneededDualEmissionGainTest,validWavelengthCombinationTest,wavelengthSelectionRequiredTest,
				wavelengthSelectionUnusedTest,wavelengthOrderingTest,validSamplingComboTest,validSamplingInstrumentTest,
				validSamplingModeTest,multichromaticsTest,compatibleGainsTests, unneededFocalHeightTest,requiredFocalHeightTest,
				adjustmentTest,adjustmentAmbiguousTest,adjustmentIndexTest, focalHeightAdjustmentTest,requiredAdjustmentTest,
				unusedAdjustmentTest,fullPlateScanTest,plateReaderMixTests, moatTests,nameTest,topReadTest,retainCoverTest,
				plateReaderTest,spectroscopyTests,repeatedSampleTest,duplicateDestinationWellTest,invalidFlowRateTest,invalidDestinationWellLengthTest,
				aliquotTest,tooManySamplesTest,aliquotContainerTest,wellColorAliquotTest,compatibleMaterialsTests,stowawayTest,
				validInjectionTests,invalidStorageConditionTest, aliquotTests
			}],
			Null
		]
	}
];

$DefaultWavelengthSpacing = 50 Nanometer;
$RequiredWavelengthSpacing = 25 Nanometer;

validateFluorescenceSpectroscopyOptions[experimentOptionsAssociation_Association,plateReaderModelPacket:(PacketP[]|Null),gatherTests:BooleanP]:=Module[{
	resolvedSpectralScan,emissionScan,excitationScan,excitationWavelength,emissionWavelength,excitationWavelengthRange,emissionWavelengthRange,
	emissionScanMissingRequired,excitationScanMissingRequired,excitationScanHasExtra,emissionScanHasExtra,
	invalidScan,invalidSpectralScanOption,spectralScanTest,minExcitationWavelength,maxExcitationWavelength,
	minEmissionWavelength,maxEmissionWavelength,knownInstrumentLimits,maxRequestedExcitation,validExcitationScanDistances,emissionScanConflict,
	excitationScanConflict,emissionSpectrumConflictTest,excitationSpectrumConflictTest,conflictingEmissionSpectrumOptions,
	conflictingExcitationSpectrumOptions,minRequestedEmission,validEmissionScanDistance,excitationRangeTest,emissionRangeTest,
	invalidExcitationRangeOptions,invalidEmissionRangeOptions,adjustmentExcitationWavelength,adjustmentEmissionWavelength,
	excitationScanGain,emissionScanGain,focalHeight,adjustmentSample,excitationScanAdjusting,emissionScanAdjusting,adjusting,
	missingExcitationScanGain,missingEmissionScanGain,unusedExcitationScanGain,unusedEmissionScanGain,gainTest,missingExcitationAdjustment,
	missingEmissionAdjustment,unusedExcitationAdjustment,unusedEmissionAdjustment,adjustmentWavelengthTest,invalidAdjustmentWavelengthOptions,
	excitationAdjustmentWavelengthInBounds,excitationAdjustmentWavelengthBoundTest,
	emissionAdjustmentWavelengthInBounds,emissionAdjustmentWavelengthBoundTest
},

	(* Figure out how we're going to resolve spectral scan *)
	resolvedSpectralScan=resolveSpectralScan[experimentOptionsAssociation];

	(* Determine which scans we're doing *)
	emissionScan=MemberQ[ToList[resolvedSpectralScan],Emission];
	excitationScan=MemberQ[ToList[resolvedSpectralScan],Excitation];

	(* Lookup options for wavelength checks *)
	{excitationWavelength,emissionWavelength,excitationWavelengthRange,emissionWavelengthRange}=Lookup[
		experimentOptionsAssociation,
		{ExcitationWavelength,EmissionWavelength,ExcitationWavelengthRange,EmissionWavelengthRange}
	];

	(* -- Correct options are set for SpectralScan value? -- *)
	{emissionScanMissingRequired,excitationScanMissingRequired,excitationScanHasExtra,emissionScanHasExtra}=If[MatchQ[spectralScan,Automatic],
		(* If user didn't specify we can resolve appropriately based on wavelength options *)
		{False,False,False,False},
		{
			(* If SpectralScan->Emission, EmissionWavelengthRange and ExcitationWavelength must be specified *)
			emissionScan&&MemberQ[{emissionWavelengthRange,excitationWavelength},Null],
			(* If SpectralScan->Excitation, ExcitationWavelengthRange and EmissionWavelength must be specified *)
			excitationScan&&MemberQ[{excitationWavelengthRange,emissionWavelength},Null],
			(* If we're only doing an excitation scan (i.e. not an emission scan), then emission scan options shouldn't be specified *)
			!emissionScan&&MemberQ[{emissionWavelengthRange,excitationWavelength},Except[Automatic|Null]],
			(* If we're only doing an emission scan (i.e. not an excitation scan), then excitation scan options shouldn't be specified *)
			!excitationScan&&MemberQ[{excitationWavelengthRange,emissionWavelength},Except[Automatic|Null]]
		}
	];

	(* Throw scan invalidity messages *)
	If[emissionScanMissingRequired&&!gatherTests,Message[Error::EmissionScanOptionsRequired]];
	If[excitationScanMissingRequired&&!gatherTests,Message[Error::ExcitationScanOptionsRequired]];
	If[excitationScanHasExtra&&!gatherTests,Message[Error::UnneededExcitationScanOptions]];
	If[emissionScanHasExtra&&!gatherTests,Message[Error::UnneededEmissionScanOptions]];

	(* Track scan invalidity and create test *)
	invalidScan=Or[emissionScanMissingRequired,excitationScanMissingRequired,excitationScanHasExtra,emissionScanHasExtra];
	invalidSpectralScanOption=If[invalidScan,SpectralScan];
	spectralScanTest=If[gatherTests,Test["The wavelength options needed to record the requested spectra are specified or left Automatic:",invalidScan,False]];

	(* -- Validate Wavelength Combo Validity -- *)
	(* EmissionWavelengthRange and ExcitationWavelength must both be specified or both be Null *)
	emissionScanConflict=MatchQ[{emissionWavelengthRange,excitationWavelength},{_Span,Null}|{Null,DistanceP}];

	(* ExcitationWavelengthRange and EmissionWavelength must both be specified or both be Null *)
	excitationScanConflict=MatchQ[{excitationWavelengthRange,emissionWavelength},{_Span,Null}|{Null,DistanceP}];

	(* Throw wavelength combo messages *)
	If[emissionScanConflict&&!gatherTests,Message[Error::EmissionSpectrumOptionsRequiredTogether]];
	If[excitationScanConflict&&!gatherTests,Message[Error::ExcitationSpectrumOptionsRequiredTogether]];

	(* Create invalid wavelength combo tests *)
	emissionSpectrumConflictTest=If[gatherTests,Test["EmissionWavelengthRange and ExcitationWavelength are both specified or both set to Null:",emissionScanConflict,False]];
	excitationSpectrumConflictTest=If[gatherTests,Test["ExcitationWavelengthRange and EmissionWavelength are both specified or both set to Null:",excitationScanConflict,False]];

	(* Track invalid wavelength combo errors *)
	conflictingEmissionSpectrumOptions=If[emissionScanConflict,{EmissionWavelengthRange,ExcitationWavelength}];
	conflictingExcitationSpectrumOptions=If[excitationScanConflict,{ExcitationWavelengthRange,EmissionWavelength}];

	(* -- Validate Wavelength Differences -- *)
	(* EmissionWavelength is sufficiently larger than end of ExcitationWavelengthRange *)
	(* ExcitationWavelength is sufficiently smaller than start of EmissionWavelengthRange *)

	(* Lookup instrument limits to help in our assessments *)
	{minExcitationWavelength,maxExcitationWavelength,minEmissionWavelength,maxEmissionWavelength}=If[MatchQ[plateReaderModelPacket,Null],
		{Null,Null,Null,Null},
		Lookup[
			plateReaderModelPacket,
			{MinExcitationWavelength,MaxExcitationWavelength,MinEmissionWavelength,MaxEmissionWavelength}
		]
	];

	(* If we weren't given a plate reader or if we were given a plate reader which doesn't support fluorescence spec, use this to avoid throwing additional errors about wavelength specifications *)
	knownInstrumentLimits=MatchQ[{minExcitationWavelength,maxExcitationWavelength,minEmissionWavelength,maxEmissionWavelength},{DistanceP..}];

	(* Take user requested value for start of excitation scan, or if unspecified assume we'll start at the instrument min and go up to $RequiredWavelengthSpacing *)
	maxRequestedExcitation=Last[excitationWavelengthRange,minExcitationWavelength+$RequiredWavelengthSpacing];

	validExcitationScanDistances=Or[
		!knownInstrumentLimits,
		(* If emissionWavelength is unspecified, make sure we can resolve it (excitation range can't get too close to instrument max
		such that with our spacing between the end of the excitation wavelength and our emission wavelength causes us to pop above instrument max) *)
		MatchQ[emissionWavelength,Automatic]&&(maxRequestedExcitation+$RequiredWavelengthSpacing<=maxEmissionWavelength),
		(* Make sure supplied or default max excitation will be okay *)
		(maxRequestedExcitation+$RequiredWavelengthSpacing<=emissionWavelength)
	];

	(* Take user request for start of emission scan, or if unspecified assume we'll scan from (max - $RequiredWavelengthSpacing) to max *)
	minRequestedEmission=First[emissionWavelengthRange,maxEmissionWavelength-$RequiredWavelengthSpacing];

	validEmissionScanDistance=Or[
		!knownInstrumentLimits,
		(* If excitationWavelength is unspecified, make sure we can resolve it (emission range can't get too close to the instrument min
		such that with our spacing between the start of the emission wavelength and our excitation wavelength causes us to dip below instrument min) *)
		MatchQ[excitationWavelength,Automatic]&&(minRequestedEmission-$RequiredWavelengthSpacing>=minExcitationWavelength),
		(minRequestedEmission-($RequiredWavelengthSpacing)>=excitationWavelength)
	];
	(* Throw scan distance messages *)

	If[!gatherTests&&!validExcitationScanDistances,Message[Error::ExcitationWavelengthRangeOverlap]];
	If[!gatherTests&&!validEmissionScanDistance,Message[Error::EmissionWavelengthRangeOverlap]];

	(* Create scan distance tests *)
	excitationRangeTest=If[gatherTests,Test["The emission wavelength must be larger than any of the excitation wavelengths:",validEmissionScanDistance,True]];
	emissionRangeTest=If[gatherTests,Test["The excitation wavelength must be smaller than any of the emission wavelengths:",validEmissionScanDistance,True]];

	(* Track scan distance errors *)
	invalidExcitationRangeOptions=If[!validEmissionScanDistance,{EmissionWavelength,ExcitationWavelengthRange}];
	invalidEmissionRangeOptions=If[!validEmissionScanDistance,{EmissionWavelengthRange,ExcitationWavelength}];

	(* -- Validate supplied gains  -- *)

	(* Lookup the supplied options *)
	{excitationScanGain,emissionScanGain}=Lookup[experimentOptionsAssociation,{ExcitationScanGain,EmissionScanGain}];

	(* Determine the planned scans *)
	(* We'll do a scan if user explicitly requested it or if it's implied from the wavelengths specified *)

	(* For each scan we're doing, make sure we have the corresponding gain *)
	missingExcitationScanGain=excitationScan&&MatchQ[excitationScanGain,Null];
	missingEmissionScanGain=emissionScan&&MatchQ[emissionScanGain,Null];

	(* If we're not doing a scan, make sure the corresponding gain isn't specified *)
	unusedExcitationScanGain=!excitationScan&&MatchQ[excitationScanGain,UnitsP[]];
	unusedEmissionScanGain=!emissionScan&&MatchQ[emissionScanGain,UnitsP[]];

	(* Throw errors for gain checks *)
	If[!gatherTests&&missingExcitationScanGain,Message[Error::ExcitationScanGainRequired]];
	If[!gatherTests&&missingEmissionScanGain,Message[Error::EmissionScanGainRequired]];

	If[!gatherTests&&unusedExcitationScanGain,Message[Error::ExcitationScanGainUnneeded]];
	If[!gatherTests&&unusedEmissionScanGain,Message[Error::EmissionScanGainUnneeded]];

	gainTest=If[gatherTests,
		Test[
			"The appropriate gains are supplied for the types of scan being performed:",
			missingExcitationScanGain||missingEmissionScanGain||unusedExcitationScanGain||unusedEmissionScanGain,
			False
		]
	];

	(* -- Adjustment wavelengths are specified if needed? -- *)
	{adjustmentExcitationWavelength,adjustmentEmissionWavelength,focalHeight,adjustmentSample}=Lookup[
		experimentOptionsAssociation,
		{AdjustmentExcitationWavelength,AdjustmentEmissionWavelength,FocalHeight,AdjustmentSample}
	];

	(* Determine if we even have anything to adjust *)
	excitationScanAdjusting=MatchQ[excitationScanGain,PercentP|Automatic]||MatchQ[focalHeight,Auto|Automatic];
	emissionScanAdjusting=MatchQ[emissionScanGain,PercentP|Automatic]||MatchQ[focalHeight,Auto|Automatic];

	(* If we are adjusting, make sure the needed wavelengths aren't set to Null *)
	missingExcitationAdjustment=excitationScanAdjusting&&excitationScan&&MatchQ[adjustmentExcitationWavelength,Null];
	missingEmissionAdjustment=excitationScanAdjusting&&emissionScan&&MatchQ[adjustmentEmissionWavelength,Null];

	(* If we aren't adjusting, make sure wavelengths didn't get specified anyways *)
	unusedExcitationAdjustment=(!excitationScanAdjusting||!excitationScan)&&MatchQ[adjustmentExcitationWavelength,DistanceP];
	unusedEmissionAdjustment=(!excitationScanAdjusting||!emissionScan)&&MatchQ[adjustmentEmissionWavelength,DistanceP];

	(* Throw adjustment wavelength errors *)
	If[!gatherTests&&missingExcitationAdjustment,Message[Error::AdjustmentExcitationWavelengthRequired]];
	If[!gatherTests&&missingEmissionAdjustment,Message[Error::AdjustmentEmissionWavelengthRequired]];

	If[!gatherTests&&unusedExcitationAdjustment,Message[Error::AdjustmentExcitationWavelengthUnneeded]];
	If[!gatherTests&&unusedEmissionAdjustment,Message[Error::AdjustmentEmissionWavelengthUnneeded]];

	(* Create adjustment wavelength tests. If it's true that any wavelengths are missing or unused, test will fail *)
	adjustmentWavelengthTest=If[gatherTests,
		Test[
			"The appropriate adjustment wavelengths are supplied if Gain/FocalHeight has not been set directly:",
			missingExcitationAdjustment||missingEmissionAdjustment||unusedExcitationAdjustment||unusedEmissionAdjustment,
			False
		]
	];

	(* - Validate AdjustmentExcitationWavelength Bounds - *)
	(* Lookup relevant options *)

	(* Make sure our adjustment wavelength is within the wavelengths we're scanning over (endpoints are also okay) *)
	excitationAdjustmentWavelengthInBounds=If[MatchQ[adjustmentExcitationWavelength,DistanceP]&&MatchQ[excitationWavelengthRange,_Span],
		Between[adjustmentExcitationWavelength,List@@excitationWavelengthRange],
		True
	];

	(* Throw a message if we're out of bounds *)
	If[!excitationAdjustmentWavelengthInBounds&&!gatherTests,
		Message[Error::AdjustmentExcitationWavelengthOutOfRange]
	];

	(* Generate test *)
	excitationAdjustmentWavelengthBoundTest=If[gatherTests,
		Test["The AdjustmentExcitationWavelength is between the wavelengths specified in ExcitationWavelengthRange:",excitationAdjustmentWavelengthInBounds,True]
	];

	(* - Validate AdjustmentEmissionWavelength Bounds - *)
	(* Lookup relevant options *)

	(* Make sure our adjustment wavelength is within the wavelengths we're scanning over (endpoints are also okay) *)
	emissionAdjustmentWavelengthInBounds=If[MatchQ[adjustmentEmissionWavelength,DistanceP]&&MatchQ[emissionWavelengthRange,_Span],
		Between[adjustmentEmissionWavelength,List@@emissionWavelengthRange],
		True
	];

	(* Throw a message if we're out of bounds *)
	If[!emissionAdjustmentWavelengthInBounds&&!gatherTests,
		Message[Error::AdjustmentEmissionWavelengthOutOfRange]
	];

	(* Generate test *)
	emissionAdjustmentWavelengthBoundTest=If[gatherTests,
		Test["The AdjustmentEmissionWavelength is between the wavelengths specified in EmissionWavelengthRange:",emissionAdjustmentWavelengthInBounds,True]
	];

	(* Track all adjustment wavelength errors *)
	invalidAdjustmentWavelengthOptions={
		If[missingExcitationAdjustment||unusedExcitationAdjustment||!excitationAdjustmentWavelengthInBounds,AdjustmentExcitationWavelength,Nothing],
		If[missingEmissionAdjustment||unusedEmissionAdjustment||!emissionAdjustmentWavelengthInBounds,AdjustmentEmissionWavelength,Nothing]
	};

	{
		{invalidSpectralScanOption,conflictingEmissionSpectrumOptions,conflictingExcitationSpectrumOptions,invalidExcitationRangeOptions,invalidEmissionRangeOptions,invalidAdjustmentWavelengthOptions},
		{spectralScanTest,emissionSpectrumConflictTest,excitationSpectrumConflictTest,excitationRangeTest,emissionRangeTest,gainTest,adjustmentWavelengthTest,excitationAdjustmentWavelengthBoundTest,emissionAdjustmentWavelengthBoundTest}
	}
];

resolveSpectralScan[experimentOptionsAssociation_Association]:=Module[
	{spectralScan,excitationWavelength,emissionWavelength,excitationWavelengthRange,emissionWavelengthRange,
	excitationScanGain,emissionScanGain,adjustmentExcitationWavelength,adjustmentEmissionWavelength,
	excitationScanImplied,emissionScanImplied,resolvedSpectralScan},

	(* Lookup options for resolution *)
	{
		spectralScan,excitationWavelength,emissionWavelength,excitationWavelengthRange,emissionWavelengthRange,
		excitationScanGain,emissionScanGain,adjustmentExcitationWavelength,adjustmentEmissionWavelength
	}=Lookup[experimentOptionsAssociation,{
		SpectralScan,ExcitationWavelength,EmissionWavelength,ExcitationWavelengthRange,EmissionWavelengthRange,
		ExcitationScanGain,EmissionScanGain,AdjustmentExcitationWavelength,AdjustmentEmissionWavelength
	}];

	(* Look at wavelength options they set to see what's implied *)
	(* If they've tried to set any options related to a given scan we'll assume they want to do that scan *)
	excitationScanImplied=MemberQ[{excitationWavelengthRange,emissionWavelength,excitationScanGain,adjustmentExcitationWavelength},Except[Automatic|Null]];
	emissionScanImplied=MemberQ[{emissionWavelengthRange,excitationWavelength,emissionScanGain,adjustmentEmissionWavelength},Except[Automatic|Null]];

	(* Default to scan implied by specified wavelengths - else do both *)
	resolvedSpectralScan=Which[
		!MatchQ[spectralScan,Automatic],spectralScan,
		excitationScanImplied&&emissionScanImplied,{Excitation,Emission},
		excitationScanImplied,Excitation,
		emissionScanImplied,Emission,
		True,{Excitation,Emission}
	]
];


validateLuminescenceSpectroscopyOptions[experimentOptionsAssociation_Association,plateReaderModelPacket:(PacketP[]|Null),gatherTests:BooleanP]:=Module[
	{emissionWavelengthRange,adjustmentEmissionWavelength,gain,adjustmentWavelengthInBounds,invalidAdjustmentWavelength,adjustmentWavelengthTest},

	(* - Validate AdjustmentEmissionWavelength - *)
	(* Lookup relevant options *)
	{emissionWavelengthRange,adjustmentEmissionWavelength,gain}=Lookup[experimentOptionsAssociation,{EmissionWavelengthRange,AdjustmentEmissionWavelength,Gain}];

	(* Make sure our adjustment wavelength is within the wavelengths we're scanning over (endpoints are also okay) *)
	adjustmentWavelengthInBounds=If[MatchQ[adjustmentEmissionWavelength,DistanceP]&&MatchQ[emissionWavelengthRange,_Span],
		Between[adjustmentEmissionWavelength,List@@emissionWavelengthRange],
		True
	];

	(* Throw a message if we're out of bounds *)
	If[!adjustmentWavelengthInBounds&&!gatherTests,
		Message[Error::AdjustmentEmissionWavelengthOutOfRange]
	];

	(* Track invalid option *)
	invalidAdjustmentWavelength=If[!adjustmentWavelengthInBounds,AdjustmentEmissionWavelength];

	(* Generate test *)
	adjustmentWavelengthTest=If[gatherTests,
		Test["The AdjustmentEmissionWavelength is between the wavelengths specified in EmissionWavelengthRange:",adjustmentWavelengthInBounds,True]
	];

	{{invalidAdjustmentWavelength},{adjustmentWavelengthTest}}
];


resolveFluorescenceSpectroscopyOptions[experimentOptions_Association,plateReaderModelPacket:PacketP[],gatherTests:BooleanP]:=Module[{
	excitationWavelength,emissionWavelength,excitationWavelengthRange,emissionWavelengthRange,
	minExcitationWavelength,maxExcitationWavelength,minEmissionWavelength,maxEmissionWavelength,
	resolvedSpectralScan,emissionScan,excitationScan,resolvedExcitation,resolvedEmissionRange,resolvedEmission,resolvedExcitationRange,
	defaultGainPercentage,defaultGain,excitationScanGain,emissionScanGain,adjustmentSample,resolvedExcitationScanGain,resolvedEmissionScanGain,
	adjustmentExcitationWavelength,adjustmentEmissionWavelength,gain,focalHeight,excitationAdjusting,
	emissionAdjusting,resolvedAdjustmentExcitation,resolvedAdjustmentEmission},

	(* Lookup instrument limits to help in our assessments *)
	{minExcitationWavelength,maxExcitationWavelength,minEmissionWavelength,maxEmissionWavelength}=Lookup[
		plateReaderModelPacket,
		{MinExcitationWavelength,MaxExcitationWavelength,MinEmissionWavelength,MaxEmissionWavelength}
	];

	(* --- Resolve Options --- *)

	(* -- Resolve Spectral Scan -- *)
	(* Default to scan implied by specified options - else do both *)
	resolvedSpectralScan=resolveSpectralScan[experimentOptions];

	(* Determine which scans we're doing *)
	emissionScan=MemberQ[ToList[resolvedSpectralScan],Emission];
	excitationScan=MemberQ[ToList[resolvedSpectralScan],Excitation];

	(* -- Resolve Scanning Wavelengths -- *)

	(* Lookup options for wavelength resolution *)
	{excitationWavelength,emissionWavelength,excitationWavelengthRange,emissionWavelengthRange}=Lookup[
		experimentOptions,
		{ExcitationWavelength,EmissionWavelength,ExcitationWavelengthRange,EmissionWavelengthRange}
	];

	(* - Resolve Excitation Wavelength - *)
	resolvedExcitation=Which[
		(* Use user value *)
		MatchQ[excitationWavelength,DistanceP],excitationWavelength,

		(* If no emission scanning, set to Null *)
		!emissionScan,Null,

		(* If EmissionWavelengthRange is specified, set to default spacing below *)
		MatchQ[emissionWavelengthRange,_Span],First[emissionWavelengthRange]-$DefaultWavelengthSpacing,

		(* If nothing is specified, start at instrument min *)
		True,minExcitationWavelength
	];

	(* - Resolve Emission Wavelength Range - *)
	resolvedEmissionRange=Which[
		(* Use user value *)
		MatchQ[emissionWavelengthRange,_Span],emissionWavelengthRange,

		(* If no emission scanning, set to Null *)
		!emissionScan,Null,

		(* Default to Span[default spacing above excitation, instrument max] *)
		True,(resolvedExcitation+$DefaultWavelengthSpacing);;maxEmissionWavelength
	];

	(* - Resolve Emission Wavelength - *)
	resolvedEmission=Which[
		(* Use user value *)
		MatchQ[emissionWavelength,DistanceP],emissionWavelength,

		(* If no excitation scanning, set to Null *)
		!excitationScan,Null,

		(* If ExcitationWavelengthRange is specified, set to default spacing above *)
		MatchQ[excitationWavelengthRange,_Span],Last[excitationWavelengthRange]+$DefaultWavelengthSpacing,

		(* If nothing is specified, use instrument max *)
		True,maxEmissionWavelength
	];

	(* - Resolve Excitation Wavelength Range - *)
	resolvedExcitationRange=Which[
		(* Use user value *)
		MatchQ[excitationWavelengthRange,_Span],excitationWavelengthRange,

		(* If no excitation scanning, set to Null *)
		!excitationScan,Null,

		(* Default to Span[instrumentMin, default spacing below emission] *)
		True,minExcitationWavelength;;(resolvedEmission-$DefaultWavelengthSpacing)
	];

	(* -- Resolve Gains -- *)
	defaultGainPercentage=90 Percent;
	defaultGain=2500 Microvolt;
	
	{excitationScanGain,emissionScanGain,adjustmentSample}=Lookup[experimentOptions,{ExcitationScanGain,EmissionScanGain,AdjustmentSample}];
	
	resolvedExcitationScanGain=Which[
		(* Use user value *)
		MatchQ[excitationScanGain,Except[Automatic]],excitationScanGain,

		(* Set as a percentage of the AdjustmentSample if one is provided (or if we can pick one) *)
		excitationScan&&MatchQ[adjustmentSample,Except[Null]],defaultGainPercentage,
		
		(* If user explicitly turned adjustment sample off, set as voltage *)
		excitationScan,defaultGain,
		
		(* Set to Null if we aren't doing an excitation scan *)
		True,Null
	];

	resolvedEmissionScanGain=Which[
		(* Use user value *)
		MatchQ[emissionScanGain,Except[Automatic]],emissionScanGain,

		(* Set as a percentage of the AdjustmentSample if one is provided (or if we can pick one) *)
		emissionScan&&MatchQ[adjustmentSample,Except[Null]],defaultGainPercentage,

		(* If user explicitly turned adjustment sample off, set as voltage *)
		emissionScan,defaultGain,

		(* Set to Null if we aren't doing an emission scan *)
		True,Null
	];

	(* -- Resolve Adjustment Wavelengths -- *)
	{adjustmentExcitationWavelength,adjustmentEmissionWavelength,focalHeight}=Lookup[
		experimentOptions,
		{AdjustmentExcitationWavelength,AdjustmentEmissionWavelength,FocalHeight}
	];

	(* Determine if we even have anything to adjust *)
	excitationAdjusting=MatchQ[resolvedExcitationScanGain,PercentP]||MatchQ[focalHeight,Auto];
	emissionAdjusting=MatchQ[resolvedEmissionScanGain,PercentP]||MatchQ[focalHeight,Auto];

	(* - Resolve Adjustment Excitation Wavelength - *)
	resolvedAdjustmentExcitation=Which[
		(* Use user value *)
		MatchQ[adjustmentExcitationWavelength,DistanceP],adjustmentExcitationWavelength,

		(* If we're make an adjustment and we're doing an excitation scan, resolve to middle value *)
		excitationAdjusting&&excitationScan,Round[Mean[List@@resolvedExcitationRange],1 Nanometer],

		(* If no excitation scanning or don't need to adjust set to Null *)
		True,Null
	];

	(* - Resolve Adjustment Emission Wavelength - *)
	resolvedAdjustmentEmission=Which[
		(* Use user value *)
		MatchQ[adjustmentEmissionWavelength,DistanceP],adjustmentEmissionWavelength,

		(* If we're make an adjustment and we're doing an emission scan, resolve to middle value *)
		emissionAdjusting&&emissionScan,Round[Mean[List@@resolvedEmissionRange],1 Nanometer],

		(* If no emission scanning or don't need to adjust set to Null *)
		True,Null
	];

	(* Gather up our resolved options *)
	{
		SpectralScan->resolvedSpectralScan,

		ExcitationWavelengthRange->resolvedExcitationRange,
		EmissionWavelength->resolvedEmission,
		AdjustmentExcitationWavelength->resolvedAdjustmentExcitation,
		ExcitationScanGain->resolvedExcitationScanGain,

		ExcitationWavelength->resolvedExcitation,
		EmissionWavelengthRange->resolvedEmissionRange,
		AdjustmentEmissionWavelength->resolvedAdjustmentEmission,
		EmissionScanGain->resolvedEmissionScanGain
	}
];


resolveLuminescenceSpectroscopyOptions[experimentOptions_Association,plateReaderModelPacket:PacketP[],gatherTests:BooleanP]:=Module[{
	gain,adjustmentSample,defaultGainPercentage,defaultGain,resolvedGain,emissionWavelengthRange,adjustmentEmissionWavelength,
	focalHeight,adjusting,resolvedAdjustmentEmission},

	(* --- Resolve Options --- *)

	(* -- Resolve Gain -- *)
	(* Lookup options for gain resolution *)
	{gain,adjustmentSample}=Lookup[experimentOptions,{Gain,AdjustmentSample}];

	(* Set some reasonable defaults *)
	defaultGainPercentage=90 Percent;
	defaultGain=2500 Microvolt;

	(* Resolve Gain *)
	resolvedGain=Which[
		(* Use user value *)
		MatchQ[gain,Except[Automatic]],gain,

		(* Set as a percentage of the AdjustmentSample if one is provided (or if we can pick one) *)
		MatchQ[adjustmentSample,Except[Null]],defaultGainPercentage,

		(* If user explicitly turned adjustment sample off, set as voltage *)
		True,defaultGain
	];

	(* -- Resolve Adjustment Wavelength -- *)

	(* Lookup options for resolution *)
	{emissionWavelengthRange,adjustmentEmissionWavelength,focalHeight}=Lookup[
		experimentOptions,
		{EmissionWavelengthRange,AdjustmentEmissionWavelength,FocalHeight}
	];

	(* Determine if we even have anything to adjust *)
	adjusting=MatchQ[resolvedGain,PercentP]||MatchQ[focalHeight,Auto];

	(* Resolve wavelength *)
	resolvedAdjustmentEmission=Which[
		(* Use user value *)
		MatchQ[adjustmentEmissionWavelength,DistanceP],adjustmentEmissionWavelength,

		(* If we're make an adjustment resolve to middle value *)
		adjusting,Round[Mean[List@@emissionWavelengthRange],1 Nanometer],

		(* If we don't need to adjust set to Null *)
		True,Null
	];

	(* Gather up our resolved options *)
	{
		Gain->resolvedGain,
		AdjustmentEmissionWavelength->resolvedAdjustmentEmission
	}
];

DefineOptions[validPlateReaderInjections,
	Options:>{
		HelperOutputOption,
		CacheOption
	}
];

validPlateReaderInjections[
		type:TypeP[],
		inputSamplePackets:{PacketP[Object[Sample]]..},
		injectionSamplePackets:{PacketP[Object[Sample]]...},
		containerModelPacket_,
		options:{(_Rule)..},
		ops:OptionsPattern[]
	]:=Module[{
	cache,outputSpecification,output,gatherTestsQ,messagesQ,appendedTests,appendedOptionInvalidities,
	primaryInjectionSamplesOption,secondaryInjectionSamplesOption,tertiaryInjectionSampleOption,quaternaryInjectionSampleOption,
	primaryInjectionSample,secondaryInjectionSample,tertiaryInjectionSample,quaternaryInjectionSample,
	validInjectionSpecFunction,validPrimaryQ,validSecondaryQ,validTertiaryQ,validQuaternaryQ,primaryInjectionVolumes,secondaryInjectionVolumes,
	tertiaryInjectionVolumes,quaternaryInjectionVolumes,anyInjectionsQ,assayVolumes,dilutionsQ,
	splashVolume,maxVolume,postInjectionVolumes,highVolumePackets,nonHighVolumePackets,overFlowPackets,nonOverFlowPackets,
	injectionSampleVolumes,lowVolumeSamples,sufficientStartingVolume,lowVolumeOptions,injectionSamples,validInjectionSampleNumberQ,
	selectedInjectionSamplePackets,nonLiquidInjectionSampleBooleans,nonLiquidInjectionSamples,injectionSampleStateError,badStateOptions,primaryInjectionTime,
	secondaryInjectionTime,tertiaryInjectionTime,quaternaryInjectionTime,sensibleTimeOrder,
	instrument,instrumentModel,supportedSimultaneousInjections,
	suppliedPrimaryFlowRate,suppliedSecondaryFlowRate,suppliedTertiaryFlowRate,suppliedQuaternaryFlowRate,primaryInjectionsQ,
	secondaryInjectionQ,tertiaryInjectionQ,quaternaryInjectionQ,flowRateRequired,flowRateUnneeded,flowRateConflictQ,storageCondition,unneededStorageCondition,invalidOptions},

	(* Determine the requested return value from the function, and set-up test collection structure *)
	outputSpecification=OptionValue[Output];
	cache=OptionValue[Cache];
	output=ToList[outputSpecification];
	gatherTestsQ=MemberQ[output,Tests];
	messagesQ=!MemberQ[output,Tests];
	appendedTests={};
	appendedOptionInvalidities={};

	(* Lookup our injection samples from the experiment function options *)
	(* Each option is index matched to SamplesIn or is a flat Null *)
	{primaryInjectionSamplesOption,secondaryInjectionSamplesOption,tertiaryInjectionSampleOption,quaternaryInjectionSampleOption}=Lookup[
		options,
		{PrimaryInjectionSample,SecondaryInjectionSample,TertiaryInjectionSample,QuaternaryInjectionSample},
		Null
	];

	(* Pull out our actual sample - there should only be a single unique sample which we verify below in validInjectionSpecFunction *)
	{primaryInjectionSample,secondaryInjectionSample,tertiaryInjectionSample,quaternaryInjectionSample}=Map[
		FirstCase[ToList[#],ObjectP[],Null]&,
		{primaryInjectionSamplesOption,secondaryInjectionSamplesOption,tertiaryInjectionSampleOption,quaternaryInjectionSampleOption}
	];

	(* == Define Function: validInjectionSpecFunction == *)
	(* Checks if an injection group is valid
	 	1: any injections occurring have all needed info (sample, volume, and time (if required))
	 	2: only one sample is present in each injection group
	 *)
	validInjectionSpecFunction[injectionSampleOptionName_,injectionVolumeOptionName_,injectionTimeOptionName_]:=Module[{
		injectionSamples,injectionVolumes,injectionTime,validInjectionCombos,
		inputPacketsWithInvalidInjections,inputPacketsWithValidInjections,uniqueInjectionSamples,singleInjectionSamples,anyInjections,validInjectionTime},

		(* Get injection options *)
		{injectionSamples,injectionVolumes,injectionTime}=Lookup[options,{injectionSampleOptionName,injectionVolumeOptionName,injectionTimeOptionName}];

		(* -- Check all needed info was given for each injection -- *)
		(* Determine if each injection is properly specified *)
		validInjectionCombos=MapThread[
			Module[{inputSamplePacket,injectionSample,injectionVolume},
				{inputSamplePacket,injectionSample,injectionVolume}={#1,#2,#3};

				Which[
					(* Injection is properly specified with sample and volume*)
					MatchQ[injectionSample,ObjectP[]]&&VolumeQ[injectionVolume],True,

					(* No injection *)
					MatchQ[{injectionSample,injectionVolume},{Null,Null}],True,

					(* At least one parameter missing and one specified *)
					MemberQ[{injectionSample,injectionVolume},Null]&&!MatchQ[{injectionSample,injectionVolume},{(Null|Automatic)..}],False
				]
			]&,
			{inputSamplePackets,injectionSamples,injectionVolumes}
		];

		(* Get the input samples with improperly specified injections *)
		inputPacketsWithInvalidInjections=PickList[inputSamplePackets,validInjectionCombos,False];
		inputPacketsWithValidInjections=PickList[inputSamplePackets,validInjectionCombos,True];

		If[gatherTestsQ,
			If[MatchQ[validInjectionCombos,{True..}|{False..}],
				(* All samples are invalid or if no samples are invalid *)
				AppendTo[appendedTests,Test["Any samples with a "<>ToString[injectionSampleOptionName]<>" specified have a corresponding "<>ToString[injectionVolumeOptionName]<>" specified",And@@validInjectionCombos,True]],

				(* Some samples are invalid, some are okay *)
				AppendTo[appendedTests,{
					Test[ObjectToString[inputPacketsWithInvalidInjections]<>" have "<>ToString[injectionSampleOptionName]<>" specified if a corresponding "<>ToString[injectionVolumeOptionName]<>" is specified",False,True],
					Test[ObjectToString[inputPacketsWithValidInjections]<>" have "<>ToString[injectionSampleOptionName]<>" specified if a corresponding "<>ToString[injectionVolumeOptionName]<>" is specified",True,True]
				}]
			]
		];

		(* Throw messages if base-level specifications are invalid *)
		If[!MatchQ[validInjectionCombos,{True..}]&&messagesQ,
			Message[Error::MissingInjectionInformation,injectionSampleOptionName,injectionVolumeOptionName,Lookup[inputPacketsWithInvalidInjections,Object]]
		];

		(* Track invalid option *)
		If[!MatchQ[validInjectionCombos,{True..}],AppendTo[appendedOptionInvalidities,{injectionSampleOptionName,injectionVolumeOptionName}]];

		(* -- Check injection sample is unique -- *)
		uniqueInjectionSamples=Download[DeleteCases[injectionSamples,Null],Object];
		singleInjectionSamples=SameQ@@uniqueInjectionSamples;

		(* Test for single injection sample *)
		If[gatherTestsQ,
			AppendTo[appendedTests,Test["If specified, there is only one "<>ToString[injectionSampleOptionName],singleInjectionSamples,True]]
		];

		(* Throw message *)
		If[!singleInjectionSamples&&messagesQ,
			Message[Error::SingleInjectionSampleRequired,injectionSampleOptionName]
		];

		(* Track invalid option *)
		If[!singleInjectionSamples,AppendTo[appendedOptionInvalidities,injectionSampleOptionName]];

		(* -- Check Injection Time -- *)
		anyInjections=MemberQ[injectionSamples,ObjectP[]];

		(* A time should only be provided if there are injections *)
		(* FI doesn't have a time option, so this is valid by default *)
		validInjectionTime=Or[
			MatchQ[type,Object[Protocol,AbsorbanceIntensity]|Object[Protocol,AbsorbanceSpectroscopy]|Object[Protocol,FluorescenceIntensity]|Object[Protocol,FluorescenceSpectroscopy]|Object[Protocol,FluorescencePolarization]|Object[Protocol,LuminescenceIntensity]|Object[Protocol,LuminescenceSpectroscopy]|Object[Protocol,Nephelometry]],
			anyInjections&&TimeQ[injectionTime]&&injectionTime<Lookup[options,RunTime],
			!anyInjections&&MatchQ[injectionTime,Null]
		];

		(* Add tests for FK *)
		If[MatchQ[type,Object[Protocol,FluorescenceKinetics]|Object[Protocol,LuminescenceKinetics]|Object[Protocol,FluorescencePolarizationKinetics]|Object[Protocol,AbsorbanceKinetics]|Object[Protocol,NephelometryKinetics]]&&gatherTestsQ,
			If[anyInjections,
				AppendTo[appendedTests,Test[ToString[injectionTimeOptionName]<>" is set to a time less than RunTime if injections are occurring:",validInjectionTime,True]],
				AppendTo[appendedTests,Test[ToString[injectionTimeOptionName]<>" is not specified if injections are not occurring:",validInjectionTime,True]]
			]
		];

		(* Throw messages for FK *)
		(* Don't complain about injection time if some of their combos are invalid since then it's unclear if they even want injections *)
		If[MatchQ[type,Object[Protocol,FluorescenceKinetics]|Object[Protocol,LuminescenceKinetics]|Object[Protocol,FluorescencePolarizationKinetics]|Object[Protocol,AbsorbanceKinetics]|Object[Protocol,NephelometryKinetics]]&&!validInjectionTime&&messagesQ&&MatchQ[validInjectionCombos,{True..}],
			If[anyInjections,
				Message[Error::InjectionTimeInvalid,injectionTimeOptionName,injectionSampleOptionName,injectionVolumeOptionName],
				Message[Error::InjectionTimeUnneeded,injectionTimeOptionName,injectionSampleOptionName,injectionVolumeOptionName]
			]
		];

		(* Track invalid option *)
		If[!validInjectionTime,AppendTo[appendedOptionInvalidities,injectionTimeOptionName]];

		MatchQ[validInjectionCombos,{True..}]&&singleInjectionSamples&&validInjectionTime
	];

	validPrimaryQ=validInjectionSpecFunction[PrimaryInjectionSample,PrimaryInjectionVolume,PrimaryInjectionTime];
	validSecondaryQ=validInjectionSpecFunction[SecondaryInjectionSample,SecondaryInjectionVolume,SecondaryInjectionTime];
	{validTertiaryQ,validQuaternaryQ}=If[MatchQ[type,Object[Protocol,FluorescenceKinetics]|Object[Protocol,LuminescenceKinetics]|Object[Protocol,FluorescencePolarizationKinetics]|Object[Protocol,AbsorbanceKinetics]|Object[Protocol,NephelometryKinetics]],
		{
			validInjectionSpecFunction[TertiaryInjectionSample,TertiaryInjectionVolume,TertiaryInjectionTime],
			validInjectionSpecFunction[QuaternaryInjectionSample,QuaternaryInjectionVolume,QuaternaryInjectionTime]
		},
		{True,True}
	];

	(* Only FluorescenceKinetics has tertiary and quaternary options, so pad with Nulls for MapThread *)
	{primaryInjectionVolumes,secondaryInjectionVolumes,tertiaryInjectionVolumes,quaternaryInjectionVolumes}=Lookup[
		options,
		{PrimaryInjectionVolume,SecondaryInjectionVolume,TertiaryInjectionVolume,QuaternaryInjectionVolume},
		ConstantArray[Null,Length[inputSamplePackets]]
	];
	anyInjectionsQ=MemberQ[Join[primaryInjectionVolumes,secondaryInjectionVolumes,tertiaryInjectionVolumes,quaternaryInjectionVolumes],VolumeP];

	assayVolumes=If[MatchQ[Lookup[options,AssayVolume],{VolumeP..}],
		Lookup[options,AssayVolume],
		ConstantArray[Null,Length[inputSamplePackets]]
	];

	(* Append tests that check if well volume will be exceeded and assign a string to each input sample so we can then throw a consolidated message *)
	maxVolume=Lookup[containerModelPacket,MaxVolume];
	splashVolume=maxVolume*0.85;

	postInjectionVolumes=MapThread[
		Module[{primaryInjectionVolume,secondaryInjectionVolume,tertiaryInjectionVolume,quaternaryInjectionVolume,inputSamplePacket,assayVolume,startingVolume,
			injectionVolumeAdded,volumeAfterInjections},

			(* Name MapThread variables *)
			{primaryInjectionVolume,secondaryInjectionVolume,tertiaryInjectionVolume,quaternaryInjectionVolume,inputSamplePacket,assayVolume}={#1,#2,#3,#4,#5,#6};

			startingVolume=If[MatchQ[assayVolume,VolumeP],
				assayVolume,
				Lookup[inputSamplePacket,Volume]
			];

			injectionVolumeAdded=Total[Replace[{primaryInjectionVolume,secondaryInjectionVolume,tertiaryInjectionVolume,quaternaryInjectionVolume},Null->0 Microliter,1]];

			(* We don't want to complain about volumes if we aren't doing any injections, so set to 0 so sample volume doesn't cause issues *)
			volumeAfterInjections=If[MatchQ[injectionVolumeAdded, 0 Microliter],
				0 Microliter,
				startingVolume+injectionVolumeAdded
			]
		]&,
		{primaryInjectionVolumes,secondaryInjectionVolumes,tertiaryInjectionVolumes,quaternaryInjectionVolumes,inputSamplePackets,assayVolumes}
	];

	(* - Check to see if injections will cause overflow - *)
	(* postInjectionVolumes were set to zero if we aren't injecting, so we will only flag samples whose volume becomes too high after injecting *)
	highVolumePackets=PickList[inputSamplePackets,postInjectionVolumes,RangeP[splashVolume,maxVolume]];
	nonHighVolumePackets=PickList[inputSamplePackets,postInjectionVolumes,!RangeP[splashVolume,maxVolume]];

	overFlowPackets=PickList[inputSamplePackets,postInjectionVolumes,GreaterP[maxVolume]];
	nonOverFlowPackets=PickList[inputSamplePackets,postInjectionVolumes,LessP[maxVolume]];

	(* Lookup if dilutions are happening (only an option for Nephelometry), as dilution+injection volume checks happen already in Neph *)
	dilutionsQ = !NullQ[Lookup[options,Diluent,Null]];

	(* Create warning tests if volume is getting up there *)
	If[gatherTestsQ&&!MatchQ[highVolumePackets,{}]&&!dilutionsQ,
		AppendTo[appendedTests,
			If[MatchQ[postInjectionVolumes,{RangeP[splashVolume,maxVolume]..}],
				Warning["None of the injections will raise the well volume of any samples to the point where splashing may occur:",False,True],
				{
					Warning["None of the injections will raise the well volume of "<>ObjectToString[highVolumePackets]<>" to the point where splashing may occur:",False,True],
					Warning["None of the injections will raise the well volume of "<>ObjectToString[nonHighVolumePackets]<>" to the point where splashing may occur:",True,True]
				}
			]
		]
	];

	(* Create tests for volumes which are too high *)
	If[gatherTestsQ&&!MatchQ[overFlowPackets,{}]&&!dilutionsQ,
		AppendTo[appendedTests,
			If[MatchQ[postInjectionVolumes,{GreaterP[maxVolume]..}|{LessP[maxVolume]..}],
				(* All okay, or all not okay *)
				Test["None of the injections will cause any samples to surpass their max well volume:",overFlowPackets,{}],
				{
					Test["None of the injections will cause "<>ObjectToString[overFlowPackets]<>" to surpass their max well volume:",False,True],
					Test["None of the injections will cause "<>ObjectToString[nonOverFlowPackets]<>" to surpass their max well volume:",True,True]
				}
			]
		]
	];

	If[!MatchQ[overFlowPackets,{}]&&messagesQ&&!dilutionsQ,
		Message[Error::WellVolumeExceeded,ObjectToString[overFlowPackets]]
	];

	If[!MatchQ[highVolumePackets,{}]&&messagesQ&&!dilutionsQ,
		Message[Warning::HighWellVolume,ObjectToString[highVolumePackets]]
	];

	(* Track invalid options *)
	If[!MatchQ[overFlowPackets,{}]&&!dilutionsQ,AppendTo[appendedOptionInvalidities,{PrimaryInjectionVolume,SecondaryInjectionVolume,TertiaryInjectionVolume,QuaternaryInjectionVolume}]];

	(* - Check to make sure there are no more than two total samples being injected - *)

	(* Get all sample objects *)
	injectionSamples=Download[
		DeleteCases[
			Join@@Lookup[options,{PrimaryInjectionSample,SecondaryInjectionSample,TertiaryInjectionSample,QuaternaryInjectionSample},Nothing],
			Null
		],
		Object
	];

	(* BMG plate readers have only two syringe pumps, so make sure we don't exceed this *)
	validInjectionSampleNumberQ=Length[DeleteDuplicates[injectionSamples]]<=2;

	(* Generate test for total sample number *)
	If[gatherTestsQ,
		AppendTo[appendedTests,Test["There are no more than two unique injection samples:",validInjectionSampleNumberQ,True]]
	];

	(* Throw message *)
	If[messagesQ&&!validInjectionSampleNumberQ,
		Message[Error::TooManyInjectionSamples]
	];

	(* Track invalid option *)
	If[!validInjectionSampleNumberQ,AppendTo[appendedOptionInvalidities,{PrimaryInjectionSample,SecondaryInjectionSample,TertiaryInjectionSample,QuaternaryInjectionSample}]];

	(* - Check the state of injection samples - *)
	(* Remove Null and duplicates *)
	selectedInjectionSamplePackets=DeleteCases[DeleteDuplicates[injectionSamplePackets],NullP];

	(* if there are injection samples, track the invalid ones that are not Liquid *)
	nonLiquidInjectionSampleBooleans=If[!MatchQ[selectedInjectionSamplePackets,{}],
		(!MatchQ[#,Liquid])&/@Lookup[selectedInjectionSamplePackets,State],
		{}
	];

	(* Track the invalid ones that are not liquid *)
	nonLiquidInjectionSamples=Lookup[PickList[selectedInjectionSamplePackets,nonLiquidInjectionSampleBooleans],Object,{}];

	injectionSampleStateError=Length[nonLiquidInjectionSamples]>0;

	(* Throw message *)
	If[injectionSampleStateError&&messagesQ,
		Message[Error::InjectionSampleStateError,ObjectToString[nonLiquidInjectionSamples,Cache->cache]]
	];

	(* Create test *)
	If[gatherTestsQ,
		AppendTo[appendedTests,Test["The states of the injection samples are Liquid:",injectionSampleStateError,False]]
	];

	badStateOptions=PickList[
		{PrimaryInjectionSample,SecondaryInjectionSample,TertiaryInjectionSample,QuaternaryInjectionSample},
		{primaryInjectionSample,secondaryInjectionSample,tertiaryInjectionSample,quaternaryInjectionSample},
		_?(MatchQ[#,Alternatives@@nonLiquidInjectionSamples]&)
	];

	(* Track invalid option *)
	If[injectionSampleStateError,AppendTo[appendedOptionInvalidities,badStateOptions]];

	(* - Make sure injection samples have enough volume to prime the lines - *)

	(* Get current volume of samples to be injected - default to something silly if we're injecting a model *)
	injectionSampleVolumes=Lookup[injectionSamplePackets,Volume];

	(* Make sure all injection samples have at least enough volume to do the prime *)
	lowVolumeSamples=If[anyInjectionsQ&&MatchQ[injectionSamplePackets,{ObjectP[Object[Sample]]..}],
		Lookup[PickList[injectionSamplePackets,injectionSampleVolumes,LessP[$BMGPrimeVolume]],Object,{}],
		{}
	];
	sufficientStartingVolume=MatchQ[lowVolumeSamples,{}];

	(* Throw message *)
	(* Not even having enough to prime is a hard error since it introduces air into the lines during set-up *)
	(* and we don't want ops to block thinking something is wrong with tubing/positioning *)
	(* Throw an insufficient volume error only if samples are actually liquid - otherwise we're just rubbing salt in the wound *)
	If[!sufficientStartingVolume&&messagesQ&&!injectionSampleStateError,
		Message[Error::InsufficientPrimeVolume,$BMGPrimeVolume]
	];

	(* Create test *)
	If[gatherTestsQ,
		AppendTo[appendedTests,Test["Any samples being injected have at least "<>ToString[$BMGPrimeVolume]<>", the volume needed to prime the injection lines",sufficientStartingVolume,True]]
	];

	(* Determine the injection group with which the samples *)
	lowVolumeOptions=Map[
		If[!sufficientStartingVolume&&MatchQ[FirstCase[Lookup[options,#],ObjectP[],Null],ObjectP[lowVolumeSamples]],
			#,
			Nothing
		]&,
		{PrimaryInjectionSample,SecondaryInjectionSample,TertiaryInjectionSample,QuaternaryInjectionSample}
	];

	If[!sufficientStartingVolume,AppendTo[appendedOptionInvalidities,lowVolumeOptions]];

	(* - Check to make sure injection times are sensible - *)
	{primaryInjectionTime,secondaryInjectionTime,tertiaryInjectionTime,quaternaryInjectionTime}=Lookup[options,{PrimaryInjectionTime,SecondaryInjectionTime,TertiaryInjectionTime,QuaternaryInjectionTime},Null];

	(* Make sure injections are in ascending order for kinetics experiments. It's okay if two injections have the same time *)
	sensibleTimeOrder=If[MatchQ[type,Object[Protocol,FluorescenceKinetics]|Object[Protocol,LuminescenceKinetics]|Object[Protocol,FluorescencePolarizationKinetics]|Object[Protocol,AbsorbanceKinetics]|Object[Protocol,NephelometryKinetics]],
		OrderedQ[DeleteCases[{primaryInjectionTime,secondaryInjectionTime,tertiaryInjectionTime,quaternaryInjectionTime},Null]],
		True
	];

	(* Generate test for time order *)
	If[gatherTestsQ,
		AppendTo[appendedTests,Test["Subsequent injections are set to occur at the same time or after previous injections:",sensibleTimeOrder,True]]
	];

	(* Throw messages *)
	If[messagesQ&&!sensibleTimeOrder,
		Message[Error::InjectionTimeOrder]
	];

	(* Track invalid option *)
	If[!sensibleTimeOrder,AppendTo[appendedOptionInvalidities,{PrimaryInjectionTime,SecondaryInjectionTime,TertiaryInjectionTime,QuaternaryInjectionTime}]];

	(* - Check the simultaneous injection time - *)

	(* If the instrument is automatic, default it to Omega for this check. *)
	instrument=Lookup[options,Instrument][Object]/.{Automatic->Model[Instrument, PlateReader, "id:mnk9jO3qDzpY"]};

	instrumentModel=If[MatchQ[instrument,ObjectP[Object[Instrument,PlateReader]]],
		instrument[Model][Object],
		instrument
	];

	(* Two injections at the same time only supported in PHERAstar or FLUOstar using two different pumps *)
	supportedSimultaneousInjections=If[
		And[
			MatchQ[type,Object[Protocol,FluorescenceKinetics]|Object[Protocol,LuminescenceKinetics]|Object[Protocol,FluorescencePolarizationKinetics]|Object[Protocol,AbsorbanceKinetics]|Object[Protocol,NephelometryKinetics]],
			MatchQ[Length[DeleteCases[{primaryInjectionTime,secondaryInjectionTime,tertiaryInjectionTime,quaternaryInjectionTime},Null]],Length[DeleteCases[{primaryInjectionSample,secondaryInjectionSample,tertiaryInjectionSample,quaternaryInjectionSample},Null]]]
		],
		Module[{injectionInfo,groupedInjectionInfo,simultaneousInjectionQ,simultaneousInjection,uniqueInjectionSampleQ},
			(* Gather injection information in the form of {injection time, injection sample} *)
			injectionInfo=MapThread[{#1,#2}&,
				{DeleteCases[{primaryInjectionTime,secondaryInjectionTime,tertiaryInjectionTime,quaternaryInjectionTime},Null],
				DeleteCases[{primaryInjectionSample,secondaryInjectionSample,tertiaryInjectionSample,quaternaryInjectionSample},Null]
				}
			];

			(* Gather the injection info based on injection time *)
			groupedInjectionInfo=Gather[injectionInfo,First[#1]==First[#2]&];

			(* Check if there are any same injection times *)
			simultaneousInjectionQ=Length[#]>1&/@groupedInjectionInfo;

			(* Take the simultaneous injection time *)
			simultaneousInjection=PickList[groupedInjectionInfo,simultaneousInjectionQ];

			(* Check if there are any simultaneous injection and if the simultaneous injection sample are the same *)
			uniqueInjectionSampleQ=If[Length[simultaneousInjection]>0,
				(* False, if the simultaneous injection samples are the same *)
				(* We do the check by comparing the simultaneousInjection and the same variable after delete duplicates. *)
				MatchQ[simultaneousInjection,Map[Function[x,DeleteDuplicatesBy[x,#[[2]]&]],simultaneousInjection]
				],
				True
			];

			(* If there is no simultaneous injection, return True anyway; Otherwise, return True if uniqueInjectionSampleQ is True and the instrument is PHERAstar or FLUOstar *)
			If[Length[simultaneousInjection]>0,
				uniqueInjectionSampleQ&&(MatchQ[instrumentModel,Model[Instrument, PlateReader, "id:01G6nvkKr3o7"]|Model[Instrument, PlateReader, "id:mnk9jO3qDzpY"]|Model[Instrument, Nephelometer, "NEPHELOstar Plus"]]),
			True
			]
		],

		True
	];

	(* Generate test for time order *)
	If[gatherTestsQ,
		AppendTo[appendedTests,Test["Subsequent injections are set to occur at the same time using different pumps and supported plate reader:",supportedSimultaneousInjections,True]]
	];

	(* Throw messages *)
	If[messagesQ&&!supportedSimultaneousInjections,
		Message[Error::InvalidSimultaneousInjections]
	];

	(* Track invalid option *)
	If[!supportedSimultaneousInjections,AppendTo[appendedOptionInvalidities,{PrimaryInjectionTime,SecondaryInjectionTime,TertiaryInjectionTime,QuaternaryInjectionTime}]];

	(* - Check InjectionFlowRate - *)
	(* Defaults to Null as Thertiary/Quaternary injections are not available for non-kinetics experiments. *)
	{suppliedPrimaryFlowRate,suppliedSecondaryFlowRate,suppliedTertiaryFlowRate,suppliedQuaternaryFlowRate}=Lookup[options,{PrimaryInjectionFlowRate,SecondaryInjectionFlowRate,TertiaryInjectionFlowRate,QuaternaryInjectionFlowRate},Null];

	(* Check whether any injection is performed  *)
	{primaryInjectionsQ,secondaryInjectionQ,tertiaryInjectionQ,quaternaryInjectionQ}=Map[
		MemberQ[#,VolumeP]&,
		{primaryInjectionVolumes,secondaryInjectionVolumes,tertiaryInjectionVolumes,quaternaryInjectionVolumes}
	];

	flowRateRequired=MapThread[
		#1&&MatchQ[#2,Null]&,
		{{primaryInjectionsQ,secondaryInjectionQ,tertiaryInjectionQ,quaternaryInjectionQ},{suppliedPrimaryFlowRate,suppliedSecondaryFlowRate,suppliedTertiaryFlowRate,suppliedQuaternaryFlowRate}}
	];
	flowRateUnneeded=MapThread[
		!#1&&FlowRateQ[#2]&,
		{{primaryInjectionsQ,secondaryInjectionQ,tertiaryInjectionQ,quaternaryInjectionQ},{suppliedPrimaryFlowRate,suppliedSecondaryFlowRate,suppliedTertiaryFlowRate,suppliedQuaternaryFlowRate}}
	];

	(* Create tests *)
	If[gatherTestsQ,
		AppendTo[
			appendedTests,
			If[MatchQ[type,Object[Protocol,FluorescenceKinetics]|Object[Protocol,LuminescenceKinetics]|Object[Protocol,FluorescencePolarizationKinetics]|Object[Protocol,AbsorbanceKinetics]|Object[Protocol,NephelometryKinetics]],
				{
					Test["PrimaryInjectionFlowRate is only specified when primary injections are being performed:",flowRateRequired[[1]]||flowRateUnneeded[[1]],False],
					Test["SecondaryInjectionFlowRate is only specified when secondary injections are being performed:",flowRateRequired[[2]]||flowRateUnneeded[[2]],False],
					Test["TertiaryInjectionFlowRate is only specified when tertiary injections are being performed:",flowRateRequired[[3]]||flowRateUnneeded[[3]],False],
					Test["QuaternaryInjectionFlowRate is only specified when quaternary injections are being performed:",flowRateRequired[[4]]||flowRateUnneeded[[4]],False]
				},
				{
					Test["PrimaryInjectionFlowRate is only specified when primary injections are being performed:",flowRateRequired[[1]]||flowRateUnneeded[[1]],False],
					Test["SecondaryInjectionFlowRate is only specified when secondary injections are being performed:",flowRateRequired[[2]]||flowRateUnneeded[[2]],False]
				}
			]
		]
	];

	(* Throw messages *)
	If[MemberQ[flowRateRequired,True]&&messagesQ,
		Message[Error::InjectionFlowRateRequired,ToString[PickList[{"primary","secondary","tertiary","quaternary"},flowRateRequired,True]],ToString[PickList[{PrimaryInjectionFlowRate,SecondaryInjectionFlowRate,TertiaryInjectionFlowRate,QuaternaryInjectionFlowRate},flowRateRequired,True]]]
	];
	If[MemberQ[flowRateUnneeded,True]&&messagesQ,
		Message[Error::InjectionFlowRateUnneeded,ToString[PickList[{"primary","secondary","tertiary","quaternary"},flowRateUnneeded,True]],ToString[PickList[{PrimaryInjectionFlowRate,SecondaryInjectionFlowRate,TertiaryInjectionFlowRate,QuaternaryInjectionFlowRate},flowRateUnneeded,True]]]
	];

	flowRateConflictQ=MapThread[
		(#1||#2)&,
		{flowRateUnneeded,flowRateRequired}
	];

	(* Track invalid option *)
	If[MemberQ[flowRateConflictQ,True],AppendTo[appendedOptionInvalidities,PickList[{PrimaryInjectionFlowRate,SecondaryInjectionFlowRate,TertiaryInjectionFlowRate,QuaternaryInjectionFlowRate},flowRateConflictQ,True]]];

	(* - Check InjectionSampleStorageCondition - *)

	(* InjectionSampleStorageCondition should only be set if we're injecting *)
	storageCondition=If[
		MatchQ[type,Alternatives[Object[Protocol,NephelometryKinetics],Object[Protocol,Nephelometry]]],
			Lookup[options,{PrimaryInjectionSampleStorageCondition,SecondaryInjectionSampleStorageCondition}],
			Lookup[options,InjectionSampleStorageCondition]
		];
	unneededStorageCondition=!anyInjectionsQ&&MatchQ[storageCondition,Except[ListableP[Null]]];

	(* Create test*)
	If[gatherTestsQ,
		AppendTo[appendedTests,Test["InjectionSampleStorageCondition is only specified when injections are being performed:",unneededStorageCondition,False]]
	];

	(* Throw message *)
	If[unneededStorageCondition&&messagesQ,
		Message[Error::UnneededInjectionStorageCondition]
	];

	(* Track invalid option *)
		If[
			MatchQ[type,Alternatives[Object[Protocol,NephelometryKinetics],Object[Protocol,Nephelometry]]],
			If[unneededStorageCondition,AppendTo[appendedOptionInvalidities,{PrimaryInjectionSampleStorageCondition,SecondaryInjectionSampleStorageCondition}]],
			If[unneededStorageCondition,AppendTo[appendedOptionInvalidities,InjectionSampleStorageCondition]]
		];

	(* Clean-up our list of options with problems *)
	invalidOptions=DeleteDuplicates[Flatten[appendedOptionInvalidities]];

	outputSpecification/.{Result->invalidOptions,Tests->appendedTests}
];


DefineOptions[
	plateReaderResourcePackets,
	Options:>{HelperOutputOption,CacheOption,SimulationOption}
];

plateReaderResourcePackets[type:(Object[Protocol,FluorescenceIntensity]|Object[Protocol,FluorescenceKinetics]|Object[Protocol,FluorescencePolarization]|Object[Protocol,FluorescencePolarizationKinetics]|Object[Protocol,FluorescenceSpectroscopy]|Object[Protocol,LuminescenceIntensity]|Object[Protocol,LuminescenceKinetics]|Object[Protocol,LuminescenceSpectroscopy]),mySamples:{ObjectP[Object[Sample]]...},templatedOptions:{(_Rule|_RuleDelayed)...},resolvedOptions:{(_Rule|_RuleDelayed)..},ops:OptionsPattern[]]:=Module[
	{experimentFunction,primitiveHead,outputSpecification,output,gatherTestsQ,protocolID,cache,simulation,updatedSimulation,
	numberOfReplicates,replicatedSamples,replicatedOptions,simulatedSamples,injectionObjects,uniqueInjectionSamples,resolvedPlateReader,
	plateReaderDownloadField,samplePackets,downloadedInjectionValues,
	plateReaderModel,samplesInDownload,simulatedSampleDownload,sampleObjects,sampleContainers,simulatedWells,injectionContainers,injectionContainerModels,
	injectionContainerLookup,containerModelLookup,requiredVolumes,sampleVolumeTuples,uniqueSampleVolumeTuples,
	uniqueSampleResources,sampleResourceLookup,sampleResources,resolvedPlateReaderMixTime,numberOfInjectionContainers,plateReaderTime,
	plateReaderResource,populateInjectionFieldFunction,primaryInjections,secondaryInjections,tertiaryInjections,
	quaternaryInjections,injectionSampleVolumeAssociation,allowedInjectionContainers,injectionSampleToResourceLookup,
	primaryInjectionWithResources,secondaryInjectionsWithResources,tertiaryInjectionsWithResources,quaternaryInjectionsWithResources,
	anyInjectionsQ,washVolume,primaryCleaningSolvent,adjustmentSampleFromOptions,
	secondaryCleaningSolvent,injectorCleaningFields,resolvedFocalHeight,resolvedGains,resolvedDualEmissionGains,
	paddedGains,paddedGainPercentages,paddedDualEmissionGains,paddedDualEmissionGainPercentages,
	opticModuleDownload,opticModuleFields,opticModuleModels,filterExcitationWavelengths,filterEmissionWavelengths,filterSecondaryEmissionWavelengths,filterPolarizations,resolvedExcitationWavelengths,resolveOpticModules,resolvedOpticModules,resolvedEmissionWavelengths,resolvedDualEmissionWavelengths,
	excitationScanGain,emissionScanGain,parentProtocol,adjustmentSample,adjustmentSampleWell,adjustmentSampleResource,uniqueSampleContainers,
	containerResources,protocolPacket,intensityAndKineticsFields,sampleLabelsWithReplicates,
	fkAndfiFields,fpFields,fpKineticsFields,kineticsFields,specificFields,prepPacket,finalizedPacket,allResourceBlobs,resourcesOk,resourceTests,
	resolvedPreparation,nonHiddenOptions,unitOperationPackets,rawResourceBlobs,resourcesWithoutName,resourceToNameReplaceRules,previewRule,resultRule,testsRule, optionsRule,
	focalHeight, autoFocalHeight, adjustmentSampleResourceRule, listedAdjustmentSampleFromOptions, adjustmentSampleListed,adjustmentSampleWellListed},

	experimentFunction=type/.{
		Object[Protocol,FluorescenceIntensity]->ExperimentFluorescenceIntensity,
		Object[Protocol,FluorescenceKinetics]->ExperimentFluorescenceKinetics,
		Object[Protocol,FluorescencePolarization]->ExperimentFluorescencePolarization,
		Object[Protocol,FluorescencePolarizationKinetics]->ExperimentFluorescencePolarizationKinetics,
		Object[Protocol,FluorescenceSpectroscopy]->ExperimentFluorescenceSpectroscopy,
		Object[Protocol,LuminescenceIntensity]->ExperimentLuminescenceIntensity,
		Object[Protocol,LuminescenceKinetics]->ExperimentLuminescenceKinetics,
		Object[Protocol,LuminescenceSpectroscopy]->ExperimentLuminescenceSpectroscopy
	};

	primitiveHead=type/.{
		Object[Protocol,FluorescenceIntensity]->FluorescenceIntensity,
		Object[Protocol,FluorescenceKinetics]->FluorescenceKinetics,
		Object[Protocol,FluorescencePolarization]->FluorescencePolarization,
		Object[Protocol,FluorescencePolarizationKinetics]->FluorescencePolarizationKinetics,
		Object[Protocol,FluorescenceSpectroscopy]->FluorescenceSpectroscopy,
		Object[Protocol,LuminescenceIntensity]->LuminescenceIntensity,
		Object[Protocol,LuminescenceKinetics]->LuminescenceKinetics,
		Object[Protocol,LuminescenceSpectroscopy]->LuminescenceSpectroscopy
	};

	(* Determine the requested return value from the function *)
	outputSpecification=OptionDefault[OptionValue[Output]];
	output=ToList[outputSpecification];
	gatherTestsQ=MemberQ[output,Tests];

	(* Generate an ID for the new protocol *)
	protocolID=CreateID[type];

	(* Get cache for Download *)
	cache=OptionDefault[OptionValue[Cache]];

	simulation=OptionDefault[OptionValue[Simulation]];

	(* Determine if we need to make replicate spots *)
	numberOfReplicates=Lookup[resolvedOptions,NumberOfReplicates];

	(* Regenerate the simulations done in the option resolver *)
	{simulatedSamples,updatedSimulation}=simulateSamplesResourcePacketsNew[experimentFunction,Download[mySamples,Object],resolvedOptions,Cache->cache,Simulation->simulation];

	(* -- Download -- *)

	(* Get unique list of all samples to be injected *)
	injectionObjects=DeleteCases[Flatten[Lookup[resolvedOptions,{PrimaryInjectionSample,SecondaryInjectionSample,TertiaryInjectionSample,QuaternaryInjectionSample},Null],1],Null];
	uniqueInjectionSamples=Download[Cases[injectionObjects,ObjectP[Object]],Object];

	(* Lookup specified plate reader *)
	resolvedPlateReader=Lookup[resolvedOptions,Instrument];

	(* Download the model from the object or return the model as is *)
	plateReaderDownloadField=If[MatchQ[resolvedPlateReader,ObjectP[Object[Instrument]]],
		Field[Model[Object]],
		Object
	];

	(* Lookup optic module fields through Model of the plate reader *)
	opticModuleFields=If[MatchQ[resolvedPlateReader,ObjectP[Object[Instrument]]],
		Field[Model[OpticModules][{Object,ExcitationFilterWavelength,EmissionFilterWavelength,SecondaryEmissionFilterWavelength,EmissionPolarizer}]],
		Field[OpticModules[{Object,ExcitationFilterWavelength,EmissionFilterWavelength,SecondaryEmissionFilterWavelength,EmissionPolarizer}]]
	];

	(* Make our download call *)
	{downloadedInjectionValues,{{plateReaderModel}},samplesInDownload,simulatedSampleDownload,opticModuleDownload}=Download[
		{
			uniqueInjectionSamples,
			{resolvedPlateReader},
			mySamples,
			simulatedSamples,
			{resolvedPlateReader}
		},
		{
			{Container[Object],Container[Model][Object]},
			{plateReaderDownloadField},
			{Object,Container[Object]},
			{Well},
			{opticModuleFields}
		},
		Cache->cache,
		Simulation -> updatedSimulation,
		Date->Now
	];



	(* {opticModuleModels,filterExcitationWavelengths,filterEmissionWavelengths,filterSecondaryEmissionWavelengths,filterPolarizations}=Flatten[opticModuleDownload,2];
	The Flatten step here gets rid of the additional brackets from Download call*)
	opticModuleModels=Flatten[opticModuleDownload,2][[All,1]];
	filterExcitationWavelengths=Flatten[opticModuleDownload,2][[All,2]];
	filterEmissionWavelengths=Flatten[opticModuleDownload,2][[All,3]];
	filterSecondaryEmissionWavelengths=Flatten[opticModuleDownload,2][[All,4]];
	filterPolarizations=Flatten[opticModuleDownload,2][[All,5]];

	(* Get a flat list of sample containers and packets *)
	sampleObjects=samplesInDownload[[All,1]];
	sampleContainers=samplesInDownload[[All,2]];

	simulatedWells=simulatedSampleDownload[[All,1]];

	(* Get the injection containers and their models *)
	{injectionContainers,injectionContainerModels}={downloadedInjectionValues[[All,1]],downloadedInjectionValues[[All,2]]};

	(* Create lookups that will give container for each injection sample, model for each injection container *)
	injectionContainerLookup=AssociationThread[uniqueInjectionSamples,injectionContainers];
	containerModelLookup=AssociationThread[injectionContainers,injectionContainerModels];

	(* If user has asked for replicates, repeat the sample and the option that number of times *)
	{replicatedSamples,replicatedOptions}=expandFluorescenceReplicates[experimentFunction,sampleObjects,resolvedOptions,numberOfReplicates];

	(* --- Generate Resources for the SamplesIn --- *)
	(* Determine how much volume we're going to need from each sample *)
	requiredVolumes=Replace[Lookup[replicatedOptions,AliquotAmount],Null->0 Milliliter,{1}];

	(* Generate a list of pairs in the form {sample,volume needed} *)
	sampleVolumeTuples=Transpose[{replicatedSamples,requiredVolumes}];

	(* Gather up samples that appear multiple times and get the total volume needed from each *)
	uniqueSampleVolumeTuples=Map[
		{#[[1,1]],Total[#[[All,2]]]}&,
		GatherBy[sampleVolumeTuples,First]
	];

	(* Make a list of unique sample resources - requesting volume if *)
	uniqueSampleResources=Resource[Sample->First[#],Amount->Last[#],Name->ToString[Unique[]]]&/@uniqueSampleVolumeTuples;

	(* Create a little lookup between unique samples and resources and then get the right resource for each sample so we can preserve index-matching *)
	sampleResourceLookup=AssociationThread[uniqueSampleVolumeTuples[[All,1]]->uniqueSampleResources];
	sampleResources=Lookup[sampleResourceLookup,#]&/@replicatedSamples;

	(* - Generate Instrument resource - *)

	(* Lookup relevant options *)
	resolvedPlateReaderMixTime=Lookup[replicatedOptions,PlateReaderMixTime];

	(* Estimate how long the plate reader will be needed *)
	numberOfInjectionContainers=Length[DeleteDuplicates[injectionObjects]];
	plateReaderTime=15 Minute +
		(resolvedPlateReaderMixTime/.Null->0 Minute) +
		(* If this is a FK/LK protocol, need to add RunTime *)
		(If[MatchQ[type,Object[Protocol,FluorescenceKinetics]|Object[Protocol,LuminescenceKinetics]],Lookup[replicatedOptions,RunTime],0*Minute])+
		(* Add time needed to clean/prime each each injection line *)
		(If[numberOfInjectionContainers>0,numberOfInjectionContainers*15*Minute,0*Minute]);

	(* Create the resource *)
	plateReaderResource=Resource[Instrument->resolvedPlateReader,Time->plateReaderTime];

	(* == Define Function: populateInjectionFieldFunction == *)
	(* Format a set of injection options into the structure used for the corresponding injection field *)
	(* Fluorescence Kinetics overload - field formatted as {{time, sample, volume}..}*)
	populateInjectionFieldFunction[Object[Protocol,FluorescenceKinetics]|Object[Protocol,FluorescencePolarizationKinetics]|Object[Protocol,LuminescenceKinetics],injectionVolumes_,injectionSamples_,injectionTime_]:=Module[
		{injectionSampleObjects,injectionSample,injectionTuples,injectionFieldValue},

		injectionSampleObjects=Download[injectionSamples,Object];

		(* Sample we're injecting (injectionSampleObjects will be a mix of Nulls and repeated object) *)
		injectionSample=FirstCase[injectionSampleObjects,ObjectP[]];

		injectionTuples=Prepend[#,injectionTime]&/@Transpose[{injectionSampleObjects,injectionVolumes}];

		injectionFieldValue=If[MemberQ[injectionVolumes,VolumeP],
			(* Replace {Null,Null,Null} with {time, sample, 0 Microliter} as a placeholder to keep index-matching *)
			Replace[injectionTuples, {TimeP,Null, Null} :> {injectionTime, Null, 0 Microliter}, {1}],
			{}
		]
	];

	(* == Define Function: populateInjectionFieldFunction == *)
	(* Format a set of injection options into the structure used for the corresponding injection field *)
	(* Fluorescence Intensity overload - field formatted as {{sample, volume}..} *)
	populateInjectionFieldFunction[Object[Protocol,FluorescenceIntensity]|Object[Protocol,FluorescencePolarization]|Object[Protocol,FluorescenceSpectroscopy]|Object[Protocol,LuminescenceIntensity]|Object[Protocol,LuminescenceSpectroscopy],injectionVolumes_,injectionSamples_,injectionTime_]:=Module[
		{injectionSampleObjects,injectionSample,injectionFieldValue},

		injectionSampleObjects=Download[injectionSamples,Object];

		injectionSample=FirstCase[injectionSampleObjects,ObjectP[]];

		injectionFieldValue=If[MemberQ[injectionVolumes,VolumeP],
			(* Replace {Null,Null} with {sample, 0 Microliter} as a placeholder to keep index-matching *)
			Replace[Transpose[{injectionSampleObjects,injectionVolumes}], {Null, Null} :> {Null, 0 Microliter}, {1}],
			{}
		]
	];

	(* Format injections as tuples index-matched to samples in. These will look different depending on the experiment:
		FI is in the form {{time, sample, volume}..}
		FK is in the form {{sample, volume}..}
	*)
	(* Note: wells which aren't receiving injections will have sample=Null, volume=0 Microliter *)
	primaryInjections=populateInjectionFieldFunction[type,Lookup[replicatedOptions,PrimaryInjectionVolume],Lookup[replicatedOptions,PrimaryInjectionSample],Lookup[replicatedOptions,PrimaryInjectionTime]];
	secondaryInjections=populateInjectionFieldFunction[type,Lookup[replicatedOptions,SecondaryInjectionVolume],Lookup[replicatedOptions,SecondaryInjectionSample],Lookup[replicatedOptions,SecondaryInjectionTime]];
	tertiaryInjections=populateInjectionFieldFunction[type,Lookup[replicatedOptions,TertiaryInjectionVolume],Lookup[replicatedOptions,TertiaryInjectionSample],Lookup[replicatedOptions,TertiaryInjectionTime]];
	quaternaryInjections=populateInjectionFieldFunction[type,Lookup[replicatedOptions,QuaternaryInjectionVolume],Lookup[replicatedOptions,QuaternaryInjectionSample],Lookup[replicatedOptions,QuaternaryInjectionTime]];

	(* Get assoc in the form <|(sample -> total volume needed)..|> *)
	(* Note: regardless of experiment, second to last entry will be sample, last entry will be volume *)
	injectionSampleVolumeAssociation=KeyDrop[GroupBy[Join[primaryInjections,secondaryInjections,tertiaryInjections],(#[[-2]]&)->(#[[-1]]&), Total],Null];

	(* Track containers which can be used to hold injection samples - plate readers have spots for 2mL, 15mL and 50mL tubes *)
	allowedInjectionContainers=Search[Model[Container, Vessel],Footprint==(Conical50mLTube|Conical15mLTube|MicrocentrifugeTube)&&Deprecated!=True];

	(* Create a single resource for each unique injection sample *)
	injectionSampleToResourceLookup=KeyValueMap[
		Module[{sample,volume,injectionContainer,injectionContainerModel,resource},
			{sample,volume}={#1,#2};

			(* Lookup sample's container model *)
			injectionContainer=Lookup[injectionContainerLookup,sample];
			injectionContainerModel=Lookup[containerModelLookup,injectionContainer,Null];

			(* Create a resource for the sample *)
			resource=If[MatchQ[sample,Null],
				Null,
				Resource@@{
					Sample->sample,
					(* Include volume lost due to priming lines (compiler sets to 1mL)
					- prime should account for all needed dead volume - prime fluid stays in syringe/line (which have vol of ~750 uL) *)
					Amount->(volume + $BMGPrimeVolume),

					(* Specify a container if we're working with a model or if current container isn't workable *)
					If[MatchQ[injectionContainerModel,ObjectP[allowedInjectionContainers]],
						Nothing,
						Container -> PreferredContainer[volume + $BMGPrimeVolume,Type->Vessel]
					],
					Name->ToString[Unique[]]
				}
			];
			sample->resource
		]&,
		injectionSampleVolumeAssociation
	];

	(* Replace injection samples with resources for those samples *)
	{primaryInjectionWithResources,secondaryInjectionsWithResources,tertiaryInjectionsWithResources,quaternaryInjectionsWithResources}=Map[
		Function[{injectionEntries},
			If[MatchQ[injectionEntries,{}],
				{},
				Module[{injectionSample,injectionResource},
					(* Get injection sample for the group  - regardless of experiment, second to last entry will be sample, last entry will be volume *)
					injectionSample=FirstCase[injectionEntries[[All,-2]],ObjectP[]];

					(* Find resource created for that sample *)
					injectionResource=Lookup[injectionSampleToResourceLookup,injectionSample];

					(* Replace any injection objects with corresponding resource *)
					Replace[injectionEntries,{time___,ObjectP[],volume___}:>{time,injectionResource,volume},{1}]
				]
			]
		],
		{primaryInjections,secondaryInjections,tertiaryInjections,quaternaryInjections}
	];

	(*  --- Select optic modules for Pherastar --- *)

	(* Get resolved wavelengths to compare against optic modules *)
	{resolvedExcitationWavelengths,resolvedEmissionWavelengths,resolvedDualEmissionWavelengths}=Lookup[replicatedOptions,{ExcitationWavelength,EmissionWavelength,DualEmissionWavelength}];
	
    (* Map through available optic modules, selecting modules matching the resolved wavelengths *)
    resolveOpticModules[resolvedExcitationWavelength_,resolvedEmissionWavelength_,resolvedDualEmissionWavelength_]:=MapThread[
        Function[{opticModuleModel, filterExcitationWavelength, filterEmissionWavelength, filterSecondaryEmissionWavelength, filterPolarization},
            Module[{excitationMatch,emissionsResolved,emissionMatch,polarizationRequired,polarizationMatch},
                (* Boolean, resolved excitation wavelength matches filter wavelength**)

                excitationMatch=MatchQ[resolvedExcitationWavelength,filterExcitationWavelength];

								(* Determine match between resolved emission wavelengths and module emission filters *)
                emissionsResolved=Cases[{resolvedEmissionWavelength,resolvedDualEmissionWavelength},DistanceP];
								(* Check whether the optic module can work for the resolved wavelength pairs *)
								emissionMatch=If[Length[emissionsResolved]==1,

									(* If there is only one emission wavelength, we can select an optic module as long as it covers this wavelength *)
									ContainsAll[{filterEmissionWavelength,filterSecondaryEmissionWavelength},emissionsResolved],

									(* If there are two wavelengths, they must match the optic module wavelengths exactly *)
									MatchQ[emissionsResolved,{filterEmissionWavelength,filterSecondaryEmissionWavelength}|{filterSecondaryEmissionWavelength,filterEmissionWavelength}]

								];

                (* Module supports polarization *)
								polarizationRequired=MatchQ[type,Object[Protocol,FluorescencePolarization]|Object[Protocol,FluorescencePolarizationKinetics]];
								(* Check whether the provided polarization of the optic module matches the required experiment type *)
								(* Xnor is equivalent to (a&&b)||(!a&&!b). It yields True when the given values are True/True of False/False - in other words, polarizationMatch is True only when the optic module polarization matches the polarization requirement of the experiment *)
								polarizationMatch=Xnor[polarizationRequired,!MatchQ[filterPolarization,Null]];

                If[excitationMatch&&emissionMatch&&polarizationMatch,
									(* Qualified polarization module *)
									opticModuleModel,
									Nothing
								]
            ]
        ],
				{opticModuleModels,filterExcitationWavelengths,filterEmissionWavelengths,filterSecondaryEmissionWavelengths,filterPolarizations}
    ];


    (* Matches resolved wavelengths with optic module filters, and returns the first qualified module*)	
    resolvedOpticModules=If[MatchQ[plateReaderModel,ObjectP[Model[Instrument, PlateReader, "id:01G6nvkKr3o7"]]]&&MatchQ[experimentFunction,ExperimentFluorescenceIntensity|ExperimentFluorescenceKinetics|ExperimentFluorescencePolarization|ExperimentFluorescencePolarizationKinetics]&&!MatchQ[opticModuleDownload,Null],
        MapThread[
					(* For each set of wavelength requirements, we can find the qualified list of optic modules. As we map through all the optic modules to find the qualified ones, it returns as a list. Every optic module in the list will work for the required experiment. Taking only the first here so the pattern will match the protocol field of OpticModules - list instead of {{..}..}. *)
            First[resolveOpticModules[#1,#2,#3]]&,
            {resolvedExcitationWavelengths,resolvedEmissionWavelengths,resolvedDualEmissionWavelengths}
        ]
    ];


	(*  --- Create resources to clean the injectors and lines --- *)

	(* Track whether or not we're injecting anything *)
	anyInjectionsQ=MemberQ[Flatten[Lookup[replicatedOptions,{PrimaryInjectionVolume,SecondaryInjectionVolume,TertiaryInjectionVolume,QuaternaryInjectionVolume}]],VolumeP];

	(* Wash each line being used with the flush volume - request a little extra to avoid air in the lines *)
	(* Always multiply by 2 - either we'll use same resource for prepping and flushing or we have two lines to flush *)
	washVolume=($BMGFlushVolume + 2.5 Milliliter) * 2;

	(* Create solvent resources to clean the lines *)
	primaryCleaningSolvent=Resource@@{
		Sample->Model[Sample,StockSolution,"id:BYDOjv1VA7Zr"] (* 70% Ethanol *),
		Amount->washVolume,
		Container->Model[Container,Vessel,"id:bq9LA0dBGGR6"],
		(* If we have only one injection container then we are only priming one line and we can use the same resource for set-up and tear-down *)
		If[numberOfInjectionContainers==1,
			Name->"Primary Cleaning Solvent",
			Nothing
		]
	};

	secondaryCleaningSolvent=Resource@@{
		Sample->Model[Sample,"id:8qZ1VWNmdLBD"] (*Milli-Q water *),
		Amount->washVolume,
		Container->Model[Container,Vessel,"id:bq9LA0dBGGR6"],
		(* If we have only one injection container then we are only priming one line and we can use the same resource for set-up and tear-down *)
		If[numberOfInjectionContainers==1,
			Name->"Secondary Cleaning Solvent",
			Nothing
		]
	};

	(* Populate fields needed to clean the lines before/after the run *)
	injectorCleaningFields=If[anyInjectionsQ,
		<|
			PrimaryPreppingSolvent->primaryCleaningSolvent,
			PrimaryFlushingSolvent->primaryCleaningSolvent,
			SecondaryPreppingSolvent->secondaryCleaningSolvent,
			SecondaryFlushingSolvent ->secondaryCleaningSolvent
		|>,
		<||>
	];

	(* Lookup some options to more easily prepare protocol packet *)
	(* Gain and DualEmissionGain are only options to intensity and kinetics protocols *)
	(* ExcitationScanGain,EmissionScanGain are only options to spectroscopy protocols *)
	{resolvedFocalHeight,resolvedGains,resolvedDualEmissionGains,excitationScanGain,emissionScanGain,parentProtocol}=Lookup[
		replicatedOptions,
		{FocalHeight,Gain,DualEmissionGain,ExcitationScanGain,EmissionScanGain,ParentProtocol},
		Null
	];

	(* Gain option is given as a percentage or a voltage which we split into two different fields *)
	(* To preserve index-matching of gain fields to emission wavelengths, insert Nulls as needed
	 	e.g. Gain->{70%,2500 mv, 90%} becomes Gain -> {Null, 2500 mv, Null} and GainPercentage -> {70%, Null, 90%}
	 *)
	{paddedGains,paddedGainPercentages}=If[MatchQ[resolvedDualEmissionGains,Null],
		{{},{}},
		Transpose@Map[
			If[MatchQ[#,PercentP],
				{Null,#},
				{#,Null}
			]&,
			resolvedGains
		]
	];

	(* Repeat our padding for Null with dual emission gains *)
	{paddedDualEmissionGains,paddedDualEmissionGainPercentages}=If[MatchQ[resolvedDualEmissionGains,Null],
		{{},{}},
		Transpose@Map[
			If[MatchQ[#,PercentP],
				{Null,#},
				{#,Null}
			]&,
			resolvedDualEmissionGains
		]
	];

	(* Determine the well which our adjustment sample will end up in *)
	adjustmentSampleFromOptions = Lookup[replicatedOptions,AdjustmentSample];

	listedAdjustmentSampleFromOptions = If[MatchQ[adjustmentSampleFromOptions, {_Integer, ObjectP[]}|Except[_List]],
		{adjustmentSampleFromOptions},
		adjustmentSampleFromOptions
	];
	{adjustmentSampleListed,adjustmentSampleWellListed} = Transpose@Map[
		If[!MatchQ[#, Null|FullPlate],
			Module[
				{index,sample,sampleObject,aliquotBooleans,destinationWells,well},
				{index,sample}=#;
				sampleObject=Download[sample,Object];

				(* Lookup relevant options *)
				{aliquotBooleans,destinationWells}=Lookup[resolvedOptions,{Aliquot,DestinationWell}];

				(* If we're aliquoting figure out which aliquot of our adjustment sample is the one we want to use *)
				well=If[MatchQ[aliquotBooleans,{True..}],
					Module[{adjustmentWells,replicates},
						(* Get all the wells which will receive aliquots of our samples *)
						adjustmentWells=PickList[destinationWells,replicatedSamples,sampleObject];

						(* Account for the fact that if we're doing replicates it's going to shift our index over *)
						(* e.g. if sampleObjects=ABBC, index=2 and numberOfReplicates=2 then replicatesSamples is AABBBBCC *)
						(* we now want to look at B in the third position since the second position is just a replicate of the first B *)
						replicates=numberOfReplicates/.Null->1;
						adjustmentWells[[index+(index-1)*(replicates-1)]]
					],
					(* In our standard case, look at the well the sample will end up in *)
					Module[{samplesAndWells},
						samplesAndWells=Transpose[{sampleObjects,simulatedWells}];
						FirstCase[samplesAndWells,{sampleObject,_}][[2]]
					]
				];
				{sampleObject,well}

			],
			{Null, Null}
		]&,
		listedAdjustmentSampleFromOptions
	];

	{adjustmentSample,adjustmentSampleWell} = If[MatchQ[type, Object[Protocol, FluorescenceSpectroscopy]|Object[Protocol, LuminescenceSpectroscopy]],
		{First@adjustmentSampleListed,First@adjustmentSampleWellListed},
		{adjustmentSampleListed,adjustmentSampleWellListed}
	];

	adjustmentSampleResource=Lookup[sampleResourceLookup,adjustmentSample,Null];

	adjustmentSampleResourceRule = If[MatchQ[adjustmentSample, _List],
		MapThread[#1 -> Link[#2]&, {adjustmentSample, adjustmentSampleResource}],
		{adjustmentSample -> adjustmentSampleResource}
	];

	(* Get ContainersIn *)
	uniqueSampleContainers=DeleteDuplicates[sampleContainers];
	containerResources=Link[Resource[Sample->#],Protocols]&/@uniqueSampleContainers;


	(* -- Generate our unit operation packet -- *)
	resolvedPreparation = Lookup[replicatedOptions,Preparation];

	(* expand sample labels for replicates *)
	sampleLabelsWithReplicates = Lookup[replicatedOptions, SampleLabel];

	(* get the non hidden options *)
	nonHiddenOptions=Lookup[
		Cases[OptionDefinition[experimentFunction], KeyValuePattern["Category"->Except["Hidden"]]],
		"OptionSymbol"
	];
	focalHeight = If[MatchQ[type, Object[Protocol, FluorescenceSpectroscopy]|Object[Protocol, LuminescenceSpectroscopy]],
		If[DistanceQ[resolvedFocalHeight],
			resolvedFocalHeight
		],
		Replace[resolvedFocalHeight, Except[DistanceP] -> Null, {1}]
	];

	autoFocalHeight = If[MatchQ[type, Object[Protocol, FluorescenceSpectroscopy]|Object[Protocol, LuminescenceSpectroscopy]],
		If[MatchQ[resolvedFocalHeight, Auto],
			True
		],
		If[MatchQ[#,Auto],
			True
		]&/@resolvedFocalHeight
	];


	{finalizedPacket, unitOperationPackets} = If[MatchQ[resolvedPreparation,Manual],
		Module[{protocolPacket, intensityAndKineticsFields, fkAndfiFields, fpFields, fpKineticsFields, kineticsFields, specificFields, prepPacket, singleMultiplefields},
			(* Create a protocol packet *)
			protocolPacket=<|
				Type->type,
				Object->protocolID,
				Author->If[MatchQ[parentProtocol,None],
					Link[$PersonID,ProtocolsAuthored]
				],
				ParentProtocol->If[MatchQ[parentProtocol,ObjectP[ProtocolTypes[]]],
					Link[parentProtocol,Subprotocols]
				],
				Replace[ContainersIn]->containerResources,
				Replace[SamplesIn]->sampleResources,

				UnresolvedOptions->templatedOptions,
				ResolvedOptions->resolvedOptions,

				Name->Lookup[replicatedOptions,Name],
				Instrument->plateReaderResource,
				Temperature->(Lookup[replicatedOptions,Temperature]/.Ambient->Null),
				EquilibrationTime->Lookup[replicatedOptions,EquilibrationTime],
				ReadLocation->Lookup[replicatedOptions,ReadLocation],
				ReadDirection->Lookup[replicatedOptions,ReadDirection],
				RetainCover->Lookup[replicatedOptions,RetainCover],

				SamplingPattern->Lookup[replicatedOptions,SamplingPattern],
				SamplingDistance->Lookup[replicatedOptions,SamplingDistance],
				SamplingDimension->Lookup[replicatedOptions,SamplingDimension],

				Replace[PrimaryInjections]->primaryInjectionWithResources,
				Replace[SecondaryInjections]->secondaryInjectionsWithResources,

				InjectionStorageCondition->Lookup[replicatedOptions,InjectionSampleStorageCondition],
				PrimaryInjectionFlowRate->Lookup[replicatedOptions,PrimaryInjectionFlowRate],
				SecondaryInjectionFlowRate->Lookup[replicatedOptions,SecondaryInjectionFlowRate],
				PlateReaderMix->Lookup[replicatedOptions,PlateReaderMix],
				PlateReaderMixRate->Lookup[replicatedOptions,PlateReaderMixRate],
				PlateReaderMixTime->resolvedPlateReaderMixTime,
				PlateReaderMixMode->Lookup[replicatedOptions,PlateReaderMixMode],
				MoatSize->Lookup[replicatedOptions,MoatSize],
				MoatBuffer->Link[Lookup[replicatedOptions,MoatBuffer]],
				MoatVolume->Lookup[replicatedOptions,MoatVolume],
				(*RetainCover->Lookup[replicatedOptions,RetainCover],*)
				ImageSample->Lookup[replicatedOptions,ImageSample],

				Replace[Checkpoints] -> {
					{"Picking Resources", 30 Minute,"Samples required to execute this protocol are gathered from storage.",
						Link[Resource[Operator->Model[User, Emerald, Operator, "Trainee"],Time->30 Minute]]
					},
					{"Preparing Samples", 45 Minute,"Preprocessing, such as mixing, centrifuging, thermal incubation, and aliquoting, is performed.",
						Link[Resource[Operator->Model[User, Emerald, Operator, "Trainee"],Time->45 Minute]]
					},
					{"Acquiring Data", plateReaderTime,"Change in fluorescence is monitored in the samples over a fixed time period.",
						Link[Resource[Operator->Model[User, Emerald, Operator, "Trainee"],Time->plateReaderTime]]
					},
					{"Sample Post-Processing", 15 Minute,"Any measuring of volume, weight, or sample imaging post experiment is performed.",
						Link[Resource[Operator->Model[User, Emerald, Operator, "Trainee"],Time->15 Minute]]
					},
					{"Returning Materials", 15 Minute,"Samples are returned to storage.",
						Link[Resource[Operator->Model[User, Emerald, Operator, "Trainee"],Time->15 Minute]]
					}
				},
				If[MatchQ[resolvedPreparation,Robotic],Replace[BatchedUnitOperations]->(Link[#, Protocol]&)/@ToList[Lookup[unitOperationPackets, Object]],Nothing]
			|>;

			singleMultiplefields = If[MatchQ[type, Object[Protocol, FluorescenceSpectroscopy]|Object[Protocol, LuminescenceSpectroscopy]],
				(* For Spectroscopy protocols the following fields present: FocalHeight, AutoFocalHeight, AdjustmentSample, AdjustmentSampleWell, all are single fields *)
				<|
					FocalHeight->focalHeight,
					AutoFocalHeight->autoFocalHeight,
					AdjustmentSampleWell->adjustmentSampleWell,
					AdjustmentSample->adjustmentSampleResource
				|>,
				(* For other type of protocols the following fields present: FocalHeights, AutoFocalHeights, AdjustmentSamples, AdjustmentSampleWells, all are multiple fields *)
				<|
					Replace[FocalHeights]->focalHeight,
					Replace[AutoFocalHeights]->autoFocalHeight,
					Replace[AdjustmentSampleWells]->adjustmentSampleWell,
					Replace[AdjustmentSamples]->adjustmentSampleResource
				|>
			];

			intensityAndKineticsFields=<|
				Replace[EmissionWavelengths]->(Lookup[replicatedOptions,EmissionWavelength]/.{NoFilter->Null}),
				Replace[DualEmissionWavelengths]->If[MatchQ[plateReaderModel,ObjectP[Model[Instrument,PlateReader,"id:01G6nvkKr3o7"]]],
					Lookup[replicatedOptions,DualEmissionWavelength],
					{}
				],
				Replace[Gains]->paddedGains,
				Replace[GainPercentages]->paddedGainPercentages,
				WavelengthSelection->Lookup[replicatedOptions,WavelengthSelection],
				DualEmission->MemberQ[Lookup[replicatedOptions,DualEmissionWavelength],DistanceP],
				Replace[DualEmissionGains]->paddedDualEmissionGains,
				Replace[DualEmissionGainPercentages]->paddedDualEmissionGainPercentages,
				Replace[OpticModules]->Link[resolvedOpticModules]
			|>;

			fkAndfiFields=<|
				Replace[ExcitationWavelengths]->Lookup[replicatedOptions,ExcitationWavelength],
				Mode->Lookup[replicatedOptions,Mode],
				NumberOfReadings->Lookup[replicatedOptions,NumberOfReadings],
				DelayTime->Lookup[replicatedOptions,DelayTime],
				ReadTime->Lookup[replicatedOptions,ReadTime]
			|>;

			fpFields=<|
				Replace[ExcitationWavelengths]->Lookup[replicatedOptions,ExcitationWavelength],
				Mode->Fluorescence,
				NumberOfReadings->Lookup[replicatedOptions,NumberOfReadings],
				(* This is added here because we don't have option WavelengthSelection in ExperimentPolarization and ExperimentPolarizationKinetics. In intensityAndKineticsFields, it was returned as Missing in the Lookup above. For FP/FPK, the WavelengthSelection can only be Filters *)
				WavelengthSelection->Filters,
				TargetPolarization->Lookup[replicatedOptions,TargetPolarization]
			|>;

			fpKineticsFields=<|
				Replace[ExcitationWavelengths]->Lookup[replicatedOptions,ExcitationWavelength],
				Mode->Fluorescence,
				NumberOfReadings->Lookup[replicatedOptions,NumberOfReadings],
				(* This is added here because we don't have option WavelengthSelection in ExperimentPolarization and ExperimentPolarizationKinetics. In intensityAndKineticsFields, it was returned as Missing in the Lookup above. For FP/FPK, the WavelengthSelection can only be Filters *)
				WavelengthSelection->Filters,
				TargetPolarization->Lookup[replicatedOptions,TargetPolarization]
			|>;

			kineticsFields=<|
				RunTime->Lookup[replicatedOptions,RunTime],
				ReadOrder->Lookup[replicatedOptions,ReadOrder],
				PlateReaderMixSchedule->Lookup[replicatedOptions,PlateReaderMixSchedule],
				Replace[TertiaryInjections]->tertiaryInjectionsWithResources,
				Replace[QuaternaryInjections]->quaternaryInjectionsWithResources,
				TertiaryInjectionFlowRate->Lookup[replicatedOptions,TertiaryInjectionFlowRate],
				QuaternaryInjectionFlowRate->Lookup[replicatedOptions,QuaternaryInjectionFlowRate]
			|>;

			(* Populate fields specific to one protocol type *)
			specificFields=Switch[type,
				Object[Protocol,FluorescenceKinetics],Join[
					kineticsFields,
					intensityAndKineticsFields,
					fkAndfiFields
				],
				Object[Protocol,FluorescencePolarizationKinetics],Join[
					kineticsFields,
					intensityAndKineticsFields,
					fpKineticsFields
				],
				Object[Protocol,FluorescenceIntensity],Join[intensityAndKineticsFields,fkAndfiFields],
				Object[Protocol,FluorescencePolarization],Join[intensityAndKineticsFields,fpFields],
				Object[Protocol,FluorescenceSpectroscopy],<|
					NumberOfReadings->Lookup[replicatedOptions,NumberOfReadings],
					Replace[SpectralScan]->ToList[Lookup[replicatedOptions,SpectralScan]],

					ExcitationWavelength->Lookup[replicatedOptions,ExcitationWavelength],
					MinEmissionWavelength->Replace[Lookup[replicatedOptions,EmissionWavelengthRange],Span[min_,max_]:>min],
					MaxEmissionWavelength->Replace[Lookup[replicatedOptions,EmissionWavelengthRange],Span[min_,max_]:>max],

					EmissionWavelength->Lookup[replicatedOptions,EmissionWavelength],
					MinExcitationWavelength->Replace[Lookup[replicatedOptions,ExcitationWavelengthRange],Span[min_,max_]:>min],
					MaxExcitationWavelength->Replace[Lookup[replicatedOptions,ExcitationWavelengthRange],Span[min_,max_]:>max],

					AdjustmentEmissionWavelength->Lookup[replicatedOptions,AdjustmentEmissionWavelength],
					AdjustmentExcitationWavelength->Lookup[replicatedOptions,AdjustmentExcitationWavelength],

					ExcitationScanGain->If[VoltageQ[excitationScanGain],
						excitationScanGain
					],
					ExcitationScanGainPercentage->If[PercentQ[excitationScanGain],
						excitationScanGain
					],
					EmissionScanGain->If[VoltageQ[emissionScanGain],
						emissionScanGain
					],
					EmissionScanGainPercentage->If[PercentQ[emissionScanGain],
						emissionScanGain
					]
				|>,
				Object[Protocol,LuminescenceIntensity],Join[
					intensityAndKineticsFields,
					<|IntegrationTime->Lookup[replicatedOptions,IntegrationTime]|>
				],
				Object[Protocol,LuminescenceKinetics],Join[
					intensityAndKineticsFields,
					kineticsFields,
					<|IntegrationTime->Lookup[replicatedOptions,IntegrationTime]|>
				],
				Object[Protocol,LuminescenceSpectroscopy],<|
					MinEmissionWavelength->Replace[Lookup[replicatedOptions,EmissionWavelengthRange],Span[min_,max_]:>min],
					MaxEmissionWavelength->Replace[Lookup[replicatedOptions,EmissionWavelengthRange],Span[min_,max_]:>max],
					AdjustmentEmissionWavelength->Lookup[replicatedOptions,AdjustmentEmissionWavelength],
					(* In the case of LuminescenceSpectroscopy, resolvedGains will actually be a single *)
					Gain->If[MatchQ[resolvedGains,VoltageP],resolvedGains],
					GainPercentage->If[MatchQ[resolvedGains,PercentP],resolvedGains],
					IntegrationTime->Lookup[replicatedOptions,IntegrationTime]
				|>
			];

			(* Populate prep fields - send in initial samples and options since this handles NumberOfReplicates on its own *)
			prepPacket=populateSamplePrepFields[sampleObjects,resolvedOptions, Cache -> cache, Simulation -> updatedSimulation];

			{
				Join[injectorCleaningFields,protocolPacket,specificFields,prepPacket, singleMultiplefields],
				{}
			}
		],
		Module[{unitOpPacket,unitOperationPacketWithLabeledObjects},
			unitOpPacket = UploadUnitOperation[
				primitiveHead@@Join[
					{
						Sample->sampleResources
					},
					ReplaceRule[
						Cases[replicatedOptions, Verbatim[Rule][Alternatives@@nonHiddenOptions, _]],
						{
							Instrument -> plateReaderResource,
							(* AdjustmentSample is in the form {index,sample} or FullPlate *)
							AdjustmentSample->Module[{testVarTest2},
								testVarTest2 = Switch[
									{Lookup[replicatedOptions, AdjustmentSample], type},
									{Null | FullPlate, _},
										Lookup[replicatedOptions,AdjustmentSample],
									{{_Integer, ObjectP[{Model[Sample], Object[Sample]}]}, Object[Protocol, FluorescenceSpectroscopy]|Object[Protocol, LuminescenceSpectroscopy]},
										Lookup[replicatedOptions,AdjustmentSample]/.adjustmentSampleResourceRule,
									{{_Integer, ObjectP[{Model[Sample], Object[Sample]}]}, _},
										{Lookup[replicatedOptions,AdjustmentSample]/.adjustmentSampleResourceRule},
									_,
									Lookup[replicatedOptions,AdjustmentSample]/.adjustmentSampleResourceRule
								]
							],
							(* injection sample resources are always in second to last position for all experiments *)
							PrimaryInjectionSample->If[Length[primaryInjectionWithResources[[All,-2]]]==0,
								ConstantArray[Null, Length[mySamples]],
								primaryInjectionWithResources[[All,-2]]
							],
							SecondaryInjectionSample->If[Length[secondaryInjectionsWithResources[[All,-2]]]==0,
								ConstantArray[Null, Length[mySamples]],
								secondaryInjectionsWithResources[[All,-2]]
							],
							(* kinetics only *)
							If[MatchQ[experimentFunction,ExperimentFluorescenceKinetics|ExperimentFluorescencePolarizationKinetics|ExperimentLuminescenceKinetics],
								TertiaryInjectionSample->If[Length[tertiaryInjectionsWithResources[[All,-2]]]==0,
									ConstantArray[Null, Length[mySamples]],
									tertiaryInjectionsWithResources[[All,-2]]
								],
								Nothing
							],
							If[MatchQ[experimentFunction,ExperimentFluorescenceKinetics|ExperimentFluorescencePolarizationKinetics|ExperimentLuminescenceKinetics],
								QuaternaryInjectionSample->If[Length[quaternaryInjectionsWithResources[[All,-2]]]==0,
									ConstantArray[Null, Length[mySamples]],
									quaternaryInjectionsWithResources[[All,-2]]
								],
								Nothing
							],
							(* NOTE: Don't pass Name down. *)
							Name->Null
						}
					],
					{SampleLabel->sampleLabelsWithReplicates}
				],
				Preparation->Robotic,
				UnitOperationType->Output,
				FastTrack->True,
				Upload->False
			];

			(* Add the LabeledObjects field to the Robotic unit operation packet. *)
			(* NOTE: This will be stripped out of the UnitOperation packet by the framework and only stored at the top protocol level. *)
			unitOperationPacketWithLabeledObjects=Append[
				unitOpPacket,
				Replace[LabeledObjects]->DeleteDuplicates@Join[
					Cases[
						Transpose[{sampleLabelsWithReplicates, sampleResources}],
						{_String, Resource[KeyValuePattern[Sample->ObjectP[{Object[Sample], Model[Sample]}]]]}
					],
					Cases[
						Transpose[{DeleteDuplicates@Lookup[replicatedOptions, SampleContainerLabel], containerResources}],
						{_String, Resource[KeyValuePattern[Sample->ObjectP[{Object[Container], Model[Container]}]]]}
					]
				]
			];

			(* Return our unit operation packet with labeled objects. *)
			{
				Null,
				{unitOperationPacketWithLabeledObjects}
			}
		]
	];

	(* make list of all the resources we need to check in FRQ *)
	rawResourceBlobs=DeleteDuplicates[Cases[Flatten[{Normal[finalizedPacket], Normal[unitOperationPackets]}],_Resource,Infinity]];

	(* Get all resources without a name. *)
	(* NOTE: Don't try to consolidate operator resources. *)
	resourcesWithoutName=DeleteDuplicates[Cases[rawResourceBlobs, Resource[_?(MatchQ[KeyExistsQ[#, Name], False] && !KeyExistsQ[#, Operator]&)]]];
	resourceToNameReplaceRules=MapThread[#1->#2&, {resourcesWithoutName, (Resource[Append[#[[1]], Name->CreateUUID[]]]&)/@resourcesWithoutName}];
	allResourceBlobs=rawResourceBlobs/.resourceToNameReplaceRules;

	(* Verify we can satisfy all our resources *)
	{resourcesOk,resourceTests}=Which[
		MatchQ[$ECLApplication,Engine],
		{True,{}},
		(* When Preparation->Robotic, the framework will call FRQ for us. *)
		MatchQ[resolvedPreparation, Robotic],
		{True, {}},
		gatherTestsQ,
		Resources`Private`fulfillableResourceQ[allResourceBlobs,Output->{Result,Tests},FastTrack->Lookup[replicatedOptions,FastTrack],Site->Lookup[replicatedOptions,Site],Simulation->simulation,Cache->cache],
		True,
		{Resources`Private`fulfillableResourceQ[allResourceBlobs,FastTrack->Lookup[replicatedOptions,FastTrack],Site->Lookup[replicatedOptions,Site],Messages->Not[gatherTestsQ],Simulation->simulation,Cache->cache],Null}
	];

	(* --- Output --- *)
	(* Generate the Preview output rule *)
	previewRule=Preview->Null;

	(* Generate the options output rule *)
	optionsRule=Options->If[MemberQ[output,Options],
		resolvedOptionsNoHidden,
		Null
	];

	(* Generate the tests rule *)
	testsRule=Tests->If[gatherTestsQ,
		resourceTests,
		{}
	];

	(* generate the Result output rule *)
	(* If not returning Result, or the resources are not fulfillable, Results rule is just $Failed *)
	resultRule=Result->If[MemberQ[output,Result]&&TrueQ[resourcesOk],
		{finalizedPacket, unitOperationPackets}/.resourceToNameReplaceRules,
		$Failed
	];

	(* Return the output as we desire it *)
	outputSpecification/.{previewRule,optionsRule,resultRule,testsRule}
];

expandFluorescenceReplicates[experiment_,mySamples:{ObjectP[]...},options:{(_Rule|_RuleDelayed)..},numberOfReplicates:(_Integer|Null)]:=Module[
	{samplesWithReplicates,mapThreadOptions,optionsWithReplicates},

	(*Repeat the inputs if we have replicates*)
	samplesWithReplicates=duplicateFluorescenceReplicates[mySamples,numberOfReplicates];

	(* Determine options index-matched to the input *)
	mapThreadOptions=Lookup[Select[OptionDefinition[experiment],MatchQ[Lookup[#,"IndexMatchingInput"],Except[Null]]&],"OptionSymbol"];

	(*Repeat MapThread options if we have replicates*)
	optionsWithReplicates=Map[
		If[MemberQ[mapThreadOptions,First[#]],
			First[#]->duplicateFluorescenceReplicates[Last[#],numberOfReplicates],
			First[#]->Last[#]
		]&,
		options
	];

	{samplesWithReplicates,optionsWithReplicates}
];

(* =Define Function:duplicateFluorescenceReplicates-expand samples/options for replicates= *)
duplicateFluorescenceReplicates[value_,numberOfReplicates_]:=Module[{},
	If[MatchQ[numberOfReplicates,Null],
		value,
		Flatten[Map[ConstantArray[#,numberOfReplicates]&,value],1]
	]
];

(* Returns the wells which should be filled to make the moat *)
getMoatWells[plateWells:{{_String..}..},moatSize_Integer]:=Module[{minDimension},

	(* Get Min[{column,row}] *)
	minDimension=Min[Dimensions[plateWells]];

	(* Our moat will fill the perimeter wells *)
	(* We will take the first N rows, the last N rows, the first N columns and the last N columns *)
	(* This means moat size can't be more than half our minDimension, else we'll be covering the full plate *)
	If[moatSize<=Floor[minDimension/2],
		DeleteDuplicates[
			Flatten[
				{
					Take[plateWells,moatSize],
					Take[plateWells,-moatSize],
					Take[Transpose[plateWells],moatSize],
					Take[Transpose[plateWells],-moatSize]
				},
				2
			]
		],
		Flatten[plateWells]
	]
];


DefineOptions[validPlateReaderMixing,
	Options:>{
		HelperOutputOption
	}
];

validPlateReaderMixing[functionName_,experimentOptionsAssociation_Association,ops:OptionsPattern[]]:=Module[
	{outputSpecification,output,gatherTestsQ,messagesQ,suppliedPlateReaderMix,mixParameterOptionNames,presentedMixParameterOptionNames,
	suppliedPlateReaderMixRate,suppliedPlateReaderMixTime,suppliedPlateReaderMixMode,suppliedPlateReaderMixSchedule,
	suppliedMixParameters,mixingParametersMissing,unneededMixingParameters,conflictingMixParameters,mixingTests,invalidMixOptions,
	anyInjectionsQ,validMixSchedule,plateReaderMixScheduleTests,invalidMixScheduleOption,
	validMixTimeInjectionCombo,plateReaderMixTimeInjectionComboTests,invalidMixInjectionOptions,tests,invalidOptions},

	(* Determine the requested return value from the function, and set-up test collection structure *)
	outputSpecification=OptionValue[Output];
	output=ToList[outputSpecification];
	gatherTestsQ=MemberQ[output,Tests];
	messagesQ=!MemberQ[output,Tests];

	(* - Validate Mixing Parameters - *)
	(* Lookup relevant options *)
	suppliedPlateReaderMix=Lookup[experimentOptionsAssociation,PlateReaderMix];
	mixParameterOptionNames={PlateReaderMixRate,PlateReaderMixTime,PlateReaderMixMode,PlateReaderMixSchedule};
	presentedMixParameterOptionNames=If[MatchQ[functionName,ExperimentFluorescencePolarizationKinetics|ExperimentFluorescenceKinetics|ExperimentLuminescenceKinetics|ExperimentAbsorbanceKinetics|ExperimentNephelometryKinetics],
		{PlateReaderMixRate,PlateReaderMixTime,PlateReaderMixMode,PlateReaderMixSchedule},
		{PlateReaderMixRate,PlateReaderMixTime,PlateReaderMixMode}
	];
	{suppliedPlateReaderMixRate,suppliedPlateReaderMixTime,suppliedPlateReaderMixMode,suppliedPlateReaderMixSchedule}=Lookup[
		experimentOptionsAssociation,
		mixParameterOptionNames,
		Automatic (* Only Kinetics experiments have a MixSchedule option, so default it to Automatic so it won't confuse checks *)
	];

	(* Get a list of the mix parameters so they're easier to work with *)
	suppliedMixParameters={suppliedPlateReaderMixRate,suppliedPlateReaderMixTime,suppliedPlateReaderMixMode,suppliedPlateReaderMixSchedule};

	(* If we're mixing, make sure none of the associated options are Null *)
	mixingParametersMissing=MatchQ[suppliedPlateReaderMix,True]&&MemberQ[suppliedMixParameters,Null];

	(* If we're not mixing, make sure none of the associated options are set *)
	unneededMixingParameters=MatchQ[suppliedPlateReaderMix,False]&&MemberQ[suppliedMixParameters,UnitsP[]|MechanicalShakingP|MixingScheduleP];

	(* Make sure we can resolve Mix - can't have some parameters set to Null, but others specified *)
	conflictingMixParameters=MatchQ[suppliedPlateReaderMix,Automatic]&&MemberQ[suppliedMixParameters,Null]&&MemberQ[suppliedMixParameters,UnitsP[]|MechanicalShakingP|MixingScheduleP];

	(* Create tests *)
	mixingTests=If[gatherTestsQ,
		{
			Test["PlateReader mix options are supplied if PlateReaderMix is set to True and left unspecified otherwise:",mixingParametersMissing||unneededMixingParameters,False],
			Test["The plate reader mix parameters do not conflict:",conflictingMixParameters,False]
		}
	];

	(* Throw messages for possible mix errors *)
	If[mixingParametersMissing&&messagesQ,
		Message[Error::MixingParametersRequired]
	];
	If[unneededMixingParameters&&messagesQ,
		Message[Error::MixingParametersUnneeded]
	];
	If[conflictingMixParameters&&messagesQ,
		Message[Error::MixingParametersConflict]
	];

	(* Track that the mixing issues are hard errors *)
	(* Our above checks indicate at least one option is invalid, PickList to determine which ones are causing the problem *)
	invalidMixOptions=Which[
		mixingParametersMissing,Append[PickList[mixParameterOptionNames,suppliedMixParameters,UnitsP[]|MechanicalShakingP|MixingScheduleP],PlateReaderMix],
		unneededMixingParameters,Append[PickList[mixParameterOptionNames,suppliedMixParameters,Null],PlateReaderMix],
		conflictingMixParameters,presentedMixParameterOptionNames
	];

	(* - Validate PlateReaderMixSchedule - *)

	(* Track whether or not we're injecting anything *)
	anyInjectionsQ=MemberQ[Flatten[Lookup[experimentOptionsAssociation,{PrimaryInjectionVolume,SecondaryInjectionVolume,TertiaryInjectionVolume,QuaternaryInjectionVolume}]],VolumeP];

	(* Note: PlateReaderMixSchedule is an option to kinetics experiments *)
	validMixSchedule=Which[
		!anyInjectionsQ&&MatchQ[suppliedPlateReaderMixSchedule,AfterInjections],Module[{},
			If[messagesQ,
				Message[Error::NoPostInjectionMixing]
			];
			False
		],
		MatchQ[Lookup[experimentOptionsAssociation,ReadOrder],Serial]&&MatchQ[suppliedPlateReaderMixSchedule,BetweenReadings],Module[{},
			If[messagesQ,
				Message[Error::NoSerialCycleMixing]
			];
			False
		],
		MatchQ[suppliedPlateReaderMixSchedule,Null|Automatic],True,
		True,True
	];

	(* Test for plate reader mix schedule *)
	plateReaderMixScheduleTests=If[gatherTestsQ,
		If[MatchQ[functionName,ExperimentFluorescenceKinetics|ExperimentLuminescenceKinetics|ExperimentAbsorbanceKinetics|ExperimentNephelometryKinetics],
			{Test["The PlateReaderMixSchedule is supported for the current ReadOrder and injection settings:",validMixSchedule,True]},
			{}
		]
	];

	(* Track that this is a hard error *)
	invalidMixScheduleOption=If[!validMixSchedule,
		PlateReaderMixSchedule
	];

	(* Validate PlateReaderMixTime/Injection Times *)
	(* No InjectionTime options for FI, so he's fine *)
	(* If we're mixing after injection cycles or after every cycle, we have to make sure injections are farther apart than cycles
		e.g. can't injection after 5 minutes, mix for 5 minutes and then try to inject after 7.5 minutes (have to wait until 10 minutes when mixing is done)
	*)
	validMixTimeInjectionCombo=Or[
		MatchQ[functionName,Except[ExperimentAbsorbanceKinetics|ExperimentFluorescenceKinetics|ExperimentLuminescenceKinetics|ExperimentFluorescencePolarizationKinetics|ExperimentNephelometryKinetics]],
		MatchQ[suppliedPlateReaderMixTime,Null|Automatic],
		MatchQ[suppliedPlateReaderMixSchedule,BeforeReadings],
		Module[{injectionTimes},
			injectionTimes=DeleteDuplicates[DeleteCases[Lookup[experimentOptionsAssociation,{PrimaryInjectionTime,SecondaryInjectionTime,TertiaryInjectionTime}],Null]];
			If[Length[injectionTimes]<=1,
				True,
				Max[Append[Rest[injectionTimes],Last[injectionTimes]]-injectionTimes]>suppliedPlateReaderMixTime
			]
		]
	];

	(* Message for plate reader mix time-injection time compatibility check *)
	If[!validMixTimeInjectionCombo&&messagesQ,
		Message[Error::InjectionTimeOverlap];
	];

	(* Test for plate reader mix time-injection time compatibility check *)
	plateReaderMixTimeInjectionComboTests=If[gatherTestsQ,
		If[MatchQ[experimentType,Kinetics],
			{Test["When mixing is occurring during reading cycles, the difference between injection times must be greater than the mixing time since the next injection can only occur after mixing completes:",validMixTimeInjectionCombo,True]},
			{}
		]
	];

	(* Track that this is a hard error  *)
	invalidMixInjectionOptions=If[!validMixTimeInjectionCombo,
		{PlateReaderMixTime,PrimaryInjectionTime,SecondaryInjectionTime,TertiaryInjectionTime}
	];

	tests=Join[mixingTests,plateReaderMixScheduleTests,plateReaderMixTimeInjectionComboTests];
	invalidOptions={invalidMixOptions,invalidMixScheduleOption,invalidMixInjectionOptions};

	outputSpecification/.{
		Tests->tests,
		Options->invalidOptions
	}
];


DefineOptions[validMoat,
	Options:>{
		HelperOutputOption,
		{
			OptionName -> AliquotGeneratedAssayPlate,
			Default -> True,
			Description -> "Whether moat generation will occur via the aliquot system. If an assay plate with a moat is being prepared outside of the aliquot system, aliquoting is not required for moat generation.",
			AllowNull -> False,
			Widget -> Widget[Type -> Enumeration,Pattern :> BooleanP]
		},
		{
			OptionName -> EmptyMoat,
			Default -> False,
			Description -> "Specified that if the moat wells are empty, this option was created for ExperimentCircularDichroism: when using quzrtz plate, it's outter layer of wells have very high background signal, thereby cannot be used. In this case, MoatSize->2 but moat well will be left empty.",
			AllowNull -> False,
			Widget -> Widget[Type -> Enumeration,Pattern :> BooleanP]
		}
	}
];


(* assayContainerModelPacket may be the aliquot container model or the assay 
	container model if the aliquot system is not being used to generate the assay plate *)


(* Authors definition for Experiment`Private`validMoat *)
Authors[Experiment`Private`validMoat]:={"hayley", "mohamad.zandian"};

validMoat[numberOfAssaySamples_Integer,assayContainerModelPacket:PacketP[Model[Container]],experimentOptionsAssociation_Association,ops:OptionsPattern[]]:=Module[{
	outputSpecification,output,gatherTestsQ,messagesQ,moatParameterOptionNames,suppliedMoatParameters,
	suppliedMoatSize,suppliedMoatBuffer,suppliedMoatVolume,conflictingMoatParameters,moatTest,
	invalidMoatOptions,impliedMoat,moatAliquotError,moatAliquotTest,invalidMoatAliquotOptions,
	validMoatVolume,invalidMoatVolumeTest,invalidMoatVolumeOption,
	suppliedAliquotBooleans,defaultMoatSize,suppliedDestinationWells,validMoatSize,conflictingWells,
	validDestinationWells,validMoatSizeTest,validWellsTest,invalidMoatSizeOption,emptyMoatQ,
	aliquotGeneratedAssayPlateQ},

	(* Determine the requested return value from the function, and set-up test collection structure *)
	outputSpecification=OptionValue[Output];
	output=ToList[outputSpecification];
	gatherTestsQ=MemberQ[output,Tests];
	messagesQ=!MemberQ[output,Tests];

	(* Check if emptyMoat is specified*)
	emptyMoatQ=OptionValue[EmptyMoat];

	(* --- Validate Moat Options --- *)

	(* - Validate Moat Parameter Combo - *)
	(* Lookup relevant options *)
	moatParameterOptionNames={MoatSize,MoatBuffer,MoatVolume};
	suppliedMoatParameters=Lookup[experimentOptionsAssociation,moatParameterOptionNames];
	{suppliedMoatSize,suppliedMoatBuffer,suppliedMoatVolume}=suppliedMoatParameters;

	(* Make sure we can resolve moat options *)
	conflictingMoatParameters=If[
		TrueQ[emptyMoatQ],

		(* if moat can be empty, we check the MoatSize: if it's Null, then MoatBuffer and MoatSize cannot be specified, else, both moat buffer moat size needs to be null or specified.*)
		If[NullQ[suppliedMoatSize],MemberQ[{suppliedMoatBuffer,suppliedMoatVolume},Except[Null|Automatic]],MemberQ[{suppliedMoatBuffer,suppliedMoatVolume},Null]&&MemberQ[{suppliedMoatBuffer,suppliedMoatVolume},Except[Null|Automatic]]],

		(*If moat wells required to be filled - then can't have some parameters set to Null, but others specified*)
		MemberQ[suppliedMoatParameters,Null]&&MemberQ[suppliedMoatParameters,Except[Null|Automatic]]

	];

	(* Create test *)
	moatTest=If[gatherTestsQ,
		Test["The moat parameters do not conflict:",conflictingMoatParameters,False]
	];

	(* Throw messages for possible moat errors *)
	If[conflictingMoatParameters&&messagesQ,
		Message[Error::MoatParametersConflict]
	];

	(* Track InvalidOption *)
	invalidMoatOptions=If[conflictingMoatParameters,
		{MoatSize,MoatBuffer,MoatVolume}
	];

	(* Assume user wants a moat if they'e set one of the parameters *)
	impliedMoat=!conflictingMoatParameters&&MemberQ[suppliedMoatParameters,Except[Null|Automatic]];

	(* -- Validate Moat x Aliquot, if AliquotGeneratedAssayPlate->True -- *)
	
	(* Is aliquoting required for moat generation in this experiment? *)
	aliquotGeneratedAssayPlateQ = TrueQ[OptionValue[AliquotGeneratedAssayPlate]];
		
	(* If aliquoting is required, get aliquot bools and what wells user wants to put aliquots in.
	 	If aliquoting is not required, Set these values such that they will not interfere with checks below.*)
	{suppliedAliquotBooleans,suppliedDestinationWells} = If[aliquotGeneratedAssayPlateQ,
		Lookup[experimentOptionsAssociation,{Aliquot,DestinationWell}],
		{{True}, {}}
	];

	(* Unless options specifically indicate otherwise, must be aliquoting if we're gonna make a moat *)
	moatAliquotError=If[aliquotGeneratedAssayPlateQ,
		MemberQ[suppliedAliquotBooleans,False]&&impliedMoat,
		False
	];

	(* Create test if applicable *)
	moatAliquotTest=If[gatherTestsQ,
		Test["If a moat is to be created, the samples may be aliquoted in order to create a new plate with a moat surrounding the assay samples:",moatAliquotError,False]
	];

	(* Throw message *)
	If[messagesQ&&moatAliquotError,
		Message[Error::MoatAliquotsRequired]
	];

	(* Track invalid option *)
	invalidMoatAliquotOptions=If[moatAliquotError,Join[{Aliquot},PickList[moatParameterOptionNames,suppliedMoatParameters,Except[Null|Automatic]]]];

	(* -- Validate MoatVolume -- *)
	(* This check is short-circuited if a moat is being generated by the aliquot system but not all samples have Aliquot->True *)
	validMoatVolume=If[Or[!aliquotGeneratedAssayPlateQ, !MemberQ[suppliedAliquotBooleans,False]] && MatchQ[suppliedMoatVolume,VolumeP],
		Module[{maxVolume},
			maxVolume=Lookup[assayContainerModelPacket,MaxVolume];
			suppliedMoatVolume <= maxVolume
		],
		True
	];

	(* Create test *)
	invalidMoatVolumeTest=If[gatherTestsQ,
		Test["It a MoatVolume is specified it does not exceed the max volume of the assay container.",validMoatVolume,True]
	];

	(* Throw message *)
	If[!validMoatVolume&&messagesQ,
		Message[Error::MoatVolumeOverflow]
	];

	(* Track invalid option *)
	invalidMoatVolumeOption=If[!validMoatVolume,MoatVolume];

	(* -- Validate MoatSize -- *)

	(* If moat is implied but size isn't specified, we'll make one layer of moat wells *)
	defaultMoatSize=1;

	(* - Make sure we have enough space for moat and samples and that moat doesn't overlap with DestinationWells - *)
	(* This check is short-circuited if aliquoting is required but not all samples have Aliquot->True *)
	{validMoatSize,conflictingWells}=If[Or[!aliquotGeneratedAssayPlateQ, !MemberQ[suppliedAliquotBooleans,False]] && impliedMoat,
		Module[{plateWells,moatSize,moatWells,availableWells,moatSizeOk,overlappingWells},
		(* Determine how many wells we'll have left once we've made our moat *)
			plateWells=AllWells[assayContainerModelPacket];

			(* If user asked for moat by setting volume or buffer, by not size, use default size *)
			moatSize=If[MatchQ[suppliedMoatSize,_Integer],
				suppliedMoatSize,
				defaultMoatSize
			];

			(* Get wells which should be filled with moat buffer *)
			moatWells=getMoatWells[plateWells,moatSize];

			(* See what wells are left over *)
			availableWells=DeleteCases[Flatten[plateWells,1],Alternatives@@moatWells];

			(* MoatSize is valid if there's enough room for the samples with replicates in the remaining wells *)
			moatSizeOk=Length[availableWells] >= numberOfAssaySamples;

			(* Make sure none of our destination wells are slated to be moat wells *)
			overlappingWells=Cases[suppliedDestinationWells,Alternatives@@moatWells];

			{moatSizeOk,overlappingWells}
		],
		{True,{}}
	];

	validDestinationWells=MatchQ[conflictingWells,{}];

	(* Create tests *)
	validMoatSizeTest=If[gatherTestsQ,
		Test["If a moat is to be created, there will be enough remaining wells for the assay samples:",validMoatSize,True]
	];

	validWellsTest=If[gatherTestsQ,
		Test["If a moat is to be created, none of the specified destination wells are earmarked to be used as moat wells:",validDestinationWells,True]
	];

	(* Throw messages *)
	If[
		MatchQ[Lookup[assayContainerModelPacket,Object],ObjectP[Model[Container,Cuvette]]],
		True,
		If[!validMoatSize&&messagesQ,
			Message[Error::TooManyMoatWells]
		]
	];

	If[!validDestinationWells&&messagesQ,
		Message[Error::WellOverlap,conflictingWells]
	];

	(* Track invalid option *)
	invalidMoatSizeOption=If[!validMoatSize||!validDestinationWells,MoatSize];

	outputSpecification/.{
		Tests->{
			moatTest,
			moatAliquotTest,
			invalidMoatVolumeTest,
			validMoatSizeTest,
			validWellsTest
		},
		Options->DeleteCases[
			Flatten[
				{
					invalidMoatOptions,
					invalidMoatAliquotOptions,
					invalidMoatVolumeOption,
					invalidMoatSizeOption
				},
				1
			],
			Null
		]
	}
];

plateReaderExperimentDownload[type:(TypeP[Object[Protocol]]),samples:{ObjectP[Object[Sample]]..},experimentOptions:{(_Rule|_RuleDelayed)..},cache:{_Association...},simulation:SimulationP]:=Module[{defaultAliquotContainer,allPlateReaderModels,suppliedPlateReader,plateReaderToDownload,
	plateReaderModelFields,plateReaderModelPacketSpec,suppliedPlateReaderPacketSpec,possibleAliquotContainers,
	userSpecifiedObjects,objectsExistQs,fastCacheBall,
	sampleModelFields,sampleModelPacket,samplePacket,containerModelPacket,aliquotContainerPacket,containerPacket,download},

	defaultAliquotContainer=Model[Container,Plate,"id:kEJ9mqR3XELE"];

	(* Search for all plate reader models; we may need this to help resolve options *)
	allPlateReaderModels=Search[Model[Instrument,PlateReader],Deprecated!=True&&PlateReaderMode==(Fluorescence|TimeResolvedFluorescence|FluorescenceSpectroscopy)];

	(* Lookup option values for download *)
	suppliedPlateReader=Lookup[experimentOptions,Instrument];

	(* If Instrument is left Automatic, convert to Null to play nice with Download *)
	plateReaderToDownload=Replace[suppliedPlateReader,Automatic->Null];

	(* Fields we need to download from any plate reader models we might use: *)
	plateReaderModelFields={EmissionFilterTypes,ExcitationFilterTypes,PlateReaderMode,OpticModules,MinTemperature,MaxTemperature,MinExcitationWavelength,MaxExcitationWavelength,
		ExcitationFilters,PolarizationExcitationFilters,ExcitationWavelengthResolution,MinEmissionWavelength,MaxEmissionWavelength,EmissionFilters,PolarizationEmissionFilters,EmissionWavelengthResolution,MaxFilters,WettedMaterials,SamplingPatterns};

	(* Get fields in packet form *)
	plateReaderModelPacketSpec=Packet@@plateReaderModelFields;

	(* Set-up to download model info from the plate reader option *)
	suppliedPlateReaderPacketSpec=Switch[suppliedPlateReader,
		Automatic,{},
		ObjectP[Object[Instrument,PlateReader]],{Packet[Model[plateReaderModelFields]]},
		ObjectP[Model[Instrument,PlateReader]],{plateReaderModelPacketSpec}
	];

	possibleAliquotContainers=Append[
		DeleteDuplicates[Cases[Lookup[experimentOptions,AliquotContainer],ObjectP[]]],
		defaultAliquotContainer
	];

	sampleModelFields=Join[SamplePreparationCacheFields[Model[Sample]],{IncompatibleMaterials}];
	sampleModelPacket=Packet@@sampleModelFields;
	samplePacket=Packet@@Join[SamplePreparationCacheFields[Object[Sample]],{Well,RequestedResources,IncompatibleMaterials}];
	containerModelPacket=SamplePreparationCacheFields[Model[Container]];
	aliquotContainerPacket=SamplePreparationCacheFields[Model[Container],Format -> Packet];
	containerPacket=Append[SamplePreparationCacheFields[Object[Container]],RequestedResources];

	(* Before Download, check whether any of the specified objects does not exist. This is done early to avoid tons of errors later. *)
	userSpecifiedObjects=DeleteDuplicates[
		Cases[
			Flatten@Join[
				samples,
				Values[experimentOptions]
			],
			ObjectP[]
		]
	];

	(* Check that the specified objects exist or are visible to the current user *)
	fastCacheBall = makeFastAssocFromCache[cache];

	objectsExistQs=MapThread[
		Or[#1,#2]&,
		{
			MatchQ[fetchPacketFromFastAssoc[#, fastCacheBall], KeyValuePattern[Simulated->True]]&/@userSpecifiedObjects,
			DatabaseMemberQ[
				userSpecifiedObjects,
				Simulation->simulation
			]
		}
	];

	(* If objects do not exist, return failure *)
	If[!(And@@objectsExistQs),
		Message[Error::ObjectDoesNotExist,PickList[userSpecifiedObjects,objectsExistQs,False]];
		Message[Error::InvalidInput,PickList[userSpecifiedObjects,objectsExistQs,False]];
		Return[$Failed],
		Nothing
	];

	download=Check[
		Quiet[
			Download[
				{
					samples,
					(* These samples are used by default in the plate reader experiments. *)
					DeleteDuplicates@Flatten[{
						{Model[Sample, "id:8qZ1VWNmdLBD"], Model[Sample,StockSolution,"id:BYDOjv1VA7Zr"]},
						Cases[Normal[KeyDrop[experimentOptions, {Cache, Simulation}], Association], ObjectReferenceP[Model[Sample]], Infinity]
					}],
					{plateReaderToDownload},
					allPlateReaderModels,
					possibleAliquotContainers
				},
				{
					{
						samplePacket,
						Packet[Model[sampleModelFields]],
						Packet[Container[containerPacket]],
						Packet[Container[Model][containerModelPacket]]
					},
					{sampleModelPacket},
					suppliedPlateReaderPacketSpec,
					{plateReaderModelPacketSpec},
					{aliquotContainerPacket}
				},
				Cache->cache,
				Simulation -> simulation,
				Date->Now
			],
			{Download::FieldDoesntExist,Download::NotLinkField}
		],
		$Failed,
		Download::ObjectDoesNotExist
	];

	(* Return early if objects do not exist *)
	If[MatchQ[download,$Failed],
		Return[$Failed]
	];

	(* Join what we've downloaded with what we've been given from the cache *)
	(* cache-Download behavior means the last packet will be used if there are multiple packets downloaded for the same object *)

	FlattenCachePackets[{cache,download}]
]
 