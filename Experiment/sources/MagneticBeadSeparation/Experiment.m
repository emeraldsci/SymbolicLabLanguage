(* ::Package:: *)

(* ::Text:: *)
(*\[Copyright] 2011-2022 Emerald Cloud Lab, Inc.*)


(* ::Section:: *)
(*Source Code*)


(* ::Subsection::Closed:: *)
(*ExperimentMagneticBeadSeparation*)


(* ::Subsubsection::Closed:: *)
(*ExperimentMagneticBeadSeparation Options and Messages*)

DefineOptions[ExperimentMagneticBeadSeparation,
	Options:>{
		(*===General===*)
		{
			OptionName->SelectionStrategy,
			Default->Positive,
			Description->"Specified if the target analyte (Positive) or contaminants (Negative) binds to the magnetic beads in order to isolate the target analyte. When the target analyte is bound to the magnetic beads (Positive), they are collected as SamplesOut during the elution step. When contaminants are bound to the magnetic beads (Negative), the target analyte remains in the supernatant and is collected as SamplesOut during the loading step.",
			AllowNull->False,
			Widget->Widget[
				Type->Enumeration,
				Pattern:>MagneticBeadSeparationSelectionStrategyP
			],
			Category->"General"
		},
		{
			OptionName->SeparationMode,
			Default->Affinity,
			Description->"The mechanism used to selectively isolate or remove targeted components from the samples by magnetic beads. Options include NormalPhase, ReversePhase, IonExchange, Affinity. In NormalPhase mode, magnetic beads are coated with polar molecules (mainly pure silica) and the mobile phase less polar causing the adsorption of polar targeted components. In ReversePhase mode, magnetic beads are coated with hydrophobic groups on the surface to bind targeted components. In IonExchange mode, magnetic beads coated with ion-exchange groups ionically bind charged targeted components. In Affinity mode, magnetic beads are coated with functional groups that can covalently conjugate ligands on targeted components.",
			AllowNull->False,
			Widget->Widget[Type->Enumeration,Pattern:>MagneticBeadSeparationModeP],
			Category->"General"
		},
		{
			OptionName->ProcessingOrder,
			Default->Automatic,
			Description->"The order for processing samples in the experiment. Parallel indicates all samples are processed at the same time in all steps of the experiment, can only be used if the samples are provided in a flat list. Serial indicates samples are processed sequentially such that all steps of the experiment are completed for a given sample before processing the next, can only be used if the samples are provided in a flat list. Batch indicates the input is a nested list and each sample group is fully processed (in parallel) before moving to the next, can only be used if the samples are provided in a nested list.",
			ResolutionDescription->"Automatically set to Parallel if SamplesIn is a list of samples and to Batch if SamplesIn is a list of lists of samples.",
			AllowNull->False,
			Widget->Widget[Type->Enumeration,Pattern:>MagneticBeadSeparationProcessingOrderP],
			Category->"General"
		},
		{
			OptionName->NumberOfReplicates,
			Default->Null,
			AllowNull->True,
			Widget->Widget[Type->Number,Pattern:>RangeP[2,500,1]],
			Description->"The number of aliquots to generate from the input sample before loading to the magnetic beads.",
			Category->"General"
		},
		IndexMatching[
			IndexMatchingInput->"experiment samples",
			{
				OptionName->Volume,
				Default->Automatic,
				Description->"The amount of sample that is added to the magnetic beads in order to allow binding of target analyte or contaminant to the magnetic beads after the magnetic beads are optionally prewashed and equilibrated.",
				ResolutionDescription->"Automatically set to the sample volume (aliquoted if specified NumberOfReplicates) if it is below 25 mL for manual preparation or below 1 mL for robotic preparation. Otherwise, set to 25 mL for manual preparation or to 1 mL for robotic preparation.",
				AllowNull->False,
				Widget->Alternatives[
					"Volume"->Widget[
						Type->Quantity,
						Pattern:>RangeP[1 Microliter,50 Milliliter],
						Units->{Microliter,{Microliter,Milliliter}}
					],
					"All"->Widget[
						Type->Enumeration,
						Pattern:>Alternatives[All]
					]
				],
				Category->"General",
				NestedIndexMatching->True
			},
			{
				OptionName->Target,
				Default->Automatic,
				Description->"The molecule or analyte that we aim to purify from the SamplesIn.",
				ResolutionDescription->"Automatically set to the first item in Analytes of the sample if analyteAffinityLabel is not specified. Otherwise, Target is set to analyteAffinityLabel if SelectionStrategy->Positive, and is set to the first non-analyteAffinityLabel item in Analytes of the sample if SelectionStrategy->Negative.",
				AllowNull->True,
				Widget->Widget[Type->Object,Pattern:>ObjectP[Model[Molecule]]],
				Category->"General",
				NestedIndexMatching->True
			},
			{
				OptionName->AnalyteAffinityLabel,
				Default->Automatic,
				Description->"The target molecule in the sample that binds the immobilized ligand on the magnetic beads for affinity separation, applicable if SeparationMode is set to Affinity. AnalyteAffinityLabel is used to help set automatic options such as MagneticBeadAffinityLabel.",
				ResolutionDescription->"Automatically set to match the Target if SelectionStrategy is set to Positive, and is set to the first non-Target item in Analytes of the sample if SelectionStrategy is set to Negative.",
				AllowNull->True,
				Widget->Widget[Type->Object,Pattern:>ObjectP[Model[Molecule]]],
				Category->"General",
				NestedIndexMatching->True
			},
			{
				OptionName->MagneticBeadAffinityLabel,
				Default->Automatic,
				Description->"The molecule immobilized on the magnetic beads that specifically binds the target analyte for affinity separation, applicable if SeparationMode is set to Affinity. MagneticBeadAffinityLabel is used to help set automatic options such as MagneticBeads.",
				ResolutionDescription->"Automatically set to the first item in the Targets field of the AnalyteAffinityLabel if SeparationMode is set to Affinity. For example, if the AnalyteAffinityLabel is a biotinylated molecule, that molecule's Targets field is set to streptavidin.",
				AllowNull->True,
				Widget->Widget[Type->Object,Pattern:>ObjectP[Model[Molecule]]],
				Category->"General",
				NestedIndexMatching->True
			},
			{
				OptionName->MagneticBeads,
				Default->Automatic,
				Description->"The superparamagnetic particles with surface coatings to bind target analyte or contaminants. They exhibit magnetic behavior only in the presence of an external magnetic field. The magnetic beads are pulled to the perimeter of the container by applying a magnetic force, thus enables maximal aspiration of the supernatant.",
				ResolutionDescription->"If SeparationMode is Affinity, MagneticBeads is automatically set to the first found magnetic beads model with the affinity label of MagneticBeadAffinityLabel. Otherwise, MagneticBeads is automatically set according to Target and Separation Mode. If Target is a nucleic acid (DNA, RNA, cDNA, plasmid, etc.), MagneticBeads is automatically set to Model[Sample, \"Dynabeads MyOne SILANE Sample\"]. If Target is a protein or peptide, MagneticBeads is automatically set to Model[Sample,\"MagSi-proteomics C4\"] when SeparationMode is ReversePhase, and set to Model[Sample,\"MagSi-WCX\"] when SeparationMode is IonExchange. Otherwise, MagneticBeads is automatically set to Model[Sample, \"Mag-Bind Particles CNR (Mag-Bind Viral DNA/RNA Kit)\"]",(*TODO::Come back after creating the models.*)
				AllowNull->False,
				Widget->Widget[
					Type->Object,
					Pattern:>ObjectP[{Model[Sample],Object[Sample]}],
					OpenPaths->{
						{
							Object[Catalog,"Root"],"Materials","Magnetic Bead Separation","Magnetic Beads"
						}
					}
				],
				Category->"General",
				NestedIndexMatching->True
			},
			{
				OptionName->MagneticBeadVolume,
				Default->Automatic,
				Description->"The volumetric amount of MagneticBeads that is added to the assay container prior to optional prewash and equilibration.",
				ResolutionDescription->"Automatically set to 1/10 of the maximum Volume across the batch if ProcessingOrder->Batch or across all SamplesIn if ProcessingOrder->Parallel.",
				AllowNull->False,
				Widget->Widget[
					Type->Quantity,
					Pattern:>RangeP[1 Microliter,50 Milliliter],
					Units->{Microliter,{Microliter,Milliliter}}
					],
				Category->"General",
				NestedIndexMatching->True
			},
			{
				OptionName->MagneticBeadCollectionStorageCondition,
				Default->Disposal,
				Description->"The non-default condition under which the used magnetic beads are stored after the protocol is completed.",
				AllowNull->True,
				Widget->Alternatives[
					"Condition"->Widget[
						Type->Enumeration,Pattern:>SampleStorageTypeP|Disposal
					],
					"Objects"->Widget[
						Type->Object,
						Pattern:>ObjectP[Model[StorageCondition]],
						OpenPaths->{
							{
							Object[Catalog,"Root"],"Storage Conditions"
							}
						}
					]
				],
				Category->"Post Experiment",
				NestedIndexMatching->True
			},
			{
				OptionName->MagnetizationRack,
				Default->Automatic,
				Description->"The magnetic rack used during magnetization that provides the magnetic force to attract the magnetic beads.",
				ResolutionDescription->"Automatically set to Model[Item, MagnetizationRack, \"Alpaqua Magnum FLX Enhanced Universal Magnet 96-well Plate Rack\"] for robotic preparation. For manual preparation, set to the rack that fits tube with capacity of holding the maximum possible volume of sample during the experiment. See Table 3.1 for what this is automatically set to for manual preparation.",
				AllowNull->False,
				Widget->Widget[
					Type->Object,
					Pattern:>ObjectP[{
						Model[Container,Rack],
						Object[Container,Rack],
						Model[Item,MagnetizationRack],
						Object[Item,MagnetizationRack]
					}],
					OpenPaths->{
						{
							Object[Catalog,"Root"],"Materials", "Magnetic Bead Separation","Magnetization Racks"
						}
					}
				],
				Category->"General",
				NestedIndexMatching->True
			},

			(*===PreWash===*)

			{
				OptionName->PreWash,
				Default->Automatic,
				Description->"Indicates if the magnetic beads are rinsed prior to equilibration in order to remove the storage buffer.",
				ResolutionDescription->"Automatically set to True if other PreWash options are set, or False otherwise.",
				AllowNull->False,
				Widget->Widget[Type->Enumeration,Pattern:>BooleanP],
				Category->"PreWash",
				NestedIndexMatching->True
			},
			{
				OptionName->PreWashBuffer,
				Default->Automatic,
				Description->"The solution used to rinse the magnetic beads in order to remove the storage buffer prior to equilibration.",
				ResolutionDescription->"Automatically set to match the ElutionBuffer if PreWash is set to True.",
				AllowNull->True,
				Widget->Widget[
					Type->Object,
					Pattern:>ObjectP[{Model[Sample],Object[Sample]}],
					OpenPaths -> {
						{Object[Catalog,"Root"],"Materials", "Magnetic Bead Separation", "Wash Solutions"},
						{Object[Catalog,"Root"],"Materials", "Reagents", "Buffers"}
					}
				],
				Category->"PreWash",
				NestedIndexMatching->True
			},
			{
				OptionName->PreWashBufferVolume,
				Default->Automatic,
				Description->"The amount of PreWashBuffer that is added to the magnetic beads for each prewash prior to equilibration.",
				ResolutionDescription->"Automatically set to the same as sample volume to load (Volume) if PreWash is set to True.",
				AllowNull->True,
				Widget->Widget[
					Type->Quantity,
					Pattern:>RangeP[1 Microliter,50 Milliliter],
					Units->{Microliter,{Microliter,Milliliter}}
				],
				Category->"PreWash",
				NestedIndexMatching->True
			},
			{
				OptionName->PreWashMix,
				Default->Automatic,
				Description->"Indicates if the solution is mixed following combination of PreWashBuffer and the magnetic beads during each prewash.",
				ResolutionDescription->"Automatically set to True if PreWash is set to True and PreWashMixType is not set to Null.",
				AllowNull->True,
				Widget->Widget[Type->Enumeration,Pattern:>BooleanP],
				Category->"PreWash",
				NestedIndexMatching->True
			},

			ModifyOptions[ExperimentMix,
				{
					OptionName -> MixType,
					ModifiedOptionName -> PreWashMixType,
					Default->Automatic,
					Description -> "The style of motion used to mix the suspension following the addition of the PreWashBuffer to the magnetic beads. Options include Roll, Vortex, Sonicate, Pipette, Invert, Stir, Shake, Homogenize, Swirl, Disrupt, Nutate.",
					ResolutionDescription -> "Automatically set based on the volume-to-mix (i.e. the volume of the combined PreWashBuffer and magnetic beads) and the PreWashMix options. Specifically, PreWashMixType is automatically set to Pipette when the volume-to-mix is greater than 20 Microliter and none of PreWashMixRate, PreWashMixTemperature, and PreWashMixTime is specified to non-default values; otherwise, PreWashMixType is automatically set to Vortex when Preparation is Manual, PreWashMixTemperature is Automatic or Ambient, and PreWashMixRate is specified to be greater than 600 RPM; otherwise, PreWashMixType is automatically set to Shake.",
					NestedIndexMatching -> True,
					Category -> "PreWash",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> Time,
					ModifiedOptionName -> PreWashMixTime,
					Default->Automatic,
					Description -> "The duration during which the combined PreWashBuffer and magnetic beads are mixed.",
					ResolutionDescription -> "If PreWashMixType is among Disrupt, Nutate, Shake, Vortex, Roll, Stir, Homogenize, and Sonicate, PreWashMixTime is automatically set to 5 Minute for robotic preparation, and is set to 15 Minute for manual preparation.",
					NestedIndexMatching -> True,
					Category -> "PreWash",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> MixRate,
					ModifiedOptionName -> PreWashMixRate,
					Default->Automatic,
					Description -> "The frequency of rotation used to mix the combined PreWashBuffer and magnetic beads.",
					ResolutionDescription -> "Automatically set to 300 RPM if PreWashMixType is Shake or Stir, to 1000 RPM if PreWashMixType is Vortex or Disrupt, and to 30 RPM if PreWashMixType is Nutate or Roll.",
					NestedIndexMatching -> True,
					Category -> "PreWash",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> NumberOfMixes,
					ModifiedOptionName -> NumberOfPreWashMixes,
					Default->Automatic,
					Description -> "The number of times that the combined PreWashBuffer and magnetic beads are mixed if PreWashMixType is Pipette or Invert.",
					ResolutionDescription -> "Automatically set to 20 if PreWashMixType is Pipette, Swirl or Invert.",
					NestedIndexMatching -> True,
					Category -> "PreWash",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> MixVolume,
					ModifiedOptionName -> PreWashMixVolume,
					Default->Automatic,
					Description ->"The volume of the combined PreWashBuffer and magnetic beads that is pipetted up and down in order to mix, if PreWashMixType->Pipette, .",
					ResolutionDescription -> "For robotic preparation, PreWashMixVolume is automatically set to 970 Microliter if 0.8*volume-to-mix (i.e.volume-to-mix is the volume of the combined PreWashBuffer and magnetic beads) is greater than 970 Microliter, and otherwise is set to the greater of 10 Microliter and 0.8*volume-to-mix. For manual preparation, PreWashMixVolume is automatically set to the lesser of 50 Milliliter and 0.8*volume-to-mix.",
					NestedIndexMatching -> True,
					Category -> "PreWash",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> Temperature,
					ModifiedOptionName -> PreWashMixTemperature,
					Default->Automatic,
					Description ->"The temperature of the device that is used to mix/incubate the combined PreWashBuffer and magnetic beads.",
					ResolutionDescription->"Automatically set to Ambient if PreWashMix is set to True and PreWashMixType is not Null.",
					NestedIndexMatching -> True,
					Category -> "PreWash",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> TipType,
					ModifiedOptionName -> PreWashMixTipType,
					Default->Automatic,
					Description -> "The type of pipette tips used to mix the combined PreWashBuffer and magnetic beads. Options include Normal, Barrier, WideBore, GelLoading, Aspirator. This option can only be set if PreWashMixType->Pipette.",
					ResolutionDescription -> "Automatically set to WideBore for robotic preparation. For manual preparation, PreWashMixTipType is automatically set to WideBore if PreWashMixVolume is less or equal to 970 Microliter, to Normal if PreWashMixVolume is larger than 970 Microliter but less or equal to 5 Milliliter, and to Barrier if PreWashMixVolume is larger than 5 Milliliter.",
					NestedIndexMatching -> True,
					Category -> "PreWash",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> TipMaterial,
					ModifiedOptionName -> PreWashMixTipMaterial,
					Default->Automatic,
					Description -> "The material of the pipette tips used to aspirate and dispense the requested volume during the PreWashMix. This option can only be set if PreWashMixType->Pipette.",
					ResolutionDescription -> "Automatically set to Polypropylene if PreWashMixVolume is less or equal to 5 Milliliter, and to Glass if PreWashMixVolume is larger than 5 Milliliter.",
					NestedIndexMatching -> True,
					Category -> "PreWash",
					IndexMatchingOptions -> {}
				}
			],
			{
				OptionName->PreWashMagnetizationTime,
				Default->Automatic,
				Description->"The duration of magnetizing the magnetic beads after PreWashMixTime has elapsed, in order to pull the magnetic beads to the perimeter of the container by applying a magnetic force, thus enables maximal aspiration of the used PreWashBuffer.",
				ResolutionDescription->"Automatically set to 5 minutes if PreWash is set to True.",
				AllowNull->True,
				Widget->Widget[Type->Quantity,Pattern:>RangeP[0 Second,$MaxExperimentTime],Units->{Second,{Second,Minute,Hour}}],
				Category->"PreWash",
				NestedIndexMatching->True
			},
			{
				OptionName->PreWashAspirationVolume,
				Default->Automatic,
				Description->"The volume of solution to aspirate out while the magnetic beads are magnetized and gathered to the side during each wash prior to equilibration.",
				ResolutionDescription->"Automatically set to All for manual preparation, and set to PreWashBufferVolume for robotic preparation, if PreWash is set to True.",
				AllowNull->True,
				Widget->Alternatives[
					"All"->Widget[Type->Enumeration,Pattern:>Alternatives[All]],
					"Volume"->Widget[Type->Quantity,Pattern:>RangeP[1 Microliter,50 Milliliter],Units->{Microliter,{Microliter,Milliliter}}]
				],
				Category->"PreWash",
				NestedIndexMatching->True
			},
     
      ModifyOptions[TransferRoboticTipOptions,
        {
          OptionName -> AspirationPosition,
          ModifiedOptionName -> PreWashAspirationPosition,
          Default->Automatic,
          AllowNull ->True,
          Widget -> Widget[
            Type -> Enumeration,
            Pattern :> MagneticBeadSeparationPipettingPositionP
          ],
          Description -> "The location from which the solution is aspirated after PreWashMagnetizationTime. Top will aspirate PreWashAspirationPositionOffset below the Top of the container, Bottom will aspirate PreWashAspirationPositionOffset above the Bottom of the container, and LiquidLevel will aspirate PreWashAspirationPositionOffset below the liquid level of the sample in the container.",
          ResolutionDescription -> "Automatically set to Bottom if Preparation is Robotic and PreWash is True.",
          NestedIndexMatching -> True,
          Category -> "PreWash"
        }
      ],
      ModifyOptions[TransferRoboticTipOptions,
        {
          OptionName -> AspirationPositionOffset,
          ModifiedOptionName -> PreWashAspirationPositionOffset,
          Default->Automatic,
          AllowNull ->True,
          Description -> "The distance from the center of the well that the solution is aspirated after PreWashMagnetizationTime. The Z Offset is based on the PreWashAspirationPosition option -- measured as the height below the top of the well (Top), the height above the bottom of the well (Bottom), or the height below the detected liquid level (LiquidLevel). Please refer to the AspirationPosition diagram in the help file of ExperimentTransfer for more information. If an X and Y offset is not specified, the liquid will be aspirated in the center of the well, otherwise, -X/+X values will shift the position left and right, respectively, and -Y/+Y values will shift the position down and up, respectively.",
          ResolutionDescription -> "Automatically set to 0 Millimeter if MagnetizationRack is Model[Item,MagnetizationRack,\"Alpaqua Magnum FLX Enhanced Universal Magnet 96-well Plate Rack\"] and PreWashAspirationPosition is bottom, otherwise set to 2 Millimeter.",
          NestedIndexMatching -> True,
          Category -> "PreWash"
        }
      ],
			{
				OptionName->PreWashCollectionContainer,
				Default->Automatic,
				Description->"The container(s) for collecting the aspirated used PreWashBuffer during the prewash(es) prior to equilibration. By default, the same container is selected for the repeated washes (i.e. aspirated samples in the repeated washes will be combined) unless different container objects are specified for the prewashes prior to equilibration.",
				ResolutionDescription->"Automatically set to a container plate and its first available position. The container plate is selected by the function PreferredContainer given the volume of PreWashAspirationVolume for manual preparation, and is set to 2 mL Deep well plate for robotic preparation, if PreWash is set to True.",
				AllowNull->True,
				Widget -> Alternatives[
					Adder[
						Alternatives[
							"Container" -> Widget[
								Type -> Object,
								Pattern :> ObjectP[{Object[Container], Model[Container]}]
							],
							"Container with Index" -> {
								"Index" -> Widget[
									Type -> Number,
									Pattern :> GreaterEqualP[1, 1]
								],
								"Container" -> Widget[
									Type -> Object,
									Pattern :> ObjectP[Model[Container]],
									PreparedSample -> False,
									PreparedContainer -> False
								]
							},
							"Container with Well" -> {
								"Well" -> Widget[
									Type -> Enumeration,
									Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
									PatternTooltip -> "Enumeration must be any well from A1 to H12."
								],
								"Container" -> Widget[
									Type -> Object,
									Pattern :> ObjectP[Model[Container]],
									PreparedSample -> False,
									PreparedContainer -> False
								]
							},
							"Container with Well and Index" -> {
								"Well" -> Widget[
									Type -> Enumeration,
									Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
									PatternTooltip -> "Enumeration must be any well from A1 to H12."
								],
								"Index and Container"->{
									"Index"->Widget[
										Type->Number,
										Pattern:>GreaterEqualP[1,1]
									],
									"Container"->Widget[
										Type->Object,
										Pattern:>ObjectP[{Model[Container]}],
										PreparedSample->False,
										PreparedContainer->False
									]
								}
							},
							"Automatic or Null" -> Widget[
								Type -> Enumeration,
								Pattern :> Alternatives[Automatic,Null] (* For this option and all the additionally nested-index matching options (xxCollectionContainer, xxLabel, xxDestinationWell, XXIndex), we need to explicitly allow Automatic to be the same level of nestiness as Null and other real inputs to make ExpandIndexMatchedInputs happy. *)
							]
						]
					],
					Alternatives[
						"Container" -> Widget[
							Type -> Object,
							Pattern :> ObjectP[{Object[Container], Model[Container]}]
						],
						"Container with Index" -> {
							"Index" -> Widget[
								Type -> Number,
								Pattern :> GreaterEqualP[1, 1]
							],
							"Container" -> Widget[
								Type -> Object,
								Pattern :> ObjectP[Model[Container]],
								PreparedSample -> False,
								PreparedContainer -> False
							]
						},
						"Container with Well" -> {
							"Well" -> Widget[
								Type -> Enumeration,
								Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
								PatternTooltip -> "Enumeration must be any well from A1 to H12."
							],
							"Container" -> Widget[
								Type -> Object,
								Pattern :> ObjectP[Model[Container]],
								PreparedSample -> False,
								PreparedContainer -> False
							]
						},
						"Container with Well and Index" -> {
							"Well" -> Widget[
								Type -> Enumeration,
								Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
								PatternTooltip -> "Enumeration must be any well from A1 to H12."
							],
							"Index and Container"->{
								"Index"->Widget[
									Type->Number,
									Pattern:>GreaterEqualP[1,1]
								],
								"Container"->Widget[
									Type->Object,
									Pattern:>ObjectP[{Model[Container]}],
									PreparedSample->False,
									PreparedContainer->False
								]
							}
						}
					]
				],
				Category->"PreWash",
				NestedIndexMatching->True
			},
			{
				OptionName->PreWashCollectionStorageCondition,
				Default->Automatic,
				Description->"The non-default condition under which the aspirated samples during the prewash prior to equilibration are stored after the protocol is completed.",
				ResolutionDescription->"Automatically set to Refrigerator if PreWash is set to True.",
				AllowNull->True,
				Widget->Alternatives[
					"Condition"->Widget[
						Type->Enumeration,Pattern:>SampleStorageTypeP|Disposal
					],
					"Objects"->Widget[
						Type->Object,
						Pattern:>ObjectP[Model[StorageCondition]],
						OpenPaths->{
							{Object[Catalog,"Root"],"Storage Conditions"}
						}
					]
				],
				Category->"Post Experiment",
				NestedIndexMatching->True
			},
			{
				OptionName->NumberOfPreWashes,
				Default->Automatic,
				Description->"The number of times the magnetic beads are washed by adding PreWashBuffer, mixing, magnetization, and aspirating solution prior to equilibration.",
				ResolutionDescription->"Automatically set to 1 if PreWash is set to True.",
				AllowNull->True,
				Widget->Widget[Type->Number,Pattern:>RangeP[1,20,1]],
				Category->"PreWash",
				NestedIndexMatching->True
			},
			{
				OptionName->PreWashAirDry,
				Default->Automatic,
				Description->"Indicates if the magnetic beads are exposed to open air to evaporate the remaining PreWashBuffer following the final prewash prior to equilibration.",
				ResolutionDescription->"Automatically set to False if PreWash is set to True.",
				AllowNull->True,
				Widget->Widget[Type->Enumeration,Pattern:>BooleanP],
				Category->"PreWash",
				NestedIndexMatching->True
			},
			{
				OptionName->PreWashAirDryTime,
				Default->Automatic,
				Description->"The duration that the magnetic beads are exposed to open air to evaporate the remaining PreWashBuffer following the final prewash prior to equilibration.",
				ResolutionDescription->"Automatically set to 1 Minute if PreWashAirDry is set to True.",
				AllowNull->True,
				Widget->Widget[
					Type->Quantity,
					Pattern:>RangeP[0 Second,$MaxExperimentTime],
					Units->{Second,{Second,Minute,Hour}}
				],
				Category->"PreWash",
				NestedIndexMatching->True
			},


			(*===Equilibration===*)
			{
				OptionName->Equilibration,
				Default->Automatic,
				Description->"Indicates if the magnetic beads are equilibrated to a condition for optimal bead-target binding prior to adding samples to the magnetic beads.",
				ResolutionDescription->"Automatically set to True if other Equilibration options are set.",
				AllowNull->False,
				Widget->Widget[Type->Enumeration,Pattern:>BooleanP],
				Category->"Equilibration",
				NestedIndexMatching->True
			},
			{
				OptionName->EquilibrationBuffer,
				Default->Automatic,
				Description->"The solution used for equilibrating the magnetic beads to a condition for optimal bead-target binding prior to adding samples to the magnetic beads.",
				ResolutionDescription->"Automatically set to Model[Sample,\"Milli-Q water\"] if Equilibration is set to True.",
				AllowNull->True,
				Widget->Widget[
					Type->Object,
					Pattern:>ObjectP[{Model[Sample],Object[Sample]}],
					OpenPaths -> {
						{Object[Catalog, "Root"], "Materials", "Reagents", "Buffers"}
					}
				],
				Category->"Equilibration",
				NestedIndexMatching->True
			},
			{
				OptionName->EquilibrationBufferVolume,
				Default->Automatic,
				Description->"The amount of EquilibrationBuffer to add to the magnetic beads for equilibration.",
				ResolutionDescription->"If Equilibration is set to True, EquilibrationBufferVolume is automatically set to PreWashBufferVolume when PreWash is set to True, and is set to Volume when PreWash is set to False.",
				AllowNull->True,
				Widget->Widget[Type->Quantity,Pattern:>RangeP[1 Microliter,50 Milliliter],Units->{Microliter,{Microliter,Milliliter}}],
				Category->"Equilibration",
				NestedIndexMatching->True
			},
			{
				OptionName->EquilibrationMix,
				Default->Automatic,
				Description->"Indicates if the solution is mixed following combination of EquilibrationBuffer and the magnetic beads.",
				ResolutionDescription->"Automatically set to True if Equilibration is set to True and Equilibration MixType is not set to Null.",
				AllowNull->True,
				Widget->Widget[Type->Enumeration,Pattern:>BooleanP],
				Category->"Equilibration",
				NestedIndexMatching->True
			},

			ModifyOptions[ExperimentMix,
				{
					OptionName -> MixType,
					ModifiedOptionName -> EquilibrationMixType,
					Default->Automatic,
					Description -> "The style of motion used to mix the suspension following the addition of the EquilibrationBuffer to the magnetic beads. Options include Roll, Vortex, Sonicate, Pipette, Invert, Stir, Shake, Homogenize, Swirl, Disrupt, Nutate.",
					ResolutionDescription -> "Automatically set based on the volume-to-mix (i.e. the volume of the combined EquilibrationBuffer and magnetic beads) and the EquilibrationMix options. Specifically, EquilibrationMixType is automatically set to Pipette when the volume-to-mix is greater than 20 Microliter and none of EquilibrationMixRate, EquilibrationMixTemperature, and EquilibrationMixTime is specified to non-default values; otherwise, EquilibrationMixType is automatically set to Vortex when Preparation is Manual, EquilibrationMixTemperature is Automatic or Ambient, and EquilibrationMixRate is specified to be greater than 600 RPM; otherwise, EquilibrationMixType is automatically set to Shake.",
					NestedIndexMatching -> True,
					Category -> "Equilibration",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> Time,
					ModifiedOptionName -> EquilibrationMixTime,
					Default->Automatic,
					Description -> "The duration during which the combined EquilibrationBuffer and magnetic beads are mixed.",
					ResolutionDescription -> "If EquilibrationMixType is among Disrupt, Nutate, Shake, Vortex, Roll, Stir, Homogenize, and Sonicate, EquilibrationMixTime is automatically set to 5 Minute for robotic preparation, and is set to 15 Minute for manual preparation.",
					NestedIndexMatching -> True,
					Category -> "Equilibration",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> MixRate,
					ModifiedOptionName -> EquilibrationMixRate,
					Default->Automatic,
					Description -> "The frequency of rotation used to mix the combined EquilibrationBuffer and magnetic beads.",
					ResolutionDescription -> "Automatically set to 300 RPM if EquilibrationMixType is Shake or Stir, to 1000 RPM if EquilibrationMixType is Vortex or Disrupt, and to 30 RPM if EquilibrationMixType is Nutate or Roll.",
					NestedIndexMatching -> True,
					Category -> "Equilibration",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> NumberOfMixes,
					ModifiedOptionName -> NumberOfEquilibrationMixes,
					Default->Automatic,
					Description -> "The number of times that the combined EquilibrationBuffer and magnetic beads are mixed if EquilibrationMixType is Pipette or Invert.",
					ResolutionDescription -> "Automatically set to 20 if EquilibrationMixType is Pipette, Swirl or Invert.",
					NestedIndexMatching -> True,
					Category -> "Equilibration",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> MixVolume,
					ModifiedOptionName -> EquilibrationMixVolume,
					Default->Automatic,
					Description ->"The volume of the combined EquilibrationBuffer and magnetic beads that is pipetted up and down in order to mix, if EquilibrationMixType->Pipette.",
					ResolutionDescription -> "For robotic preparation, EquilibrationMixVolume is automatically set to 970 Microliter if 0.8*volume-to-mix (i.e.volume-to-mix is the volume of the combined EquilibrationBuffer and magnetic beads) is greater than 970 Microliter, and otherwise is set to the greater of 10 Microliter and 0.8*volume-to-mix. For manual preparation, EquilibrationMixVolume is automatically set to the lesser of 50 Milliliter and 0.8*volume-to-mix.",
					NestedIndexMatching -> True,
					Category -> "Equilibration",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> Temperature,
					ModifiedOptionName -> EquilibrationMixTemperature,
					Default->Automatic,
					Description ->"The temperature of the device that is used to mix/incubate the combined EquilibrationBuffer and magnetic beads.",
					ResolutionDescription->"Automatically set to Ambient if EquilibrationMix is set to True and EquilibrationMixType is not Null.",
					NestedIndexMatching -> True,
					Category -> "Equilibration",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> TipType,
					ModifiedOptionName -> EquilibrationMixTipType,
					Default->Automatic,
					Description -> "The type of pipette tips used to mix the combined EquilibrationBuffer and magnetic beads. Options include Normal, Barrier, WideBore, GelLoading, Aspirator. This option can only be set if EquilibrationMixType->Pipette.",
					ResolutionDescription -> "Automatically set to WideBore for robotic preparation. For manual preparation, EquilibrationMixTipType is automatically set to WideBore if EquilibrationMixVolume is less or equal to 970 Microliter, to Normal if EquilibrationMixVolume is larger than 970 Microliter but less or equal to 5 Milliliter, and to Barrier if EquilibrationMixVolume is larger than 5 Milliliter.",
					NestedIndexMatching -> True,
					Category -> "Equilibration",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> TipMaterial,
					ModifiedOptionName -> EquilibrationMixTipMaterial,
					Default->Automatic,
					Description -> "The material of the pipette tips used to aspirate and dispense the requested volume during the EquilibrationMix. This option can only be set if EquilibrationMixType->Pipette.",
					ResolutionDescription -> "Automatically set to Polypropylene if EquilibrationMixVolume is less or equal to 5 Milliliter, and to Glass if EquilibrationMixVolume is larger than 5 Milliliter.",
					NestedIndexMatching -> True,
					Category -> "Equilibration",
					IndexMatchingOptions -> {}
				}
			],
			{
				OptionName->EquilibrationMagnetizationTime,
				Default->Automatic,
				Description->"The duration of magnetizing the magnetic beads after EquilibrationMixTime has elapsed in order to attract the magnetic beads to the side of the container by applying a magnetic force, thus enables removal or collection of the used EquilibrationBuffer.",
				ResolutionDescription->"Automatically set to 5 minutes if Equilibration is set to True.",
				AllowNull->True,
				Widget->Widget[
					Type->Quantity,
					Pattern:>RangeP[0 Second,$MaxExperimentTime],
					Units->{Second,{Second,Minute,Hour}}
				],
				Category->"Equilibration",
				NestedIndexMatching->True
			},
			{
				OptionName->EquilibrationAspirationVolume,
				Default->Automatic,
				Description->"The volume of solution to aspirate out while the magnetic beads are magnetized and gathered to the side during equilibration.",
				ResolutionDescription->"Automatically set to All for manual preparation, and set to EquilibrationBufferVolume for robotic preparation, if Equilibration is set to True. Set to Null if Equilibration is set to False.",
				AllowNull->True,
				Widget->Alternatives[
					"All"->Widget[Type->Enumeration,Pattern:>Alternatives[All]],
					"Volume"->Widget[Type->Quantity,Pattern:>RangeP[1 Microliter,50 Milliliter],Units->{Microliter,{Microliter,Milliliter}}]
				],
				Category->"Equilibration",
				NestedIndexMatching->True
			},
      ModifyOptions[TransferRoboticTipOptions,
        {
          OptionName -> AspirationPosition,
          ModifiedOptionName -> EquilibrationAspirationPosition,
          Default->Automatic,
          AllowNull ->True,
          Widget -> Widget[
            Type -> Enumeration,
            Pattern :> MagneticBeadSeparationPipettingPositionP
          ],
          Description -> "The location from which the solution is aspirated after EquilibrationMagnetizationTime. Top will aspirate EquilibrationAspirationPositionOffset below the Top of the container, Bottom will aspirate EquilibrationAspirationPositionOffset above the Bottom of the container, and LiquidLevel will aspirate EquilibrationAspirationPositionOffset below the liquid level of the sample in the container.",
          ResolutionDescription -> "Automatically set to Bottom if Preparation is Robotic and Equilibration is True.",
          NestedIndexMatching -> True,
          Category -> "Equilibration"
        }
      ],
      ModifyOptions[TransferRoboticTipOptions,
        {
          OptionName -> AspirationPositionOffset,
          ModifiedOptionName -> EquilibrationAspirationPositionOffset,
          Default->Automatic,
          AllowNull ->True,
          Description -> "The distance from the center of the well that the solution is aspirated after EquilibrationMagnetizationTime. The Z Offset is based on the EquilibrationAspirationPosition option -- measured as the height below the top of the well (Top), the height above the bottom of the well (Bottom), or the height below the detected liquid level (LiquidLevel). Please refer to the AspirationPosition diagram in the help file of ExperimentTransfer for more information. If an X and Y offset is not specified, the liquid will be aspirated in the center of the well, otherwise, -X/+X values will shift the position left and right, respectively, and -Y/+Y values will shift the position down and up, respectively.",
          ResolutionDescription -> "Automatically set to 0 Millimeter if MagnetizationRack is Model[Item,MagnetizationRack,\"Alpaqua Magnum FLX Enhanced Universal Magnet 96-well Plate Rack\"] and EquilibrationAspirationPosition is bottom, otherwise set to 2 Millimeter.",
          NestedIndexMatching -> True,
          Category -> "Equilibration"
        }
      ],
			{
				OptionName->EquilibrationCollectionContainer,
				Default->Automatic,
				Description->"The container for collecting the aspirated used EquilibrationBuffer during the equilibration.",
				ResolutionDescription->"Automatically set to a container plate and its first available position. The container plate is selected by the function PreferredContainer given the volume of EquilibrationAspirationVolume for manual preparation, and is set to 2 mL Deep well plate for robotic preparation, if Equilibration is set to True.",
				AllowNull->True,
				Widget -> Alternatives[
					Adder[
						Alternatives[
							"Container" -> Widget[
								Type -> Object,
								Pattern :> ObjectP[{Object[Container], Model[Container]}]
							],
							"Container with Index" -> {
								"Index" -> Widget[
									Type -> Number,
									Pattern :> GreaterEqualP[1, 1]
								],
								"Container" -> Widget[
									Type -> Object,
									Pattern :> ObjectP[Model[Container]],
									PreparedSample -> False,
									PreparedContainer -> False
								]
							},
							"Container with Well" -> {
								"Well" -> Widget[
									Type -> Enumeration,
									Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
									PatternTooltip -> "Enumeration must be any well from A1 to H12."
								],
								"Container" -> Widget[
									Type -> Object,
									Pattern :> ObjectP[Model[Container]],
									PreparedSample -> False,
									PreparedContainer -> False
								]
							},
							"Container with Well and Index" -> {
								"Well" -> Widget[
									Type -> Enumeration,
									Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
									PatternTooltip -> "Enumeration must be any well from A1 to H12."
								],
								"Index and Container"->{
									"Index"->Widget[
										Type->Number,
										Pattern:>GreaterEqualP[1,1]
									],
									"Container"->Widget[
										Type->Object,
										Pattern:>ObjectP[{Model[Container]}],
										PreparedSample->False,
										PreparedContainer->False
									]
								}
							},
							"Automatic or Null" -> Widget[
								Type -> Enumeration,
								Pattern :> Alternatives[Automatic,Null]
							]
						]
					],
					Alternatives[
						"Container" -> Widget[
							Type -> Object,
							Pattern :> ObjectP[{Object[Container], Model[Container]}]
						],
						"Container with Index" -> {
							"Index" -> Widget[
								Type -> Number,
								Pattern :> GreaterEqualP[1, 1]
							],
							"Container" -> Widget[
								Type -> Object,
								Pattern :> ObjectP[Model[Container]],
								PreparedSample -> False,
								PreparedContainer -> False
							]
						},
						"Container with Well" -> {
							"Well" -> Widget[
								Type -> Enumeration,
								Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
								PatternTooltip -> "Enumeration must be any well from A1 to H12."
							],
							"Container" -> Widget[
								Type -> Object,
								Pattern :> ObjectP[Model[Container]],
								PreparedSample -> False,
								PreparedContainer -> False
							]
						},
						"Container with Well and Index" -> {
							"Well" -> Widget[
								Type -> Enumeration,
								Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
								PatternTooltip -> "Enumeration must be any well from A1 to H12."
							],
							"Index and Container"->{
								"Index"->Widget[
									Type->Number,
									Pattern:>GreaterEqualP[1,1]
								],
								"Container"->Widget[
									Type->Object,
									Pattern:>ObjectP[{Model[Container]}],
									PreparedSample->False,
									PreparedContainer->False
								]
							}
						}
					]
				],
				Category->"Equilibration",
				NestedIndexMatching->True
			},
			{
				OptionName->EquilibrationCollectionStorageCondition,
				Default->Automatic,
				Description->"The non-default condition under which the aspirated samples during the equilibration are stored after the protocol is completed.",
				ResolutionDescription->"Automatically set to Refrigerator if Equilibration is set to True.",
				AllowNull->True,
				Widget->Alternatives[
					"Condition"->Widget[
						Type->Enumeration,Pattern:>SampleStorageTypeP|Disposal
					],
					"Objects"->Widget[
						Type->Object,
						Pattern:>ObjectP[Model[StorageCondition]],
						OpenPaths->{
							{Object[Catalog,"Root"],
								"Storage Conditions"}
						}
					]
				],
				Category->"Post Experiment",
				NestedIndexMatching->True
			},
			{
				OptionName->EquilibrationAirDry,
				Default->Automatic,
				Description->"Indicates if the magnetic beads are exposed to open air to evaporate the remaining EquilibrationBuffer before contact with the input sample.",
				ResolutionDescription->"Automatically set to False if Equilibration is set to True.",
				AllowNull->True,
				Widget->Widget[Type->Enumeration,Pattern:>BooleanP],
				Category->"Equilibration",
				NestedIndexMatching->True
			},
			{
				OptionName->EquilibrationAirDryTime,
				Default->Automatic,
				Description->"The duration that the magnetic beads are exposed to open air to evaporate the remaining EquilibrationBuffer before contact with the input sample.",
				ResolutionDescription->"Automatically set to 1 Minute if EquilibrationAirDry is set to True.",
				AllowNull->True,
				Widget->Widget[
					Type->Quantity,
					Pattern:>RangeP[0 Second,$MaxExperimentTime],
					Units->{Second,{Second,Minute,Hour}}],
				Category->"Equilibration",
				NestedIndexMatching->True
			},


			(*===Loading===*)
			{
				OptionName->LoadingMix,
				NestedIndexMatching->True,
				Default->Automatic,
				Description->"Indicates if the solution is mixed following the combination of the input sample and the magnetic beads.",
        ResolutionDescription->"Automatically set to True if LoadingMixType is not set to Null.",
				AllowNull->True,
				Widget->Widget[Type->Enumeration,Pattern:>BooleanP],
				Category->"Loading"
			},
			ModifyOptions[ExperimentMix,
				{
					OptionName -> MixType,
					ModifiedOptionName -> LoadingMixType,
					Default->Automatic,
					Description -> "The style of motion used to mix the suspension following the addition of the SamplesIn to the magnetic beads. Options include Roll, Vortex, Sonicate, Pipette, Invert, Stir, Shake, Homogenize, Swirl, Disrupt, Nutate.",
					ResolutionDescription -> "Automatically set based on the volume-to-mix (i.e. the volume of the combined SamplesIn and magnetic beads) and the LoadingMix options. Specifically, LoadingMixType is automatically set to Pipette when the volume-to-mix is greater than 20 Microliter and none of LoadingMixRate, LoadingMixTemperature, and LoadingMixTime is specified to non-default values; otherwise, LoadingMixType is automatically set to Vortex when Preparation is Manual, LoadingMixTemperature is Automatic or Ambient, and LoadingMixRate is specified to be greater than 600 RPM; otherwise, LoadingMixType is automatically set to Shake.",
					NestedIndexMatching -> True,
					Category -> "Loading",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> Time,
					ModifiedOptionName -> LoadingMixTime,
					Default->Automatic,
					Description -> "The duration during which the combined SamplesIn and magnetic beads are mixed.",
					ResolutionDescription -> "If LoadingMixType is among Disrupt, Nutate, Shake, Vortex, Roll, Stir, Homogenize, and Sonicate, LoadingMixTime is automatically set to 5 Minute for robotic preparation, and is set to 15 Minute for manual preparation.",
					NestedIndexMatching -> True,
					Category -> "Loading",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> MixRate,
					ModifiedOptionName -> LoadingMixRate,
					Default->Automatic,
					Description -> "The frequency of rotation used to mix the combined SamplesIn and magnetic beads.",
					ResolutionDescription -> "Automatically set to 300 RPM if LoadingMixType is Shake or Stir, to 1000 RPM if LoadingMixType is Vortex or Disrupt, and to 30 RPM if LoadingMixType is Nutate or Roll.",
					NestedIndexMatching -> True,
					Category -> "Loading",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> NumberOfMixes,
					ModifiedOptionName -> NumberOfLoadingMixes,
					Default->Automatic,
					Description -> "The number of times that the combined SamplesIn and magnetic beads are mixed if LoadingMixType is Pipette or Invert.",
					ResolutionDescription -> "Automatically set to 20 if LoadingMixType is Pipette, Swirl or Invert.",
					NestedIndexMatching -> True,
					Category -> "Loading",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> MixVolume,
					ModifiedOptionName -> LoadingMixVolume,
					Default->Automatic,
					Description ->"The volume of the combined SamplesIn and magnetic beads that is pipetted up and down in order to mix, if LoadingMixType->Pipette.",
					ResolutionDescription -> "For robotic preparation, LoadingMixVolume is automatically set to 970 Microliter if 0.8*volume-to-mix (i.e.volume-to-mix is the combined sample volume and magnetic beads volume) is greater than 970 Microliter, and otherwise is set to the greater of 10 Microliter and 0.8*volume-to-mix. For manual preparation, LoadingMixVolume is automatically set to the lesser of 50 Milliliter and 0.8*volume-to-mix.",
					NestedIndexMatching -> True,
					Category -> "Loading",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> Temperature,
					ModifiedOptionName -> LoadingMixTemperature,
					Default->Automatic,
					Description ->"The temperature of the device that is used to mix/incubate the combined SamplesIn and magnetic beads.",
					ResolutionDescription->"Automatically set to Ambient if LoadingMix is set to True and LoadingMixType is not Null.",
					NestedIndexMatching -> True,
					Category -> "Loading",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> TipType,
					ModifiedOptionName -> LoadingMixTipType,
					Default->Automatic,
					Description -> "The type of pipette tips used to mix the combined sample and magnetic beads. Options include Normal, Barrier, WideBore, GelLoading, Aspirator. This option can only be set if LoadingMixType->Pipette.",
					ResolutionDescription -> "Automatically set to WideBore for robotic preparation. For manual preparation, LoadingMixTipType is automatically set to WideBore if LoadingMixVolume is less or equal to 970 Microliter, to Normal if LoadingMixVolume is larger than 970 Microliter but less or equal to 5 Milliliter, and to Barrier if LoadingMixVolume is larger than 5 Milliliter.",
					NestedIndexMatching -> True,
					Category -> "Loading",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> TipMaterial,
					ModifiedOptionName -> LoadingMixTipMaterial,
					Default->Automatic,
					Description -> "The material of the pipette tips used to aspirate and dispense the requested volume during the LoadingMix. This option can only be set if LoadingMixType->Pipette.",
					ResolutionDescription -> "Automatically set to Polypropylene if LoadingMixVolume is less or equal to 5 Milliliter, and to Glass if LoadingMixVolume is larger than 5 Milliliter.",
					NestedIndexMatching -> True,
					Category -> "Loading",
					IndexMatchingOptions -> {}
				}
			],
			{
				OptionName->LoadingMagnetizationTime,
				NestedIndexMatching->True,
				Default->5 Minute,
				Description->"The duration of magnetizing the magnetic beads after LoadingMixTime has elapsed, in order to pull the magnetic beads to the perimeter of the container by applying a magnetic force, thus enables maximal aspiration of the sample solution containing components that are not bound to the magnetic beads.",
				AllowNull->False,
				Widget->Widget[Type->Quantity,Pattern:>RangeP[0 Second,$MaxExperimentTime],Units->{Second,{Second,Minute,Hour}}],
				Category -> "Loading",
				NestedIndexMatching->True
			},
			{
				OptionName->LoadingAspirationVolume,
				NestedIndexMatching->True,
				Default->Automatic,
				Description->"The volume of sample solution to aspirate out while the magnetic beads are magnetized and gathered to the side.",
				AllowNull->False,
				Widget->Alternatives[
					"All"->Widget[Type->Enumeration,Pattern:>Alternatives[All]],
					"Volume"->Widget[Type->Quantity,Pattern:>RangeP[1 Microliter,50 Milliliter],Units->{Microliter,{Microliter,Milliliter}}]
				],
				Category->"Loading",
				NestedIndexMatching->True
			},
      ModifyOptions[TransferRoboticTipOptions,
        {
          OptionName -> AspirationPosition,
          ModifiedOptionName -> LoadingAspirationPosition,
          Default->Automatic,
          AllowNull ->True,
          Widget -> Widget[
            Type -> Enumeration,
            Pattern :> MagneticBeadSeparationPipettingPositionP
          ],
          Description -> "The location from which the solution is aspirated after LoadingMagnetizationTime. Top will aspirate LoadingAspirationPositionOffset below the Top of the container, Bottom will aspirate LoadingAspirationPositionOffset above the Bottom of the container, and LiquidLevel will aspirate LoadingAspirationPositionOffset below the liquid level of the sample in the container.",
          ResolutionDescription -> "Automatically set to Bottom if Preparation->Robotic.",
          NestedIndexMatching -> True,
          Category -> "Loading"
        }
      ],
      ModifyOptions[TransferRoboticTipOptions,
        {
          OptionName -> AspirationPositionOffset,
          ModifiedOptionName -> LoadingAspirationPositionOffset,
          Default->Automatic,
          AllowNull ->True,
          Description -> "The distance from the center of the well that the solution is aspirated after LoadingMagnetizationTime. The Z Offset is based on the LoadingAspirationPosition option -- measured as the height below the top of the well (Top), the height above the bottom of the well (Bottom), or the height below the detected liquid level (LiquidLevel). Please refer to the AspirationPosition diagram in the help file of ExperimentTransfer for more information. If an X and Y offset is not specified, the liquid will be aspirated in the center of the well, otherwise, -X/+X values will shift the position left and right, respectively, and -Y/+Y values will shift the position down and up, respectively.",
          ResolutionDescription -> "Automatically set to 0 Millimeter if MagnetizationRack is Model[Item,MagnetizationRack,\"Alpaqua Magnum FLX Enhanced Universal Magnet 96-well Plate Rack\"] and LoadingAspirationPosition is bottom, otherwise set to 2 Millimeter.",
          NestedIndexMatching -> True,
          Category -> "Loading"
        }
      ],
			{
				OptionName->LoadingCollectionContainer,
				Default->Automatic,
				Description->"The container for collecting the aspirated sample during loading. By default, the same container is selected for samples in the same pool (i.e. aspirated samples in the same pool will be combined) unless different container objects are specified for samples in the pool.",
				ResolutionDescription->"Automatically set to a container plate and its first available position. The container plate is selected by the function PreferredContainer given the volume of LoadingAspirationVolume for manual preparation, and is set to 2 mL Deep well plate for robotic preparation, if Loading is set to True.",
				AllowNull->False,
				Widget -> Alternatives[
					Adder[
						Alternatives[
							"Container" -> Widget[
								Type -> Object,
								Pattern :> ObjectP[{Object[Container], Model[Container]}]
							],
							"Container with Index" -> {
								"Index" -> Widget[
									Type -> Number,
									Pattern :> GreaterEqualP[1, 1]
								],
								"Container" -> Widget[
									Type -> Object,
									Pattern :> ObjectP[Model[Container]],
									PreparedSample -> False,
									PreparedContainer -> False
								]
							},
							"Container with Well" -> {
								"Well" -> Widget[
									Type -> Enumeration,
									Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
									PatternTooltip -> "Enumeration must be any well from A1 to H12."
								],
								"Container" -> Widget[
									Type -> Object,
									Pattern :> ObjectP[Model[Container]],
									PreparedSample -> False,
									PreparedContainer -> False
								]
							},
							"Container with Well and Index" -> {
								"Well" -> Widget[
									Type -> Enumeration,
									Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
									PatternTooltip -> "Enumeration must be any well from A1 to H12."
								],
								"Index and Container"->{
									"Index"->Widget[
										Type->Number,
										Pattern:>GreaterEqualP[1,1]
									],
									"Container"->Widget[
										Type->Object,
										Pattern:>ObjectP[{Model[Container]}],
										PreparedSample->False,
										PreparedContainer->False
									]
								}
							},
							"Automatic or Null" -> Widget[
								Type -> Enumeration,
								Pattern :> Alternatives[Automatic,Null]
							]
						]
					],
					Alternatives[
						"Container" -> Widget[
							Type -> Object,
							Pattern :> ObjectP[{Object[Container], Model[Container]}]
						],
						"Container with Index" -> {
							"Index" -> Widget[
								Type -> Number,
								Pattern :> GreaterEqualP[1, 1]
							],
							"Container" -> Widget[
								Type -> Object,
								Pattern :> ObjectP[Model[Container]],
								PreparedSample -> False,
								PreparedContainer -> False
							]
						},
						"Container with Well" -> {
							"Well" -> Widget[
								Type -> Enumeration,
								Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
								PatternTooltip -> "Enumeration must be any well from A1 to H12."
							],
							"Container" -> Widget[
								Type -> Object,
								Pattern :> ObjectP[Model[Container]],
								PreparedSample -> False,
								PreparedContainer -> False
							]
						},
						"Container with Well and Index" -> {
							"Well" -> Widget[
								Type -> Enumeration,
								Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
								PatternTooltip -> "Enumeration must be any well from A1 to H12."
							],
							"Index and Container"->{
								"Index"->Widget[
									Type->Number,
									Pattern:>GreaterEqualP[1,1]
								],
								"Container"->Widget[
									Type->Object,
									Pattern:>ObjectP[{Model[Container]}],
									PreparedSample->False,
									PreparedContainer->False
								]
							}
						}
					]
				],
				Category->"Loading",
				NestedIndexMatching->True
			},
			{
				OptionName->LoadingCollectionStorageCondition,
				NestedIndexMatching->True,
				Default->Refrigerator,
				Description->"The non-default condition under which the aspirated samples during loading are stored after the protocol is completed.",
				AllowNull->True,
				Widget->Alternatives[
					"Condition"->Widget[
						Type->Enumeration,Pattern:>SampleStorageTypeP|Disposal
					],
					"Objects"->Widget[
						Type->Object,
						Pattern:>ObjectP[Model[StorageCondition]],
						OpenPaths->{
							{Object[Catalog,"Root"],
								"Storage Conditions"}
						}
					]
				],
				Category->"Post Experiment",
				NestedIndexMatching->True
			},
			{
				OptionName->LoadingAirDry,
				NestedIndexMatching->True,
				Default->False,
				Description->"Indicates if the magnetic beads are exposed to open air to evaporate the remaining solution of the sample after aspirating the supernatant.",
				AllowNull->False,
				Widget->Widget[Type->Enumeration,Pattern:>BooleanP],
				Category->"Loading",
				NestedIndexMatching->True
			},
			{
				OptionName->LoadingAirDryTime,
				NestedIndexMatching->True,
				Default->Automatic,
				Description->"The duration that the magnetic beads are exposed to open air to evaporate the remaining solution of the sample after aspirating the supernatant.",
				ResolutionDescription->"Automatically set to 1 Minute if LoadingAirDry is set to True.",
				AllowNull->True,
				Widget->Widget[
					Type->Quantity,
					Pattern:>RangeP[0 Second,$MaxExperimentTime],
					Units->{Second,{Second,Minute,Hour}}
				],
				Category->"Loading",
				NestedIndexMatching->True
			},


			(*===Wash===*)

			(*--- PrimaryWash---*)
			{
				OptionName->Wash,
				Default->Automatic,
				Description->"Indicates if the magnetic beads with bound targets or contaminants are rinsed prior to elution or optional SecondaryWash, in order to better separate the bead-bound components from the unbound components in the sample, or for on-bead digestion. The washing steps (up to SeptenaryWash) can optionally be used for on-bead digestion to perform alkylation, reduction, trypsin digestion, etc.",
				ResolutionDescription->"Automatically set to True if other Wash options are set, or False otherwise.",
				AllowNull->False,
				Widget->Widget[Type->Enumeration,Pattern:>BooleanP],
				Category->"Wash",
				NestedIndexMatching->True
			},
			{
				OptionName->WashBuffer,
				Default->Automatic,
				Description->"The solution used to rinse the magnetic beads during Wash prior to elution or optional SecondaryWash, in order to better separate the bead-bound components from the unbound components in the sample, or for on-bead digestion.",
				ResolutionDescription->"Automatically set to Model[Sample,\"Milli-Q water\"] if Wash is set to True.",
				AllowNull->True,
				Widget->Widget[
					Type->Object,
					Pattern:>ObjectP[{Model[Sample],Object[Sample]}],
					OpenPaths -> {
						{Object[Catalog, "Root"], "Materials", "Magnetic Bead Separation", "Wash Solutions"},
						{Object[Catalog, "Root"], "Materials", "Reagents", "Buffers"}
					}
				],

				Category->"Wash",
				NestedIndexMatching->True
			},
			{
				OptionName->WashBufferVolume,
				Default->Automatic,
				Description->"The amount of WashBuffer that is added to the magnetic beads for each wash prior to elution or optional SecondaryWash.",
				ResolutionDescription->"If Wash is set to True, WashBufferVolume is automatically set to PreWashBufferVolume when PreWash is set to True, and is set to Volume when PreWash is set to False.",
				AllowNull->True,
				Widget->Widget[Type->Quantity,Pattern:>RangeP[1 Microliter,50 Milliliter],Units->{Microliter,{Microliter,Milliliter}}],
				Category->"Wash",
				NestedIndexMatching->True
			},
			{
				OptionName->WashMix,
				Default->Automatic,
				Description->"Indicates if the solution is mixed following combination of WashBuffer and the magnetic beads during each wash.",
				ResolutionDescription->"Automatically set to True if Wash is set to True and WashMixType is not set to Null.",
				AllowNull->True,
				Widget->Widget[Type->Enumeration,Pattern:>BooleanP],
				Category->"Wash",
				NestedIndexMatching->True
			},
			ModifyOptions[ExperimentMix,
				{
					OptionName -> MixType,
					ModifiedOptionName -> WashMixType,
					Default->Automatic,
					Description -> "The style of motion used to mix the suspension following the addition of the WashBuffer to the magnetic beads. Options include Roll, Vortex, Sonicate, Pipette, Invert, Stir, Shake, Homogenize, Swirl, Disrupt, Nutate.",
					ResolutionDescription -> "Automatically set based on the volume-to-mix (i.e. the volume of the combined WashBuffer and magnetic beads) and the WashMix options. Specifically, WashMixType is automatically set to Pipette when the volume-to-mix is greater than 20 Microliter and none of WashMixRate, WashMixTemperature, and WashMixTime is specified to non-default values; otherwise, WashMixType is automatically set to Vortex when Preparation is Manual, WashMixTemperature is Automatic or Ambient, and WashMixRate is specified to be greater than 600 RPM; otherwise, WashMixType is automatically set to Shake.",
					NestedIndexMatching -> True,
					Category -> "Wash",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> Time,
					ModifiedOptionName -> WashMixTime,
					Default->Automatic,
					Description -> "The duration during which the combined WashBuffer and magnetic beads are mixed.",
					ResolutionDescription -> "If WashMixType is among Disrupt, Nutate, Shake, Vortex, Roll, Stir, Homogenize, and Sonicate, WashMixTime is automatically set to 5 Minute for robotic preparation, and is set to 15 Minute for manual preparation.",
					NestedIndexMatching -> True,
					Category -> "Wash",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> MixRate,
					ModifiedOptionName -> WashMixRate,
					Default->Automatic,
					Description -> "The frequency of rotation used to mix the combined WashBuffer and magnetic beads.",
					ResolutionDescription -> "Automatically set to 300 RPM if WashMixType is Shake or Stir, to 1000 RPM if WashMixType is Vortex or Disrupt, and to 30 RPM if WashMixType is Nutate or Roll.",
					NestedIndexMatching -> True,
					Category -> "Wash",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> NumberOfMixes,
					ModifiedOptionName -> NumberOfWashMixes,
					Default->Automatic,
					Description -> "The number of times that the combined WashBuffer and magnetic beads are mixed if WashMixType is Pipette or Invert.",
					ResolutionDescription -> "Automatically set to 20 if WashMixType is Pipette, Swirl or Invert.",
					NestedIndexMatching -> True,
					Category -> "Wash",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> MixVolume,
					ModifiedOptionName -> WashMixVolume,
					Default->Automatic,
					Description ->"The volume of the combined WashBuffer and magnetic beads that is pipetted up and down in order to mix, if WashMixType->Pipette.",
					ResolutionDescription -> "For robotic preparation, WashMixVolume is automatically set to 970 Microliter if 0.8*volume-to-mix (i.e.volume-to-mix is the volume of the combined WashBuffer and magnetic beads) is greater than 970 Microliter, and otherwise is set to the greater of 10 Microliter and 0.8*volume-to-mix. For manual preparation, WashMixVolume is automatically set to the lesser of 50 Milliliter and 0.8*volume-to-mix.",
					NestedIndexMatching -> True,
					Category -> "Wash",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> Temperature,
					ModifiedOptionName -> WashMixTemperature,
					Default->Automatic,
					Description ->"The temperature of the device that is used to mix/incubate the combined WashBuffer and magnetic beads.",
					ResolutionDescription->"Automatically set to Ambient if WashMix is set to True and WashMixType is not Null.",
					NestedIndexMatching -> True,
					Category -> "Wash",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> TipType,
					ModifiedOptionName -> WashMixTipType,
					Default->Automatic,
					Description -> "The type of pipette tips used to mix the combined WashBuffer and magnetic beads. Options include Normal, Barrier, WideBore, GelLoading, Aspirator. This option can only be set if WashMixType->Pipette.",
					ResolutionDescription -> "Automatically set to WideBore for robotic preparation. For manual preparation, WashMixTipType is automatically set to WideBore if WashMixVolume is less or equal to 970 Microliter, to Normal if WashMixVolume is larger than 970 Microliter but less or equal to 5 Milliliter, and to Barrier if WashMixVolume is larger than 5 Milliliter.",
					NestedIndexMatching -> True,
					Category -> "Wash",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> TipMaterial,
					ModifiedOptionName -> WashMixTipMaterial,
					Default->Automatic,
					Description -> "The material of the pipette tips used to aspirate and dispense the requested volume during the WashMix. This option can only be set if WashMixType->Pipette.",
					ResolutionDescription -> "Automatically set to Polypropylene if WashMixVolume is less or equal to 5 Milliliter, and to Glass if WashMixVolume is larger than 5 Milliliter.",
					NestedIndexMatching -> True,
					Category -> "Wash",
					IndexMatchingOptions -> {}
				}
			],
			{
				OptionName->WashMagnetizationTime,
				Default->Automatic,
				Description->"The duration of magnetizing the magnetic beads after WashMixTime has elapsed, in order to pull the magnetic beads to the perimeter of the container by applying a magnetic force, thus enables maximal aspiration of the used WashBuffer containing residual sample components that are not bound to the magnetic beads.",
				ResolutionDescription->"Automatically set to 5 minutes if Wash is set to True.",
				AllowNull->True,
				Widget->Widget[Type->Quantity,Pattern:>RangeP[0 Second,$MaxExperimentTime],Units->{Second,{Second,Minute,Hour}}],
				Category->"Wash",
				NestedIndexMatching->True
			},
			{
				OptionName->WashAspirationVolume,
				Default->Automatic,
				Description->"The volume of solution to aspirate out while the magnetic beads are magnetized and gathered to the side during each wash prior to elution or optional SecondaryWash.",
				ResolutionDescription->"Automatically set to All for manual preparation, and set to WashBufferVolume for robotic preparation.",
				AllowNull->True,
				Widget->Alternatives[
					"All"->Widget[Type->Enumeration,Pattern:>Alternatives[All]],
					"Volume"->Widget[Type->Quantity,Pattern:>RangeP[1 Microliter,50 Milliliter],Units->{Microliter,{Microliter,Milliliter}}]
				],
				Category->"Wash",
				NestedIndexMatching->True
			},
      ModifyOptions[TransferRoboticTipOptions,
        {
          OptionName -> AspirationPosition,
          ModifiedOptionName -> WashAspirationPosition,
          Default->Automatic,
          AllowNull ->True,
          Widget -> Widget[
            Type -> Enumeration,
            Pattern :> MagneticBeadSeparationPipettingPositionP
          ],
          Description -> "The location from which the solution is aspirated after WashMagnetizationTime. Top will aspirate WashAspirationPositionOffset below the Top of the container, Bottom will aspirate WashAspirationPositionOffset above the Bottom of the container, and LiquidLevel will aspirate WashAspirationPositionOffset below the liquid level of the sample in the container.",
          ResolutionDescription -> "Automatically set to Bottom if Preparation->Robotic and Wash is True.",
          NestedIndexMatching -> True,
          Category -> "Wash"
        }
      ],
      ModifyOptions[TransferRoboticTipOptions,
        {
          OptionName -> AspirationPositionOffset,
          ModifiedOptionName -> WashAspirationPositionOffset,
          Default->Automatic,
          AllowNull ->True,
          Description -> "The distance from the center of the well that the solution is aspirated after WashMagnetizationTime. The Z Offset is based on the WashAspirationPosition option -- measured as the height below the top of the well (Top), the height above the bottom of the well (Bottom), or the height below the detected liquid level (LiquidLevel). Please refer to the AspirationPosition diagram in the help file of ExperimentTransfer for more information. If an X and Y offset is not specified, the liquid will be aspirated in the center of the well, otherwise, -X/+X values will shift the position left and right, respectively, and -Y/+Y values will shift the position down and up, respectively.",
          ResolutionDescription -> "Automatically set to 0 Millimeter if MagnetizationRack is Model[Item,MagnetizationRack,\"Alpaqua Magnum FLX Enhanced Universal Magnet 96-well Plate Rack\"] and WashAspirationPosition is bottom, otherwise set to 2 Millimeter.",
          NestedIndexMatching -> True,
          Category -> "Wash"
        }
      ],
			{
				OptionName->WashCollectionContainer,
				Default->Automatic,
				Description->"The container(s) for collecting the aspirated sample(s) during the wash(es) prior to elution or optional SecondaryWash. By default, the same container is selected for the repeated washes (i.e. aspirated samples in the repeated washes will be combined) unless different container objects are specified for the washes.",
				ResolutionDescription->"Automatically set to a container plate and its first available position. The container plate is selected by the function PreferredContainer given the volume of WashAspirationVolume for manual preparation, and is set to 2 mL Deep well plate for robotic preparation, if Wash is set to True.",
				AllowNull->True,
				Widget -> Alternatives[
					Adder[
						Alternatives[
							"Container" -> Widget[
								Type -> Object,
								Pattern :> ObjectP[{Object[Container], Model[Container]}]
							],
							"Container with Index" -> {
								"Index" -> Widget[
									Type -> Number,
									Pattern :> GreaterEqualP[1, 1]
								],
								"Container" -> Widget[
									Type -> Object,
									Pattern :> ObjectP[Model[Container]],
									PreparedSample -> False,
									PreparedContainer -> False
								]
							},
							"Container with Well" -> {
								"Well" -> Widget[
									Type -> Enumeration,
									Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
									PatternTooltip -> "Enumeration must be any well from A1 to H12."
								],
								"Container" -> Widget[
									Type -> Object,
									Pattern :> ObjectP[Model[Container]],
									PreparedSample -> False,
									PreparedContainer -> False
								]
							},
							"Container with Well and Index" -> {
								"Well" -> Widget[
									Type -> Enumeration,
									Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
									PatternTooltip -> "Enumeration must be any well from A1 to H12."
								],
								"Index and Container"->{
									"Index"->Widget[
										Type->Number,
										Pattern:>GreaterEqualP[1,1]
									],
									"Container"->Widget[
										Type->Object,
										Pattern:>ObjectP[{Model[Container]}],
										PreparedSample->False,
										PreparedContainer->False
									]
								}
							},
							"Automatic or Null" -> Widget[
								Type -> Enumeration,
								Pattern :> Alternatives[Automatic,Null]
							]
						]
					],
					Alternatives[
						"Container" -> Widget[
							Type -> Object,
							Pattern :> ObjectP[{Object[Container], Model[Container]}]
						],
						"Container with Index" -> {
							"Index" -> Widget[
								Type -> Number,
								Pattern :> GreaterEqualP[1, 1]
							],
							"Container" -> Widget[
								Type -> Object,
								Pattern :> ObjectP[Model[Container]],
								PreparedSample -> False,
								PreparedContainer -> False
							]
						},
						"Container with Well" -> {
							"Well" -> Widget[
								Type -> Enumeration,
								Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
								PatternTooltip -> "Enumeration must be any well from A1 to H12."
							],
							"Container" -> Widget[
								Type -> Object,
								Pattern :> ObjectP[Model[Container]],
								PreparedSample -> False,
								PreparedContainer -> False
							]
						},
						"Container with Well and Index" -> {
							"Well" -> Widget[
								Type -> Enumeration,
								Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
								PatternTooltip -> "Enumeration must be any well from A1 to H12."
							],
							"Index and Container"->{
								"Index"->Widget[
									Type->Number,
									Pattern:>GreaterEqualP[1,1]
								],
								"Container"->Widget[
									Type->Object,
									Pattern:>ObjectP[{Model[Container]}],
									PreparedSample->False,
									PreparedContainer->False
								]
							}
						}
					]
				],
				Category->"Wash",
				NestedIndexMatching->True
			},
			{
				OptionName->WashCollectionStorageCondition,
				Default->Automatic,
				Description->"The non-default condition under which the aspirated samples during the wash prior to elution or optional SecondaryWash are stored after the protocol is completed.",
				ResolutionDescription->"Automatically set to Refrigerator if Wash is set to True.",
				AllowNull->True,
				Widget->Alternatives[
					"Condition"->Widget[
						Type->Enumeration,Pattern:>SampleStorageTypeP|Disposal
					],
					"Objects"->Widget[
						Type->Object,
						Pattern:>ObjectP[Model[StorageCondition]],
						OpenPaths->{
							{Object[Catalog,"Root"],"Storage Conditions"}
						}
					]
				],
				Category->"Post Experiment",
				NestedIndexMatching->True
			},
			{
				OptionName->NumberOfWashes,
				Default->Automatic,
				Description->"The number of times the magnetic beads are washed by adding WashBuffer, mixing, magnetization, and aspirating solution prior to elution or optional SecondaryWash.",
				ResolutionDescription->"Automatically set to 1 if Wash is set to True.",
				AllowNull->True,
				Widget->Widget[Type->Number,Pattern:>RangeP[1,20,1]],
				Category->"Wash",
				NestedIndexMatching->True
			},
			{
				OptionName->WashAirDry,
				Default->Automatic,
				Description->"Indicates if the magnetic beads are exposed to open air to evaporate the remaining WashBuffer following the final wash prior to elution or optional SecondaryWash.",
				ResolutionDescription->"Automatically set to False if Wash is set to True.",
				AllowNull->True,
				Widget->Widget[Type->Enumeration,Pattern:>BooleanP],
				Category->"Wash",
				NestedIndexMatching->True
			},
			{
				OptionName->WashAirDryTime,
				Default->Automatic,
				Description->"The duration that the magnetic beads are exposed to open air to evaporate the remaining WashBuffer following the final wash prior to elution or optional SecondaryWash.",
				ResolutionDescription->"Automatically set to 1 Minute if WashAirDry is set to True.",
				AllowNull->True,
				Widget->Widget[Type->Quantity,Pattern:>RangeP[0 Second,$MaxExperimentTime],Units->{Second,{Second,Minute,Hour}}],
				Category->"Wash",
				NestedIndexMatching->True
			},

			(*--- SecondaryWash---*)
			{
				OptionName->SecondaryWash,
				Default->Automatic,
				Description->"Indicates if the magnetic beads with bound targets or contaminants are further rinsed after Wash prior to elution or optional TertiaryWash, in order to better separate the bead-bound components from the unbound components in the sample, or for on-bead digestion. The washing steps (up to SeptenaryWash) can optionally be used for on-bead digestion to perform alkylation, reduction, trypsin digestion, etc.",
				ResolutionDescription->"Automatically set to True if other SecondaryWash options are set, or False otherwise.",
				AllowNull->False,
				Widget->Widget[Type->Enumeration,Pattern:>BooleanP],
				Category->"Wash",
				NestedIndexMatching->True
			},
			{
				OptionName->SecondaryWashBuffer,
				Default->Automatic,
				Description->"The solution used to rinse the magnetic beads during SecondaryWash prior to elution or optional TertiaryWash, in order to better separate the bead-bound components from the unbound components in the sample, or for on-bead digestion.",
				ResolutionDescription->"Automatically set to Model[Sample,\"Milli-Q water\"] if SecondaryWash is set to True.",
				AllowNull->True,
				Widget->Widget[
					Type->Object,
					Pattern:>ObjectP[{Model[Sample],Object[Sample]}],
					OpenPaths -> {
						{Object[Catalog, "Root"], "Materials", "Magnetic Bead Separation", "Wash Solutions"},
						{Object[Catalog, "Root"], "Materials", "Reagents", "Buffers"}
					}
				],

				Category->"Wash",
				NestedIndexMatching->True
			},
			{
				OptionName->SecondaryWashBufferVolume,
				Default->Automatic,
				Description->"The amount of SecondaryWashBuffer that is added to the magnetic beads for each secondary wash prior to elution or optional TertiaryWash.",
				ResolutionDescription->"If SecondaryWash is set to True, SecondaryWashBufferVolume is automatically set to PreWashBufferVolume when PreWash is set to True, and is set to Volume when PreWash is set to False.",
				AllowNull->True,
				Widget->Widget[Type->Quantity,Pattern:>RangeP[1 Microliter,50 Milliliter],Units->{Microliter,{Microliter,Milliliter}}],
				Category->"Wash",
				NestedIndexMatching->True
			},
			{
				OptionName->SecondaryWashMix,
				Default->Automatic,
				Description->"Indicates if the solution is mixed following combination of SecondaryWashBuffer and the magnetic beads during each secondary wash.",
				ResolutionDescription->"Automatically set to True if SecondaryWash is set to True and SecondaryWashMixType is not set to Null.",
				AllowNull->True,
				Widget->Widget[Type->Enumeration,Pattern:>BooleanP],
				Category->"Wash",
				NestedIndexMatching->True
			},
			ModifyOptions[ExperimentMix,
				{
					OptionName -> MixType,
					ModifiedOptionName -> SecondaryWashMixType,
					Default->Automatic,
					Description -> "The style of motion used to mix the suspension following the addition of the SecondaryWashBuffer to the magnetic beads. Options include Roll, Vortex, Sonicate, Pipette, Invert, Stir, Shake, Homogenize, Swirl, Disrupt, Nutate.",
					ResolutionDescription -> "Automatically set based on the volume-to-mix (i.e. the volume of the combined SecondaryWashBuffer and magnetic beads) and the SecondaryWashMix options. Specifically, SecondaryWashMixType is automatically set to Pipette when the volume-to-mix is greater than 20 Microliter and none of SecondaryWashMixRate, SecondaryWashMixTemperature, and SecondaryWashMixTime is specified to non-default values; otherwise, SecondaryWashMixType is automatically set to Vortex when Preparation is Manual, SecondaryWashMixTemperature is Automatic or Ambient, and SecondaryWashMixRate is specified to be greater than 600 RPM; otherwise, SecondaryWashMixType is automatically set to Shake.",
					NestedIndexMatching -> True,
					Category -> "Wash",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> Time,
					ModifiedOptionName -> SecondaryWashMixTime,
					Default->Automatic,
					Description -> "The duration during which the combined SecondaryWashBuffer and magnetic beads are mixed.",
					ResolutionDescription -> "If SecondaryWashMixType is among Disrupt, Nutate, Shake, Vortex, Roll, Stir, Homogenize, and Sonicate, SecondaryWashMixTime is automatically set to 5 Minute for robotic preparation, and is set to 15 Minute for manual preparation.",
					NestedIndexMatching -> True,
					Category -> "Wash",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> MixRate,
					ModifiedOptionName -> SecondaryWashMixRate,
					Default->Automatic,
					Description -> "The frequency of rotation used to mix the combined SecondaryWashBuffer and magnetic beads.",
					ResolutionDescription -> "Automatically set to 300 RPM if SecondaryWashMixType is Shake or Stir, to 1000 RPM if SecondaryWashMixType is Vortex or Disrupt, and to 30 RPM if SecondaryWashMixType is Nutate or Roll.",
					NestedIndexMatching -> True,
					Category -> "Wash",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> NumberOfMixes,
					ModifiedOptionName -> NumberOfSecondaryWashMixes,
					Default->Automatic,
					Description -> "The number of times that the combined SecondaryWashBuffer and magnetic beads are mixed if SecondaryWashMixType is Pipette or Invert.",
					ResolutionDescription -> "Automatically set to 20 if SecondaryWashMixType is Pipette, Swirl or Invert.",
					NestedIndexMatching -> True,
					Category -> "Wash",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> MixVolume,
					ModifiedOptionName -> SecondaryWashMixVolume,
					Default->Automatic,
					Description ->"The volume of the combined SecondaryWashBuffer and magnetic beads that is pipetted up and down in order to mix, if SecondaryWashMixType->Pipette.",
					ResolutionDescription -> "For robotic preparation, SecondaryWashMixVolume is automatically set to 970 Microliter if 0.8*volume-to-mix (i.e.volume-to-mix is the volume of the combined SecondaryWashBuffer and magnetic beads) is greater than 970 Microliter, and otherwise is set to the greater of 10 Microliter and 0.8*volume-to-mix. For manual preparation, SecondaryWashMixVolume is automatically set to the lesser of 50 Milliliter and 0.8*volume-to-mix.",
					NestedIndexMatching -> True,
					Category -> "Wash",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> Temperature,
					ModifiedOptionName -> SecondaryWashMixTemperature,
					Default->Automatic,
					Description ->"The temperature of the device that is used to mix/incubate the combined SecondaryWashBuffer and magnetic beads.",
					ResolutionDescription->"Automatically set to Ambient if SecondaryWashMix is set to True and SecondaryWashMixType is not Null.",
					NestedIndexMatching -> True,
					Category -> "Wash",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> TipType,
					ModifiedOptionName -> SecondaryWashMixTipType,
					Default->Automatic,
					Description -> "The type of pipette tips used to mix the combined SecondaryWashBuffer and magnetic beads. Options include Normal, Barrier, WideBore, GelLoading, Aspirator. This option can only be set if SecondaryWashMixType->Pipette.",
					ResolutionDescription -> "Automatically set to WideBore for robotic preparation. For manual preparation, SecondaryWashMixTipType is automatically set to WideBore if SecondaryWashMixVolume is less or equal to 970 Microliter, to Normal if SecondaryWashMixVolume is larger than 970 Microliter but less or equal to 5 Milliliter, and to Barrier if SecondaryWashMixVolume is larger than 5 Milliliter.",
					NestedIndexMatching -> True,
					Category -> "Wash",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> TipMaterial,
					ModifiedOptionName -> SecondaryWashMixTipMaterial,
					Default->Automatic,
					Description -> "The material of the pipette tips used to aspirate and dispense the requested volume during the SecondaryWashMix. This option can only be set if SecondaryWashMixType->Pipette.",
					ResolutionDescription -> "Automatically set to Polypropylene if SecondaryWashMixVolume is less or equal to 5 Milliliter, and to Glass if SecondaryWashMixVolume is larger than 5 Milliliter.",
					NestedIndexMatching -> True,
					Category -> "Wash",
					IndexMatchingOptions -> {}
				}
			],
			{
				OptionName->SecondaryWashMagnetizationTime,
				Default->Automatic,
				Description->"The duration of magnetizing the magnetic beads after SecondaryWashMixTime has elapsed, in order to pull the magnetic beads to the perimeter of the container by applying a magnetic force, thus enables maximal aspiration of the used SecondaryWashBuffer containing residual sample components that are not bound to the magnetic beads.",
				ResolutionDescription->"Automatically set to 5 minutes if SecondaryWash is set to True.",
				AllowNull->True,
				Widget->Widget[Type->Quantity,Pattern:>RangeP[0 Second,$MaxExperimentTime],Units->{Second,{Second,Minute,Hour}}],
				Category->"Wash",
				NestedIndexMatching->True
			},
			{
				OptionName->SecondaryWashAspirationVolume,
				Default->Automatic,
				Description->"The volume of solution to aspirate out while the magnetic beads are magnetized and gathered to the side during each secondary wash prior to elution or optional TertiaryWash.",
				ResolutionDescription->"Automatically set to All for manual preparation, and set to SecondaryWashBufferVolume for robotic preparation.",
				AllowNull->True,
				Widget->Alternatives[
					"All"->Widget[Type->Enumeration,Pattern:>Alternatives[All]],
					"Volume"->Widget[Type->Quantity,Pattern:>RangeP[1 Microliter,50 Milliliter],Units->{Microliter,{Microliter,Milliliter}}]
				],
				Category->"Wash",
				NestedIndexMatching->True
			},
      ModifyOptions[TransferRoboticTipOptions,
        {
          OptionName -> AspirationPosition,
          ModifiedOptionName -> SecondaryWashAspirationPosition,
          Default->Automatic,
          AllowNull ->True,
          Widget -> Widget[
            Type -> Enumeration,
            Pattern :> MagneticBeadSeparationPipettingPositionP
          ],
          Description -> "The location from which the solution is aspirated after SecondaryWashMagnetizationTime. Top will aspirate SecondaryWashAspirationPositionOffset below the Top of the container, Bottom will aspirate SecondaryWashAspirationPositionOffset above the Bottom of the container, and LiquidLevel will aspirate SecondaryWashAspirationPositionOffset below the liquid level of the sample in the container.",
          ResolutionDescription -> "Automatically set to Bottom if Preparation->Robotic and SecondaryWash is True.",
          NestedIndexMatching -> True,
          Category->"Wash"
        }
      ],
      ModifyOptions[TransferRoboticTipOptions,
        {
          OptionName -> AspirationPositionOffset,
          ModifiedOptionName -> SecondaryWashAspirationPositionOffset,
          Default->Automatic,
          AllowNull ->True,
          Description -> "The distance from the center of the well that the solution is aspirated after SecondaryWashMagnetizationTime. The Z Offset is based on the SecondaryWashAspirationPosition option -- measured as the height below the top of the well (Top), the height above the bottom of the well (Bottom), or the height below the detected liquid level (LiquidLevel). Please refer to the AspirationPosition diagram in the help file of ExperimentTransfer for more information. If an X and Y offset is not specified, the liquid will be aspirated in the center of the well, otherwise, -X/+X values will shift the position left and right, respectively, and -Y/+Y values will shift the position down and up, respectively.",
          ResolutionDescription -> "Automatically set to 0 Millimeter if MagnetizationRack is Model[Item,MagnetizationRack,\"Alpaqua Magnum FLX Enhanced Universal Magnet 96-well Plate Rack\"] and SecondaryWashAspirationPosition is bottom, otherwise set to 2 Millimeter.",
          NestedIndexMatching -> True,
          Category->"Wash"
        }
      ],
			{
				OptionName->SecondaryWashCollectionContainer,
				Default->Automatic,
				Description->"The container(s) for collecting the aspirated sample(s) during the secondary wash(es) prior to elution or optional TertiaryWash. By default, the same container is selected for the repeated secondary washes (i.e. aspirated samples in the repeated secondary washes will be combined) unless different container objects are specified for the secondary washes.",
				ResolutionDescription->"Automatically set to a container plate and its first available position. The container plate is selected by the function PreferredContainer given the volume of SecondaryWashAspirationVolume for manual preparation, and is set to 2 mL Deep well plate for robotic preparation, if SecondaryWash is set to True.",
				AllowNull->True,
				Widget -> Alternatives[
					Adder[
						Alternatives[
							"Container" -> Widget[
								Type -> Object,
								Pattern :> ObjectP[{Object[Container], Model[Container]}]
							],
							"Container with Index" -> {
								"Index" -> Widget[
									Type -> Number,
									Pattern :> GreaterEqualP[1, 1]
								],
								"Container" -> Widget[
									Type -> Object,
									Pattern :> ObjectP[Model[Container]],
									PreparedSample -> False,
									PreparedContainer -> False
								]
							},
							"Container with Well" -> {
								"Well" -> Widget[
									Type -> Enumeration,
									Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
									PatternTooltip -> "Enumeration must be any well from A1 to H12."
								],
								"Container" -> Widget[
									Type -> Object,
									Pattern :> ObjectP[Model[Container]],
									PreparedSample -> False,
									PreparedContainer -> False
								]
							},
							"Container with Well and Index" -> {
								"Well" -> Widget[
									Type -> Enumeration,
									Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
									PatternTooltip -> "Enumeration must be any well from A1 to H12."
								],
								"Index and Container"->{
									"Index"->Widget[
										Type->Number,
										Pattern:>GreaterEqualP[1,1]
									],
									"Container"->Widget[
										Type->Object,
										Pattern:>ObjectP[{Model[Container]}],
										PreparedSample->False,
										PreparedContainer->False
									]
								}
							},
							"Automatic or Null" -> Widget[
								Type -> Enumeration,
								Pattern :> Alternatives[Automatic,Null]
							]
						]
					],
					Alternatives[
						"Container" -> Widget[
							Type -> Object,
							Pattern :> ObjectP[{Object[Container], Model[Container]}]
						],
						"Container with Index" -> {
							"Index" -> Widget[
								Type -> Number,
								Pattern :> GreaterEqualP[1, 1]
							],
							"Container" -> Widget[
								Type -> Object,
								Pattern :> ObjectP[Model[Container]],
								PreparedSample -> False,
								PreparedContainer -> False
							]
						},
						"Container with Well" -> {
							"Well" -> Widget[
								Type -> Enumeration,
								Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
								PatternTooltip -> "Enumeration must be any well from A1 to H12."
							],
							"Container" -> Widget[
								Type -> Object,
								Pattern :> ObjectP[Model[Container]],
								PreparedSample -> False,
								PreparedContainer -> False
							]
						},
						"Container with Well and Index" -> {
							"Well" -> Widget[
								Type -> Enumeration,
								Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
								PatternTooltip -> "Enumeration must be any well from A1 to H12."
							],
							"Index and Container"->{
								"Index"->Widget[
									Type->Number,
									Pattern:>GreaterEqualP[1,1]
								],
								"Container"->Widget[
									Type->Object,
									Pattern:>ObjectP[{Model[Container]}],
									PreparedSample->False,
									PreparedContainer->False
								]
							}
						}
					]
				],
				Category->"Wash",
				NestedIndexMatching->True
			},
			{
				OptionName->SecondaryWashCollectionStorageCondition,
				Default->Automatic,
				Description->"The non-default condition under which the aspirated samples during the secondary wash prior to elution or optional TertiaryWash are stored after the protocol is completed.",
				ResolutionDescription->"Automatically set to Refrigerator if SecondaryWash is set to True.",
				AllowNull->True,
				Widget->Alternatives[
					"Condition"->Widget[
						Type->Enumeration,Pattern:>SampleStorageTypeP|Disposal
					],
					"Objects"->Widget[
						Type->Object,
						Pattern:>ObjectP[Model[StorageCondition]],
						OpenPaths->{
							{Object[Catalog,"Root"],
								"Storage Conditions"}
						}
					]
				],
				Category->"Post Experiment",
				NestedIndexMatching->True
			},
			{
				OptionName->NumberOfSecondaryWashes,
				Default->Automatic,
				Description->"The number of times the magnetic beads are washed by adding SecondaryWashBuffer, mixing, magnetization, and aspirating solution prior to elution or optional TertiaryWash.",
				ResolutionDescription->"Automatically set to 1 if SecondaryWash is set to True.",
				AllowNull->True,
				Widget->Widget[Type->Number,Pattern:>RangeP[1,20,1]],
				Category->"Wash",
				NestedIndexMatching->True
			},
			{
				OptionName->SecondaryWashAirDry,
				Default->Automatic,
				Description->"Indicates if the magnetic beads are exposed to open air to evaporate the remaining SecondaryWashBuffer following the final secondary wash prior to elution or optional TertiaryWash.",
				ResolutionDescription->"Automatically set to False if SecondaryWash is set to True.",
				AllowNull->True,
				Widget->Widget[Type->Enumeration,Pattern:>BooleanP],
				Category->"Wash",
				NestedIndexMatching->True
			},
			{
				OptionName->SecondaryWashAirDryTime,
				Default->Automatic,
				Description->"The duration that the magnetic beads are exposed to open air to evaporate the remaining SecondaryWashBuffer following the final secondary wash prior to elution or optional TertiaryWash.",
				ResolutionDescription->"Automatically set to 1 Minute if SecondaryWashAirDry is set to True.",
				AllowNull->True,
				Widget->Widget[Type->Quantity,Pattern:>RangeP[0 Second,$MaxExperimentTime],Units->{Second,{Second,Minute,Hour}}],
				Category->"Wash",
				NestedIndexMatching->True
			},

			(*--- TertiaryWash---*)
			{
				OptionName->TertiaryWash,
				Default->Automatic,
				Description->"Indicates if the magnetic beads with bound targets or contaminants are further rinsed after SecondaryWash prior to Elution or optional QuaternaryWash, in order to better separate the bead-bound components from the unbound components in the sample, or for on-bead digestion. The washing steps (up to SeptenaryWash) can optionally be used for on-bead digestion to perform alkylation, reduction, trypsin digestion, etc.",
				ResolutionDescription->"Automatically set to True if other TertiaryWash options are set, or False otherwise.",
				AllowNull->False,
				Widget->Widget[Type->Enumeration,Pattern:>BooleanP],
				Category->"Wash",
				NestedIndexMatching->True
			},
			{
				OptionName->TertiaryWashBuffer,
				Default->Automatic,
				Description->"The solution used to rinse the magnetic beads during TertiaryWash prior to elution or optional QuaternaryWash, in order to better separate the bead-bound components from the unbound components in the sample, or for on-bead digestion.",
				ResolutionDescription->"Automatically set to Model[Sample,\"Milli-Q water\"] if TertiaryWash is set to True.",
				AllowNull->True,
				Widget->Widget[
					Type->Object,
					Pattern:>ObjectP[{Model[Sample],Object[Sample]}],
					OpenPaths -> {
						{Object[Catalog, "Root"], "Materials", "Magnetic Bead Separation", "Wash Solutions"},
						{Object[Catalog, "Root"], "Materials", "Reagents", "Buffers"}
					}
				],

				Category->"Wash",
				NestedIndexMatching->True
			},
			{
				OptionName->TertiaryWashBufferVolume,
				Default->Automatic,
				Description->"The amount of TertiaryWashBuffer that is added to the magnetic beads for each tertiary wash prior to elution or optional QuaternaryWash.",
				ResolutionDescription->"If TertiaryWash is set to True, TertiaryWashBufferVolume is automatically set to PreWashBufferVolume when PreWash is set to True, and is set to Volume when PreWash is set to False.",
				AllowNull->True,
				Widget->Widget[Type->Quantity,Pattern:>RangeP[1 Microliter,50 Milliliter],Units->{Microliter,{Microliter,Milliliter}}],
				Category->"Wash",
				NestedIndexMatching->True
			},
			{
				OptionName->TertiaryWashMix,
				Default->Automatic,
				Description->"Indicates if the solution is mixed following combination of TertiaryWashBuffer and the magnetic beads during each tertiary wash.",
				ResolutionDescription->"Automatically set to True if TertiaryWash is set to True and TertiaryWashMixType is not set to Null.",
				AllowNull->True,
				Widget->Widget[Type->Enumeration,Pattern:>BooleanP],
				Category->"Wash",
				NestedIndexMatching->True
			},
			ModifyOptions[ExperimentMix,
				{
					OptionName -> MixType,
					ModifiedOptionName -> TertiaryWashMixType,
					Default->Automatic,
					Description -> "The style of motion used to mix the suspension following the addition of the TertiaryWashBuffer to the magnetic beads. Options include Roll, Vortex, Sonicate, Pipette, Invert, Stir, Shake, Homogenize, Swirl, Disrupt, Nutate.",
					ResolutionDescription -> "Automatically set based on the volume-to-mix (i.e. the volume of the combined TertiaryWashBuffer and magnetic beads) and the TertiaryWashMix options. Specifically, TertiaryWashMixType is automatically set to Pipette when the volume-to-mix is greater than 20 Microliter and none of TertiaryWashMixRate, TertiaryWashMixTemperature, and TertiaryWashMixTime is specified to non-default values; otherwise, TertiaryWashMixType is automatically set to Vortex when Preparation is Manual, TertiaryWashMixTemperature is Automatic or Ambient, and TertiaryWashMixRate is specified to be greater than 600 RPM; otherwise, TertiaryWashMixType is automatically set to Shake.",
					NestedIndexMatching -> True,
					Category -> "Wash",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> Time,
					ModifiedOptionName -> TertiaryWashMixTime,
					Default->Automatic,
					Description -> "The duration during which the combined TertiaryWashBuffer and magnetic beads are mixed.",
					ResolutionDescription -> "If TertiaryWashMixType is among Disrupt, Nutate, Shake, Vortex, Roll, Stir, Homogenize, and Sonicate, TertiaryWashMixTime is automatically set to 5 Minute for robotic preparation, and is set to 15 Minute for manual preparation.",
					NestedIndexMatching -> True,
					Category -> "Wash",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> MixRate,
					ModifiedOptionName -> TertiaryWashMixRate,
					Default->Automatic,
					Description -> "The frequency of rotation used to mix the combined TertiaryWashBuffer and magnetic beads.",
					ResolutionDescription -> "Automatically set to 300 RPM if TertiaryWashMixType is Shake or Stir, to 1000 RPM if TertiaryWashMixType is Vortex or Disrupt, and to 30 RPM if TertiaryWashMixType is Nutate or Roll.",
					NestedIndexMatching -> True,
					Category -> "Wash",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> NumberOfMixes,
					ModifiedOptionName -> NumberOfTertiaryWashMixes,
					Default->Automatic,
					Description -> "The number of times that the combined TertiaryWashBuffer and magnetic beads are mixed if TertiaryWashMixType is Pipette or Invert.",
					ResolutionDescription -> "Automatically set to 20 if TertiaryWashMixType is Pipette, Swirl or Invert.",
					NestedIndexMatching -> True,
					Category -> "Wash",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> MixVolume,
					ModifiedOptionName -> TertiaryWashMixVolume,
					Default->Automatic,
					Description ->"The volume of the combined TertiaryWashBuffer and magnetic beads that is pipetted up and down in order to mix, if TertiaryWashMixType->Pipette.",
					ResolutionDescription -> "For robotic preparation, TertiaryWashMixVolume is automatically set to 970 Microliter if 0.8*volume-to-mix (i.e.volume-to-mix is the volume of the combined TertiaryWashBuffer and magnetic beads) is greater than 970 Microliter, and otherwise is set to the greater of 10 Microliter and 0.8*volume-to-mix. For manual preparation, TertiaryWashMixVolume is automatically set to the lesser of 50 Milliliter and 0.8*volume-to-mix.",
					NestedIndexMatching -> True,
					Category -> "Wash",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> Temperature,
					ModifiedOptionName -> TertiaryWashMixTemperature,
					Default->Automatic,
					Description ->"The temperature of the device that is used to mix/incubate the combined TertiaryWashBuffer and magnetic beads.",
					ResolutionDescription->"Automatically set to Ambient if TertiaryWashMix is set to True and TertiaryWashMixType is not Null.",
					NestedIndexMatching -> True,
					Category -> "Wash",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> TipType,
					ModifiedOptionName -> TertiaryWashMixTipType,
					Default->Automatic,
					Description -> "The type of pipette tips used to mix the combined TertiaryWashBuffer and magnetic beads. Options include Normal, Barrier, WideBore, GelLoading, Aspirator. This option can only be set if TertiaryWashMixType->Pipette.",
					ResolutionDescription -> "Automatically set to WideBore for robotic preparation. For manual preparation, TertiaryWashMixTipType is automatically set to WideBore if TertiaryWashMixVolume is less or equal to 970 Microliter, to Normal if TertiaryWashMixVolume is larger than 970 Microliter but less or equal to 5 Milliliter, and to Barrier if TertiaryWashMixVolume is larger than 5 Milliliter.",
					NestedIndexMatching -> True,
					Category -> "Wash",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> TipMaterial,
					ModifiedOptionName -> TertiaryWashMixTipMaterial,
					Default->Automatic,
					Description -> "The material of the pipette tips used to aspirate and dispense the requested volume during the TertiaryWashMix. This option can only be set if TertiaryWashMixType->Pipette.",
					ResolutionDescription -> "Automatically set to Polypropylene if TertiaryWashMixVolume is less or equal to 5 Milliliter, and to Glass if TertiaryWashMixVolume is larger than 5 Milliliter.",
					NestedIndexMatching -> True,
					Category -> "Wash",
					IndexMatchingOptions -> {}
				}
			],
			{
				OptionName->TertiaryWashMagnetizationTime,
				Default->Automatic,
				Description->"The duration of magnetizing the magnetic beads after TertiaryWashMixTime has elapsed, in order to pull the magnetic beads to the perimeter of the container by applying a magnetic force, thus enables maximal aspiration of the used TertiaryWashBuffer containing residual sample components that are not bound to the magnetic beads.",
				ResolutionDescription->"Automatically set to 5 minutes if TertiaryWash is set to True.",
				AllowNull->True,
				Widget->Widget[Type->Quantity,Pattern:>RangeP[0 Second,$MaxExperimentTime],Units->{Second,{Second,Minute,Hour}}],
				Category->"Wash",
				NestedIndexMatching->True
			},
			{
				OptionName->TertiaryWashAspirationVolume,
				Default->Automatic,
				Description->"The volume of solution to aspirate out while the magnetic beads are magnetized and gathered to the side during each tertiary wash prior to elution or optional QuaternaryWash.",
				ResolutionDescription->"Automatically set to All for manual preparation, and set to TertiaryWashBufferVolume for robotic preparation.",
				AllowNull->True,
				Widget->Alternatives[
					"All"->Widget[Type->Enumeration,Pattern:>Alternatives[All]],
					"Volume"->Widget[Type->Quantity,Pattern:>RangeP[1 Microliter,50 Milliliter],Units->{Microliter,{Microliter,Milliliter}}]
				],
				Category->"Wash",
				NestedIndexMatching->True
			},
      ModifyOptions[TransferRoboticTipOptions,
        {
          OptionName -> AspirationPosition,
          ModifiedOptionName -> TertiaryWashAspirationPosition,
          Default->Automatic,
          AllowNull ->True,
          Widget -> Widget[
            Type -> Enumeration,
            Pattern :> MagneticBeadSeparationPipettingPositionP
          ],
          Description -> "The location from which the solution is aspirated after TertiaryWashMagnetizationTime. Top will aspirate TertiaryWashAspirationPositionOffset below the Top of the container, Bottom will aspirate TertiaryWashAspirationPositionOffset above the Bottom of the container, and LiquidLevel will aspirate TertiaryWashAspirationPositionOffset below the liquid level of the sample in the container.",
          ResolutionDescription -> "Automatically set to Bottom if Preparation->Robotic and TertiaryWash is True.",
          NestedIndexMatching -> True,
          Category->"Wash"
        }
      ],
      ModifyOptions[TransferRoboticTipOptions,
        {
          OptionName -> AspirationPositionOffset,
          ModifiedOptionName -> TertiaryWashAspirationPositionOffset,
          Default->Automatic,
          AllowNull ->True,
          Description -> "The distance from the center of the well that the solution is aspirated after TertiaryWashMagnetizationTime. The Z Offset is based on the TertiaryWashAspirationPosition option -- measured as the height below the top of the well (Top), the height above the bottom of the well (Bottom), or the height below the detected liquid level (LiquidLevel). Please refer to the AspirationPosition diagram in the help file of ExperimentTransfer for more information. If an X and Y offset is not specified, the liquid will be aspirated in the center of the well, otherwise, -X/+X values will shift the position left and right, respectively, and -Y/+Y values will shift the position down and up, respectively.",
          ResolutionDescription -> "Automatically set to 0 Millimeter if MagnetizationRack is Model[Item,MagnetizationRack,\"Alpaqua Magnum FLX Enhanced Universal Magnet 96-well Plate Rack\"] and TertiaryWashAspirationPosition is bottom, otherwise set to 2 Millimeter.",
          NestedIndexMatching -> True,
          Category->"Wash"
        }
      ],
			{
				OptionName->TertiaryWashCollectionContainer,
				Default->Automatic,
				Description->"The container(s) for collecting the aspirated sample(s) during the Tertiary wash(es) prior to elution or optional QuaternaryWash. By default, the same container is selected for the repeated tertiary washes (i.e. aspirated samples in the repeated tertiary washes will be combined) unless different container objects are specified for the tertiary washes.",
				ResolutionDescription->"Automatically set to a container plate and its first available position. The container plate is selected by the function PreferredContainer given the volume of TertiaryWashAspirationVolume for manual preparation, and is set to 2 mL Deep well plate for robotic preparation, if TertiaryWash is set to True.",
				AllowNull->True,
				Widget -> Alternatives[
					Adder[
						Alternatives[
							"Container" -> Widget[
								Type -> Object,
								Pattern :> ObjectP[{Object[Container], Model[Container]}]
							],
							"Container with Index" -> {
								"Index" -> Widget[
									Type -> Number,
									Pattern :> GreaterEqualP[1, 1]
								],
								"Container" -> Widget[
									Type -> Object,
									Pattern :> ObjectP[Model[Container]],
									PreparedSample -> False,
									PreparedContainer -> False
								]
							},
							"Container with Well" -> {
								"Well" -> Widget[
									Type -> Enumeration,
									Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
									PatternTooltip -> "Enumeration must be any well from A1 to H12."
								],
								"Container" -> Widget[
									Type -> Object,
									Pattern :> ObjectP[Model[Container]],
									PreparedSample -> False,
									PreparedContainer -> False
								]
							},
							"Container with Well and Index" -> {
								"Well" -> Widget[
									Type -> Enumeration,
									Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
									PatternTooltip -> "Enumeration must be any well from A1 to H12."
								],
								"Index and Container"->{
									"Index"->Widget[
										Type->Number,
										Pattern:>GreaterEqualP[1,1]
									],
									"Container"->Widget[
										Type->Object,
										Pattern:>ObjectP[{Model[Container]}],
										PreparedSample->False,
										PreparedContainer->False
									]
								}
							},
							"Automatic or Null" -> Widget[
								Type -> Enumeration,
								Pattern :> Alternatives[Automatic,Null]
							]
						]
					],
					Alternatives[
						"Container" -> Widget[
							Type -> Object,
							Pattern :> ObjectP[{Object[Container], Model[Container]}]
						],
						"Container with Index" -> {
							"Index" -> Widget[
								Type -> Number,
								Pattern :> GreaterEqualP[1, 1]
							],
							"Container" -> Widget[
								Type -> Object,
								Pattern :> ObjectP[Model[Container]],
								PreparedSample -> False,
								PreparedContainer -> False
							]
						},
						"Container with Well" -> {
							"Well" -> Widget[
								Type -> Enumeration,
								Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
								PatternTooltip -> "Enumeration must be any well from A1 to H12."
							],
							"Container" -> Widget[
								Type -> Object,
								Pattern :> ObjectP[Model[Container]],
								PreparedSample -> False,
								PreparedContainer -> False
							]
						},
						"Container with Well and Index" -> {
							"Well" -> Widget[
								Type -> Enumeration,
								Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
								PatternTooltip -> "Enumeration must be any well from A1 to H12."
							],
							"Index and Container"->{
								"Index"->Widget[
									Type->Number,
									Pattern:>GreaterEqualP[1,1]
								],
								"Container"->Widget[
									Type->Object,
									Pattern:>ObjectP[{Model[Container]}],
									PreparedSample->False,
									PreparedContainer->False
								]
							}
						}
					]
				],
				Category->"Wash",
				NestedIndexMatching->True
			},
			{
				OptionName->TertiaryWashCollectionStorageCondition,
				Default->Automatic,
				Description->"The non-default condition under which the aspirated samples during the tertiary wash prior to elution or optional QuaternaryWash are stored after the protocol is completed.",
				ResolutionDescription->"Automatically set to Refrigerator if TertiaryWash is set to True.",
				AllowNull->True,
				Widget->Alternatives[
					"Condition"->Widget[
						Type->Enumeration,Pattern:>SampleStorageTypeP|Disposal
					],
					"Objects"->Widget[
						Type->Object,
						Pattern:>ObjectP[Model[StorageCondition]],
						OpenPaths->{
							{Object[Catalog,"Root"],
								"Storage Conditions"}
						}
					]
				],
				Category->"Post Experiment",
				NestedIndexMatching->True
			},
			{
				OptionName->NumberOfTertiaryWashes,
				Default->Automatic,
				Description->"The number of times the magnetic beads are washed by adding TertiaryWashBuffer, mixing, magnetization, and aspirating solution prior to elution or optional QuaternaryWash.",
				ResolutionDescription->"Automatically set to 1 if TertiaryWash is set to True.",
				AllowNull->True,
				Widget->Widget[Type->Number,Pattern:>RangeP[1,20,1]],
				Category->"Wash",
				NestedIndexMatching->True
			},
			{
				OptionName->TertiaryWashAirDry,
				Default->Automatic,
				Description->"Indicates if the magnetic beads are exposed to open air to evaporate the remaining TertiaryWashBuffer following the final tertiary wash prior to elution or optional QuaternaryWash.",
				ResolutionDescription->"Automatically set to False if TertiaryWash is set to True.",
				AllowNull->True,
				Widget->Widget[Type->Enumeration,Pattern:>BooleanP],
				Category->"Wash",
				NestedIndexMatching->True
			},
			{
				OptionName->TertiaryWashAirDryTime,
				Default->Automatic,
				Description->"The duration that the magnetic beads are exposed to open air to evaporate the remaining TertiaryWashBuffer following the final tertiary wash prior to elution or optional QuaternaryWash.",
				ResolutionDescription->"Automatically set to 1 Minute if TertiaryWashAirDry is set to True.",
				AllowNull->True,
				Widget->Widget[Type->Quantity,Pattern:>RangeP[0 Second,$MaxExperimentTime],Units->{Second,{Second,Minute,Hour}}],
				Category->"Wash",
				NestedIndexMatching->True
			},

			(*--- QuaternaryWash---*)
			{
				OptionName->QuaternaryWash,
				Default->Automatic,
				Description->"Indicates if the magnetic beads with bound targets or contaminants are further rinsed after TertiaryWash prior to Elution or optional QuinaryWash, in order to better separate the bead-bound components from the unbound components in the sample, or for on-bead digestion. The washing steps (up to SeptenaryWash) can optionally be used for on-bead digestion to perform alkylation, reduction, trypsin digestion, etc.",
				ResolutionDescription->"Automatically set to True if other QuaternaryWash options are set, or False otherwise.",
				AllowNull->False,
				Widget->Widget[Type->Enumeration,Pattern:>BooleanP],
				Category->"Wash",
				NestedIndexMatching->True
			},
			{
				OptionName->QuaternaryWashBuffer,
				Default->Automatic,
				Description->"The solution used to rinse the magnetic beads during QuaternaryWash prior to elution or optional QuinaryWash, in order to better separate the bead-bound components from the unbound components in the sample, or for on-bead digestion.",
				ResolutionDescription->"Automatically set to Model[Sample,\"Milli-Q water\"] if QuaternaryWash is set to True.",
				AllowNull->True,
				Widget->Widget[
					Type->Object,
					Pattern:>ObjectP[{Model[Sample],Object[Sample]}],
					OpenPaths -> {
						{Object[Catalog, "Root"], "Materials", "Magnetic Bead Separation", "Wash Solutions"},
						{Object[Catalog, "Root"], "Materials", "Reagents", "Buffers"}
					}
				],

				Category->"Wash",
				NestedIndexMatching->True
			},
			{
				OptionName->QuaternaryWashBufferVolume,
				Default->Automatic,
				Description->"The amount of QuaternaryWashBuffer that is added to the magnetic beads for each quaternary wash prior to elution or optional QuinaryWash.",
				ResolutionDescription->"If QuaternaryWash is set to True, QuaternaryWashBufferVolume is automatically set to PreWashBufferVolume when PreWash is set to True, and is set to Volume when PreWash is set to False.",
				AllowNull->True,
				Widget->Widget[Type->Quantity,Pattern:>RangeP[1 Microliter,50 Milliliter],Units->{Microliter,{Microliter,Milliliter}}],
				Category->"Wash",
				NestedIndexMatching->True
			},
			{
				OptionName->QuaternaryWashMix,
				Default->Automatic,
				Description->"Indicates if the solution is mixed following combination of QuaternaryWashBuffer and the magnetic beads during each quaternary wash.",
				ResolutionDescription->"Automatically set to True if QuaternaryWash is set to True and QuaternaryWashMixType is not set to Null.",
				AllowNull->True,
				Widget->Widget[Type->Enumeration,Pattern:>BooleanP],
				Category->"Wash",
				NestedIndexMatching->True
			},
			ModifyOptions[ExperimentMix,
				{
					OptionName -> MixType,
					ModifiedOptionName -> QuaternaryWashMixType,
					Default->Automatic,
					Description -> "The style of motion used to mix the suspension following the addition of the QuaternaryWashBuffer to the magnetic beads. Options include Roll, Vortex, Sonicate, Pipette, Invert, Stir, Shake, Homogenize, Swirl, Disrupt, Nutate.",
					ResolutionDescription -> "Automatically set based on the container of the sample and the QuaternaryWashMix option. Specifically, if QuaternaryWashMix is set to False, the option is set to Null. If any of QuaternaryWashMixRate, QuaternaryWashMixTemperature, and QuaternaryWashMixTime is specified to a non-default value, QuaternaryWashMixType is automatically set to Shake when Preparation is Robotic, when QuaternaryWashMixTemperature is not Ambient, or when QuaternaryWashMixRate is less or equal to 600 RPM; Otherwise QuaternaryWashMixType is automatically set to Vortex. If none of QuaternaryWashMixRate, QuaternaryWashMixTemperature, and QuaternaryWashMixTime is specified to non-default values, QuaternaryWashMixType is automatically set to Pipette.",
					NestedIndexMatching -> True,
					Category -> "Wash",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> Time,
					ModifiedOptionName -> QuaternaryWashMixTime,
					Default->Automatic,
					Description -> "The duration during which the combined QuaternaryWashBuffer and magnetic beads are mixed.",
					ResolutionDescription -> "If QuaternaryWashMixType is among Disrupt, Nutate, Shake, Vortex, Roll, Stir, Homogenize, and Sonicate, QuaternaryWashMixTime is automatically set to 5 Minute for robotic preparation, and is set to 15 Minute for manual preparation.",
					NestedIndexMatching -> True,
					Category -> "Wash",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> MixRate,
					ModifiedOptionName -> QuaternaryWashMixRate,
					Default->Automatic,
					Description -> "The frequency of rotation used to mix the combined QuaternaryWashBuffer and magnetic beads.",
					ResolutionDescription -> "Automatically set to 300 RPM if QuaternaryWashMixType is Shake or Stir, to 1000 RPM if QuaternaryWashMixType is Vortex or Disrupt, and to 30 RPM if QuaternaryWashMixType is Nutate or Roll.",
					NestedIndexMatching -> True,
					Category -> "Wash",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> NumberOfMixes,
					ModifiedOptionName -> NumberOfQuaternaryWashMixes,
					Default->Automatic,
					Description -> "The number of times that the combined QuaternaryWashBuffer and magnetic beads are mixed if QuaternaryWashMixType is Pipette or Invert.",
					ResolutionDescription -> "Automatically set to 20 if QuaternaryWashMixType is Pipette, Swirl or Invert.",
					NestedIndexMatching -> True,
					Category -> "Wash",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> MixVolume,
					ModifiedOptionName -> QuaternaryWashMixVolume,
					Default->Automatic,
					Description ->"The volume of the combined QuaternaryWashBuffer and magnetic beads that is pipetted up and down in order to mix, if QuaternaryWashMixType->Pipette.",
					ResolutionDescription -> "For robotic preparation, QuaternaryWashMixVolume is automatically set to 970 Microliter if 0.8*volume-to-mix (i.e.volume-to-mix is the volume of the combined QuaternaryWashBuffer and magnetic beads) is greater than 970 Microliter, and otherwise is set to the greater of 10 Microliter and 0.8*volume-to-mix. For manual preparation, QuaternaryWashMixVolume is automatically set to the lesser of 50 Milliliter and 0.8*volume-to-mix.",
					NestedIndexMatching -> True,
					Category -> "Wash",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> Temperature,
					ModifiedOptionName -> QuaternaryWashMixTemperature,
					Default->Automatic,
					Description ->"The temperature of the device that is used to mix/incubate the combined QuaternaryWashBuffer and magnetic beads.",
					ResolutionDescription->"Automatically set to Ambient if QuaternaryWashMix is set to True and QuaternaryWashMixType is not Null.",
					NestedIndexMatching -> True,
					Category -> "Wash",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> TipType,
					ModifiedOptionName -> QuaternaryWashMixTipType,
					Default->Automatic,
					Description -> "The type of pipette tips used to mix the combined QuaternaryWashBuffer and magnetic beads. Options include Normal, Barrier, WideBore, GelLoading, Aspirator. This option can only be set if QuaternaryWashMixType->Pipette.",
					ResolutionDescription -> "Automatically set to WideBore for robotic preparation. For manual preparation, QuaternaryWashMixTipType is automatically set to WideBore if QuaternaryWashMixVolume is less or equal to 970 Microliter, to Normal if QuaternaryWashMixVolume is larger than 970 Microliter but less or equal to 5 Milliliter, and to Barrier if QuaternaryWashMixVolume is larger than 5 Milliliter.",
					NestedIndexMatching -> True,
					Category -> "Wash",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> TipMaterial,
					ModifiedOptionName -> QuaternaryWashMixTipMaterial,
					Default->Automatic,
					Description -> "The material of the pipette tips used to aspirate and dispense the requested volume during the QuaternaryWashMix. This option can only be set if QuaternaryWashMixType->Pipette.",
					ResolutionDescription -> "Automatically set to Polypropylene if QuaternaryWashMixVolume is less or equal to 5 Milliliter, and to Glass if QuaternaryWashMixVolume is larger than 5 Milliliter.",
					NestedIndexMatching -> True,
					Category -> "Wash",
					IndexMatchingOptions -> {}
				}
			],
			{
				OptionName->QuaternaryWashMagnetizationTime,
				Default->Automatic,
				Description->"The duration of magnetizing the magnetic beads after QuaternaryWashMixTime has elapsed, in order to pull the magnetic beads to the perimeter of the container by applying a magnetic force, thus enables maximal aspiration of the used QuaternaryWashBuffer containing residual sample components that are not bound to the magnetic beads.",
				ResolutionDescription->"Automatically set to 5 minutes if QuaternaryWash is set to True.",
				AllowNull->True,
				Widget->Widget[Type->Quantity,Pattern:>RangeP[0 Second,$MaxExperimentTime],Units->{Second,{Second,Minute,Hour}}],
				Category->"Wash",
				NestedIndexMatching->True
			},
			{
				OptionName->QuaternaryWashAspirationVolume,
				Default->Automatic,
				Description->"The volume of solution to aspirate out while the magnetic beads are magnetized and gathered to the side during each quaternary wash prior to elution or optional QuinaryWash.",
				ResolutionDescription->"Automatically set to All for manual preparation, and set to QuaternaryWashBufferVolume for robotic preparation.",
				AllowNull->True,
				Widget->Alternatives[
					"All"->Widget[Type->Enumeration,Pattern:>Alternatives[All]],
					"Volume"->Widget[Type->Quantity,Pattern:>RangeP[1 Microliter,50 Milliliter],Units->{Microliter,{Microliter,Milliliter}}]
				],
				Category->"Wash",
				NestedIndexMatching->True
			},
      ModifyOptions[TransferRoboticTipOptions,
        {
          OptionName -> AspirationPosition,
          ModifiedOptionName -> QuaternaryWashAspirationPosition,
          Default->Automatic,
          AllowNull ->True,
          Widget -> Widget[
            Type -> Enumeration,
            Pattern :> MagneticBeadSeparationPipettingPositionP
          ],
          Description -> "The location from which the solution is aspirated after QuaternaryWashMagnetizationTime. Top will aspirate QuaternaryWashAspirationPositionOffset below the Top of the container, Bottom will aspirate QuaternaryWashAspirationPositionOffset above the Bottom of the container, and LiquidLevel will aspirate QuaternaryWashAspirationPositionOffset below the liquid level of the sample in the container.",
          ResolutionDescription -> "Automatically set to Bottom if Preparation->Robotic and QuaternaryWash is True.",
          NestedIndexMatching -> True,
          Category->"Wash"
        }
      ],
      ModifyOptions[TransferRoboticTipOptions,
        {
          OptionName -> AspirationPositionOffset,
          ModifiedOptionName -> QuaternaryWashAspirationPositionOffset,
          Default->Automatic,
          AllowNull ->True,
          Description -> "The distance from the center of the well that the solution is aspirated after QuaternaryWashMagnetizationTime. The Z Offset is based on the QuaternaryWashAspirationPosition option -- measured as the height below the top of the well (Top), the height above the bottom of the well (Bottom), or the height below the detected liquid level (LiquidLevel). Please refer to the AspirationPosition diagram in the help file of ExperimentTransfer for more information. If an X and Y offset is not specified, the liquid will be aspirated in the center of the well, otherwise, -X/+X values will shift the position left and right, respectively, and -Y/+Y values will shift the position down and up, respectively.",
          ResolutionDescription -> "Automatically set to 0 Millimeter if MagnetizationRack is Model[Item,MagnetizationRack,\"Alpaqua Magnum FLX Enhanced Universal Magnet 96-well Plate Rack\"] and QuaternaryWashAspirationPosition is bottom, otherwise set to 2 Millimeter.",
          NestedIndexMatching -> True,
          Category->"Wash"
        }
      ],
			{
				OptionName->QuaternaryWashCollectionContainer,
				Default->Automatic,
				Description->"The container(s) for collecting the aspirated sample(s) during the Quaternary wash(es) prior to elution or optional QuinaryWash. By default, the same container is selected for the repeated quaternary washes (i.e. aspirated samples in the repeated quaternary washes will be combined) unless different container objects are specified for the quaternary washes.",
				ResolutionDescription->"Automatically set to a container plate and its first available position. The container plate is selected by the function PreferredContainer given the volume of QuaternaryWashAspirationVolume for manual preparation, and is set to 2 mL Deep well plate for robotic preparation, if QuaternaryWash is set to True.",
				AllowNull->True,
				Widget -> Alternatives[
					Adder[
						Alternatives[
							"Container" -> Widget[
								Type -> Object,
								Pattern :> ObjectP[{Object[Container], Model[Container]}]
							],
							"Container with Index" -> {
								"Index" -> Widget[
									Type -> Number,
									Pattern :> GreaterEqualP[1, 1]
								],
								"Container" -> Widget[
									Type -> Object,
									Pattern :> ObjectP[Model[Container]],
									PreparedSample -> False,
									PreparedContainer -> False
								]
							},
							"Container with Well" -> {
								"Well" -> Widget[
									Type -> Enumeration,
									Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
									PatternTooltip -> "Enumeration must be any well from A1 to H12."
								],
								"Container" -> Widget[
									Type -> Object,
									Pattern :> ObjectP[Model[Container]],
									PreparedSample -> False,
									PreparedContainer -> False
								]
							},
							"Container with Well and Index" -> {
								"Well" -> Widget[
									Type -> Enumeration,
									Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
									PatternTooltip -> "Enumeration must be any well from A1 to H12."
								],
								"Index and Container"->{
									"Index"->Widget[
										Type->Number,
										Pattern:>GreaterEqualP[1,1]
									],
									"Container"->Widget[
										Type->Object,
										Pattern:>ObjectP[{Model[Container]}],
										PreparedSample->False,
										PreparedContainer->False
									]
								}
							},
							"Automatic or Null" -> Widget[
								Type -> Enumeration,
								Pattern :> Alternatives[Automatic,Null]
							]
						]
					],
					Alternatives[
						"Container" -> Widget[
							Type -> Object,
							Pattern :> ObjectP[{Object[Container], Model[Container]}]
						],
						"Container with Index" -> {
							"Index" -> Widget[
								Type -> Number,
								Pattern :> GreaterEqualP[1, 1]
							],
							"Container" -> Widget[
								Type -> Object,
								Pattern :> ObjectP[Model[Container]],
								PreparedSample -> False,
								PreparedContainer -> False
							]
						},
						"Container with Well" -> {
							"Well" -> Widget[
								Type -> Enumeration,
								Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
								PatternTooltip -> "Enumeration must be any well from A1 to H12."
							],
							"Container" -> Widget[
								Type -> Object,
								Pattern :> ObjectP[Model[Container]],
								PreparedSample -> False,
								PreparedContainer -> False
							]
						},
						"Container with Well and Index" -> {
							"Well" -> Widget[
								Type -> Enumeration,
								Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
								PatternTooltip -> "Enumeration must be any well from A1 to H12."
							],
							"Index and Container"->{
								"Index"->Widget[
									Type->Number,
									Pattern:>GreaterEqualP[1,1]
								],
								"Container"->Widget[
									Type->Object,
									Pattern:>ObjectP[{Model[Container]}],
									PreparedSample->False,
									PreparedContainer->False
								]
							}
						}
					]
				],
				Category->"Wash",
				NestedIndexMatching->True
			},
			{
				OptionName->QuaternaryWashCollectionStorageCondition,
				Default->Automatic,
				Description->"The non-default condition under which the aspirated samples during the quaternary wash prior to elution or optional QuinaryWash are stored after the protocol is completed.",
				ResolutionDescription->"Automatically set to Refrigerator if QuaternaryWash is set to True.",
				AllowNull->True,
				Widget->Alternatives[
					"Condition"->Widget[
						Type->Enumeration,Pattern:>SampleStorageTypeP|Disposal
					],
					"Objects"->Widget[
						Type->Object,
						Pattern:>ObjectP[Model[StorageCondition]],
						OpenPaths->{
							{Object[Catalog,"Root"],
								"Storage Conditions"}
						}
					]
				],
				Category->"Post Experiment",
				NestedIndexMatching->True
			},
			{
				OptionName->NumberOfQuaternaryWashes,
				Default->Automatic,
				Description->"The number of times the magnetic beads are washed by adding QuaternaryWashBuffer, mixing, magnetization, and aspirating solution prior to elution or optional QuinaryWash.",
				ResolutionDescription->"Automatically set to 1 if QuaternaryWash is set to True.",
				AllowNull->True,
				Widget->Widget[Type->Number,Pattern:>RangeP[1,20,1]],
				Category->"Wash",
				NestedIndexMatching->True
			},
			{
				OptionName->QuaternaryWashAirDry,
				Default->Automatic,
				Description->"Indicates if the magnetic beads are exposed to open air to evaporate the remaining QuaternaryWashBuffer following the final quaternary wash prior to elution or optional QuinaryWash.",
				ResolutionDescription->"Automatically set to False if QuaternaryWash is set to True.",
				AllowNull->True,
				Widget->Widget[Type->Enumeration,Pattern:>BooleanP],
				Category->"Wash",
				NestedIndexMatching->True
			},
			{
				OptionName->QuaternaryWashAirDryTime,
				Default->Automatic,
				Description->"The duration that the magnetic beads are exposed to open air to evaporate the remaining QuaternaryWashBuffer following the final quaternary wash prior to elution or optional QuinaryWash.",
				ResolutionDescription->"Automatically set to 1 Minute if QuaternaryWashAirDry is set to True.",
				AllowNull->True,
				Widget->Widget[Type->Quantity,Pattern:>RangeP[0 Second,$MaxExperimentTime],Units->{Second,{Second,Minute,Hour}}],
				Category->"Wash",
				NestedIndexMatching->True
			},

			(*--- QuinaryWash---*)
			{
				OptionName->QuinaryWash,
				Default->Automatic,
				Description->"Indicates if the magnetic beads with bound targets or contaminants are further rinsed after QuaternaryWash prior to Elution or optional SenaryWash, in order to better separate the bead-bound components from the unbound components in the sample, or for on-bead digestion. The washing steps (up to SeptenaryWash) can optionally be used for on-bead digestion to perform alkylation, reduction, trypsin digestion, etc.",
				ResolutionDescription->"Automatically set to True if other QuinaryWash options are set, or False otherwise.",
				AllowNull->False,
				Widget->Widget[Type->Enumeration,Pattern:>BooleanP],
				Category->"Wash",
				NestedIndexMatching->True
			},
			{
				OptionName->QuinaryWashBuffer,
				Default->Automatic,
				Description->"The solution used to rinse the magnetic beads during QuinaryWash prior to elution or optional SenaryWash, in order to better separate the bead-bound components from the unbound components in the sample, or for on-bead digestion.",
				ResolutionDescription->"Automatically set to Model[Sample,\"Milli-Q water\"] if QuinaryWash is set to True.",
				AllowNull->True,
				Widget->Widget[
					Type->Object,
					Pattern:>ObjectP[{Model[Sample],Object[Sample]}],
					OpenPaths -> {
						{Object[Catalog, "Root"], "Materials", "Magnetic Bead Separation", "Wash Solutions"},
						{Object[Catalog, "Root"], "Materials", "Reagents", "Buffers"}
					}
				],

				Category->"Wash",
				NestedIndexMatching->True
			},
			{
				OptionName->QuinaryWashBufferVolume,
				Default->Automatic,
				Description->"The amount of QuinaryWashBuffer that is added to the magnetic beads for each quinary wash prior to elution or optional SenaryWash.",
				ResolutionDescription->"If QuinaryWash is set to True, QuinaryWashBufferVolume is automatically set to PreWashBufferVolume when PreWash is set to True, and is set to Volume when PreWash is set to False.",
				AllowNull->True,
				Widget->Widget[Type->Quantity,Pattern:>RangeP[1 Microliter,50 Milliliter],Units->{Microliter,{Microliter,Milliliter}}],
				Category->"Wash",
				NestedIndexMatching->True
			},
			{
				OptionName->QuinaryWashMix,
				Default->Automatic,
				Description->"Indicates if the solution is mixed following combination of QuinaryWashBuffer and the magnetic beads during each quinary wash.",
				ResolutionDescription->"Automatically set to True if QuinaryWash is set to True and QuinaryWashMixType is not set to Null.",
				AllowNull->True,
				Widget->Widget[Type->Enumeration,Pattern:>BooleanP],
				Category->"Wash",
				NestedIndexMatching->True
			},
			ModifyOptions[ExperimentMix,
				{
					OptionName -> MixType,
					ModifiedOptionName -> QuinaryWashMixType,
					Default->Automatic,
					Description -> "The style of motion used to mix the suspension following the addition of the QuinaryWashBuffer to the magnetic beads. Options include Roll, Vortex, Sonicate, Pipette, Invert, Stir, Shake, Homogenize, Swirl, Disrupt, Nutate.",
					ResolutionDescription -> "Automatically set based on the container of the sample and the QuinaryWashMix option. Specifically, if QuinaryWashMix is set to False, the option is set to Null. If any of QuinaryWashMixRate, QuinaryWashMixTemperature, and QuinaryWashMixTime is specified to a non-default value, QuinaryWashMixType is automatically set to Shake when Preparation is Robotic, when QuinaryWashMixTemperature is not Ambient, or when QuinaryWashMixRate is less or equal to 600 RPM; Otherwise QuinaryWashMixType is automatically set to Vortex. If none of QuinaryWashMixRate, QuinaryWashMixTemperature, and QuinaryWashMixTime is specified to non-default values, QuinaryWashMixType is automatically set to Pipette.",
					NestedIndexMatching -> True,
					Category -> "Wash",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> Time,
					ModifiedOptionName -> QuinaryWashMixTime,
					Default->Automatic,
					Description -> "The duration during which the combined QuinaryWashBuffer and magnetic beads are mixed.",
					ResolutionDescription -> "If QuinaryWashMixType is among Disrupt, Nutate, Shake, Vortex, Roll, Stir, Homogenize, and Sonicate, QuinaryWashMixTime is automatically set to 5 Minute for robotic preparation, and is set to 15 Minute for manual preparation.",
					NestedIndexMatching -> True,
					Category -> "Wash",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> MixRate,
					ModifiedOptionName -> QuinaryWashMixRate,
					Default->Automatic,
					Description -> "The frequency of rotation used to mix the combined QuinaryWashBuffer and magnetic beads.",
					ResolutionDescription -> "Automatically set to 300 RPM if QuinaryWashMixType is Shake or Stir, to 1000 RPM if QuinaryWashMixType is Vortex or Disrupt, and to 30 RPM if QuinaryWashMixType is Nutate or Roll.",
					NestedIndexMatching -> True,
					Category -> "Wash",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> NumberOfMixes,
					ModifiedOptionName -> NumberOfQuinaryWashMixes,
					Default->Automatic,
					Description -> "The number of times that the combined QuinaryWashBuffer and magnetic beads are mixed if QuinaryWashMixType is Pipette or Invert.",
					ResolutionDescription -> "Automatically set to 20 if QuinaryWashMixType is Pipette, Swirl or Invert.",
					NestedIndexMatching -> True,
					Category -> "Wash",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> MixVolume,
					ModifiedOptionName -> QuinaryWashMixVolume,
					Default->Automatic,
					Description ->"The volume of the combined QuinaryWashBuffer and magnetic beads that is pipetted up and down in order to mix, if QuinaryWashMixType->Pipette.",
					ResolutionDescription -> "For robotic preparation, QuinaryWashMixVolume is automatically set to 970 Microliter if 0.8*volume-to-mix (i.e.volume-to-mix is the volume of the combined QuinaryWashBuffer and magnetic beads) is greater than 970 Microliter, and otherwise is set to the greater of 10 Microliter and 0.8*volume-to-mix. For manual preparation, QuinaryWashMixVolume is automatically set to the lesser of 50 Milliliter and 0.8*volume-to-mix.",
					NestedIndexMatching -> True,
					Category -> "Wash",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> Temperature,
					ModifiedOptionName -> QuinaryWashMixTemperature,
					Default->Automatic,
					Description ->"The temperature of the device that is used to mix/incubate the combined QuinaryWashBuffer and magnetic beads.",
					ResolutionDescription->"Automatically set to Ambient if QuinaryMix is set to True and QuinaryWashMixType is not Null.",
					NestedIndexMatching -> True,
					Category -> "Wash",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> TipType,
					ModifiedOptionName -> QuinaryWashMixTipType,
					Default->Automatic,
					Description -> "The type of pipette tips used to mix the combined QuinaryWashBuffer and magnetic beads. Options include Normal, Barrier, WideBore, GelLoading, Aspirator. This option can only be set if QuinaryWashMixType->Pipette.",
					ResolutionDescription -> "Automatically set to WideBore for robotic preparation. For manual preparation, QuinaryWashMixTipType is automatically set to WideBore if QuinaryWashMixVolume is less or equal to 970 Microliter, to Normal if QuinaryWashMixVolume is larger than 970 Microliter but less or equal to 5 Milliliter, and to Barrier if QuinaryWashMixVolume is larger than 5 Milliliter.",
					NestedIndexMatching -> True,
					Category -> "Wash",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> TipMaterial,
					ModifiedOptionName -> QuinaryWashMixTipMaterial,
					Default->Automatic,
					Description -> "The material of the pipette tips used to aspirate and dispense the requested volume during the QuinaryWashMix. This option can only be set if QuinaryWashMixType->Pipette.",
					ResolutionDescription -> "Automatically set to Polypropylene if QuinaryWashMixVolume is less or equal to 5 Milliliter, and to Glass if QuinaryWashMixVolume is larger than 5 Milliliter.",
					NestedIndexMatching -> True,
					Category -> "Wash",
					IndexMatchingOptions -> {}
				}
			],
			{
				OptionName->QuinaryWashMagnetizationTime,
				Default->Automatic,
				Description->"The duration of magnetizing the magnetic beads after QuinaryWashMixTime has elapsed, in order to pull the magnetic beads to the perimeter of the container by applying a magnetic force, thus enables maximal aspiration of the used QuinaryWashBuffer containing residual sample components that are not bound to the magnetic beads.",
				ResolutionDescription->"Automatically set to 5 minutes if QuinaryWash is set to True.",
				AllowNull->True,
				Widget->Widget[Type->Quantity,Pattern:>RangeP[0 Second,$MaxExperimentTime],Units->{Second,{Second,Minute,Hour}}],
				Category->"Wash",
				NestedIndexMatching->True
			},
			{
				OptionName->QuinaryWashAspirationVolume,
				Default->Automatic,
				Description->"The volume of solution to aspirate out while the magnetic beads are magnetized and gathered to the side during each quinary wash prior to elution or optional SenaryWash.",
				ResolutionDescription->"Automatically set to All for manual preparation, and set to QuinaryWashBufferVolume for robotic preparation.",
				AllowNull->True,
				Widget->Alternatives[
					"All"->Widget[Type->Enumeration,Pattern:>Alternatives[All]],
					"Volume"->Widget[Type->Quantity,Pattern:>RangeP[1 Microliter,50 Milliliter],Units->{Microliter,{Microliter,Milliliter}}]
				],
				Category->"Wash",
				NestedIndexMatching->True
			},
      ModifyOptions[TransferRoboticTipOptions,
        {
          OptionName -> AspirationPosition,
          ModifiedOptionName -> QuinaryWashAspirationPosition,
          Default->Automatic,
          AllowNull ->True,
          Widget -> Widget[
            Type -> Enumeration,
            Pattern :> MagneticBeadSeparationPipettingPositionP
          ],
          Description -> "The location from which the solution is aspirated after QuinaryWashMagnetizationTime. Top will aspirate QuinaryWashAspirationPositionOffset below the Top of the container, Bottom will aspirate QuinaryWashAspirationPositionOffset above the Bottom of the container, and LiquidLevel will aspirate QuinaryWashAspirationPositionOffset below the liquid level of the sample in the container.",
          ResolutionDescription -> "Automatically set to Bottom if Preparation->Robotic and QuinaryWash is True.",
          NestedIndexMatching -> True,
          Category->"Wash"
        }
      ],
      ModifyOptions[TransferRoboticTipOptions,
        {
          OptionName -> AspirationPositionOffset,
          ModifiedOptionName -> QuinaryWashAspirationPositionOffset,
          Default->Automatic,
          AllowNull ->True,
          Description -> "The distance from the center of the well that the solution is aspirated after QuinaryWashMagnetizationTime. The Z Offset is based on the QuinaryWashAspirationPosition option -- measured as the height below the top of the well (Top), the height above the bottom of the well (Bottom), or the height below the detected liquid level (LiquidLevel). Please refer to the AspirationPosition diagram in the help file of ExperimentTransfer for more information. If an X and Y offset is not specified, the liquid will be aspirated in the center of the well, otherwise, -X/+X values will shift the position left and right, respectively, and -Y/+Y values will shift the position down and up, respectively.",
          ResolutionDescription -> "Automatically set to 0 Millimeter if MagnetizationRack is Model[Item,MagnetizationRack,\"Alpaqua Magnum FLX Enhanced Universal Magnet 96-well Plate Rack\"] and QuinaryWashAspirationPosition is bottom, otherwise set to 2 Millimeter.",
          NestedIndexMatching -> True,
          Category->"Wash"
        }
      ],
			{
				OptionName->QuinaryWashCollectionContainer,
				Default->Automatic,
				Description->"The container(s) for collecting the aspirated sample(s) during the Quinary wash(es) prior to elution or optional SenaryWash. By default, the same container is selected for the repeated quinary washes (i.e. aspirated samples in the repeated quinary washes will be combined) unless different container objects are specified for the quinary washes.",
				ResolutionDescription->"Automatically set to a container plate and its first available position. The container plate is selected by the function PreferredContainer given the volume of QuinaryWashAspirationVolume for manual preparation, and is set to 2 mL Deep well plate for robotic preparation, if QuinaryWash is set to True.",
				AllowNull->True,
				Widget -> Alternatives[
					Adder[
						Alternatives[
							"Container" -> Widget[
								Type -> Object,
								Pattern :> ObjectP[{Object[Container], Model[Container]}]
							],
							"Container with Index" -> {
								"Index" -> Widget[
									Type -> Number,
									Pattern :> GreaterEqualP[1, 1]
								],
								"Container" -> Widget[
									Type -> Object,
									Pattern :> ObjectP[Model[Container]],
									PreparedSample -> False,
									PreparedContainer -> False
								]
							},
							"Container with Well" -> {
								"Well" -> Widget[
									Type -> Enumeration,
									Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
									PatternTooltip -> "Enumeration must be any well from A1 to H12."
								],
								"Container" -> Widget[
									Type -> Object,
									Pattern :> ObjectP[Model[Container]],
									PreparedSample -> False,
									PreparedContainer -> False
								]
							},
							"Container with Well and Index" -> {
								"Well" -> Widget[
									Type -> Enumeration,
									Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
									PatternTooltip -> "Enumeration must be any well from A1 to H12."
								],
								"Index and Container"->{
									"Index"->Widget[
										Type->Number,
										Pattern:>GreaterEqualP[1,1]
									],
									"Container"->Widget[
										Type->Object,
										Pattern:>ObjectP[{Model[Container]}],
										PreparedSample->False,
										PreparedContainer->False
									]
								}
							},
							"Automatic or Null" -> Widget[
								Type -> Enumeration,
								Pattern :> Alternatives[Automatic,Null]
							]
						]
					],
					Alternatives[
						"Container" -> Widget[
							Type -> Object,
							Pattern :> ObjectP[{Object[Container], Model[Container]}]
						],
						"Container with Index" -> {
							"Index" -> Widget[
								Type -> Number,
								Pattern :> GreaterEqualP[1, 1]
							],
							"Container" -> Widget[
								Type -> Object,
								Pattern :> ObjectP[Model[Container]],
								PreparedSample -> False,
								PreparedContainer -> False
							]
						},
						"Container with Well" -> {
							"Well" -> Widget[
								Type -> Enumeration,
								Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
								PatternTooltip -> "Enumeration must be any well from A1 to H12."
							],
							"Container" -> Widget[
								Type -> Object,
								Pattern :> ObjectP[Model[Container]],
								PreparedSample -> False,
								PreparedContainer -> False
							]
						},
						"Container with Well and Index" -> {
							"Well" -> Widget[
								Type -> Enumeration,
								Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
								PatternTooltip -> "Enumeration must be any well from A1 to H12."
							],
							"Index and Container"->{
								"Index"->Widget[
									Type->Number,
									Pattern:>GreaterEqualP[1,1]
								],
								"Container"->Widget[
									Type->Object,
									Pattern:>ObjectP[{Model[Container]}],
									PreparedSample->False,
									PreparedContainer->False
								]
							}
						}
					]
				],
				Category->"Wash",
				NestedIndexMatching->True
			},
			{
				OptionName->QuinaryWashCollectionStorageCondition,
				Default->Automatic,
				Description->"The non-default condition under which the aspirated samples during the quinary wash prior to elution or optional SenaryWash are stored after the protocol is completed.",
				ResolutionDescription->"Automatically set to Refrigerator if QuinaryWash is set to True.",
				AllowNull->True,
				Widget->Alternatives[
					"Condition"->Widget[
						Type->Enumeration,Pattern:>SampleStorageTypeP|Disposal
					],
					"Objects"->Widget[
						Type->Object,
						Pattern:>ObjectP[Model[StorageCondition]],
						OpenPaths->{
							{Object[Catalog,"Root"],
								"Storage Conditions"}
						}
					]
				],
				Category->"Post Experiment",
				NestedIndexMatching->True
			},
			{
				OptionName->NumberOfQuinaryWashes,
				Default->Automatic,
				Description->"The number of times the magnetic beads are washed by adding QuinaryWashBuffer, mixing, magnetization, and aspirating solution prior to elution or optional SenaryWash.",
				ResolutionDescription->"Automatically set to 1 if QuinaryWash is set to True.",
				AllowNull->True,
				Widget->Widget[Type->Number,Pattern:>RangeP[1,20,1]],
				Category->"Wash",
				NestedIndexMatching->True
			},
			{
				OptionName->QuinaryWashAirDry,
				Default->Automatic,
				Description->"Indicates if the magnetic beads are exposed to open air to evaporate the remaining QuinaryWashBuffer following the final quinary wash prior to elution or optional SenaryWash.",
				ResolutionDescription->"Automatically set to False if QuinaryWash is set to True.",
				AllowNull->True,
				Widget->Widget[Type->Enumeration,Pattern:>BooleanP],
				Category->"Wash",
				NestedIndexMatching->True
			},
			{
				OptionName->QuinaryWashAirDryTime,
				Default->Automatic,
				Description->"The duration that the magnetic beads are exposed to open air to evaporate the remaining QuinaryWashBuffer following the final quinary wash prior to elution or optional SenaryWash.",
				ResolutionDescription->"Automatically set to 1 Minute if QuinaryWashAirDry is set to True.",
				AllowNull->True,
				Widget->Widget[Type->Quantity,Pattern:>RangeP[0 Second,$MaxExperimentTime],Units->{Second,{Second,Minute,Hour}}],
				Category->"Wash",
				NestedIndexMatching->True
			},

			(*--- SenaryWash---*)
			{
				OptionName->SenaryWash,
				Default->Automatic,
				Description->"Indicates if the magnetic beads with bound targets or contaminants are further rinsed after QuinaryWash prior to elution or optional SeptenaryWash, in order to better separate the bead-bound components from the unbound components in the sample, or for on-bead digestion. The washing steps (up to SeptenaryWash) can optionally be used for on-bead digestion to perform alkylation, reduction, trypsin digestion, etc.",
				ResolutionDescription->"Automatically set to True if other SenaryWash options are set, or False otherwise.",
				AllowNull->False,
				Widget->Widget[Type->Enumeration,Pattern:>BooleanP],
				Category->"Wash",
				NestedIndexMatching->True
			},
			{
				OptionName->SenaryWashBuffer,
				Default->Automatic,
				Description->"The solution used to rinse the magnetic beads during SenaryWash prior to Elution or optional SeptenaryWash, in order to better separate the bead-bound components from the unbound components in the sample, or for on-bead digestion.",
				ResolutionDescription->"Automatically set to Model[Sample,\"Milli-Q water\"] if SenaryWash is set to True.",
				AllowNull->True,
				Widget->Widget[
					Type->Object,
					Pattern:>ObjectP[{Model[Sample],Object[Sample]}],
					OpenPaths -> {
						{Object[Catalog, "Root"], "Materials", "Magnetic Bead Separation", "Wash Solutions"},
						{Object[Catalog, "Root"], "Materials", "Reagents", "Buffers"}
					}
				],

				Category->"Wash",
				NestedIndexMatching->True
			},
			{
				OptionName->SenaryWashBufferVolume,
				Default->Automatic,
				Description->"The amount of SenaryWashBuffer that is added to the magnetic beads for each senary wash prior to elution.",
				ResolutionDescription->"If SenaryWash is set to True, SenaryWashBufferVolume is automatically set to PreWashBufferVolume when PreWash is set to True, and is set to Volume when PreWash is set to False.",
				AllowNull->True,
				Widget->Widget[Type->Quantity,Pattern:>RangeP[1 Microliter,50 Milliliter],Units->{Microliter,{Microliter,Milliliter}}],
				Category->"Wash",
				NestedIndexMatching->True
			},
			{
				OptionName->SenaryWashMix,
				Default->Automatic,
				Description->"Indicates if the solution is mixed following combination of SenaryWashBuffer and the magnetic beads during each senary wash.",
				ResolutionDescription->"Automatically set to True if SenaryWash is set to True and SenaryWashMixType is not set to Null.",
				AllowNull->True,
				Widget->Widget[Type->Enumeration,Pattern:>BooleanP],
				Category->"Wash",
				NestedIndexMatching->True
			},
			ModifyOptions[ExperimentMix,
				{
					OptionName -> MixType,
					ModifiedOptionName -> SenaryWashMixType,
					Default->Automatic,
					Description -> "The style of motion used to mix the suspension following the addition of the SenaryWashBuffer to the magnetic beads. Options include Roll, Vortex, Sonicate, Pipette, Invert, Stir, Shake, Homogenize, Swirl, Disrupt, Nutate.",
					ResolutionDescription -> "Automatically set based on the container of the sample and the SenaryWashMix option. Specifically, if SenaryWashMix is set to False, the option is set to Null. If any of SenaryWashMixRate, SenaryWashMixTemperature, and SenaryWashMixTime is specified to a non-default value, SenaryWashMixType is automatically set to Shake when Preparation is Robotic, when SenaryWashMixTemperature is not Ambient, or when SenaryWashMixRate is less or equal to 600 RPM; Otherwise SenaryWashMixType is automatically set to Vortex. If none of SenaryWashMixRate, SenaryWashMixTemperature, and SenaryWashMixTime is specified to non-default values, SenaryWashMixType is automatically set to Pipette.",
					NestedIndexMatching -> True,
					Category -> "Wash",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> Time,
					ModifiedOptionName -> SenaryWashMixTime,
					Default->Automatic,
					Description -> "The duration during which the combined SenaryWashBuffer and magnetic beads are mixed.",
					ResolutionDescription -> "If SenaryWashMixType is among Disrupt, Nutate, Shake, Vortex, Roll, Stir, Homogenize, and Sonicate, SenaryWashMixTime is automatically set to 5 Minute for robotic preparation, and is set to 15 Minute for manual preparation.",
					NestedIndexMatching -> True,
					Category -> "Wash",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> MixRate,
					ModifiedOptionName -> SenaryWashMixRate,
					Default->Automatic,
					Description -> "The frequency of rotation used to mix the combined SenaryWashBuffer and magnetic beads.",
					ResolutionDescription -> "Automatically set to 300 RPM if SenaryWashMixType is Shake or Stir, to 1000 RPM if SenaryWashMixType is Vortex or Disrupt, and to 30 RPM if SenaryWashMixType is Nutate or Roll.",
					NestedIndexMatching -> True,
					Category -> "Wash",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> NumberOfMixes,
					ModifiedOptionName -> NumberOfSenaryWashMixes,
					Default->Automatic,
					Description -> "The number of times that the combined SenaryWashBuffer and magnetic beads are mixed if SenaryWashMixType is Pipette or Invert.",
					ResolutionDescription -> "Automatically set to 20 if SenaryWashMixType is Pipette, Swirl or Invert.",
					NestedIndexMatching -> True,
					Category -> "Wash",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> MixVolume,
					ModifiedOptionName -> SenaryWashMixVolume,
					Default->Automatic,
					Description ->"The volume of the combined SenaryWashBuffer and magnetic beads that is pipetted up and down in order to mix, if SenaryWashMixType->Pipette.",
					ResolutionDescription -> "For robotic preparation, SenaryWashMixVolume is automatically set to 970 Microliter if 0.8*volume-to-mix (i.e.volume-to-mix is the volume of the combined SenaryWashBuffer and magnetic beads) is greater than 970 Microliter, and otherwise is set to the greater of 10 Microliter and 0.8*volume-to-mix. For manual preparation, SenaryWashMixVolume is automatically set to the lesser of 50 Milliliter and 0.8*volume-to-mix.",
					NestedIndexMatching -> True,
					Category -> "Wash",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> Temperature,
					ModifiedOptionName -> SenaryWashMixTemperature,
					Default->Automatic,
					Description ->"The temperature of the device that is used to mix/incubate the combined SenaryWashBuffer and magnetic beads.",
					ResolutionDescription->"Automatically set to Ambient if SenaryMix is set to True and SenaryWashMixType is not Null.",
					NestedIndexMatching -> True,
					Category -> "Wash",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> TipType,
					ModifiedOptionName -> SenaryWashMixTipType,
					Default->Automatic,
					Description -> "The type of pipette tips used to mix the combined SenaryWashBuffer and magnetic beads. Options include Normal, Barrier, WideBore, GelLoading, Aspirator. This option can only be set if SenaryWashMixType->Pipette.",
					ResolutionDescription -> "Automatically set to WideBore for robotic preparation. For manual preparation, SenaryWashMixTipType is automatically set to WideBore if SenaryWashMixVolume is less or equal to 970 Microliter, to Normal if SenaryWashMixVolume is larger than 970 Microliter but less or equal to 5 Milliliter, and to Barrier if SenaryWashMixVolume is larger than 5 Milliliter.",
					NestedIndexMatching -> True,
					Category -> "Wash",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> TipMaterial,
					ModifiedOptionName -> SenaryWashMixTipMaterial,
					Default->Automatic,
					Description -> "The material of the pipette tips used to aspirate and dispense the requested volume during the SenaryWashMix. This option can only be set if SenaryWashMixType->Pipette.",
					ResolutionDescription -> "Automatically set to Polypropylene if SenaryWashMixVolume is less or equal to 5 Milliliter, and to Glass if SenaryWashMixVolume is larger than 5 Milliliter.",
					NestedIndexMatching -> True,
					Category -> "Wash",
					IndexMatchingOptions -> {}
				}
			],
			{
				OptionName->SenaryWashMagnetizationTime,
				Default->Automatic,
				Description->"The duration of magnetizing the magnetic beads after SenaryWashMixTime has elapsed, in order to pull the magnetic beads to the perimeter of the container by applying a magnetic force, thus enables maximal aspiration of the used SenaryWashBuffer containing residual sample components that are not bound to the magnetic beads.",
				ResolutionDescription->"Automatically set to 5 minutes if SenaryWash is set to True.",
				AllowNull->True,
				Widget->Widget[Type->Quantity,Pattern:>RangeP[0 Second,$MaxExperimentTime],Units->{Second,{Second,Minute,Hour}}],
				Category->"Wash",
				NestedIndexMatching->True
			},
			{
				OptionName->SenaryWashAspirationVolume,
				Default->Automatic,
				Description->"The volume of solution to aspirate out while the magnetic beads are magnetized and gathered to the side during each senary wash prior to elution or optional SeptenaryWash.",
				ResolutionDescription->"Automatically set to All for manual preparation, and set to SenaryWashBufferVolume for robotic preparation.",
				AllowNull->True,
				Widget->Alternatives[
					"All"->Widget[Type->Enumeration,Pattern:>Alternatives[All]],
					"Volume"->Widget[Type->Quantity,Pattern:>RangeP[1 Microliter,50 Milliliter],Units->{Microliter,{Microliter,Milliliter}}]
				],
				Category->"Wash",
				NestedIndexMatching->True
			},
      ModifyOptions[TransferRoboticTipOptions,
        {
          OptionName -> AspirationPosition,
          ModifiedOptionName -> SenaryWashAspirationPosition,
          Default->Automatic,
          AllowNull ->True,
          Widget -> Widget[
            Type -> Enumeration,
            Pattern :> MagneticBeadSeparationPipettingPositionP
          ],
          Description -> "The location from which the solution is aspirated after SenaryWashMagnetizationTime. Top will aspirate SenaryWashAspirationPositionOffset below the Top of the container, Bottom will aspirate SenaryWashAspirationPositionOffset above the Bottom of the container, and LiquidLevel will aspirate SenaryWashAspirationPositionOffset below the liquid level of the sample in the container.",
          ResolutionDescription -> "Automatically set to Bottom if Preparation->Robotic and SenaryWash is True.",
          NestedIndexMatching -> True,
          Category->"Wash"
        }
      ],
      ModifyOptions[TransferRoboticTipOptions,
        {
          OptionName -> AspirationPositionOffset,
          ModifiedOptionName -> SenaryWashAspirationPositionOffset,
          Default->Automatic,
          AllowNull ->True,
          Description -> "The distance from the center of the well that the solution is aspirated after SenaryWashMagnetizationTime. The Z Offset is based on the SenaryWashAspirationPosition option -- measured as the height below the top of the well (Top), the height above the bottom of the well (Bottom), or the height below the detected liquid level (LiquidLevel). Please refer to the AspirationPosition diagram in the help file of ExperimentTransfer for more information. If an X and Y offset is not specified, the liquid will be aspirated in the center of the well, otherwise, -X/+X values will shift the position left and right, respectively, and -Y/+Y values will shift the position down and up, respectively.",
          ResolutionDescription -> "Automatically set to 0 Millimeter if MagnetizationRack is Model[Item,MagnetizationRack,\"Alpaqua Magnum FLX Enhanced Universal Magnet 96-well Plate Rack\"] and SenaryWashAspirationPosition is bottom, otherwise set to 2 Millimeter.",
          NestedIndexMatching -> True,
          Category->"Wash"
        }
      ],
			{
				OptionName->SenaryWashCollectionContainer,
				Default->Automatic,
				Description->"The container(s) for collecting the aspirated sample(s) during the senary wash(es) prior to elution or optional SeptenaryWash. By default, the same container is selected for the repeated senary washes (i.e. aspirated samples in the repeated senary washes will be combined) unless different container objects are specified for the senary washes.",
				ResolutionDescription->"Automatically set to a container plate and its first available position. The container plate is selected by the function PreferredContainer given the volume of SenaryWashAspirationVolume for manual preparation, and is set to 2 mL Deep well plate for robotic preparation, if SenaryWash is set to True.",
				AllowNull->True,
				Widget -> Alternatives[
					Adder[
						Alternatives[
							"Container" -> Widget[
								Type -> Object,
								Pattern :> ObjectP[{Object[Container], Model[Container]}]
							],
							"Container with Index" -> {
								"Index" -> Widget[
									Type -> Number,
									Pattern :> GreaterEqualP[1, 1]
								],
								"Container" -> Widget[
									Type -> Object,
									Pattern :> ObjectP[Model[Container]],
									PreparedSample -> False,
									PreparedContainer -> False
								]
							},
							"Container with Well" -> {
								"Well" -> Widget[
									Type -> Enumeration,
									Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
									PatternTooltip -> "Enumeration must be any well from A1 to H12."
								],
								"Container" -> Widget[
									Type -> Object,
									Pattern :> ObjectP[Model[Container]],
									PreparedSample -> False,
									PreparedContainer -> False
								]
							},
							"Container with Well and Index" -> {
								"Well" -> Widget[
									Type -> Enumeration,
									Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
									PatternTooltip -> "Enumeration must be any well from A1 to H12."
								],
								"Index and Container"->{
									"Index"->Widget[
										Type->Number,
										Pattern:>GreaterEqualP[1,1]
									],
									"Container"->Widget[
										Type->Object,
										Pattern:>ObjectP[{Model[Container]}],
										PreparedSample->False,
										PreparedContainer->False
									]
								}
							},
							"Automatic or Null" -> Widget[
								Type -> Enumeration,
								Pattern :> Alternatives[Automatic,Null]
							]
						]
					],
					Alternatives[
						"Container" -> Widget[
							Type -> Object,
							Pattern :> ObjectP[{Object[Container], Model[Container]}]
						],
						"Container with Index" -> {
							"Index" -> Widget[
								Type -> Number,
								Pattern :> GreaterEqualP[1, 1]
							],
							"Container" -> Widget[
								Type -> Object,
								Pattern :> ObjectP[Model[Container]],
								PreparedSample -> False,
								PreparedContainer -> False
							]
						},
						"Container with Well" -> {
							"Well" -> Widget[
								Type -> Enumeration,
								Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
								PatternTooltip -> "Enumeration must be any well from A1 to H12."
							],
							"Container" -> Widget[
								Type -> Object,
								Pattern :> ObjectP[Model[Container]],
								PreparedSample -> False,
								PreparedContainer -> False
							]
						},
						"Container with Well and Index" -> {
							"Well" -> Widget[
								Type -> Enumeration,
								Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
								PatternTooltip -> "Enumeration must be any well from A1 to H12."
							],
							"Index and Container"->{
								"Index"->Widget[
									Type->Number,
									Pattern:>GreaterEqualP[1,1]
								],
								"Container"->Widget[
									Type->Object,
									Pattern:>ObjectP[{Model[Container]}],
									PreparedSample->False,
									PreparedContainer->False
								]
							}
						}
					]
				],
				Category->"Wash",
				NestedIndexMatching->True
			},
			{
				OptionName->SenaryWashCollectionStorageCondition,
				Default->Automatic,
				Description->"The non-default condition under which the aspirated samples during the senary wash prior to elution or optional SeptenaryWash are stored after the protocol is completed.",
				ResolutionDescription->"Automatically set to Refrigerator if SenaryWash is set to True.",
				AllowNull->True,
				Widget->Alternatives[
					"Condition"->Widget[
						Type->Enumeration,Pattern:>SampleStorageTypeP|Disposal
					],
					"Objects"->Widget[
						Type->Object,
						Pattern:>ObjectP[Model[StorageCondition]],
						OpenPaths->{
							{Object[Catalog,"Root"],
								"Storage Conditions"}
						}
					]
				],
				Category->"Post Experiment",
				NestedIndexMatching->True
			},
			{
				OptionName->NumberOfSenaryWashes,
				Default->Automatic,
				Description->"The number of times the magnetic beads are washed by adding SenaryWashBuffer, mixing, magnetization, and aspirating solution prior to elution or optional SeptenaryWash.",
				ResolutionDescription->"Automatically set to 1 if SenaryWash is set to True.",
				AllowNull->True,
				Widget->Widget[Type->Number,Pattern:>RangeP[1,20,1]],
				Category->"Wash",
				NestedIndexMatching->True
			},
			{
				OptionName->SenaryWashAirDry,
				Default->Automatic,
				Description->"Indicates if the magnetic beads are exposed to open air to evaporate the remaining SenaryWashBuffer following the final senary wash prior to elution or optional SeptenaryWash.",
				ResolutionDescription->"Automatically set to False if SenaryWash is set to True.",
				AllowNull->True,
				Widget->Widget[Type->Enumeration,Pattern:>BooleanP],
				Category->"Wash",
				NestedIndexMatching->True
			},
			{
				OptionName->SenaryWashAirDryTime,
				Default->Automatic,
				Description->"The duration that the magnetic beads are exposed to open air to evaporate the remaining SenaryWashBuffer following the final senary wash prior to elution or optional SeptenaryWash.",
				ResolutionDescription->"Automatically set to 1 Minute if SenaryWashAirDry is set to True.",
				AllowNull->True,
				Widget->Widget[Type->Quantity,Pattern:>RangeP[0 Second,$MaxExperimentTime],Units->{Second,{Second,Minute,Hour}}],
				Category->"Wash",
				NestedIndexMatching->True
			},

			(*--- SeptenaryWash---*)
			{
				OptionName->SeptenaryWash,
				Default->Automatic,
				Description->"Indicates if the magnetic beads with bound targets or contaminants are rinsed after SenaryWash prior to Elution, in order to better separate the bead-bound components from the unbound components in the sample, or for on-bead digestion. The washing steps (up to SeptenaryWash) can optionally be used for on-bead digestion to perform alkylation, reduction, trypsin digestion, etc.",
				ResolutionDescription->"Automatically set to True if other SeptenaryWash options are set, or False otherwise.",
				AllowNull->False,
				Widget->Widget[Type->Enumeration,Pattern:>BooleanP],
				Category->"Wash",
				NestedIndexMatching->True
			},
			{
				OptionName->SeptenaryWashBuffer,
				Default->Automatic,
				Description->"The solution used to rinse the magnetic beads during SeptenaryWash prior to elution, in order to better separate the bead-bound components from the unbound components in the sample, or for on-bead digestion.",
				ResolutionDescription->"Automatically set to Model[Sample,\"Milli-Q water\"] if SeptenaryWash is set to True.",
				AllowNull->True,
				Widget->Widget[
					Type->Object,
					Pattern:>ObjectP[{Model[Sample],Object[Sample]}],
					OpenPaths -> {
						{Object[Catalog, "Root"], "Materials", "Magnetic Bead Separation", "Wash Solutions"},
						{Object[Catalog, "Root"], "Materials", "Reagents", "Buffers"}
					}
				],

				Category->"Wash",
				NestedIndexMatching->True
			},
			{
				OptionName->SeptenaryWashBufferVolume,
				Default->Automatic,
				Description->"The amount of SeptenaryWashBuffer that is added to the magnetic beads for each septenary wash prior to elution.",
				ResolutionDescription->"If SeptenaryWash is set to True, SeptenaryWashBufferVolume is automatically set to PreWashBufferVolume when PreWash is set to True, and is set to Volume when PreWash is set to False.",
				AllowNull->True,
				Widget->Widget[Type->Quantity,Pattern:>RangeP[1 Microliter,50 Milliliter],Units->{Microliter,{Microliter,Milliliter}}],
				Category->"Wash",
				NestedIndexMatching->True
			},
			{
				OptionName->SeptenaryWashMix,
				Default->Automatic,
				Description->"Indicates if the solution is mixed following combination of SeptenaryWashBuffer and the magnetic beads during each septenary wash.",
				ResolutionDescription->"Automatically set to True if SeptenaryWash is set to True and SeptenaryWashMixType is not set to Null.",
				AllowNull->True,
				Widget->Widget[Type->Enumeration,Pattern:>BooleanP],
				Category->"Wash",
				NestedIndexMatching->True
			},
			ModifyOptions[ExperimentMix,
				{
					OptionName -> MixType,
					ModifiedOptionName -> SeptenaryWashMixType,
					Default->Automatic,
					Description -> "The style of motion used to mix the suspension following the addition of the SeptenaryWashBuffer to the magnetic beads. Options include Roll, Vortex, Sonicate, Pipette, Invert, Stir, Shake, Homogenize, Swirl, Disrupt, Nutate.",
					ResolutionDescription -> "Automatically set based on the container of the sample and the SeptenaryWashMix option. Specifically, if SeptenaryWashMix is set to False, the option is set to Null. If any of SeptenaryWashMixRate, SeptenaryWashMixTemperature, and SeptenaryWashMixTime is specified to a non-default value, SeptenaryWashMixType is automatically set to Shake when Preparation is Robotic, when SeptenaryWashMixTemperature is not Ambient, or when SeptenaryWashMixRate is less or equal to 600 RPM; Otherwise SeptenaryWashMixType is automatically set to Vortex. If none of SeptenaryWashMixRate, SeptenaryWashMixTemperature, and SeptenaryWashMixTime is specified to non-default values, SeptenaryWashMixType is automatically set to Pipette.",
					NestedIndexMatching -> True,
					Category -> "Wash",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> Time,
					ModifiedOptionName -> SeptenaryWashMixTime,
					Default->Automatic,
					Description -> "The duration during which the combined SeptenaryWashBuffer and magnetic beads are mixed.",
					ResolutionDescription -> "If SeptenaryWashMixType is among Disrupt, Nutate, Shake, Vortex, Roll, Stir, Homogenize, and Sonicate, SeptenaryWashMixTime is automatically set to 5 Minute for robotic preparation, and is set to 15 Minute for manual preparation.",
					NestedIndexMatching -> True,
					Category -> "Wash",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> MixRate,
					ModifiedOptionName -> SeptenaryWashMixRate,
					Default->Automatic,
					Description -> "The frequency of rotation used to mix the combined SeptenaryWashBuffer and magnetic beads.",
					ResolutionDescription -> "Automatically set to 300 RPM if SeptenaryWashMixType is Shake or Stir, to 1000 RPM if SeptenaryWashMixType is Vortex or Disrupt, and to 30 RPM if SeptenaryWashMixType is Nutate or Roll.",
					NestedIndexMatching -> True,
					Category -> "Wash",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> NumberOfMixes,
					ModifiedOptionName -> NumberOfSeptenaryWashMixes,
					Default->Automatic,
					Description -> "The number of times that the combined SeptenaryWashBuffer and magnetic beads are mixed if SeptenaryWashMixType is Pipette or Invert.",
					ResolutionDescription -> "Automatically set to 20 if SeptenaryWashMixType is Pipette, Swirl or Invert.",
					NestedIndexMatching -> True,
					Category -> "Wash",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> MixVolume,
					ModifiedOptionName -> SeptenaryWashMixVolume,
					Default->Automatic,
					Description ->"The volume of the combined SeptenaryWashBuffer and magnetic beads that is pipetted up and down in order to mix, if SeptenaryWashMixType->Pipette.",
					ResolutionDescription -> "For robotic preparation, SeptenaryWashMixVolume is automatically set to 970 Microliter if 0.8*volume-to-mix (i.e.volume-to-mix is the volume of the combined SeptenaryWashBuffer and magnetic beads) is greater than 970 Microliter, and otherwise is set to the greater of 10 Microliter and 0.8*volume-to-mix. For manual preparation, SeptenaryWashMixVolume is automatically set to the lesser of 50 Milliliter and 0.8*volume-to-mix.",
					NestedIndexMatching -> True,
					Category -> "Wash",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> Temperature,
					ModifiedOptionName -> SeptenaryWashMixTemperature,
					Default->Automatic,
					Description ->"The temperature of the device that is used to mix/incubate the combined SeptenaryWashBuffer and magnetic beads.",
					ResolutionDescription->"Automatically set to Ambient if SeptenaryMix is set to True and SeptenaryWashMixType is not Null.",
					NestedIndexMatching -> True,
					Category -> "Wash",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> TipType,
					ModifiedOptionName -> SeptenaryWashMixTipType,
					Default->Automatic,
					Description -> "The type of pipette tips used to mix the combined SeptenaryWashBuffer and magnetic beads. Options include Normal, Barrier, WideBore, GelLoading, Aspirator. This option can only be set if SeptenaryWashMixType->Pipette.",
					ResolutionDescription -> "Automatically set to WideBore for robotic preparation. For manual preparation, SeptenaryWashMixTipType is automatically set to WideBore if SeptenaryWashMixVolume is less or equal to 970 Microliter, to Normal if SeptenaryWashMixVolume is larger than 970 Microliter but less or equal to 5 Milliliter, and to Barrier if SeptenaryWashMixVolume is larger than 5 Milliliter.",
					NestedIndexMatching -> True,
					Category -> "Wash",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> TipMaterial,
					ModifiedOptionName -> SeptenaryWashMixTipMaterial,
					Default->Automatic,
					Description -> "The material of the pipette tips used to aspirate and dispense the requested volume during the SeptenaryWashMix. This option can only be set if SeptenaryWashMixType->Pipette.",
					ResolutionDescription -> "Automatically set to Polypropylene if SeptenaryWashMixVolume is less or equal to 5 Milliliter, and to Glass if SeptenaryWashMixVolume is larger than 5 Milliliter.",
					NestedIndexMatching -> True,
					Category -> "Wash",
					IndexMatchingOptions -> {}
				}
			],
			{
				OptionName->SeptenaryWashMagnetizationTime,
				Default->Automatic,
				Description->"The duration of magnetizing the magnetic beads after SeptenaryWashMixTime has elapsed, in order to pull the magnetic beads to the perimeter of the container by applying a magnetic force, thus enables maximal aspiration of the used SeptenaryWashBuffer containing residual sample components that are not bound to the magnetic beads.",
				ResolutionDescription->"Automatically set to 5 minutes if SeptenaryWash is set to True.",
				AllowNull->True,
				Widget->Widget[Type->Quantity,Pattern:>RangeP[0 Second,$MaxExperimentTime],Units->{Second,{Second,Minute,Hour}}],
				Category->"Wash",
				NestedIndexMatching->True
			},
			{
				OptionName->SeptenaryWashAspirationVolume,
				Default->Automatic,
				Description->"The volume of solution to aspirate out while the magnetic beads are magnetized and gathered to the side during each septenary wash prior to elution.",
				ResolutionDescription->"Automatically set to All for manual preparation, and set to SeptenaryWashBufferVolume for robotic preparation.",
				AllowNull->True,
				Widget->Alternatives[
					"All"->Widget[Type->Enumeration,Pattern:>Alternatives[All]],
					"Volume"->Widget[Type->Quantity,Pattern:>RangeP[1 Microliter,50 Milliliter],Units->{Microliter,{Microliter,Milliliter}}]
				],
				Category->"Wash",
				NestedIndexMatching->True
			},
      ModifyOptions[TransferRoboticTipOptions,
        {
          OptionName -> AspirationPosition,
          ModifiedOptionName -> SeptenaryWashAspirationPosition,
          Default->Automatic,
          AllowNull ->True,
          Widget -> Widget[
            Type -> Enumeration,
            Pattern :> MagneticBeadSeparationPipettingPositionP
          ],
          Description -> "The location from which the solution is aspirated after SeptenaryWashMagnetizationTime. Top will aspirate SeptenaryWashAspirationPositionOffset below the Top of the container, Bottom will aspirate SeptenaryWashAspirationPositionOffset above the Bottom of the container, and LiquidLevel will aspirate SeptenaryWashAspirationPositionOffset below the liquid level of the sample in the container.",
          ResolutionDescription -> "Automatically set to Bottom if Preparation->Robotic and SeptenaryWash is True.",
          NestedIndexMatching -> True,
          Category->"Wash"
        }
      ],
      ModifyOptions[TransferRoboticTipOptions,
        {
          OptionName -> AspirationPositionOffset,
          ModifiedOptionName -> SeptenaryWashAspirationPositionOffset,
          Default->Automatic,
          AllowNull ->True,
          Description -> "The distance from the center of the well that the solution is aspirated after SeptenaryWashMagnetizationTime. The Z Offset is based on the SeptenaryWashAspirationPosition option -- measured as the height below the top of the well (Top), the height above the bottom of the well (Bottom), or the height below the detected liquid level (LiquidLevel). Please refer to the AspirationPosition diagram in the help file of ExperimentTransfer for more information. If an X and Y offset is not specified, the liquid will be aspirated in the center of the well, otherwise, -X/+X values will shift the position left and right, respectively, and -Y/+Y values will shift the position down and up, respectively.",
          ResolutionDescription -> "Automatically set to 0 Millimeter if MagnetizationRack is Model[Item,MagnetizationRack,\"Alpaqua Magnum FLX Enhanced Universal Magnet 96-well Plate Rack\"] and SeptenaryWashAspirationPosition is bottom, otherwise set to 2 Millimeter.",
          NestedIndexMatching -> True,
          Category->"Wash"
        }
      ],
			{
				OptionName->SeptenaryWashCollectionContainer,
				Default->Automatic,
				Description->"The container(s) for collecting the aspirated sample(s) during the Septenary wash(es) prior to elution. By default, the same container is selected for the repeated septenary washes (i.e. aspirated samples in the repeated septenary washes will be combined) unless different container objects are specified for the septenary washes.",
				ResolutionDescription->"Automatically set to a container plate and its first available position. The container plate is selected by the function PreferredContainer given the volume of SeptenaryWashAspirationVolume for manual preparation, and is set to 2 mL Deep well plate for robotic preparation, if SeptenaryWash is set to True.",
				AllowNull->True,
				Widget -> Alternatives[
					Adder[
						Alternatives[
							"Container" -> Widget[
								Type -> Object,
								Pattern :> ObjectP[{Object[Container], Model[Container]}]
							],
							"Container with Index" -> {
								"Index" -> Widget[
									Type -> Number,
									Pattern :> GreaterEqualP[1, 1]
								],
								"Container" -> Widget[
									Type -> Object,
									Pattern :> ObjectP[Model[Container]],
									PreparedSample -> False,
									PreparedContainer -> False
								]
							},
							"Container with Well" -> {
								"Well" -> Widget[
									Type -> Enumeration,
									Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
									PatternTooltip -> "Enumeration must be any well from A1 to H12."
								],
								"Container" -> Widget[
									Type -> Object,
									Pattern :> ObjectP[Model[Container]],
									PreparedSample -> False,
									PreparedContainer -> False
								]
							},
							"Container with Well and Index" -> {
								"Well" -> Widget[
									Type -> Enumeration,
									Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
									PatternTooltip -> "Enumeration must be any well from A1 to H12."
								],
								"Index and Container"->{
									"Index"->Widget[
										Type->Number,
										Pattern:>GreaterEqualP[1,1]
									],
									"Container"->Widget[
										Type->Object,
										Pattern:>ObjectP[{Model[Container]}],
										PreparedSample->False,
										PreparedContainer->False
									]
								}
							},
							"Automatic or Null" -> Widget[
								Type -> Enumeration,
								Pattern :> Alternatives[Automatic,Null]
							]
						]
					],
					Alternatives[
						"Container" -> Widget[
							Type -> Object,
							Pattern :> ObjectP[{Object[Container], Model[Container]}]
						],
						"Container with Index" -> {
							"Index" -> Widget[
								Type -> Number,
								Pattern :> GreaterEqualP[1, 1]
							],
							"Container" -> Widget[
								Type -> Object,
								Pattern :> ObjectP[Model[Container]],
								PreparedSample -> False,
								PreparedContainer -> False
							]
						},
						"Container with Well" -> {
							"Well" -> Widget[
								Type -> Enumeration,
								Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
								PatternTooltip -> "Enumeration must be any well from A1 to H12."
							],
							"Container" -> Widget[
								Type -> Object,
								Pattern :> ObjectP[Model[Container]],
								PreparedSample -> False,
								PreparedContainer -> False
							]
						},
						"Container with Well and Index" -> {
							"Well" -> Widget[
								Type -> Enumeration,
								Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
								PatternTooltip -> "Enumeration must be any well from A1 to H12."
							],
							"Index and Container"->{
								"Index"->Widget[
									Type->Number,
									Pattern:>GreaterEqualP[1,1]
								],
								"Container"->Widget[
									Type->Object,
									Pattern:>ObjectP[{Model[Container]}],
									PreparedSample->False,
									PreparedContainer->False
								]
							}
						}
					]
				],
				Category->"Wash",
				NestedIndexMatching->True
			},
			{
				OptionName->SeptenaryWashCollectionStorageCondition,
				Default->Automatic,
				Description->"The non-default condition under which the aspirated samples during the septenary wash prior to elution are stored after the protocol is completed.",
				ResolutionDescription->"Automatically set to Refrigerator if SeptenaryWash is set to True.",
				AllowNull->True,
				Widget->Alternatives[
					"Condition"->Widget[
						Type->Enumeration,Pattern:>SampleStorageTypeP|Disposal
					],
					"Objects"->Widget[
						Type->Object,
						Pattern:>ObjectP[Model[StorageCondition]],
						OpenPaths->{
							{Object[Catalog,"Root"],
								"Storage Conditions"}
						}
					]
				],
				Category->"Post Experiment",
				NestedIndexMatching->True
			},
			{
				OptionName->NumberOfSeptenaryWashes,
				Default->Automatic,
				Description->"The number of times the magnetic beads are washed by adding SeptenaryWashBuffer, mixing, magnetization, and aspirating solution prior to elution.",
				ResolutionDescription->"Automatically set to 1 if SeptenaryWash is set to True.",
				AllowNull->True,
				Widget->Widget[Type->Number,Pattern:>RangeP[1,20,1]],
				Category->"Wash",
				NestedIndexMatching->True
			},
			{
				OptionName->SeptenaryWashAirDry,
				Default->Automatic,
				Description->"Indicates if the magnetic beads are exposed to open air to evaporate the remaining SeptenaryWashBuffer following the final septenary wash prior to elution.",
				ResolutionDescription->"Automatically set to False if SeptenaryWash is set to True.",
				AllowNull->True,
				Widget->Widget[Type->Enumeration,Pattern:>BooleanP],
				Category->"Wash",
				NestedIndexMatching->True
			},
			{
				OptionName->SeptenaryWashAirDryTime,
				Default->Automatic,
				Description->"The duration that the magnetic beads are exposed to open air to evaporate the remaining SeptenaryWashBuffer following the final septenary wash prior to elution.",
				ResolutionDescription->"Automatically set to 1 Minute if SeptenaryWashAirDry is set to True.",
				AllowNull->True,
				Widget->Widget[Type->Quantity,Pattern:>RangeP[0 Second,$MaxExperimentTime],Units->{Second,{Second,Minute,Hour}}],
				Category->"Wash",
				NestedIndexMatching->True
			},

			(*===Elution===*)
			{
				OptionName->Elution,
				Default->Automatic,
				Description->"Indicates if the magnetic beads are rinsed in a different buffer condition in order to release the components bound to the magnetic beads.",
				ResolutionDescription->"Automatically set to True if other Elution options are set or if SelectionStrategy->Positive, and is set to False otherwise.",
				AllowNull->False,
				Widget->Widget[Type->Enumeration,Pattern:>BooleanP],
				Category->"Elution",
				NestedIndexMatching->True
			},
			{
				OptionName->ElutionBuffer,
				Default->Automatic,
				Description->"The solution used to rinse the magnetic beads, providing a buffer condition in order to release the components bound to the magnetic beads.",
				ResolutionDescription->"Automatically set to Model[Sample,\"Milli-Q water\"] if Elution is set to True.",
				AllowNull->True,
				Widget->Widget[
					Type->Object,
					Pattern:>ObjectP[{Model[Sample],Object[Sample]}],
					OpenPaths -> {
						{Object[Catalog, "Root"], "Materials", "Magnetic Bead Separation", "Elution Solutions"},
						{Object[Catalog, "Root"], "Materials", "Reagents", "Buffers"}
					}
				],
				Category->"Elution",
				NestedIndexMatching->True
			},
			{
				OptionName->ElutionBufferVolume,
				Default->Automatic,
				Description->"The amount of ElutionBuffer that is added to the magnetic beads for each elution.",
				ResolutionDescription->"Automatically set to 1/10 of the Volume if Elution is set to True.",
				AllowNull->True,
				Widget->Widget[Type->Quantity,Pattern:>RangeP[1 Microliter,50 Milliliter],Units->{Microliter,{Microliter,Milliliter}}],
				Category->"Elution",
				NestedIndexMatching->True
			},
			{
				OptionName->ElutionMix,
				Default->Automatic,
				Description->"Indicates if the solution is mixed following combination of ElutionBuffer and the magnetic beads during each elution.",
				ResolutionDescription->"Automatically set to True if Elution is set to True and ElutionMixType is not set to Null.",
				AllowNull->True,
				Widget->Widget[Type->Enumeration,Pattern:>BooleanP],
				Category->"Elution",
				NestedIndexMatching->True
			},
			ModifyOptions[ExperimentMix,
				{
					OptionName -> MixType,
					ModifiedOptionName -> ElutionMixType,
					Default->Automatic,
					Description -> "The style of motion used to mix the suspension following the addition of the ElutionBuffer to the magnetic beads. Options include Roll, Vortex, Sonicate, Pipette, Invert, Stir, Shake, Homogenize, Swirl, Disrupt, Nutate.",
					ResolutionDescription -> "Automatically set based on the volume-to-mix (i.e. the volume of the combined ElutionBuffer and magnetic beads) and the ElutionMix options. Specifically, ElutionMixType is automatically set to Pipette when the volume-to-mix is greater than 20 Microliter and none of ElutionMixRate, ElutionMixTemperature, and ElutionMixTime is specified to non-default values; otherwise, ElutionMixType is automatically set to Vortex when Preparation is Manual, ElutionMixTemperature is Automatic or Ambient, and ElutionMixRate is specified to be greater than 600 RPM; otherwise, ElutionMixType is automatically set to Shake.",
					NestedIndexMatching -> True,
					Category -> "Elution",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> Time,
					ModifiedOptionName -> ElutionMixTime,
					Default->Automatic,
					Description -> "The duration during which the combined ElutionBuffer and magnetic beads are mixed.",
					ResolutionDescription -> "If ElutionMixType is among Disrupt, Nutate, Shake, Vortex, Roll, Stir, Homogenize, and Sonicate, ElutionMixTime is automatically set to 5 Minute for robotic preparation, and is set to 15 Minute for manual preparation.",
					NestedIndexMatching -> True,
					Category -> "Elution",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> MixRate,
					ModifiedOptionName -> ElutionMixRate,
					Default->Automatic,
					Description -> "The frequency of rotation used to mix the combined ElutionBuffer and magnetic beads.",
					ResolutionDescription -> "Automatically set to 300 RPM if ElutionMixType is Shake or Stir, to 1000 RPM if ElutionMixType is Vortex or Disrupt, and to 30 RPM if ElutionMixType is Nutate or Roll.",
					NestedIndexMatching -> True,
					Category -> "Elution",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> NumberOfMixes,
					ModifiedOptionName -> NumberOfElutionMixes,
					Default->Automatic,
					Description -> "The number of times that the combined ElutionBuffer and magnetic beads are mixed if ElutionMixType is Pipette or Invert.",
					ResolutionDescription -> "Automatically set to 20 if ElutionMixType is Pipette, Swirl or Invert.",
					NestedIndexMatching -> True,
					Category -> "Elution",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> MixVolume,
					ModifiedOptionName -> ElutionMixVolume,
					Default->Automatic,
					Description ->"The volume of the combined ElutionBuffer and magnetic beads that is pipetted up and down in order to mix, if ElutionMixType->Pipette.",
					ResolutionDescription -> "For robotic preparation, ElutionMixVolume is automatically set to 970 Microliter if 0.8*volume-to-mix (i.e.volume-to-mix is the volume of the combined ElutionBuffer and magnetic beads) is greater than 970 Microliter, and otherwise is set to the greater of 10 Microliter and 0.8*volume-to-mix. For manual preparation, ElutionMixVolume is automatically set to the lesser of 50 Milliliter and 0.8*volume-to-mix.",
					NestedIndexMatching -> True,
					Category -> "Elution",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> Temperature,
					ModifiedOptionName -> ElutionMixTemperature,
					Default->Automatic,
					Description ->"The temperature of the device that is used to mix/incubate the combined ElutionBuffer and magnetic beads.",
					ResolutionDescription->"Automatically set to Ambient if ElutionMix is set to True and ElutionMixType is not Null.",
					NestedIndexMatching -> True,
					Category -> "Elution",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> TipType,
					ModifiedOptionName -> ElutionMixTipType,
					Default->Automatic,
					Description -> "The type of pipette tips used to mix the combined ElutionBuffer and magnetic beads. Options include Normal, Barrier, WideBore, GelLoading, Aspirator. This option can only be set if ElutionMixType->Pipette.",
					ResolutionDescription -> "Automatically set to WideBore for robotic preparation. For manual preparation, ElutionMixTipType is automatically set to WideBore if ElutionMixVolume is less or equal to 970 Microliter, to Normal if ElutionMixVolume is larger than 970 Microliter but less or equal to 5 Milliliter, and to Barrier if ElutionMixVolume is larger than 5 Milliliter.",
					NestedIndexMatching -> True,
					Category -> "Elution",
					IndexMatchingOptions -> {}
				}
			],
			ModifyOptions[ExperimentMix,
				{
					OptionName -> TipMaterial,
					ModifiedOptionName -> ElutionMixTipMaterial,
					Default->Automatic,
					Description -> "The material of the pipette tips used to aspirate and dispense the requested volume during the ElutionMix. This option can only be set if ElutionMixType->Pipette.",
					ResolutionDescription -> "Automatically set to Polypropylene if ElutionMixVolume is less or equal to 5 Milliliter, and to Glass if ElutionMixVolume is larger than 5 Milliliter.",
					NestedIndexMatching -> True,
					Category -> "Elution",
					IndexMatchingOptions -> {}
				}
			],
			{
				OptionName->ElutionMagnetizationTime,
				Default->Automatic,
				Description->"The duration of magnetizing the magnetic beads after ElutionMixTime has elapsed, in order to pull the magnetic beads to the perimeter of the container by applying a magnetic force, thus enables maximal aspiration of the ElutionBuffer containing sample components released from the magnetic beads.",
				ResolutionDescription->"Automatically set to 5 minutes if Elution is set to True.",
				AllowNull->True,
				Widget->Widget[Type->Quantity,Pattern:>RangeP[0 Second,$MaxExperimentTime],Units->{Second,{Second,Minute,Hour}}],
				Category->"Elution",
				NestedIndexMatching->True
			},
			{
				OptionName->ElutionAspirationVolume,
				Default->Automatic,
				Description->"The amount of solution to aspirate out while the magnetic beads are magnetized and gathered to the side during each elution.",
				ResolutionDescription->"Automatically set to All for manual preparation, and set to ElutionBufferVolume for robotic preparation, if Elution is set to True. Set to Null if Elution is set to False.",
				AllowNull->True,
				Widget->Alternatives[
					"All"->Widget[Type->Enumeration,Pattern:>Alternatives[All]],
					"Volume"->Widget[Type->Quantity,Pattern:>RangeP[1 Microliter,50 Milliliter],Units->{Microliter,{Microliter,Milliliter}}]
				],
				Category->"Elution",
				NestedIndexMatching->True
			},
      ModifyOptions[TransferRoboticTipOptions,
        {
          OptionName -> AspirationPosition,
          ModifiedOptionName -> ElutionAspirationPosition,
          Default->Automatic,
          AllowNull ->True,
          Widget -> Widget[
            Type -> Enumeration,
            Pattern :> MagneticBeadSeparationPipettingPositionP
          ],
          Description -> "The location from which the solution is aspirated after ElutionMagnetizationTime. Top will aspirate ElutionAspirationPositionOffset below the Top of the container, Bottom will aspirate ElutionAspirationPositionOffset above the Bottom of the container, and LiquidLevel will aspirate ElutionAspirationPositionOffset below the liquid level of the sample in the container",
          ResolutionDescription -> "Automatically set to Bottom if Preparation->Robotic and Elution is True.",
          NestedIndexMatching -> True,
          Category -> "Elution"
        }
      ],
      ModifyOptions[TransferRoboticTipOptions,
        {
          OptionName -> AspirationPositionOffset,
          ModifiedOptionName -> ElutionAspirationPositionOffset,
          Default->Automatic,
          AllowNull ->True,
          Description -> "The distance from the center of the well that the solution is aspirated after ElutionMagnetizationTime. The Z Offset is based on the ElutionAspirationPosition option -- measured as the height below the top of the well (Top), the height above the bottom of the well (Bottom), or the height below the detected liquid level (LiquidLevel). Please refer to the AspirationPosition diagram in the help file of ExperimentTransfer for more information. If an X and Y offset is not specified, the liquid will be aspirated in the center of the well, otherwise, -X/+X values will shift the position left and right, respectively, and -Y/+Y values will shift the position down and up, respectively.",
          ResolutionDescription -> "Automatically set to 0 Millimeter if MagnetizationRack is Model[Item,MagnetizationRack,\"Alpaqua Magnum FLX Enhanced Universal Magnet 96-well Plate Rack\"] and ElutionAspirationPosition is bottom, otherwise set to 2 Millimeter.",
          NestedIndexMatching -> True,
          Category -> "Elution"
        }
      ],
			{
				OptionName->ElutionCollectionContainer,
				Default->Automatic,
				Description->"The container(s) for collecting the aspirated sample(s) during elution(s). By default, the same container is selected for the repeated elutions (i.e. aspirated samples in the repeated elutions will be combined) unless different container objects are specified for the elutions.",
				ResolutionDescription->"Automatically set to a container plate and its first available position. The container plate is selected by the function PreferredContainer given the volume of ElutionAspirationVolume for manual preparation, and is set to 2 mL Deep well plate for robotic preparation, if Elution is set to True.",
				AllowNull->True,
				Widget -> Alternatives[
					Adder[
						Alternatives[
							"Container" -> Widget[
								Type -> Object,
								Pattern :> ObjectP[{Object[Container], Model[Container]}]
							],
							"Container with Index" -> {
								"Index" -> Widget[
									Type -> Number,
									Pattern :> GreaterEqualP[1, 1]
								],
								"Container" -> Widget[
									Type -> Object,
									Pattern :> ObjectP[Model[Container]],
									PreparedSample -> False,
									PreparedContainer -> False
								]
							},
							"Container with Well" -> {
								"Well" -> Widget[
									Type -> Enumeration,
									Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
									PatternTooltip -> "Enumeration must be any well from A1 to H12."
								],
								"Container" -> Widget[
									Type -> Object,
									Pattern :> ObjectP[Model[Container]],
									PreparedSample -> False,
									PreparedContainer -> False
								]
							},
							"Container with Well and Index" -> {
								"Well" -> Widget[
									Type -> Enumeration,
									Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
									PatternTooltip -> "Enumeration must be any well from A1 to H12."
								],
								"Index and Container"->{
									"Index"->Widget[
										Type->Number,
										Pattern:>GreaterEqualP[1,1]
									],
									"Container"->Widget[
										Type->Object,
										Pattern:>ObjectP[{Model[Container]}],
										PreparedSample->False,
										PreparedContainer->False
									]
								}
							},
							"Automatic or Null" -> Widget[
								Type -> Enumeration,
								Pattern :> Alternatives[Automatic,Null]
							]
						]
					],
					Alternatives[
						"Container" -> Widget[
							Type -> Object,
							Pattern :> ObjectP[{Object[Container], Model[Container]}]
						],
						"Container with Index" -> {
							"Index" -> Widget[
								Type -> Number,
								Pattern :> GreaterEqualP[1, 1]
							],
							"Container" -> Widget[
								Type -> Object,
								Pattern :> ObjectP[Model[Container]],
								PreparedSample -> False,
								PreparedContainer -> False
							]
						},
						"Container with Well" -> {
							"Well" -> Widget[
								Type -> Enumeration,
								Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
								PatternTooltip -> "Enumeration must be any well from A1 to H12."
							],
							"Container" -> Widget[
								Type -> Object,
								Pattern :> ObjectP[Model[Container]],
								PreparedSample -> False,
								PreparedContainer -> False
							]
						},
						"Container with Well and Index" -> {
							"Well" -> Widget[
								Type -> Enumeration,
								Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
								PatternTooltip -> "Enumeration must be any well from A1 to H12."
							],
							"Index and Container"->{
								"Index"->Widget[
									Type->Number,
									Pattern:>GreaterEqualP[1,1]
								],
								"Container"->Widget[
									Type->Object,
									Pattern:>ObjectP[{Model[Container]}],
									PreparedSample->False,
									PreparedContainer->False
								]
							}
						}
					]
				],
				Category->"Elution",
				NestedIndexMatching->True
			},
			{
				OptionName->ElutionCollectionStorageCondition,
				Default->Automatic,
				Description->"The non-default condition under which the aspirated samples during elution are stored after the protocol is completed.",
				ResolutionDescription->"Automatically set to Refrigerator if Elution is set to True.",
				AllowNull->True,
				Widget->Alternatives[
					"Condition"->Widget[
						Type->Enumeration,Pattern:>SampleStorageTypeP|Disposal
					],
					"Objects"->Widget[
						Type->Object,
						Pattern:>ObjectP[Model[StorageCondition]],
						OpenPaths->{
							{Object[Catalog,"Root"],
								"Storage Conditions"}
						}
					]
				],
				Category->"Post Experiment",
				NestedIndexMatching->True
			},
			{
				OptionName->NumberOfElutions,
				Default->Automatic,
				Description->"The number of times the bound components on the magnetic beads are eluted by adding ElutionBuffer, mixing, magnetization, and aspirating solution.",
				ResolutionDescription->"Automatically set to 1 if Elution is set to True.",
				AllowNull->True,
				Widget->Widget[Type->Number,Pattern:>RangeP[1,20,1]],
				Category->"Elution",
				NestedIndexMatching->True
			},

			(*---HIDDEN OPTIONS to propogate information only---*)

			(*===assay container options===*)
			{
				OptionName->AssayContainer,
				Default->Automatic,
				Description->"The container(s) that holds the samples during magnetization steps of the experiment.",
				ResolutionDescription->"Automatically set to an Object[Container] according to Table 3.2.",
				AllowNull->True,
				Widget->Widget[Type->Object,Pattern:>ObjectP[{Model[Container],Object[Container]}]],
				Category->"Hidden",
				NestedIndexMatching->True
			},

			(*===label options===*)
			{
				OptionName->SampleLabel,
				Default->Automatic,
				AllowNull->True,
				NestedIndexMatching->True,
				Widget->Widget[Type->String,Pattern:>_String,Size->Line],
				Description->"The user defined word or phrase used to identify the sample that is subject to magnetic bead separation and is used for identification elsewhere in sample preparation.",
				ResolutionDescription->"Automatically set to the previously specified label if the same sample has already been labeled in an upstream unit operation within the same sample preparation protocol. Otherwise, set to \"MBS Sample #\".",
				Category->"General",
				UnitOperation->True
			},
			{
				OptionName->SampleContainerLabel,
				Default->Automatic,
				AllowNull->True,
				NestedIndexMatching->True,
				Widget->Widget[Type->String,Pattern:>_String,Size->Line],
				Description->"The user defined word or phrase used to identify the sample's container (i.e. plate or tube) that are being used in the experiment, and is used for identification elsewhere in sample preparation.",
				ResolutionDescription->"Automatically set to the previously specified label if the same container has already been labeled in an upstream unit operation within the same sample preparation protocol. Otherwise, set to \"MBS SampleContainer #\".",
				Category->"General",
				UnitOperation->True
			},
			{
				OptionName->SampleOutLabel,
				Default->Automatic,
				AllowNull->False,
				Widget->Alternatives[
					Adder[
						Alternatives[
							Widget[Type->String,Pattern:>_String,Size->Line],
							Widget[Type->Enumeration,Pattern:>Alternatives[Automatic,Null]]
						]
					],
					Widget[Type->String,Pattern:>_String,Size->Line]
				],
				Description->"The user defined word or phrase used to identify the collected sample during loading or elution, depending on the selection strategy,  and is used for identification elsewhere in sample preparation. The SampleOutLabel is used to identify the sample collected during elution if SelectionStrategy->Positive, or to identify the sample collected during loading if SelectionStrategy->Negative.",
				ResolutionDescription->"Automatically set to the previously specified label if the same sample has already been labeled in an upstream unit operation within the same sample preparation protocol. Otherwise, set to \"MBS Sample Out #\".",
				Category->"General",
				NestedIndexMatching->True,
				UnitOperation->True
			},
			{
				OptionName->ContainerOutLabel,
				Default->Automatic,
				AllowNull->False,
				Widget->Alternatives[
					Adder[
						Alternatives[
							Widget[Type->String,Pattern:>_String,Size->Line],
							Widget[Type->Enumeration,Pattern:>Alternatives[Automatic,Null]]
						]
					],
					Widget[Type->String,Pattern:>_String,Size->Line]
				],
				Description->"The user defined word or phrase used to identify the container of the output sample that will be created in this experiment, and is used for identification elsewhere in sample preparation.",
				ResolutionDescription->"Automatically set to the previously specified label if the same container has already been labeled in an upstream unit operation within the same sample preparation protocol. When ContainerOutLabel is fully Automatic, ContainerOutLabel is set to ElutionCollectionContainerLabel if SelectionStrategy->Positive, and is set to LoadingCollectionContainerLabel if SelectionStrategy->Negative. Otherwise, the unspecified member ContainerOutLabel is set to \"MBS Container Out #\".",
				Category->"General",
				NestedIndexMatching->True,
				UnitOperation->True
			},
			{
				OptionName->PreWashCollectionContainerLabel,
				Default->Automatic,
				AllowNull->True,
				Widget->Alternatives[
					Adder[
						Alternatives[
							Widget[Type->String,Pattern:>_String,Size->Line],
							Widget[Type->Enumeration,Pattern:>Alternatives[Automatic,Null]]
						]
					],
					Widget[Type->String,Pattern:>_String,Size->Line]
				],
				Description->"The user defined word or phrase used to identify the container for collecting the aspirated sample during prewash.",
				ResolutionDescription->"Automatically set to the previously specified label if the same container has already been labeled in an upstream unit operation within the same sample preparation protocol. Otherwise, set to \"MBS collection container #\".",
				Category->"General",
				NestedIndexMatching->True,
				UnitOperation->True
			},
			{
				OptionName->EquilibrationCollectionContainerLabel,
				Default->Automatic,
				AllowNull->True,
				Widget->Alternatives[
					Adder[
						Alternatives[
							Widget[Type->String,Pattern:>_String,Size->Line],
							Widget[Type->Enumeration,Pattern:>Alternatives[Automatic,Null]]
						]
					],
					Widget[Type->String,Pattern:>_String,Size->Line]
				],
				Description->"The user defined word or phrase used to identify the container for collecting the aspirated sample during equilibration.",
				ResolutionDescription->"Automatically set to the previously specified label if the same container has already been labeled in an upstream unit operation within the same sample preparation protocol. Otherwise, set to \"MBS collection container #\".",
				Category->"General",
				NestedIndexMatching->True,
				UnitOperation->True
			},
			{
				OptionName->LoadingCollectionContainerLabel,
				Default->Automatic,
				AllowNull->True,
				NestedIndexMatching->True,
				Widget->Alternatives[
					Adder[
						Alternatives[
							Widget[Type->String,Pattern:>_String,Size->Line],
							Widget[Type->Enumeration,Pattern:>Alternatives[Automatic,Null]]
						]
					],
					Widget[Type->String,Pattern:>_String,Size->Line]
				],
				Description->"The user defined word or phrase used to identify the container for collecting the aspirated sample during loading.",
				ResolutionDescription->"Automatically set to the previously specified label if the same container has already been labeled in an upstream unit operation within the same sample preparation protocol. Otherwise, set to \"MBS collection container #\".",
				Category->"General",
				UnitOperation->True
			},
			{
				OptionName->WashCollectionContainerLabel,
				Default->Automatic,
				AllowNull->True,
				Widget->Alternatives[
					Adder[
						Alternatives[
							Widget[Type->String,Pattern:>_String,Size->Line],
							Widget[Type->Enumeration,Pattern:>Alternatives[Automatic,Null]]
						]
					],
					Widget[Type->String,Pattern:>_String,Size->Line]
				],
				Description->"The user defined word or phrase used to identify the container used for collecting the aspirated sample(s) during the wash(es) prior to elution or optional SecondaryWash.",
				ResolutionDescription->"Automatically set to the previously specified label if the same container has already been labeled in an upstream unit operation within the same sample preparation protocol. Otherwise, set to \"MBS collection container #\".",
				Category->"General",
				NestedIndexMatching->True,
				UnitOperation->True
			},
			{
				OptionName->SecondaryWashCollectionContainerLabel,
				Default->Automatic,
				AllowNull->True,
				Widget->Alternatives[
					Adder[
						Alternatives[
							Widget[Type->String,Pattern:>_String,Size->Line],
							Widget[Type->Enumeration,Pattern:>Alternatives[Automatic,Null]]
						]
					],
					Widget[Type->String,Pattern:>_String,Size->Line]
				],
				Description->"The user defined word or phrase used to identify the container used for collecting the aspirated sample(s) during the secondary wash(es) prior to elution or optional TertiaryWash.",
				ResolutionDescription->"Automatically set to the previously specified label if the same container has already been labeled in an upstream unit operation within the same sample preparation protocol. Otherwise, set to \"MBS collection container #\".",
				Category->"General",
				NestedIndexMatching->True,
				UnitOperation->True
			},
			{
				OptionName->TertiaryWashCollectionContainerLabel,
				Default->Automatic,
				AllowNull->True,
				Widget->Alternatives[
					Adder[
						Alternatives[
							Widget[Type->String,Pattern:>_String,Size->Line],
							Widget[Type->Enumeration,Pattern:>Alternatives[Automatic,Null]]
						]
					],
					Widget[Type->String,Pattern:>_String,Size->Line]
				],
				Description->"The user defined word or phrase used to identify the container used for collecting the aspirated sample(s) during the tertiary wash(es) prior to elution or optional QuaternaryWash.",
				ResolutionDescription->"Automatically set to the previously specified label if the same container has already been labeled in an upstream unit operation within the same sample preparation protocol. Otherwise, set to \"MBS collection container #\".",
				Category->"General",
				NestedIndexMatching->True,
				UnitOperation->True
			},
			{
				OptionName->QuaternaryWashCollectionContainerLabel,
				Default->Automatic,
				AllowNull->True,
				Widget->Alternatives[
					Adder[
						Alternatives[
							Widget[Type->String,Pattern:>_String,Size->Line],
							Widget[Type->Enumeration,Pattern:>Alternatives[Automatic,Null]]
						]
					],
					Widget[Type->String,Pattern:>_String,Size->Line]
				],
				Description->"The user defined word or phrase used to identify the container used for collecting the aspirated sample(s) during the quaternary wash(es) prior to elution or optional QuinaryWash.",
				ResolutionDescription->"Automatically set to the previously specified label if the same container has already been labeled in an upstream unit operation within the same sample preparation protocol. Otherwise, set to \"MBS collection container #\".",
				Category->"General",
				NestedIndexMatching->True,
				UnitOperation->True
			},
			{
				OptionName->QuinaryWashCollectionContainerLabel,
				Default->Automatic,
				AllowNull->True,
				Widget->Alternatives[
					Adder[
						Alternatives[
							Widget[Type->String,Pattern:>_String,Size->Line],
							Widget[Type->Enumeration,Pattern:>Alternatives[Automatic,Null]]
						]
					],
					Widget[Type->String,Pattern:>_String,Size->Line]
				],
				Description->"The user defined word or phrase used to identify the container used for collecting the aspirated sample(s) during the quainary wash(es) prior to elution or optional SenaryWash.",
				ResolutionDescription->"Automatically set to the previously specified label if the same container has already been labeled in an upstream unit operation within the same sample preparation protocol. Otherwise, set to \"MBS collection container #\".",
				Category->"General",
				NestedIndexMatching->True,
				UnitOperation->True
			},
			{
				OptionName->SenaryWashCollectionContainerLabel,
				Default->Automatic,
				AllowNull->True,
				Widget->Alternatives[
					Adder[
						Alternatives[
							Widget[Type->String,Pattern:>_String,Size->Line],
							Widget[Type->Enumeration,Pattern:>Alternatives[Automatic,Null]]
						]
					],
					Widget[Type->String,Pattern:>_String,Size->Line]
				],
				Description->"The user defined word or phrase used to identify the container used for collecting the aspirated sample(s) during the senary wash(es) prior to elution or optional SeptenaryWash.",
				ResolutionDescription->"Automatically set to the previously specified label if the same container has already been labeled in an upstream unit operation within the same sample preparation protocol. Otherwise, set to \"MBS collection container #\".",
				Category->"General",
				NestedIndexMatching->True,
				UnitOperation->True
			},
			{
				OptionName->SeptenaryWashCollectionContainerLabel,
				Default->Automatic,
				AllowNull->True,
				Widget->Alternatives[
					Adder[
						Alternatives[
							Widget[Type->String,Pattern:>_String,Size->Line],
							Widget[Type->Enumeration,Pattern:>Alternatives[Automatic,Null]]
						]
					],
					Widget[Type->String,Pattern:>_String,Size->Line]
				],
				Description->"The user defined word or phrase used to identify the container used for collecting the aspirated sample(s) during the septenary wash(es) prior to elution.",
				ResolutionDescription->"Automatically set to the previously specified label if the same container has already been labeled in an upstream unit operation within the same sample preparation protocol. Otherwise, set to \"MBS collection container #\".",
				Category->"General",
				NestedIndexMatching->True,
				UnitOperation->True
			},
			{
				OptionName->ElutionCollectionContainerLabel,
				Default->Automatic,
				AllowNull->True,
				Widget->Alternatives[
					Adder[
						Alternatives[
							Widget[Type->String,Pattern:>_String,Size->Line],
							Widget[Type->Enumeration,Pattern:>Alternatives[Automatic,Null]]
						]
					],
					Widget[Type->String,Pattern:>_String,Size->Line]
				],
				Description->"The user defined word or phrase used to identify the container used for collecting the aspirated sample(s) during elution(s).",
				ResolutionDescription->"Automatically set to the previously specified label if the same container has already been labeled in an upstream unit operation within the same sample preparation protocol. Otherwise, set to \"MBS collection container #\".",
				Category->"General",
				NestedIndexMatching->True,
				UnitOperation->True
			},
			(*===CollectionContainer wells and indices options===*)
			(* these are hidden options used to propagate information only *)
			{
				OptionName->PreWashDestinationWell,
				Default->Automatic,
				Description->"The destination well in the PreWashCollectionContainer that the collected used PreWashBuffer goes to.",
				AllowNull->True,
				Widget->Alternatives[
					Adder[
						Alternatives[
							Widget[
								Type -> Enumeration,
								Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
								PatternTooltip -> "Enumeration must be any well from A1 to H12."
							],
							Widget[Type->Enumeration,Pattern:>Alternatives[Automatic,Null]]
						]
					],
					Widget[
						Type -> Enumeration,
						Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
						PatternTooltip -> "Enumeration must be any well from A1 to H12."
					]
				],
				Category->"Hidden",
				NestedIndexMatching->True
			},
			{
				OptionName->PreWashCollectionContainerIndex,
				Default->Automatic,
				Description->"The index of the PreWashCollectionContainer that the collected used PreWashBuffer goes to.",
				AllowNull->True,
				Widget->Alternatives[
					Adder[
						Alternatives[
							Widget[Type -> Number, Pattern :> GreaterEqualP[1, 1]],
							Widget[Type->Enumeration,Pattern:>Alternatives[Automatic,Null]]
						]
					],
					Widget[Type -> Number, Pattern :> GreaterEqualP[1, 1]]
				],
				Category->"Hidden",
				NestedIndexMatching->True
			},
			{
				OptionName->EquilibrationDestinationWell,
				Default->Automatic,
				Description->"The destination well in the EquilibrationCollectionContainer that the collected used EquilibrationBuffer goes to.",
				AllowNull->True,
				Widget->Alternatives[
					Adder[
						Alternatives[
							Widget[
								Type -> Enumeration,
								Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
								PatternTooltip -> "Enumeration must be any well from A1 to H12."
							],
							Widget[Type->Enumeration,Pattern:>Alternatives[Automatic,Null]]
						]
					],
					Widget[
						Type -> Enumeration,
						Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
						PatternTooltip -> "Enumeration must be any well from A1 to H12."
					]
				],
				Category->"Hidden",
				NestedIndexMatching->True
			},
			{
				OptionName->EquilibrationCollectionContainerIndex,
				Default->Automatic,
				Description->"The index of the EquilibrationCollectionContainer that the collected used EquilibrationBuffer goes to.",
				AllowNull->True,
				Widget->Alternatives[
					Adder[
						Alternatives[
							Widget[Type -> Number, Pattern :> GreaterEqualP[1, 1]],
							Widget[Type->Enumeration,Pattern:>Alternatives[Automatic,Null]]
						]
					],
					Widget[Type -> Number, Pattern :> GreaterEqualP[1, 1]]
				],
				Category->"Hidden",
				NestedIndexMatching->True
			},
			{
				OptionName->LoadingDestinationWell,
				Default->Automatic,
				Description->"The destination well in the LoadingCollectionContainer that the collected used sample goes to.",
				AllowNull->True,
				Widget->Alternatives[
					Adder[
						Alternatives[
							Widget[
								Type -> Enumeration,
								Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
								PatternTooltip -> "Enumeration must be any well from A1 to H12."
							],
							Widget[Type->Enumeration,Pattern:>Alternatives[Automatic,Null]]
						]
					],
					Widget[
						Type -> Enumeration,
						Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
						PatternTooltip -> "Enumeration must be any well from A1 to H12."
					]
				],
				Category->"Hidden",
				NestedIndexMatching->True
			},
			{
				OptionName->LoadingCollectionContainerIndex,
				Default->Automatic,
				Description->"The index of the LoadingCollectionContainer that the collected used sample goes to.",
				AllowNull->True,
				Widget->Alternatives[
					Adder[
						Alternatives[
							Widget[Type -> Number, Pattern :> GreaterEqualP[1, 1]],
							Widget[Type->Enumeration,Pattern:>Alternatives[Automatic,Null]]
						]
					],
					Widget[Type -> Number, Pattern :> GreaterEqualP[1, 1]]
				],
				Category->"Hidden",
				NestedIndexMatching->True
			},
			{
				OptionName->WashDestinationWell,
				Default->Automatic,
				Description->"The destination well in the WashCollectionContainer that the collected used WashBuffer goes to.",
				AllowNull->True,
				Widget->Alternatives[
					Adder[
						Alternatives[
							Widget[
								Type -> Enumeration,
								Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
								PatternTooltip -> "Enumeration must be any well from A1 to H12."
							],
							Widget[Type->Enumeration,Pattern:>Alternatives[Automatic,Null]]
						]
					],
					Widget[
						Type -> Enumeration,
						Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
						PatternTooltip -> "Enumeration must be any well from A1 to H12."
					]
				],
				Category->"Hidden",
				NestedIndexMatching->True
			},
			{
				OptionName->WashCollectionContainerIndex,
				Default->Automatic,
				Description->"The index of the WashCollectionContainer that the collected used WashBuffer goes to.",
				AllowNull->True,
				Widget->Alternatives[
					Adder[
						Alternatives[
							Widget[Type -> Number, Pattern :> GreaterEqualP[1, 1]],
							Widget[Type->Enumeration,Pattern:>Alternatives[Automatic,Null]]
						]
					],
					Widget[Type -> Number, Pattern :> GreaterEqualP[1, 1]]
				],
				Category->"Hidden",
				NestedIndexMatching->True
			},
			{
				OptionName->SecondaryWashDestinationWell,
				Default->Automatic,
				Description->"The destination well in the SecondaryWashCollectionContainer that the collected used SecondaryWashBuffer goes to.",
				AllowNull->True,
				Widget->Alternatives[
					Adder[
						Alternatives[
							Widget[
								Type -> Enumeration,
								Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
								PatternTooltip -> "Enumeration must be any well from A1 to H12."
							],
							Widget[Type->Enumeration,Pattern:>Alternatives[Automatic,Null]]
						]
					],
					Widget[
						Type -> Enumeration,
						Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
						PatternTooltip -> "Enumeration must be any well from A1 to H12."
					]
				],
				Category->"Hidden",
				NestedIndexMatching->True
			},
			{
				OptionName->SecondaryWashCollectionContainerIndex,
				Default->Automatic,
				Description->"The index of the SecondaryWashCollectionContainer that the collected used SecondaryWashBuffer goes to.",
				AllowNull->True,
				Widget->Alternatives[
					Adder[
						Alternatives[
							Widget[Type -> Number, Pattern :> GreaterEqualP[1, 1]],
							Widget[Type->Enumeration,Pattern:>Alternatives[Automatic,Null]]
						]
					],
					Widget[Type -> Number, Pattern :> GreaterEqualP[1, 1]]
				],
				Category->"Hidden",
				NestedIndexMatching->True
			},
			{
				OptionName->TertiaryWashDestinationWell,
				Default->Automatic,
				Description->"The destination well in the TertiaryWashCollectionContainer that the collected used TertiaryWashBuffer goes to.",
				AllowNull->True,
				Widget->Alternatives[
					Adder[
						Alternatives[
							Widget[
								Type -> Enumeration,
								Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
								PatternTooltip -> "Enumeration must be any well from A1 to H12."
							],
							Widget[Type->Enumeration,Pattern:>Alternatives[Automatic,Null]]
						]
					],
					Widget[
						Type -> Enumeration,
						Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
						PatternTooltip -> "Enumeration must be any well from A1 to H12."
					]
				],
				Category->"Hidden",
				NestedIndexMatching->True
			},
			{
				OptionName->TertiaryWashCollectionContainerIndex,
				Default->Automatic,
				Description->"The index of the TertiaryWashCollectionContainer that the collected used TertiaryWashBuffer goes to.",
				AllowNull->True,
				Widget->Alternatives[
					Adder[
						Alternatives[
							Widget[Type -> Number, Pattern :> GreaterEqualP[1, 1]],
							Widget[Type->Enumeration,Pattern:>Alternatives[Automatic,Null]]
						]
					],
					Widget[Type -> Number, Pattern :> GreaterEqualP[1, 1]]
				],
				Category->"Hidden",
				NestedIndexMatching->True
			},
			{
				OptionName->QuaternaryWashDestinationWell,
				Default->Automatic,
				Description->"The destination well in the QuaternaryWashCollectionContainer that the collected used QuaternaryWashBuffer goes to.",
				AllowNull->True,
				Widget->Alternatives[
					Adder[
						Alternatives[
							Widget[
								Type -> Enumeration,
								Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
								PatternTooltip -> "Enumeration must be any well from A1 to H12."
							],
							Widget[Type->Enumeration,Pattern:>Alternatives[Automatic,Null]]
						]
					],
					Widget[
						Type -> Enumeration,
						Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
						PatternTooltip -> "Enumeration must be any well from A1 to H12."
					]
				],
				Category->"Hidden",
				NestedIndexMatching->True
			},
			{
				OptionName->QuaternaryWashCollectionContainerIndex,
				Default->Automatic,
				Description->"The index of the QuaternaryWashCollectionContainer that the collected used QuaternaryWashBuffer goes to.",
				AllowNull->True,
				Widget->Alternatives[
					Adder[
						Alternatives[
							Widget[Type -> Number, Pattern :> GreaterEqualP[1, 1]],
							Widget[Type->Enumeration,Pattern:>Alternatives[Automatic,Null]]
						]
					],
					Widget[Type -> Number, Pattern :> GreaterEqualP[1, 1]]
				],
				Category->"Hidden",
				NestedIndexMatching->True
			},
			{
				OptionName->QuinaryWashDestinationWell,
				Default->Automatic,
				Description->"The destination well in the QuinaryWashCollectionContainer that the collected used QuinaryWashBuffer goes to.",
				AllowNull->True,
				Widget->Alternatives[
					Adder[
						Alternatives[
							Widget[
								Type -> Enumeration,
								Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
								PatternTooltip -> "Enumeration must be any well from A1 to H12."
							],
							Widget[Type->Enumeration,Pattern:>Alternatives[Automatic,Null]]
						]
					],
					Widget[
						Type -> Enumeration,
						Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
						PatternTooltip -> "Enumeration must be any well from A1 to H12."
					]
				],
				Category->"Hidden",
				NestedIndexMatching->True
			},
			{
				OptionName->QuinaryWashCollectionContainerIndex,
				Default->Automatic,
				Description->"The index of the QuinaryWashCollectionContainer that the collected used QuinaryWashBuffer goes to.",
				AllowNull->True,
				Widget->Alternatives[
					Adder[
						Alternatives[
							Widget[Type -> Number, Pattern :> GreaterEqualP[1, 1]],
							Widget[Type->Enumeration,Pattern:>Alternatives[Automatic,Null]]
						]
					],
					Widget[Type -> Number, Pattern :> GreaterEqualP[1, 1]]
				],
				Category->"Hidden",
				NestedIndexMatching->True
			},
			{
				OptionName->SenaryWashDestinationWell,
				Default->Automatic,
				Description->"The destination well in the SenaryWashCollectionContainer that the collected used SenaryWashBuffer goes to.",
				AllowNull->True,
				Widget->Alternatives[
					Adder[
						Alternatives[
							Widget[
								Type -> Enumeration,
								Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
								PatternTooltip -> "Enumeration must be any well from A1 to H12."
							],
							Widget[Type->Enumeration,Pattern:>Alternatives[Automatic,Null]]
						]
					],
					Widget[
						Type -> Enumeration,
						Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
						PatternTooltip -> "Enumeration must be any well from A1 to H12."
					]
				],
				Category->"Hidden",
				NestedIndexMatching->True
			},
			{
				OptionName->SenaryWashCollectionContainerIndex,
				Default->Automatic,
				Description->"The index of the SenaryWashCollectionContainer that the collected used SenaryWashBuffer goes to.",
				AllowNull->True,
				Widget->Alternatives[
					Adder[
						Alternatives[
							Widget[Type -> Number, Pattern :> GreaterEqualP[1, 1]],
							Widget[Type->Enumeration,Pattern:>Alternatives[Automatic,Null]]
						]
					],
					Widget[Type -> Number, Pattern :> GreaterEqualP[1, 1]]
				],
				Category->"Hidden",
				NestedIndexMatching->True
			},
			{
				OptionName->SeptenaryWashDestinationWell,
				Default->Automatic,
				Description->"The destination well in the SeptenaryWashCollectionContainer that the collected used SeptenaryWashBuffer goes to.",
				AllowNull->True,
				Widget->Alternatives[
					Adder[
						Alternatives[
							Widget[
								Type -> Enumeration,
								Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
								PatternTooltip -> "Enumeration must be any well from A1 to H12."
							],
							Widget[Type->Enumeration,Pattern:>Alternatives[Automatic,Null]]
						]
					],
					Widget[
						Type -> Enumeration,
						Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
						PatternTooltip -> "Enumeration must be any well from A1 to H12."
					]
				],
				Category->"Hidden",
				NestedIndexMatching->True
			},
			{
				OptionName->SeptenaryWashCollectionContainerIndex,
				Default->Automatic,
				Description->"The index of the SeptenaryWashCollectionContainer that the collected used SeptenaryWashBuffer goes to.",
				AllowNull->True,
				Widget->Alternatives[
					Adder[
						Alternatives[
							Widget[Type -> Number, Pattern :> GreaterEqualP[1, 1]],
							Widget[Type->Enumeration,Pattern:>Alternatives[Automatic,Null]]
						]
					],
					Widget[Type -> Number, Pattern :> GreaterEqualP[1, 1]]
				],
				Category->"Hidden",
				NestedIndexMatching->True
			},
			{
				OptionName->ElutionDestinationWell,
				Default->Automatic,
				Description->"The destination well in the ElutionCollectionContainer that the collected used ElutionBuffer goes to.",
				AllowNull->True,
				Widget->Alternatives[
					Adder[
						Alternatives[
							Widget[
								Type -> Enumeration,
								Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
								PatternTooltip -> "Enumeration must be any well from A1 to H12."
							],
							Widget[Type->Enumeration,Pattern:>Alternatives[Automatic,Null]]
						]
					],
					Widget[
						Type -> Enumeration,
						Pattern :> Alternatives @@ Flatten[AllWells[NumberOfWells -> 384]],
						PatternTooltip -> "Enumeration must be any well from A1 to H12."
					]
				],
				Category->"Hidden",
				NestedIndexMatching->True
			},
			{
				OptionName->ElutionCollectionContainerIndex,
				Default->Automatic,
				Description->"The index of the ElutionCollectionContainer that the collected used ElutionBuffer goes to.",
				AllowNull->True,
				Widget->Alternatives[
					Adder[
						Alternatives[
							Widget[Type -> Number, Pattern :> GreaterEqualP[1, 1]],
							Widget[Type->Enumeration,Pattern:>Alternatives[Automatic,Null]]
						]
					],
					Widget[Type -> Number, Pattern :> GreaterEqualP[1, 1]]
				],
				Category->"Hidden",
				NestedIndexMatching->True
			},
			{
				OptionName->UnresolvedMagnetizationRack,
				Default->Automatic,
				Description->"The user input of the magnetic rack used during magnetization that is passed to Transfer unit operation and eventually to the primitive framework in order to in order to decide if an error should be thrown if Preparation->Robotic, and MagnetizationRack -> Model[Item, MagnetizationRack, \"Alpaqua Magnum FLX Enhanced Universal Magnet 96-well Plate Rack\"] while also having a Filter unit operation.",
				ResolutionDescription->"Automatically set to the unresolved MagnetizationRack if it is any Model[Item,MagnetizationRack] or Object[Item,MagnetizationRack]. Otherwise set to Null.",
				AllowNull->True,
				Widget-> Alternatives[
					Widget[
						Type->Object,
						Pattern:>ObjectP[{
							Model[Item,MagnetizationRack],
							Object[Item,MagnetizationRack]
						}]
					],
					Widget[Type->Enumeration,Pattern:>Alternatives[Automatic]
					]
				],
				Category->"Hidden",
				NestedIndexMatching->True
			}
		],

		(*===Shared Options===*)
		ModifyOptions[WorkCellOption,
			{Category->"Hidden"}
		],
		ModifyOptions[
			ModelInputOptions,
			{
				{
					OptionName -> PreparedModelAmount(* Note: MBS expand nested options differently than other functions use ExpandIndexMatchedInputs, easier not to expand as nested index *)
				},
				{
					OptionName -> PreparedModelContainer,
					ResolutionDescription -> "If PreparedModelAmount is set to All and the input model has a product associated with both Amount and DefaultContainerModel populated, automatically set to the DefaultContainerModel value in the product. Otherwise, automatically set to Model[Container, Plate, \"96-well 2mL Deep Well Plate\"]."
				}
			}
		],
		NonBiologyFuntopiaSharedOptionsNestedIndexMatching,
		SubprotocolDescriptionOption,
		SamplesInStorageOptions,
		PreparationOption,
		SimulationOption,
		MeasureWeightOption,
		MeasureVolumeOption
	}
];


Error::SeparationModeMismatch="If SeparationMode is not Affinity, AnalyteAffinityLabel and MagneticBeadAffinityLabel must not be specified. Please change the values of these options, or leave them unspecified to be set automatically.";
Warning::MultipleAnalytes="For the following samples `1`, there are multiple Analytes. The first member of Analytes will be used as AnalyteAffinityLabel.";
Warning::MultipleTargetTypes="For the following samples `1`, there are multiple molecules types in Analytes. The first member of Analytes will be used as Target.";
Warning::MultipleTargets="For the following analytes `1`, there are multiple Targets. The first member of Targets will be used.";
Warning::GeneralResolvedMagneticBeads="For the following samples `1`, the option MagneticBeads is resolved to a generic model due to the lack of magnetic bead recommendation based on the Target and SeparationMode. Please check if it works for this experiment or specify the option of MagneticBeads.";
Warning::MaxTimeParallelProcessing="Under Parallel ProcessingOrder, the maximum processing time, temperature, mix rate of each step for the samples will be used for all the samples even if different settings are provided. Please consider changing ProcessingOrder to Serial.";
Error::InvalidProcessingOrder="Parallel and Serial ProcessingOrder can only be specified for a flat list and Batch ProcessingOrder can only be specified for a nested or semi-nested list. Please change the value of this option, or leave it unspecified to be set automatically.";
Error::InvalidDestinationWells="The specified DestinationWells `1` for collection container `2` in the `3` stage are not valid positions on the container. Please change the value of this option, or leave it unspecified to be set automatically.";
Warning::NoAvailablePositionsInContainer="For the following user specified collection container `1` in the `2` stage, there are no empty wells. The could cause unwanted mixing of collected samples. If this is not intended, please specify a container or container and well that is empty or leave the `2` CollectionContainer and DestinationWell options to be set automatically.";
Error::InvalidBufferVolume="For the following samples, `1` the buffer volume `2` for stage `3` is greater than the MaxVolume of the chosen AssayContainer. Please reduce this volume. Note that if Preparation->Robotic the only possible assay container is the 96-well 2mL Deep Well Plate, Model[Container, Plate, \"96-well 2mL Deep Well Plate\"].";
Error::CollectionContainerConflictingStorageCondition="The following collection containers `1` have multiple storage conditions specified. Please change the PreWashCollectionStorageCondition, EquilibrationCollectionStorageCondition, LoadingCollectionStorageCondition, WashCollectionStorageCondition, and/or ElutionCollectionStorageCondition options or leave them to be set automatically.";

Error::PreWashMismatch="For the following samples `1`, the PreWash options are in conflict with PreWash. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::PreWashMixMismatch="For the following samples `1`, the PreWashMix options are in conflict with PreWashMix. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::InvalidPreWashMixTipType="For the following samples `1`, the PreWashMixTipType is specified as a non-WideBore TipTypeP, while the PreWashMixVolume of `2` is less or equal to 970 Microliter. Using a non-WideBore tip for small-volume pipette mixing risks clogging the tip due to the magnetic beads. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::PreWashMixNoTip="For the following samples `1`, there is no tips found by the function TransferDevices for the PreWashMixVolume of `2`, given the specified PreWashMixTipType `3` and PreWashMixTipMaterial `4`. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::PreWashMixNoInstrument="For the following samples `1`, there is no instrument found by the function MixDevices given the specified options in PreWashMixType, PreWashMixTemperature, and PreWashMixRate. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::PreWashAirDryMismatch="For the following samples `1`, PreWashAirDryTime is in conflict with PreWashAirDry. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::NumberOfPreWashesMismatch="For the following samples `1`, NumberOfPreWashes is not compatible with the length of PreWashCollectionContainer or PreWashCollectionContainerLabel. Please change the values of these options, or leave them unspecified to be set automatically.";
Warning::PreWashMixStowaways="The following samples `1` have a PreWashMixType which will affect their entire container, `2`, including the samples in that container with different PreWashMixTypes, potentially causing more mixing than intended. If this additional mixing is not intended, consider changing the PreWashMixType for these samples.";
Warning::PreWashAirDryStowaways="For the following samples `1` in batch `2`, PreWashAirDry is turned off; however, there are other samples in the batch `3` that have PreWashAirDry turned on so all samples will be air dried. If this is not the intended behavior, please separate the samples into separate batches so they can have separate air dry settings.";
Error::PreWashAspirationPipettingOptionsMismatch = "For the following samples `1`, PreWashAspirationPosition is in conflict with PreWashAspirationPositionOffset. Please change the values of these options, or leave them unspecified to be set automatically.";

Error::EquilibrationMismatch="For the following samples `1`, the Equilibration options are in conflict with Equilibration. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::EquilibrationMixMismatch="For the following samples `1`, the EquilibrationMix options are in conflict with EquilibrationMix. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::InvalidEquilibrationMixTipType="For the following samples `1`, the EquilibrationMixTipType is specified as a non-WideBore TipTypeP, while the EquilibrationMixVolume of `2` is less or equal to 970 Microliter. Using a non-WideBore tip for small-volume pipette mixing risks clogging the tip due to the magnetic beads. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::EquilibrationMixNoTip="For the following samples `1`, there is no tips found by the function TransferDevices for the EquilibrationMixVolume of `2`, given the specified EquilibrationMixTipType `3` and EquilibrationMixTipMaterial `4`. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::EquilibrationMixNoInstrument="For the following samples `1`, there is no instrument found by the function MixDevices given the specified options in EquilibrationMixType, EquilibrationMixTemperature, and EquilibrationMixRate. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::EquilibrationAirDryMismatch="For the following samples `1`, EquilibrationAirDryTime is in conflict with EquilibrationAirDry. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::NumberOfEquilibrationsMismatch="Each sample can only be equilibrated once. For the following samples `1`, either the EquilibrationCollectionContainer or EquilibrationCollectionContainerLabel option resolve the number of equilibraitons to more than 1. Please change the values of these options, or leave them unspecified to be set automatically.";
Warning::EquilibrationMixStowaways="The following samples `1` have a EquilibrationMixType which will affect their entire container, `2`, including the samples in that container with different EquilibrationMixTypes, potentially causing more mixing than intended. If this additional mixing is not intended, consider changing the EquilibrationMixType for these samples.";
Warning::EquilibrationAirDryStowaways="For the following samples `1` in batch `2`, EquilibrationAirDry is turned off; however, there are other samples in the batch `3` that have EquilibrationAirDry turned on so all samples will be air dried. If this is not the intended behavior, please separate the samples into separate batches so they can have separate air dry settings.";
Error::EquilibrationAspirationPipettingOptionsMismatch = "For the following samples `1`, EquilibrationAspirationPosition is in conflict with EquilibrationAspirationPositionOffset. Please change the values of these options, or leave them unspecified to be set automatically.";

Error::LoadingMixMismatch="For the following samples `1`, the LoadingMix options are in conflict with LoadingMix. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::InvalidLoadingMixTipType="For the following samples `1`, the LoadingMixTipType is specified as a non-WideBore TipTypeP, while the LoadingMixVolume of `2` is less or equal to 970 Microliter. Using a non-WideBore tip for small-volume pipette mixing risks clogging the tip due to the magnetic beads. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::LoadingMixNoTip="For the following samples `1`, there is no tips found by the function TransferDevices for the LoadingMixVolume of `2`, given the specified LoadingMixTipType `3` and LoadingMixTipMaterial `4`. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::LoadingMixNoInstrument="For the following samples `1`, there is no instrument found by the function MixDevices given the specified options in LoadingMixType, LoadingMixTemperature, and LoadingMixRate. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::LoadingAirDryMismatch="For the following samples `1`, LoadingAirDryTime is in conflict with LoadingAirDry. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::NumberOfLoadingsMismatch="Each sample can only be loaded once. For the following samples `1`, either the LoadingCollectionContainer or LoadingCollectionContainerLabel option resolve the number of loadings to more than 1. Please change the values of these options, or leave them unspecified to be set automatically.";
Warning::LoadingMixStowaways="The following samples `1` have a LoadingMixType which will affect their entire container, `2`, including the samples in that container with different LoadingMixTypes, potentially causing more mixing than intended. If this additional mixing is not intended, consider changing the LoadingMixType for these samples.";
Warning::LoadingAirDryStowaways="For the following samples `1` in batch `2`, LoadingAirDry is turned off; however, there are other samples in the batch `3` that have LoadingAirDry turned on so all samples will be air dried. If this is not the intended behavior, please separate the samples into separate batches so they can have separate air dry settings.";
Error::LoadingAspirationPipettingOptionsMismatch = "For the following samples `1`, LoadingAspirationPosition is in conflict with LoadingAspirationPositionOffset. Please change the values of these options, or leave them unspecified to be set automatically.";

Error::WashMismatch="For the following samples `1`, the Wash options are in conflict with Wash. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::WashMixMismatch="For the following samples `1`, the WashMix options are in conflict with WashMix. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::InvalidWashMixTipType="For the following samples `1`, the WashMixTipType is specified as a non-WideBore TipTypeP, while the WashMixVolume of `2` is less or equal to 970 Microliter. Using a non-WideBore tip for small-volume pipette mixing risks clogging the tip due to the magnetic beads. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::WashMixNoTip="For the following samples `1`, there is no tips found by the function TransferDevices for the WashMixVolume of `2`, given the specified WashMixTipType `3` and WashMixTipMaterial `4`. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::WashMixNoInstrument="For the following samples `1`, there is no instrument found by the function MixDevices given the specified options in WashMixType, WashMixTemperature, and WashMixRate. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::WashAirDryMismatch="For the following samples `1`, WashAirDryTime is in conflict with WashAirDry. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::NumberOfWashesMismatch="For the following samples `1`, NumberOfWashes is not compatible with the length of WashCollectionContainer or WashCollectionContainerLabel. Please change the values of these options, or leave them unspecified to be set automatically.";
Warning::WashMixStowaways="The following samples `1` have a WashMixType which will affect their entire container, `2`, including the samples in that container with different WashMixTypes, potentially causing more mixing than intended. If this additional mixing is not intended, consider changing the WashMixType for these samples.";
Warning::WashAirDryStowaways="For the following samples `1` in batch `2`, WashAirDry is turned off; however, there are other samples in the batch `3` that have WashAirDry turned on so all samples will be air dried. If this is not the intended behavior, please separate the samples into separate batches so they can have separate air dry settings.";
Error::WashAspirationPipettingOptionsMismatch = "For the following samples `1`, WashAspirationPosition is in conflict with WashAspirationPositionOffset. Please change the values of these options, or leave them unspecified to be set automatically.";

Error::SecondaryWashMismatch="For the following samples `1`, the SecondaryWash options are in conflict with SecondaryWash. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::SecondaryWashMixMismatch="For the following samples `1`, the SecondaryWashMix options are in conflict with SecondaryWashMix. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::InvalidSecondaryWashMixTipType="For the following samples `1`, the SecondaryWashMixTipType is specified as a non-WideBore TipTypeP, while the SecondaryWashMixVolume of `2` is less or equal to 970 Microliter. Using a non-WideBore tip for small-volume pipette mixing risks clogging the tip due to the magnetic beads. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::SecondaryWashMixNoTip="For the following samples `1`, there is no tips found by the function TransferDevices for the SecondaryWashMixVolume of `2`, given the specified SecondaryWashMixTipType `3` and SecondaryWashMixTipMaterial `4`. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::SecondaryWashMixNoInstrument="For the following samples `1`, there is no instrument found by the function MixDevices given the specified options in SecondaryWashMixType, SecondaryWashMixTemperature, and SecondaryWashMixRate. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::SecondaryWashAirDryMismatch="For the following samples `1`, SecondaryWashAirDryTime is in conflict with SecondaryWashAirDry. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::NumberOfSecondaryWashesMismatch="For the following samples `1`, NumberOfSecondaryWashes is not compatible with the length of SecondaryWashCollectionContainer or SecondaryWashCollectionContainerLabel. Please change the values of these options, or leave them unspecified to be set automatically.";
Warning::SecondaryWashMixStowaways="The following samples `1` have a SecondaryWashMixType which will affect their entire container, `2`, including the samples in that container with different SecondaryWashMixTypes, potentially causing more mixing than intended. If this additional mixing is not intended, consider changing the SecondaryWashMixType for these samples.";
Warning::SecondaryWashAirDryStowaways="For the following samples `1` in batch `2`, SecondaryWashAirDry is turned off; however, there are other samples in the batch `3` that have SecondaryWashAirDry turned on so all samples will be air dried. If this is not the intended behavior, please separate the samples into separate batches so they can have separate air dry settings.";
Error::InvalidSecondaryWash="SecondaryWash is carried out after Wash. For the following samples `1`, SecondaryWash is True either as specified by SecondaryWash or resolved to True because there is other option in SecondaryWash specified, while Wash is False either as specified by Wash or because of the absence of other specified Wash options. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::SecondaryWashAspirationPipettingOptionsMismatch = "For the following samples `1`, SecondaryWashAspirationPosition is in conflict with SecondaryWashAspirationPositionOffset. Please change the values of these options, or leave them unspecified to be set automatically.";

Error::TertiaryWashMismatch="For the following samples `1`, the TertiaryWash options are in conflict with TertiaryWash. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::TertiaryWashMixMismatch="For the following samples `1`, the TertiaryWashMix options are in conflict with TertiaryWashMix. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::InvalidTertiaryWashMixTipType="For the following samples `1`, the TertiaryWashMixTipType is specified as a non-WideBore TipTypeP, while the TertiaryWashMixVolume of `2` is less or equal to 970 Microliter. Using a non-WideBore tip for small-volume pipette mixing risks clogging the tip due to the magnetic beads. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::TertiaryWashMixNoTip="For the following samples `1`, there is no tips found by the function TransferDevices for the TertiaryWashMixVolume of `2`, given the specified TertiaryWashMixTipType `3` and TertiaryWashMixTipMaterial `4`. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::TertiaryWashMixNoInstrument="For the following samples `1`, there is no instrument found by the function MixDevices given the specified options in TertiaryWashMixType, TertiaryWashMixTemperature, and TertiaryWashMixRate. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::TertiaryWashAirDryMismatch="For the following samples `1`, TertiaryWashAirDryTime is in conflict with TertiaryWashAirDry. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::NumberOfTertiaryWashesMismatch="For the following samples `1`, NumberOfTertiaryWashes is not compatible with the length of TertiaryWashCollectionContainer or TertiaryWashCollectionContainerLabel. Please change the values of these options, or leave them unspecified to be set automatically.";
Warning::TertiaryWashMixStowaways="The following samples `1` have a TertiaryWashMixType which will affect their entire container, `2`, including the samples in that container with different TertiaryWashMixTypes, potentially causing more mixing than intended. If this additional mixing is not intended, consider changing the TertiaryWashMixType for these samples.";
Warning::TertiaryWashAirDryStowaways="For the following samples `1` in batch `2`, TertiaryWashAirDry is turned off; however, there are other samples in the batch `3` that have TertiaryWashAirDry turned on so all samples will be air dried. If this is not the intended behavior, please separate the samples into separate batches so they can have separate air dry settings.";
Error::InvalidTertiaryWash="TertiaryWash is carried out after SecondaryWash. For the following samples `1`, TertiaryWash is True either as specified by TertiaryWash or resolved to True because there is other option in TertiaryWash specified, while SecondaryWash is False either as specified by SecondaryWash or because of the absence of other specified SecondaryWash options. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::TertiaryWashAspirationPipettingOptionsMismatch = "For the following samples `1`, TertiaryWashAspirationPosition is in conflict with TertiaryWashAspirationPositionOffset. Please change the values of these options, or leave them unspecified to be set automatically.";

Error::QuaternaryWashMismatch="For the following samples `1`, the QuaternaryWash options are in conflict with QuaternaryWash. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::QuaternaryWashMixMismatch="For the following samples `1`, the QuaternaryWashMix options are in conflict with QuaternaryWashMix. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::InvalidQuaternaryWashMixTipType="For the following samples `1`, the QuaternaryWashMixTipType is specified as a non-WideBore TipTypeP, while the QuaternaryWashMixVolume of `2` is less or equal to 970 Microliter. Using a non-WideBore tip for small-volume pipette mixing risks clogging the tip due to the magnetic beads. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::QuaternaryWashMixNoTip="For the following samples `1`, there is no tips found by the function TransferDevices for the QuaternaryWashMixVolume of `2`, given the specified QuaternaryWashMixTipType `3` and QuaternaryWashMixTipMaterial `4`. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::QuaternaryWashMixNoInstrument="For the following samples `1`, there is no instrument found by the function MixDevices given the specified options in QuaternaryWashMixType, QuaternaryWashMixTemperature, and QuaternaryWashMixRate. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::QuaternaryWashAirDryMismatch="For the following samples `1`, QuaternaryWashAirDryTime is in conflict with QuaternaryWashAirDry. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::NumberOfQuaternaryWashesMismatch="For the following samples `1`, NumberOfQuaternaryWashes is not compatible with the length of QuaternaryWashCollectionContainer or QuaternaryWashCollectionContainerLabel. Please change the values of these options, or leave them unspecified to be set automatically.";
Warning::QuaternaryWashMixStowaways="The following samples `1` have a QuaternaryWashMixType which will affect their entire container, `2`, including the samples in that container with different QuaternaryWashMixTypes, potentially causing more mixing than intended. If this additional mixing is not intended, consider changing the QuaternaryWashMixType for these samples.";
Warning::QuaternaryWashAirDryStowaways="For the following samples `1` in batch `2`, QuaternaryWashAirDry is turned off; however, there are other samples in the batch `3` that have QuaternaryWashAirDry turned on so all samples will be air dried. If this is not the intended behavior, please separate the samples into separate batches so they can have separate air dry settings.";
Error::InvalidQuaternaryWash="QuaternaryWash is carried out after TertiaryWash. For the following samples `1`, QuaternaryWash is True either as specified by QuaternaryWash or resolved to True because there is other option in QuaternaryWash specified, while TertiaryWash is False either as specified by TertiaryWash or because of the absence of other specified TertiaryWash options. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::QuaternaryWashAspirationPipettingOptionsMismatch = "For the following samples `1`, QuaternaryWashAspirationPosition is in conflict with QuaternaryWashAspirationPositionOffset. Please change the values of these options, or leave them unspecified to be set automatically.";

Error::QuinaryWashMismatch="For the following samples `1`, the QuinaryWash options are in conflict with QuinaryWash. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::QuinaryWashMixMismatch="For the following samples `1`, the QuinaryWashMix options are in conflict with QuinaryWashMix. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::InvalidQuinaryWashMixTipType="For the following samples `1`, the QuinaryWashMixTipType is specified as a non-WideBore TipTypeP, while the QuinaryWashMixVolume of `2` is less or equal to 970 Microliter. Using a non-WideBore tip for small-volume pipette mixing risks clogging the tip due to the magnetic beads. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::QuinaryWashMixNoTip="For the following samples `1`, there is no tips found by the function TransferDevices for the QuinaryWashMixVolume of `2`, given the specified QuinaryWashMixTipType `3` and QuinaryWashMixTipMaterial `4`. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::QuinaryWashMixNoInstrument="For the following samples `1`, there is no instrument found by the function MixDevices given the specified options in QuinaryWashMixType, QuinaryWashMixTemperature, and QuinaryWashMixRate. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::QuinaryWashAirDryMismatch="For the following samples `1`, QuinaryWashAirDryTime is in conflict with QuinaryWashAirDry. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::NumberOfQuinaryWashesMismatch="For the following samples `1`, NumberOfQuinaryWashes is not compatible with the length of QuinaryWashCollectionContainer or QuinaryWashCollectionContainerLabel. Please change the values of these options, or leave them unspecified to be set automatically.";
Warning::QuinaryWashMixStowaways="The following samples `1` have a QuinaryWashMixType which will affect their entire container, `2`, including the samples in that container with different QuinaryWashMixTypes, potentially causing more mixing than intended. If this additional mixing is not intended, consider changing the QuinaryWashMixType for these samples.";
Warning::QuinaryWashAirDryStowaways="For the following samples `1` in batch `2`, QuinaryWashAirDry is turned off; however, there are other samples in the batch `3` that have QuinaryWashAirDry turned on so all samples will be air dried. If this is not the intended behavior, please separate the samples into separate batches so they can have separate air dry settings.";
Error::InvalidQuinaryWash="QuinaryWash is carried out after QuaternaryWash. For the following samples `1`, QuinaryWash is True either as specified by QuinaryWash or resolved to True because there is other option in QuinaryWash specified, while QuaternaryWash is False either as specified by QuaternaryWash or because of the absence of other specified QuaternaryWash options. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::QuinaryWashAspirationPipettingOptionsMismatch = "For the following samples `1`, QuinaryWashAspirationPosition is in conflict with QuinaryWashAspirationPositionOffset. Please change the values of these options, or leave them unspecified to be set automatically.";


Error::SenaryWashMismatch="For the following samples `1`, the SenaryWash options are in conflict with SenaryWash. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::SenaryWashMixMismatch="For the following samples `1`, the SenaryWashMix options are in conflict with SenaryWashMix. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::InvalidSenaryWashMixTipType="For the following samples `1`, the SenaryWashMixTipType is specified as a non-WideBore TipTypeP, while the SenaryWashMixVolume of `2` is less or equal to 970 Microliter. Using a non-WideBore tip for small-volume pipette mixing risks clogging the tip due to the magnetic beads. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::SenaryWashMixNoTip="For the following samples `1`, there is no tips found by the function TransferDevices for the SenaryWashMixVolume of `2`, given the specified SenaryWashMixTipType `3` and SenaryWashMixTipMaterial `4`. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::SenaryWashMixNoInstrument="For the following samples `1`, there is no instrument found by the function MixDevices given the specified options in SenaryWashMixType, SenaryWashMixTemperature, and SenaryWashMixRate. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::SenaryWashAirDryMismatch="For the following samples `1`, SenaryWashAirDryTime is in conflict with SenaryWashAirDry. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::NumberOfSenaryWashesMismatch="For the following samples `1`, NumberOfSenaryWashes is not compatible with the length of SenaryWashCollectionContainer or SenaryWashCollectionContainerLabel. Please change the values of these options, or leave them unspecified to be set automatically.";
Warning::SenaryWashMixStowaways="The following samples `1` have a SenaryWashMixType which will affect their entire container, `2`, including the samples in that container with different SenaryWashMixTypes, potentially causing more mixing than intended. If this additional mixing is not intended, consider changing the SenaryWashMixType for these samples.";
Warning::SenaryWashAirDryStowaways="For the following samples `1` in batch `2`, SenaryWashAirDry is turned off; however, there are other samples in the batch `3` that have SenaryWashAirDry turned on so all samples will be air dried. If this is not the intended behavior, please separate the samples into separate batches so they can have separate air dry settings.";
Error::InvalidSenaryWash="SenaryWash is carried out after QuinaryWash. For the following samples `1`, SenaryWash is True either as specified by SenaryWash or resolved to True because there is other option in SenaryWash specified, while QuinaryWash is False either as specified by QuinaryWash or because of the absence of other specified QuinaryWash options. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::SenaryWashAspirationPipettingOptionsMismatch = "For the following samples `1`, SenaryWashAspirationPosition is in conflict with SenaryWashAspirationPositionOffset. Please change the values of these options, or leave them unspecified to be set automatically.";

Error::SeptenaryWashMismatch="For the following samples `1`, the SeptenaryWash options are in conflict with SeptenaryWash. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::SeptenaryWashMixMismatch="For the following samples `1`, the SeptenaryWashMix options are in conflict with SeptenaryWashMix. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::InvalidSeptenaryWashMixTipType="For the following samples `1`, the SeptenaryWashMixTipType is specified as a non-WideBore TipTypeP, while the SeptenaryWashMixVolume of `2` is less or equal to 970 Microliter. Using a non-WideBore tip for small-volume pipette mixing risks clogging the tip due to the magnetic beads. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::SeptenaryWashMixNoTip="For the following samples `1`, there is no tips found by the function TransferDevices for the SeptenaryWashMixVolume of `2`, given the specified SeptenaryWashMixTipType `3` and SeptenaryWashMixTipMaterial `4`. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::SeptenaryWashMixNoInstrument="For the following samples `1`, there is no instrument found by the function MixDevices given the specified options in SeptenaryWashMixType, SeptenaryWashMixTemperature, and SeptenaryWashMixRate. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::SeptenaryWashAirDryMismatch="For the following samples `1`, SeptenaryWashAirDryTime is in conflict with SeptenaryWashAirDry. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::NumberOfSeptenaryWashesMismatch="For the following samples `1`, NumberOfSeptenaryWashes is not compatible with the length of SeptenaryWashCollectionContainer or SeptenaryWashCollectionContainerLabel. Please change the values of these options, or leave them unspecified to be set automatically.";
Warning::SeptenaryWashMixStowaways="The following samples `1` have a SeptenaryWashMixType which will affect their entire container, `2`, including the samples in that container with different SeptenaryWashMixTypes, potentially causing more mixing than intended. If this additional mixing is not intended, consider changing the SeptenaryWashMixType for these samples.";
Warning::SeptenaryWashAirDryStowaways="For the following samples `1` in batch `2`, SeptenaryWashAirDry is turned off; however, there are other samples in the batch `3` that have SeptenaryWashAirDry turned on so all samples will be air dried. If this is not the intended behavior, please separate the samples into separate batches so they can have separate air dry settings.";
Error::InvalidSeptenaryWash="SeptenaryWash is carried out after SenaryWash. For the following samples `1`, SeptenaryWash is True either as specified by SeptenaryWash or resolved to True because there is other option in SeptenaryWash specified, while SenaryWash is False either as specified by SenaryWash or because of the absence of other specified SenaryWash options. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::SeptenaryWashAspirationPipettingOptionsMismatch = "For the following samples `1`, SeptenaryWashAspirationPosition is in conflict with SeptenaryWashAspirationPositionOffset. Please change the values of these options, or leave them unspecified to be set automatically.";

Error::ElutionMismatch="For the following samples `1`, the Elution options are in conflict with Elution. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::ElutionMixMismatch="For the following samples `1`, the ElutionMix options are in conflict with ElutionMix. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::InvalidElutionMixTipType="For the following samples `1`, the ElutionMixTipType is specified as a non-WideBore TipTypeP, while the ElutionMixVolume of `2` is less or equal to 970 Microliter. Using a non-WideBore tip for small-volume pipette mixing risks clogging the tip due to the magnetic beads. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::ElutionMixNoTip="For the following samples `1`, there is no tips found by the function TransferDevices for the ElutionMixVolume of `2`, given the specified ElutionMixTipType `3` and ElutionMixTipMaterial `4`. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::ElutionMixNoInstrument="For the following samples `1`, there is no instrument found by the function MixDevices given the specified options in ElutionMixType, ElutionMixTemperature, and ElutionMixRate. Please change the values of these options, or leave them unspecified to be set automatically.";
Error::NumberOfElutionsMismatch="For the following samples `1`, NumberOfElutions is not matching with the length of ElutionCollectionContainer or ElutionCollectionContainerLabel. Please change the values of these options, or leave them unspecified to be set automatically.";
Warning::ElutionMixStowaways="The following samples `1` have a ElutionMixType which will affect their entire container, `2`, including the samples in that container with different ElutionMixTypes, potentially causing more mixing than intended. If this additional mixing is not intended, consider changing the ElutionMixType for these samples.";
Error::ElutionAspirationPipettingOptionsMismatch = "For the following samples `1`, ElutionAspirationPosition is in conflict with ElutionAspirationPositionOffset. Please change the values of these options, or leave them unspecified to be set automatically.";

(* ::Subsubsection::Closed:: *)
(*ExperimentMagneticBeadSeparation*)


(*---Function overload accepting semi-pooled sample/container objects as inputs. Note: {s1,{s2,s3}}->{{s1},{s2,s3}}---*)
ExperimentMagneticBeadSeparation[
	mySemiNestedInputs:ListableP[ListableP[ObjectP[{Object[Sample],Object[Container], Model[Sample]}]|_String|{LocationPositionP,_String|ObjectP[Object[Container]]}]],
	myOptions:OptionsPattern[ExperimentMagneticBeadSeparation]
]:=Module[
	{
		outputSpecification, output, gatherTests, processingOrder,  resolvedProcessingOrder, semiNestedSamplesAndContainers,
		optionDefinition, semiNestedOptions, listedSamples, listedOptions, mySamplesWithPreparedSamplesNamed, myOptionsWithPreparedSamplesNamed,
		samplePreparationSimulation, validSamplePreparationResult, containerToSampleSimulation, currentSimulation, listedContainers,
		emptyContainers, unnestedSamplesWithPreparedSamples, containerToSampleResult, containerToSampleOutput, containerToSampleTests,
		unnestedContainerToSampleOutput, unnestedContainerToSampleTests, myFullyNestedSamples, myFullyNestedOptions
	},

	(* Determine the requested return value from the function *)
	outputSpecification = Quiet[OptionValue[Output]];
	output = ToList[outputSpecification];

	(* Determine if we should keep a running list of tests *)
	gatherTests = MemberQ[output,Tests];

	(* Lookup the unresolved ProcessingOrder *)
  (* Note:we are checking safe options and its test later after convert inputs. Not throwing error here. *)
	processingOrder = Lookup[
		SafeOptions[ExperimentMagneticBeadSeparation, Cases[ToList[myOptions], HoldPattern[ProcessingOrder -> _]]],
		ProcessingOrder
	];

	(* Get a resolved ProcessingOrder based on the structure of the input samples *)
	resolvedProcessingOrder = If[!MatchQ[processingOrder, Automatic],
		(* If it is not Automatic leave it as is *)
		processingOrder,
		(* If it is Automatic, look at structure of input samples *)
		Switch[mySemiNestedInputs,
			(* Singleton *)
			ObjectP[{Object[Sample], Object[Container], Model[Sample]}]|_String|{LocationPositionP, _String|ObjectP[Object[Container]]},
				Parallel,
			(* flat list *)
			{Except[_List]..},
				Parallel,
			(* Nested or semi nested list *)
			_,
				Batch
		]
	];

	(* If ProcessingOrder is Parallel or Automatic and we are given a flat list of inputs, wrap the input in another list *)
	semiNestedSamplesAndContainers = If[MatchQ[mySemiNestedInputs, {Except[_List]..}] && MatchQ[resolvedProcessingOrder, Parallel],
		{mySemiNestedInputs},
		mySemiNestedInputs
	];

	(* Get the option definition for the function *)
	optionDefinition = OptionDefinition[ExperimentMagneticBeadSeparation];

	(* Look at all the given options, expand the options to match the nesting of the inputs if processing order is Parallel or Batch  *)
	semiNestedOptions = Map[
		Function[{option},
			Module[
				{
					optionSymbol, optionValue, specificOptionDef, nestedIndexMatchingQ, singletonPatternMatchingQ, optionSymbolsToSkip,
					singletonP
				},
				(* Get our option value. *)
				optionSymbol = option[[1]];
				optionValue = option[[2]];

				(* Get the definition of our option. *)
				specificOptionDef = FirstCase[optionDefinition, KeyValuePattern["OptionSymbol" -> optionSymbol], <||>];

				(* Determine if our option is NestedIndexMatching *)
				nestedIndexMatchingQ = MatchQ[Lookup[specificOptionDef, "NestedIndexMatching", $Failed], True];

				(* Determine if our option matches the singleton pattern *)
				singletonPatternMatchingQ = MatchQ[optionValue,ReleaseHold[Lookup[specificOptionDef, "SingletonPattern", _]]];

				(* Define which options to skip singletonPatternMatching *)
				optionSymbolsToSkip = Alternatives[
					PreWashCollectionContainer,PreWashCollectionContainerLabel,
					EquilibrationCollectionContainer,EquilibrationCollectionContainerLabel,
					LoadingCollectionContainer,LoadingCollectionContainerLabel,
					WashCollectionContainer,WashCollectionContainerLabel,
					SecondaryWashCollectionContainer,SecondaryWashCollectionContainerLabel,
					TertiaryWashCollectionContainer,TertiaryWashCollectionContainerLabel,
					QuaternaryWashCollectionContainer,QuaternaryWashCollectionContainerLabel,
					QuinaryWashCollectionContainer,QuinaryWashCollectionContainerLabel,
					SenaryWashCollectionContainer,SenaryWashCollectionContainerLabel,
					SeptenaryWashCollectionContainer,SeptenaryWashCollectionContainerLabel,
					ElutionCollectionContainer,ElutionCollectionContainerLabel,
					ContainerOutLabel,SampleOutLabel
				];

				(* Ignore CollectionContainer,CollectionContainerLabel,and DestinationWell options as they are unique and not handled *)
				(* well by ExpandIndexMatchedInputs *)
				If[MatchQ[optionSymbol, optionSymbolsToSkip],
					singletonPatternMatchingQ = False
				];

				singletonP = Alternatives[
					Except[_List],
					{_Integer, ObjectP[]},
					{_String, ObjectP[]},
					{_String, {_Integer, ObjectP[]}}
				];
				(* Expand the option *)
				Which[
					(* If it matches the singleton pattern of the option definition we can leave it as ExpandIndexMatchingInputs will take care of it *)
					singletonPatternMatchingQ,
						option,
					(* If the option is a flat list and the resolvedProcessingOrder is Parallel, wrap another list around the option *)
					MatchQ[optionValue, {singletonP..}] && MatchQ[resolvedProcessingOrder, Parallel] && nestedIndexMatchingQ,
						optionSymbol -> {optionValue},
					(* If the option is a flat list and the resolvedProcessingOrder is Batch *)
					MatchQ[optionValue, {singletonP..}] && MatchQ[resolvedProcessingOrder, Batch] && nestedIndexMatchingQ,
						(* If the option and sample are not the same length, skip. The error will be caught in the next function *)
						If[!MatchQ[Length[optionValue/.singletonP->Null], Length[semiNestedSamplesAndContainers]],
							option,
							(* If the lengths are the same, mapthread over and expand the option value to be the same dimensions as the sample  *)
							optionSymbol -> MapThread[
								Function[{optionValue ,sample},
									If[MatchQ[sample, _List] && MatchQ[optionValue, singletonP],
										ConstantArray[optionValue, Length[sample]],
										optionValue
									]
								],
								{optionValue, semiNestedSamplesAndContainers}
							]
						],
					True,
						option
				]
			]
		],
		ToList[myOptions]
	];

	(* make the inputs and options a list *)
	{listedSamples,listedOptions}={ToList[semiNestedSamplesAndContainers],ToList[semiNestedOptions]};

	(*--Simulate sample preparation--*)
	validSamplePreparationResult=Check[
		{mySamplesWithPreparedSamplesNamed,myOptionsWithPreparedSamplesNamed,samplePreparationSimulation}=simulateSamplePreparationPacketsNew[
			ExperimentMagneticBeadSeparation,
			listedSamples,
			listedOptions,
			DefaultPreparedModelContainer -> Model[Container, Plate, "96-well 2mL Deep Well Plate"]
		],
		$Failed,
		{Download::ObjectDoesNotExist,Error::MissingDefineNames,Error::InvalidInput,Error::InvalidOption}
	];

	(*If we are given an invalid define name, return early*)
	If[MatchQ[validSamplePreparationResult,$Failed],
		(*Return early*)
		(*Note: We've already thrown a message above in simulateSamplePreparationPackets*)
		Return[$Failed]
	];

	(*--Check for empty containers--*)
	listedContainers=Cases[Flatten@listedSamples,ObjectP[Object[Container]]];

	emptyContainers=If[MatchQ[listedContainers,{}],
		{},
		PickList[listedContainers,Download[listedContainers,Contents,Cache->Lookup[myOptionsWithPreparedSamplesNamed,Cache,{}],Simulation->samplePreparationSimulation],{}]
	];

	(*Return early if empty containers*)
	If[Length[emptyContainers]>0,
		Message[Error::EmptyContainers,emptyContainers];
		Return[$Failed]
	];

	(* Unflatten the prepared samples and containers based on the pattern of the original input *)
	unnestedSamplesWithPreparedSamples=Unflatten[Flatten[mySamplesWithPreparedSamplesNamed],ToList[mySemiNestedInputs]];

	(*--Convert the given containers into samples and sample index-matched options--*)
	containerToSampleResult=If[gatherTests,
		(*We are gathering tests. This silences any messages being thrown*)
		{containerToSampleOutput,containerToSampleTests,containerToSampleSimulation}=pooledContainerToSampleOptions[
			ExperimentMagneticBeadSeparation,
			mySamplesWithPreparedSamplesNamed,
			myOptionsWithPreparedSamplesNamed,
			Output->{Result,Tests,Simulation},
			Simulation->samplePreparationSimulation,
			GroupContainerSamples->!MatchQ[resolvedProcessingOrder,Serial]
		];

		(*Therefore, we have to run the tests to see if we encountered a failure*)
		If[RunUnitTest[<|"Tests"->containerToSampleTests|>,OutputFormat->SingleBoolean,Verbose->False],
			Null,
			$Failed
		],

		(*We are not gathering tests. Simply check for Error::EmptyContainers*)
		Check[
			{containerToSampleOutput,containerToSampleSimulation}=pooledContainerToSampleOptions[
				ExperimentMagneticBeadSeparation,
				mySamplesWithPreparedSamplesNamed,
				myOptionsWithPreparedSamplesNamed,
				Output->{Result,Simulation},
				Simulation->samplePreparationSimulation,
				GroupContainerSamples->!MatchQ[resolvedProcessingOrder,Serial]
			],
			$Failed,
			{Error::EmptyContainers, Error::ContainerEmptyWells, Error::WellDoesNotExist}
		]
	];

	currentSimulation = If[MatchQ[Lookup[myOptionsWithPreparedSamplesNamed,Cache,{}], SimulationP],
		UpdateSimulation[Lookup[myOptionsWithPreparedSamplesNamed,Cache,{}],containerToSampleSimulation],
		containerToSampleSimulation
	];

	(* Similarly, convert the unnested container list to sample. Note that we are using containerToSampleOptions here since we don't want the pooling behavior for our unnested sample list *)
	{unnestedContainerToSampleOutput,unnestedContainerToSampleTests}=If[MatchQ[unnestedSamplesWithPreparedSamples,ListableP[ObjectP[{Object[Sample],Object[Container]}]|_String|{LocationPositionP,_String|ObjectP[Object[Container]]}]],
		Quiet[containerToSampleOptions[
			ExperimentMagneticBeadSeparation,
			unnestedSamplesWithPreparedSamples,
			myOptionsWithPreparedSamplesNamed,
			Output->Result,
			Simulation->currentSimulation
		]],
		Quiet[pooledContainerToSampleOptions[
			ExperimentMagneticBeadSeparation,
			unnestedSamplesWithPreparedSamples,
			myOptionsWithPreparedSamplesNamed,
			Output->Result,
			Simulation->currentSimulation
		]]
	];

	(* Make sure the samples are in a nested list *)
	myFullyNestedSamples=Map[
		(If[MatchQ[#,ObjectP[Object[Sample]]],
			{#},
			#
		])&,
		First@containerToSampleOutput
	];

	(* Make sure the options are in a nested list if they are specified as NestedIndexMatching *)
	myFullyNestedOptions=Map[
		Function[{option},
			Module[{optionSymbol,optionValue,specificOptionDef,nestedIndexMatchingQ,singletonPattern},
				(* Get our option symbol and value. *)
				optionSymbol=option[[1]];
				optionValue=option[[2]];

				(* Get the definition of our option. *)
				specificOptionDef=FirstCase[optionDefinition,KeyValuePattern["OptionSymbol"->optionSymbol],<||>];

				(* Determine if the option is NestedIndexMatching *)
				nestedIndexMatchingQ=MatchQ[Lookup[specificOptionDef,"NestedIndexMatching",$Failed],True];

				(* Extract the singleton pattern *)
				singletonPattern = ReleaseHold@Lookup[specificOptionDef,"SingletonPattern",_];

				(* If the option value is a list and the option is NestedIndexMatching and it doesn't match its singleton pattern,*)
				(* map over it to make sure we have a fully nested list *)
				If[(!MatchQ[optionValue,singletonPattern])&&MatchQ[optionValue,_List]&&nestedIndexMatchingQ,
					optionSymbol->Map[
						(If[!MatchQ[#,_List],
							{#},
							#
						])&,
						optionValue
					],
					option
				]
			]
		],
		Last@containerToSampleOutput
	];

	(*If we were given an empty container, return early*)
	If[ContainsAny[ToList[containerToSampleResult],{$Failed}],
		(*containerToSampleOptions failed - return $Failed*)
		outputSpecification/.{
			Result->$Failed,
			Tests->containerToSampleTests,
			Options->$Failed,
			Preview->Null
		},

		(*Call the main function with our samples and converted options*)
		ExperimentMagneticBeadSeparationCore[
			myFullyNestedSamples,
			mySemiNestedInputs,
			unnestedContainerToSampleOutput,
			ToList[myOptions],
			ReplaceRule[myFullyNestedOptions,Simulation->currentSimulation]
		]
	]
];

(*Helper function to correctly unflatten a list of possibly complex container format for a repeated stage,e.g .NumberOfPreWashes *)
(* Allow resolvedOptions to be non-list since it may just be the non-list version of inputOptions. Our real resolved container is guaranteed to be a list *)
unnestOptionsOfRepeatedStage[resolvedOptions_,numberOfStage:ListableP[Alternatives[_Integer,Null],2],inputOptions:ListableP[Alternatives[Automatic,Null,_String,_Integer,ObjectP[],{_Integer,ObjectP[]},{_String,ObjectP[]},{_String,{_Integer,ObjectP[]}}],3],unnestedSampleInputs_]:=If[MemberQ[ToList[inputOptions],Automatic],
	(*If the input contains any Automatic, the outputCollectionContainers would have been a flat list of singletons, other optiond are flat lists*)
	Module[{flatResolvedOptionValue},
		flatResolvedOptionValue=TakeList[resolvedOptions,(Flatten[numberOfStage]/.Null->1)];
		Unflatten[flatResolvedOptionValue,unnestedSampleInputs]
	],
	(*If the input container is fully user-specified, it is either already collasped or index matched with unnested samples, *)
	resolvedOptions
];
(* Helper function to correctly unflatten a flattened list according to the structure of a nested list of samples or sample labels*)
unflattenListHelper[flatList_List, nestedList:ListableP[ObjectP[] | _String, 2]]:=TakeList[flatList,Length/@nestedList];
(* Helper function to correctly expand nested index matched options that would be affected by the number of repeats of a stage *)
expandIndexMatchedInputsHelper[
	mySamples:ListableP[ObjectP[],3],
	unexpandedOptions:ListableP[Alternatives[ObjectP[],_String,_Integer,Automatic,Null],4],
	numberOfStageRepeats:ListableP[_Integer,3]
]:=Which[
	(* Here, we assume mySamples is always a nested list and unexpandedOptions and numberOfStageRepeats are either a single value, or *)
	(* a nested list matching the dimensions of mySamples. Enumerate all the combinations and replace accordingly *)
	(* If unexpandedOptions is a singleton *)
	MatchQ[unexpandedOptions,Except[_List]],
		(* Case on the structure of numberOfStageRepeats *)
		Which[
			(* If numberOfStageRepeats is  number *)
			MatchQ[numberOfStageRepeats,_Integer],
			mySamples/.sample:ObjectP[{Object[Sample],Model[Sample]}]->ConstantArray[unexpandedOptions,numberOfStageRepeats],
			(* If numberOfStageRepeats is a nested list *)
			MatchQ[Depth[numberOfStageRepeats],3],
			(* Replace with unexpanded option *)
			numberOfStageRepeats/.num_Integer:>ConstantArray[unexpandedOptions,If[NullQ[num],1,num]]
		],
	(* If unexpanded options is only a list of lists *)
	Depth[unexpandedOptions/.{ObjectP[]->Null}] == 3,
		(* Case on the structure of numberOfStageRepeats *)
		Which[
			(* If numberOfStageRepeats is a singleton *)
			MatchQ[numberOfStageRepeats,_Integer],
			unexpandedOptions/.optionValue:Alternatives[ObjectP[{Object[Container],Model[Container]}],_String,_Integer,Automatic,Null]:>If[MatchQ[Length[optionValue/.ObjectP[]->Null],numberOfStageRepeats],{optionValue},ConstantArray[optionValue,numberOfStageRepeats]],
			(* If numberOfStageRepeats is a nested list *)
			MatchQ[Depth[numberOfStageRepeats],3],
			MapThread[
				Function[{options,repeats},
					MapThread[
						ConstantArray[#1,If[NullQ[#2],1,#2]]&,
						{options,repeats}
					]
				],
				{unexpandedOptions,numberOfStageRepeats}
			]
		],
	(* If unexpanded options contains lists of lists of lists *)
	True,
		(* If numberOfStageRepeats is a singleton *)
		If[MatchQ[numberOfStageRepeats,_Integer],
			(* Map over the first level of inner lists *)
			Map[
				Function[{unexpandedOption},
					(* If this level is a list of lists, keep it as is - we will catch any length incompatibilities in the option resolver *)
					If[Depth[unexpandedOption/.{ObjectP[]->Null}] == 3,
						unexpandedOption,
						(* Otherwise, we have a flat list and treat it as if it were a part of a list of lists *)
						unexpandedOption/.optionValue:Alternatives[ObjectP[{Object[Container],Model[Container]}],_String,_Integer,Automatic,Null]:>ConstantArray[optionValue,numberOfStageRepeats]
					]
				],
				unexpandedOptions
			],
			(* If numberOfStageRepeats is a nested list *)
			(* Map over the first level of inner lists *)
			MapThread[
				Function[{unexpandedOption,repeats},
					(* If this level is a list of lists, keep it as is - we will catch any length incompatibilities in the option resolver *)
					If[Depth[unexpandedOption/.{ObjectP[]->Null}] == 3,
						unexpandedOption,
						(* Otherwise, we have a flat list and treat it as if it were a part of a list of lists *)
						MapThread[
							ConstantArray[#1,If[NullQ[#2],1,#2]]&,
							{unexpandedOption,repeats}
						]
					]
				],
				{unexpandedOptions,numberOfStageRepeats}
			]
		]
];

(*-=-Helper function to convert new-style CollectionContainer input to old style Container+DestinationWells-=-*)

(*Overload for a nested list of containers*)
convertInputContainerFormat[inputCollectionContainers:
		ListableP[
			ObjectP[Object[Container]]|ObjectP[_String]|ObjectP[Model[Container]],3
		]]:= Module[
	{convertedCollectionContainers,convertedDestinationWells,convertedIndices},
	(* Accept the input as it is as converted containers *)
	convertedCollectionContainers = inputCollectionContainers;
	(* Create a nested list of the same size and fill with Automatic as converted wells *)
	convertedDestinationWells =inputCollectionContainers/.ObjectP[]->Automatic;
	(* Create a nested list of the same size and fill with Null as converted indices *)
	convertedIndices =inputCollectionContainers/. ObjectP[]->Null;
	(* Return the converted lists *)
	{convertedCollectionContainers, convertedDestinationWells, convertedIndices}
];

(*Overload for a nested list of Indices and Containers*)
convertInputContainerFormat[inputIndicesAndCollectionContainers:
		ListableP[
			{GreaterEqualP[1, 1], _String|ObjectP[Model[Container]]},3
		]]:= Module[
	{convertedCollectionContainers,convertedDestinationWells,convertedIndices},
	(* Remove the indices from the input as converted containers *)
	convertedCollectionContainers = inputIndicesAndCollectionContainers/.{GreaterEqualP[1, 1],x:ObjectP[]}:>x;
	(* Create a nested list of the same size and fill with Automatic as converted wells *)
	convertedDestinationWells = inputIndicesAndCollectionContainers/. {GreaterEqualP[1, 1],ObjectP[]} -> Automatic;
	(* Remove the container objects from the input as converted indices *)
	convertedIndices = inputIndicesAndCollectionContainers/.{x:GreaterEqualP[1, 1],ObjectP[]}:>x;
	(* Return the converted lists *)
	{convertedCollectionContainers,convertedDestinationWells,convertedIndices}
];

(* Define a helper to check for well pattern in order to pattern match in the following overloads with wells *)
wellQ[well_] := MemberQ[Flatten[AllWells[NumberOfWells -> 384]], well];

(*Overload for a nested list of Wells and Containers*)
convertInputContainerFormat[inputWellsAndCollectionContainers:
		ListableP[
			{_?wellQ,_String|ObjectP[Model[Container]]},3
		]] := Module[
	{convertedCollectionContainers,convertedDestinationWells,convertedIndices},
	(* Remove the wells from the input as converted containers *)
	convertedCollectionContainers = inputWellsAndCollectionContainers/.{_?wellQ,x:ObjectP[]}:>x;
	(* Remove the container objects from the input as converted wells *)
	convertedDestinationWells = inputWellsAndCollectionContainers/.{x_?wellQ,ObjectP[]}:>x;
	(* Create a nested list of the same size and fill with Nulls converted indices *)
	convertedIndices = inputWellsAndCollectionContainers/. {_?wellQ,ObjectP[]}->Null;
	(* Return the converted lists *)
	{convertedCollectionContainers,convertedDestinationWells,convertedIndices}
];

(*Overload for a nested list of Wells, Indices and Containers*)
convertInputContainerFormat[inputWellsIndicesAndCollectionContainers:
		ListableP[
			{_?wellQ, {GreaterEqualP[1, 1],_String|ObjectP[Model[Container]]}},3
		]]:=Module[
	{convertedCollectionContainers,convertedDestinationWells,convertedIndices},
	(* Remove the wells and indices from the input as converted containers *)
	convertedCollectionContainers = inputWellsIndicesAndCollectionContainers/.{_?wellQ,{GreaterEqualP[1,1],x:ObjectP[]}}:>x;
	(* Remove the containers and indices from the input as converted wells *)
	convertedDestinationWells = inputWellsIndicesAndCollectionContainers/.{x_?wellQ,{GreaterEqualP[1,1],ObjectP[]}}:>x;
	(* Remove the containers and wells from the input as converted indices *)
	convertedIndices = inputWellsIndicesAndCollectionContainers/.{_?wellQ,{x:GreaterEqualP[1,1],ObjectP[]}}:>x;
	(* Return the converted lists*)
	{convertedCollectionContainers,convertedDestinationWells,convertedIndices}
];

(*Overload for a nested list of Automatic or Null*)
convertInputContainerFormat[inputAutomaticNull:
		ListableP[
			Automatic|Null,3
		]]:= Module[
	{convertedCollectionContainers,convertedDestinationWells,convertedIndices},
	(* Accept the input as it is as converted containers *)
	convertedCollectionContainers = inputAutomaticNull;
	(* Accept the input as it is as converted wells *)
	convertedDestinationWells = inputAutomaticNull;
	(* If the container input is automatic, we do not set indices, leave them as null  *)
	convertedIndices = inputAutomaticNull/.Automatic->Null;
	(* Return the converted lists*)
	{convertedCollectionContainers,convertedDestinationWells,convertedIndices}
];
(*Helper function to expand elution collection options when the length is one and does not match sample length of one batch. Assume this means the user wants to pool the collected samples from the batch, or multiple washes *)
expandStageCollectionHelper[sampleOrRepeatNumbers_Integer,unexpandedOption:ListableP[Alternatives[Automatic,Null,ObjectP[],_String,_Integer],1]]:=
    If[And[EqualQ[Length[ToList[unexpandedOption]], 1],
      GreaterQ[sampleOrRepeatNumbers, 1]
      (*!MatchQ[unexpandedOption,ListableP[Automatic|Null]]*)],

      (*If the option value is not Automatic or Null, and length is one while there are multiple samples/rounds, get it expanded to be index matched to sample or repeat length.*)
      ConstantArray[unexpandedOption, sampleOrRepeatNumbers],

      (*Otherwise nothing needs to be modified*)
      unexpandedOption
    ];
(*Overload for if the unexpanded option is already a level-2 list. We would need to strip a list if there is only one singleton while having multiple samples/repeats. Because in some cases, {{singleton}} is treated as a singleton due to the adder-inside-adder in the collection container option definition*)
expandStageCollectionHelper[sampleOrRepeatNumbers_Integer,unexpandedOption: {{Alternatives[Automatic, Null, ObjectP[], _String, _Integer]..}..}]:=
    If[And[EqualQ[Length[ToList[unexpandedOption]], 1],
      GreaterQ[sampleOrRepeatNumbers, 1]
      (*!MatchQ[unexpandedOption,ListableP[Automatic|Null]]*)],

      (*If the option value is not Automatic or Null, and length is one while there are multiple samples/rounds, get it expanded to be index matched to sample or repeat length.*)
      ConstantArray[unexpandedOption[[1]], sampleOrRepeatNumbers],

      (*Otherwise nothing needs to be modified*)
      unexpandedOption
    ];
(*Helper function to expand collection options when the length is one and does not match sample length of one batch. Assume this means the user wants to pool the collected samples from the batch, or multiple washes *)
expandStageCollectionOption[
  nestedSamples:ListableP[ObjectP[],2],
  unexpandedOption:ListableP[Alternatives[Automatic,Null,ObjectP[],_String,_Integer],3],
  unresolvedNumberOfStages:ListableP[Alternatives[Automatic,Null,_Integer],2]
]:=If[MatchQ[unresolvedNumberOfStages,ListableP[Automatic|_Integer,3]],
  (*If the stage is performed, i.e. NumberOfStage is not list of Nulls, might need to expand the option*)
  Module[{nestedNumberOfStages},
    nestedNumberOfStages = If[!MatchQ[unresolvedNumberOfStages,_List],
      (*If it is a singleton,i.e. Automatic, Null, Number.., make array of that repeated sington and nest it*)
      unflattenListHelper[
        ConstantArray[unresolvedNumberOfStages,Length[Flatten[nestedSamples]]],
        nestedSamples
      ],
      (*Otherwise it is a list. It may or may not be correctly index matched (i.e. could be not properly index matched so that the unflattenListHelp will error. So we do a conditional thus has to be taken as index-matched*)
      unflattenListHelper[Flatten[unresolvedNumberOfStages],nestedSamples]
    ];
    (*If unexpanded option is the same in batch length as the samples*)
    If[MatchQ[Length[unexpandedOption/.ObjectP->Null],Length[nestedSamples]],
      MapThread[
        Function[{samplesBatch,OptionValuesBatch,numberOfStagesBatch},
          Module[{optionValues},
            optionValues = expandStageCollectionHelper[Length[samplesBatch],OptionValuesBatch];
            MapThread[
              Function[{optionValue,numberOfStage},
                expandStageCollectionHelper[numberOfStage/.Automatic->1,optionValue]
              ],
              {optionValues,numberOfStagesBatch}
            ]
          ]
        ],
        {nestedSamples,unexpandedOption,nestedNumberOfStages}
      ],
      (*Otherwise, we might have multiple batches but one option values*)
      MapThread[
        Function[{samplesBatch,numberOfStagesBatch},
          Module[{optionValues},
            optionValues = expandStageCollectionHelper[Length[samplesBatch],unexpandedOption];
            MapThread[
              Function[{optionValue,numberOfStage},
                expandStageCollectionHelper[numberOfStage/.Automatic->1,optionValue]
              ],
              {optionValues,numberOfStagesBatch}
            ]
          ]
        ],
        {nestedSamples,nestedNumberOfStages}
      ]
    ]
  ],
  (*Otherwise the stage is not performed, i.e. NumberOfStage is a  list of Nulls, no need to expand the StageCollectioContainer *)
  unexpandedOption
];

(* Helper function that gets all magnetic bead identity models and memoizes it so that the resolver can go fast *)
allActiveMagneticBeadIdentityModels[fakeString_String]:=allActiveMagneticBeadIdentityModels[fakeString] = Module[{},
  (*Add allActiveMagneticBeadIdentityModels to list of Memoized functions*)
  AppendTo[$Memoization,Experiment`Private`allActiveMagneticBeadIdentityModels];
  (*If we are on manifold, we need to require $SessionUUID in search in order to avoid getting test objects created for other unit tests*)
  If[MatchQ[$ManifoldComputation,ObjectP[]],
    Block[{$RequiredSearchName = $SessionUUID}, Search[Model[Resin],Magnetic==True]],
    Search[Model[Resin],Magnetic==True]
  ]
];

(* Helper function that gets all magnetization rack models and memoizes it so that the resolver can go fast *)
allActiveMagnetizationRacks[fakeString_String]:=allActiveMagnetizationRacks[fakeString] = Module[
	{},
	(*Add allActiveMagnetizationRacks to list of Memoized functions*)
	AppendTo[$Memoization,Experiment`Private`allActiveMagnetizationRacks];
	Flatten@Search[
		{Model[Container,Rack],Model[Item,MagnetizationRack]},
		{Magnetized==True&&Deprecated!=True&&DeveloperObject!=True,Deprecated!=True&&DeveloperObject!=True}
	]
];

(*Helper function to resolve mix options for each stage. *)
resolveMixOptionsForStage[
	resolvedStageMasterswitch:BooleanP,
	volumeToMix:Alternatives[VolumeP,Automatic,Null],
	resolvedPreparation:PreparationMethodP,
	unresolvedMixMasterswitch:Alternatives[BooleanP,Automatic,Null],
	unresolvedMixType:Alternatives[MixTypeP,Automatic,Null],
	unresolvedMixVolume:Alternatives[VolumeP,Automatic,Null],
	unresolvedMixTime:Alternatives[TimeP,Automatic,Null],
	unresolvedMixTemperature:Alternatives[TemperatureP,Ambient,Automatic,Null],
	unresolvedMixRate:Alternatives[_?QuantityQ,Automatic,Null],
	unresolvedNumberOfMixes:Alternatives[_Integer,Automatic,Null],
	unresolvedMixTipType:Alternatives[TipTypeP,Automatic,Null],
	unresolvedMixTipMaterial:Alternatives[MaterialP,Automatic,Null]
]:= Module[
	{resolvedMixMasterswitch, resolvedMixType, resolvedMixVolume,
		resolvedMixTime, resolvedMixTemperature, resolvedMixRate,
		resolvedNumberOfMixes, resolvedMixTipType, resolvedMixTipMaterial},

	(*Resolve MixMasterswitch*)
	resolvedMixMasterswitch = If[
		(*If the option is Automatic,resolve it*)
		MatchQ[unresolvedMixMasterswitch, Automatic],
		(*If resolvedStageMasterswitch is True, resolve based on unresolvedMixType*)
		If[
			MatchQ[resolvedStageMasterswitch, True],
			(*Resolve to False if unresolvedMixType is specified as Null, to True otherwise*)
			If[MatchQ[unresolvedMixType, Null],
				False,
				True],
			(*If resolvedStageMasterswitch is not True, resolve to Null*)
			Null
		],
		(*If the option is specified,accept it*)
		unresolvedMixMasterswitch
	];

	(*Resolve MixType*)
	resolvedMixType = If[
		(*If the option is Automatic,resolve it*)
		MatchQ[unresolvedMixType,Automatic],
		(*If resolvedMixMasterswitch is True, resolve it based on other mix options settings *)
		If[MatchQ[resolvedMixMasterswitch,True],
			Which[
				(*If none of the MixRate,MixTime,MixTemperature is user specified as other than default or Null, and the volume to mix is larger than 20 microliter, resolve to Pipette*)
				MatchQ[{unresolvedMixRate,unresolvedMixTime,unresolvedMixTemperature}, {Automatic|Null,Automatic|Null,Automatic|Ambient|Null}]&&GreaterQ[volumeToMix,20 Microliter],
				Pipette,
				(*If resolvedPreparation is Manual, and MixTemperature is Automatic/Ambient/Null, and the MixRate > 600RPM, resolve to Vortex *)
				MatchQ[resolvedPreparation, Manual]&&MatchQ[unresolvedMixTemperature, Automatic|Ambient]&&GreaterQ[unresolvedMixRate,600 RPM],
				Vortex,
				(*Otherwise, resolve to Shake *)
				True,Shake
			],
			(*If resolvedStageMasterswitch is not True, resolve to Null*)
			Null
		],
		(*If the option is specified,accept it*)
		unresolvedMixType
	];

	(*Resolve MixVolume*)
	resolvedMixVolume = If[
		(*If the option is Automatic,resolve it*)
		MatchQ[unresolvedMixVolume, Automatic],
		(*If resolvedMixMasterswitch is True and resolvedMixType is Pipette, resolve it based on other mix options settings *)
		If[
			MatchQ[resolvedMixMasterswitch, True] && MatchQ[resolvedMixType, Pipette],
			Which[
				(*When Preparation is Robotic and SafeRound[volumeToMix*0.8, 0.1 Microliter] is larger than 970 Microliter, resolve to 970 Microliter*)
				MatchQ[resolvedPreparation, Robotic] &&	GreaterQ[SafeRound[volumeToMix*0.8, 0.1 Microliter], 970 Microliter], 970 Microliter,
				(*Otherwise when Preparation is Robotic, resolve to the greater of 10 Microliter and SafeRound[volumeToMix*0.8, 0.1 Microliter]*)
				MatchQ[resolvedPreparation, Robotic], Max[SafeRound[volumeToMix*0.8, 0.1 Microliter], 10 Microliter],
				(*When Preparation is Manual, and SafeRound[volumeToMix*0.8, 0.1 Microliter] is larger than 50 Milliliter, resolve to 50 Milliliter*)
				GreaterQ[SafeRound[volumeToMix*0.8, 0.1 Microliter], 50 Milliliter], 50 Milliliter,
				(*Otherwise when preparation is Manual, resolve to SafeRound[volumeToMix*0.8, 0.1 Microliter]*)
				True, SafeRound[volumeToMix*0.8, 0.1 Microliter]
			],
			(*If resolvedStageMasterswitch is not True or resolvedMixType is not Pipette, resolve to Null*)
			Null
		],
		(*If the option is specified,accept it*)
		unresolvedMixVolume
	];

	(*Resolve MixTime*)
	resolvedMixTime = If[
		(*If the option is Automatic,resolve it*)
		MatchQ[unresolvedMixTime, Automatic],
		(*If resolvedMixMasterswitch is True and resolvedMixType is one of {Disrupt,Nutate,Shake,Vortex,Roll,Stir,Homogenize,Sonicate}, resolve it based on other mix options settings *)
		If[
			MatchQ[resolvedMixMasterswitch, True] && MemberQ[{Disrupt, Nutate, Shake, Vortex, Roll, Stir,Homogenize, Sonicate},resolvedMixType],
			(*If resolvedPreparation is Robotic, resolve to 5 Minute*)
			If[MatchQ[resolvedPreparation, Robotic],
				5 Minute,
				(*If resolvedPreparation is Manual, resolve to 15 Minute*)
				15 Minute],
			(*If resolvedStageMasterswitch is not True or resolvedMixType is not one of {Disrupt,Nutate,Shake,Vortex,Roll,Stir,Homogenize,Sonicate}, resolve to Null*)
			Null
		],
		(*If the option is specified,accept it*)
		unresolvedMixTime
	];

	(*Resolve MixTemperature*)
	resolvedMixTemperature = If[
		(*If the option is Automatic,resolve it*)
		MatchQ[unresolvedMixTemperature, Automatic],
		(*If resolvedMixMasterswitch is True and resolvedMixType is not Null, resolve it to Ambient *)
		If[MatchQ[resolvedMixMasterswitch, True] && !MatchQ[resolvedMixType, Null],
			Ambient,
			(*Otherwise, resolve to Null*)
			Null],
		(*If the option is specified,accept it*)
		unresolvedMixTemperature
	];

	(*Resolve MixRate*)
	resolvedMixRate = If[
		(*If the option is Automatic,resolve it*)
		MatchQ[unresolvedMixRate, Automatic],
		(*If resolvedMixMasterswitch is True, resolve it based on MixType *)
		If[MatchQ[resolvedMixMasterswitch, True],
			Which[
				(*When resolvedMixType is one of {Shake,Stir}, resolve to 300 RPM*)
				MatchQ[resolvedMixType, Shake | Stir], 300 RPM,
				(*When resolvedMixType is {Vortex,Disrupt}, resolve to 1000 RPM*)
				MatchQ[resolvedMixType, Vortex | Disrupt], 1000 RPM,
				(*When resolvedMixType is one of {Nutate,Roll}, resolve to 30 RPM*)
				MatchQ[resolvedMixType, Nutate | Roll], 30 RPM,
				(*Otherwise, i.e. the resolvedMixType is Sonicate|Pipette|Invert|Homogenize|Swirl, set to Null*)
				True,	Null
			],
			(*If resolvedStageMasterswitch is not True, resolve to Null*)
			Null],
		(*If the option is specified,accept it*)
		unresolvedMixRate
	];

	(*Resolve NumberOfMixes*)
	resolvedNumberOfMixes = If[
		(*If the option is Automatic,resolve it*)
		MatchQ[unresolvedNumberOfMixes, Automatic],
		Which[
			(*If resolvedMixMasterswitch is True and resolvedMixType is Pipette, resolve to 20 *)
			MatchQ[resolvedMixMasterswitch, True] && MatchQ[resolvedMixType, Pipette], 20,
			(*If resolvedMixMasterswitch is True and resolvedMixType is Swirl or Invert, resolve to 20 *)
			MatchQ[resolvedMixMasterswitch, True] && MatchQ[resolvedMixType, Swirl | Invert], 20,
			(*Otherwise, resolve to Null*)
			True, Null
		],
		(*If the option is specified,accept it*)
		unresolvedNumberOfMixes
	];

	(*Resolve MixTipType*)
	resolvedMixTipType = If[
		(*If the option is Automatic,resolve it*)
		MatchQ[unresolvedMixTipType, Automatic],
		(*If resolvedMixMasterswitch is True and resolvedMixType is Pipette, resolve it based on other mix options settings *)
		If[MatchQ[resolvedMixMasterswitch, True] &&	MatchQ[resolvedMixType, Pipette],
			(*When Preparation is Robotic or resolvedMixVolume is no larger than 970 Microliter, resolve to Widebore*)
			Which[
				(* Use only WideBore for robotic preparation *)
				MatchQ[resolvedPreparation, Robotic], WideBore,
				(* For mix volume no larger than 970 uL, set  to WideBore *)
				LessEqualQ[resolvedMixVolume, 970 Microliter], WideBore,
				(* For mix volume no larger than 5 mL, set to Normal *)
				LessEqualQ[resolvedMixVolume, 5 Milliliter], Normal,
				(* For mix volume larger than 5 mL, set  to Barrier *)
				True,Barrier
			],
			(*If resolvedStageMasterswitch is not True or resolvedMixType is not Pipette, resolve to Null*)
			Null],
		(*If the option is specified,accept it*)
		unresolvedMixTipType
	];

	(*Resolve MixTipMaterial*)
	resolvedMixTipMaterial = If[
		(*If the option is Automatic,resolve it based on resolvedMixVolume*)
		MatchQ[unresolvedMixTipMaterial, Automatic],

		(*If resolvedMixMasterswitch is True and resolvedMixType is Pipette, resolve it based on other mix options settings *)
		If[MatchQ[resolvedMixMasterswitch, True] &&	MatchQ[resolvedMixType, Pipette],
			(* Set to Glass if resolvedMixVolume is larger than 5 Milliliter, and to Polypropylene otherwise *)
			If[GreaterQ[resolvedMixVolume,5 Milliliter],
				Glass,
				Polypropylene
			],
			(*If resolvedStageMasterswitch is not True or resolvedMixType is not Pipette, resolve to Null*)
			Null
		],
		(*If the option is specified,accept it*)
		unresolvedMixTipMaterial
	];

	(*Return resolved mix options for a stage*)
	{resolvedMixMasterswitch, resolvedMixType, resolvedMixVolume,
		resolvedMixTime, resolvedMixTemperature, resolvedMixRate,
		resolvedNumberOfMixes, resolvedMixTipType, resolvedMixTipMaterial}
];

(*Helper function to collapse container indices, in case CollectionContainer is specified to imply pooling, but the indices were expanded so that conflicting storage condition checking was failing*)
collapseContainerIndices[
  resolvedContainerIndices:ListableP[Alternatives[Null,_Integer],3],
  resolvedCollectionContainers:ListableP[Alternatives[Null,ObjectP[]],3]
]:=MapThread[
  Function[{containers,indices},
    (*If the length matches for containers and indices, output indices. Otherwise, collapse by deleting duplicates because we expanded indices by created duplicates*)
    If[EqualQ[Length[containers],Length[indices]],
      indices,
      DeleteDuplicates[indices]
    ]
  ],
  {resolvedCollectionContainers,resolvedContainerIndices}
];

(*Helper Function to gather conflicting storage condition info for each stage in the resolver. Samples collected on the same container cannot have different storage conditions*)
gatherConflictingStorageConditionInfo[
	stageStorageConditions:ListableP[Alternatives[Null,SampleStorageTypeP,Disposal,ObjectP[]]],
	stageContainers:ListableP[Alternatives[Null,ObjectP[]],2],
	stageIndices:ListableP[Alternatives[Null,_Integer],2],
	initialStorageConditionLookup_Association,
	initialAllContainers_Association,
	downloadedStorageConditionPackets:ListableP[PacketP[],3]|{}
]:= Module[
	{currentStorageConditionLookup,currentAllContainers,conflictingStorageConditions},
	currentStorageConditionLookup=initialStorageConditionLookup;
	currentAllContainers=initialAllContainers;
	conflictingStorageConditions=Flatten[
		MapThread[
			Function[{storageCondition, containers, indices},
				MapThread[
					Function[{container,index},
						Module[{storedStorageCondition,storageConditionType},

							(* Convert Object to SampleStorageTypeP if storage condition is selected as an object *)
							storageConditionType=If[MatchQ[storageCondition,ObjectP[Model[StorageCondition]]],
								Lookup[Cases[Flatten@downloadedStorageConditionPackets,KeyValuePattern[Object->storageCondition]],StorageCondition,Null],
								storageCondition
							];

							(* If the container is an object, or a model with index, see if there is already a specified storage condition *)
							Which[
								MatchQ[container,ObjectP[Object[Container]]],
								Module[{},
									(* Keep track of all the object containers *)
									currentAllContainers[container] = Null;

									(* See if there is a storage condition for this container already *)
									storedStorageCondition = Lookup[currentStorageConditionLookup,container,Null];

									(* If the specified storage condition does not match, mark the container *)
									If[!NullQ[storedStorageCondition]&&!MatchQ[storedStorageCondition,storageConditionType],
										container,
										(* Otherwise add the container to the lookup *)
										currentStorageConditionLookup[container] = storageCondition;
										Nothing
									]
								],
								MatchQ[container,ObjectP[Model[Container]]]&&MatchQ[index,GreaterEqualP[1,1]],
								Module[{},
									(* Keep track of all the object containers *)
									currentAllContainers[container] = Null;

									(* See if there is a storage condition for this container already *)
									storedStorageCondition = Lookup[currentStorageConditionLookup,Key[{container,index}],Null];

									(* If the specified storage condition does not match, mark the container *)
									If[!NullQ[storedStorageCondition]&&!MatchQ[storedStorageCondition,storageConditionType],
										container,
										(* Otherwise add the container to the lookup *)
										currentStorageConditionLookup[{container,index}] = storageCondition;
										Nothing
									]
								],

								(*If the container is neither an object nor a model with index, no need to check conflict*)
								True,Nothing
							]
						]
					],
					{containers,indices}
				]
			],
			{stageStorageConditions,stageContainers,stageIndices}
		]
	];
	(*Return the conflicting storage condition and updated associations*)
	{conflictingStorageConditions,currentStorageConditionLookup,currentAllContainers}
];


(*Helper function to correct the storage conditions of collection containers. If there are Object[Container]'s with multiple specified storage conditions, make them all have the same so errors do not get thrown later on in the simulation function. *)
correctStorageConditionsOfStage[
	resolvedStageCollectionStorageConditions:ListableP[Alternatives[Null,SampleStorageTypeP,Disposal,ObjectP[]],3],
	resolvedStageCollectionContainers:ListableP[Alternatives[Null,ObjectP[]],3],
	gatheredStorageConditionLookup_Association
]:=Flatten@MapThread[
	Function[{storageCondition,containers},
		Module[{containerObject},
			(* If there is a container object, use the storage condition in the lookup, otherwise use the storage condition already given *)
			containerObject = FirstCase[containers,ObjectP[Object[Container]],Null];
			If[!NullQ[containerObject],
				Lookup[gatheredStorageConditionLookup,containerObject],
				storageCondition
			]
		]
	],
	{resolvedStageCollectionStorageConditions,resolvedStageCollectionContainers}
];

(* Helper function to correct dimensions of options of collection containers, destination wells, container indices, and container labels based on number of repetitions of the stage *)
correctOptionsDimensions[
	stageSamples:ListableP[ObjectP[],3],
	stageCollectionContainers:ListableP[Alternatives[Automatic,Null,ObjectP[]],3],
	stageDestinationWells:ListableP[Alternatives[Automatic,Null,_String],3],
	stageCollectionContainerIndices:ListableP[Alternatives[Automatic,Null,_Integer],3],
	stageCollectionContainerLabels:ListableP[Alternatives[Automatic,Null,_String],3],
	stageNumberOfRepetitions:ListableP[Alternatives[Null,_Integer],3]
]:= MapThread[
	Function[{samples,collectionContainers,destinationWells,collectionContainerIndices,collectionContainerLabels, numberOfRepetitions},
		MapThread[
			Function[{sample,collectionContainer,destinationWell,collectionContainerIndex,collectionContainerLabel,repetitions},
				{
					(* if something is mismatched *)
					If[(Length[collectionContainer]!=repetitions)||(Length[ToList[destinationWell]]!=repetitions)||(Length[collectionContainerLabel]!=repetitions),
						sample,
						Null
					],
					If[(Length[collectionContainer]!=repetitions),
						ConstantArray[First[collectionContainer],repetitions],
						collectionContainer
					],
					If[(Length[ToList[destinationWell]]!=repetitions),
						ConstantArray[First[ToList[destinationWell]],repetitions],
						ToList[destinationWell]
					],
					If[(Length[collectionContainerIndex]!=repetitions),
						ConstantArray[First[collectionContainerIndex],repetitions],
						collectionContainerIndex
					],
					If[(Length[collectionContainerLabel]!=repetitions),
						ConstantArray[First[collectionContainerLabel],repetitions],
						collectionContainerLabel
					]
				}
			],
			{
				samples,
				collectionContainers,
				destinationWells,
				collectionContainerIndices,
				collectionContainerLabels,
				numberOfRepetitions
			}
		]
	],
	{
		stageSamples,
		stageCollectionContainers,
		stageDestinationWells,
		stageCollectionContainerIndices,
		stageCollectionContainerLabels,
		stageNumberOfRepetitions
	}
];
(*Helper Function to resolve destination wells and collection container labels based on collection container, storage condition, and label information *)
resolveDestinationWellsAndContainerLabelsOfStage[
	stageCollectionContainersBatch:ListableP[Alternatives[Null,Automatic,ObjectP[]],2],
	stageDestinationWellsBatch:ListableP[Alternatives[Null,Automatic,_String],2],
	stageCollectionContainerIndicesBatch:ListableP[Alternatives[Null,Automatic,_Integer],2],
	stageCollectionContainerLabelsBatch:ListableP[Alternatives[Null,Automatic,_String],2],
	stageCollectionStorageConditionsBatch:ListableP[Alternatives[Null,SampleStorageTypeP,Disposal,ObjectP[]],2],
	stageBoolsBatch:ListableP[Alternatives[Null,BooleanP],2],
	samplesBatch:ListableP[ObjectP[],2],
	initialCollectionContainerLookup_Association,
	initialInvalidDestinationWells_List,
	initialNoAvailablePositionsInContainer_List,
	combinedAssocForLookup_Association,
	stageLabelPrefix_String
]:=Module[
	{currentCollectionContainerLookup, currentInvalidDestinationWells, currentNoAvailablePositionsInContainer,output},

	currentCollectionContainerLookup = initialCollectionContainerLookup;
	currentInvalidDestinationWells = initialInvalidDestinationWells;
	currentNoAvailablePositionsInContainer = initialNoAvailablePositionsInContainer;

	output=MapThread[
		Function[{collectionContainers,destinationWells,collectionContainerIndices,collectionContainerLabels,collectionStorageCondition,stageBools,simulatedSample},
			If[stageBools,
				Transpose@MapThread[
					Function[{collectionContainer,destinationWell,collectionContainerIndex,collectionContainerLabel},
						Module[{availableContainerInfo},

							availableContainerInfo=Lookup[
								currentCollectionContainerLookup,
								Key[{collectionContainer,collectionContainerIndex,collectionStorageCondition}],
								Null
							];

							(* Was there an available container? (Matching object/model with available positions and same storage condition) *)
							If[And[
								!NullQ[availableContainerInfo],
								Or[(*It is a Vessel, and the index is a number, i.e. the available container was found by container-index-storagecondition match. Then we want to pool the samples*)
                  MatchQ[collectionContainerIndex,_Integer]&&                  EqualQ[Length[Lookup[availableContainerInfo,AllowedPositions]],1],
                  (*There are available positions (i.e. container is a plate*)
                  Length[Lookup[availableContainerInfo,AvailablePositions]]>0
                ]
							],

								(* Yes there was an available container *)
								Module[{containerLabel,allowedPositions,availablePositions,newPositionToOccupy},

									(* Get the info about the object *)
									{containerLabel,allowedPositions,availablePositions} = Lookup[availableContainerInfo, {Label,AllowedPositions,AvailablePositions}];

									(* Throw an error if the user specified destination well is not a position of the container *)
									If[MatchQ[destinationWell,_String]&&!MemberQ[allowedPositions,destinationWell],
										currentInvalidDestinationWells=Append[currentInvalidDestinationWells,{destinationWell,collectionContainer,stageLabelPrefix,simulatedSample}]
									];

									(* If the user specified a destination well, use it otherwise default to the first available position *)
									newPositionToOccupy=If[MatchQ[destinationWell,_String],
										destinationWell,
                    (*If it is a vessel, i.e. only 1 position is available, use that position. We are pooling samples.*)
										If[EqualQ[Length[allowedPositions],1],
                      FirstCase[allowedPositions,_String,"A1"],
                      First[availablePositions]
                    ]
									];

									(* update the lookup with new container information *)
									currentCollectionContainerLookup=AssociateTo[
										currentCollectionContainerLookup,
										{collectionContainer,collectionContainerIndex,collectionStorageCondition}->{
											Label->containerLabel,
											AllowedPositions->allowedPositions,
											AvailablePositions->DeleteCases[availablePositions,newPositionToOccupy]
										}
									];

									(* return the resolved collection container label and destination well *)
									{containerLabel,newPositionToOccupy}

								],

								(* No there was no an available container *)
								Module[{containerLabel,allowedPositions,occupiedPositions,availablePositions,newPositionToOccupy,positionsAvailable},

									(* Create a new label for the plate if one is not given *)
									containerLabel=If[MatchQ[collectionContainerLabel,Automatic|Null],
										CreateUniqueLabel["MBS collection container"],
										collectionContainerLabel
									];

									(* Get the allowed, occupied, and open positions in the collection container *)
									{allowedPositions,occupiedPositions}=If[MatchQ[collectionContainer,ObjectP[Object[Container]]],
										(* If the container is an object. Lookup from the cache *)
										{
											Lookup[fastAssocLookup[combinedAssocForLookup,collectionContainer, {Model,Positions}],Name],
											fastAssocLookup[combinedAssocForLookup,collectionContainer,Contents][[All,1]]
										},
										(* Otherwise if the container is a model start with all the allowed positions *)
										{
											Lookup[fastAssocLookup[combinedAssocForLookup,collectionContainer,Positions],Name],
											{}
										}
									];
									(* Available positions are those that are allowed but not occupied *)
									availablePositions=UnsortedComplement[allowedPositions,occupiedPositions];

									(* If there are no open positions and the user did not specify a destination well, throw an error *)
									If[MatchQ[availablePositions,{}]&&MatchQ[destinationWell,Null|Automatic],
										(* Throw warning and default to first used position *)
										currentNoAvailablePositionsInContainer=Append[currentNoAvailablePositionsInContainer,{collectionContainer,stageLabelPrefix,simulatedSample}];
										availablePositions={"A1"};
									];

									(* If the specified well is not an allowed position of the container, mark it and throw error outside mapthread *)
									If[MatchQ[destinationWell,_String]&&!MemberQ[allowedPositions,destinationWell],
										currentInvalidDestinationWells=Append[currentInvalidDestinationWells,{destinationWell,collectionContainer,stageLabelPrefix,simulatedSample}]
									];

									(* Determine which position to use for this sample *)
									newPositionToOccupy=If[MatchQ[destinationWell,_String],
										(* If destination well is specified, use it *)
										destinationWell,
										(* Otherwise use the first of the available positions *)
										First[availablePositions]
									];

									(* Remove the newly occupied position from the available positions *)
									positionsAvailable=DeleteCases[availablePositions,newPositionToOccupy];

									(* Update the lookup with the new plate information *)
									currentCollectionContainerLookup=AssociateTo[currentCollectionContainerLookup,
										{collectionContainer,collectionContainerIndex,collectionStorageCondition}->{
											Label->containerLabel,
											AllowedPositions->allowedPositions,
											AvailablePositions->positionsAvailable
										}
									];

									(* return the resolved collection container label and destination well *)
									{containerLabel,newPositionToOccupy}
								]
							]
						]
					],
					{collectionContainers,destinationWells,collectionContainerIndices,collectionContainerLabels}
				],
				Transpose@ConstantArray[{Null,Null},Length[collectionContainers]]
			]
		],
		{stageCollectionContainersBatch, stageDestinationWellsBatch, stageCollectionContainerIndicesBatch, stageCollectionContainerLabelsBatch, stageCollectionStorageConditionsBatch, stageBoolsBatch, samplesBatch}
	];
	(*Return the output and the updated associations and lists*)
	{output,currentCollectionContainerLookup, currentInvalidDestinationWells, currentNoAvailablePositionsInContainer}
];

(*Helper function returns a flat list of pre resolved options of a batch. To be called when pre resolve an option, i.e. propagate any user input within the batch, if there is non-Automatic in user input (either single Automatic, or the batch with index-matched containing Automatic).*)
preResolveOneOptionOfBatch[
	mapThreadFriendlyBatch:ListableP[Alternatives[Automatic,Null,BooleanP,TimeP,MixTypeP,TemperatureP,Ambient,_?QuantityQ, _Integer]]
]:= If[MemberQ[mapThreadFriendlyBatch,Automatic]&&!MatchQ[mapThreadFriendlyBatch,ListableP[Automatic]],
	(*If the input specified by the user has Automatic but also contains an actual specification, propagate the commonest non-Automatic specification within the batch.*)
	Module[
		{resultPick},
		(*Find the commonest non-Automatic user specification within the batch*)
		resultPick=Commonest[DeleteCases[mapThreadFriendlyBatch,Automatic],UpTo[1]];
		Flatten[Replace[mapThreadFriendlyBatch, Automatic -> resultPick, 1]]
	],
	(*Otherwise, the input is fully Automatic or user specified, no need to change*)
	mapThreadFriendlyBatch
];
(*Helper function returns a flat list of one pre resolved option of a stage. To be called when pre resolve an option, i.e. propagate any user input within the batch, if there is non-Automatic in user input (either single Automatic, or the batch with index-matched containing Automatic).*)
preResolveOneOptionOfStage[
	samples:ListableP[ObjectP[],3],
	flatResolvedAssayContainers:ListableP[ObjectP[],3],
	flatMapThreadFriendly:ListableP[Alternatives[Automatic,Null,BooleanP,TimeP,MixTypeP,TemperatureP,Ambient,_?QuantityQ, _Integer]]
]:=Flatten@MapThread[
	(*Mapthread over mapthread-friendly values and assay containers to check whether to pre-resolve the options*)
	Function[{samplesBatch,resolvedAssayContainersBatch,mapThreadFriendlyBatch},
		(*If the input specified by the user has non-Automatic values and the resolved assay container of this batch is plate, call the pre resolver*)
		If[MemberQ[mapThreadFriendlyBatch,Except[Automatic]]&&MatchQ[resolvedAssayContainersBatch,{ObjectP[Model[Container,Plate]]..}],
			preResolveOneOptionOfBatch[mapThreadFriendlyBatch],
			(*Otherwise, the resolved assay container of this batch is not plate, different settings are allowed*)
			mapThreadFriendlyBatch
		]
	],
	{
		samples,
   		unflattenListHelper[flatResolvedAssayContainers,samples],
    	unflattenListHelper[flatMapThreadFriendly,samples]
	}
];
(*Helper function returns flat lists of pre resolved mix option of a stage. To be called when pre resolve an option, i.e. propagate any user input within the batch, depending on mixtype, if there is non-Automatic in user input (either single Automatic, or the batch with index-matched containing Automatic). Note that MixVolume, MixTipType and MixTipMaterial are only for pipette mixing, and this mix type does not affect the whole container, so they do not need to be pre-resolved*)
preResolveMixOptionsOfStage[
	samples:ListableP[ObjectP[],3],
	flatResolvedAssayContainers:ListableP[ObjectP[]],
	flatMixTypes:ListableP[Alternatives[MixTypeP,Automatic,Null]],
	flatMixTimes:ListableP[Alternatives[TimeP,Automatic,Null]],
	flatMixTemperatures:ListableP[Alternatives[TemperatureP,Ambient,Automatic,Null]],
	flatMixRates:ListableP[Alternatives[_?QuantityQ,Automatic,Null]],
	flatNumbersOfMixes:ListableP[Alternatives[_Integer,Automatic,Null]]
]:=Module[
	{fullContainerMixTypes,preResolvedMixTypes,preResolvedMixTimes,preResolvedMixTemperatures,preResolvedMixRates,preResolvedNumbersOfMixes},
	(* MixTypes which will affect an entire container *)
	fullContainerMixTypes = {Roll, Vortex, Invert, Shake, Swirl, Disrupt, Nutate};

	(*If there is any mix type specified that affects the whole container, go through the mapthread to check batch by batch.*)
	preResolvedMixTypes=If[ContainsAny[flatMixTypes,fullContainerMixTypes],
		Flatten@MapThread[
			Function[{samplesBatch,resolvedAssayContainersBatch,mixTypesBatch},
				(*If the resolved assay container is plate and there is full-container mix type in this batch, call the pre resolver to modify resolved mixtypes*)
				If[MatchQ[resolvedAssayContainersBatch,{ObjectP[Model[Container,Plate]]..}]&&ContainsAny[mixTypesBatch,fullContainerMixTypes],
					preResolveOneOptionOfBatch[mixTypesBatch],
					(*Otherwise, the resolved assay container is not a plate or there is no full-container mix type, different settings are allowed, then used resolved values*)
					mixTypesBatch
				]
			],
			{
				samples,
        unflattenListHelper[flatResolvedAssayContainers,samples],
        unflattenListHelper[flatMixTypes,samples]
			}
		],
		(*If there is no mix type that affects the whole container, returned the resolved values*)
		flatMixTypes
	];
	(*Mix Temperature, rate, and time affect the entire container if it is a plate*)
	preResolvedMixTemperatures=Flatten@MapThread[
		Function[{samplesBatch,resolvedAssayContainersBatch,mixTemperaturesBatch},
			(*If the resolved assay container is plate, call the pre resolver to modify resolved mixTemperatures*)
			If[MatchQ[resolvedAssayContainersBatch,{ObjectP[Model[Container,Plate]]..}],
				preResolveOneOptionOfBatch[mixTemperaturesBatch],
				(*Otherwise, the resolved assay container is not a plate or there is no full-container mix type, different settings are allowed, then used resolved values*)
				mixTemperaturesBatch
			]
		],
		{
			samples,
			unflattenListHelper[flatResolvedAssayContainers,samples],
			unflattenListHelper[flatMixTemperatures,samples]
		}
	];
	preResolvedMixRates=Flatten@MapThread[
		Function[{samplesBatch,resolvedAssayContainersBatch,mixRatesBatch},
			(*If the resolved assay container is plate, call the pre resolver to modify resolved mixRates*)
			If[MatchQ[resolvedAssayContainersBatch,{ObjectP[Model[Container,Plate]]..}],
				preResolveOneOptionOfBatch[mixRatesBatch],
				(*Otherwise, the resolved assay container is not a plate or there is no full-container mix type, different settings are allowed, then used resolved values*)
				mixRatesBatch
			]
		],
		{
			samples,
			unflattenListHelper[flatResolvedAssayContainers,samples],
			unflattenListHelper[flatMixRates,samples]
		}
	];
	preResolvedMixTimes=Flatten@MapThread[
		Function[{samplesBatch,resolvedAssayContainersBatch,mixTimesBatch},
			(*If the resolved assay container is plate, call the pre resolver to modify resolved mixTimes*)
			If[MatchQ[resolvedAssayContainersBatch,{ObjectP[Model[Container,Plate]]..}],
				preResolveOneOptionOfBatch[mixTimesBatch],
				(*Otherwise, the resolved assay container is not a plate or there is no full-container mix type, different settings are allowed, then used resolved values*)
				mixTimesBatch
			]
		],
		{
			samples,
			unflattenListHelper[flatResolvedAssayContainers,samples],
			unflattenListHelper[flatMixTimes,samples]
		}
	];
	(*number of mixes affects the entire plate only when the mix type is Swirl or Invert*)
	preResolvedNumbersOfMixes=Flatten@MapThread[
		Function[{samplesBatch,resolvedAssayContainersBatch,preResolvedMixTypesBatch,numberOfMixesBatch},
			(*If the resolved assay container is plate, and the preResolvedMixTypesBatch is a list of Invert or Swirl, call the pre resolver to modify resolved numberOfMixes*)
			If[MatchQ[resolvedAssayContainersBatch,{ObjectP[Model[Container,Plate]]..}]&&MatchQ[preResolvedMixTypesBatch,{Alternatives[Invert,Swirl]..}],
				preResolveOneOptionOfBatch[numberOfMixesBatch],
				(*Otherwise, the resolved assay container is not a plate or there is no full-container mix type, different settings are allowed, then used resolved values*)
				numberOfMixesBatch
			]
		],
		{
			samples,
			unflattenListHelper[flatResolvedAssayContainers,samples],
			unflattenListHelper[preResolvedMixTypes,samples],
			unflattenListHelper[flatNumbersOfMixes,samples]
		}
	];
	(*Return the pre-resolved mix options*)
	{preResolvedMixTypes,preResolvedMixTimes,preResolvedMixTemperatures,preResolvedMixRates,preResolvedNumbersOfMixes}
];

(* Helper function to resolve AspirationPosition and AspirationPositionOffset options for a stage*)
resolveAspirationPipettingOptionsOfStage[
  resolvedStageMasterswitch:Alternatives[BooleanP,Null],
  preparation:PreparationMethodP,
  magnetizationRackModel:ObjectP[{Model[Container,Rack],Model[Item,MagnetizationRack]}],
  inputAspirationPosition:Alternatives[Null,Automatic,MagneticBeadSeparationPipettingPositionP],
  inputAspirationPositionOffset:Alternatives[Null,Automatic,GreaterEqualP[0 Millimeter],Coordinate[{DistanceP, DistanceP, GreaterEqualP[0 Millimeter]}]]
]:=Module[{resolvedAspirationPosition, resolvedAspirationPositionOffset},
  (*Resolve AspirationPosition*)
  resolvedAspirationPosition=If[MatchQ[inputAspirationPosition,Automatic],
    If[resolvedStageMasterswitch&&MatchQ[preparation,Robotic]&&!NullQ[inputAspirationPositionOffset],
      (* The option is Automatic, If we are in Robotic prep and the stage is on, and the other option is not set to Null, resolve to Bottom *)
      Bottom,
      (* Otherwise this option is not applicable, set to Null *)
      Null
    ],
    (*If the option is specified, accept it*)
    inputAspirationPosition
  ];
  resolvedAspirationPositionOffset=If[MatchQ[inputAspirationPositionOffset,Automatic],
    Which[
      (*If the magnetization rack is Model[Item,MagnetizationRack,"Alpaqua Magnum FLX Enhanced Universal Magnet 96-well Plate Rack"] and the aspiration position is Bottom, set it to 0 mm to push down a bit for better aspiration*)
      MatchQ[magnetizationRackModel,ObjectP[Model[Item,MagnetizationRack,"Alpaqua Magnum FLX Enhanced Universal Magnet 96-well Plate Rack"]]]&&MatchQ[resolvedAspirationPosition,Bottom],
        0 Millimeter,
      (*Otherwise if we have a non-Null resolvedAspirationPosition, set to 2 Millimeter *)
      MatchQ[resolvedAspirationPosition,Except[Null]],
      (* The option is Automatic, If the resolved AspirationPosition is not Null, resolve to 2 Millimeter *)
        2 Millimeter,
      (* Otherwise this option is not applicable, set to Null *)
      True,
        Null
    ],
    (*If the option is specified, accept it*)
    inputAspirationPositionOffset
  ];
  (*Return resolved values*)
  {resolvedAspirationPosition, resolvedAspirationPositionOffset}
];

(* Helper function to resolve independent options of a wash stage within the map thread*)
resolveWashStageOptions[
	resolvedStageMasterswitch:Alternatives[BooleanP,Null],
	preparation:PreparationMethodP,
	preWashBufferVolume:Alternatives[Null,VolumeP],
	sampleVolume:VolumeP,
	inputStageBuffer:Alternatives[Null,Automatic,ObjectP[]],
	inputStageBufferVolume:Alternatives[Null,Automatic,VolumeP],
	inputStageMagnetizationTime:Alternatives[Null,Automatic,TimeP],
	inputStageAspirationVolume:Alternatives[Null,Automatic,All,VolumeP],
	inputNumberOfStages:Alternatives[Null,Automatic,_Integer],
	inputStageCollectionContainer:ListableP[Alternatives[Automatic,Null,ObjectP[]]],
	inputStageCollectionStorageCondition:ListableP[Alternatives[Automatic,Null,SampleStorageTypeP,Disposal,ObjectP[]]],
	inputStageAirDry:Alternatives[Automatic,BooleanP,Null],
	inputStageAirDryTime:Alternatives[Null,Automatic,TimeP]
]:=Module[
	{resolvedStageBuffer,resolvedStageBufferVolume,resolvedStageMagnetizationTime,resolvedStageAspirationVolume,resolvedNumberOfStages,resolvedStageCollectionContainer,resolvedStageCollectionStorageCondition,resolvedStageAirDry,resolvedStageAirDryTime},
	(*Resolve the wash buffer of the stage*)
	resolvedStageBuffer=If[MatchQ[inputStageBuffer,Automatic],
		(*If the option is Automatic, resolve it*)
		If[resolvedStageMasterswitch,
			(*If stage masterswitch is True, resolve it to Model[Sample,"Milli-Q water"]*)
			Model[Sample,"Milli-Q water"],
			(*If stage masterswitch is False, resolve it to Null*)
			Null
		],
		(*If the option is specified, accept it*)
		inputStageBuffer
	];
	(*Resolve the buffer volume of the stage*)
	resolvedStageBufferVolume=If[MatchQ[inputStageBufferVolume,Automatic],
		(*If the option is Automatic, resolve it*)
		If[resolvedStageMasterswitch,
			(*If Stage is True, resolve it to resolvedPreStageBufferVolume*)
			If[VolumeQ[preWashBufferVolume],
				preWashBufferVolume,
				sampleVolume
			],
			(*If Stage is False, resolve it to Null*)
			Null
		],
		(*If the option is specified, accept it*)
		inputStageBufferVolume
	];
	(*Resolved the magnetization time of the stage*)
	resolvedStageMagnetizationTime=If[MatchQ[inputStageMagnetizationTime,Automatic],
		(*If the option is Automatic, resolve it*)
		If[resolvedStageMasterswitch,
			(*If stage masterswitch is True, resolve it to 5 minutes*)
			5 Minute,
			(*If stage masterswitch is False, resolve it to Null*)
			Null
		],
		(*If the option is specified, accept it*)
		inputStageMagnetizationTime
	];
	(*Resolve the aspiration volume of the stage*)
	resolvedStageAspirationVolume=If[MatchQ[inputStageAspirationVolume,Automatic],
		(*If the option is Automatic, resolve it*)
		If[resolvedStageMasterswitch,
			(*If stage masterswitch is True, resolve based on the preparation option*)
			If[MatchQ[preparation,Manual],
				(* If Manual, can use All *)
				All,
				(* If Robotic, use the resolvedStageBufferVolume as All is not valid *)
				resolvedStageBufferVolume
			],
			(*If stage masterswitch is False, resolve it to Null*)
			Null
		],
		(*If the option is specified, accept it*)
		inputStageAspirationVolume
	];
	(*Resolve NumberOfWashStages*)
	resolvedNumberOfStages=If[MatchQ[inputNumberOfStages,Automatic],
		(*If the option is Automatic, resolve it*)
		If[resolvedStageMasterswitch,
			(*If stage masterswitch is True, resolve it to the length of the inputStageCollectionContainer*)
			Length[inputStageCollectionContainer],
			(*If stage masterswitch is False, resolve it to Null*)
			Null
		],
		(*If the option is specified, accept it*)
		inputNumberOfStages
	];
	(*Resolve the collection container of the stage*)
	resolvedStageCollectionContainer=If[MatchQ[inputStageCollectionContainer,ListableP[Automatic]],
		(*If the option is Automatic, resolve it*)
		If[resolvedStageMasterswitch,
			(*If the stage masterswitch is True, resolve it to an appropriate container*)
			Module[{collectionVolume},
				collectionVolume=If[MatchQ[resolvedStageAspirationVolume,All],
					resolvedStageBufferVolume,
					resolvedStageAspirationVolume
				];
				If[MatchQ[collectionVolume,LessEqualP[3.5 Milliliter]],
					(*MaxVolume of all preferred plates is 3.5 mL*)
					(* If volume is less than 2 mL and Preparation->Robotic, default to 2mL Deep well plate *)
					If[MatchQ[collectionVolume,LessEqualP[2.0 Milliliter]]&&MatchQ[preparation,Robotic],
						Table[Model[Container, Plate, "id:L8kPEjkmLbvW"],resolvedNumberOfStages], (* 2 mL plate *)
						Table[PreferredContainer[collectionVolume,Type->Plate],resolvedNumberOfStages]
					],
					Table[PreferredContainer[collectionVolume],resolvedNumberOfStages]
				]
			],
			(*If the stage masterswitch is False, resolve it to Null*)
			{Null}
		],
		inputStageCollectionContainer
	];
	(*Resolved the collection storage condition of the stage*)
	resolvedStageCollectionStorageCondition=If[MatchQ[inputStageCollectionStorageCondition,Automatic],
		(*If the option is Automatic, resolve it*)
		If[resolvedStageMasterswitch,
			(*If the stage masterswitch is True, resolve it to Refrigerator*)
			Refrigerator,
			(*If the stage masterswitch is False, resolve it to Null*)
			Null
		],
		(*If the option is specified, accept it*)
		inputStageCollectionStorageCondition
	];
	(*Resolve the AirDry of the stage*)
	resolvedStageAirDry=If[MatchQ[inputStageAirDry,Automatic],
		(*If the option is Automatic, resolve it*)
		Which[
			(* If the inputSTageAirDryTime is specified, set the air dry masterswitch to True. *)
			MatchQ[inputStageAirDryTime, TimeP],
			True,
			(*If the stage masterswitch is True, resolve it to False*)
			resolvedStageMasterswitch,
			False,
			(*If the stage masterswitch is False, resolve it to Null*)
			True,
			Null
		],
		(*If the option is specified, accept it*)
		inputStageAirDry
	];
	(*Resolve the AirDryTime of the stage*)
	resolvedStageAirDryTime=If[MatchQ[inputStageAirDryTime,Automatic],
		(*If the option is Automatic, resolve it*)
		If[TrueQ[resolvedStageAirDry],
			(*If resolvedStageAirDry is True, resolve it to 1 minute*)
			1 Minute,
			(*If resolvedStageAirDry is not True, resolve it to Null*)
			Null
		],
		(*If the option is specified, accept it*)
		inputStageAirDryTime
	];
	(*Return the resolved options of the stage*)
	{resolvedStageBuffer,resolvedStageBufferVolume,resolvedStageMagnetizationTime,resolvedStageAspirationVolume,resolvedNumberOfStages,resolvedStageCollectionContainer,resolvedStageCollectionStorageCondition,resolvedStageAirDry,resolvedStageAirDryTime}
];

(*Helper Function to check invalid MixType for container. For container with multiple samples, some mix types will affect the entire container, thus different MixType within the container would be invalid.*)
checkInvalidMixTypeForContainer[
	samples:ListableP[ObjectP[],3],
	stageResolvedMixTypes:ListableP[Alternatives[Null,MixTypeP],3],
	flatSamplePackets:ListableP[PacketP[]]
]:=Flatten@MapThread[
	Function[{batchSamples,batchMixTypes},
		Module[{fullContainerMixTypes,samplesAndMixTypesByContainer,containersAndBadSamples},

			(* MixTypes which will affect an entire container *)
			fullContainerMixTypes = {Roll, Vortex, Invert, Shake, Swirl, Disrupt, Nutate};

			(* If the MixTypes are different and at least one will effect the entire container, see if the samples are in the same container *)
			If[!((SameQ@@batchMixTypes)&&ContainsAny[batchMixTypes,fullContainerMixTypes]),

				(* Group the samples by container and then by MixType *)
				samplesAndMixTypesByContainer=GroupBy[
					Rule@@@Transpose@{batchSamples,batchMixTypes},
					{
						(* Container group *)
						Download[Lookup[Cases[flatSamplePackets,KeyValuePattern[Object->#[[1]]]][[1]],Container],Object]&,
						(* MixType group *)
						MemberQ[fullContainerMixTypes,#[[2]]]&
					}
				];

				(* Map over each container and see if there are conflicting mix types *)
				containersAndBadSamples=KeyValueMap[
					Function[{container,mixTypeAssoc},
						Which[

							(* Only not full container mixing types *)
							Length[mixTypeAssoc]==1&&KeyExistsQ[mixTypeAssoc,False],
							Nothing,

							(* There are only fullContainer mixing types *)
							Length[mixTypeAssoc]==1&&KeyExistsQ[mixTypeAssoc,True],
							(* If there is only one sample in the container we are good no matter what the MixType *)
							Which[
								Length[Lookup[mixTypeAssoc,True]]==1,
								Nothing,
								(* If all of the samples have the same mix type we are good *)
								SameQ@@@(Flatten@Values[Values[mixTypeAssoc]]),
								Nothing,
								(* Otherwise we have to warn about potential overmixing *)
								True,
								Rule[container,Flatten@Keys[Lookup[mixTypeAssoc,True]]]
							],

							(* There are both fullContainer mixing and not full container mixing types *)
							True,
							Rule[container,Join[Flatten@Keys[Lookup[mixTypeAssoc,True]],Flatten@Keys[Lookup[mixTypeAssoc,False]]]]
						]
					],
					samplesAndMixTypesByContainer
				];
				containersAndBadSamples,

				Nothing
			]
		]
	],
	{
		samples,
		unflattenListHelper[stageResolvedMixTypes,samples]
	}
];

(*Helper function to check if the same batch have the same airdry settings for a stage*)
checkConflictingAirDryOfStage[
	samples:ListableP[ObjectP[],3],
	resolvedAirDries:ListableP[Alternatives[Null,BooleanP],3]
]:=MapThread[
	Function[{samplesBatch,airDriesBatch,batchIndex},
		(* Tag the batch if there is at least one sample with airdry->True and one with airdry->False|Null *)
		If[Length[airDriesBatch]>1&&MemberQ[airDriesBatch,True]&&!SameQ@@airDriesBatch,
			Module[{airDriedSamples,nonAirDriedSamples},
				airDriedSamples=PickList[samplesBatch,airDriesBatch];
				nonAirDriedSamples=Complement[samplesBatch,airDriedSamples];
				{nonAirDriedSamples,airDriedSamples,batchIndex}
			],
			Nothing
		]
	],
	{
		samples,
		unflattenListHelper[resolvedAirDries,samples],
		Range[Length[samples]]
	}
];

(*Helper function to check if there is mismatch for aspiration pipetting options*)
checkAspirationPipettingMismatchErrorOfStage[
  flatSamples:ListableP[ObjectP[]],
  unresolvedAspirationOptions_List
]:=MapThread[
  Function[{sample, unresolvedAspirationOption},
    Module[{aspirationPosition,aspirationPositionOffset},
      {aspirationPosition,aspirationPositionOffset} = unresolvedAspirationOption;
      (*If both aspirationPosition,aspirationPositionOffset are specified by user, check for mix mismatch*)
      If[MatchQ[aspirationPosition, Except[Automatic]] && MatchQ[aspirationPositionOffset, Except[Automatic]],
        Which[
          (*If aspirationPosition is specified as a pipetting position but aspirationPositionOffset is specified as Null, output error for the sample *)
          MatchQ[aspirationPosition, MagneticBeadSeparationPipettingPositionP] && MatchQ[aspirationPositionOffset, Null], True,
          (*If aspirationPosition is specified as other than pipetting but aspirationPositionOffset is specified, output error for the sample *)
          (!MatchQ[aspirationPosition, MagneticBeadSeparationPipettingPositionP|Automatic]) &&
              MatchQ[aspirationPositionOffset, Except[Null|Automatic]], True,
          (*Otherwise, output no error for the sample *)
          True,
          False
        ],
        False
      ]
    ]
  ],
  {flatSamples,Transpose[unresolvedAspirationOptions]}
];

(*Helper function to check if there is mismatch for mix options*)
checkMixMismatchErrorOfStage[
	flatSamples:ListableP[ObjectP[]],
	unresolvedMixOptions_List
]:=MapThread[
	Function[{sample, unresolvedMixOption},
		Module[{mix, mixType, mixTime, mixRate, numberOfMixes, mixVolume,
			mixTemperature, mixTipType, mixTipMaterial},
			{mix, mixType, mixTime, mixRate, numberOfMixes, mixVolume,
				mixTemperature, mixTipType, mixTipMaterial} = unresolvedMixOption;
			(*If both mix and mixType are specified by user, check for mix mismatch*)
			If[MatchQ[mix, Except[Automatic]] &&
				MatchQ[mixType, Except[Automatic]],
				Which[
					(*If mix is specified as True but mixType is specified as Null, output error for the sample *)
					MatchQ[mix, True] && MatchQ[mixType, Null], True,
					(*If mix is specified as other than True but there is any other mix option that is specified, output error for the sample *)
					(!MatchQ[mix, True|Automatic]) &&
						MemberQ[{mixType, mixTime, mixRate, numberOfMixes, mixVolume,
							mixTemperature, mixTipType, mixTipMaterial},
							Except[Null | Automatic | Ambient]], True,
					(*Otherwise, output no error for the sample *)
					True,
					False
				],
				False
			]
		]
	],
	{flatSamples,Transpose[unresolvedMixOptions]}
];

(*Helper function to check if mix TipType of a stage is valid. For mix volume less than 970 microliter, WideBore tips need to be used to prevent clogging by beads*)
checkInvalidMixTipTypeOfStage[
	flatSamples:ListableP[ObjectP[]],
	flatMixTipTypes:ListableP[Alternatives[Automatic,Null,TipTypeP]],
	flatMixVolumes:ListableP[Alternatives[Automatic,Null,VolumeP]]
]:=MapThread[
	Function[{sample, unresolvedMixTipType, resolvedMixVolume},
		(*If unresolved MixTipType is specified by user as anything other than WideBore. check the MixVolume*)
		If[MatchQ[unresolvedMixTipType, Except[Automatic|Null|WideBore]],
			(*If the MixVolume is no larger than 970 uL, output the sample and MixVolume*)
			If[MatchQ[resolvedMixVolume,LessEqualP[970 Microliter]],
				{sample,resolvedMixVolume},
				Nothing
			],
			Nothing
		]
	],
	{flatSamples, flatMixTipTypes, flatMixVolumes}
];

(*Helper function to check if there is tip available for the MixTipType, MixTipMaterial, and MixVolume*)
checkMixNoTipErrorOfStage[
	flatSamples:ListableP[ObjectP[]],
	flatInputMixTipTypes:ListableP[Alternatives[Automatic,Null,TipTypeP]],
	flatResolvedMixTipTypes:ListableP[Alternatives[Automatic,Null,TipTypeP]],
	flatInputMixTipMaterials:ListableP[Alternatives[Automatic,Null,MaterialP]],
	flatResolvedMixTipMaterials:ListableP[Alternatives[Automatic,Null,MaterialP]],
	flatResolvedMixVolumes:ListableP[Alternatives[Automatic,Null,VolumeP]],
  preparation:PreparationMethodP
]:=MapThread[
	Function[{sample, unresolvedMixTipType,resolvedMixTipType,unresolvedMixTipMaterial,resolvedMixTipMaterial,resolvedMixVolume},
		(*If any of the TipType or TipMaterial is specified by user, check if there is such tips available*)
		If[MemberQ[{unresolvedMixTipType,unresolvedMixTipMaterial},Except[Automatic|Null]],
			(*If the MixVolume is no larger than 970 uL, output the sample and MixVolume*)
			Module[{potentialTips},
				(*Search potential tips by resolved TipType and TipMaterial which kept user input *)
				potentialTips=If[MatchQ[preparation,Robotic],
          (*If using Robotic preparation, search for Hamilton tips only*)
          TransferDevices[Model[Item,Tips], resolvedMixVolume, PipetteType->Hamilton,TipType->resolvedMixTipType, TipMaterial->resolvedMixTipMaterial],
          (*Otherwise, Manual preparation is used, use default Pipette setting which is {Micropipette, Seroligical}*)
          TransferDevices[Model[Item,Tips], resolvedMixVolume, TipType->resolvedMixTipType, TipMaterial->resolvedMixTipMaterial]
        ];
				If[Length[potentialTips] == 0,
					(*If no potential tips can be found, return the information needed for error message*)
					{sample,resolvedMixVolume,unresolvedMixTipType,unresolvedMixTipMaterial},
					Nothing]
			],
			Nothing
		]
	],
	{flatSamples, flatInputMixTipTypes, flatResolvedMixTipTypes, flatInputMixTipMaterials, flatResolvedMixTipMaterials, flatResolvedMixVolumes}
];

(*Helper Function to check that there is instrument that satisfies the mix options of a stage.*)
checkMixNoInstrumentErrorsOfStage[
	flatResolvedAssayContainers:ListableP[ObjectP[]],
	flatResolvedMagneticBeadVolumes:ListableP[VolumeP],
	flatResolvedStageMixBools:ListableP[Alternatives[BooleanP,Null]],
	flatResolvedStageBufferVolumes:ListableP[Alternatives[VolumeP,Null]],
	flatResolvedStageMixTypes:ListableP[Alternatives[MixTypeP,Null]],
	flatResolvedStageMixRates:ListableP[Alternatives[_?QuantityQ,Null]],
	flatResolvedStageMixTemperatures:ListableP[Alternatives[TemperatureP,Ambient,Null]]
]:=MapThread[
	Function[{assayContainer, resolvedBeadVolume, resolvedMix, resolvedBufferVolume, resolvedMixType, resolvedMixRate, resolvedMixTemperature},
		(*If resolvedMix is True, and the resolvedMixType is one of those that needs an instrument, check if there is suitable mixing instrument*)
		If[MatchQ[resolvedMix, True]&&MatchQ[resolvedMixType,Vortex|Stir|Shake|Roll|Disrupt|Nutate|Sonicate|Homogenize],
			Module[{assayContainerModel, volumeToMix, instruments},
				(*Convert to the Model[Container] if resolved assay container is an Object[Container]*)
				assayContainerModel =If[MatchQ[assayContainer, ObjectP[Object[Container]]],
					Lookup[assayContainer, Model],
					assayContainer];
				(*Calculate the volume for mixing at the stage*)
				volumeToMix = Total[Cases[{resolvedBeadVolume, resolvedBufferVolume}, VolumeP]];
				(*Find eligible instruments using MixDevices given the resolved MixType, MixRate, and MixTemperature*)
				Which[
					(*If all are not null*)
					MatchQ[resolvedMixType, Except[Null]] &&
						MatchQ[resolvedMixRate, Except[Null]] &&
						MatchQ[resolvedMixTemperature, Except[Null]],
					instruments = MixDevices[assayContainerModel, volumeToMix,
						Types -> resolvedMixType, Rate -> resolvedMixRate,
						Temperature -> resolvedMixTemperature],
					(*If type and temperature are not Null*)
					MatchQ[resolvedMixType, Except[Null]] && MatchQ[resolvedMixTemperature, Except[Null]],
					instruments = MixDevices[assayContainerModel, volumeToMix,
						Types -> resolvedMixType,
						Temperature -> resolvedMixTemperature],
					(*If rate and temperature are not Null*)
					MatchQ[resolvedMixRate, Except[Null]] &&MatchQ[resolvedMixTemperature, Except[Null]],
					instruments = MixDevices[assayContainerModel, volumeToMix,
						Rate -> resolvedMixRate,
						Temperature -> resolvedMixTemperature],
					(*If type and rate are not Null*)
					MatchQ[resolvedMixType, Except[Null]] &&MatchQ[resolvedMixRate, Except[Null]],
					instruments =MixDevices[assayContainerModel, volumeToMix,
						Types -> resolvedMixType, Rate -> resolvedMixRate],
					(*If type is not Null*)
					MatchQ[resolvedMixType, Except[Null]],
					instruments =MixDevices[assayContainerModel,volumeToMix,Types -> resolvedMixType],
					(*If temperature is not Null*)
					MatchQ[resolvedMixTemperature, Except[Null]],
					instruments =MixDevices[assayContainerModel,volumeToMix,Temperature -> resolvedMixTemperature],
					(*If rate is not Null*)
					MatchQ[resolvedMixRate, Except[Null]],
					instruments =MixDevices[assayContainerModel,volumeToMix,Rate -> resolvedMixRate],
					(*Otherwise just search based on the container and volume*)
					True, instruments = MixDevices[assayContainerModel, volumeToMix]
				];
				(*If there is no eligible instrument found, output error for the sample*)
				If[Length[instruments] == 0,
					True,
					False]
			],
			False]],
	{flatResolvedAssayContainers,flatResolvedMagneticBeadVolumes,flatResolvedStageMixBools,flatResolvedStageBufferVolumes,flatResolvedStageMixTypes,flatResolvedStageMixRates,flatResolvedStageMixTemperatures}
];

(*Helper function used in resolver to check if a wash stage occurs after a True for the previous wash stage*)
checkInvalidMultipleWashStageError[
	flatSamples:ListableP[ObjectP[]],
	resolvedPreviousWashes:ListableP[BooleanP,3],
	resolvedCurrentWashes:ListableP[BooleanP,3]
]:=MapThread[
	Function[{sample,resolvedPreviousWash,resolvedCurrentWash},
		(*If the previous wash is resolved to False but the current wash is resolved to True, flip the error to True for the sample*)
		If[MatchQ[resolvedPreviousWash,False]&&MatchQ[resolvedCurrentWash,True],
			True,
			False
		]
	],
	{flatSamples,Flatten[resolvedPreviousWashes],Flatten[resolvedCurrentWashes]}
];

(*Helper function to convert the format of output resolved container if the input is Automatic. If the collection container is a plate, the output resolved container is in {well,object} format, otherwise, the output is just the object.*)
convertAutomaticCollectionContainerOutput[
	inputCollectionContainers:ListableP[Alternatives[Automatic,Null,ObjectP[],{_Integer,ObjectP[]},{_String,ObjectP[]},{_String,{_Integer,ObjectP[]}}],3],
	flatResolvedCollectionContainers:ListableP[Alternatives[Null,ObjectP[]]],
	flatResolvedDestinationWells:ListableP[Alternatives[Null,_String]]
]:=If[
	(*If the user input contains any Automatic, the output format is converted based on container type*)
	MemberQ[Flatten[ToList[inputCollectionContainers]],Automatic],
	MapThread[
		Function[{resolvedContainer,resolvedWell},
			Which[
				(*If the resolved container is a plate, return the combined container+well*)
				Or[
					MatchQ[resolvedContainer,ObjectP[Object[Container,Plate]]],
					MatchQ[resolvedContainer,ObjectP[Model[Container,Plate]]]
				],
				{resolvedWell,resolvedContainer},

				(*If the resolved container is an non-plate object or Model, return the container*)
				MatchQ[resolvedContainer,ObjectP[]],
				resolvedContainer,

				(*Otherwise, return Null*)
				True,Null
			]
		],
		{flatResolvedCollectionContainers,flatResolvedDestinationWells}
	],
	inputCollectionContainers
];

(*Helper function to convert any format of collection containers (possibly with index, wells info) to flat singletons before unnest *)
flattenCollectionContainersToSingletons[
  collectionContainers:ListableP[Alternatives[ObjectP[],{_Integer,ObjectP[]},{_String,ObjectP[]},{_String,{_Integer,ObjectP[]}},Null],3]
]:= Module[
  {singletonP},
  (*Define singletons for collection conatiners*)
  singletonP = Alternatives[
    {_Integer, ObjectP[]},
    {_String,ObjectP[]},
    {_String,{_Integer,ObjectP[]}}
  ];
  If[MatchQ[Flatten[collectionContainers],ListableP[ObjectP[]|Null]],
    Flatten[collectionContainers],
    Cases[collectionContainers, singletonP, 3]
  ]
];

(*Helper function to convert any format of collection containers (possibly with index, wells info) to flat Object/Model of collection containers in resource packet*)
flattenCollectionContainersOfStage[
	stageCollectionContainers:ListableP[Alternatives[ObjectP[],{_Integer,ObjectP[]},{_String,ObjectP[]},{_String,{_Integer,ObjectP[]}},Null],3]
]:= Module[
	{singletonP,flatSingletons},
	(*Define singletons for collection conatiners*)
	singletonP = Alternatives[
		{_Integer, ObjectP[]},
		{_String,ObjectP[]},
		{_String,{_Integer,ObjectP[]}}
	];
	flatSingletons=If[MatchQ[Flatten[stageCollectionContainers],ListableP[ObjectP[]|Null]],
    Flatten[stageCollectionContainers],
    Cases[stageCollectionContainers, singletonP, 3]
  ];
	(*Go through the flat singletons list to normalize the containers*)
	Flatten[
		Switch[#,
			(*If it is index and model container, flatten the model containers*)
			{_Integer,ObjectP[]},
			#/.{_Integer, x : ObjectP[]} :> x,
			(*If it is well and model container, flatten the model containers*)
			{_String,ObjectP[]},
			#/.{_String,x:ObjectP[]}:>x,
			(*If it is well, index, and model container, flatten the model containers*)
			{_String, {_Integer,ObjectP[]}},
			#/.{_String,{_Integer,x:ObjectP[]}}:>x,
			(*Otherwise, it is container objects or models or Null, flatten it as it is*)
			_,
      #
		]&/@flatSingletons
	]
];

(*Helper function to generate resources for collection containers of each stage in resource packet *)
generateCollectionContainerResourcesOfStage[
	flatCollectionContainers:ListableP[Alternatives[ObjectP[],Null]],
	flatCollectionContainerIndices:ListableP[Alternatives[_Integer,Null]],
	flatCollectionContainerLabels:ListableP[Alternatives[_String,Null]],
	initialUniquePlateResourceLookup_Association
]:=Module[
	{currentUniquePlateResourceLookup,resource},
	currentUniquePlateResourceLookup=initialUniquePlateResourceLookup;
	resource=MapThread[
		Function[{container,index,label},
			Which[
				(*If container is an object container (and implied index is null),look up if it is in our uniquePlateResourceLookup, otherwise create it*)
				MatchQ[container,ObjectP[Object[Container]]],
				Module[{containerResourceInfo,newResource},
					containerResourceInfo=Lookup[currentUniquePlateResourceLookup, Key[{container,Null,label}], Null];
					If[Length[containerResourceInfo]>0,
						containerResourceInfo,
						newResource=Resource[Sample->container, Name->CreateUUID[]];
						currentUniquePlateResourceLookup=AssociateTo[
							currentUniquePlateResourceLookup,
							{container,Null,label}->newResource
						];
						newResource
					]
				],
				(*If container is a model container and index is not null, check if it exist, or create a new *)
				MatchQ[container,ObjectP[Model[Container]]],
				Module[{containerResourceInfo,newResource},
					containerResourceInfo=Lookup[currentUniquePlateResourceLookup, Key[{container,index,label}], Null];
					If[Length[containerResourceInfo]>0,
						containerResourceInfo,
						newResource=Resource[Sample->container, Name->CreateUUID[]];
						currentUniquePlateResourceLookup=AssociateTo[
							currentUniquePlateResourceLookup,
							{container,index,label}->newResource
						];
						(*Return the container resource info *)
						newResource
					]
				],
				True,Null
			]
		],
		{flatCollectionContainers,flatCollectionContainerIndices,flatCollectionContainerLabels}
	];
	(*Return generated resources of stage and the updated lookup*)
	{resource,currentUniquePlateResourceLookup}
];

(*---Helper function to normalize container options for simulation function*)
normalizeResolvedContainersForSimulation[myResolvedContainers:
    ListableP[Alternatives[Null,ObjectP[],{_Integer,ObjectP[]},{_String,ObjectP[]},{_String,{_Integer,ObjectP[]}}],3]
]:= myResolvedContainers/.{
	{_String,{_Integer,x:ObjectP[]}}:>x,
	{_String,x:ObjectP[]}:>x,
	{_Integer,x:ObjectP[]}:>x,
	Null->{Null}
};

(* Helper function to generate primitives for PreWash and multiple Wash stages in resource packet *)
generateWashStagePrimitivesInResourcePacket[
	stageBools:ListableP[Alternatives[BooleanP,Null],3],
	stageBufferVolumes:ListableP[Alternatives[VolumeP,Null],3],
	stageMagnetizationTimes:ListableP[Alternatives[TimeP,Null],3],
	stageAspirationVolumes:ListableP[Alternatives[VolumeP,Null, All],3],
  stageAspirationPositions:ListableP[Alternatives[MagneticBeadSeparationPipettingPositionP,Null],3],
  stageAspirationPositionOffsets:ListableP[Alternatives[GreaterEqualP[0 Millimeter]|Coordinate[{DistanceP, DistanceP, GreaterEqualP[0 Millimeter]}],Null],3],
	numberOfStages:ListableP[Alternatives[_Integer,Null],3],
	stageAirDries:ListableP[Alternatives[BooleanP,Null],3],
	stageAirDryTimes:ListableP[Alternatives[TimeP,Null],3],
	stageMixes:ListableP[Alternatives[BooleanP,Null],3],
	stageMixTypes:ListableP[Alternatives[MixTypeP,Null],3],
	stageMixTimes:ListableP[Alternatives[TimeP,Null],3],
	stageMixRates:ListableP[Alternatives[_?QuantityQ,Null],3],
	numberOfStageMixes:ListableP[Alternatives[_Integer,Null],3],
	stageMixVolumes:ListableP[Alternatives[VolumeP,Null],3],
	stageMixTemperatures:ListableP[Alternatives[TemperatureP,Ambient,Null],3],
	stageMixTipTypes:ListableP[Alternatives[TipTypeP,Null],3],
	stageMixTipMaterials:ListableP[Alternatives[MaterialP,Null],3],
	stageDestinationWells:ListableP[Alternatives[_String,Null],3],
	stageCollectionContainerLabels:ListableP[Alternatives[_String,Null],3],
	expAssayContainerLabels:ListableP[Alternatives[_String,Null],3],
	expAssayWells:ListableP[Alternatives[_String,Null],3],
	expMagnetizationRacks:ListableP[ObjectP[],3],
  expUnresolvedMagnetizationRacks:ListableP[Alternatives[ObjectP[],Automatic,Null],3],
	stageBufferLabels:ListableP[Alternatives[_String,Null],3]
]:=MapThread[
	Function[
		{
			stageBoolsBatch,stageBufferVolumesBatch,stageMagnetizationTimesBatch,stageAspirationVolumesBatch,stageAspirationPositionsBatch,stageAspirationPositionOffsetsBatch,numberOfStagesBatch,
			stageAirDriesBatch,stageAirDryTimesBatch,stageMixesBatch,stageMixTypesBatch,stageMixTimesBatch,stageMixRatesBatch,numberOfStageMixesBatch,stageMixVolumesBatch,stageMixTemperaturesBatch, stageMixTipTypesBatch, stageMixTipMaterialsBatch,stageDestinationWellsBatch,stageCollectionContainerLabelsBatch,assayContainerLabelsBatch,assayWellsBatch,magnetizationRacksBatch,unresolvedMagnetizationRacksBatch,stageBufferLabelsBatch
		},
		Module[{maxNumStages,numberOfStagesBatchBools,mixingBools,transferAndMixPrimitives,waitPrimitive},
			(* Get the max number of times we are PreWashing in this batch *)
			maxNumStages=Max[DeleteCases[numberOfStagesBatch,Null],{0}];

			(* Table that number of prewashes *)
			transferAndMixPrimitives=Table[

				(* See what samples we use this round *)
				numberOfStagesBatchBools=(LessEqualQ[i,#])&/@numberOfStagesBatch;
				mixingBools=MapThread[(LessEqualQ[i,#1]&&TrueQ[#2])&,{numberOfStagesBatch,stageMixesBatch}];

				If[Or@@numberOfStagesBatchBools,
					{
						(* Transfer preWashBuffer into assay container *)
						Transfer[
							Source->PickList[stageBufferLabelsBatch,numberOfStagesBatchBools][[All,i]],
							Destination->Transpose[{PickList[assayWellsBatch,numberOfStagesBatchBools],PickList[assayContainerLabelsBatch,numberOfStagesBatchBools]}],
							Amount->PickList[stageBufferVolumesBatch,numberOfStagesBatchBools],
							MultichannelTransfer->False
						],
						(* Mix if necessary. Only choosing the samples that we are using this round and that we mix *)
						If[Or@@mixingBools,
							Mix[
								Sample->Transpose[{PickList[assayWellsBatch,numberOfStagesBatchBools],PickList[assayContainerLabelsBatch,numberOfStagesBatchBools]}],
								MixType->PickList[stageMixTypesBatch,mixingBools],
								Time->PickList[stageMixTimesBatch,mixingBools],
								MixRate->PickList[stageMixRatesBatch,mixingBools],
								NumberOfMixes->PickList[numberOfStageMixesBatch,mixingBools],
								MixVolume->PickList[stageMixVolumesBatch,mixingBools],
                MixFlowRate->Replace[PickList[stageMixTypesBatch,mixingBools],{Except[Pipette]->Null,Pipette->500 Microliter/Second},2],(*give it a higher default than in Mix which is only 100 Microliter/Second*)
                MixPosition -> Replace[PickList[stageMixTypesBatch,mixingBools],{Except[Pipette]->Null,Pipette->Bottom},2],(*give it a default other than in Mix which is LiquidLevel*)
                MixPositionOffset-> Replace[PickList[stageMixTypesBatch,mixingBools],{Except[Pipette]->Null,Pipette->1 Millimeter},2],(*give it a smaller default other than in Mix which is 2mm*)
								Temperature->PickList[stageMixTemperaturesBatch,mixingBools],
								TipType->PickList[stageMixTipTypesBatch,mixingBools],
								TipMaterial->PickList[stageMixTipMaterialsBatch,mixingBools]
							],
							Nothing
						],
						(* Move to the magnet then transfer to collection container *)
						Transfer[
							Source->Transpose[{PickList[assayWellsBatch,numberOfStagesBatchBools],PickList[assayContainerLabelsBatch,numberOfStagesBatchBools]}],
							Destination->Transpose[{PickList[stageDestinationWellsBatch,numberOfStagesBatchBools][[All,i]],PickList[stageCollectionContainerLabelsBatch,numberOfStagesBatchBools][[All,i]]}],
							Amount->PickList[stageAspirationVolumesBatch,numberOfStagesBatchBools],
							Magnetization->True,
							MagnetizationTime->PickList[stageMagnetizationTimesBatch,numberOfStagesBatchBools],
							MagnetizationRack->PickList[magnetizationRacksBatch,numberOfStagesBatchBools],
              UnresolvedMagnetizationRackFromParentProtocol -> PickList[unresolvedMagnetizationRacksBatch,numberOfStagesBatchBools],
							AspirationPosition->PickList[stageAspirationPositionsBatch,numberOfStagesBatchBools],
              AspirationPositionOffset->PickList[stageAspirationPositionOffsetsBatch,numberOfStagesBatchBools],
              AspirationMix -> False,
							MultichannelTransfer->False
						]
					},
					Nothing
				],
				{i,1,maxNumStages}
			];

			(* If a sample in this batch is set to air dry, air dry the batch *)
			waitPrimitive=If[Or@@stageAirDriesBatch&&Or@@stageBoolsBatch,
				(* Generate a Wait primitive if we are asked to air dry *)
				{Wait[Duration -> Max[stageAirDryTimesBatch]]},
				{}
			];

			Join[transferAndMixPrimitives,waitPrimitive]
		]
	],
	{
		stageBools, stageBufferVolumes, stageMagnetizationTimes, stageAspirationVolumes,stageAspirationPositions,stageAspirationPositionOffsets, numberOfStages, stageAirDries, stageAirDryTimes, stageMixes, stageMixTypes, stageMixTimes, stageMixRates, numberOfStageMixes, stageMixVolumes, stageMixTemperatures, stageMixTipTypes, stageMixTipMaterials, stageDestinationWells, stageCollectionContainerLabels, expAssayContainerLabels, expAssayWells, expMagnetizationRacks, expUnresolvedMagnetizationRacks,stageBufferLabels
	}
];

(*---Helper function to normalize container options for upload resource packet unit operations*)
normalizeResolvedContainersForUnitOperation[myResolvedOption:
	ListableP[Alternatives[Null,ObjectP[],_Integer,_String,{_Integer,ObjectP[]},{_String,ObjectP[]},{_String,{_Integer,ObjectP[]}}],4]
]:=
	Switch[myResolvedOption,
		(*If it is a listable objects already, remove one layer of listiness*)
		ListableP[ObjectP[Object[Container]]|ObjectP[Model[Container]],3],
		myResolvedOption/. {x : ObjectP[Object[Container]] | ObjectP[Model[Container]]}:>x,
		(*If it is a listable indices and containers, remove one layer of listiness*)
		ListableP[{GreaterEqualP[1, 1], ObjectP[Model[Container]]},3],
		myResolvedOption/. {x : {GreaterEqualP[1, 1], ObjectP[]}}:>x,
		(*If it is a listable wells and containers, remove one layer of listiness*)
		ListableP[{_String,ObjectP[Model[Container]]},4],
		myResolvedOption/. {x : {_String, ObjectP[]}}:>x,
		(*If it is a listable wells indices and containers, remove one layer of listiness *)
		ListableP[{_String, {GreaterEqualP[1, 1],ObjectP[Model[Container]]}},3],
		myResolvedOption/. {x : {_String, {GreaterEqualP[1, 1], ObjectP[]}}}:>x,
		(* If it is a listable indices, remove one layer of listiness*)
		ListableP[GreaterEqualP[1, 1],3],
		myResolvedOption/. {x : GreaterEqualP[1, 1]}:>x,
		(* If it is a listable wells, remove one layer of listiness*)
		ListableP[_String,3],
		myResolvedOption/. {x : _String}:>x,
		(*If it is a listable Null, remove one layer of listiness*)
		_,
		myResolvedOption/. {Null}->Null
	];

(*Helper function to update MBS collected sample composition*)
updateMBSSampleComposition[
	separationMode:MagneticBeadSeparationModeP,
	selectionStrategy:MagneticBeadSeparationSelectionStrategyP,
	workingSampleComposition:ListableP[{Alternatives[{Null|CompositionP, IdentityModelP|Null}, {Null|CompositionP, IdentityModelP|Null, _?DateObjectQ|Null}, Null] ...}|Null, 3],
	volume:Alternatives[VolumeP,Null],
	analyteAffinityLabel:Alternatives[IdentityModelP,Null],
	target:Alternatives[IdentityModelP,Null],
	magneticBeadResin:Alternatives[ObjectP[Model[Resin]],Null],
	stageContainerSampleVolume:Alternatives[VolumeP,Null],
	stageContainerSampleComposition:ListableP[{Alternatives[{Null|CompositionP, IdentityModelP|Null},{Null|CompositionP, IdentityModelP|Null, _?DateObjectQ|Null},Null] ...}|Null, 3],
	stage:Alternatives[PreWash,Equilibration,Loading,Wash,Elution,AdditionalElution]
]:=Module[{sampleCompositionNoTime, sampleCompositionNoResin, targetTypeMolecules, updatedSampleCompositionNoTime, updatedSampleCompositionNoZero},

  (* Remove the time element in field Composition *)
  sampleCompositionNoTime = If[NullQ[stageContainerSampleComposition],
    (*If it is Null, no need to touch it*)
    stageContainerSampleComposition,
    (*Otherwise we need to remove the time dimension*)
    stageContainerSampleComposition[[All,{1,2}]]
  ];

	(* Remove the magnetic bead resins from the composition *)
	sampleCompositionNoResin=DeleteCases[sampleCompositionNoTime,{_,ObjectP[magneticBeadResin]}];

	(*Get a list of all molecules of the same type as Target in the WorkingSamples*)
	targetTypeMolecules=Which[
		(*If target is a nucleic acid, fish out all the nucleic acid molecules in the loadingSampleToAdjust including the target*)
		Or[
			MatchQ[target,ObjectP[Model[Molecule, Transcript]]|ObjectP[Model[Molecule, cDNA]]],
			MatchQ[target,ObjectP[Model[Molecule, Oligomer]]] && MatchQ[target[PolymerType],DNA | RNA]
		],
		Select[Flatten@workingSampleComposition,
			Or[
				MatchQ[#,ObjectP[Model[Molecule, Transcript]]|ObjectP[Model[Molecule, cDNA]]],
				MatchQ[#,ObjectP[Model[Molecule, Oligomer]]] && MatchQ[#[PolymerType],DNA | RNA]
			]&
		],
		(*If target is a protein or peptide, fish out all the nucleic acid molecules in the loadingSampleToAdjust including the target*)
		Or[
			MatchQ[target,ObjectP[Model[Molecule,Protein]]],
			MatchQ[target,ObjectP[Model[Molecule,Oligomer]]]&&MatchQ[target[PolymerType],Peptide]
		],
		Select[Flatten@workingSampleComposition,
			Or[
				MatchQ[#,ObjectP[Model[Molecule,Protein]]],
				MatchQ[#,ObjectP[Model[Molecule,Oligomer]]]&&MatchQ[#[PolymerType],Peptide]
			]&
		],
		(*If target is Null or neither nucleic acids nor protein/peptide, we don't know what to fish out from the list, just leave the target itself*)
		True,
		target
	];

	(* Calculate the updated sample composition based on the stage it was collected from, the separation mode, and the selection strategy *)
  (* NOTE: we do not append time to the composition yet *)
  updatedSampleCompositionNoTime=Switch[{stage,separationMode,selectionStrategy},

		{Alternatives[PreWash,Equilibration],_,_},
		(*If the sample to update is from PreWash, just remove the magnetic bead resins regardless of the separation mode *)
		sampleCompositionNoResin,

		{Wash,Affinity,_},
		(*If the sample to update is from any of the wash stages, remove the magnetic bead resins and the molecules bound to the beads. In affinity mode, the AnalyteAffinityLabel binds to the beads regardless of the selectionStrategy. *)
		If[!MatchQ[analyteAffinityLabel,Null|{}],
			(*If analyteAffinityLabel is not Null, remove it from the composition in the update*)
			DeleteCases[sampleCompositionNoResin,{_,ObjectP[analyteAffinityLabel]}],
			(*If somehow the analyteAffinityLabel is Null, we don't know what else to remove, just remove the beads*)
			sampleCompositionNoResin
		],

		{Wash,Except[Affinity],Positive},
		(*If the sample to update is from any of the wash stages, remove the magnetic bead resins and the molecules bound to the beads. In non-affinity mode with Positive selection, the target along with all the same type of molecules binds to the beads. *)
		If[!MatchQ[targetTypeMolecules,Null|{}],
      DeleteCases[sampleCompositionNoResin,{_,ObjectP[ToList[targetTypeMolecules]]}],
			sampleCompositionNoResin
		],

		{Wash,Except[Affinity],_},
		(*If the sample to update is from any of the wash stages, remove the magnetic bead resins and the molecules bound to the beads. In non-affinity mode with Negative selection, we don't know what actually bind the beads, just remove the magnetic bead resins*)
		sampleCompositionNoResin,

		{Loading,Affinity,_},
		(*If the sample to update is from Loading and the separation mode is Affinity, remove the magnetic bead resins and the AnalyteAffinityLabel bound to the beads regardless of the selection strategy.*)
		If[
			!MatchQ[analyteAffinityLabel,Null|{}],
			DeleteCases[sampleCompositionNoResin,{_,ObjectP[analyteAffinityLabel]}],
			sampleCompositionNoResin
		],


		{Loading,Except[Affinity],Positive},
		(*If the sample to update is from Loading with Positive selection and non-Affinity separation mode, the target along with all the same type of molecules are bound to the beads thus need to be removed from the composition.*)
		If[
			!MatchQ[targetTypeMolecules,Null|{}],
      DeleteCases[sampleCompositionNoResin,{_,ObjectP[ToList[targetTypeMolecules]]}],
			sampleCompositionNoResin
		],

		{Elution,Affinity,_},
		(*If the sample to update is from Elution and the separation mode is Affinity, remove the magnetic bead resins and the AnalyteAffinityLabel bound to the beads is eluted at a new calculated concentration.*)
		Module[
			{newAnalyteAffinityLabelConcentration,workingSampleAnalyteAffinityLabelConcentration},
			(*Calculate the eluted AnalyteAffinityLabel concentration based on original concentration in prepared input sample, volume of input to MBS experiment, and elution sample volume.  is a member of the prepared input sample to MBS, get its original concentration and input volume to calculate the eluted concentration. Otherwise, we don't know what to concentration to update, new concentration is Null*)
			newAnalyteAffinityLabelConcentration=If[
				MemberQ[Flatten[workingSampleComposition],ObjectP[analyteAffinityLabel]],
				(*If the AnalyteAffinityLabel is a member of the prepared input sample to MBS, get its original concentration*)
				workingSampleAnalyteAffinityLabelConcentration=FirstCase[workingSampleComposition,{concentration_,ObjectP[analyteAffinityLabel],__}:>concentration];
				(*If the concentration and volumes used to calculate the new concentration are in their valid forms, do the calculation, otherwise the concentration is unknown so output Null*)
				If[MatchQ[{workingSampleAnalyteAffinityLabelConcentration,volume,stageContainerSampleVolume},{ConcentrationP,VolumeP,VolumeP}],
					workingSampleAnalyteAffinityLabelConcentration*volume/stageContainerSampleVolume,
					Null],
				(*Otherwise AnalyteAffinityLabel is not a member of the prepared input sample to MBS, we don't know the original concentration, new concentration is then Null to indicate unknown*)
				Null
			];
			(* Replace the AnalyteAffinityLabel concentration with our calculated one *)
			sampleCompositionNoResin/.{_,x:ObjectP[analyteAffinityLabel]}:>{newAnalyteAffinityLabelConcentration,x}
		],

		{Elution,Except[Affinity],Positive},
		(*If the sample to update is from Elution with Positive selection and non-Affinity separation mode, the target along with all the same type of molecules binds to the beads and are eluted at a new concentration*)
		Module[
			{updateTargetTypeMoleculeConcentrationRules},
			updateTargetTypeMoleculeConcentrationRules=Map[Function[{targetTypeMolecule},
				Module[{targetTypeMoleculeConcentration,workingSampleTargetTypeMoleculeConcentration},
					workingSampleTargetTypeMoleculeConcentration=FirstCase[workingSampleComposition,{concentration_,ObjectP[targetTypeMolecule],__}:>concentration];
					targetTypeMoleculeConcentration= If[
						(*If the concentration and volumes used to calculate the new concentration are in their valid forms, do the calculation, otherwise the concentration is unknown so output Null*)
						MatchQ[{workingSampleTargetTypeMoleculeConcentration,volume,stageContainerSampleVolume},{ConcentrationP,VolumeP,VolumeP}],
						workingSampleTargetTypeMoleculeConcentration*volume/stageContainerSampleVolume,
						Null
					];
					(*Generate the rule of updating the concentration of targetTypeMolecule*)
					{_,ObjectP[targetTypeMolecule]}->{targetTypeMoleculeConcentration,targetTypeMolecule}
				]
			],
				targetTypeMolecules
			];
			(*Return the resin-removed sample composition with all concentrations replaced with the new calculated ones*)
			If[!MatchQ[updateTargetTypeMoleculeConcentrationRules,Null|{}],
				sampleCompositionNoResin/.updateTargetTypeMoleculeConcentrationRules,
				sampleCompositionNoResin
			]
		],

		{AdditionalElution,Affinity,_},
		(*If the sample to update is from additional Elution (NumberOfElutions>1 and this the not the first one) with separation mode is Affinity, we assume the majority of the AnalyteAffinityLabel bound to the beads is eluted at a new concentration during the first round of elution, then the AnalyteAffinityLabel is still assumed to be present in the additional eluted samples with the residual concentration unknown.*)

		sampleCompositionNoResin/.{_,x:ObjectP[analyteAffinityLabel]}:>{Null,x},

		{AdditionalElution,Except[Affinity],Positive},
		(*If the sample to update is from additional Elution (NumberOfElutions>1 and this the not the first one) with Positive selection and non-Affinity separation mode, we assume the majority of the target along with all the same type of molecules binds to the beads and are eluted at a new concentration for the first round of elution, then those molecules are still assumed to be present in the additional eluted samples with the residual concentration unknown*)
		Module[
			{updateTargetTypeMoleculeConcentrationRules},
			updateTargetTypeMoleculeConcentrationRules=Map[
				Function[{targetTypeMolecule},
					(*Generate the rule of updating the concentration of targetTypeMolecule*)
					{_,ObjectP[targetTypeMolecule]}->{Null,targetTypeMolecule}
				],
				targetTypeMolecules
			];
			(*Return the resin-removed sample composition with all concentrations replaced with the new calculated ones*)
			If[!NullQ[updateTargetTypeMoleculeConcentrationRules],
				sampleCompositionNoResin/.updateTargetTypeMoleculeConcentrationRules,
				sampleCompositionNoResin
			]
		],

		{Alternatives[Loading,Elution,AdditionalElution],Except[Affinity],_},
		(*If the sample to update is from Loading or Elution with Negative selection and non-Affinity separation mode, unknown contaminant binds the beads. Target molecules along with all molecules of the same type are mostly coming out into the Loading collection and the concentration calculated by Transfer with homogeneous-assumption is accurate. We would not be able to know what molecules get removed during loading and eluted at a new concentration, so no other updates*)
		sampleCompositionNoResin,

		{_,_,_},
		(*In case any weird case is not caught by the conditions above, just remove magnetic bead resin*)
		sampleCompositionNoResin
	];

	(* We need to handle a special case here. Since some transfers may result in 0 remaining volume, if we then add more stuff into the remaining sample *)
	(* We get 0 concentration for certain components. This is fine in general but will crash the LabelSample primitive later to update composition *)
	(* Thus we should update all 0 concentrations to Null *)
	updatedSampleCompositionNoZero = If[NullQ[updatedSampleCompositionNoTime],
		Null,
    (* NOTE: Here we append Null as 3rd element for Composition. The reason we do not update real time is because this function can be called before experiment time *)
    (* We will update SamplesOut with real transfer time in parser *)
    Map[
      {#[[1]]/. {ZeroCompositionP -> Null}, #[[2]], Null}&,
      updatedSampleCompositionNoTime
    ]
	];

	(*Return the sampleToAdjust and updatedSampleComposition if there is a sample to adjust and the update is not Null*)
	If[!NullQ[updatedSampleCompositionNoZero],
		updatedSampleCompositionNoZero,
		Nothing
	]
];

updateSamplesCompositionOfStage[
	sampleLabels:ListableP[Alternatives[_String,Null],3],
	stageName:Alternatives[PreWash,Wash,Equilibration,Loading],
	resolvedDestinationWells:ListableP[Alternatives[_String,Null],3],
	resolvedCollectionContainerLabels:ListableP[Alternatives[_String,Null],3],
	downloadedWorkingSampleCompositions:ListableP[{Alternatives[{Null|CompositionP,IdentityModelP|Null},{Null|CompositionP,IdentityModelP|Null,_?DateObjectQ|Null},Null] ...}|Null, 3],
	resolvedVolumes:ListableP[Alternatives[VolumeP,Null],3],
	resolvedAnalyteAffinityLabels:ListableP[Alternatives[ObjectP[],Null],3],
	resolvedTargets:ListableP[Alternatives[ObjectP[],Null],3],
	resolvedMagneticBeadResins:ListableP[Alternatives[ObjectP[],Null],3],
	resolvedSeparationMode:MagneticBeadSeparationModeP,
	resolvedSelectionStrategy:MagneticBeadSeparationSelectionStrategyP,
	downloadedContainerSampleInfoPackets:ListableP[PacketP[],3],
	downloadedContainerContentsPackets:ListableP[PacketP[],3],
	simulation:SimulationP
]:=Module[
	{listOfSampleLabelsToUpdate,listOfSamplesToUpdate,listOfCompositionsToUpdate,updates},
	listOfSampleLabelsToUpdate= {};
	listOfSamplesToUpdate= {};
	listOfCompositionsToUpdate= {};
	updates=MapThread[
		Function[
			{
				destinationWellsBatch,
				collectionContainerLabelsBatch,
				workingSampleCompositionsBatch,
				volumesBatch,
				analyteAffinityLabelsBatch,
				targetsBatch,
				magneticBeadResinsBatch
			},
			MapThread[
				Function[
					{
						destinationWells,
						collectionContainerLabels,
						workingSampleComposition,
						volume,
						analyteAffinityLabel,
						target,
						magneticBeadResin
					},
					MapThread[
						Function[
							{destinationWell,collectionContainerLabel},
							Module[{sampleContainer,sampleToAdjust,sampleLabelToAdjust,updatedComposition},
								(*look up the fake object id of the collection container*)
								sampleContainer=LookupLabeledObject[simulation,collectionContainerLabel];
								(*look up the fake sample id of the collected sample to adjust its composition*)
								sampleToAdjust=FirstCase[
									Lookup[fetchPacketFromCache[sampleContainer, Flatten@downloadedContainerContentsPackets], Contents,Null],
									{destinationWell,x_}:>LinkedObject[x]
								];
								(*look up the label of the simulated sample*)
								sampleLabelToAdjust=LookupObjectLabel[simulation,sampleToAdjust];

								(* Call the helper function to calculate updated compositions*)
								updatedComposition=updateMBSSampleComposition[
									resolvedSeparationMode,
									resolvedSelectionStrategy,
									workingSampleComposition,
									volume,
									analyteAffinityLabel,
									target,
									magneticBeadResin,
									(*collected preWash sample volume*)
									Lookup[fetchPacketFromCache[sampleToAdjust, Flatten@downloadedContainerSampleInfoPackets], Volume,Null],
									(*collected preWash sample composition*)
									Lookup[fetchPacketFromCache[sampleToAdjust, Flatten@downloadedContainerSampleInfoPackets], Composition,Null],
									stageName
								];

								(*Return the samples to adjust and updated composition*)
								If[!NullQ[sampleLabelToAdjust],
									listOfSampleLabelsToUpdate=AppendTo[listOfSampleLabelsToUpdate,sampleLabelToAdjust];
									listOfSamplesToUpdate=AppendTo[listOfSamplesToUpdate,sampleToAdjust];
									listOfCompositionsToUpdate=AppendTo[listOfCompositionsToUpdate,updatedComposition];
								]
							]
						],
						{destinationWells,collectionContainerLabels}
					]
				],
				{
					destinationWellsBatch,
					collectionContainerLabelsBatch,
					workingSampleCompositionsBatch,
					volumesBatch,
					analyteAffinityLabelsBatch,
					targetsBatch,
					magneticBeadResinsBatch
				}
			]
		],
		{
			resolvedDestinationWells,
			resolvedCollectionContainerLabels,
			unflattenListHelper[downloadedWorkingSampleCompositions,sampleLabels],
			resolvedVolumes,
			resolvedAnalyteAffinityLabels,
			resolvedTargets,
			unflattenListHelper[resolvedMagneticBeadResins,sampleLabels]
		}
	];
	(*Return the updated lists*)
	{listOfSamplesToUpdate,listOfSampleLabelsToUpdate,listOfCompositionsToUpdate}
];

(*Helper Function to resolve destination wells and collection container labels based on collection container, storage condition, and label information *)
simulateDestinationWellsAndContainerLabelsOfStage[
	stageCollectionContainersBatch:ListableP[Alternatives[Null,Automatic,ObjectP[]],3],
	stageDestinationWellsBatch:ListableP[Alternatives[Null,_String],3],
	stageCollectionContainerIndicesBatch:ListableP[Alternatives[Null,_Integer],3],
	stageCollectionContainerLabelsBatch:ListableP[Alternatives[Null,_String],3],
	stageCollectionStorageConditionsBatch:ListableP[Alternatives[Null,SampleStorageTypeP,Disposal,ObjectP[]],3],
	stageBoolsBatch:ListableP[Alternatives[Null,BooleanP],3],
	samplesBatch:ListableP[ObjectP[],3],
	initialCollectionContainerLookup_Association,
	inheritedAssocForLookup_Association
]:=Module[
	{currentCollectionContainerLookup,simulatedOutput},
	currentCollectionContainerLookup=initialCollectionContainerLookup;
	simulatedOutput=MapThread[
		Function[{collectionContainers,destinationWells,collectionContainerIndices,collectionContainerLabels,collectionStorageCondition,stageBools,simulatedSample},
			If[stageBools,
				Transpose@MapThread[
					Function[{collectionContainer,destinationWell,collectionContainerIndex,collectionContainerLabel},
						Module[{availableContainerInfo},

							availableContainerInfo=Lookup[
								currentCollectionContainerLookup,
								Key[{collectionContainer,collectionContainerIndex,collectionStorageCondition}],
								Null
							];

							(* Was there an available container? (Matching object/model with available positions and same storage condition) *)
							If[And[
								!NullQ[availableContainerInfo],
                Or[(*It is a Vessel, and the index is a number, i.e. the available container was found by container-index-storagecondition match. Then we want to pool the samples*)
                  MatchQ[collectionContainerIndex,_Integer]&&                  EqualQ[Length[Lookup[availableContainerInfo,AllowedPositions]],1],
                  (*There are available positions (i.e. container is a plate*)
                  Length[Lookup[availableContainerInfo,AvailablePositions]]>0
                ]
							],

								(* Yes there was an available container *)
								Module[{containerLabel,allowedPositions,availablePositions,newPositionToOccupy},

									(* Get the info about the object *)
									{containerLabel,allowedPositions,availablePositions} = Lookup[availableContainerInfo, {Label,AllowedPositions,AvailablePositions}];

									(* If the user specified a destination well, use it otherwise default to the first available position *)
									newPositionToOccupy=Which[
										MatchQ[destinationWell,_String]&&!MemberQ[allowedPositions,destinationWell],
										  "A1",
										MatchQ[destinationWell,_String],
										  destinationWell,
                    (*If it is a vessel, i.e. only 1 position is available, use that position. We are pooling samples.*)
                    EqualQ[Length[allowedPositions],1],
                      FirstCase[allowedPositions,_String,"A1"],
                    True,
										  First[availablePositions]
									];

									(* update the lookup with new container information *)
									currentCollectionContainerLookup=AssociateTo[
										currentCollectionContainerLookup,
										{collectionContainer,collectionContainerIndex,collectionStorageCondition}->{
											Label->containerLabel,
											AllowedPositions->allowedPositions,
											AvailablePositions->DeleteCases[availablePositions,newPositionToOccupy]
										}
									];

									(* return the resolved collection container label and destination well *)
									{containerLabel,newPositionToOccupy}

								],

								(* No there was no an available container *)
								Module[{containerLabel,allowedPositions,occupiedPositions,availablePositions,newPositionToOccupy,positionsAvailable},

									(* Create a new label for the plate if one is not given *)
									containerLabel=If[MatchQ[collectionContainerLabel,Automatic|Null],
										CreateUniqueLabel["MBS collection container"],
										collectionContainerLabel
									];

									(* Get the allowed, occupied, and open positions in the collection container *)
									{allowedPositions,occupiedPositions}=If[MatchQ[collectionContainer,ObjectP[Object[Container]]],
										(* If the container is an object. Lookup from the cache *)
										{
											Lookup[fastAssocLookup[inheritedAssocForLookup,collectionContainer, {Model,Positions}],Name],
											fastAssocLookup[inheritedAssocForLookup,collectionContainer,Contents][[All,1]]
										},
										(* Otherwise if the container is a model start with all the allowed positions *)
										{
											Lookup[fastAssocLookup[inheritedAssocForLookup,collectionContainer,Positions],Name],
											{}
										}
									];
									(* Available positions are those that are allowed but not occupied *)
									availablePositions=UnsortedComplement[allowedPositions,occupiedPositions];

									(* If there are no open positions and the user did not specify a destination well, use the first position *)
									If[MatchQ[availablePositions,{}]&&MatchQ[destinationWell,Null|Automatic],
										(* Default to first used position *)
										availablePositions={"A1"};
									];

									(* Determine which position to use for this sample *)
									newPositionToOccupy=Which[
										MatchQ[destinationWell,_String]&&!MemberQ[allowedPositions,destinationWell],
										"A1",
										MatchQ[destinationWell,_String],
										destinationWell,
										True,
										First[availablePositions]
									];

									(* Remove the newly occupied position from the available positions *)
									positionsAvailable=DeleteCases[availablePositions,newPositionToOccupy];

									(* Update the lookup with the new plate information *)
									currentCollectionContainerLookup=AssociateTo[currentCollectionContainerLookup,
										{collectionContainer,collectionContainerIndex,collectionStorageCondition}->{
											Label->containerLabel,
											AllowedPositions->allowedPositions,
											AvailablePositions->positionsAvailable
										}
									];

									(* return the resolved collection container label and destination well *)
									{containerLabel,newPositionToOccupy}
								]
							]
						]
					],
					{collectionContainers,destinationWells,collectionContainerIndices,collectionContainerLabels}
				],
				Transpose@ConstantArray[{Null,Null},Length[collectionContainers]]
			]
		],
		{stageCollectionContainersBatch, stageDestinationWellsBatch, stageCollectionContainerIndicesBatch, stageCollectionContainerLabelsBatch, stageCollectionStorageConditionsBatch, stageBoolsBatch, samplesBatch}
	];
	(*Return the simulated output and updated lookup*)
	{simulatedOutput,currentCollectionContainerLookup}
];

(*Helper function used in simulation to simulate labels for buffers used in prewash and multiple wash stages*)
simulateWashStageBufferLabels[
	stageBools:ListableP[Alternatives[BooleanP,Null],3],
	stageBuffers:ListableP[Alternatives[ObjectP[],Null],3],
	stageBufferVolumes:ListableP[Alternatives[VolumeP,Null],3],
	numberOfStages:ListableP[Alternatives[_Integer,Null],3],
	initialBufferLabelLookup_Association
]:=Module[
	{currentBufferLabelLookup,bufferLabels},
	currentBufferLabelLookup=initialBufferLabelLookup;
	bufferLabels=MapThread[
		Function[{doStageBatch,bufferBatch, volumeBatch, repeatsBatch},
			MapThread[
				Function[{doStage,buffer,volume,repeats},
					Module[{currentBufferInfo,bufferFromLookup},

						If[doStage,
							(* Table this by the number of repeats *)
							(* Make sure the buffer is a canonical object *)
							buffer=Download[buffer,Object];

							Table[
								(* See if this buffer already exists in the lookup and there is an instance that can hold the needed volume *)
								bufferFromLookup=Lookup[currentBufferLabelLookup,buffer,<||>];
								currentBufferInfo=FirstCase[bufferFromLookup,_?(LessEqualQ[#[[2]] + volume, 50 Milliliter] &),Null];

								If[!NullQ[currentBufferInfo],

									(* If the buffer already exists *)
									Module[{label, amount, containerLabel,newAssoc},

										(* Extract current info *)
										{label, amount, containerLabel}=currentBufferInfo;

										(* Add to the amount *)
										newAssoc=<|label->{label,amount+SafeRound[volume*1.05, 1 Microliter],containerLabel}|>;
										currentBufferLabelLookup=AssociateTo[currentBufferLabelLookup,
											buffer->AssociateTo[bufferFromLookup,newAssoc]
										];

										(* Return the label *)
										label
									],

									(* If the buffer does not exist in the lookup *)
									Module[{newLabel,newContainerLabel,newAssoc},

										(* Create new labels *)
										newLabel=CreateUniqueLabel["MBS Buffer"];
										newContainerLabel=CreateUniqueLabel["MBS Buffer Container"];

										(* Add to the lookup *)
										newAssoc=<|newLabel->{newLabel,SafeRound[volume*1.05, 1 Microliter],newContainerLabel}|>;
										currentBufferLabelLookup=AssociateTo[currentBufferLabelLookup,
											buffer->AssociateTo[bufferFromLookup,newAssoc]
										];

										(* Return the new label *)
										newLabel
									]
								],
								{i,1,repeats}
							]
						]
					]
				],
				{doStageBatch,bufferBatch, volumeBatch, repeatsBatch}
			]
		],
		{stageBools,stageBuffers,stageBufferVolumes,numberOfStages}
	];
	(*Return the buffer labels and updated currentBufferLabelLookup*)
	{bufferLabels,currentBufferLabelLookup}
];

(*Helper function used in simulation to create tuples that UploadSampleTransfer can accept*)
simulateWashStageTuples[
	stageBools:ListableP[Alternatives[Null,BooleanP],3],
	stageBuffers:ListableP[Alternatives[Null,ObjectP[]],3],
	stageBufferVolumes:ListableP[Alternatives[Null,VolumeP],3],
	stageAspirationVolumes:ListableP[Alternatives[Null,VolumeP, All],3],
	numberOfStages:ListableP[Alternatives[Null,_Integer],3],
	stageCollectionContainers:ListableP[Alternatives[Null,ObjectP[]],3],
	stageDestinationWells:ListableP[Alternatives[Null,_String],3],
	expAssayContainers:ListableP[Alternatives[Null,ObjectP[]],3],
	expAssayWells:ListableP[Alternatives[Null,_String],3]
]:=Module[
	{stageTuples,flattenedStageTuples},
	stageTuples=MapThread[
		Function[
			{
				stageBoolsBatch,stageBuffersBatch,stageBufferVolumesBatch,stageAspirationVolumesBatch,numberOfStagesBatch,
				stageCollectionContainersBatch,stageDestinationWellsBatch,
				assayContainersBatch,assayWellsBatch
			},
			Module[{maxNumStages,numberOfStagesBatchBools,transferAndMixPrimitives,waitPrimitive},
				(* Get the max number of times we are Stageing in this batch *)
				maxNumStages=Max[DeleteCases[numberOfStagesBatch,Null],{0}];

				(* Table that number of stagees *)
				transferAndMixPrimitives=Table[

					(* See what samples we use this round *)
					numberOfStagesBatchBools=(LessEqualQ[i,#])&/@numberOfStagesBatch;

					If[Or@@numberOfStagesBatchBools,
						Join@@{
							(* Transfer stageBuffer into assay container, Move to the magnet then transfer to collection container *)
							MapThread[
								{#1,#2,#3}&,
								{
									PickList[stageBuffersBatch,numberOfStagesBatchBools],
									Transpose[{PickList[assayWellsBatch,numberOfStagesBatchBools],PickList[assayContainersBatch,numberOfStagesBatchBools]}],
									PickList[stageBufferVolumesBatch,numberOfStagesBatchBools]
								}
							],
							MapThread[
								{#1,#2,#3}&,
								{
									Transpose[{PickList[assayWellsBatch,numberOfStagesBatchBools],PickList[assayContainersBatch,numberOfStagesBatchBools]}],
									Transpose[{PickList[stageDestinationWellsBatch,numberOfStagesBatchBools][[All,i]],PickList[stageCollectionContainersBatch,numberOfStagesBatchBools][[All,i]]}],
									PickList[stageAspirationVolumesBatch,numberOfStagesBatchBools]
								}
							]
						},
						{}
					],
					{i,1,maxNumStages}
				]
			]
		],
		{stageBools,stageBuffers,stageBufferVolumes,stageAspirationVolumes,numberOfStages,stageCollectionContainers,stageDestinationWells,expAssayContainers,expAssayWells}
	];
	flattenedStageTuples=If[MatchQ[stageTuples,ListableP[{}]],
		{},
		Flatten[stageTuples,{1,2,3}]
	]
];

(*---Main function accepting nested sample objects as inputs (e.g. {{s1},{s2,s3}})---*)
ExperimentMagneticBeadSeparationCore[
	myNestedSamples:ListableP[{ObjectP[Object[Sample]]..}],
	mySemiNestedInputs:ListableP[ListableP[ObjectP[{Object[Sample],Object[Container],Model[Sample]}]|_String|{LocationPositionP,_String|ObjectP[Object[Container]]}]],
	myUnnestedSampleInputs:ListableP[ListableP[ObjectP[Object[Sample]]]],
	myOriginalOptions:{_Rule...},
	myOptions:OptionsPattern[ExperimentMagneticBeadSeparation]
]:=Module[
	{
    outputSpecification,output,gatherTests,messages,notInEngine,options,listedSamples,listedOptions,simulation,currentSimulation,
		safeOptionsNamed,
		mySamplesWithPreparedSamples,safeOps,safeOpsTests,validLengths,
		validLengthTests,templatedOptions,templateTests,inheritedOptions,upload,confirm,canaryBranch,fastTrack,parentProtocol,cache,

		processingOrder,selectionStrategy,
		inputPreWashCollectionContainers,inputEquilibrationCollectionContainers,inputLoadingCollectionContainers,inputWashCollectionContainers,
    inputSecondaryWashCollectionContainers,inputTertiaryWashCollectionContainers,inputQuaternaryWashCollectionContainers,
    inputQuinaryWashCollectionContainers,inputSenaryWashCollectionContainers,inputSeptenaryWashCollectionContainers,
		inputElutionCollectionContainers,

		preWashCollectionContainers,preWashDestinationWells,preWashCollectionContainerLabels,numberOfPreWashes,
		equilibrationCollectionContainers,equilibrationDestinationWells,equilibrationCollectionContainerLabels,
		loadingCollectionContainers,loadingDestinationWells,loadingCollectionContainerLabels,
		washCollectionContainers,washDestinationWells,washCollectionContainerLabels,numberOfWashes,
		secondaryWashCollectionContainers,secondaryWashDestinationWells,secondaryWashCollectionContainerLabels,numberOfSecondaryWashes,
		tertiaryWashCollectionContainers,tertiaryWashDestinationWells,tertiaryWashCollectionContainerLabels,numberOfTertiaryWashes,
		quaternaryWashCollectionContainers,quaternaryWashDestinationWells,quaternaryWashCollectionContainerLabels,numberOfQuaternaryWashes,
		quinaryWashCollectionContainers,quinaryWashDestinationWells,quinaryWashCollectionContainerLabels,numberOfQuinaryWashes,
		senaryWashCollectionContainers,senaryWashDestinationWells,senaryWashCollectionContainerLabels,numberOfSenaryWashes,
		septenaryWashCollectionContainers,septenaryWashDestinationWells,septenaryWashCollectionContainerLabels,numberOfSeptenaryWashes,
		elutionCollectionContainers,elutionDestinationWells,elutionCollectionContainerLabels,numberOfElutions,
		containerOutLabels,sampleOutLabels,

		correctedPreWashCollectionContainers,correctedPreWashDestinationWells,correctedPreWashCollectionContainerIndices,correctedPreWashCollectionContainerLabels,
		correctedEquilibrationCollectionContainers,correctedEquilibrationDestinationWells,correctedEquilibrationCollectionContainerIndices,correctedEquilibrationCollectionContainerLabels,
		correctedLoadingCollectionContainers,correctedLoadingDestinationWells,correctedLoadingCollectionContainerIndices,correctedLoadingCollectionContainerLabels,
		correctedWashCollectionContainers,correctedWashDestinationWells,correctedWashCollectionContainerIndices,correctedWashCollectionContainerLabels,
		correctedSecondaryWashCollectionContainers,correctedSecondaryWashDestinationWells,correctedSecondaryWashCollectionContainerIndices,correctedSecondaryWashCollectionContainerLabels,
		correctedTertiaryWashCollectionContainers,correctedTertiaryWashDestinationWells,correctedTertiaryWashCollectionContainerIndices,correctedTertiaryWashCollectionContainerLabels,
		correctedQuaternaryWashCollectionContainers,correctedQuaternaryWashDestinationWells,correctedQuaternaryWashCollectionContainerIndices,correctedQuaternaryWashCollectionContainerLabels,
		correctedQuinaryWashCollectionContainers,correctedQuinaryWashDestinationWells,correctedQuinaryWashCollectionContainerIndices,correctedQuinaryWashCollectionContainerLabels,
		correctedSenaryWashCollectionContainers,correctedSenaryWashDestinationWells,correctedSenaryWashCollectionContainerIndices,correctedSenaryWashCollectionContainerLabels,
		correctedSeptenaryWashCollectionContainers,correctedSeptenaryWashDestinationWells,correctedSeptenaryWashCollectionContainerIndices,correctedSeptenaryWashCollectionContainerLabels,
		correctedElutionCollectionContainers,correctedElutionDestinationWells,correctedElutionCollectionContainerIndices,correctedElutionCollectionContainerLabels,
		preWashCollectionContainerIndices,equilibrationCollectionContainerIndices,loadingCollectionContainerIndices,washCollectionContainerIndices,secondaryWashCollectionContainerIndices,tertiaryWashCollectionContainerIndices,quaternaryWashCollectionContainerIndices,quinaryWashCollectionContainerIndices,senaryWashCollectionContainerIndices,septenaryWashCollectionContainerIndices,elutionCollectionContainerIndices,
		correctedContainerOutLabels,correctedSampleOutLabels,
    furtherCorrectedPreWashCollectionContainers, furtherCorrectedPreWashDestinationWells, furtherCorrectedPreWashCollectionContainerIndices,
    furtherCorrectedPreWashCollectionContainerLabels,
    furtherCorrectedEquilibrationCollectionContainers, furtherCorrectedEquilibrationDestinationWells, furtherCorrectedEquilibrationCollectionContainerIndices,
    furtherCorrectedEquilibrationCollectionContainerLabels,
    furtherCorrectedLoadingCollectionContainers, furtherCorrectedLoadingDestinationWells, furtherCorrectedLoadingCollectionContainerIndices,
    furtherCorrectedLoadingCollectionContainerLabels,
    furtherCorrectedWashCollectionContainers, furtherCorrectedWashDestinationWells, furtherCorrectedWashCollectionContainerIndices,
    furtherCorrectedWashCollectionContainerLabels,
    furtherCorrectedSecondaryWashCollectionContainers, furtherCorrectedSecondaryWashDestinationWells, furtherCorrectedSecondaryWashCollectionContainerIndices,
    furtherCorrectedSecondaryWashCollectionContainerLabels,
    furtherCorrectedTertiaryWashCollectionContainers, furtherCorrectedTertiaryWashDestinationWells, furtherCorrectedTertiaryWashCollectionContainerIndices,
    furtherCorrectedTertiaryWashCollectionContainerLabels,
    furtherCorrectedQuaternaryWashCollectionContainers, furtherCorrectedQuaternaryWashDestinationWells, furtherCorrectedQuaternaryWashCollectionContainerIndices,
    furtherCorrectedQuaternaryWashCollectionContainerLabels,
    furtherCorrectedQuinaryWashCollectionContainers, furtherCorrectedQuinaryWashDestinationWells, furtherCorrectedQuinaryWashCollectionContainerIndices,
    furtherCorrectedQuinaryWashCollectionContainerLabels,
    furtherCorrectedSenaryWashCollectionContainers, furtherCorrectedSenaryWashDestinationWells, furtherCorrectedSenaryWashCollectionContainerIndices,
    furtherCorrectedSenaryWashCollectionContainerLabels,
    furtherCorrectedSeptenaryWashCollectionContainers, furtherCorrectedSeptenaryWashDestinationWells, furtherCorrectedSeptenaryWashCollectionContainerIndices,
    furtherCorrectedSeptenaryWashCollectionContainerLabels,
    furtherCorrectedElutionCollectionContainers, furtherCorrectedElutionDestinationWells, furtherCorrectedElutionCollectionContainerIndices,
    furtherCorrectedElutionCollectionContainerLabels,
    furtherCorrectedContainerOutLabels,furtherCorrectedSampleOutLabels,

		resolvedOptionsWithConvertedContainers,outputPreWashCollectionContainers,outputEquilibrationCollectionContainers,outputLoadingCollectionContainers,outputWashCollectionContainers,outputSecondaryWashCollectionContainers,outputTertiaryWashCollectionContainers,outputQuaternaryWashCollectionContainers,outputQuinaryWashCollectionContainers,outputSenaryWashCollectionContainers, outputSeptenaryWashCollectionContainers,outputElutionCollectionContainers,

		correctedListyOptions,

		expandedSafeOps,expandedSafeOpsUnappended,mbsOptionsAssociation,flatMySamplesWithPreparedSamples,analyteAffinityLabels,magneticBeadAffinityLabels,targetMolecules,preWashCollectionStorageConditions,equilibrationCollectionStorageConditions,loadingCollectionStorageConditions,washCollectionStorageConditions,
		secondaryWashCollectionStorageConditions,tertiaryWashCollectionStorageConditions,quaternaryWashCollectionStorageConditions,quinaryWashCollectionStorageConditions,senaryWashCollectionStorageConditions,septenaryWashCollectionStorageConditions,elutionCollectionStorageConditions,
		allTargetMolecules,allAnalyteAffinityLabels,allMagneticBeadIdentityModels,allMagnetizationRackModels,allMagnetizationRackObjects,magnetizationRacks,uniqueContainerModels,uniqueContainerObjects,assayContainerModels,uniqueStorageConditions,
		sampleDownloadPacket,identityModelDownloadPacket,
		containerModelDownloadPacket,containerObjectDownloadPacket,containerContentsObjectDownloadPacket,
		allPackets,cacheBall,resolvedOptionsResult,resolvedOptions,resolvedOptionsTests,
		nestedIndexMatchingOptions,unnestedIndexMatchingOptions,unnestedResolvedOptions,collapsedResolvedOptions,userReturnFriendlyOptions,myNormalizedCollapsedResolvedOptions,collapsedUnnestedResolvedOptions,resolvedPreparation,returnEarlyQ,performSimulationQ,resultQ,resourceResult,protocolObject,
		roboticSimulation,runTime,resourcePacketTests,optionsWithObjects,userSpecifiedObjects,simulatedProtocol,simulatedProtocolSimulation,
		objectsExistQs, uniqueSampleObjects, uniqueSampleModels, modelDownloadPacket
	},

	(* Determine the requested return value from the function *)
	outputSpecification=Quiet[OptionValue[Output]];
	output=ToList[outputSpecification];

	(* Determine if we should keep a running list of tests *)
	gatherTests=MemberQ[output,Tests];
	messages=!gatherTests;

	(*Determine if we are in Engine or not, in Engine we silence warnings*)
	notInEngine=!MatchQ[$ECLApplication,Engine];

	(* Get specified options into usable form *)
	options = ToList[myOptions];

	(* Lookup the simulation *)
  (* Note:simulation from simulateSamplePreparationPacketsNew is passed on from other overload here *)
	simulation = Lookup[options,Simulation];

	(* Remove temporal links -- we have to remove all links from the samples because we need to store them in nested format in the protocol object; i.e. we need to put them into Expression fields whose pattern is {{ObjectReferenceP..}..} so they can't be links *)
	{listedSamples,listedOptions}=removeLinks[Download[ToList[myNestedSamples],Object],options];

	(*--Call SafeOptions and ValidInputLengthsQ--*)
	(*Call SafeOptions to make sure all options match patterns*)
	{safeOptionsNamed,safeOpsTests}=If[gatherTests,
		SafeOptions[ExperimentMagneticBeadSeparation,listedOptions,AutoCorrect->False,Output->{Result,Tests}],
		{SafeOptions[ExperimentMagneticBeadSeparation,listedOptions,AutoCorrect->False],{}}
	];

	(* replace all objects referenced by Name to ID *)
	{mySamplesWithPreparedSamples,safeOps}=sanitizeInputs[listedSamples,safeOptionsNamed,Simulation->simulation];

	(*If the specified options don't match their patterns or if option lengths are invalid, return $Failed*)
	If[MatchQ[safeOps,$Failed],
		Return[outputSpecification/.{
			Result->$Failed,
			Tests->safeOpsTests,
			Options->$Failed,
			Preview->Null
		}]
	];

	(*Call ValidInputLengthsQ to make sure all options have matching lengths*)
	{validLengths,validLengthTests}=If[gatherTests,
		ValidInputLengthsQ[ExperimentMagneticBeadSeparation,{mySamplesWithPreparedSamples},safeOps,Output->{Result,Tests}],
		{ValidInputLengthsQ[ExperimentMagneticBeadSeparation,{mySamplesWithPreparedSamples},safeOps],Null}
	];

	(*If option lengths are invalid, return $Failed (or the tests up to this point)*)
	If[!validLengths,
		Return[outputSpecification/.{
			Result->$Failed,
			Tests->Join[safeOpsTests,validLengthTests],
			Options->$Failed,
			Preview->Null
		}]
	];

	(*--Use any template options to get values for options not specified in myOptions--*)
	{templatedOptions,templateTests}=If[gatherTests,
		ApplyTemplateOptions[ExperimentMagneticBeadSeparation,{mySamplesWithPreparedSamples},listedOptions,Output->{Result,Tests}],
		{ApplyTemplateOptions[ExperimentMagneticBeadSeparation,{mySamplesWithPreparedSamples},listedOptions],Null}
	];

	(*Return early if the template cannot be used - will only occur if the template object does not exist*)
	If[MatchQ[templatedOptions,$Failed],
		Return[outputSpecification/.{
			Result->$Failed,
			Tests->Join[safeOpsTests,validLengthTests,templateTests],
			Options->$Failed,
			Preview->Null
		}]
	];

	(*Replace our safe options with the inherited options from the template*)
	inheritedOptions=ReplaceRule[safeOps,templatedOptions];

	(*get assorted hidden options*)
	{upload,confirm,canaryBranch,fastTrack,parentProtocol,cache}=Lookup[inheritedOptions,{Upload,Confirm,CanaryBranch,FastTrack,ParentProtocol,Cache}];

	(* Get options that possibly need to have their listyness modified so ExpandIndexMatchedInputs works as wanted *)
	{
		processingOrder,selectionStrategy,
		inputPreWashCollectionContainers,preWashCollectionContainerLabels,numberOfPreWashes,
		inputEquilibrationCollectionContainers,equilibrationCollectionContainerLabels,
		inputLoadingCollectionContainers,loadingCollectionContainerLabels,
		inputWashCollectionContainers,washCollectionContainerLabels,numberOfWashes,
		inputSecondaryWashCollectionContainers,secondaryWashCollectionContainerLabels,numberOfSecondaryWashes,
		inputTertiaryWashCollectionContainers,tertiaryWashCollectionContainerLabels,numberOfTertiaryWashes,
		inputQuaternaryWashCollectionContainers,quaternaryWashCollectionContainerLabels,numberOfQuaternaryWashes,
		inputQuinaryWashCollectionContainers,quinaryWashCollectionContainerLabels,numberOfQuinaryWashes,
		inputSenaryWashCollectionContainers,senaryWashCollectionContainerLabels,numberOfSenaryWashes,
		inputSeptenaryWashCollectionContainers,septenaryWashCollectionContainerLabels,numberOfSeptenaryWashes,
		inputElutionCollectionContainers,elutionCollectionContainerLabels,numberOfElutions,
		containerOutLabels,sampleOutLabels
	}=Lookup[
		inheritedOptions,
		{
			ProcessingOrder,SelectionStrategy,
			PreWashCollectionContainer,PreWashCollectionContainerLabel,NumberOfPreWashes,
			EquilibrationCollectionContainer,EquilibrationCollectionContainerLabel,
			LoadingCollectionContainer,LoadingCollectionContainerLabel,
			WashCollectionContainer,WashCollectionContainerLabel,NumberOfWashes,
			SecondaryWashCollectionContainer,SecondaryWashCollectionContainerLabel,NumberOfSecondaryWashes,
			TertiaryWashCollectionContainer,TertiaryWashCollectionContainerLabel,NumberOfTertiaryWashes,
			QuaternaryWashCollectionContainer,QuaternaryWashCollectionContainerLabel,NumberOfQuaternaryWashes,
			QuinaryWashCollectionContainer,QuinaryWashCollectionContainerLabel,NumberOfQuinaryWashes,
			SenaryWashCollectionContainer,SenaryWashCollectionContainerLabel,NumberOfSenaryWashes,
			SeptenaryWashCollectionContainer,SeptenaryWashCollectionContainerLabel,NumberOfSeptenaryWashes,
			ElutionCollectionContainer,ElutionCollectionContainerLabel,NumberOfElutions,
			ContainerOutLabel,SampleOutLabel
		}
	];
	(* For each of the stages, expand the collection container, destination well, and collection container label options differently than how ExpandIndexMatchedInputs would *)

	(*-=-Converting format of output options and resolve number of each stage*)
	{preWashCollectionContainers,preWashDestinationWells,preWashCollectionContainerIndices} = convertInputContainerFormat[inputPreWashCollectionContainers];
	{equilibrationCollectionContainers,equilibrationDestinationWells,equilibrationCollectionContainerIndices} = convertInputContainerFormat[inputEquilibrationCollectionContainers];
	{loadingCollectionContainers,loadingDestinationWells,loadingCollectionContainerIndices} = convertInputContainerFormat[inputLoadingCollectionContainers];
	{washCollectionContainers,washDestinationWells,washCollectionContainerIndices} = convertInputContainerFormat[inputWashCollectionContainers];
	{secondaryWashCollectionContainers,secondaryWashDestinationWells,secondaryWashCollectionContainerIndices} = convertInputContainerFormat[inputSecondaryWashCollectionContainers];
	{tertiaryWashCollectionContainers,tertiaryWashDestinationWells,tertiaryWashCollectionContainerIndices} = convertInputContainerFormat[inputTertiaryWashCollectionContainers];
	{quaternaryWashCollectionContainers,quaternaryWashDestinationWells,quaternaryWashCollectionContainerIndices} = convertInputContainerFormat[inputQuaternaryWashCollectionContainers];
	{quinaryWashCollectionContainers,quinaryWashDestinationWells,quinaryWashCollectionContainerIndices} = convertInputContainerFormat[inputQuinaryWashCollectionContainers];
	{senaryWashCollectionContainers,senaryWashDestinationWells,senaryWashCollectionContainerIndices} = convertInputContainerFormat[inputSenaryWashCollectionContainers];
	{septenaryWashCollectionContainers,septenaryWashDestinationWells,septenaryWashCollectionContainerIndices} = convertInputContainerFormat[inputSeptenaryWashCollectionContainers];
	{elutionCollectionContainers,elutionDestinationWells,elutionCollectionContainerIndices} = convertInputContainerFormat[inputElutionCollectionContainers];

	(* -- PreWash -- *)
	{correctedPreWashCollectionContainers,correctedPreWashDestinationWells,correctedPreWashCollectionContainerIndices,correctedPreWashCollectionContainerLabels}=Map[
		Function[{options},
			Module[{resolvedNumberOfPreWashes},

				(* Resolve number of pre washes *)
				resolvedNumberOfPreWashes = If[MatchQ[numberOfPreWashes,ListableP[Automatic|Null,3]],1,numberOfPreWashes];

				expandIndexMatchedInputsHelper[myNestedSamples,options,resolvedNumberOfPreWashes]
			]
		],
		{preWashCollectionContainers, preWashDestinationWells, preWashCollectionContainerIndices,preWashCollectionContainerLabels}
	];
  (* In case that the multiple samples or rounds are actually intended to be pooled in PreWashCollectionContainer, these options are expanded to match the length of samples of each batch*)
  furtherCorrectedPreWashCollectionContainers = expandStageCollectionOption[myNestedSamples,correctedPreWashCollectionContainers,numberOfPreWashes];

  furtherCorrectedPreWashDestinationWells=expandStageCollectionOption[myNestedSamples,correctedPreWashDestinationWells,numberOfPreWashes];

  furtherCorrectedPreWashCollectionContainerIndices = expandStageCollectionOption[myNestedSamples,correctedPreWashCollectionContainerIndices,numberOfPreWashes];

  furtherCorrectedPreWashCollectionContainerLabels = expandStageCollectionOption[myNestedSamples,correctedPreWashCollectionContainerLabels,numberOfPreWashes];

	(* -- Equilibration -- *)
	{correctedEquilibrationCollectionContainers,correctedEquilibrationDestinationWells,correctedEquilibrationCollectionContainerIndices,correctedEquilibrationCollectionContainerLabels}=Map[
		Function[{options},
			(* You can only do the equilibration stage once *)
			expandIndexMatchedInputsHelper[myNestedSamples,options,1]
		],
		{equilibrationCollectionContainers, equilibrationDestinationWells, equilibrationCollectionContainerIndices,equilibrationCollectionContainerLabels}
	];
  (* In case that the multiple samples or rounds are actually intended to be pooled in EquilibrationCollectionContainer, these options are expanded to match the length of samples of each batch*)
  furtherCorrectedEquilibrationCollectionContainers = expandStageCollectionOption[myNestedSamples,correctedEquilibrationCollectionContainers,1];

  furtherCorrectedEquilibrationDestinationWells=expandStageCollectionOption[myNestedSamples,correctedEquilibrationDestinationWells,1];

  furtherCorrectedEquilibrationCollectionContainerIndices = expandStageCollectionOption[myNestedSamples,correctedEquilibrationCollectionContainerIndices,1];

  furtherCorrectedEquilibrationCollectionContainerLabels = expandStageCollectionOption[myNestedSamples,correctedEquilibrationCollectionContainerLabels,1];
  
	(* -- Loading -- *)
	{correctedLoadingCollectionContainers,correctedLoadingDestinationWells,correctedLoadingCollectionContainerIndices,correctedLoadingCollectionContainerLabels}=Map[
		Function[{options},
			(* You can only do the loading stage once *)
			expandIndexMatchedInputsHelper[myNestedSamples,options,1]
		],
		{loadingCollectionContainers, loadingDestinationWells, loadingCollectionContainerIndices, loadingCollectionContainerLabels}
	];
  (* In case that the multiple samples or rounds are actually intended to be pooled in LoadingCollectionContainer, these options are expanded to match the length of samples of each batch*)
  furtherCorrectedLoadingCollectionContainers = expandStageCollectionOption[myNestedSamples,correctedLoadingCollectionContainers,1];

  furtherCorrectedLoadingDestinationWells=expandStageCollectionOption[myNestedSamples,correctedLoadingDestinationWells,1];

  furtherCorrectedLoadingCollectionContainerIndices = expandStageCollectionOption[myNestedSamples,correctedLoadingCollectionContainerIndices,1];

  furtherCorrectedLoadingCollectionContainerLabels = expandStageCollectionOption[myNestedSamples,correctedLoadingCollectionContainerLabels,1];

	(* -- Wash -- *)
	{correctedWashCollectionContainers,correctedWashDestinationWells,correctedWashCollectionContainerIndices,correctedWashCollectionContainerLabels}=Map[
		Function[{options},
			Module[{resolvedNumberOfWashes},

				(* Resolve number of washes *)
				resolvedNumberOfWashes = If[MatchQ[numberOfWashes,ListableP[Automatic|Null,3]],1,numberOfWashes];

				expandIndexMatchedInputsHelper[myNestedSamples,options,resolvedNumberOfWashes]

			]
		],
		{washCollectionContainers, washDestinationWells, washCollectionContainerIndices,washCollectionContainerLabels}
	];
  (* In case that the multiple samples or rounds are actually intended to be pooled in WashCollectionContainer, these options are expanded to match the length of samples of each batch*)
  furtherCorrectedWashCollectionContainers = expandStageCollectionOption[myNestedSamples,correctedWashCollectionContainers,numberOfWashes];

  furtherCorrectedWashDestinationWells=expandStageCollectionOption[myNestedSamples,correctedWashDestinationWells,numberOfWashes];

  furtherCorrectedWashCollectionContainerIndices = expandStageCollectionOption[myNestedSamples,correctedWashCollectionContainerIndices,numberOfWashes];

  furtherCorrectedWashCollectionContainerLabels = expandStageCollectionOption[myNestedSamples,correctedWashCollectionContainerLabels,numberOfWashes];

	(* -- SecondaryWash -- *)
	{correctedSecondaryWashCollectionContainers,correctedSecondaryWashDestinationWells,correctedSecondaryWashCollectionContainerIndices,correctedSecondaryWashCollectionContainerLabels}=Map[
		Function[{options},
			Module[{resolvedNumberOfSecondaryWashes},

				(* Resolve number of washes *)
				resolvedNumberOfSecondaryWashes = If[MatchQ[numberOfSecondaryWashes,ListableP[Automatic|Null,3]],1,numberOfSecondaryWashes];

				expandIndexMatchedInputsHelper[myNestedSamples,options,resolvedNumberOfSecondaryWashes]

			]
		],
		{secondaryWashCollectionContainers, secondaryWashDestinationWells, secondaryWashCollectionContainerIndices,secondaryWashCollectionContainerLabels}
	];
  (* In case that the multiple samples or rounds are actually intended to be pooled in SecondaryWashCollectionContainer, these options are expanded to match the length of samples of each batch*)
  furtherCorrectedSecondaryWashCollectionContainers = expandStageCollectionOption[myNestedSamples,correctedSecondaryWashCollectionContainers,numberOfSecondaryWashes];

  furtherCorrectedSecondaryWashDestinationWells=expandStageCollectionOption[myNestedSamples,correctedSecondaryWashDestinationWells,numberOfSecondaryWashes];

  furtherCorrectedSecondaryWashCollectionContainerIndices = expandStageCollectionOption[myNestedSamples,correctedSecondaryWashCollectionContainerIndices,numberOfSecondaryWashes];

  furtherCorrectedSecondaryWashCollectionContainerLabels = expandStageCollectionOption[myNestedSamples,correctedSecondaryWashCollectionContainerLabels,numberOfSecondaryWashes];

	(* -- TertiaryWash -- *)
	{correctedTertiaryWashCollectionContainers,correctedTertiaryWashDestinationWells,correctedTertiaryWashCollectionContainerIndices,correctedTertiaryWashCollectionContainerLabels}=Map[
		Function[{options},
			Module[{resolvedNumberOfTertiaryWashes},

				(* Resolve number of washes *)
				resolvedNumberOfTertiaryWashes = If[MatchQ[numberOfTertiaryWashes,ListableP[Automatic|Null,3]],1,numberOfTertiaryWashes];

				expandIndexMatchedInputsHelper[myNestedSamples,options,resolvedNumberOfTertiaryWashes]

			]
		],
		{tertiaryWashCollectionContainers, tertiaryWashDestinationWells, tertiaryWashCollectionContainerIndices,tertiaryWashCollectionContainerLabels}
	];
  (* In case that the multiple samples or rounds are actually intended to be pooled in TertiaryWashCollectionContainer, these options are expanded to match the length of samples of each batch*)
  furtherCorrectedTertiaryWashCollectionContainers = expandStageCollectionOption[myNestedSamples,correctedTertiaryWashCollectionContainers,numberOfTertiaryWashes];

  furtherCorrectedTertiaryWashDestinationWells=expandStageCollectionOption[myNestedSamples,correctedTertiaryWashDestinationWells,numberOfTertiaryWashes];

  furtherCorrectedTertiaryWashCollectionContainerIndices = expandStageCollectionOption[myNestedSamples,correctedTertiaryWashCollectionContainerIndices,numberOfTertiaryWashes];

  furtherCorrectedTertiaryWashCollectionContainerLabels = expandStageCollectionOption[myNestedSamples,correctedTertiaryWashCollectionContainerLabels,numberOfTertiaryWashes];

	(* -- QuaternaryWash -- *)
	{correctedQuaternaryWashCollectionContainers,correctedQuaternaryWashDestinationWells,correctedQuaternaryWashCollectionContainerIndices,correctedQuaternaryWashCollectionContainerLabels}=Map[
		Function[{options},
			Module[{resolvedNumberOfQuaternaryWashes},

				(* Resolve number of washes *)
				resolvedNumberOfQuaternaryWashes = If[MatchQ[numberOfQuaternaryWashes,ListableP[Automatic|Null,3]],1,numberOfQuaternaryWashes];

				expandIndexMatchedInputsHelper[myNestedSamples,options,resolvedNumberOfQuaternaryWashes]

			]
		],
		{quaternaryWashCollectionContainers, quaternaryWashDestinationWells, quaternaryWashCollectionContainerIndices,quaternaryWashCollectionContainerLabels}
	];

  (* In case that the multiple samples or rounds are actually intended to be pooled in QuaternaryWashCollectionContainer, these options are expanded to match the length of samples of each batch*)
  furtherCorrectedQuaternaryWashCollectionContainers = expandStageCollectionOption[myNestedSamples,correctedQuaternaryWashCollectionContainers,numberOfQuaternaryWashes];

  furtherCorrectedQuaternaryWashDestinationWells=expandStageCollectionOption[myNestedSamples,correctedQuaternaryWashDestinationWells,numberOfQuaternaryWashes];

  furtherCorrectedQuaternaryWashCollectionContainerIndices = expandStageCollectionOption[myNestedSamples,correctedQuaternaryWashCollectionContainerIndices,numberOfQuaternaryWashes];

  furtherCorrectedQuaternaryWashCollectionContainerLabels = expandStageCollectionOption[myNestedSamples,correctedQuaternaryWashCollectionContainerLabels,numberOfQuaternaryWashes];

	(* -- QuinaryWash -- *)
	{correctedQuinaryWashCollectionContainers,correctedQuinaryWashDestinationWells,correctedQuinaryWashCollectionContainerIndices,correctedQuinaryWashCollectionContainerLabels}=Map[
		Function[{options},
			Module[{resolvedNumberOfQuinaryWashes},

				(* Resolve number of washes *)
				resolvedNumberOfQuinaryWashes = If[MatchQ[numberOfQuinaryWashes,ListableP[Automatic|Null,3]],1,numberOfQuinaryWashes];

				expandIndexMatchedInputsHelper[myNestedSamples,options,resolvedNumberOfQuinaryWashes]

			]
		],
		{quinaryWashCollectionContainers, quinaryWashDestinationWells, quinaryWashCollectionContainerIndices,quinaryWashCollectionContainerLabels}
	];
  (* In case that the multiple samples or rounds are actually intended to be pooled in QuinaryWashCollectionContainer, these options are expanded to match the length of samples of each batch*)
  furtherCorrectedQuinaryWashCollectionContainers = expandStageCollectionOption[myNestedSamples,correctedQuinaryWashCollectionContainers,numberOfQuinaryWashes];

  furtherCorrectedQuinaryWashDestinationWells=expandStageCollectionOption[myNestedSamples,correctedQuinaryWashDestinationWells,numberOfQuinaryWashes];

  furtherCorrectedQuinaryWashCollectionContainerIndices = expandStageCollectionOption[myNestedSamples,correctedQuinaryWashCollectionContainerIndices,numberOfQuinaryWashes];

  furtherCorrectedQuinaryWashCollectionContainerLabels = expandStageCollectionOption[myNestedSamples,correctedQuinaryWashCollectionContainerLabels,numberOfQuinaryWashes];

	(* -- SenaryWash -- *)
	{correctedSenaryWashCollectionContainers,correctedSenaryWashDestinationWells,correctedSenaryWashCollectionContainerIndices,correctedSenaryWashCollectionContainerLabels}=Map[
		Function[{options},
			Module[{resolvedNumberOfSenaryWashes},

				(* Resolve number of washes *)
				resolvedNumberOfSenaryWashes = If[MatchQ[numberOfSenaryWashes,ListableP[Automatic|Null,3]],1,numberOfSenaryWashes];

				expandIndexMatchedInputsHelper[myNestedSamples,options,resolvedNumberOfSenaryWashes]

			]
		],
		{senaryWashCollectionContainers, senaryWashDestinationWells, senaryWashCollectionContainerIndices,senaryWashCollectionContainerLabels}
	];

  (* In case that the multiple samples or rounds are actually intended to be pooled in SenaryWashCollectionContainer, these options are expanded to match the length of samples of each batch*)
  furtherCorrectedSenaryWashCollectionContainers = expandStageCollectionOption[myNestedSamples,correctedSenaryWashCollectionContainers,numberOfSenaryWashes];

  furtherCorrectedSenaryWashDestinationWells=expandStageCollectionOption[myNestedSamples,correctedSenaryWashDestinationWells,numberOfSenaryWashes];

  furtherCorrectedSenaryWashCollectionContainerIndices = expandStageCollectionOption[myNestedSamples,correctedSenaryWashCollectionContainerIndices,numberOfSenaryWashes];

  furtherCorrectedSenaryWashCollectionContainerLabels = expandStageCollectionOption[myNestedSamples,correctedSenaryWashCollectionContainerLabels,numberOfSenaryWashes];
  
	(* -- SeptenaryWash -- *)
	{correctedSeptenaryWashCollectionContainers,correctedSeptenaryWashDestinationWells,correctedSeptenaryWashCollectionContainerIndices,correctedSeptenaryWashCollectionContainerLabels}=Map[
		Function[{options},
			Module[{resolvedNumberOfSeptenaryWashes},

				(* Resolve number of washes *)
				resolvedNumberOfSeptenaryWashes = If[MatchQ[numberOfSeptenaryWashes,ListableP[Automatic|Null,3]],1,numberOfSeptenaryWashes];

				expandIndexMatchedInputsHelper[myNestedSamples,options,resolvedNumberOfSeptenaryWashes]

			]
		],
		{septenaryWashCollectionContainers, septenaryWashDestinationWells, septenaryWashCollectionContainerIndices,septenaryWashCollectionContainerLabels}
	];

  (* In case that the multiple samples or rounds are actually intended to be pooled in SeptenaryWashCollectionContainer, these options are expanded to match the length of samples of each batch*)
  furtherCorrectedSeptenaryWashCollectionContainers = expandStageCollectionOption[myNestedSamples,correctedSeptenaryWashCollectionContainers,numberOfSeptenaryWashes];

  furtherCorrectedSeptenaryWashDestinationWells=expandStageCollectionOption[myNestedSamples,correctedSeptenaryWashDestinationWells,numberOfSeptenaryWashes];

  furtherCorrectedSeptenaryWashCollectionContainerIndices = expandStageCollectionOption[myNestedSamples,correctedSeptenaryWashCollectionContainerIndices,numberOfSeptenaryWashes];

  furtherCorrectedSeptenaryWashCollectionContainerLabels = expandStageCollectionOption[myNestedSamples,correctedSeptenaryWashCollectionContainerLabels,numberOfSeptenaryWashes];

	(* -- Elution -- *)
	{correctedElutionCollectionContainers,correctedElutionDestinationWells,correctedElutionCollectionContainerIndices,correctedElutionCollectionContainerLabels}=Map[
		Function[{options},
			Module[{resolvedNumberOfElutions},

				(* Resolve number of elutions *)
				resolvedNumberOfElutions = If[MatchQ[numberOfElutions,ListableP[Automatic|Null,3]],1,numberOfElutions];

				expandIndexMatchedInputsHelper[myNestedSamples,options,resolvedNumberOfElutions]

			]
		],
		{elutionCollectionContainers, elutionDestinationWells, elutionCollectionContainerIndices,elutionCollectionContainerLabels}
	];
  
  (* In case that the multiple samples or rounds are actually intended to be pooled in ElutionCollectionContainer, these options are expanded to match the length of samples of each batch*)
  furtherCorrectedElutionCollectionContainers = expandStageCollectionOption[myNestedSamples,correctedElutionCollectionContainers,numberOfElutions];

  furtherCorrectedElutionDestinationWells=expandStageCollectionOption[myNestedSamples,correctedElutionDestinationWells,numberOfElutions];

  furtherCorrectedElutionCollectionContainerIndices = expandStageCollectionOption[myNestedSamples,correctedElutionCollectionContainerIndices,numberOfElutions];

  furtherCorrectedElutionCollectionContainerLabels = expandStageCollectionOption[myNestedSamples,correctedElutionCollectionContainerLabels,numberOfElutions];
  
  (* -- ContainerOut -- *)

  furtherCorrectedContainerOutLabels=Module[{resolvedNumberOfStage,correctedContainerOutLabels},

    (* Resolve number of sample out collection stage *)
    resolvedNumberOfStage = If[MatchQ[selectionStrategy,Positive],
      If[MatchQ[numberOfElutions,ListableP[Automatic|Null,3]],
        1,
        numberOfElutions],
      1
    ];

    correctedContainerOutLabels = expandIndexMatchedInputsHelper[myNestedSamples,containerOutLabels,resolvedNumberOfStage];
    
    expandStageCollectionOption[myNestedSamples,correctedContainerOutLabels,resolvedNumberOfStage]
  ];
  
	(* -- SampleOutLabel -- *)
	(* -- ContainerOut -- *)
	furtherCorrectedSampleOutLabels=Module[{resolvedNumberOfStage,correctedSampleOutlabels},

		(* Resolve number of sample out collection stage *)
		resolvedNumberOfStage = If[MatchQ[selectionStrategy,Positive],
			If[MatchQ[numberOfElutions,ListableP[Automatic|Null,3]],1,numberOfElutions],
			1
		];

		correctedSampleOutLabels = expandIndexMatchedInputsHelper[myNestedSamples,sampleOutLabels,resolvedNumberOfStage];

    expandStageCollectionOption[myNestedSamples,correctedSampleOutLabels,resolvedNumberOfStage]
	];

	(* Put the modified options back with the rest *)
	correctedListyOptions=Flatten@ReplaceRule[
		inheritedOptions,
		{
			PreWashCollectionContainer->furtherCorrectedPreWashCollectionContainers,
			PreWashCollectionContainerLabel->furtherCorrectedPreWashCollectionContainerLabels,
			PreWashDestinationWell->furtherCorrectedPreWashDestinationWells,
			PreWashCollectionContainerIndex->furtherCorrectedPreWashCollectionContainerIndices,
			EquilibrationCollectionContainer->furtherCorrectedEquilibrationCollectionContainers,
			EquilibrationCollectionContainerLabel->furtherCorrectedEquilibrationCollectionContainerLabels,
			EquilibrationDestinationWell->furtherCorrectedEquilibrationDestinationWells,
			EquilibrationCollectionContainerIndex->furtherCorrectedEquilibrationCollectionContainerIndices,
			LoadingCollectionContainer->furtherCorrectedLoadingCollectionContainers,
			LoadingCollectionContainerLabel->furtherCorrectedLoadingCollectionContainerLabels,
			LoadingDestinationWell->furtherCorrectedLoadingDestinationWells,
			LoadingCollectionContainerIndex->furtherCorrectedLoadingCollectionContainerIndices,
			WashCollectionContainer->furtherCorrectedWashCollectionContainers,
			WashCollectionContainerLabel->furtherCorrectedWashCollectionContainerLabels,
			WashDestinationWell->furtherCorrectedWashDestinationWells,
			WashCollectionContainerIndex->furtherCorrectedWashCollectionContainerIndices,
			SecondaryWashCollectionContainer->furtherCorrectedSecondaryWashCollectionContainers,
			SecondaryWashCollectionContainerLabel->furtherCorrectedSecondaryWashCollectionContainerLabels,
			SecondaryWashDestinationWell->furtherCorrectedSecondaryWashDestinationWells,
			SecondaryWashCollectionContainerIndex->furtherCorrectedSecondaryWashCollectionContainerIndices,
			TertiaryWashCollectionContainer->furtherCorrectedTertiaryWashCollectionContainers,
			TertiaryWashCollectionContainerLabel->furtherCorrectedTertiaryWashCollectionContainerLabels,
			TertiaryWashDestinationWell->furtherCorrectedTertiaryWashDestinationWells,
			TertiaryWashCollectionContainerIndex->furtherCorrectedTertiaryWashCollectionContainerIndices,
			QuaternaryWashCollectionContainer->furtherCorrectedQuaternaryWashCollectionContainers,
			QuaternaryWashCollectionContainerLabel->furtherCorrectedQuaternaryWashCollectionContainerLabels,
			QuaternaryWashDestinationWell->furtherCorrectedQuaternaryWashDestinationWells,
			QuaternaryWashCollectionContainerIndex->furtherCorrectedQuaternaryWashCollectionContainerIndices,
			QuinaryWashCollectionContainer->furtherCorrectedQuinaryWashCollectionContainers,
			QuinaryWashCollectionContainerLabel->furtherCorrectedQuinaryWashCollectionContainerLabels,
			QuinaryWashDestinationWell->furtherCorrectedQuinaryWashDestinationWells,
			QuinaryWashCollectionContainerIndex->furtherCorrectedQuinaryWashCollectionContainerIndices,
			SenaryWashCollectionContainer->furtherCorrectedSenaryWashCollectionContainers,
			SenaryWashCollectionContainerLabel->furtherCorrectedSenaryWashCollectionContainerLabels,
			SenaryWashDestinationWell->furtherCorrectedSenaryWashDestinationWells,
			SenaryWashCollectionContainerIndex->furtherCorrectedSenaryWashCollectionContainerIndices,
			SeptenaryWashCollectionContainer->furtherCorrectedSeptenaryWashCollectionContainers,
			SeptenaryWashCollectionContainerLabel->furtherCorrectedSeptenaryWashCollectionContainerLabels,
			SeptenaryWashDestinationWell->furtherCorrectedSeptenaryWashDestinationWells,
			SeptenaryWashCollectionContainerIndex->furtherCorrectedSeptenaryWashCollectionContainerIndices,
			ElutionCollectionContainer->furtherCorrectedElutionCollectionContainers,
			ElutionCollectionContainerLabel->furtherCorrectedElutionCollectionContainerLabels,
			ElutionDestinationWell->furtherCorrectedElutionDestinationWells,
			ElutionCollectionContainerIndex->furtherCorrectedElutionCollectionContainerIndices,
			ContainerOutLabel->furtherCorrectedContainerOutLabels,
			SampleOutLabel->furtherCorrectedSampleOutLabels
		},
		Append->True
	];

	(*Expand index-matching options*)
	expandedSafeOps=Last[ExpandIndexMatchedInputs[ExperimentMagneticBeadSeparation,{mySamplesWithPreparedSamples},correctedListyOptions]];

	(*Append the corrected options that are not in the DefineOptions of the experiment*)
	mbsOptionsAssociation=Association[expandedSafeOps];

	(* Any options whose values _could_ be an object *)
	optionsWithObjects={
		AnalyteAffinityLabel,
		MagneticBeadAffinityLabel,
		MagneticBeads,
		MagnetizationRack,
		PreWashBuffer,
		PreWashCollectionContainer,
		PreWashCollectionStorageCondition,
		EquilibrationBuffer,
		EquilibrationCollectionContainer,
		EquilibrationCollectionStorageCondition,
		LoadingCollectionContainer,
		LoadingCollectionStorageCondition,
		WashBuffer,
		WashCollectionContainer,
		WashCollectionStorageCondition,
		SecondaryWashBuffer,
		SecondaryWashCollectionContainer,
		SecondaryWashCollectionStorageCondition,
		TertiaryWashBuffer,
		TertiaryWashCollectionContainer,
		TertiaryWashCollectionStorageCondition,
		QuaternaryWashBuffer,
		QuaternaryWashCollectionContainer,
		QuaternaryWashCollectionStorageCondition,
		QuinaryWashBuffer,
		QuinaryWashCollectionContainer,
		QuinaryWashCollectionStorageCondition,
		SenaryWashBuffer,
		SenaryWashCollectionContainer,
		SenaryWashCollectionStorageCondition,
		SeptenaryWashBuffer,
		SeptenaryWashCollectionContainer,
		SeptenaryWashCollectionStorageCondition,
		ElutionBuffer,
		ElutionCollectionContainer,
		ElutionCollectionStorageCondition
	};

	(* Extract any objects that the user has explicitly specified *)
	userSpecifiedObjects=DeleteDuplicates@Cases[
		Flatten@Join[ToList[myNestedSamples],Lookup[ToList[myOptions],optionsWithObjects,Null]],
		ObjectP[]
	];

	(*--Download the information we need for the option resolver and resource packet function--*)

	(*Flatten mySamplesWithPreparedSamples*)
	flatMySamplesWithPreparedSamples=Flatten[mySamplesWithPreparedSamples];

	(*Pull out the options that may have models/objects whose information we need to download*)
	{
		analyteAffinityLabels,
		magneticBeadAffinityLabels,
		targetMolecules,
		magnetizationRacks,
		preWashCollectionContainers,
		equilibrationCollectionContainers,
		loadingCollectionContainers,
		washCollectionContainers,
		secondaryWashCollectionContainers,
		tertiaryWashCollectionContainers,
		quaternaryWashCollectionContainers,
		quinaryWashCollectionContainers,
		senaryWashCollectionContainers,
		septenaryWashCollectionContainers,
		elutionCollectionContainers,
		preWashCollectionStorageConditions,
		equilibrationCollectionStorageConditions,
		loadingCollectionStorageConditions,
		washCollectionStorageConditions,
		secondaryWashCollectionStorageConditions,
		tertiaryWashCollectionStorageConditions,
		quaternaryWashCollectionStorageConditions,
		quinaryWashCollectionStorageConditions,
		senaryWashCollectionStorageConditions,
		septenaryWashCollectionStorageConditions,
		elutionCollectionStorageConditions
	}=Lookup[
		mbsOptionsAssociation,
		{
			AnalyteAffinityLabel,
			MagneticBeadAffinityLabel,
			Target,
			MagnetizationRack,
			PreWashCollectionContainer,
			EquilibrationCollectionContainer,
			LoadingCollectionContainer,
			WashCollectionContainer,
			SecondaryWashCollectionContainer,
			TertiaryWashCollectionContainer,
			QuaternaryWashCollectionContainer,
			QuinaryWashCollectionContainer,
			SenaryWashCollectionContainer,
			SeptenaryWashCollectionContainer,
			ElutionCollectionContainer,
			PreWashCollectionStorageCondition,
			EquilibrationCollectionStorageCondition,
			LoadingCollectionStorageCondition,
			WashCollectionStorageCondition,
			SecondaryWashCollectionStorageCondition,
			TertiaryWashCollectionStorageCondition,
			QuaternaryWashCollectionStorageCondition,
			QuinaryWashCollectionStorageCondition,
			SenaryWashCollectionStorageCondition,
			SeptenaryWashCollectionStorageCondition,
			ElutionCollectionStorageCondition
		}
	];

	(*Get all the target molecule models*)
	allTargetMolecules=Cases[{targetMolecules,Download[flatMySamplesWithPreparedSamples,Analytes,Cache->cache,Simulation->simulation]},ObjectP[],Infinity];

	(*Get all the analyte identity models*)
	allAnalyteAffinityLabels=Cases[{analyteAffinityLabels,Download[flatMySamplesWithPreparedSamples,Analytes,Cache->cache,Simulation->simulation]},ObjectP[],Infinity];

	(* Get all magnetic bead identity models *)
	allMagneticBeadIdentityModels = allActiveMagneticBeadIdentityModels["Memoization"];

	(* Get all the magnetization racks *)
	allMagnetizationRackModels = allActiveMagnetizationRacks["Memoization"];

	(* Get all user specified magnetization rack objects *)
	allMagnetizationRackObjects = Cases[magnetizationRacks,ObjectP[Object[Container,Rack],Object[Item,MagnetizationRack]]];

	(*Get the preferred, liquid handler-compatible, and collection container models*)
	uniqueContainerModels=DeleteDuplicates[
		Cases[
			Flatten[{
				PreferredContainer[All,Type->All],
				hamiltonAliquotContainers["Memoization"],
				preWashCollectionContainers,
				equilibrationCollectionContainers,
				loadingCollectionContainers,
				washCollectionContainers,
				secondaryWashCollectionContainers,
				tertiaryWashCollectionContainers,
				quaternaryWashCollectionContainers,
				quinaryWashCollectionContainers,
				senaryWashCollectionContainers,
				septenaryWashCollectionContainers,
				elutionCollectionContainers
			}],
			ObjectP[Model[Container]]
		]
	];

	uniqueContainerObjects=DeleteDuplicates[
		Cases[
			Flatten[{
				preWashCollectionContainers,
				equilibrationCollectionContainers,
				loadingCollectionContainers,
				washCollectionContainers,
				secondaryWashCollectionContainers,
				tertiaryWashCollectionContainers,
				quaternaryWashCollectionContainers,
				quinaryWashCollectionContainers,
				senaryWashCollectionContainers,
				septenaryWashCollectionContainers,
				elutionCollectionContainers
			}],
			ObjectP[Object[Container]]
		]
	];

	(*Get all the storage condition model objects*)
	uniqueStorageConditions=DeleteDuplicates[
	Cases[Flatten[{preWashCollectionStorageConditions,equilibrationCollectionStorageConditions,loadingCollectionStorageConditions, washCollectionStorageConditions,secondaryWashCollectionStorageConditions,tertiaryWashCollectionStorageConditions,quaternaryWashCollectionStorageConditions,quinaryWashCollectionStorageConditions,senaryWashCollectionStorageConditions,septenaryWashCollectionStorageConditions,elutionCollectionStorageConditions}],ObjectP[]]
	];

	(* Get sample objects/models from options *)
	uniqueSampleObjects=Cases[userSpecifiedObjects, ObjectP[Object[Sample]]];
	uniqueSampleModels=Cases[userSpecifiedObjects, ObjectP[Model[Sample]]];

	(* These are the possible chosen assay containers, whose Position field we need later. Download them all now to reduce *)
	(* connections with the server *)
	assayContainerModels={
		Model[Container,Plate,"id:L8kPEjkmLbvW"],  (* "96-well 2mL Deep Well Plate" *)
		Model[Container,Plate,"id:01G6nvkKrrYm"],  (* "96-well PCR Plate" *)
		Model[Container,Vessel,"id:3em6Zv9NjjN8"], (* "2mL Tube" *)
		Model[Container,Vessel,"id:xRO9n3vk11pw"], (* "15mL Tube" *)
		Model[Container,Vessel,"id:bq9LA0dBGGR6"]  (* "50mL Tube" *)
	};

	(*Get all the packets and fields we need to download*)
	sampleDownloadPacket=Packet[SamplePreparationCacheFields[Object[Sample],Format->Sequence],CellType];
	modelDownloadPacket=Packet[SamplePreparationCacheFields[Model[Sample],Format->Sequence]];
	identityModelDownloadPacket=Packet[Targets,AffinityLabels,MolecularWeight,DefaultSampleModel,Composition];
	containerModelDownloadPacket=Packet[LiquidHandlerPrefix,MagnetFootprint,Footprint,Positions,MaxVolume, Model,Magnetized,SamplePreparationCacheFields[Model[Container],Format->Sequence]];
	containerObjectDownloadPacket=SamplePreparationCacheFields[Object[Container],Format->Packet];
	containerContentsObjectDownloadPacket=Packet[Field[Contents[[All, 2]][{Composition, Solvent}]]];

  (*Download*)
	(*Make the upfront Download call*)
	allPackets=Quiet[
		Download[
			{
				flatMySamplesWithPreparedSamples,
				allTargetMolecules,
				allAnalyteAffinityLabels,
				allMagneticBeadIdentityModels,
				allMagnetizationRackModels,
				allMagnetizationRackObjects,
				uniqueContainerModels,
				uniqueContainerObjects,
				assayContainerModels,
				uniqueStorageConditions,
				uniqueSampleObjects,
				uniqueSampleModels
			},
			{
				(*flatMySamplesWithPreparedSamples*)
				{
					sampleDownloadPacket
				},
				(*allTargetMolecules*)
				{
					identityModelDownloadPacket
				},
				(*allAnalyteAffinityLabels*)
				{
					identityModelDownloadPacket
				},
				(*allMagneticBeadIdentityModels*)
				{
					identityModelDownloadPacket
				},
				(*allMagnetizationRackModels*)
				{
					containerModelDownloadPacket
				},
				(*allMagnetizationRackObjects*)
				{
					Packet[Model]
				},
				(*uniqueContainerModels*)
				{
					containerModelDownloadPacket
				},
				(* uniqueContainerObjects *)
				{
					containerObjectDownloadPacket,
					containerContentsObjectDownloadPacket
				},
				(* assayContainerModels *)
				{
					containerModelDownloadPacket
				},
				(*uniqueStorageConditions*)
				{
					Packet[StorageCondition]
				},
				(* uniqueSampleObjects *)
				{
					sampleDownloadPacket
				},
				(* uniqueSampleModels *)
				{
					modelDownloadPacket
				}
			},
			Cache->FlattenCachePackets[{cache}],
			Simulation->simulation,
			Date->Now
		],
		{Download::FieldDoesntExist}
	];

	(*Combine our downloaded and simulated cache*)
	cacheBall=FlattenCachePackets[{cache,allPackets}];

	(*--Build the resolved options--*)
	resolvedOptionsResult=If[gatherTests,
		(*We are gathering tests. This silences any messages being thrown*)
		{resolvedOptions,resolvedOptionsTests}=resolveExperimentMagneticBeadSeparationOptions[mySamplesWithPreparedSamples,mySemiNestedInputs,expandedSafeOps,Cache->cacheBall,Simulation->simulation,Output->{Result,Tests}];
		(*Therefore, we have to run the tests to see if we encountered a failure*)
		If[RunUnitTest[<|"Tests"->resolvedOptionsTests|>,OutputFormat->SingleBoolean,Verbose->False],
			{resolvedOptions,resolvedOptionsTests},
			$Failed
		],

		(*We are not gathering tests. Simply check for Error::InvalidInput and Error::InvalidOption*)
		Check[
			{resolvedOptions,resolvedOptionsTests}={resolveExperimentMagneticBeadSeparationOptions[mySamplesWithPreparedSamples,mySemiNestedInputs,expandedSafeOps,Cache->cacheBall,Simulation->simulation],{}},
			$Failed,
			{Error::InvalidInput,Error::InvalidOption}
		]
	];

	(*=== Convert the output CollectionContainer format if Automatic ===*)

	(*PreWash*)
	outputPreWashCollectionContainers=convertAutomaticCollectionContainerOutput[
		inputPreWashCollectionContainers,
		Flatten[Lookup[resolvedOptions,PreWashCollectionContainer]],
		Flatten[Lookup[resolvedOptions,PreWashDestinationWell]]
	];

	(*Equilibration*)
	outputEquilibrationCollectionContainers=convertAutomaticCollectionContainerOutput[
		inputEquilibrationCollectionContainers,
		Flatten[Lookup[resolvedOptions,EquilibrationCollectionContainer]],
		Flatten[Lookup[resolvedOptions,EquilibrationDestinationWell]]
	];

	(*Loading*)
	outputLoadingCollectionContainers=convertAutomaticCollectionContainerOutput[
		inputLoadingCollectionContainers,
		Flatten[Lookup[resolvedOptions,LoadingCollectionContainer]],
		Flatten[Lookup[resolvedOptions,LoadingDestinationWell]]
	];

	(*Wash*)
	outputWashCollectionContainers=convertAutomaticCollectionContainerOutput[
		inputWashCollectionContainers,
		Flatten[Lookup[resolvedOptions,WashCollectionContainer]],
		Flatten[Lookup[resolvedOptions,WashDestinationWell]]
	];

	(*SecondaryWash*)
	outputSecondaryWashCollectionContainers=convertAutomaticCollectionContainerOutput[
		inputSecondaryWashCollectionContainers,
		Flatten[Lookup[resolvedOptions,SecondaryWashCollectionContainer]],
		Flatten[Lookup[resolvedOptions,SecondaryWashDestinationWell]]
	];

	(*TertiaryWash*)
	outputTertiaryWashCollectionContainers=convertAutomaticCollectionContainerOutput[
		inputTertiaryWashCollectionContainers,
		Flatten[Lookup[resolvedOptions,TertiaryWashCollectionContainer]],
		Flatten[Lookup[resolvedOptions,TertiaryWashDestinationWell]]
	];

	(*QuaternaryWash*)
	outputQuaternaryWashCollectionContainers=convertAutomaticCollectionContainerOutput[
		inputQuaternaryWashCollectionContainers,
		Flatten[Lookup[resolvedOptions,QuaternaryWashCollectionContainer]],
		Flatten[Lookup[resolvedOptions,QuaternaryWashDestinationWell]]
	];

	(*QuinaryWash*)
	outputQuinaryWashCollectionContainers=convertAutomaticCollectionContainerOutput[
		inputQuinaryWashCollectionContainers,
		Flatten[Lookup[resolvedOptions,QuinaryWashCollectionContainer]],
		Flatten[Lookup[resolvedOptions,QuinaryWashDestinationWell]]
	];

	(*SenaryWash*)
	outputSenaryWashCollectionContainers=convertAutomaticCollectionContainerOutput[
		inputSenaryWashCollectionContainers,
		Flatten[Lookup[resolvedOptions,SenaryWashCollectionContainer]],
		Flatten[Lookup[resolvedOptions,SenaryWashDestinationWell]]
	];

	(*SeptenaryWash*)
	outputSeptenaryWashCollectionContainers=convertAutomaticCollectionContainerOutput[
		inputSeptenaryWashCollectionContainers,
		Flatten[Lookup[resolvedOptions,SeptenaryWashCollectionContainer]],
		Flatten[Lookup[resolvedOptions,SeptenaryWashDestinationWell]]
	];

	(*Elution*)
	outputElutionCollectionContainers=convertAutomaticCollectionContainerOutput[
		inputElutionCollectionContainers,
		Flatten[Lookup[resolvedOptions,ElutionCollectionContainer]],
		Flatten[Lookup[resolvedOptions,ElutionDestinationWell]]
	];
	(*Replace the collection container options in resolved options with format of {well, container} if there is any automatic in the input, otherwise use the input*)
	resolvedOptionsWithConvertedContainers=ReplaceRule[
		resolvedOptions,
		{
			If[
				MemberQ[Flatten[ToList@inputPreWashCollectionContainers],Automatic],
				PreWashCollectionContainer->unflattenListHelper[
					TakeList[outputPreWashCollectionContainers,(Flatten[Lookup[resolvedOptions,NumberOfPreWashes]]/.Null->1)],
          myNestedSamples],
				PreWashCollectionContainer->inputPreWashCollectionContainers
			],
			If[
				MemberQ[Flatten[ToList@inputEquilibrationCollectionContainers],Automatic],
				EquilibrationCollectionContainer->unflattenListHelper[
					TakeList[outputEquilibrationCollectionContainers, ConstantArray[1,Length[Flatten@myNestedSamples]]],
					myNestedSamples],
				EquilibrationCollectionContainer->inputEquilibrationCollectionContainers
			],
			If[
				MemberQ[Flatten[ToList@inputLoadingCollectionContainers],Automatic],
				LoadingCollectionContainer->unflattenListHelper[
					TakeList[outputLoadingCollectionContainers, ConstantArray[1,Length[Flatten@myNestedSamples]]],
					myNestedSamples],
				LoadingCollectionContainer->inputLoadingCollectionContainers
			],
			If[
				MemberQ[Flatten[ToList@inputWashCollectionContainers],Automatic],
				WashCollectionContainer->unflattenListHelper[
					TakeList[outputWashCollectionContainers,(Flatten[Lookup[resolvedOptions,NumberOfWashes]]/.Null->1)],
					myNestedSamples],
				WashCollectionContainer->inputWashCollectionContainers
			],
			If[
				MemberQ[Flatten[ToList@inputSecondaryWashCollectionContainers],Automatic],
				SecondaryWashCollectionContainer->unflattenListHelper[
				TakeList[outputSecondaryWashCollectionContainers,(Flatten[Lookup[resolvedOptions,NumberOfSecondaryWashes]]/.Null->1)],
				myNestedSamples],
				SecondaryWashCollectionContainer->inputSecondaryWashCollectionContainers
			],
			If[
				MemberQ[Flatten[ToList@inputTertiaryWashCollectionContainers],Automatic],
				TertiaryWashCollectionContainer->unflattenListHelper[
				TakeList[outputTertiaryWashCollectionContainers,(Flatten[Lookup[resolvedOptions,NumberOfTertiaryWashes]]/.Null->1)],
				myNestedSamples],
				TertiaryWashCollectionContainer->inputTertiaryWashCollectionContainers
			],
			If[
				MemberQ[Flatten[ToList@inputQuaternaryWashCollectionContainers],Automatic],
				QuaternaryWashCollectionContainer->unflattenListHelper[
					TakeList[outputQuaternaryWashCollectionContainers,(Flatten[Lookup[resolvedOptions,NumberOfQuaternaryWashes]]/.Null->1)],
					myNestedSamples],
				QuaternaryWashCollectionContainer->inputQuaternaryWashCollectionContainers
			],
			If[
				MemberQ[Flatten[ToList@inputQuinaryWashCollectionContainers],Automatic],
				QuinaryWashCollectionContainer->unflattenListHelper[
					TakeList[outputQuinaryWashCollectionContainers,(Flatten[Lookup[resolvedOptions,NumberOfQuinaryWashes]]/.Null->1)],
          myNestedSamples],
				QuinaryWashCollectionContainer->inputQuinaryWashCollectionContainers
			],
			If[
				MemberQ[Flatten[ToList@inputSenaryWashCollectionContainers],Automatic],
				SenaryWashCollectionContainer->unflattenListHelper[
					TakeList[outputSenaryWashCollectionContainers,(Flatten[Lookup[resolvedOptions,NumberOfSenaryWashes]]/.Null->1)],
          myNestedSamples],
				SenaryWashCollectionContainer->inputSenaryWashCollectionContainers
			],
			If[
				MemberQ[Flatten[ToList@inputSeptenaryWashCollectionContainers],Automatic],
				SeptenaryWashCollectionContainer->unflattenListHelper[
					TakeList[outputSeptenaryWashCollectionContainers,(Flatten[Lookup[resolvedOptions,NumberOfSeptenaryWashes]]/.Null->1)],
          myNestedSamples],
				SeptenaryWashCollectionContainer->inputSeptenaryWashCollectionContainers
			],
			If[
				MemberQ[Flatten[ToList@inputElutionCollectionContainers],Automatic],
				ElutionCollectionContainer->unflattenListHelper[
					TakeList[outputElutionCollectionContainers,(Flatten[Lookup[resolvedOptions,NumberOfElutions]]/.Null->1)],
          myNestedSamples
				],
				ElutionCollectionContainer->inputElutionCollectionContainers
			]
		}
	];

	(* Before we call CollapseIndexMatchedOptions, process the nested index matching options according to the original input. This is mostly for primitive framework where we will put unnested input back as part of the primitive and we don't want to run into index matching problem *)
	(* Do this here since we want the fully nested resolvedOptions for resource packets *)
	nestedIndexMatchingOptions=Module[
		{optionDefinition,nestedIndexMatchingOptionDefs},
		(* Get the option definition for the function *)
		optionDefinition=OptionDefinition[ExperimentMagneticBeadSeparation];

		(* Get the nested index matching options *)
		nestedIndexMatchingOptionDefs=Cases[optionDefinition,KeyValuePattern["NestedIndexMatching"->True]];

		Join[Lookup[nestedIndexMatchingOptionDefs,"OptionSymbol",{}],{AliquotContainer}]
	];


	(* Unflatten nested index matching options based on the original input *)
	unnestedIndexMatchingOptions=Map[
		If[KeyExistsQ[resolvedOptions,#],
			Which[
				(*If the key is one of the collection containers, it needs to be unnested differently because of the possible extra nestiness due to its format e.g. {well,container}*)
				MatchQ[#,PreWashCollectionContainer],
					#->unnestOptionsOfRepeatedStage[outputPreWashCollectionContainers,Lookup[resolvedOptions,NumberOfPreWashes],inputPreWashCollectionContainers,myUnnestedSampleInputs],
				MatchQ[#,EquilibrationCollectionContainer],
					#->unnestOptionsOfRepeatedStage[outputEquilibrationCollectionContainers, ConstantArray[1,Length[Flatten@myNestedSamples]],inputEquilibrationCollectionContainers,myUnnestedSampleInputs],
				MatchQ[#,LoadingCollectionContainer],
					#->unnestOptionsOfRepeatedStage[outputLoadingCollectionContainers, ConstantArray[1,Length[Flatten@myNestedSamples]],inputLoadingCollectionContainers,myUnnestedSampleInputs],
				MatchQ[#,WashCollectionContainer],
					#->unnestOptionsOfRepeatedStage[outputWashCollectionContainers,Lookup[resolvedOptions,NumberOfWashes],inputWashCollectionContainers,myUnnestedSampleInputs],
				MatchQ[#,SecondaryWashCollectionContainer],
					#->unnestOptionsOfRepeatedStage[outputSecondaryWashCollectionContainers,Lookup[resolvedOptions,NumberOfSecondaryWashes],inputSecondaryWashCollectionContainers,myUnnestedSampleInputs],
				MatchQ[#,TertiaryWashCollectionContainer],
					#->unnestOptionsOfRepeatedStage[outputTertiaryWashCollectionContainers,Lookup[resolvedOptions,NumberOfTertiaryWashes],inputTertiaryWashCollectionContainers,myUnnestedSampleInputs],
				MatchQ[#,QuaternaryWashCollectionContainer],
					#->unnestOptionsOfRepeatedStage[outputQuaternaryWashCollectionContainers,Lookup[resolvedOptions,NumberOfQuaternaryWashes],inputQuaternaryWashCollectionContainers,myUnnestedSampleInputs],
				MatchQ[#,QuinaryWashCollectionContainer],
					#->unnestOptionsOfRepeatedStage[outputQuinaryWashCollectionContainers,Lookup[resolvedOptions,NumberOfQuinaryWashes],inputQuinaryWashCollectionContainers,myUnnestedSampleInputs],
				MatchQ[#,SenaryWashCollectionContainer],
					#->unnestOptionsOfRepeatedStage[outputSenaryWashCollectionContainers,Lookup[resolvedOptions,NumberOfSenaryWashes],inputSenaryWashCollectionContainers,myUnnestedSampleInputs],
				MatchQ[#,SeptenaryWashCollectionContainer],
					#->unnestOptionsOfRepeatedStage[outputSeptenaryWashCollectionContainers,Lookup[resolvedOptions,NumberOfSeptenaryWashes],inputSeptenaryWashCollectionContainers,myUnnestedSampleInputs],
				MatchQ[#,ElutionCollectionContainer],
					#->unnestOptionsOfRepeatedStage[outputElutionCollectionContainers,Lookup[resolvedOptions,NumberOfElutions],inputElutionCollectionContainers,myUnnestedSampleInputs],
				(*If the key is any other collection conatiner option of a non-repeated stage i.e. Sample Preparation ones! They would need a special flatten becuase the container format could be complex*)
				MatchQ[#,Alternatives[IncubateAliquotContainer,CentrifugeAliquotContainer,FilterContainerOut,FilterAliquotContainer,AliquotContainer]],
					(#->Unflatten[flattenCollectionContainersToSingletons[Lookup[resolvedOptions,#]],myUnnestedSampleInputs]),
				(*If the key is other collection option affected by repeated stage, including wells, indices,and container labels*)
				MatchQ[#,Alternatives[PreWashDestinationWell,PreWashCollectionContainerIndex,PreWashCollectionContainerLabel]],
					(#->unnestOptionsOfRepeatedStage[Flatten[Lookup[resolvedOptions,#]],Lookup[resolvedOptions,NumberOfPreWashes],Lookup[inheritedOptions,#],myUnnestedSampleInputs]),
				MatchQ[#,Alternatives[WashDestinationWell,WashCollectionContainerIndex,WashCollectionContainerLabel]],
					(#->unnestOptionsOfRepeatedStage[Flatten[Lookup[resolvedOptions,#]],Lookup[resolvedOptions,NumberOfWashes],Lookup[inheritedOptions,#],myUnnestedSampleInputs]),
				MatchQ[#,Alternatives[SecondaryWashDestinationWell,SecondaryWashCollectionContainerIndex,SecondaryWashCollectionContainerLabel]],
					(#->unnestOptionsOfRepeatedStage[Flatten[Lookup[resolvedOptions,#]],Lookup[resolvedOptions,NumberOfSecondaryWashes],Lookup[inheritedOptions,#],myUnnestedSampleInputs]),
				MatchQ[#,Alternatives[TertiaryWashDestinationWell,TertiaryWashCollectionContainerIndex,TertiaryWashCollectionContainerLabel]],
					(#->unnestOptionsOfRepeatedStage[Flatten[Lookup[resolvedOptions,#]],Lookup[resolvedOptions,NumberOfTertiaryWashes],Lookup[inheritedOptions,#],myUnnestedSampleInputs]),
				MatchQ[#,Alternatives[QuaternaryWashDestinationWell,QuaternaryWashCollectionContainerIndex,QuaternaryWashCollectionContainerLabel]],
					(#->unnestOptionsOfRepeatedStage[Flatten[Lookup[resolvedOptions,#]],Lookup[resolvedOptions,NumberOfQuaternaryWashes],Lookup[inheritedOptions,#],myUnnestedSampleInputs]),
				MatchQ[#,Alternatives[QuinaryWashDestinationWell,QuinaryWashCollectionContainerIndex,QuinaryWashCollectionContainerLabel]],
					(#->unnestOptionsOfRepeatedStage[Flatten[Lookup[resolvedOptions,#]],Lookup[resolvedOptions,NumberOfQuinaryWashes],Lookup[inheritedOptions,#],myUnnestedSampleInputs]),
				MatchQ[#,Alternatives[SenaryWashDestinationWell,SenaryWashCollectionContainerIndex,SenaryWashCollectionContainerLabel]],
					(#->unnestOptionsOfRepeatedStage[Flatten[Lookup[resolvedOptions,#]],Lookup[resolvedOptions,NumberOfSenaryWashes],Lookup[inheritedOptions,#],myUnnestedSampleInputs]),
				MatchQ[#,Alternatives[SeptenaryWashDestinationWell,SeptenaryWashCollectionContainerIndex,SeptenaryWashCollectionContainerLabel]],
					(#->unnestOptionsOfRepeatedStage[Flatten[Lookup[resolvedOptions,#]],Lookup[resolvedOptions,NumberOfSeptenaryWashes],Lookup[inheritedOptions,#],myUnnestedSampleInputs]),
				MatchQ[#,Alternatives[ElutionDestinationWell,ElutionCollectionContainerIndex,ElutionCollectionContainerLabel]],
					(#->unnestOptionsOfRepeatedStage[Flatten[Lookup[resolvedOptions,#]],Lookup[resolvedOptions,NumberOfElutions],Lookup[inheritedOptions,#],myUnnestedSampleInputs]),
				(*SampleOutLabel can be either Elution or loading samples depending on SelectionStrategy*)
				(*If SelectionStrategy is Postive, SampleOutLabel corresponds to elution samples, and has extra layer of nestiness due to NumberOfElutions *)
				MatchQ[#,Alternatives[SampleOutLabel,ContainerOutLabel]]&&MatchQ[Lookup[resolvedOptions,SelectionStrategy],Positive],
					(#->unnestOptionsOfRepeatedStage[Flatten[Lookup[resolvedOptions,#]],Lookup[resolvedOptions,NumberOfElutions],Lookup[inheritedOptions,#],myUnnestedSampleInputs]),
				(*Otherwise for SampleOutLabel,loading sample are collected, and does not have extra layer of nestiness*)
				(*If the key is not one of the collection options above, just unflatten regularly*)
				True,
					(#->Unflatten[Flatten[Lookup[resolvedOptions,#]],myUnnestedSampleInputs])
			],
			Nothing
		]&,
		nestedIndexMatchingOptions
	];

	unnestedResolvedOptions=ReplaceRule[
		resolvedOptions,
		unnestedIndexMatchingOptions
	];

	collapsedUnnestedResolvedOptions=CollapseIndexMatchedOptions[
		ExperimentMagneticBeadSeparation,
		unnestedResolvedOptions,
		Ignore->myOriginalOptions,
		Messages->False
	];

	(*Collapse the resolved options*)
	userReturnFriendlyOptions=CollapseIndexMatchedOptions[
		ExperimentMagneticBeadSeparation,
		resolvedOptionsWithConvertedContainers,
		Ignore->myOriginalOptions,
		Messages->False
	];

	(* Lookup our resolved Preparation option. *)
	resolvedPreparation = Lookup[resolvedOptions, Preparation];

	(* run all the tests from the resolution; if any of them were False, then we should return early here *)
	(* need to do this because if we are collecting tests then the Check wouldn't have caught it *)
	(* basically, if _not_ all the tests are passing, then we do need to return early *)
	returnEarlyQ = MatchQ[resolvedOptionsResult, $Failed];

	(* NOTE: We need to perform simulation if Result is asked for in MBS since it's part of the SamplePreparation experiments. *)
	(* This is because we pass down our simulation to ExperimentMSP or ExperimentRSP. *)
	performSimulationQ = MemberQ[output, Result|Simulation];
	(* If we did get the result, we should try to quiet messages in simulation so that we will not duplicate them. We will just silently update our simulation *)
	resultQ = MemberQ[output, Result];

	(*If option resolution failed, return early*)
	If[returnEarlyQ && !performSimulationQ,
		Return[outputSpecification/.{
			Result->$Failed,
			Tests->Join[safeOpsTests,validLengthTests,templateTests,resolvedOptionsTests],
			Options->RemoveHiddenOptions[ExperimentMagneticBeadSeparation,userReturnFriendlyOptions],
			Preview->Null,
			Simulation->Simulation[]
		}]
	];

	(*--Build packets with resources--*)

	{{resourceResult,roboticSimulation,runTime},resourcePacketTests}=Which[
		MatchQ[resolvedOptionsResult, $Failed],
			{{$Failed,$Failed,$Failed}, {}},
		gatherTests,
			experimentMagneticBeadSeparationResourcePackets[mySamplesWithPreparedSamples,templatedOptions,resolvedOptions,Cache->cacheBall,Simulation -> simulation,Output->{Result,Tests}],
		True,
			{experimentMagneticBeadSeparationResourcePackets[mySamplesWithPreparedSamples,templatedOptions,resolvedOptions,Cache->cacheBall,Simulation -> simulation],{}}
	];

	(* If we were asked for a simulation, also return a simulation. *)
	{simulatedProtocol, simulatedProtocolSimulation} = Which[
		!performSimulationQ,
			{Null, Null},
		MatchQ[resolvedPreparation, Robotic] && MatchQ[roboticSimulation, SimulationP],
			{Null, roboticSimulation},
		!resultQ,
			simulateExperimentMagneticBeadSeparation[
				If[MatchQ[resourceResult, $Failed],
					$Failed,
					First[resourceResult] (* protocolPacket *)
				],
				If[MatchQ[resourceResult, $Failed],
					$Failed,
					Rest[resourceResult] (* unitOperationPackets *)
				],
				ToList[Download[mySamplesWithPreparedSamples,Object]],
				resolvedOptions,
				Cache->cacheBall,
				Simulation->simulation,
				ParentProtocol->Lookup[safeOps,ParentProtocol]
			],
		True,
			simulateExperimentMagneticBeadSeparation[
				If[MatchQ[resourceResult, $Failed],
					$Failed,
					First[resourceResult] (* protocolPacket *)
				],
				If[MatchQ[resourceResult, $Failed],
					$Failed,
					Rest[resourceResult] (* unitOperationPackets *)
				],
				ToList[Download[mySamplesWithPreparedSamples,Object]],
				resolvedOptions,
				Cache->cacheBall,
				Simulation->simulation,
				ParentProtocol->Lookup[safeOps,ParentProtocol]
				]

	];

	(* If we don't have to return the Result, don't bother calling UploadProtocol[...]. *)
	If[!MemberQ[output,Result],
		Return[outputSpecification/.{
			Result -> Null,
			Tests -> Flatten[{safeOpsTests,validLengthTests,templateTests,resolvedOptionsTests,resourcePacketTests}],
      Options -> RemoveHiddenOptions[ExperimentMagneticBeadSeparation,collapsedUnnestedResolvedOptions],
			Preview -> Null,
			Simulation -> simulatedProtocolSimulation,
			RunTime -> runTime
		}]
	];

	(* We have to return the result. Call UploadProtocol[...] to prepare our protocol packet (and upload it if asked). *)
	protocolObject = Which[
		(* If our resource packets failed, we can't upload anything. *)
		MatchQ[resourceResult,$Failed],
			$Failed,

		(* If we're doing Preparation->Robotic, return our unit operations packets back without RequireResources called if *)
		(* Upload->False. *)
		MatchQ[resolvedPreparation, Robotic] && MatchQ[Lookup[safeOps,Upload], False],
			Rest[resourceResult], (* unitOperationPackets *)

		(* If we're doing Preparation->Robotic and Upload->True, call ExperimentRoboticSamplePreparation with our primitive. *)
		MatchQ[resolvedPreparation, Robotic],
			Module[{primitive, nonHiddenOptions, experimentFunction, samplesMaybeWithModels},
				(* convert the samples to models if we had model inputs originally *)
				(* if we don't have a simulation or a single prep unit op, then we know we didn't have a model input *)
				(* NOTE: this is important. The simulation used here is "updated simulation" that includes simulated sample preparation packet.  This is because mySamples needs to get converted to model via the simulation _before_ SimulateResources is called in simulateExperimentFilter *)
				(* otherwise, the same label will point at two different IDs, and that's going to cause problems *)
				samplesMaybeWithModels = If[NullQ[simulation] || Not[MatchQ[Lookup[resolvedOptions, PreparatoryUnitOperations], {_[_LabelSample]}]],
					mySamplesWithPreparedSamples,
					simulatedSamplesToModels[
						Lookup[resolvedOptions, PreparatoryUnitOperations][[1, 1]],
						simulation,
						mySamplesWithPreparedSamples
					]
				];

				(* Create our mbs primitive to feed into RoboticSamplePreparation. *)
				primitive=MagneticBeadSeparation@@Join[
					{
						Sample->Download[ToList[samplesMaybeWithModels], Object]
					},
					RemoveHiddenPrimitiveOptions[MagneticBeadSeparation,ToList[myOptions]]
				];

				(* Remove any hidden options before returning. *)
				nonHiddenOptions=RemoveHiddenOptions[ExperimentMagneticBeadSeparation,userReturnFriendlyOptions];

				(* Memoize the value of ExperimentMagneticBeadSeparation so the framework doesn't spend time resolving it again. *)
				Internal`InheritedBlock[{ExperimentMagneticBeadSeparation, $PrimitiveFrameworkResolverOutputCache},
					$PrimitiveFrameworkResolverOutputCache=<||>;

					DownValues[ExperimentMagneticBeadSeparation]={};

					ExperimentMagneticBeadSeparation[___, options:OptionsPattern[]]:=Module[{frameworkOutputSpecification},
						(* Lookup the output specification the framework is asking for. *)
						frameworkOutputSpecification=Lookup[ToList[options], Output];

						frameworkOutputSpecification/.{
							Result -> Rest[resourceResult],
							Options -> nonHiddenOptions,
							Preview -> Null,
							Simulation -> simulatedProtocolSimulation,
							RunTime -> runTime
						}
					];
					(* mapping between workcell name and experiment function *)
					experimentFunction = Lookup[$WorkCellToExperimentFunction, Lookup[resolvedOptions, WorkCell]];
					experimentFunction[
						{primitive},
						Name->Lookup[safeOps,Name],
						Upload->Lookup[safeOps,Upload],
						Confirm->Lookup[safeOps,Confirm],
            CanaryBranch->Lookup[safeOps,CanaryBranch],
						ParentProtocol->Lookup[safeOps,ParentProtocol],
						Priority->Lookup[safeOps,Priority],
						StartDate->Lookup[safeOps,StartDate],
						HoldOrder->Lookup[safeOps,HoldOrder],
						QueuePosition->Lookup[safeOps,QueuePosition],
						Cache->cacheBall
					]
				]
			],

		(* Actually upload our protocol object. We are being called as a subprotcol in ExperimentManualSamplePreparation. *)
		True,
			(* NOTE: If Preparation->Manual, we don't have auxillary unit operation packets since there aren't batches. *)
			(* We only have unit operation packets when doing robotic. *)
			UploadProtocol[
				resourceResult[[1]],
				Upload->Lookup[safeOps,Upload],
				Confirm->Lookup[safeOps,Confirm],
        CanaryBranch->Lookup[safeOps,CanaryBranch],
				ParentProtocol->Lookup[safeOps,ParentProtocol],
				Priority->Lookup[safeOps,Priority],
				StartDate->Lookup[safeOps,StartDate],
				HoldOrder->Lookup[safeOps,HoldOrder],
				QueuePosition->Lookup[safeOps,QueuePosition],
				ConstellationMessage->Object[Protocol,MagneticBeadSeparation],
				Cache->cache,
				Simulation -> simulation
			]
	];

	(*Return the requested output*)
	outputSpecification/.{
		Result->protocolObject,
		Tests->Flatten[{safeOpsTests,validLengthTests,templateTests,resolvedOptionsTests,resourcePacketTests}],
		Options->RemoveHiddenOptions[ExperimentMagneticBeadSeparation,collapsedUnnestedResolvedOptions],
		Preview->Null,
		Simulation->simulatedProtocolSimulation,
		RunTime -> runTime
	}
];



(* ::Subsubsection::Closed:: *)
(*resolveExperimentMagneticBeadSeparationMethod*)
DefineOptions[resolveExperimentMagneticBeadSeparationMethod,
	SharedOptions:>{
		ExperimentMagneticBeadSeparation,
		CacheOption,
		SimulationOption,
		OutputOption
	}
];

Error::ConflictingMagneticBeadSeparationMethodRequirements="The following option(s)/input(s) were specified that require a Manual Preparation method, `1`. However, the following option(s)/input(s) were specified that require a Robotic Preparation method, `2`. Please resolve this conflict in order to submit a valid MagneticBeadSeparation protocol.";

(* NOTE: You should NOT throw messages in this function. Just return the methods by which you can perform your primitive with the given options. *)
resolveExperimentMagneticBeadSeparationMethod[
	myInputs:Automatic|ListableP[ListableP[ObjectP[{Object[Sample],Object[Container]}]]],
	myOptions:OptionsPattern[]
]:=Module[
	{
		listedOptions,safeOps,outputSpecification,output,gatherTests,result,tests,

		(* option variables *)
		volumes,magneticBeadVolumes,preWashBufferVolumes,preWashCollectionContainers,equilibrationBufferVolumes,
		equilibrationCollectionContainers,washBufferVolumes,elutionBufferVolumes,loadingCollectionContainers,
		washCollectionContainers,secondaryWashCollectionContainers,tertiaryWashCollectionContainers,quaternaryWashCollectionContainers,quinaryWashCollectionContainers,senaryWashCollectionContainers,septenaryWashCollectionContainers,elutionCollectionContainers,magnetizationRacks,

		(* download variables *)
		sampleContainerPackets,samplePackets,collectionContainerPackets,collectionContainerModelPackets,
		allModelContainerFootprints,allPackets,allModelContainerPackets,mySamplePackets,magnetizationRackPackets,
		magnetizationRackModelPackets,uniqueMagnetizationRackModels,

		resolvedVolumes,manualRequirementStrings,roboticRequirementStrings
	},

	(* make sure options are in listed form *)
	listedOptions=ToList[myOptions];

	(* get the safe options *)
	safeOps=SafeOptions[resolveExperimentMagneticBeadSeparationMethod,listedOptions];

	(* Determine the requested return value from the function *)
	outputSpecification=OptionValue[Output];

	output=ToList[outputSpecification];

	(* Determine if we should keep a running list of tests *)
	gatherTests=MemberQ[output,Tests];

	(* get the volume options that can force to manual if any of them exceeds 50 mL *)
	{
		volumes,preWashCollectionContainers,equilibrationCollectionContainers,
		loadingCollectionContainers,washCollectionContainers,secondaryWashCollectionContainers,tertiaryWashCollectionContainers,quaternaryWashCollectionContainers,quinaryWashCollectionContainers,senaryWashCollectionContainers,septenaryWashCollectionContainers,elutionCollectionContainers,magnetizationRacks
	}=Lookup[
		safeOps,
		{
			Volume,PreWashCollectionContainer,EquilibrationCollectionContainer,
			LoadingCollectionContainer,WashCollectionContainer,SecondaryWashCollectionContainer,TertiaryWashCollectionContainer,QuaternaryWashCollectionContainer,QuinaryWashCollectionContainer,SenaryWashCollectionContainer,SeptenaryWashCollectionContainer,ElutionCollectionContainer,MagnetizationRack
		}
	];

	(* Download information that we need from our inputs and options. *)
	{
		(*1*)sampleContainerPackets,
		(*2*)samplePackets,
		(*3*)collectionContainerPackets,
		(*4*)collectionContainerModelPackets,
		(*5*)magnetizationRackPackets,
		(*6*)magnetizationRackModelPackets
	}=Quiet[Download[
		{
			(*1*)Cases[myInputs,ObjectP[Object[Container]],Infinity],
			(*2*)Cases[myInputs,ObjectP[Object[Sample]],Infinity],
			(*3*)Cases[{preWashCollectionContainers,equilibrationCollectionContainers,loadingCollectionContainers,washCollectionContainers,secondaryWashCollectionContainers,tertiaryWashCollectionContainers,quaternaryWashCollectionContainers,quinaryWashCollectionContainers,senaryWashCollectionContainers,septenaryWashCollectionContainers,elutionCollectionContainers},ObjectP[Object[Container]],Infinity],
			(*4*)Cases[{preWashCollectionContainers,equilibrationCollectionContainers,loadingCollectionContainers,washCollectionContainers,secondaryWashCollectionContainers,tertiaryWashCollectionContainers,quaternaryWashCollectionContainers,quinaryWashCollectionContainers,senaryWashCollectionContainers,septenaryWashCollectionContainers,elutionCollectionContainers},ObjectP[Model[Container]],Infinity],
			(*5*)Cases[ToList[magnetizationRacks],ObjectP[Object[Container]],Infinity],
			(*6*)Cases[ToList[magnetizationRacks],ObjectP[Model[Container]],Infinity]
		},
		{
			{
				Packet[Model[{Name,Footprint}]],
				Packet[Name,Model,Contents],
				Packet[Contents[[All,2]][{Name,LiquidHandlerIncompatible,Container,Position}]]
			},
			{
				Packet[Name,LiquidHandlerIncompatible,Container,Position],
				Packet[Container[Model[{Name,Footprint}]]]
			},
			{Packet[Model[{Name,Footprint}]]},
			{Packet[Name,Footprint]},
			{Packet[Model[{Name,Magnetized,Footprint}]]},
			{Packet[Name,Magnetized,Footprint]}
		},
		Cache->Lookup[listedOptions,Cache,{}],
		Simulation->Lookup[listedOptions,Simulation,Null]
	],Download::FieldDoesntExist];

	(* separate out the sample packet *)
	mySamplePackets=Cases[Flatten[samplePackets],PacketP[Object[Sample]]];

	(* combine all packets *)
	allPackets=Experiment`Private`FlattenCachePackets[{
		sampleContainerPackets,samplePackets,collectionContainerPackets,collectionContainerModelPackets,
		magnetizationRackPackets,magnetizationRackModelPackets
	}];

	(* get unique magnetization rack models *)
	uniqueMagnetizationRackModels=Cases[Flatten[magnetizationRackModelPackets],KeyValuePattern[{Object->obj_,Type->Model[Container,Rack],Magnetized->True}]:>obj];

	(* Get all of our Model[Container]s and look at their footprints. *)
	allModelContainerPackets=Cases[allPackets,PacketP[Model[Container]]];
	allModelContainerFootprints=If[Length[allModelContainerPackets]==0,
		{},
		Lookup[allModelContainerPackets,Footprint]
	];

	(* Create a list of reasons why we need Preparation->Manual. *)

	manualRequirementStrings={
			If[MemberQ[Lookup[allModelContainerPackets,Footprint,{}],Except[LiquidHandlerCompatibleFootprintP]],
				"the sample container/collection container footprints "<>ToString[Cases[Transpose[{(ObjectToString[#,Cache->allModelContainerPackets]&)/@Lookup[allModelContainerPackets,Object,{}],Lookup[allModelContainerPackets,Footprint,{}]}],{_,Except[LiquidHandlerCompatibleFootprintP]}][[All,1]]]<>" are not liquid handler compatible",
				Nothing
			],
			(* check magnetization rack. all models except Model[Item,MagnetizationRack,"Alpaqua 96S Super Magnet 96-well Plate Rack"] and Model[Item,MagnetizationRack,"Alpaqua Magnum FLX Enhanced Universal Magnet 96-well Plate Rack"] *)
			(* can only be used manually *)
			If[!MatchQ[uniqueMagnetizationRackModels,{}]&&!MatchQ[uniqueMagnetizationRackModels,{ObjectReferenceP[Model[Item, MagnetizationRack, "id:aXRlGn6O3vqO"],Model[Item, MagnetizationRack, "id:kEJ9mqJYljjz"]]..}],
				"the following MagnetizationRack can only be used to perform separation manually: "<>ObjectToString[Cases[uniqueMagnetizationRackModels,Except[ObjectReferenceP[Model[Item, MagnetizationRack, "id:aXRlGn6O3vqO"],Model[Item, MagnetizationRack, "id:kEJ9mqJYljjz"]]]],Cache->allPackets],
				Nothing
			],
			(* check volume. If it is larger than 2 Milliliters, must be manual *)
			If[Length[Cases[volumes,GreaterP[2Milliliter],Infinity]]>0,
				"the following Volume can only be used to perform separation manually: " <> ToString[Cases[volumes,GreaterP[2Milliliter],Infinity]],
				Nothing
			],
			(* check mix type options *)
			Sequence@@Module[{mixTypeOptionNames},
				(* get the option names with mix type *)
				mixTypeOptionNames={PreWashMixType,EquilibrationMixType,LoadingMixType,WashMixType,SecondaryWashMixType,TertiaryWashMixType,QuaternaryWashMixType,QuinaryWashMixType,SenaryWashMixType,SeptenaryWashMixType,ElutionMixType};

				(* check each option for mix types that can only performed manually *)
				If[MemberQ[ToList[Lookup[listedOptions,#,{}]],Except[ListableP@ListableP[Automatic|Pipette|Shake|Null]]],
					StringJoin[
						"the ",
						ToString[#],
						" ",
						ToString[Cases[ToList[Lookup[listedOptions,#,{}]],Except[ListableP@ListableP[Automatic|Pipette|Shake|Null]]]],
						" can only be performed manually"
					],
					Nothing
				]&/@mixTypeOptionNames
			],
			If[MemberQ[Lookup[mySamplePackets,LiquidHandlerIncompatible],True],
				"the following samples are liquid handler incompatible "<>ObjectToString[Lookup[Cases[mySamplePackets,KeyValuePattern[LiquidHandlerIncompatible->True]],Object],Cache->allPackets],
				Nothing
			],
			If[MemberQ[safeOps,Verbatim[Rule][Alternatives@@Lookup[OptionDefinition[IncubatePrepOptionsNestedIndexMatching],"OptionSymbol"],Except[ListableP@ListableP[False|Null|Automatic]]]],
				"the Incubate Sample Preparation stage is set to True (Sample Preparation is only supported Manually)",
				Nothing
			],
			If[MemberQ[safeOps,Verbatim[Rule][Alternatives@@Lookup[OptionDefinition[CentrifugePrepOptionsNestedIndexMatching],"OptionSymbol"],Except[ListableP@ListableP[False|Null|Automatic]]]],
				"the Centrifuge Sample Preparation stage is set to True (Sample Preparation is only supported Manually)",
				Nothing
			],
			If[MemberQ[safeOps,Verbatim[Rule][Alternatives@@Lookup[OptionDefinition[FilterPrepOptionsNestedIndexMatching],"OptionSymbol"],Except[ListableP@ListableP[False|Null|Automatic]]]],
				"the Filter Sample Preparation stage is set to True (Sample Preparation is only supported Manually)",
				Nothing
			],
			If[MemberQ[safeOps,Verbatim[Rule][Alternatives@@Lookup[OptionDefinition[AliquotOptionsPooled],"OptionSymbol"],Except[ListableP@ListableP[False|Null|Automatic]]]],
				"the Aliquot Sample Preparation stage is set to True (Sample Preparation is only supported Manually)",
				Nothing
			],
			If[MatchQ[Lookup[safeOps,Preparation],Manual],
				"the Preparation option is set to Manual by the user",
				Nothing
			]
	};

	roboticRequirementStrings={
		(*The MagnetizationRack is set to Alpaqua 96S Super Magnet 96-well Plate Rack or Alpaqua Magnum FLX Enhanced Universal Magnet 96-well Plate Rack, which is used in Robotic only*)
		If[MatchQ[Lookup[safeOps,MagnetizationRack],ListableP[ObjectP[{Model[Item, MagnetizationRack, "id:aXRlGn6O3vqO"],Model[Item, MagnetizationRack, "id:kEJ9mqJYljjz"]}],3]],
			"the MagnetizationRack is set to Alpaqua 96S Super Magnet 96-well Plate Rack or Alpaqua Magnum FLX Enhanced Universal Magnet 96-well Plate Rack which is for Robotic preparation",
			Nothing
		],
		(*The preparation option is set to Robotic by the user*)
		If[MatchQ[Lookup[safeOps,Preparation],Robotic],
			"the Preparation option is set to Robotic by the user",
			Nothing
		],
    (* check aspiration pipetting options. these can only be used with Robotic *)
    Sequence@@Module[{aspirationPipettingOptionNames},
      (* get the option names with mix type *)
      aspirationPipettingOptionNames={PreWashAspirationPosition, PreWashAspirationPositionOffset,
        EquilibrationAspirationPosition, EquilibrationAspirationPositionOffset,
        LoadingAspirationPosition, LoadingAspirationPositionOffset,
        WashAspirationPosition,WashAspirationPositionOffset,
        SecondaryWashAspirationPosition,SecondaryWashAspirationPositionOffset,
        TertiaryWashAspirationPosition,TertiaryWashAspirationPositionOffset,
        QuaternaryWashAspirationPosition,QuaternaryWashAspirationPositionOffset,
        QuinaryWashAspirationPosition,QuinaryWashAspirationPositionOffset,
        SenaryWashAspirationPosition,SenaryWashAspirationPositionOffset,
        SeptenaryWashAspirationPosition,SeptenaryWashAspirationPositionOffset,
        ElutionAspirationPosition,ElutionAspirationPositionOffset};

      (* check each option for mix types that can only performed manually *)
      If[MatchQ[Lookup[safeOps,#],Except[ListableP@ListableP[Automatic|Null]]],
        StringJoin[
          "the ",
          ToString[#],
          " of ",
          ToString[Cases[ToList[Lookup[safeOps,#]],Lookup[safeOps,#]]],
          " can only be performed robotically"
        ],
        Nothing
      ]&/@aspirationPipettingOptionNames
    ]
	};

	(* Throw an error if the user has already specified Robotic Preparation option or robotic magnetization rack and it's in conflict with our requirements. *)
	If[
		And[
			Length[manualRequirementStrings]>0,
			Length[roboticRequirementStrings]>0,
			!gatherTests
		],
		(* NOTE: Blocking $MessagePrePrint stops our error message from being truncated with ... if it gets too long. *)
		Block[{$MessagePrePrint},
			Message[
				Error::ConflictingMagneticBeadSeparationMethodRequirements,
				listToString[manualRequirementStrings],
				listToString[roboticRequirementStrings]
			]
		]
	];

	(* Return our result and tests. *)
	result=Which[
		(*If user specified preparation , use as user specified*)
		MatchQ[Lookup[safeOps,Preparation],Except[Automatic]],
			Lookup[safeOps,Preparation],
		(*If there is any option that requires manual preparation, use manual*)
		Length[manualRequirementStrings]>0,
			Manual,
		(*If there is any option that requires robotic preparation, use robotic*)
		Length[roboticRequirementStrings]>0,
			Robotic,
		(*If there are more than 3 input samples, allow both but prioritize Robotic*)
		Length[Flatten[myInputs]] > 3,
			{Robotic,Manual},
		(*Otherwise, allow both but prioritize Manual*)
		True,
			{Manual,Robotic}
	];

	(* gather all tests *)
	tests=If[gatherTests,
		{
			Test["There are not conflicting Manual and Robotic requirements when resolving the Preparation method for the MagneticBeadSeparation primitive",
				Length[manualRequirementStrings]>0&&Length[roboticRequirementStrings]>0,
				False
			]
		},
		{}
	];

	(* return our result and/or tests *)
	outputSpecification/.{Result->result,Tests->tests}
];


(* ::Subsubsection::Closed:: *)

(*resolveExperimentMagneticBeadSeparationOptions*)


DefineOptions[resolveExperimentMagneticBeadSeparationOptions,
	Options:>{
		CacheOption,
		HelperOutputOption,
		SimulationOption
	}
];


resolveExperimentMagneticBeadSeparationOptions[
	myNestedSamples:ListableP[{ObjectP[Object[Sample]]..}],
	myOriginalSamples:ListableP[ListableP[ObjectP[{Object[Sample],Object[Container],Model[Sample]}]|_String|{LocationPositionP,_String|ObjectP[Object[Container]]}]],
	myOptions:{_Rule...},
	myResolutionOptions:OptionsPattern[resolveExperimentMagneticBeadSeparationOptions]
]:=Module[
	{
		(* General start *)
		outputSpecification,output,gatherTests,messages,notInEngine,inheritedCache,simulation,combinedFastAssoc,
		validProcessingOrderQ,invalidProcessingOrderOptions,validProcessingOrderTest,
		flatSamples,optionDefinitions,flatMBSOptions,flatSamplePrepOptions,
		samplePrepOptions,mbsOptions,
		preparationResult,allowedPreparation,preparationTest,resolvedPreparation,simulatedSamples,resolvedSamplePrepOptions,
		simulatedCache,samplePrepTests,mbsOptionsAssociationFlat,

		(* WorkCell-related *)
		allowedWorkCells,resolvedWorkCell,

		(* Non-precision options *)
		selectionStrategy,separationMode,processingOrder,numberOfReplicates,magnetizationRacks,name,parentProtocol,sampleLabels,sampleContainerLabels,sampleOutLabels,containerOutLabels,

		preWashDestinationWells,preWashCollectionContainerIndices,preWashCollectionContainerLabels,
		equilibrationDestinationWells,equilibrationCollectionContainerIndices,equilibrationCollectionContainerLabels,
		loadingDestinationWells,loadingCollectionContainerIndices,loadingCollectionContainerLabels,
		washDestinationWells,washCollectionContainerIndices,washCollectionContainerLabels,
		secondaryWashDestinationWells,secondaryWashCollectionContainerIndices,secondaryWashCollectionContainerLabels,
		tertiaryWashDestinationWells,tertiaryWashCollectionContainerIndices,tertiaryWashCollectionContainerLabels,
		quaternaryWashDestinationWells,quaternaryWashCollectionContainerIndices,quaternaryWashCollectionContainerLabels,
		quinaryWashDestinationWells,quinaryWashCollectionContainerIndices,quinaryWashCollectionContainerLabels,
		senaryWashDestinationWells,senaryWashCollectionContainerIndices,senaryWashCollectionContainerLabels,
		septenaryWashDestinationWells,septenaryWashCollectionContainerIndices,septenaryWashCollectionContainerLabels,
		elutionDestinationWells,elutionCollectionContainerIndices,elutionCollectionContainerLabels,
		magneticBeadCollectionStorageConditions,

		preWashCollectionStorageConditions,equilibrationCollectionStorageConditions,loadingCollectionStorageConditions,
		washCollectionStorageConditions,secondaryWashCollectionStorageConditions,tertiaryWashCollectionStorageConditions,
		quaternaryWashCollectionStorageConditions,quinaryWashCollectionStorageConditions,senaryWashCollectionStorageConditions,septenaryWashCollectionStorageConditions,elutionCollectionStorageConditions,

		flatSimulatedSamples,

		(* Options which may have models or objects with downloadable info *)
		targets,analyteAffinityLabels,magneticBeadAffinityLabels,magneticBeads,
		preWashCollectionContainers,equilibrationCollectionContainers,
		loadingCollectionContainers,washCollectionContainers,secondaryWashCollectionContainers,tertiaryWashCollectionContainers,quaternaryWashCollectionContainers,quinaryWashCollectionContainers,senaryWashCollectionContainers,septenaryWashCollectionContainers,elutionCollectionContainers,

		(* Download info *)
		allCollectionContainersNoLink,collectionContainerObjects,collectionContainerModels,magnetizationRacksNoLink,
		magnetizationRackObjects,magnetizationRackModels,allMagneticBeadIdentityModels,sampleDownloadPacket,identityModelDownloadPacket,
		containerDownloadPacket,containerModelDownloadPacket,storageConditionsNoLink,storageConditionModels,storageConditionPackets,

		simulatedSamplePackets,collectionContainerPackets,collectionContainerModelPackets,allMagneticBeadIdentityModelPackets,
		rawMagnetizationRackPackets,rawMagnetizationRackModelPackets,

		(* Parse Download *)
		flatSimulatedSamplePackets,flattenedCachePackets,

		(* Input Checks *)
		discardedSamplePackets,discardedInvalidInputs,discardedTest,
		solidSamplePackets,solidInvalidInputs,solidTest,

		(* Rounded Options *)
		roundedMBSOptions,precisionTests,

		volumes,magneticBeadVolumes,

		preWashBufferVolumes,preWashMixTimes,preWashMixTemperatures,
		preWashMixRates,preWashMixVolumes,preWashMagnetizationTimes,preWashAspirationVolumes,preWashAirDryTimes,

		equilibrationBufferVolumes,equilibrationMixTimes,equilibrationMixTemperatures,equilibrationMixRates,
		equilibrationMixVolumes,equilibrationMagnetizationTimes,equilibrationAspirationVolumes,equilibrationAirDryTimes,


		loadingMixTimes,loadingMixTemperatures,loadingMixRates,loadingMixVolumes,loadingMagnetizationTimes,
		loadingAspirationVolumes,loadingAirDryTimes,

		washBufferVolumes,washMixTimes,washMixTemperatures,washMixRates,washMixVolumes,washMagnetizationTimes,washAspirationVolumes,washAirDryTimes,

		secondaryWashBufferVolumes,secondaryWashMixTimes,secondaryWashMixTemperatures,secondaryWashMixRates,secondaryWashMixVolumes,secondaryWashMagnetizationTimes,secondaryWashAspirationVolumes,secondaryWashAirDryTimes,

		tertiaryWashBufferVolumes,tertiaryWashMixTimes,tertiaryWashMixTemperatures,tertiaryWashMixRates,tertiaryWashMixVolumes,tertiaryWashMagnetizationTimes,tertiaryWashAspirationVolumes,tertiaryWashAirDryTimes,

		quaternaryWashBufferVolumes,quaternaryWashMixTimes,quaternaryWashMixTemperatures,quaternaryWashMixRates,quaternaryWashMixVolumes,quaternaryWashMagnetizationTimes,quaternaryWashAspirationVolumes,quaternaryWashAirDryTimes,

		quinaryWashBufferVolumes,quinaryWashMixTimes,quinaryWashMixTemperatures,quinaryWashMixRates,quinaryWashMixVolumes,quinaryWashMagnetizationTimes,quinaryWashAspirationVolumes,quinaryWashAirDryTimes,

		senaryWashBufferVolumes,senaryWashMixTimes,senaryWashMixTemperatures,senaryWashMixRates,senaryWashMixVolumes,senaryWashMagnetizationTimes,senaryWashAspirationVolumes,senaryWashAirDryTimes,

		septenaryWashBufferVolumes,septenaryWashMixTimes,septenaryWashMixTemperatures,septenaryWashMixRates,septenaryWashMixVolumes,septenaryWashMagnetizationTimes,septenaryWashAspirationVolumes,septenaryWashAirDryTimes,

		elutionBufferVolumes,elutionMixTimes,elutionMixTemperatures,elutionMixRates,elutionMixVolumes,	elutionMagnetizationTimes,elutionAspirationVolumes,

		(* Conflicting option checks *)
		validNameQ,invalidNameOptions,validNameTest,
		resolvedProcessingOrder,resolvedMagneticBeadVolumes,updatedRoundedMBSOptions,
		separationModeMatchQ,separationModeMismatchOptions,separationModeMatchTest,

		(* Resolve MapThread Options *)
		mapThreadFriendlyOptions,preResolvedMapThreadFriendlyOptions,resolvedAssayContainers,resolvedMagnetizationRackModels,

		(* MapThread error tracking variables *)
		collectionContainerLookup,invalidDestinationWells,noAvailablePositionsInContainer,

		resolvedPreWashDestinationWells,resolvedEquilibrationDestinationWells,resolvedLoadingDestinationWells,resolvedWashDestinationWells,resolvedSecondaryWashDestinationWells,resolvedTertiaryWashDestinationWells,resolvedQuaternaryWashDestinationWells,resolvedQuinaryWashDestinationWells,resolvedSenaryWashDestinationWells,resolvedSeptenaryWashDestinationWells,resolvedElutionDestinationWells,

		invalidBufferVolumes,flattenedInvalidBufferVolumes,invalidBufferVolumesOptions,invalidBufferVolumeTests,
		storageConditionLookup,allContainers,conflictingPreWashCollectionStorageConditionInfo,
		conflictingEquilibrationCollectionStorageConditionInfo,conflictingLoadingCollectionStorageConditionInfo,conflictingWashCollectionStorageConditionInfo,conflictingSecondaryWashCollectionStorageConditionInfo,conflictingTertiaryWashCollectionStorageConditionInfo,conflictingQuaternaryWashCollectionStorageConditionInfo,conflictingQuinaryWashCollectionStorageConditionInfo,conflictingSenaryWashCollectionStorageConditionInfo,conflictingSeptenaryWashCollectionStorageConditionInfo,
		conflictingElutionCollectionStorageConditionInfo,conflictingCollectionStorageConditionInfo,conflictingCollectionStorageConditionOptions,
		conflictingCollectionStorageConditionTests,correctedPreWashCollectionStorageConditions,correctedEquilibrationCollectionStorageConditions,
		correctedLoadingCollectionStorageConditions,correctedWashCollectionStorageConditions,correctedSecondaryWashCollectionStorageConditions,correctedTertiaryWashCollectionStorageConditions,correctedQuaternaryWashCollectionStorageConditions,correctedQuinaryWashCollectionStorageConditions,correctedSenaryWashCollectionStorageConditions,correctedSeptenaryWashCollectionStorageConditions,correctedElutionCollectionStorageConditions,
		numberOfPreWashesMismatchSamples,correctedPreWashCollectionContainers,correctedPreWashDestinationWells,correctedPreWashCollectionContainerIndices,correctedPreWashCollectionContainerLabels,
		preWashOptionsWithCorrectDims,numberOfPreWashMismatchOptions,numberOfPreWashMismatchTests,
		numberOfEquilibrationsMismatchSamples,correctedEquilibrationCollectionContainers,correctedEquilibrationDestinationWells,correctedEquilibrationCollectionContainerIndices,correctedEquilibrationCollectionContainerLabels,
		equilibrationOptionsWithCorrectDims,numberOfEquilibrationMismatchOptions,numberOfEquilibrationMismatchTests,
		numberOfLoadingsMismatchSamples,correctedLoadingCollectionContainers,correctedLoadingDestinationWells,correctedLoadingCollectionContainerIndices,correctedLoadingCollectionContainerLabels,
		loadingOptionsWithCorrectDims,numberOfLoadingMismatchOptions,numberOfLoadingMismatchTests,
		numberOfWashesMismatchSamples,correctedWashCollectionContainers,correctedWashDestinationWells,correctedWashCollectionContainerIndices,correctedWashCollectionContainerLabels,
		washOptionsWithCorrectDims,numberOfWashMismatchOptions,numberOfWashMismatchTests,
		numberOfSecondaryWashesMismatchSamples,correctedSecondaryWashCollectionContainers,correctedSecondaryWashDestinationWells,correctedSecondaryWashCollectionContainerIndices,correctedSecondaryWashCollectionContainerLabels,
		secondaryWashOptionsWithCorrectDims,numberOfSecondaryWashMismatchOptions,numberOfSecondaryWashMismatchTests,
		numberOfTertiaryWashesMismatchSamples,correctedTertiaryWashCollectionContainers,correctedTertiaryWashDestinationWells,correctedTertiaryWashCollectionContainerIndices,correctedTertiaryWashCollectionContainerLabels,
		tertiaryWashOptionsWithCorrectDims,numberOfTertiaryWashMismatchOptions,numberOfTertiaryWashMismatchTests,
		numberOfQuaternaryWashesMismatchSamples,correctedQuaternaryWashCollectionContainers,correctedQuaternaryWashDestinationWells,correctedQuaternaryWashCollectionContainerIndices,correctedQuaternaryWashCollectionContainerLabels,
		quaternaryWashOptionsWithCorrectDims,numberOfQuaternaryWashMismatchOptions,numberOfQuaternaryWashMismatchTests,
		numberOfQuinaryWashesMismatchSamples,correctedQuinaryWashCollectionContainers,correctedQuinaryWashDestinationWells,correctedQuinaryWashCollectionContainerIndices,correctedQuinaryWashCollectionContainerLabels,
		quinaryWashOptionsWithCorrectDims,numberOfQuinaryWashMismatchOptions,numberOfQuinaryWashMismatchTests,
		numberOfSenaryWashesMismatchSamples,correctedSenaryWashCollectionContainers,correctedSenaryWashDestinationWells,correctedSenaryWashCollectionContainerIndices,correctedSenaryWashCollectionContainerLabels,
		senaryWashOptionsWithCorrectDims,numberOfSenaryWashMismatchOptions,numberOfSenaryWashMismatchTests,
		numberOfSeptenaryWashesMismatchSamples,correctedSeptenaryWashCollectionContainers,correctedSeptenaryWashDestinationWells,correctedSeptenaryWashCollectionContainerIndices,correctedSeptenaryWashCollectionContainerLabels,
		septenaryWashOptionsWithCorrectDims,numberOfSeptenaryWashMismatchOptions,numberOfSeptenaryWashMismatchTests,
		numberOfElutionsMismatchSamples,correctedElutionCollectionContainers,correctedElutionDestinationWells,correctedElutionCollectionContainerIndices,correctedElutionCollectionContainerLabels,
		elutionOptionsWithCorrectDims,numberOfElutionMismatchOptions,numberOfElutionMismatchTests,
		invalidDestinationWellsOptions,invalidDestinationWellsTests,noAvailablePositionsInContainerTests,

		multipleAnalytesWarnings,multipleTargetTypesWarnings,multipleTargetsWarnings,generalResolvedMagneticBeadsWarnings,

		preWashMismatchErrors,preWashMixMismatchErrors,preWashAirDryMismatchErrors,
		equilibrationMismatchErrors,equilibrationMixMismatchErrors,equilibrationAirDryMismatchErrors,
		loadingMixMismatchErrors,loadingAirDryMismatchErrors,nullLoadingCollectionContainerLabelErrors,
		washMismatchErrors,washMixMismatchErrors,washAirDryMismatchErrors,mismatchedWashCollectionContainerLabelErrors,
		secondaryWashMismatchErrors,secondaryWashMixMismatchErrors,secondaryWashAirDryMismatchErrors,mismatchedSecondaryWashCollectionContainerLabelErrors,
		tertiaryWashMismatchErrors,tertiaryWashMixMismatchErrors,tertiaryWashAirDryMismatchErrors,mismatchedTertiaryWashCollectionContainerLabelErrors,
		quaternaryWashMismatchErrors,quaternaryWashMixMismatchErrors,quaternaryWashAirDryMismatchErrors,mismatchedQuaternaryWashCollectionContainerLabelErrors,
		quinaryWashMismatchErrors,quinaryWashMixMismatchErrors,quinaryWashAirDryMismatchErrors,mismatchedQuinaryWashCollectionContainerLabelErrors,
		senaryWashMismatchErrors,senaryWashMixMismatchErrors,senaryWashAirDryMismatchErrors,mismatchedSenaryWashCollectionContainerLabelErrors,
		septenaryWashMismatchErrors,septenaryWashMixMismatchErrors,septenaryWashAirDryMismatchErrors,mismatchedSeptenaryWashCollectionContainerLabelErrors,
		elutionMismatchErrors,elutionMixMismatchErrors,mismatchedElutionCollectionContainerLabelErrors,nullElutionCollectionContainerLabelErrors,
	invalidContainerOutLabelLengthErrors,mismatchedContainerOutLabelErrors,

		(* MapThread resolved options *)
		resolvedVolumes,resolvedMagnetizationRacks,unresolvedMagnetizationRacks,resolvedTargets,resolvedAnalyteAffinityLabels,resolvedMagneticBeadAffinityLabels,resolvedMagneticBeads,objectAndOptionToMixOptionLookup,

		resolvedPreWashes,resolvedPreWashBuffers,resolvedPreWashBufferVolumes,resolvedPreWashMixTimes,resolvedPreWashMixTemperatures,resolvedPreWashMixes,resolvedPreWashMixTypes,resolvedPreWashMixRates,
		resolvedPreWashMixVolumes,resolvedNumberOfPreWashMixes,resolvedPreWashMagnetizationTimes,resolvedPreWashAspirationVolumes,resolvedPreWashCollectionContainers,
		resolvedPreWashCollectionStorageConditions,resolvedNumberOfPreWashes,resolvedPreWashAirDries,resolvedPreWashAirDryTimes,
		resolvedPreWashMixTipTypes,resolvedPreWashMixTipMaterials,resolvedPreWashCollectionContainerLabels,

		resolvedEquilibrations,resolvedEquilibrationBuffers,resolvedEquilibrationBufferVolumes,resolvedEquilibrationMixTimes,resolvedEquilibrationMixTemperatures,resolvedEquilibrationMixes,resolvedEquilibrationMixTypes,resolvedEquilibrationMixRates,
		resolvedEquilibrationMixVolumes,resolvedNumberOfEquilibrationMixes,resolvedEquilibrationMagnetizationTimes,resolvedEquilibrationAspirationVolumes,resolvedEquilibrationCollectionContainers,
		resolvedEquilibrationCollectionStorageConditions,resolvedEquilibrationAirDries,resolvedEquilibrationAirDryTimes,resolvedEquilibrationMixTipTypes,
		resolvedEquilibrationMixTipMaterials,
		resolvedEquilibrationCollectionContainerLabels,

		resolvedLoadingMixTimes,resolvedLoadingMixTemperatures,resolvedLoadingMixes,resolvedLoadingMixTypes,resolvedLoadingMixRates,
		resolvedLoadingMixVolumes,resolvedNumberOfLoadingMixes,resolvedLoadingMagnetizationTimes,resolvedLoadingAspirationVolumes,resolvedLoadingCollectionContainers,
		resolvedLoadingCollectionStorageConditions,resolvedLoadingAirDries,resolvedLoadingAirDryTimes,
		resolvedLoadingMixTipTypes,
		resolvedLoadingMixTipMaterials,resolvedLoadingCollectionContainerLabels,

		resolvedWashes,resolvedWashBuffers,resolvedWashBufferVolumes,resolvedWashMixTimes,resolvedWashMixTemperatures,resolvedWashMixes,resolvedWashMixTypes,resolvedWashMixRates,
		resolvedWashMixVolumes,resolvedNumberOfWashMixes,resolvedWashMagnetizationTimes,resolvedWashAspirationVolumes,resolvedWashCollectionContainers,
		resolvedWashCollectionStorageConditions,resolvedNumberOfWashes,resolvedWashAirDries,resolvedWashAirDryTimes,
		resolvedWashMixTipTypes,resolvedWashMixTipMaterials,
		resolvedWashCollectionContainerLabels,

		resolvedSecondaryWashes,resolvedSecondaryWashBuffers,resolvedSecondaryWashBufferVolumes,resolvedSecondaryWashMixTimes,resolvedSecondaryWashMixTemperatures,resolvedSecondaryWashMixes,resolvedSecondaryWashMixTypes,resolvedSecondaryWashMixRates,
		resolvedSecondaryWashMixVolumes,resolvedNumberOfSecondaryWashMixes,resolvedSecondaryWashMagnetizationTimes,resolvedSecondaryWashAspirationVolumes,resolvedSecondaryWashCollectionContainers,
		resolvedSecondaryWashCollectionStorageConditions,resolvedNumberOfSecondaryWashes,resolvedSecondaryWashAirDries,resolvedSecondaryWashAirDryTimes,
		resolvedSecondaryWashMixTipTypes,resolvedSecondaryWashMixTipMaterials,
		resolvedSecondaryWashCollectionContainerLabels,

		resolvedTertiaryWashes,resolvedTertiaryWashBuffers,resolvedTertiaryWashBufferVolumes,resolvedTertiaryWashMixTimes,resolvedTertiaryWashMixTemperatures,resolvedTertiaryWashMixes,resolvedTertiaryWashMixTypes,resolvedTertiaryWashMixRates,
		resolvedTertiaryWashMixVolumes,resolvedNumberOfTertiaryWashMixes,resolvedTertiaryWashMagnetizationTimes,resolvedTertiaryWashAspirationVolumes,resolvedTertiaryWashCollectionContainers,
		resolvedTertiaryWashCollectionStorageConditions,resolvedNumberOfTertiaryWashes,resolvedTertiaryWashAirDries,resolvedTertiaryWashAirDryTimes,
		resolvedTertiaryWashMixTipTypes,	resolvedTertiaryWashMixTipMaterials,
		resolvedTertiaryWashCollectionContainerLabels,

		resolvedQuaternaryWashes,resolvedQuaternaryWashBuffers,resolvedQuaternaryWashBufferVolumes,resolvedQuaternaryWashMixTimes,resolvedQuaternaryWashMixTemperatures,resolvedQuaternaryWashMixes,resolvedQuaternaryWashMixTypes,resolvedQuaternaryWashMixRates,
		resolvedQuaternaryWashMixVolumes,resolvedNumberOfQuaternaryWashMixes,resolvedQuaternaryWashMagnetizationTimes,resolvedQuaternaryWashAspirationVolumes,resolvedQuaternaryWashCollectionContainers,
		resolvedQuaternaryWashCollectionStorageConditions,resolvedNumberOfQuaternaryWashes,resolvedQuaternaryWashAirDries,resolvedQuaternaryWashAirDryTimes,
		resolvedQuaternaryWashMixTipTypes,	resolvedQuaternaryWashMixTipMaterials,
		resolvedQuaternaryWashCollectionContainerLabels,

		resolvedQuinaryWashes,resolvedQuinaryWashBuffers,resolvedQuinaryWashBufferVolumes,resolvedQuinaryWashMixTimes,resolvedQuinaryWashMixTemperatures,resolvedQuinaryWashMixes,resolvedQuinaryWashMixTypes,resolvedQuinaryWashMixRates,
		resolvedQuinaryWashMixVolumes,resolvedNumberOfQuinaryWashMixes,resolvedQuinaryWashMagnetizationTimes,resolvedQuinaryWashAspirationVolumes,resolvedQuinaryWashCollectionContainers,
		resolvedQuinaryWashCollectionStorageConditions,resolvedNumberOfQuinaryWashes,resolvedQuinaryWashAirDries,resolvedQuinaryWashAirDryTimes,
		resolvedQuinaryWashMixTipTypes,	resolvedQuinaryWashMixTipMaterials,
		resolvedQuinaryWashCollectionContainerLabels,

		resolvedSenaryWashes,resolvedSenaryWashBuffers,resolvedSenaryWashBufferVolumes,resolvedSenaryWashMixTimes,resolvedSenaryWashMixTemperatures,resolvedSenaryWashMixes,resolvedSenaryWashMixTypes,resolvedSenaryWashMixRates,
		resolvedSenaryWashMixVolumes,resolvedNumberOfSenaryWashMixes,resolvedSenaryWashMagnetizationTimes,resolvedSenaryWashAspirationVolumes,resolvedSenaryWashCollectionContainers,
		resolvedSenaryWashCollectionStorageConditions,resolvedNumberOfSenaryWashes,resolvedSenaryWashAirDries,resolvedSenaryWashAirDryTimes,
		resolvedSenaryWashMixTipTypes,resolvedSenaryWashMixTipMaterials,
		resolvedSenaryWashCollectionContainerLabels,

		resolvedSeptenaryWashes,resolvedSeptenaryWashBuffers,resolvedSeptenaryWashBufferVolumes,resolvedSeptenaryWashMixTimes,resolvedSeptenaryWashMixTemperatures,resolvedSeptenaryWashMixes,resolvedSeptenaryWashMixTypes,resolvedSeptenaryWashMixRates,
		resolvedSeptenaryWashMixVolumes,resolvedNumberOfSeptenaryWashMixes,resolvedSeptenaryWashMagnetizationTimes,resolvedSeptenaryWashAspirationVolumes,resolvedSeptenaryWashCollectionContainers,
		resolvedSeptenaryWashCollectionStorageConditions,resolvedNumberOfSeptenaryWashes,resolvedSeptenaryWashAirDries,resolvedSeptenaryWashAirDryTimes,
		resolvedSeptenaryWashMixTipTypes,resolvedSeptenaryWashMixTipMaterials,
		resolvedSeptenaryWashCollectionContainerLabels,


		resolvedElutions,resolvedElutionBuffers,resolvedElutionBufferVolumes,resolvedElutionMixTimes,resolvedElutionMixTemperatures,resolvedElutionMixes,resolvedElutionMixTypes,resolvedElutionMixRates,
		resolvedElutionMixVolumes,resolvedNumberOfElutionMixes,resolvedElutionMagnetizationTimes,resolvedElutionAspirationVolumes,resolvedElutionCollectionContainers,
		resolvedElutionCollectionStorageConditions,resolvedNumberOfElutions,
		resolvedElutionMixTipTypes,
		resolvedElutionMixTipMaterials,
		resolvedElutionCollectionContainerLabels,

		resolvedSampleLabels,resolvedSampleContainerLabels,resolvedSampleOutLabels,resolvedContainerOutLabels,

    (*resolved aspiration pipetting options*)
    resolvedPreWashAspirationPositions, resolvedPreWashAspirationPositionOffsets,
    resolvedEquilibrationAspirationPositions, resolvedEquilibrationAspirationPositionOffsets,
    resolvedLoadingAspirationPositions, resolvedLoadingAspirationPositionOffsets,
    resolvedWashAspirationPositions,resolvedWashAspirationPositionOffsets,
    resolvedSecondaryWashAspirationPositions,resolvedSecondaryWashAspirationPositionOffsets,
    resolvedTertiaryWashAspirationPositions,resolvedTertiaryWashAspirationPositionOffsets,
    resolvedQuaternaryWashAspirationPositions,resolvedQuaternaryWashAspirationPositionOffsets,
    resolvedQuinaryWashAspirationPositions,resolvedQuinaryWashAspirationPositionOffsets,
    resolvedSenaryWashAspirationPositions,resolvedSenaryWashAspirationPositionOffsets,
    resolvedSeptenaryWashAspirationPositions,resolvedSeptenaryWashAspirationPositionOffsets,
    resolvedElutionAspirationPositions,resolvedElutionAspirationPositionOffsets,

		(* Label option errors *)
		invalidPreWashMixTypeContainerToSampleLookup,preWashMixTypeWarnings,invalidPreWashMixTypeTests,
		invalidEquilibrationMixTypeContainerToSampleLookup,equilibrationMixTypeWarnings,invalidEquilibrationMixTypeTests,
		invalidLoadingMixTypeContainerToSampleLookup,loadingMixTypeWarnings,invalidLoadingMixTypeTests,
		invalidWashMixTypeContainerToSampleLookup,washMixTypeWarnings,invalidWashMixTypeTests,
		invalidSecondaryWashMixTypeContainerToSampleLookup,secondaryWashMixTypeWarnings,invalidSecondaryWashMixTypeTests,
		invalidTertiaryWashMixTypeContainerToSampleLookup,tertiaryWashMixTypeWarnings,invalidTertiaryWashMixTypeTests,
		invalidQuaternaryWashMixTypeContainerToSampleLookup,quaternaryWashMixTypeWarnings,invalidQuaternaryWashMixTypeTests,
		invalidQuinaryWashMixTypeContainerToSampleLookup,quinaryWashMixTypeWarnings,invalidQuinaryWashMixTypeTests,
		invalidSenaryWashMixTypeContainerToSampleLookup,senaryWashMixTypeWarnings,invalidSenaryWashMixTypeTests,
		invalidSeptenaryWashMixTypeContainerToSampleLookup,septenaryWashMixTypeWarnings,invalidSeptenaryWashMixTypeTests,
		invalidElutionMixTypeContainerToSampleLookup,elutionMixTypeWarnings,invalidElutionMixTypeTests,
		preWashAirDryWarnings,invalidPreWashAirDryWarningTests,equilibrationAirDryWarnings,invalidEquilibrationAirDryWarningTests,
		loadingAirDryWarnings,invalidLoadingAirDryWarningTests,
		washAirDryWarnings,invalidWashAirDryWarningTests,
		secondaryWashAirDryWarnings,invalidSecondaryWashAirDryWarningTests,
		tertiaryWashAirDryWarnings,invalidTertiaryWashAirDryWarningTests,
		quaternaryWashAirDryWarnings,invalidQuaternaryWashAirDryWarningTests,
		quinaryWashAirDryWarnings,invalidQuinaryWashAirDryWarningTests,
		senaryWashAirDryWarnings,invalidSenaryWashAirDryWarningTests,
		septenaryWashAirDryWarnings,invalidSeptenaryWashAirDryWarningTests,

		(* Other option errors *)
		multipleAnalytesTest,multipleTargetTypesTest,multipleTargetsTest,generalResolvedMagneticBeadsTest,

		preWashMismatchOptions,preWashMismatchTest,
		preWashMixMismatchOptions,preWashMixMismatchTest,
		preWashAirDryMismatchOptions,preWashAirDryMismatchTest,

		equilibrationMismatchOptions,equilibrationMismatchTest,
		equilibrationMixMismatchOptions,equilibrationMixMismatchTest,
		equilibrationAirDryMismatchOptions,equilibrationAirDryMismatchTest,

		loadingMixMismatchOptions,loadingMixMismatchTest,
		loadingAirDryMismatchOptions,loadingAirDryMismatchTest,

		washMismatchOptions,washMismatchTest,
		washMixMismatchOptions,washMixMismatchTest,
		washAirDryMismatchOptions,washAirDryMismatchTest,

		secondaryWashMismatchOptions,secondaryWashMismatchTest,
		secondaryWashMixMismatchOptions,secondaryWashMixMismatchTest,
		secondaryWashAirDryMismatchOptions,secondaryWashAirDryMismatchTest,

		tertiaryWashMismatchOptions,tertiaryWashMismatchTest,
		tertiaryWashMixMismatchOptions,tertiaryWashMixMismatchTest,
		tertiaryWashAirDryMismatchOptions,tertiaryWashAirDryMismatchTest,

		quaternaryWashMismatchOptions,quaternaryWashMismatchTest,
		quaternaryWashMixMismatchOptions,quaternaryWashMixMismatchTest,
		quaternaryWashAirDryMismatchOptions,quaternaryWashAirDryMismatchTest,

		quinaryWashMismatchOptions,quinaryWashMismatchTest,
		quinaryWashMixMismatchOptions,quinaryWashMixMismatchTest,
		quinaryWashAirDryMismatchOptions,quinaryWashAirDryMismatchTest,

		senaryWashMismatchOptions,senaryWashMismatchTest,
		senaryWashMixMismatchOptions,senaryWashMixMismatchTest,
		senaryWashAirDryMismatchOptions,senaryWashAirDryMismatchTest,

		septenaryWashMismatchOptions,septenaryWashMismatchTest,
		septenaryWashMixMismatchOptions,septenaryWashMixMismatchTest,
		septenaryWashAirDryMismatchOptions,septenaryWashAirDryMismatchTest,

		elutionMismatchOptions,elutionMismatchTest,
		elutionMixMismatchOptions,elutionMixMismatchTest,

		(*Added error checking variables and tests*)

		unresolvedPreWashMixOptions,invalidPreWashMixTipTypeErrors,invalidPreWashMixTipTypeOptions,validPreWashMixTipTypeTest,preWashMixNoTipErrors,
		validPreWashMixTipTest,	preWashMixNoInstrumentErrors,validPreWashMixInstrumentTest,invalidPreWashMixTipOptions,invalidPreWashMixInstrumentOptions,preWashAspirationPipettingMismatchErrors,preWashAspirationPipettingMismatchOptions,preWashAspirationPipettingMismatchTests,

		unresolvedEquilibrationMixOptions,invalidEquilibrationMixTipTypeErrors,invalidEquilibrationMixTipTypeOptions,validEquilibrationMixTipTypeTest,equilibrationMixNoTipErrors,validEquilibrationMixTipTest,equilibrationMixNoInstrumentErrors,invalidEquilibrationMixTipOptions,invalidEquilibrationMixInstrumentOptions, validEquilibrationMixInstrumentTest,equilibrationAspirationPipettingMismatchErrors,equilibrationAspirationPipettingMismatchOptions,equilibrationAspirationPipettingMismatchTests,

		unresolvedLoadingMixOptions,invalidLoadingMixTipTypeErrors,invalidLoadingMixTipTypeOptions,validLoadingMixTipTypeTest,loadingMixNoTipErrors,
		validLoadingMixTipTest,loadingMixNoInstrumentErrors,validLoadingMixInstrumentTest,invalidLoadingMixTipOptions,
		invalidLoadingMixInstrumentOptions,loadingAspirationPipettingMismatchErrors,loadingAspirationPipettingMismatchOptions,loadingAspirationPipettingMismatchTests,

		unresolvedWashMixOptions,invalidWashMixTipTypeErrors,invalidWashMixTipTypeOptions,validWashMixTipTypeTest,washMixNoTipErrors,validWashMixTipTest,washMixNoInstrumentErrors,validWashMixInstrumentTest,invalidWashMixTipOptions,invalidWashMixInstrumentOptions,washAspirationPipettingMismatchErrors,washAspirationPipettingMismatchOptions,washAspirationPipettingMismatchTests,

		unresolvedSecondaryWashMixOptions,invalidSecondaryWashMixTipTypeErrors,invalidSecondaryWashMixTipTypeOptions,validSecondaryWashMixTipTypeTest,secondaryWashMixNoTipErrors,validSecondaryWashMixTipTest,secondaryWashMixNoInstrumentErrors,validSecondaryWashMixInstrumentTest,invalidSecondaryWashMixTipOptions,invalidSecondaryWashMixInstrumentOptions,invalidSecondaryWashErrors,invalidSecondaryWashOptions,validSecondaryWashTest,secondaryWashAspirationPipettingMismatchErrors,secondaryWashAspirationPipettingMismatchOptions,secondaryWashAspirationPipettingMismatchTests,

		unresolvedTertiaryWashMixOptions,invalidTertiaryWashMixTipTypeErrors,invalidTertiaryWashMixTipTypeOptions,validTertiaryWashMixTipTypeTest,tertiaryWashMixNoTipErrors,validTertiaryWashMixTipTest,tertiaryWashMixNoInstrumentErrors,validTertiaryWashMixInstrumentTest,invalidTertiaryWashMixTipOptions,	invalidTertiaryWashMixInstrumentOptions,invalidTertiaryWashErrors,invalidTertiaryWashOptions,validTertiaryWashTest,tertiaryWashAspirationPipettingMismatchErrors,tertiaryWashAspirationPipettingMismatchOptions,tertiaryWashAspirationPipettingMismatchTests,

		unresolvedQuaternaryWashMixOptions,invalidQuaternaryWashMixTipTypeErrors,invalidQuaternaryWashMixTipTypeOptions,validQuaternaryWashMixTipTypeTest,
		quaternaryWashMixNoTipErrors,validQuaternaryWashMixTipTest,quaternaryWashMixNoInstrumentErrors,validQuaternaryWashMixInstrumentTest,invalidQuaternaryWashMixTipOptions,invalidQuaternaryWashMixInstrumentOptions,invalidQuaternaryWashErrors,invalidQuaternaryWashOptions,validQuaternaryWashTest,quaternaryWashAspirationPipettingMismatchErrors,quaternaryWashAspirationPipettingMismatchOptions,quaternaryWashAspirationPipettingMismatchTests,

		unresolvedQuinaryWashMixOptions,invalidQuinaryWashMixTipTypeErrors,invalidQuinaryWashMixTipTypeOptions,validQuinaryWashMixTipTypeTest,quinaryWashMixNoTipErrors,validQuinaryWashMixTipTest,quinaryWashMixNoInstrumentErrors,validQuinaryWashMixInstrumentTest,invalidQuinaryWashMixTipOptions,invalidQuinaryWashMixInstrumentOptions,invalidQuinaryWashErrors,invalidQuinaryWashOptions,validQuinaryWashTest,quinaryWashAspirationPipettingMismatchErrors,quinaryWashAspirationPipettingMismatchOptions,quinaryWashAspirationPipettingMismatchTests,

		unresolvedSenaryWashMixOptions,invalidSenaryWashMixTipTypeErrors,invalidSenaryWashMixTipTypeOptions,validSenaryWashMixTipTypeTest,senaryWashMixNoTipErrors,validSenaryWashMixTipTest,senaryWashMixNoInstrumentErrors,validSenaryWashMixInstrumentTest,invalidSenaryWashMixTipOptions,invalidSenaryWashMixInstrumentOptions,invalidSenaryWashErrors,invalidSenaryWashOptions,validSenaryWashTest,senaryWashAspirationPipettingMismatchErrors,senaryWashAspirationPipettingMismatchOptions,senaryWashAspirationPipettingMismatchTests,

		unresolvedSeptenaryWashMixOptions,invalidSeptenaryWashMixTipTypeErrors,invalidSeptenaryWashMixTipTypeOptions,validSeptenaryWashMixTipTypeTest,septenaryWashMixNoTipErrors,validSeptenaryWashMixTipTest,septenaryWashMixNoInstrumentErrors,validSeptenaryWashMixInstrumentTest,invalidSeptenaryWashMixTipOptions,invalidSeptenaryWashMixInstrumentOptions,invalidSeptenaryWashErrors,invalidSeptenaryWashOptions,validSeptenaryWashTest,septenaryWashAspirationPipettingMismatchErrors,septenaryWashAspirationPipettingMismatchOptions,septenaryWashAspirationPipettingMismatchTests,

		unresolvedElutionMixOptions,invalidElutionMixTipTypeErrors,invalidElutionMixTipTypeOptions,validElutionMixTipTypeTest,elutionMixNoTipErrors,
		validElutionMixTipTest,elutionMixNoInstrumentErrors,validElutionMixInstrumentTest,invalidElutionMixTipOptions,invalidElutionMixInstrumentOptions,elutionAspirationPipettingMismatchErrors,elutionAspirationPipettingMismatchOptions,elutionAspirationPipettingMismatchTests,

		(* Resolve final options *)
		optionsAllSameQ,maxOptionRequestedQ,parallelMaxOptionTest,
		targetContainers,resolvedAliquotOptions,unflattenedResolvedAliquotOptions,aliquotTests,
		resolvedPostProcessingOptions,
		resolvedEmail,

		invalidInputs,invalidOptions,

		resolvedOptions,allTests,resultRule,testsRule
	},

	(*---Set up the user-specified options and cache---*)

	(*Determine the requested return value from the function*)
	outputSpecification=OptionValue[Output];
	output=ToList[outputSpecification];

	(*Determine if we should keep a running list of tests*)
	gatherTests=MemberQ[output,Tests];
	messages=!gatherTests;

	(*Determine if we are in Engine or not, in Engine we silence warnings*)
	notInEngine=!MatchQ[$ECLApplication,Engine];

	(*Fetch our options cache from the parent function*)
	inheritedCache=Lookup[ToList[myResolutionOptions],Cache,{}];

	simulation=Lookup[ToList[myResolutionOptions],Simulation];

	(*Split up myOptions into samplePrepOptions and mbsOptions*)
	{samplePrepOptions,mbsOptions}=splitPrepOptions[myOptions];

	(* Flatten the samples and options for easier use when resolving *)
	(**)
	flatSamples = Flatten[myNestedSamples];
	optionDefinitions=OptionDefinition[ExperimentMagneticBeadSeparation];
	flatMBSOptions=Function[{option},
		Module[{optionSymbol,optionValue,optionDefinition,singletonPattern,flattenedOptionValue},
			(* Get the option name and value. *)

			optionSymbol=option[[1]];
			optionValue=option[[2]];

			(* Get the definition of our option. *)
			optionDefinition=FirstCase[optionDefinitions,KeyValuePattern["OptionSymbol"->optionSymbol]];

			(* Get the singleton pattern of our option. *)
			singletonPattern=Lookup[optionDefinition,"SingletonPattern",Null];

			(* If our option is pooled, we have to flatten it. *)
			If[Lookup[optionDefinition,"NestedIndexMatching",False],
				(* Our option is pooled. If an element of our list doesn't match the singleton, then it must be a pool. Flatten it. *)
				flattenedOptionValue=(
					If[!MatchQ[#,ReleaseHold[singletonPattern]],
						Sequence@@#,
						#
					]
				&)/@optionValue;

				(* There are possible ambiguities between pooled and singleton options. If the length of our option value still doesn't match the length of our inputs, flatten again. *)
				If[Length[flattenedOptionValue]!=Length[flatSamples],
					optionSymbol->Flatten[flattenedOptionValue],
					optionSymbol->flattenedOptionValue
				],
				(* Our option is not pooled. Nothing to do. *)
				option
			]
		]
	]/@mbsOptions;
	flatSamplePrepOptions=Function[{option},
		Module[{optionSymbol,optionValue,optionDefinition,singletonPattern,flattenedOptionValue},
			(* Get the option name and value. *)
			optionSymbol=option[[1]];
			optionValue=option[[2]];

			(* Get the definition of our option. *)
			optionDefinition=FirstCase[optionDefinitions,KeyValuePattern["OptionSymbol"->optionSymbol]];

			(* Get the singleton pattern of our option. *)
			singletonPattern=Lookup[optionDefinition,"SingletonPattern",Null];

			(* If our option is pooled, we have to flatten it. *)
			If[Lookup[optionDefinition,"NestedIndexMatching",False],
				(* Our option is pooled. If an element of our list doesn't match the singleton, then it must be a pool. Flatten it. *)
				flattenedOptionValue=(
					If[!MatchQ[#,ReleaseHold[singletonPattern]],
						Sequence@@#,
						#
					]
							&)/@optionValue;

				(* There are possible ambiguities between pooled and singleton options. If the length of our option value still doesn't match the length of our inputs, flatten again. *)
				If[Length[flattenedOptionValue]!=Length[flatSamples],
					optionSymbol->Flatten[flattenedOptionValue],
					optionSymbol->flattenedOptionValue
				],
				(* Our option is not pooled. Nothing to do. *)
				option
			]
		]
	]/@samplePrepOptions;

	(*---Resolve Preparation---*)
	(* Resolve our preparation option. *)
	(* we pass flatMBSOptions here because we need to check for specified sample prep options *)
	preparationResult=Check[
		{allowedPreparation,preparationTest}=If[gatherTests,
			resolveExperimentMagneticBeadSeparationMethod[flatSamples,Normal[Merge[{ReplaceRule[flatMBSOptions, {Cache -> inheritedCache, Simulation -> simulation, Output -> {Result, Tests}}], flatSamplePrepOptions},First],Association]],
			{
				resolveExperimentMagneticBeadSeparationMethod[flatSamples,Normal[Merge[{ReplaceRule[flatMBSOptions, {Cache -> inheritedCache, Simulation -> simulation, Output -> Result}], flatSamplePrepOptions},First],Association]],
				{}
			}
		],
		$Failed
	];

  (* If we have more than one allowable preparation method, just choose the first one. Our function returns multiple *)
  (* options so that OptimizeUnitOperations can perform primitive grouping. *)
  resolvedPreparation=If[MatchQ[allowedPreparation,_List],
    First[allowedPreparation],
    allowedPreparation
  ];

	(*Resolve sample prep options*)
	{{simulatedSamples,resolvedSamplePrepOptions,simulatedCache},samplePrepTests}=If[gatherTests,
		resolvePooledSamplePrepOptions[ExperimentMagneticBeadSeparation,myNestedSamples,samplePrepOptions,Cache->inheritedCache,Output->{Result,Tests}],
		{resolvePooledSamplePrepOptions[ExperimentMagneticBeadSeparation, myNestedSamples, samplePrepOptions, Cache -> inheritedCache, Output -> Result],{}}
	];

	(*Convert list of rules to Association so we can Lookup, Append, Join as usual*)
	mbsOptionsAssociationFlat=Association[flatMBSOptions];

	(*Pull out the options that don't have precision*)
	{selectionStrategy,separationMode,numberOfReplicates,magneticBeads,magneticBeadCollectionStorageConditions,name,parentProtocol,sampleLabels,sampleContainerLabels,sampleOutLabels,containerOutLabels}=Lookup[
		mbsOptionsAssociationFlat,
		{SelectionStrategy,SeparationMode,NumberOfReplicates,MagneticBeads,MagneticBeadCollectionStorageCondition,Name,ParentProtocol,SampleLabel,SampleContainerLabel,SampleOutLabel,ContainerOutLabel}
	];

	(* Pull out options that are resolved after the map thread *)

	{
		preWashDestinationWells,preWashCollectionContainerLabels,
		equilibrationDestinationWells,equilibrationCollectionContainerLabels,
		loadingDestinationWells,loadingCollectionContainerLabels,
		washDestinationWells,washCollectionContainerLabels,
		secondaryWashDestinationWells,secondaryWashCollectionContainerLabels,
		tertiaryWashDestinationWells,tertiaryWashCollectionContainerLabels,
		quaternaryWashDestinationWells,quaternaryWashCollectionContainerLabels,
		quinaryWashDestinationWells,quinaryWashCollectionContainerLabels,
		senaryWashDestinationWells,senaryWashCollectionContainerLabels,
		septenaryWashDestinationWells,septenaryWashCollectionContainerLabels,
		elutionDestinationWells,elutionCollectionContainerLabels
	}=Lookup[
		mbsOptions,
		{
			PreWashDestinationWell,PreWashCollectionContainerLabel,
			EquilibrationDestinationWell,EquilibrationCollectionContainerLabel,
			LoadingDestinationWell,LoadingCollectionContainerLabel,
			WashDestinationWell,WashCollectionContainerLabel,
			SecondaryWashDestinationWell,SecondaryWashCollectionContainerLabel,
			TertiaryWashDestinationWell,TertiaryWashCollectionContainerLabel,
			QuaternaryWashDestinationWell,QuaternaryWashCollectionContainerLabel,
			QuinaryWashDestinationWell,QuinaryWashCollectionContainerLabel,
			SenaryWashDestinationWell,SenaryWashCollectionContainerLabel,
			SeptenaryWashDestinationWell,SeptenaryWashCollectionContainerLabel,
			ElutionDestinationWell,ElutionCollectionContainerLabel
		}
	];


	(*--Download the information we need for the option resolver from the cache--*)

	(*Flatten simulatedSamples*)
	flatSimulatedSamples=Flatten[simulatedSamples];

	(*Pull out the options that may have models/objects whose information we need to download*)
	{
		targets,
		analyteAffinityLabels,
		magneticBeadAffinityLabels,
		magnetizationRacks,
		preWashCollectionContainers,
		equilibrationCollectionContainers,
		loadingCollectionContainers,
		washCollectionContainers,
		secondaryWashCollectionContainers,
		tertiaryWashCollectionContainers,
		quaternaryWashCollectionContainers,
		quinaryWashCollectionContainers,
		senaryWashCollectionContainers,
		septenaryWashCollectionContainers,
		elutionCollectionContainers,
		preWashCollectionStorageConditions,
		equilibrationCollectionStorageConditions,
		loadingCollectionStorageConditions,
		washCollectionStorageConditions,
		secondaryWashCollectionStorageConditions,
		tertiaryWashCollectionStorageConditions,
		quaternaryWashCollectionStorageConditions,
		quinaryWashCollectionStorageConditions,
		senaryWashCollectionStorageConditions,
		septenaryWashCollectionStorageConditions,
		elutionCollectionStorageConditions
	}=Lookup[
		mbsOptionsAssociationFlat,
		{
			Target,
			AnalyteAffinityLabel,
			MagneticBeadAffinityLabel,
			MagnetizationRack,
			PreWashCollectionContainer,
			EquilibrationCollectionContainer,
			LoadingCollectionContainer,
			WashCollectionContainer,
			SecondaryWashCollectionContainer,
			TertiaryWashCollectionContainer,
			QuaternaryWashCollectionContainer,
			QuinaryWashCollectionContainer,
			SenaryWashCollectionContainer,
			SeptenaryWashCollectionContainer,
			ElutionCollectionContainer,
			PreWashCollectionStorageCondition,
			EquilibrationCollectionStorageCondition,
			LoadingCollectionStorageCondition,
			WashCollectionStorageCondition,
			SecondaryWashCollectionStorageCondition,
			TertiaryWashCollectionStorageCondition,
			QuaternaryWashCollectionStorageCondition,
			QuinaryWashCollectionStorageCondition,
			SenaryWashCollectionStorageCondition,
			SeptenaryWashCollectionStorageCondition,
			ElutionCollectionStorageCondition
		}
	];

	{
		preWashCollectionContainerIndices,
		equilibrationCollectionContainerIndices,
		loadingCollectionContainerIndices,
		washCollectionContainerIndices,
		secondaryWashCollectionContainerIndices,
		tertiaryWashCollectionContainerIndices,
		quaternaryWashCollectionContainerIndices,
		quinaryWashCollectionContainerIndices,
		senaryWashCollectionContainerIndices,
		septenaryWashCollectionContainerIndices,
		elutionCollectionContainerIndices
	}=Lookup[
		mbsOptionsAssociationFlat,
		{
			PreWashCollectionContainerIndex,
			EquilibrationCollectionContainerIndex,
			LoadingCollectionContainerIndex,
			WashCollectionContainerIndex,
			SecondaryWashCollectionContainerIndex,
			TertiaryWashCollectionContainerIndex,
			QuaternaryWashCollectionContainerIndex,
			QuinaryWashCollectionContainerIndex,
			SenaryWashCollectionContainerIndex,
			SeptenaryWashCollectionContainerIndex,
			ElutionCollectionContainerIndex
		}
	];


	(* get model/object of collection containers to download *)
	allCollectionContainersNoLink=Download[Cases[Flatten[{preWashCollectionContainers,equilibrationCollectionContainers,loadingCollectionContainers,washCollectionContainers,secondaryWashCollectionContainers,tertiaryWashCollectionContainers,quaternaryWashCollectionContainers,quinaryWashCollectionContainers,senaryWashCollectionContainers,septenaryWashCollectionContainers,elutionCollectionContainers}],ObjectP[]],Object];
	collectionContainerObjects=Cases[allCollectionContainersNoLink,ObjectReferenceP[Object[Container]]];
	collectionContainerModels=Cases[allCollectionContainersNoLink,ObjectReferenceP[Model[Container]]];

	(* get model/object of magnetization rack to download *)
	magnetizationRacksNoLink=Download[Cases[magnetizationRacks,ObjectP[]],Object];
	magnetizationRackObjects=Cases[magnetizationRacksNoLink,ObjectReferenceP[Object]];
	magnetizationRackModels=Cases[magnetizationRacksNoLink,ObjectReferenceP[Model]];

	(*Get all the magnetic bead identity models*)
	allMagneticBeadIdentityModels=Search[Model[Resin],Magnetic==True];

	(*Pull out user specified storage condition objects Model[StorageCondition]*)
	storageConditionsNoLink=Download[Cases[Flatten[{preWashCollectionStorageConditions,equilibrationCollectionStorageConditions,loadingCollectionStorageConditions, washCollectionStorageConditions,secondaryWashCollectionStorageConditions,tertiaryWashCollectionStorageConditions,quaternaryWashCollectionStorageConditions,quinaryWashCollectionStorageConditions,senaryWashCollectionStorageConditions,septenaryWashCollectionStorageConditions,elutionCollectionStorageConditions}],ObjectP[]],Object];
	storageConditionModels=Cases[storageConditionsNoLink,ObjectP[Model[StorageCondition]]];

	(*Get all the packets and fields we need to download*)
	sampleDownloadPacket=Packet[SamplePreparationCacheFields[Object[Sample],Format->Sequence],Container];
	identityModelDownloadPacket=Packet[Targets,AffinityLabels,MolecularWeight,DefaultSampleModel,Composition];
	containerDownloadPacket=Packet[Model[{LiquidHandlerPrefix,Contents,Magnetized,SamplePreparationCacheFields[Model[Container],Format->Sequence]}]];
	containerModelDownloadPacket=Packet[LiquidHandlerPrefix,Footprint,Magnetized,Positions,SamplePreparationCacheFields[Model[Container],Format->Sequence]];

	(*Download the packets we need from the cache*)
	{
		simulatedSamplePackets,
		collectionContainerPackets,
		collectionContainerModelPackets,
		allMagneticBeadIdentityModelPackets,
		rawMagnetizationRackPackets,
		rawMagnetizationRackModelPackets,
		storageConditionPackets
	}=Quiet[
		Download[
			{
				flatSimulatedSamples,
				collectionContainerObjects,
				collectionContainerModels,
				allMagneticBeadIdentityModels,
				magnetizationRackObjects,
				magnetizationRackModels,
				storageConditionModels
			},
			{
				{
					sampleDownloadPacket
				},
				{
					containerDownloadPacket
				},
				{
					containerModelDownloadPacket
				},
				{
					identityModelDownloadPacket
				},
				{
					Packet[Model,Name],
					containerDownloadPacket
				},
				{
					containerModelDownloadPacket
				},
				{
					Packet[StorageCondition]
				}
			},
			Cache->simulatedCache,
			Simulation->simulation
		],
		{Download::FieldDoesntExist}
	];

	(* Flatten the sample packets *)
	flatSimulatedSamplePackets=Flatten[simulatedSamplePackets];

	(* combine the rest of the cache packets *)
	flattenedCachePackets = FlattenCachePackets[
		{
			simulatedSamplePackets,
			collectionContainerPackets,
			collectionContainerModelPackets,
			Cases[Flatten@rawMagnetizationRackPackets,PacketP[Object]],
			Cases[Flatten[{rawMagnetizationRackPackets,rawMagnetizationRackModelPackets}],PacketP[Model]],
			storageConditionPackets
    }
	];

	(* Create combined fast assoc *)
	combinedFastAssoc=makeFastAssocFromCache[FlattenCachePackets[{flattenedCachePackets, inheritedCache, simulatedCache}]];

	(*---Input validation checks---*)

	(*--Discarded input check--*)

	(*Get the sample packets from flatSimulatedSamples that are discarded*)
	discardedSamplePackets=Cases[flatSimulatedSamplePackets,KeyValuePattern[Status->Discarded]];

	(*Set discardedInvalidInputs to the input objects whose statuses are Discarded*)
	discardedInvalidInputs=If[MatchQ[discardedSamplePackets,{}],
		{},
		Lookup[discardedSamplePackets,Object]
	];

	(*If there are invalid inputs and we are throwing messages (not gathering tests), throw an error message and keep track of the invalid inputs*)
	If[Length[discardedInvalidInputs]>0&&messages,
		Message[Error::DiscardedSamples,ObjectToString[discardedInvalidInputs,Cache->simulatedCache]]
	];

	(*If we are gathering tests, create a passing and/or failing test with the appropriate result*)
	discardedTest=If[gatherTests,
		Module[{failingTest,passingTest},
			failingTest=If[Length[discardedInvalidInputs]==0,
				Nothing,
				Test["Our input samples "<>ObjectToString[discardedInvalidInputs,Cache->simulatedCache]<>" are not discarded:",True,False]
			];
			passingTest=If[Length[discardedInvalidInputs]==Length[flatSimulatedSamples],
				Nothing,
				Test["Our input samples "<>ObjectToString[Complement[flatSimulatedSamples,discardedInvalidInputs],Cache->simulatedCache]<>" are not discarded:",True,True]
			];
			{failingTest,passingTest}
		],
		Nothing
	];

	(*--Solid input check--*)(*-=-ChartingType:Input validation-=-*)(*-=-???-=-*)

	(*Get the sample packets from flatSimulatedSamples that are solid*)
	solidSamplePackets=Cases[flatSimulatedSamplePackets,KeyValuePattern[State->Solid]];

	(*Set solidInvalidInputs to the input objects whose states are Solid*)
	solidInvalidInputs=If[MatchQ[solidSamplePackets,{}],
		{},
		Lookup[solidSamplePackets,Object]
	];

	(*If there are invalid inputs and we are throwing messages (not gathering tests), throw an error message and keep track of the invalid inputs*)
	If[Length[solidSamplePackets]>0&&messages,
		Message[Error::SolidSamplesUnsupported,ObjectToString[solidInvalidInputs,Cache->simulatedCache],ExperimentMagneticBeadSeparation]
	];

	(*If we are gathering tests, create a passing and/or failing test with the appropriate result*)
	solidTest=If[gatherTests,
		Module[{failingTest,passingTest},
			failingTest=If[Length[solidInvalidInputs]==0,
				Nothing,
				Test["Our input samples "<>ObjectToString[solidInvalidInputs,Cache->simulatedCache]<>" are not solid:",True,False]
			];
			passingTest=If[Length[solidInvalidInputs]==Length[flatSimulatedSamples],
				Nothing,
				Test["Our input samples "<>ObjectToString[Complement[flatSimulatedSamples,solidInvalidInputs],Cache->simulatedCache]<>" are not solid:",True,True]
			];
			{failingTest,passingTest}
		],
		Nothing
	];

	(*---Conflicting options checks I---*)

	(*--Check that Name is valid--*)

	(*If the specified Name is a string, check if this name exists in the Database already*)
	validNameQ=If[MatchQ[name,_String],
		!DatabaseMemberQ[Object[Protocol,MagneticBeadSeparation,name]],
		True
	];

	(*If validNameQ is False and we are throwing messages, throw an error message*)
	invalidNameOptions=If[!validNameQ&&messages,
		(
			Message[Error::DuplicateName,"MagneticBeadSeparation protocol"];
			{Name}
		),
		{}
	];

	(*If we are gathering tests, create a test*)
	validNameTest=If[gatherTests&&MatchQ[name,_String],
		Test["If specified, Name is not already a MagneticBeadSeparation protocol object name:",
			validNameQ,
			True
		],
		Nothing
	];

	(*--Check that affinity labels aren't in conflict with SeparationMode--*)

	(*If SeparationMode is not Affinity, AnalyteAffinityLabel and MagneticBeadAffinityLabel are not specified*)
	separationModeMatchQ=If[!MatchQ[separationMode,Affinity],
		MatchQ[
			Cases[Flatten[{analyteAffinityLabels,magneticBeadAffinityLabels}],ObjectP[]],
			{}
		],
		True
	];

	(*If separationModeMatchQ is False and we are throwing messages, throw an error message*)
	separationModeMismatchOptions=If[!separationModeMatchQ&&messages,
		(
			Message[Error::SeparationModeMismatch];
			{SeparationMode,AnalyteAffinityLabel,MagneticBeadAffinityLabel}
		),
		{}
	];

	(*If we are gathering tests, create a test*)
	separationModeMatchTest=If[gatherTests,
		Test["If SeparationMode is not Affinity, AnalyteAffinityLabel and MagneticBeadAffinityLabel are not specified:",
			separationModeMatchQ,
			True
		],
		Nothing
	];

	(*---Option precision checks---*)

	(*Round the options that have precision*)
	{roundedMBSOptions,precisionTests}=If[gatherTests,
		RoundOptionPrecision[
			mbsOptionsAssociationFlat,
			{
				(*General*)
				Volume,MagneticBeadVolume,
				(*PreWash*)
				PreWashBufferVolume,PreWashMixTime,PreWashMixTemperature,PreWashMixRate,PreWashMixVolume,
				PreWashMagnetizationTime,PreWashAspirationVolume,PreWashAirDryTime,
				(*Equilibration*)
				EquilibrationBufferVolume,EquilibrationMixTime,EquilibrationMixTemperature,
				EquilibrationMixRate,EquilibrationMixVolume,EquilibrationMagnetizationTime,EquilibrationAspirationVolume,EquilibrationAirDryTime,
				(*Loading*)
				LoadingMixTime,LoadingMixTemperature,LoadingMixRate,LoadingMixVolume,
				LoadingMagnetizationTime,LoadingAspirationVolume,LoadingAirDryTime,
				(*Wash*)
				WashBufferVolume,WashMixTime,WashMixTemperature,WashMixRate,WashMixVolume,WashMagnetizationTime,
				WashAspirationVolume,WashAirDryTime,
				(*SecondaryWash*)
				SecondaryWashBufferVolume,SecondaryWashMixTime,SecondaryWashMixTemperature,SecondaryWashMixRate,SecondaryWashMixVolume,SecondaryWashMagnetizationTime,
				SecondaryWashAspirationVolume,SecondaryWashAirDryTime,
				(*TertiaryWash*)
				TertiaryWashBufferVolume,TertiaryWashMixTime,TertiaryWashMixTemperature,TertiaryWashMixRate,TertiaryWashMixVolume,TertiaryWashMagnetizationTime,
				TertiaryWashAspirationVolume,TertiaryWashAirDryTime,
				(*QuaternaryWash*)
				QuaternaryWashBufferVolume,QuaternaryWashMixTime,QuaternaryWashMixTemperature,QuaternaryWashMixRate,QuaternaryWashMixVolume,QuaternaryWashMagnetizationTime,
				QuaternaryWashAspirationVolume,QuaternaryWashAirDryTime,
				(*QuinaryWash*)
				QuinaryWashBufferVolume,QuinaryWashMixTime,QuinaryWashMixTemperature,QuinaryWashMixRate,QuinaryWashMixVolume,QuinaryWashMagnetizationTime,
				QuinaryWashAspirationVolume,QuinaryWashAirDryTime,
				(*SenaryWash*)
				SenaryWashBufferVolume,SenaryWashMixTime,SenaryWashMixTemperature,SenaryWashMixRate,SenaryWashMixVolume,SenaryWashMagnetizationTime,
				SenaryWashAspirationVolume,SenaryWashAirDryTime,
				(*SeptenaryWash*)
				SeptenaryWashBufferVolume,SeptenaryWashMixTime,SeptenaryWashMixTemperature,SeptenaryWashMixRate,SeptenaryWashMixVolume,SeptenaryWashMagnetizationTime,
				SeptenaryWashAspirationVolume,SeptenaryWashAirDryTime,
				(*Elution*)
				ElutionBufferVolume,ElutionMixTime,ElutionMixTemperature,ElutionMixRate,ElutionMixVolume,
				ElutionMagnetizationTime,ElutionAspirationVolume
			},
			{
				(*Volume,MagneticBeadVolume*)
				10^-1 Microliter,10^-1 Microliter,

				(*PreWashBufferVolume,PreWashMixTime,PreWashMixTemperature,PreWashMixRate,PreWashMixVolume,PreWashMagnetizationTime,PreWashAspirationVolume,PreWashAirDryTime*)
				10^-1 Microliter,1 Second,1 Celsius,1 RPM,10^-1 Microliter,1 Second,10^-1 Microliter,1 Second,

				(*EquilibrationBufferVolume,EquilibrationMixTime,EquilibrationMixTemperature,EquilibrationMixRate,EquilibrationMixVolume,EquilibrationMagnetizationTime,EquilibrationAspirationVolume,EquilibrationAirDryTime*)
				10^-1 Microliter,1 Second,1 Celsius,1 RPM,10^-1 Microliter,1 Second,10^-1 Microliter,1 Second,

				(*LoadingMixTime,LoadingMixTemperature,LoadingMixRate,LoadingMixVolume,LoadingMagnetizationTime,LoadingAspirationVolume,LoadingAirDryTime*)
				1 Second,1 Celsius,1 RPM,10^-1 Microliter,1 Second,10^-1 Microliter,1 Second,

				(*WashBufferVolume,WashMixTime,WashMixTemperature,WashMixRate,WashMixVolume,WashMagnetizationTime,WashAspirationVolume,WashAirDryTime*)
				10^-1 Microliter,1 Second,1 Celsius,1 RPM,10^-1 Microliter,1 Second,10^-1 Microliter,1 Second,

				(*SecondaryWashBufferVolume,SecondaryWashMixTime,SecondaryWashMixTemperature,SecondaryWashMixRate,SecondaryWashMixVolume,SecondaryWashMagnetizationTime,SecondaryWashAspirationVolume,SecondaryWashAirDryTime*)
				10^-1 Microliter,1 Second,1 Celsius,1 RPM,10^-1 Microliter,1 Second,10^-1 Microliter,1 Second,

				(*TertiaryWashBufferVolume,TertiaryWashMixTime,TertiaryWashMixTemperature,TertiaryWashMixRate,TertiaryWashMixVolume,TertiaryWashMagnetizationTime,TertiaryWashAspirationVolume,TertiaryWashAirDryTime*)
				10^-1 Microliter,1 Second,1 Celsius,1 RPM,10^-1 Microliter,1 Second,10^-1 Microliter,1 Second,

				(*QuaternaryWashBufferVolume,QuaternaryWashMixTime,QuaternaryWashMixTemperature,QuaternaryWashMixRate,QuaternaryWashMixVolume,QuaternaryWashMagnetizationTime,QuaternaryWashAspirationVolume,QuaternaryWashAirDryTime*)
				10^-1 Microliter,1 Second,1 Celsius,1 RPM,10^-1 Microliter,1 Second,10^-1 Microliter,1 Second,

				(*QuinaryWashBufferVolume,QuinaryWashMixTime,QuinaryWashMixTemperature,QuinaryWashMixRate,QuinaryWashMixVolume,QuinaryWashMagnetizationTime,QuinaryWashAspirationVolume,QuinaryWashAirDryTime*)
				10^-1 Microliter,1 Second,1 Celsius,1 RPM,10^-1 Microliter,1 Second,10^-1 Microliter,1 Second,

				(*SenaryWashBufferVolume,SenaryWashMixTime,SenaryWashMixTemperature,SenaryWashMixRate,SenaryWashMixVolume,SenaryWashMagnetizationTime,SenaryWashAspirationVolume,SenaryWashAirDryTime*)
				10^-1 Microliter,1 Second,1 Celsius,1 RPM,10^-1 Microliter,1 Second,10^-1 Microliter,1 Second,

				(*SeptenaryWashBufferVolume,SeptenaryWashMixTime,SeptenaryWashMixTemperature,SeptenaryWashMixRate,SeptenaryWashMixVolume,SeptenaryWashMagnetizationTime,SeptenaryWashAspirationVolume,SeptenaryWashAirDryTime*)
				10^-1 Microliter,1 Second,1 Celsius,1 RPM,10^-1 Microliter,1 Second,10^-1 Microliter,1 Second,

				(*ElutionBufferVolume,ElutionMixTime,ElutionMixTemperature,ElutionMixRate,ElutionMixVolume,ElutionMagnetizationTime,ElutionAspirationVolume*)
				10^-1 Microliter,1 Second,1 Celsius,1 RPM,10^-1 Microliter,1 Second,10^-1 Microliter
			},
			AvoidZero->{
				(*Volume,MagneticBeadVolume*)
				False, False,

				(*PreWashBufferVolume,PreWashMixTime,PreWashMixTemperature,PreWashMixRate,PreWashMixVolume,PreWashMagnetizationTime,PreWashAspirationVolume,PreWashAirDryTime*)
				False, False, False, False, False, False, False, False,

				(*EquilibrationBufferVolume,EquilibrationMixTime,EquilibrationMixTemperature,EquilibrationMixRate,EquilibrationMixVolume,EquilibrationMagnetizationTime,EquilibrationAspirationVolume,EquilibrationAirDryTime*)
				False, False, False, False, False, False, False, False,

				(*LoadingMixTime,LoadingMixTemperature,LoadingMixRate,LoadingMixVolume,LoadingMagnetizationTime,LoadingAspirationVolume,LoadingAirDryTime*)
				False, False, False, False, False, False, False,

				(*WashBufferVolume,WashMixTime,WashMixTemperature,WashMixRate,WashMixVolume,WashMagnetizationTime,WashAspirationVolume,WashAirDryTime*)
				False, False, False, False, False, False, False, False,

				(*SecondaryWashBufferVolume,SecondaryWashMixTime,SecondaryWashMixTemperature,SecondaryWashMixRate,SecondaryWashMixVolume,SecondaryWashMagnetizationTime,SecondaryWashAspirationVolume,SecondaryWashAirDryTime*)
				False, False, False, False, False, False, False, False,

				(*TertiaryWashBufferVolume,TertiaryWashMixTime,TertiaryWashMixTemperature,TertiaryWashMixRate,TertiaryWashMixVolume,TertiaryWashMagnetizationTime,TertiaryWashAspirationVolume,TertiaryWashAirDryTime*)
				False, False, False, False, False, False, False, False,

				(*QuaternaryWashBufferVolume,QuaternaryWashMixTime,QuaternaryWashMixTemperature,QuaternaryWashMixRate,QuaternaryWashMixVolume,QuaternaryWashMagnetizationTime,QuaternaryWashAspirationVolume,QuaternaryWashAirDryTime*)
				False, False, False, False, False, False, False, False,

				(*QuinaryWashBufferVolume,QuinaryWashMixTime,QuinaryWashMixTemperature,QuinaryWashMixRate,QuinaryWashMixVolume,QuinaryWashMagnetizationTime,QuinaryWashAspirationVolume,QuinaryWashAirDryTime*)
				False, False, False, False, False, False, False, False,

				(*SenaryWashBufferVolume,SenaryWashMixTime,SenaryWashMixTemperature,SenaryWashMixRate,SenaryWashMixVolume,SenaryWashMagnetizationTime,SenaryWashAspirationVolume,SenaryWashAirDryTime*)
				False, False, False, False, False, False, False, False,

				(*SeptenaryWashBufferVolume,SeptenaryWashMixTime,SeptenaryWashMixTemperature,SeptenaryWashMixRate,SeptenaryWashMixVolume,SeptenaryWashMagnetizationTime,SeptenaryWashAspirationVolume,SeptenaryWashAirDryTime*)
				False, False, False, False, False, False, False, False,

				(*ElutionBufferVolume,ElutionMixTime,ElutionMixTemperature,ElutionMixRate,ElutionMixVolume,ElutionMagnetizationTime,ElutionAspirationVolume*)
				False, False, False, False, False, False, False},
			Output->{Result,Tests}
		],
		{
			RoundOptionPrecision[
				mbsOptionsAssociationFlat,
				{
					(*General*)
					Volume,MagneticBeadVolume,
					(*PreWash*)
					PreWashBufferVolume,PreWashMixTime,PreWashMixTemperature,PreWashMixRate,PreWashMixVolume,
					PreWashMagnetizationTime,PreWashAspirationVolume,PreWashAirDryTime,
					(*Equilibration*)
					EquilibrationBufferVolume,EquilibrationMixTime,EquilibrationMixTemperature,
					EquilibrationMixRate,EquilibrationMixVolume,EquilibrationMagnetizationTime,EquilibrationAspirationVolume,EquilibrationAirDryTime,
					(*Loading*)
					LoadingMixTime,LoadingMixTemperature,LoadingMixRate,LoadingMixVolume,
					LoadingMagnetizationTime,LoadingAspirationVolume,LoadingAirDryTime,
					(*Wash*)
					WashBufferVolume,WashMixTime,WashMixTemperature,WashMixRate,WashMixVolume,WashMagnetizationTime,
					WashAspirationVolume,WashAirDryTime,
					(*SecondaryWash*)
					SecondaryWashBufferVolume,SecondaryWashMixTime,SecondaryWashMixTemperature,SecondaryWashMixRate,SecondaryWashMixVolume,SecondaryWashMagnetizationTime,
					SecondaryWashAspirationVolume,SecondaryWashAirDryTime,
					(*TertiaryWash*)
					TertiaryWashBufferVolume,TertiaryWashMixTime,TertiaryWashMixTemperature,TertiaryWashMixRate,TertiaryWashMixVolume,TertiaryWashMagnetizationTime,
					TertiaryWashAspirationVolume,TertiaryWashAirDryTime,
					(*QuaternaryWash*)
					QuaternaryWashBufferVolume,QuaternaryWashMixTime,QuaternaryWashMixTemperature,QuaternaryWashMixRate,QuaternaryWashMixVolume,QuaternaryWashMagnetizationTime,
					QuaternaryWashAspirationVolume,QuaternaryWashAirDryTime,
					(*QuinaryWash*)
					QuinaryWashBufferVolume,QuinaryWashMixTime,QuinaryWashMixTemperature,QuinaryWashMixRate,QuinaryWashMixVolume,QuinaryWashMagnetizationTime,
					QuinaryWashAspirationVolume,QuinaryWashAirDryTime,
					(*SenaryWash*)
					SenaryWashBufferVolume,SenaryWashMixTime,SenaryWashMixTemperature,SenaryWashMixRate,SenaryWashMixVolume,SenaryWashMagnetizationTime,
					SenaryWashAspirationVolume,SenaryWashAirDryTime,
					(*SeptenaryWash*)
					SeptenaryWashBufferVolume,SeptenaryWashMixTime,SeptenaryWashMixTemperature,SeptenaryWashMixRate,SeptenaryWashMixVolume,SeptenaryWashMagnetizationTime,
					SeptenaryWashAspirationVolume,SeptenaryWashAirDryTime,
					(*Elution*)
					ElutionBufferVolume,ElutionMixTime,ElutionMixTemperature,ElutionMixRate,ElutionMixVolume,
					ElutionMagnetizationTime,ElutionAspirationVolume
				},
				{
					(*Volume,MagneticBeadVolume*)
					10^-1 Microliter,10^-1 Microliter,

					(*PreWashBufferVolume,PreWashMixTime,PreWashMixTemperature,PreWashMixRate,PreWashMixVolume,PreWashMagnetizationTime,PreWashAspirationVolume,PreWashAirDryTime*)
					10^-1 Microliter,1 Second,1 Celsius,1 RPM,10^-1 Microliter,1 Second,10^-1 Microliter,1 Second,

					(*EquilibrationBufferVolume,EquilibrationMixTime,EquilibrationMixTemperature,EquilibrationMixRate,EquilibrationMixVolume,EquilibrationMagnetizationTime,EquilibrationAspirationVolume,EquilibrationAirDryTime*)
					10^-1 Microliter,1 Second,1 Celsius,1 RPM,10^-1 Microliter,1 Second,10^-1 Microliter,1 Second,

					(*LoadingMixTime,LoadingMixTemperature,LoadingMixRate,LoadingMixVolume,LoadingMagnetizationTime,LoadingAspirationVolume,LoadingAirDryTime*)
					1 Second,1 Celsius,1 RPM,10^-1 Microliter,1 Second,10^-1 Microliter,1 Second,

					(*WashBufferVolume,WashMixTime,WashMixTemperature,WashMixRate,WashMixVolume,WashMagnetizationTime,WashAspirationVolume,WashAirDryTime*)
					10^-1 Microliter,1 Second,1 Celsius,1 RPM,10^-1 Microliter,1 Second,10^-1 Microliter,1 Second,

					(*SecondaryWashBufferVolume,SecondaryWashMixTime,SecondaryWashMixTemperature,SecondaryWashMixRate,SecondaryWashMixVolume,SecondaryWashMagnetizationTime,SecondaryWashAspirationVolume,SecondaryWashAirDryTime*)
					10^-1 Microliter,1 Second,1 Celsius,1 RPM,10^-1 Microliter,1 Second,10^-1 Microliter,1 Second,

					(*TertiaryWashBufferVolume,TertiaryWashMixTime,TertiaryWashMixTemperature,TertiaryWashMixRate,TertiaryWashMixVolume,TertiaryWashMagnetizationTime,TertiaryWashAspirationVolume,TertiaryWashAirDryTime*)
					10^-1 Microliter,1 Second,1 Celsius,1 RPM,10^-1 Microliter,1 Second,10^-1 Microliter,1 Second,

					(*QuaternaryWashBufferVolume,QuaternaryWashMixTime,QuaternaryWashMixTemperature,QuaternaryWashMixRate,QuaternaryWashMixVolume,QuaternaryWashMagnetizationTime,QuaternaryWashAspirationVolume,QuaternaryWashAirDryTime*)
					10^-1 Microliter,1 Second,1 Celsius,1 RPM,10^-1 Microliter,1 Second,10^-1 Microliter,1 Second,

					(*QuinaryWashBufferVolume,QuinaryWashMixTime,QuinaryWashMixTemperature,QuinaryWashMixRate,QuinaryWashMixVolume,QuinaryWashMagnetizationTime,QuinaryWashAspirationVolume,QuinaryWashAirDryTime*)
					10^-1 Microliter,1 Second,1 Celsius,1 RPM,10^-1 Microliter,1 Second,10^-1 Microliter,1 Second,

					(*SenaryWashBufferVolume,SenaryWashMixTime,SenaryWashMixTemperature,SenaryWashMixRate,SenaryWashMixVolume,SenaryWashMagnetizationTime,SenaryWashAspirationVolume,SenaryWashAirDryTime*)
					10^-1 Microliter,1 Second,1 Celsius,1 RPM,10^-1 Microliter,1 Second,10^-1 Microliter,1 Second,

					(*SeptenaryWashBufferVolume,SeptenaryWashMixTime,SeptenaryWashMixTemperature,SeptenaryWashMixRate,SeptenaryWashMixVolume,SeptenaryWashMagnetizationTime,SeptenaryWashAspirationVolume,SeptenaryWashAirDryTime*)
					10^-1 Microliter,1 Second,1 Celsius,1 RPM,10^-1 Microliter,1 Second,10^-1 Microliter,1 Second,

					(*ElutionBufferVolume,ElutionMixTime,ElutionMixTemperature,ElutionMixRate,ElutionMixVolume,ElutionMagnetizationTime,ElutionAspirationVolume*)
					10^-1 Microliter,1 Second,1 Celsius,1 RPM,10^-1 Microliter,1 Second,10^-1 Microliter
				},
				AvoidZero->{
					(*Volume,MagneticBeadVolume*)
					False, False,

					(*PreWashBufferVolume,PreWashMixTime,PreWashMixTemperature,PreWashMixRate,PreWashMixVolume,PreWashMagnetizationTime,PreWashAspirationVolume,PreWashAirDryTime*)
					False, False, False, False, False, False, False, False,

					(*EquilibrationBufferVolume,EquilibrationMixTime,EquilibrationMixTemperature,EquilibrationMixRate,EquilibrationMixVolume,EquilibrationMagnetizationTime,EquilibrationAspirationVolume,EquilibrationAirDryTime*)
					False, False, False, False, False, False, False, False,

					(*LoadingMixTime,LoadingMixTemperature,LoadingMixRate,LoadingMixVolume,LoadingMagnetizationTime,LoadingAspirationVolume,LoadingAirDryTime*)
					False, False, False, False, False, False, False,

					(*WashBufferVolume,WashMixTime,WashMixTemperature,WashMixRate,WashMixVolume,WashMagnetizationTime,WashAspirationVolume,WashAirDryTime*)
					False, False, False, False, False, False, False, False,

					(*SecondaryWashBufferVolume,SecondaryWashMixTime,SecondaryWashMixTemperature,SecondaryWashMixRate,SecondaryWashMixVolume,SecondaryWashMagnetizationTime,SecondaryWashAspirationVolume,SecondaryWashAirDryTime*)
					False, False, False, False, False, False, False, False,

					(*TertiaryWashBufferVolume,TertiaryWashMixTime,TertiaryWashMixTemperature,TertiaryWashMixRate,TertiaryWashMixVolume,TertiaryWashMagnetizationTime,TertiaryWashAspirationVolume,TertiaryWashAirDryTime*)
					False, False, False, False, False, False, False, False,

					(*QuaternaryWashBufferVolume,QuaternaryWashMixTime,QuaternaryWashMixTemperature,QuaternaryWashMixRate,QuaternaryWashMixVolume,QuaternaryWashMagnetizationTime,QuaternaryWashAspirationVolume,QuaternaryWashAirDryTime*)
					False, False, False, False, False, False, False, False,

					(*QuinaryWashBufferVolume,QuinaryWashMixTime,QuinaryWashMixTemperature,QuinaryWashMixRate,QuinaryWashMixVolume,QuinaryWashMagnetizationTime,QuinaryWashAspirationVolume,QuinaryWashAirDryTime*)
					False, False, False, False, False, False, False, False,

					(*SenaryWashBufferVolume,SenaryWashMixTime,SenaryWashMixTemperature,SenaryWashMixRate,SenaryWashMixVolume,SenaryWashMagnetizationTime,SenaryWashAspirationVolume,SenaryWashAirDryTime*)
					False, False, False, False, False, False, False, False,

					(*SeptenaryWashBufferVolume,SeptenaryWashMixTime,SeptenaryWashMixTemperature,SeptenaryWashMixRate,SeptenaryWashMixVolume,SeptenaryWashMagnetizationTime,SeptenaryWashAspirationVolume,SeptenaryWashAirDryTime*)
					False, False, False, False, False, False, False, False,

					(*ElutionBufferVolume,ElutionMixTime,ElutionMixTemperature,ElutionMixRate,ElutionMixVolume,ElutionMagnetizationTime,ElutionAspirationVolume*)
					False, False, False, False, False, False, False}
			],
			{}
		}
	];

	(*Pull out the rounded options*)
	{
		volumes, magneticBeadVolumes,

		preWashBufferVolumes, preWashMixTimes, preWashMixTemperatures, preWashMixRates, preWashMixVolumes,
		preWashMagnetizationTimes, preWashAspirationVolumes, preWashAirDryTimes,

		equilibrationBufferVolumes, equilibrationMixTimes, equilibrationMixTemperatures,
		equilibrationMixRates, equilibrationMixVolumes, equilibrationMagnetizationTimes, equilibrationAspirationVolumes,
		equilibrationAirDryTimes,

		loadingMixTimes, loadingMixTemperatures, loadingMixRates, loadingMixVolumes, loadingMagnetizationTimes,
		loadingAspirationVolumes, loadingAirDryTimes,

		washBufferVolumes, washMixTimes, washMixTemperatures, washMixRates, washMixVolumes,
		washMagnetizationTimes, washAspirationVolumes, washAirDryTimes,

		secondaryWashBufferVolumes,secondaryWashMixTimes,secondaryWashMixTemperatures,secondaryWashMixRates,secondaryWashMixVolumes,secondaryWashMagnetizationTimes,
		secondaryWashAspirationVolumes,secondaryWashAirDryTimes,

		tertiaryWashBufferVolumes,tertiaryWashMixTimes,tertiaryWashMixTemperatures,tertiaryWashMixRates,tertiaryWashMixVolumes,tertiaryWashMagnetizationTimes,
		tertiaryWashAspirationVolumes,tertiaryWashAirDryTimes,

		quaternaryWashBufferVolumes,quaternaryWashMixTimes,quaternaryWashMixTemperatures,quaternaryWashMixRates,quaternaryWashMixVolumes,quaternaryWashMagnetizationTimes,
		quaternaryWashAspirationVolumes,quaternaryWashAirDryTimes,

		quinaryWashBufferVolumes,quinaryWashMixTimes,quinaryWashMixTemperatures,quinaryWashMixRates,quinaryWashMixVolumes,quinaryWashMagnetizationTimes,quinaryWashAspirationVolumes,quinaryWashAirDryTimes,

		senaryWashBufferVolumes,senaryWashMixTimes,senaryWashMixTemperatures,senaryWashMixRates,senaryWashMixVolumes,senaryWashMagnetizationTimes,
		senaryWashAspirationVolumes,senaryWashAirDryTimes,

		septenaryWashBufferVolumes,septenaryWashMixTimes,septenaryWashMixTemperatures,septenaryWashMixRates,septenaryWashMixVolumes,septenaryWashMagnetizationTimes,
		septenaryWashAspirationVolumes,septenaryWashAirDryTimes,

		elutionBufferVolumes, elutionMixTimes, elutionMixTemperatures, elutionMixRates, elutionMixVolumes,
		elutionMagnetizationTimes, elutionAspirationVolumes
	}=Lookup[
		roundedMBSOptions,
		{
			Volume,MagneticBeadVolume,

			PreWashBufferVolume,PreWashMixTime,PreWashMixTemperature,PreWashMixRate,PreWashMixVolume,
			PreWashMagnetizationTime,PreWashAspirationVolume,PreWashAirDryTime,

			EquilibrationBufferVolume,EquilibrationMixTime,EquilibrationMixTemperature,
			EquilibrationMixRate,EquilibrationMixVolume,EquilibrationMagnetizationTime,EquilibrationAspirationVolume,EquilibrationAirDryTime,

			LoadingMixTime,LoadingMixTemperature,LoadingMixRate,LoadingMixVolume,
			LoadingMagnetizationTime,LoadingAspirationVolume,LoadingAirDryTime,

			WashBufferVolume,WashMixTime,WashMixTemperature,WashMixRate,WashMixVolume,WashMagnetizationTime,
			WashAspirationVolume,WashAirDryTime,

			SecondaryWashBufferVolume,SecondaryWashMixTime,SecondaryWashMixTemperature,SecondaryWashMixRate,SecondaryWashMixVolume,SecondaryWashMagnetizationTime,
			SecondaryWashAspirationVolume,SecondaryWashAirDryTime,

			TertiaryWashBufferVolume,TertiaryWashMixTime,TertiaryWashMixTemperature,TertiaryWashMixRate,TertiaryWashMixVolume,TertiaryWashMagnetizationTime,
			TertiaryWashAspirationVolume,TertiaryWashAirDryTime,

			QuaternaryWashBufferVolume,QuaternaryWashMixTime,QuaternaryWashMixTemperature,QuaternaryWashMixRate,QuaternaryWashMixVolume,QuaternaryWashMagnetizationTime,
			QuaternaryWashAspirationVolume,QuaternaryWashAirDryTime,

			QuinaryWashBufferVolume,QuinaryWashMixTime,QuinaryWashMixTemperature,QuinaryWashMixRate,QuinaryWashMixVolume,QuinaryWashMagnetizationTime,
			QuinaryWashAspirationVolume,QuinaryWashAirDryTime,

			SenaryWashBufferVolume,SenaryWashMixTime,SenaryWashMixTemperature,SenaryWashMixRate,SenaryWashMixVolume,SenaryWashMagnetizationTime,
			SenaryWashAspirationVolume,SenaryWashAirDryTime,

			SeptenaryWashBufferVolume,SeptenaryWashMixTime,SeptenaryWashMixTemperature,SeptenaryWashMixRate,SeptenaryWashMixVolume,SeptenaryWashMagnetizationTime,
			SeptenaryWashAspirationVolume,SeptenaryWashAirDryTime,

			ElutionBufferVolume,ElutionMixTime,ElutionMixTemperature,ElutionMixRate,ElutionMixVolume,
			ElutionMagnetizationTime,ElutionAspirationVolume
		}
	];


	(*--- Resolve independent option ---*)

	(* Resolve WorkCell *)
	allowedWorkCells=resolveExperimentMagneticBeadSeparationWorkCell[myNestedSamples, myOptions];
	resolvedWorkCell=Which[
		MatchQ[Lookup[myOptions, WorkCell], Except[Automatic]],
		Lookup[myOptions, WorkCell],
		Length[allowedWorkCells]>0,
		First[allowedWorkCells],
		True,
		STAR
	];

	(* Look up the processing order *)
	processingOrder = Lookup[myOptions,ProcessingOrder];

	(* Resolve ProcessingOrder *)
	resolvedProcessingOrder=If[MatchQ[processingOrder,Automatic],
		(* If ProcessingOrder is Automatic, look at the structure of the input list to determine whether to resolve to  *)
		(* Parallel or Batch *)
		If[MatchQ[myOriginalSamples,{Alternatives[ObjectP[Object[Sample]],ObjectP[Object[Container]],ObjectP[Model[Sample]]]..}],
			Parallel,
			Batch
		],
		(* Otherwise, keep it *)
		processingOrder
	];

	(* Immediately throw an error if the processing order does not match the dimensions of the input samples *)
	validProcessingOrderQ=If[MatchQ[processingOrder,Except[Automatic]],
		If[MatchQ[myOriginalSamples,ListableP[Alternatives[ObjectP[{Object[Sample],Object[Container],Model[Sample]}],_String,{LocationPositionP,_String|ObjectP[Object[Container]]}]]],
			MatchQ[processingOrder,Parallel|Serial],
			MatchQ[processingOrder,Batch]
		],
		True
	];

	(* Throw an error if if messages are being thrown *)
	invalidProcessingOrderOptions=If[!validProcessingOrderQ&&messages,
		Message[Error::InvalidProcessingOrder];
		{ProcessingOrder},
		{}
	];

	(* Create a test if tests are being gathered *)
	validProcessingOrderTest=If[gatherTests,
		Test["ProcessingOrder matches dimensions of input:",
			validProcessingOrderQ,
			True
		],
		Nothing
	];

	(* Resolve Volume *)
	resolvedVolumes=MapThread[
		Function[{sample,specifiedVolume},

			(* If volume is specifed by the user, keep it *)
			If[MatchQ[specifiedVolume,Except[Automatic]],
				specifiedVolume,

				(* Otherwise choose minimum based on resolved preparation *)
				If[MatchQ[resolvedPreparation,Manual],
					Min[fastAssocLookup[combinedFastAssoc,sample,Volume],25. Milliliter],
					Min[fastAssocLookup[combinedFastAssoc,sample,Volume],1. Milliliter]
				]
			]
		],
		{flatSamples,Flatten@volumes}
	];

	(*Resolve MagneticBeadVolume*)
	resolvedMagneticBeadVolumes=If[MatchQ[magneticBeadVolumes,{Automatic..}],
		(Max/@resolvedVolumes)/10.,
		magneticBeadVolumes
	];

	(*Update roundedMBSOptions with the resolved independent option values*)
	updatedRoundedMBSOptions=<|ReplaceRule[Normal[roundedMBSOptions,Association],{Volume->resolvedVolumes,MagneticBeadVolume->resolvedMagneticBeadVolumes,Preparation->resolvedPreparation}]|>;

	(*---Resolve MapThread options---*)
	(*Convert our options into a MapThread friendly version*)
	mapThreadFriendlyOptions=OptionsHandling`Private`mapThreadOptions[ExperimentMagneticBeadSeparation,updatedRoundedMBSOptions];

	(* ---- Resolve MagnetizationRack and AssayContainer ahead of resolving the mix options ---- *)
	{unresolvedMagnetizationRacks,resolvedMagnetizationRacks,resolvedMagnetizationRackModels,resolvedAssayContainers}=Transpose[MapThread[
		Function[{samplePacket,myMapThreadOptions},
			Module[{volume,magneticBeadVolume,preWashBufferVolume,equilibrationBufferVolume,washBufferVolume,secondaryWashBufferVolume,tertiaryWashBufferVolume,quaternaryWashBufferVolume,quinaryWashBufferVolume,senaryWashBufferVolume,septenaryWashBufferVolume,elutionBufferVolume,
				magnetizationRack,preparation,maxPossibleVolume,resolvedMagnetizationRack,magnetRackModel,magnetRackFootprint,resolvedAssayContainer},

				(* Lookup the necessary options *)
				{
					volume,magneticBeadVolume,preWashBufferVolume,equilibrationBufferVolume,washBufferVolume,elutionBufferVolume,
					magnetizationRack,preparation
				}=Lookup[
					myMapThreadOptions,
					{
						Volume,MagneticBeadVolume,PreWashBufferVolume,EquilibrationBufferVolume,WashBufferVolume,ElutionBufferVolume,
						MagnetizationRack,Preparation
					}
				];

				(* get the max possible volume we need to handle to resolve options below *)
				(* Note that magneticBeadVolume is added together with other buffers. At this moment, MagneticBeadVolume and Volume has been resolved and should always be a volume *)
				maxPossibleVolume=Total[{
					magneticBeadVolume,
					Max@Cases[
						Flatten[{volume,magneticBeadVolume,preWashBufferVolume,equilibrationBufferVolume,washBufferVolume,secondaryWashBufferVolume,tertiaryWashBufferVolume,quaternaryWashBufferVolume,quinaryWashBufferVolume,senaryWashBufferVolume,septenaryWashBufferVolume,elutionBufferVolume}],
						VolumeP
					]
				}];
        (*TODO::change all name references to ID references once the model makes to proddb*)
				(*Resolve MagnetizationRack*)
				resolvedMagnetizationRack=If[MatchQ[magnetizationRack,Automatic],
					(*If the option is Automatic, resolve it from volumes*)
					Switch[maxPossibleVolume,
						LessEqualP[200 Microliter],
							If[MatchQ[preparation,Robotic],
								Model[Item, MagnetizationRack, "id:kEJ9mqJYljjz"],(*Alpaqua Magnum FLX Enhanced Universal Magnet 96-well Plate Rack*)
								Model[Container,Rack,"id:xRO9n3BDjjZw"](*DynaMag Magnet 96-well Skirted Plate Rack*)
							],
						LessEqualP[2 Milliliter],
							If[MatchQ[preparation,Robotic],
								Model[Item, MagnetizationRack, "id:kEJ9mqJYljjz"],(*Alpaqua Magnum FLX Enhanced Universal Magnet 96-well Plate Rack*)
								Model[Container,Rack,"id:n0k9mG8D1x36"](*DynaMag Magnet 2mL Tube Rack*)
							],
						LessEqualP[15 Milliliter],
							If[MatchQ[preparation,Robotic],
								Model[Item, MagnetizationRack, "id:kEJ9mqJYljjz"],(*Alpaqua Magnum FLX Enhanced Universal Magnet 96-well Plate Rack*)
								Model[Container,Rack,"id:qdkmxzqDev54"](*DynaMag Magnet 15mL Tube Rack*)
							],
						_,
							If[MatchQ[preparation,Robotic],
								Model[Item, MagnetizationRack, "id:kEJ9mqJYljjz"],(*Alpaqua Magnum FLX Enhanced Universal Magnet 96-well Plate Rack*)
								Model[Container,Rack,"id:D8KAEvGJllmk"](*DynaMag Magnet 50mL Tube Rack*)
							]
					],
					(*If the option is specified, accept it*)
					Download[magnetizationRack,Object]
				];

				(* Make sure the magnetization rack is a model *)
				magnetRackModel=If[MatchQ[resolvedMagnetizationRack,ObjectP[{Model[Container, Rack], Model[Item, MagnetizationRack]}]],
					resolvedMagnetizationRack,
					fastAssocLookup[combinedFastAssoc,resolvedMagnetizationRack,Model]
				];

				(* Get the footprint of the magnetization rack so we can resolve the assay container *)
				magnetRackFootprint=fastAssocLookup[combinedFastAssoc,magnetRackModel,Footprint];

				(* Resolve the assay container *)
				resolvedAssayContainer=If[MatchQ[magnetRackFootprint,Plate],
					Module[{resolvedAssayContainerModel},
						(* resolved assay container model based on Preparation option and max possible volume. If the footprint is a plate, only when  *)
						resolvedAssayContainerModel=If[MatchQ[preparation,Robotic]&&MatchQ[maxPossibleVolume,GreaterP[200 Microliter]],
							Model[Container,Plate,"id:L8kPEjkmLbvW"],(*96-well 2mL Deep Well Plate*)
							Model[Container,Plate,"id:01G6nvkKrrYm"](*96-well PCR Plate*)
						]
					],
					(* else: supported footprint is not Plate *)
					Module[{resolvedAssayContainerModel},
						(* resolved assay container model based on magnetic rack supported footprint *)
						resolvedAssayContainerModel=Switch[maxPossibleVolume,
							LessEqualP[2 Milliliter],Model[Container,Vessel,"id:3em6Zv9NjjN8"],(*2mL Tube*)
							LessEqualP[15 Milliliter],Model[Container,Vessel,"id:xRO9n3vk11pw"],(*15mL Tube*)
							_,Model[Container,Vessel,"id:bq9LA0dBGGR6"](*50mL Tube*)
						]
					]
				];
				{
          magnetizationRack,
					resolvedMagnetizationRack,
          magnetRackModel,
					resolvedAssayContainer
				}
			]
		],
		{flatSamples,mapThreadFriendlyOptions}
	]
];

	(* ---- Pre-resolve AirDry options, MagnetizationTimes, and mixOptions  ---- *)
	(*These options are required to be consistent within a batch when assay container is a plate. They are pre-resolved to propagate any user-specification within a batch ahead of independent resolving all options through mapthread.*)
	preResolvedMapThreadFriendlyOptions=Module[
		{
			preWashMixType, preWashMixTime, preWashMixRate, numberOfPreWashMixes, preWashMixTemperature,preResolvedPreWashMixType, preResolvedPreWashMixTime, preResolvedPreWashMixRate, preResolvedNumberOfPreWashMixes, preResolvedPreWashMixTemperature,preWashAirDry, preWashAirDryTime,preWashMagnetizationTime,

			equilibrationMixType, equilibrationMixTime, equilibrationMixRate, numberOfEquilibrationMixes, equilibrationMixTemperature,preResolvedEquilibrationMixType, preResolvedEquilibrationMixTime, preResolvedEquilibrationMixRate, preResolvedNumberOfEquilibrationMixes, preResolvedEquilibrationMixTemperature,equilibrationAirDry, equilibrationAirDryTime,equilibrationMagnetizationTime,

			loadingMixType, loadingMixTime, loadingMixRate, numberOfLoadingMixes, loadingMixTemperature,preResolvedLoadingMixType, preResolvedLoadingMixTime, preResolvedLoadingMixRate, preResolvedNumberOfLoadingMixes, preResolvedLoadingMixTemperature,loadingAirDry, loadingAirDryTime,loadingMagnetizationTime,

			washMixType, washMixTime, washMixRate, numberOfWashMixes, washMixTemperature,preResolvedWashMixType, preResolvedWashMixTime, preResolvedWashMixRate, preResolvedNumberOfWashMixes, preResolvedWashMixTemperature,washAirDry, washAirDryTime,washMagnetizationTime,

			secondaryWashMixType, secondaryWashMixTime, secondaryWashMixRate, numberOfSecondaryWashMixes, secondaryWashMixTemperature,preResolvedSecondaryWashMixType, preResolvedSecondaryWashMixTime, preResolvedSecondaryWashMixRate, preResolvedNumberOfSecondaryWashMixes, preResolvedSecondaryWashMixTemperature,secondaryWashAirDry, secondaryWashAirDryTime,secondaryWashMagnetizationTime,

			tertiaryWashMixType, tertiaryWashMixTime, tertiaryWashMixRate, numberOfTertiaryWashMixes, tertiaryWashMixTemperature,preResolvedTertiaryWashMixType, preResolvedTertiaryWashMixTime, preResolvedTertiaryWashMixRate, preResolvedNumberOfTertiaryWashMixes, preResolvedTertiaryWashMixTemperature,tertiaryWashAirDry, tertiaryWashAirDryTime,tertiaryWashMagnetizationTime,

			quaternaryWashMixType, quaternaryWashMixTime, quaternaryWashMixRate, numberOfQuaternaryWashMixes, quaternaryWashMixTemperature,preResolvedQuaternaryWashMixType, preResolvedQuaternaryWashMixTime, preResolvedQuaternaryWashMixRate, preResolvedNumberOfQuaternaryWashMixes, preResolvedQuaternaryWashMixTemperature,quaternaryWashAirDry, quaternaryWashAirDryTime,quaternaryWashMagnetizationTime,

			quinaryWashMixType, quinaryWashMixTime, quinaryWashMixRate, numberOfQuinaryWashMixes, quinaryWashMixTemperature,preResolvedQuinaryWashMixType, preResolvedQuinaryWashMixTime, preResolvedQuinaryWashMixRate, preResolvedNumberOfQuinaryWashMixes, preResolvedQuinaryWashMixTemperature,quinaryWashAirDry, quinaryWashAirDryTime,quinaryWashMagnetizationTime,

			senaryWashMixType, senaryWashMixTime, senaryWashMixRate, numberOfSenaryWashMixes, senaryWashMixTemperature,preResolvedSenaryWashMixType, preResolvedSenaryWashMixTime, preResolvedSenaryWashMixRate, preResolvedNumberOfSenaryWashMixes, preResolvedSenaryWashMixTemperature,senaryWashAirDry, senaryWashAirDryTime,senaryWashMagnetizationTime,

			septenaryWashMixType, septenaryWashMixTime, septenaryWashMixRate, numberOfSeptenaryWashMixes, septenaryWashMixTemperature,preResolvedSeptenaryWashMixType, preResolvedSeptenaryWashMixTime, preResolvedSeptenaryWashMixRate, preResolvedNumberOfSeptenaryWashMixes, preResolvedSeptenaryWashMixTemperature,septenaryWashAirDry, septenaryWashAirDryTime,septenaryWashMagnetizationTime,

			elutionMixType, elutionMixTime, elutionMixRate, numberOfElutionMixes, elutionMixTemperature,preResolvedElutionMixType, preResolvedElutionMixTime, preResolvedElutionMixRate, preResolvedNumberOfElutionMixes, preResolvedElutionMixTemperature,elutionMagnetizationTime,

			preResolvedMBSOptions
		},
		(*Lookup the mapthread friendly values of each option*)
		{
			preWashMixType, preWashMixTime, preWashMixRate, numberOfPreWashMixes, preWashMixTemperature, preWashAirDry, preWashAirDryTime,preWashMagnetizationTime,
			equilibrationMixType, equilibrationMixTime, equilibrationMixRate, numberOfEquilibrationMixes, equilibrationMixTemperature, equilibrationAirDry, equilibrationAirDryTime,equilibrationMagnetizationTime,
			loadingMixType, loadingMixTime, loadingMixRate, numberOfLoadingMixes, loadingMixTemperature, loadingAirDry, loadingAirDryTime,loadingMagnetizationTime,
			washMixType, washMixTime, washMixRate, numberOfWashMixes, washMixTemperature, washAirDry, washAirDryTime,washMagnetizationTime,
			secondaryWashMixType, secondaryWashMixTime, secondaryWashMixRate, numberOfSecondaryWashMixes, secondaryWashMixTemperature, secondaryWashAirDry, secondaryWashAirDryTime,secondaryWashMagnetizationTime,
			tertiaryWashMixType, tertiaryWashMixTime, tertiaryWashMixRate, numberOfTertiaryWashMixes, tertiaryWashMixTemperature, tertiaryWashAirDry, tertiaryWashAirDryTime,tertiaryWashMagnetizationTime,
			quaternaryWashMixType, quaternaryWashMixTime, quaternaryWashMixRate, numberOfQuaternaryWashMixes, quaternaryWashMixTemperature, quaternaryWashAirDry, quaternaryWashAirDryTime,quaternaryWashMagnetizationTime,
			quinaryWashMixType, quinaryWashMixTime, quinaryWashMixRate, numberOfQuinaryWashMixes, quinaryWashMixTemperature, quinaryWashAirDry, quinaryWashAirDryTime,quinaryWashMagnetizationTime,
			senaryWashMixType, senaryWashMixTime, senaryWashMixRate, numberOfSenaryWashMixes, senaryWashMixTemperature, senaryWashAirDry, senaryWashAirDryTime,senaryWashMagnetizationTime,
			septenaryWashMixType, septenaryWashMixTime, septenaryWashMixRate, numberOfSeptenaryWashMixes, septenaryWashMixTemperature, septenaryWashAirDry, septenaryWashAirDryTime,septenaryWashMagnetizationTime,
			elutionMixType, elutionMixTime, elutionMixRate, numberOfElutionMixes, elutionMixTemperature, elutionMagnetizationTime
		}=Lookup[
			updatedRoundedMBSOptions,
			{
				PreWashMixType, PreWashMixTime, PreWashMixRate, NumberOfPreWashMixes, PreWashMixTemperature, PreWashAirDry, PreWashAirDryTime,PreWashMagnetizationTime,
				EquilibrationMixType, EquilibrationMixTime, EquilibrationMixRate, NumberOfEquilibrationMixes, EquilibrationMixTemperature, EquilibrationAirDry, EquilibrationAirDryTime,EquilibrationMagnetizationTime,
				LoadingMixType, LoadingMixTime, LoadingMixRate, NumberOfLoadingMixes, LoadingMixTemperature, LoadingAirDry, LoadingAirDryTime,LoadingMagnetizationTime,
				WashMixType, WashMixTime, WashMixRate, NumberOfWashMixes, WashMixTemperature, WashAirDry, WashAirDryTime,WashMagnetizationTime,
				SecondaryWashMixType, SecondaryWashMixTime, SecondaryWashMixRate, NumberOfSecondaryWashMixes, SecondaryWashMixTemperature, SecondaryWashAirDry, SecondaryWashAirDryTime,SecondaryWashMagnetizationTime,
				TertiaryWashMixType, TertiaryWashMixTime, TertiaryWashMixRate, NumberOfTertiaryWashMixes, TertiaryWashMixTemperature, TertiaryWashAirDry, TertiaryWashAirDryTime,TertiaryWashMagnetizationTime,
				QuaternaryWashMixType, QuaternaryWashMixTime, QuaternaryWashMixRate, NumberOfQuaternaryWashMixes, QuaternaryWashMixTemperature, QuaternaryWashAirDry, QuaternaryWashAirDryTime,QuaternaryWashMagnetizationTime,
				QuinaryWashMixType, QuinaryWashMixTime, QuinaryWashMixRate, NumberOfQuinaryWashMixes, QuinaryWashMixTemperature, QuinaryWashAirDry, QuinaryWashAirDryTime,QuinaryWashMagnetizationTime,
				SenaryWashMixType, SenaryWashMixTime, SenaryWashMixRate, NumberOfSenaryWashMixes, SenaryWashMixTemperature, SenaryWashAirDry, SenaryWashAirDryTime,SenaryWashMagnetizationTime,
				SeptenaryWashMixType, SeptenaryWashMixTime, SeptenaryWashMixRate, NumberOfSeptenaryWashMixes, SeptenaryWashMixTemperature, SeptenaryWashAirDry, SeptenaryWashAirDryTime,SeptenaryWashMagnetizationTime,
				ElutionMixType, ElutionMixTime, ElutionMixRate, NumberOfElutionMixes, ElutionMixTemperature,ElutionMagnetizationTime
			}
		];
		(*Pre resolve mix options stage by stage*)
		{preResolvedPreWashMixType, preResolvedPreWashMixTime,preResolvedPreWashMixTemperature,preResolvedPreWashMixRate, preResolvedNumberOfPreWashMixes}=preResolveMixOptionsOfStage[myNestedSamples,Flatten@resolvedAssayContainers,preWashMixType,preWashMixTime,preWashMixTemperature,preWashMixRate,numberOfPreWashMixes];
		{preResolvedEquilibrationMixType, preResolvedEquilibrationMixTime,preResolvedEquilibrationMixTemperature,preResolvedEquilibrationMixRate, preResolvedNumberOfEquilibrationMixes}=preResolveMixOptionsOfStage[myNestedSamples,Flatten@resolvedAssayContainers,equilibrationMixType,equilibrationMixTime,equilibrationMixTemperature,equilibrationMixRate,numberOfEquilibrationMixes];
		{preResolvedLoadingMixType, preResolvedLoadingMixTime,preResolvedLoadingMixTemperature,preResolvedLoadingMixRate, preResolvedNumberOfLoadingMixes}=preResolveMixOptionsOfStage[myNestedSamples,Flatten@resolvedAssayContainers,loadingMixType,loadingMixTime,loadingMixTemperature,loadingMixRate,numberOfLoadingMixes];
		{preResolvedWashMixType, preResolvedWashMixTime,preResolvedWashMixTemperature,preResolvedWashMixRate, preResolvedNumberOfWashMixes}=preResolveMixOptionsOfStage[myNestedSamples,Flatten@resolvedAssayContainers,washMixType,washMixTime,washMixTemperature,washMixRate,numberOfWashMixes];
		{preResolvedSecondaryWashMixType, preResolvedSecondaryWashMixTime,preResolvedSecondaryWashMixTemperature,preResolvedSecondaryWashMixRate, preResolvedNumberOfSecondaryWashMixes}=preResolveMixOptionsOfStage[myNestedSamples,Flatten@resolvedAssayContainers,secondaryWashMixType,secondaryWashMixTime,secondaryWashMixTemperature,secondaryWashMixRate,numberOfSecondaryWashMixes];
		{preResolvedTertiaryWashMixType, preResolvedTertiaryWashMixTime,preResolvedTertiaryWashMixTemperature,preResolvedTertiaryWashMixRate, preResolvedNumberOfTertiaryWashMixes}=preResolveMixOptionsOfStage[myNestedSamples,Flatten@resolvedAssayContainers,tertiaryWashMixType,tertiaryWashMixTime,tertiaryWashMixTemperature,tertiaryWashMixRate,numberOfTertiaryWashMixes];
		{preResolvedQuaternaryWashMixType, preResolvedQuaternaryWashMixTime,preResolvedQuaternaryWashMixTemperature,preResolvedQuaternaryWashMixRate, preResolvedNumberOfQuaternaryWashMixes}=preResolveMixOptionsOfStage[myNestedSamples,Flatten@resolvedAssayContainers,quaternaryWashMixType,quaternaryWashMixTime,quaternaryWashMixTemperature,quaternaryWashMixRate,numberOfQuaternaryWashMixes];
		{preResolvedQuinaryWashMixType, preResolvedQuinaryWashMixTime,preResolvedQuinaryWashMixTemperature,preResolvedQuinaryWashMixRate, preResolvedNumberOfQuinaryWashMixes}=preResolveMixOptionsOfStage[myNestedSamples,Flatten@resolvedAssayContainers,quinaryWashMixType,quinaryWashMixTime,quinaryWashMixTemperature,quinaryWashMixRate,numberOfQuinaryWashMixes];
		{preResolvedSenaryWashMixType, preResolvedSenaryWashMixTime,preResolvedSenaryWashMixTemperature,preResolvedSenaryWashMixRate, preResolvedNumberOfSenaryWashMixes}=preResolveMixOptionsOfStage[myNestedSamples,Flatten@resolvedAssayContainers,senaryWashMixType,senaryWashMixTime,senaryWashMixTemperature,senaryWashMixRate,numberOfSenaryWashMixes];
		{preResolvedSeptenaryWashMixType, preResolvedSeptenaryWashMixTime,preResolvedSeptenaryWashMixTemperature,preResolvedSeptenaryWashMixRate, preResolvedNumberOfSeptenaryWashMixes}=preResolveMixOptionsOfStage[myNestedSamples,Flatten@resolvedAssayContainers,septenaryWashMixType,septenaryWashMixTime,septenaryWashMixTemperature,septenaryWashMixRate,numberOfSeptenaryWashMixes];
		{preResolvedElutionMixType, preResolvedElutionMixTime,preResolvedElutionMixTemperature,preResolvedElutionMixRate, preResolvedNumberOfElutionMixes}=preResolveMixOptionsOfStage[myNestedSamples,Flatten@resolvedAssayContainers,elutionMixType,elutionMixTime,elutionMixTemperature,elutionMixRate,numberOfElutionMixes];

		(*Call the helper function to pre-resolve these options *)
		preResolvedMBSOptions=ReplaceRule[
			Normal[updatedRoundedMBSOptions,Association],
			{
				PreWashMixType->preResolvedPreWashMixType,
				PreWashMixTime->preResolvedPreWashMixTime,
				PreWashMixRate->preResolvedPreWashMixRate,
				NumberOfPreWashMixes->preResolvedNumberOfPreWashMixes,
				PreWashMixTemperature->preResolvedPreWashMixTemperature,
				PreWashAirDry->preResolveOneOptionOfStage[myNestedSamples,Flatten@resolvedAssayContainers,preWashAirDry],
				PreWashAirDryTime->preResolveOneOptionOfStage[myNestedSamples,Flatten@resolvedAssayContainers,preWashAirDryTime],
				PreWashMagnetizationTime->preResolveOneOptionOfStage[myNestedSamples,Flatten@resolvedAssayContainers,preWashMagnetizationTime],
				EquilibrationMixType->preResolvedEquilibrationMixType,
				EquilibrationMixTime->preResolvedEquilibrationMixTime,
				EquilibrationMixRate->preResolvedEquilibrationMixRate,
				NumberOfEquilibrationMixes->preResolvedNumberOfEquilibrationMixes,
				EquilibrationMixTemperature->preResolvedEquilibrationMixTemperature,
				EquilibrationAirDry->preResolveOneOptionOfStage[myNestedSamples,Flatten@resolvedAssayContainers,equilibrationAirDry],
				EquilibrationAirDryTime->preResolveOneOptionOfStage[myNestedSamples,Flatten@resolvedAssayContainers,equilibrationAirDryTime],
				EquilibrationMagnetizationTime->preResolveOneOptionOfStage[myNestedSamples,Flatten@resolvedAssayContainers,equilibrationMagnetizationTime],
				LoadingMixType->preResolvedLoadingMixType,
				LoadingMixTime->preResolvedLoadingMixTime,
				LoadingMixRate->preResolvedLoadingMixRate,
				NumberOfLoadingMixes->preResolvedNumberOfLoadingMixes,
				LoadingMixTemperature->preResolvedLoadingMixTemperature,
				LoadingAirDry->preResolveOneOptionOfStage[myNestedSamples,Flatten@resolvedAssayContainers,loadingAirDry],
				LoadingAirDryTime->preResolveOneOptionOfStage[myNestedSamples,Flatten@resolvedAssayContainers,loadingAirDryTime],
				LoadingMagnetizationTime->preResolveOneOptionOfStage[myNestedSamples,Flatten@resolvedAssayContainers,loadingMagnetizationTime],
				WashMixType->preResolvedWashMixType,
				WashMixTime->preResolvedWashMixTime,
				WashMixRate->preResolvedWashMixRate,
				NumberOfWashMixes->preResolvedNumberOfWashMixes,
				WashMixTemperature->preResolvedWashMixTemperature,
				WashAirDry->preResolveOneOptionOfStage[myNestedSamples,Flatten@resolvedAssayContainers,washAirDry],
				WashAirDryTime->preResolveOneOptionOfStage[myNestedSamples,Flatten@resolvedAssayContainers,washAirDryTime],
				WashMagnetizationTime->preResolveOneOptionOfStage[myNestedSamples,Flatten@resolvedAssayContainers,washMagnetizationTime],
				SecondaryWashMixType->preResolvedSecondaryWashMixType,
				SecondaryWashMixTime->preResolvedSecondaryWashMixTime,
				SecondaryWashMixRate->preResolvedSecondaryWashMixRate,
				NumberOfSecondaryWashMixes->preResolvedNumberOfSecondaryWashMixes,
				SecondaryWashMixTemperature->preResolvedSecondaryWashMixTemperature,
				SecondaryWashAirDry->preResolveOneOptionOfStage[myNestedSamples,Flatten@resolvedAssayContainers,secondaryWashAirDry],
				SecondaryWashAirDryTime->preResolveOneOptionOfStage[myNestedSamples,Flatten@resolvedAssayContainers,secondaryWashAirDryTime],
				SecondaryWashMagnetizationTime->preResolveOneOptionOfStage[myNestedSamples,Flatten@resolvedAssayContainers,secondaryWashMagnetizationTime],
				TertiaryWashMixType->preResolvedTertiaryWashMixType,
				TertiaryWashMixTime->preResolvedTertiaryWashMixTime,
				TertiaryWashMixRate->preResolvedTertiaryWashMixRate,
				NumberOfTertiaryWashMixes->preResolvedNumberOfTertiaryWashMixes,
				TertiaryWashMixTemperature->preResolvedTertiaryWashMixTemperature,
				TertiaryWashAirDry->preResolveOneOptionOfStage[myNestedSamples,Flatten@resolvedAssayContainers,tertiaryWashAirDry],
				TertiaryWashAirDryTime->preResolveOneOptionOfStage[myNestedSamples,Flatten@resolvedAssayContainers,tertiaryWashAirDryTime],
				TertiaryWashMagnetizationTime->preResolveOneOptionOfStage[myNestedSamples,Flatten@resolvedAssayContainers,tertiaryWashMagnetizationTime],
				QuaternaryWashMixType->preResolvedQuaternaryWashMixType,
				QuaternaryWashMixTime->preResolvedQuaternaryWashMixTime,
				QuaternaryWashMixRate->preResolvedQuaternaryWashMixRate,
				NumberOfQuaternaryWashMixes->preResolvedNumberOfQuaternaryWashMixes,
				QuaternaryWashMixTemperature->preResolvedQuaternaryWashMixTemperature,
				QuaternaryWashAirDry->preResolveOneOptionOfStage[myNestedSamples,Flatten@resolvedAssayContainers,quaternaryWashAirDry],
				QuaternaryWashAirDryTime->preResolveOneOptionOfStage[myNestedSamples,Flatten@resolvedAssayContainers,quaternaryWashAirDryTime],
				QuaternaryWashMagnetizationTime->preResolveOneOptionOfStage[myNestedSamples,Flatten@resolvedAssayContainers,quaternaryWashMagnetizationTime],
				QuinaryWashMixType->preResolvedQuinaryWashMixType,
				QuinaryWashMixTime->preResolvedQuinaryWashMixTime,
				QuinaryWashMixRate->preResolvedQuinaryWashMixRate,
				NumberOfQuinaryWashMixes->preResolvedNumberOfQuinaryWashMixes,
				QuinaryWashMixTemperature->preResolvedQuinaryWashMixTemperature,
				QuinaryWashAirDry->preResolveOneOptionOfStage[myNestedSamples,Flatten@resolvedAssayContainers,quinaryWashAirDry],
				QuinaryWashAirDryTime->preResolveOneOptionOfStage[myNestedSamples,Flatten@resolvedAssayContainers,quinaryWashAirDryTime],
				QuinaryWashMagnetizationTime->preResolveOneOptionOfStage[myNestedSamples,Flatten@resolvedAssayContainers,quinaryWashMagnetizationTime],
				SenaryWashMixType->preResolvedSenaryWashMixType,
				SenaryWashMixTime->preResolvedSenaryWashMixTime,
				SenaryWashMixRate->preResolvedSenaryWashMixRate,
				NumberOfSenaryWashMixes->preResolvedNumberOfSenaryWashMixes,
				SenaryWashMixTemperature->preResolvedSenaryWashMixTemperature,
				SenaryWashAirDry->preResolveOneOptionOfStage[myNestedSamples,Flatten@resolvedAssayContainers,senaryWashAirDry],
				SenaryWashAirDryTime->preResolveOneOptionOfStage[myNestedSamples,Flatten@resolvedAssayContainers,senaryWashAirDryTime],
				SenaryWashMagnetizationTime->preResolveOneOptionOfStage[myNestedSamples,Flatten@resolvedAssayContainers,senaryWashMagnetizationTime],
				SeptenaryWashMixType->preResolvedSeptenaryWashMixType,
				SeptenaryWashMixTime->preResolvedSeptenaryWashMixTime,
				SeptenaryWashMixRate->preResolvedSeptenaryWashMixRate,
				NumberOfSeptenaryWashMixes->preResolvedNumberOfSeptenaryWashMixes,
				SeptenaryWashMixTemperature->preResolvedSeptenaryWashMixTemperature,
				SeptenaryWashAirDry->preResolveOneOptionOfStage[myNestedSamples,Flatten@resolvedAssayContainers,septenaryWashAirDry],
				SeptenaryWashAirDryTime->preResolveOneOptionOfStage[myNestedSamples,Flatten@resolvedAssayContainers,septenaryWashAirDryTime],
				SeptenaryWashMagnetizationTime->preResolveOneOptionOfStage[myNestedSamples,Flatten@resolvedAssayContainers,septenaryWashMagnetizationTime],
				ElutionMixType->preResolvedElutionMixType,
				ElutionMixTime->preResolvedElutionMixTime,
				ElutionMixRate->preResolvedElutionMixRate,
				NumberOfElutionMixes->preResolvedNumberOfElutionMixes,
				ElutionMixTemperature->preResolvedElutionMixTemperature,
				ElutionMagnetizationTime->preResolveOneOptionOfStage[myNestedSamples,Flatten@resolvedAssayContainers,elutionMagnetizationTime]
			}
		];
		(*Return the mapthread-friendly version of the updated options *)
		OptionsHandling`Private`mapThreadOptions[ExperimentMagneticBeadSeparation,preResolvedMBSOptions]
	];

	(*MapThread over each of our samples*)
	{
		(*Error-tracking variables*)

		(*1*)multipleTargetsWarnings,
		(*2*)preWashMismatchErrors,
		(*3*)preWashAirDryMismatchErrors,
		(*4*)equilibrationMismatchErrors,
		(*5*)equilibrationAirDryMismatchErrors,
		(*6*)loadingAirDryMismatchErrors,
		(*7*)washMismatchErrors,
		(*8*)washAirDryMismatchErrors,
		(*9*)secondaryWashMismatchErrors,
		(*10*)secondaryWashAirDryMismatchErrors,

		(*11*)tertiaryWashMismatchErrors,
		(*12*)tertiaryWashAirDryMismatchErrors,
		(*13*)quaternaryWashMismatchErrors,
		(*14*)quaternaryWashAirDryMismatchErrors,
		(*15*)quinaryWashMismatchErrors,
		(*16*)quinaryWashAirDryMismatchErrors,
		(*17*)senaryWashMismatchErrors,
		(*18*)senaryWashAirDryMismatchErrors,
		(*19*)septenaryWashMismatchErrors,
		(*20*)septenaryWashAirDryMismatchErrors,

		(*21*)elutionMismatchErrors,


		(*Resolved option values*)

		(*22*)resolvedTargets,
		(*23*)resolvedAnalyteAffinityLabels,
		(*24*)resolvedMagneticBeadAffinityLabels,
		(*25*)resolvedMagneticBeads,

		(*26*)resolvedPreWashes,
		(*27*)resolvedPreWashBuffers,
		(*28*)resolvedPreWashBufferVolumes,
		(*29*)resolvedPreWashMixTimes,
		(*30*)resolvedPreWashMixTemperatures,

		(*31*)resolvedPreWashMixes,
		(*32*)resolvedPreWashMixTypes,
		(*33*)resolvedPreWashMixRates,
		(*34*)resolvedPreWashMixVolumes,
		(*35*)resolvedNumberOfPreWashMixes,
		(*36*)resolvedPreWashMagnetizationTimes,
		(*37*)resolvedPreWashAspirationVolumes,
		(*38*)resolvedPreWashCollectionContainers,
		(*39*)resolvedPreWashCollectionStorageConditions,
		(*40*)resolvedNumberOfPreWashes,

		(*41*)resolvedPreWashAirDries,
		(*42*)resolvedPreWashAirDryTimes,
		(*43*)resolvedPreWashMixTipTypes,
		(*44*)resolvedPreWashMixTipMaterials,

		(*45*)resolvedEquilibrations,
		(*46*)resolvedEquilibrationBuffers,
		(*47*)resolvedEquilibrationBufferVolumes,
		(*48*)resolvedEquilibrationMixTimes,
		(*49*)resolvedEquilibrationMixTemperatures,
		(*50*)resolvedEquilibrationMixes,

		(*51*)resolvedEquilibrationMixTypes,
		(*52*)resolvedEquilibrationMixRates,
		(*53*)resolvedEquilibrationMixVolumes,
		(*54*)resolvedNumberOfEquilibrationMixes,
		(*55*)resolvedEquilibrationMagnetizationTimes,
		(*56*)resolvedEquilibrationAspirationVolumes,
		(*57*)resolvedEquilibrationCollectionContainers,
		(*58*)resolvedEquilibrationCollectionStorageConditions,
		(*59*)resolvedEquilibrationAirDries,
		(*60*)resolvedEquilibrationAirDryTimes,

		(*61*)resolvedEquilibrationMixTipTypes,
		(*62*)resolvedEquilibrationMixTipMaterials,
		(*63*)resolvedEquilibrationCollectionContainers,
		(*64*)resolvedEquilibrationCollectionStorageConditions,

		(*65*)resolvedLoadingMixTimes,
		(*66*)resolvedLoadingMixTemperatures,
		(*67*)resolvedLoadingMixes,
		(*68*)resolvedLoadingMixTypes,
		(*69*)resolvedLoadingMixRates,
		(*70*)resolvedLoadingMixVolumes,

		(*71*)resolvedNumberOfLoadingMixes,
		(*72*)resolvedLoadingMagnetizationTimes,
		(*73*)resolvedLoadingAspirationVolumes,
		(*74*)resolvedLoadingCollectionContainers,
		(*75*)resolvedLoadingCollectionStorageConditions,
		(*76*)resolvedLoadingAirDries,
		(*77*)resolvedLoadingAirDryTimes,
		(*78*)resolvedLoadingMixTipTypes,
		(*79*)resolvedLoadingMixTipMaterials,

		(*80*)resolvedWashes,

		(*81*)resolvedWashBuffers,
		(*82*)resolvedWashBufferVolumes,
		(*83*)resolvedWashMixTimes,
		(*84*)resolvedWashMixTemperatures,
		(*85*)resolvedWashMixes,
		(*86*)resolvedWashMixTypes,
		(*87*)resolvedWashMixRates,
		(*88*)resolvedWashMixVolumes,
		(*89*)resolvedNumberOfWashMixes,
		(*90*)resolvedWashMagnetizationTimes,

		(*91*)resolvedWashAspirationVolumes,
		(*92*)resolvedWashCollectionContainers,
		(*93*)resolvedWashCollectionStorageConditions,
		(*94*)resolvedNumberOfWashes,
		(*95*)resolvedWashAirDries,
		(*96*)resolvedWashAirDryTimes,
		(*97*)resolvedWashMixTipTypes,
		(*98*)resolvedWashMixTipMaterials,

		(*99*)resolvedSecondaryWashes,
		(*100*)resolvedSecondaryWashBuffers,

		(*101*)resolvedSecondaryWashBufferVolumes,
		(*102*)resolvedSecondaryWashMixTimes,
		(*103*)resolvedSecondaryWashMixTemperatures,
		(*104*)resolvedSecondaryWashMixes,
		(*105*)resolvedSecondaryWashMixTypes,
		(*106*)resolvedSecondaryWashMixRates,
		(*107*)resolvedSecondaryWashMixVolumes,
		(*108*)resolvedNumberOfSecondaryWashMixes,
		(*109*)resolvedSecondaryWashMagnetizationTimes,
		(*110*)resolvedSecondaryWashAspirationVolumes,

		(*111*)resolvedSecondaryWashCollectionContainers,
		(*112*)resolvedSecondaryWashCollectionStorageConditions,
		(*113*)resolvedNumberOfSecondaryWashes,
		(*114*)resolvedSecondaryWashAirDries,
		(*115*)resolvedSecondaryWashAirDryTimes,
		(*116*)resolvedSecondaryWashMixTipTypes,
		(*117*)resolvedSecondaryWashMixTipMaterials,

		(*118*)resolvedTertiaryWashes,
		(*119*)resolvedTertiaryWashBuffers,
		(*120*)resolvedTertiaryWashBufferVolumes,

		(*121*)resolvedTertiaryWashMixTimes,
		(*122*)resolvedTertiaryWashMixTemperatures,
		(*123*)resolvedTertiaryWashMixes,
		(*124*)resolvedTertiaryWashMixTypes,
		(*125*)resolvedTertiaryWashMixRates,
		(*126*)resolvedTertiaryWashMixVolumes,
		(*127*)resolvedNumberOfTertiaryWashMixes,
		(*128*)resolvedTertiaryWashMagnetizationTimes,
		(*129*)resolvedTertiaryWashAspirationVolumes,
		(*130*)resolvedTertiaryWashCollectionContainers,

		(*131*)resolvedTertiaryWashCollectionStorageConditions,
		(*132*)resolvedNumberOfTertiaryWashes,
		(*133*)resolvedTertiaryWashAirDries,
		(*134*)resolvedTertiaryWashAirDryTimes,
		(*135*)resolvedTertiaryWashMixTipTypes,
		(*136*)resolvedTertiaryWashMixTipMaterials,

		(*137*)resolvedQuaternaryWashes,
		(*138*)resolvedQuaternaryWashBuffers,
		(*139*)resolvedQuaternaryWashBufferVolumes,
		(*140*)resolvedQuaternaryWashMixTimes,

		(*141*)resolvedQuaternaryWashMixTemperatures,
		(*142*)resolvedQuaternaryWashMixes,
		(*143*)resolvedQuaternaryWashMixTypes,
		(*144*)resolvedQuaternaryWashMixRates,
		(*145*)resolvedQuaternaryWashMixVolumes,
		(*146*)resolvedNumberOfQuaternaryWashMixes,
		(*147*)resolvedQuaternaryWashMagnetizationTimes,
		(*148*)resolvedQuaternaryWashAspirationVolumes,
		(*149*)resolvedQuaternaryWashCollectionContainers,
		(*150*)resolvedQuaternaryWashCollectionStorageConditions,

		(*151*)resolvedNumberOfQuaternaryWashes,
		(*152*)resolvedQuaternaryWashAirDries,
		(*153*)resolvedQuaternaryWashAirDryTimes,
		(*154*)resolvedQuaternaryWashMixTipTypes,
		(*155*)resolvedQuaternaryWashMixTipMaterials,

		(*156*)resolvedQuinaryWashes,
		(*157*)resolvedQuinaryWashBuffers,
		(*158*)resolvedQuinaryWashBufferVolumes,
		(*159*)resolvedQuinaryWashMixTimes,
		(*160*)resolvedQuinaryWashMixTemperatures,
		(*161*)resolvedQuinaryWashMixes,
		(*162*)resolvedQuinaryWashMixTypes,
		(*163*)resolvedQuinaryWashMixRates,
		(*164*)resolvedQuinaryWashMixVolumes,
		(*165*)resolvedNumberOfQuinaryWashMixes,
		(*166*)resolvedQuinaryWashMagnetizationTimes,
		(*167*)resolvedQuinaryWashAspirationVolumes,
		(*168*)resolvedQuinaryWashCollectionContainers,
		(*169*)resolvedQuinaryWashCollectionStorageConditions,
		(*170*)resolvedNumberOfQuinaryWashes,
		(*171*)resolvedQuinaryWashAirDries,
		(*172*)resolvedQuinaryWashAirDryTimes,
		(*173*)resolvedQuinaryWashMixTipTypes,
		(*174*)resolvedQuinaryWashMixTipMaterials,

		(*175*)resolvedSenaryWashes,
		(*176*)resolvedSenaryWashBuffers,
		(*177*)resolvedSenaryWashBufferVolumes,
		(*178*)resolvedSenaryWashMixTimes,
		(*179*)resolvedSenaryWashMixTemperatures,
		(*180*)resolvedSenaryWashMixes,
		(*181*)resolvedSenaryWashMixTypes,
		(*182*)resolvedSenaryWashMixRates,
		(*183*)resolvedSenaryWashMixVolumes,
		(*184*)resolvedNumberOfSenaryWashMixes,
		(*185*)resolvedSenaryWashMagnetizationTimes,
		(*186*)resolvedSenaryWashAspirationVolumes,
		(*187*)resolvedSenaryWashCollectionContainers,
		(*188*)resolvedSenaryWashCollectionStorageConditions,
		(*189*)resolvedNumberOfSenaryWashes,
		(*190*)resolvedSenaryWashAirDries,
		(*191*)resolvedSenaryWashAirDryTimes,
		(*192*)resolvedSenaryWashMixTipTypes,
		(*193*)resolvedSenaryWashMixTipMaterials,

		(*194*)resolvedSeptenaryWashes,
		(*195*)resolvedSeptenaryWashBuffers,
		(*196*)resolvedSeptenaryWashBufferVolumes,
		(*197*)resolvedSeptenaryWashMixTimes,
		(*198*)resolvedSeptenaryWashMixTemperatures,
		(*199*)resolvedSeptenaryWashMixes,
		(*200*)resolvedSeptenaryWashMixTypes,
		(*201*)resolvedSeptenaryWashMixRates,
		(*202*)resolvedSeptenaryWashMixVolumes,
		(*203*)resolvedNumberOfSeptenaryWashMixes,
		(*204*)resolvedSeptenaryWashMagnetizationTimes,
		(*205*)resolvedSeptenaryWashAspirationVolumes,
		(*206*)resolvedSeptenaryWashCollectionContainers,
		(*207*)resolvedSeptenaryWashCollectionStorageConditions,
		(*208*)resolvedNumberOfSeptenaryWashes,
		(*209*)resolvedSeptenaryWashAirDries,
		(*210*)resolvedSeptenaryWashAirDryTimes,
		(*211*)resolvedSeptenaryWashMixTipTypes,
		(*212*)resolvedSeptenaryWashMixTipMaterials,

		(*213*)resolvedElutions,
		(*214*)resolvedElutionBuffers,
		(*215*)resolvedElutionBufferVolumes,
		(*216*)resolvedElutionMixTimes,
		(*217*)resolvedElutionMixTemperatures,
		(*218*)resolvedElutionMixes,
		(*219*)resolvedElutionMixTypes,
		(*220*)resolvedElutionMixRates,
		(*221*)resolvedElutionMixVolumes,
		(*222*)resolvedNumberOfElutionMixes,
		(*223*)resolvedElutionMagnetizationTimes,
		(*224*)resolvedElutionAspirationVolumes,
		(*225*)resolvedElutionCollectionContainers,
		(*226*)resolvedElutionCollectionStorageConditions,
		(*227*)resolvedNumberOfElutions,
		(*228*)resolvedElutionMixTipTypes,
		(*229*)resolvedElutionMixTipMaterials,
    (*230*)resolvedPreWashAspirationPositions,
    (*231*)resolvedPreWashAspirationPositionOffsets,
    (*232*)resolvedEquilibrationAspirationPositions,
    (*233*)resolvedEquilibrationAspirationPositionOffsets,
    (*234*)resolvedLoadingAspirationPositions,
    (*235*)resolvedLoadingAspirationPositionOffsets,
    (*236*)resolvedWashAspirationPositions,
    (*237*)resolvedWashAspirationPositionOffsets,
    (*238*)resolvedSecondaryWashAspirationPositions,
    (*239*)resolvedSecondaryWashAspirationPositionOffsets,
    (*240*)resolvedTertiaryWashAspirationPositions,
    (*241*)resolvedTertiaryWashAspirationPositionOffsets,
    (*242*)resolvedQuaternaryWashAspirationPositions,
    (*243*)resolvedQuaternaryWashAspirationPositionOffsets,
    (*244*)resolvedQuinaryWashAspirationPositions,
    (*245*)resolvedQuinaryWashAspirationPositionOffsets,
    (*246*)resolvedSenaryWashAspirationPositions,
    (*247*)resolvedSenaryWashAspirationPositionOffsets,
    (*248*)resolvedSeptenaryWashAspirationPositions,
    (*249*)resolvedSeptenaryWashAspirationPositionOffsets,
    (*250*)resolvedElutionAspirationPositions,
    (*251*)resolvedElutionAspirationPositionOffsets
	}=Transpose[MapThread[
		Function[{samplePacket,myMapThreadOptions,assayContainer,resolvedMagnetizationRackModel},
			Module[
				{
					sampleObjectRef,sameLoadingCollectionContainerModelQ,
					sampleOutLabelReplaceRules,resolveMBSBufferAndContainerLabel,resolvedPreparation,

					(*Error-tracking variables*)
					multipleTargetsWarning,

					preWashMismatchError,preWashAirDryMismatchError,

					equilibrationMismatchError,equilibrationAirDryMismatchError,

					loadingAirDryMismatchError,

					washMismatchError,washAirDryMismatchError,

					secondaryWashMismatchError,secondaryWashAirDryMismatchError,

					tertiaryWashMismatchError,tertiaryWashAirDryMismatchError,

					quaternaryWashMismatchError,quaternaryWashAirDryMismatchError,

					quinaryWashMismatchError,quinaryWashAirDryMismatchError,

					senaryWashMismatchError,senaryWashAirDryMismatchError,

					septenaryWashMismatchError,septenaryWashAirDryMismatchError,

					elutionMismatchError,mismatchedWashCollectionContainerLabelError,

					mismatchedElutionCollectionContainerLabelError,nullLoadingCollectionContainerLabelError,
					nullElutionCollectionContainerLabelError,invalidContainerOutLabelLengthError,
					mismatchedContainerOutLabelError,

					(*Specified option values*)
					volume,target,analyteAffinityLabel,magneticBeadAffinityLabel,magneticBeads,magneticBeadVolume,
					magneticBeadCollectionStorageCondition,magnetizationRack,

					preWashVolumeToMix,equilibrationVolumeToMix,loadingVolumeToMix,
					washVolumeToMix,secondaryWashVolumeToMix,tertiaryWashVolumeToMix,quaternaryWashVolumeToMix,quinaryWashVolumeToMix,senaryWashVolumeToMix,septenaryWashVolumeToMix,
					elutionVolumeToMix,

					unresolvedPreWashOptions,preWash,preWashBuffer,preWashBufferVolume,preWashMixTime,preWashMixTemperature,preWashMix,preWashMixType,preWashMixRate,
					preWashMixVolume,numberOfPreWashMixes,preWashMagnetizationTime,preWashAspirationVolume,preWashAspirationPosition, preWashAspirationPositionOffset,preWashCollectionContainer,
					preWashCollectionStorageCondition,numberOfPreWashes,preWashAirDry,preWashAirDryTime,
					preWashMixTipType,
					preWashMixTipMaterial,

					unresolvedEquilibrationOptions,equilibration,equilibrationBuffer,equilibrationBufferVolume,equilibrationMixTime,equilibrationMixTemperature,equilibrationMix,equilibrationMixType,equilibrationMixRate,
					equilibrationMixVolume,numberOfEquilibrationMixes,equilibrationMagnetizationTime,equilibrationAspirationVolume,equilibrationAspirationPosition, equilibrationAspirationPositionOffset,equilibrationCollectionContainer,
					equilibrationCollectionStorageCondition,equilibrationAirDry,equilibrationAirDryTime,equilibrationMixTipType,equilibrationMixTipMaterial,

					loadingMixTime,loadingMixTemperature,loadingMix,loadingMixType,loadingMixRate,
					loadingMixVolume,numberOfLoadingMixes,loadingMagnetizationTime,loadingAspirationVolume,loadingAspirationPosition, loadingAspirationPositionOffset,loadingCollectionContainer,
					loadingCollectionStorageCondition,loadingAirDry,loadingAirDryTime,
					loadingMixTipType,loadingMixTipMaterial,

					unresolvedWashOptions,wash,washBuffer,washBufferVolume,washMixTime,washMixTemperature,washMix,washMixType,washMixRate,
					washMixVolume,numberOfWashMixes,washMagnetizationTime,washAspirationVolume,washAspirationPosition,washAspirationPositionOffset,washCollectionContainer,
					washCollectionStorageCondition,numberOfWashes,washAirDry,washAirDryTime,
					washMixTipType,washMixTipMaterial,

					unresolvedSecondaryWashOptions,secondaryWash,secondaryWashBuffer,secondaryWashBufferVolume,secondaryWashMixTime,secondaryWashMixTemperature,secondaryWashMix,secondaryWashMixType,secondaryWashMixRate,
					secondaryWashMixVolume,numberOfSecondaryWashMixes,secondaryWashMagnetizationTime,secondaryWashAspirationVolume,secondaryWashAspirationPosition,secondaryWashAspirationPositionOffset,secondaryWashCollectionContainer,
					secondaryWashCollectionStorageCondition,numberOfSecondaryWashes,secondaryWashAirDry,secondaryWashAirDryTime,
					secondaryWashMixTipType,secondaryWashMixTipMaterial,

					unresolvedTertiaryWashOptions,tertiaryWash,tertiaryWashBuffer,tertiaryWashBufferVolume,tertiaryWashMixTime,tertiaryWashMixTemperature,tertiaryWashMix,tertiaryWashMixType,tertiaryWashMixRate,
					tertiaryWashMixVolume,numberOfTertiaryWashMixes,tertiaryWashMagnetizationTime,tertiaryWashAspirationVolume,tertiaryWashAspirationPosition,tertiaryWashAspirationPositionOffset,tertiaryWashCollectionContainer,
					tertiaryWashCollectionStorageCondition,numberOfTertiaryWashes,tertiaryWashAirDry,tertiaryWashAirDryTime,
					tertiaryWashMixTipType,tertiaryWashMixTipMaterial,

					unresolvedQuaternaryWashOptions,quaternaryWash,quaternaryWashBuffer,quaternaryWashBufferVolume,quaternaryWashMixTime,quaternaryWashMixTemperature,quaternaryWashMix,quaternaryWashMixType,quaternaryWashMixRate,
					quaternaryWashMixVolume,numberOfQuaternaryWashMixes,quaternaryWashMagnetizationTime,quaternaryWashAspirationVolume,quaternaryWashAspirationPosition,quaternaryWashAspirationPositionOffset,quaternaryWashCollectionContainer,
					quaternaryWashCollectionStorageCondition,numberOfQuaternaryWashes,quaternaryWashAirDry,quaternaryWashAirDryTime,
					quaternaryWashMixTipType,quaternaryWashMixTipMaterial,

					unresolvedQuinaryWashOptions,quinaryWash,quinaryWashBuffer,quinaryWashBufferVolume,quinaryWashMixTime,quinaryWashMixTemperature,quinaryWashMix,quinaryWashMixType,quinaryWashMixRate,
					quinaryWashMixVolume,numberOfQuinaryWashMixes,quinaryWashMagnetizationTime,quinaryWashAspirationVolume,quinaryWashAspirationPosition,quinaryWashAspirationPositionOffset,quinaryWashCollectionContainer,
					quinaryWashCollectionStorageCondition,numberOfQuinaryWashes,quinaryWashAirDry,quinaryWashAirDryTime,
					quinaryWashMixTipType,quinaryWashMixTipMaterial,

					unresolvedSenaryWashOptions,senaryWash,senaryWashBuffer,senaryWashBufferVolume,senaryWashMixTime,senaryWashMixTemperature,senaryWashMix,senaryWashMixType,senaryWashMixRate,
					senaryWashMixVolume,numberOfSenaryWashMixes,senaryWashMagnetizationTime,senaryWashAspirationVolume,senaryWashAspirationPosition,senaryWashAspirationPositionOffset,senaryWashCollectionContainer,
					senaryWashCollectionStorageCondition,numberOfSenaryWashes,senaryWashAirDry,senaryWashAirDryTime,
					senaryWashMixTipType,senaryWashMixTipMaterial,

					unresolvedSeptenaryWashOptions,septenaryWash,septenaryWashBuffer,septenaryWashBufferVolume,septenaryWashMixTime,septenaryWashMixTemperature,septenaryWashMix,septenaryWashMixType,septenaryWashMixRate,
					septenaryWashMixVolume,numberOfSeptenaryWashMixes,septenaryWashMagnetizationTime,septenaryWashAspirationVolume,septenaryWashAspirationPosition,septenaryWashAspirationPositionOffset,septenaryWashCollectionContainer,
					septenaryWashCollectionStorageCondition,numberOfSeptenaryWashes,septenaryWashAirDry,septenaryWashAirDryTime,
					septenaryWashMixTipType,septenaryWashMixTipMaterial,

					unresolvedElutionOptions,elution,elutionBuffer,elutionBufferVolume,elutionMixTime,elutionMixTemperature,elutionMix,elutionMixType,elutionMixRate,
					elutionMixVolume,numberOfElutionMixes,elutionMagnetizationTime,elutionAspirationVolume,elutionAspirationPosition,elutionAspirationPositionOffset,elutionCollectionContainer,
					elutionCollectionStorageCondition,numberOfElutions,
					elutionMixTipType,elutionMixTipMaterial,

					sampleLabel,sampleContainerLabel,sampleOutLabel,

					(*Resolved option values*)
					resolvedTarget,resolvedAnalyteAffinityLabel,resolvedMagneticBeadAffinityLabel,resolvedMagneticBead,

					resolvedPreWash,resolvedPreWashBuffer,resolvedPreWashBufferVolume,resolvedPreWashMixTime,resolvedPreWashMixTemperature,resolvedPreWashMix,resolvedPreWashMixType,resolvedPreWashMixRate,
					resolvedPreWashMixVolume,resolvedNumberOfPreWashMixes,resolvedPreWashMagnetizationTime,resolvedPreWashAspirationVolume,resolvedPreWashAspirationPosition, resolvedPreWashAspirationPositionOffset,resolvedPreWashCollectionContainer,
					resolvedPreWashCollectionStorageCondition,resolvedNumberOfPreWashes,resolvedPreWashAirDry,resolvedPreWashAirDryTime,
					resolvedPreWashMixTipType,resolvedPreWashMixTipMaterial,

					resolvedEquilibration,resolvedEquilibrationBuffer,resolvedEquilibrationBufferVolume,resolvedEquilibrationMixTime,resolvedEquilibrationMixTemperature,resolvedEquilibrationMix,resolvedEquilibrationMixType,resolvedEquilibrationMixRate,
					resolvedEquilibrationMixVolume,resolvedNumberOfEquilibrationMixes,resolvedEquilibrationMagnetizationTime,resolvedEquilibrationAspirationVolume,resolvedEquilibrationAspirationPosition, resolvedEquilibrationAspirationPositionOffset,resolvedEquilibrationCollectionContainer,
					resolvedEquilibrationCollectionStorageCondition,resolvedEquilibrationAirDry,resolvedEquilibrationAirDryTime,
					resolvedEquilibrationMixTipType,
					resolvedEquilibrationMixTipMaterial,

					resolvedLoadingMixTime,resolvedLoadingMixTemperature,resolvedLoadingMix,resolvedLoadingMixType,resolvedLoadingMixRate,
					resolvedLoadingMixVolume,resolvedNumberOfLoadingMixes,resolvedLoadingMagnetizationTime,resolvedLoadingAspirationVolume,resolvedLoadingAspirationPosition, resolvedLoadingAspirationPositionOffset,resolvedLoadingCollectionContainer,
					resolvedLoadingCollectionStorageCondition,resolvedLoadingAirDry,resolvedLoadingAirDryTime,
					resolvedLoadingMixTipType,
					resolvedLoadingMixTipMaterial,

					resolvedWash,resolvedWashBuffer,resolvedWashBufferVolume,resolvedWashMixTime,resolvedWashMixTemperature,resolvedWashMix,resolvedWashMixType,resolvedWashMixRate,
					resolvedWashMixVolume,resolvedNumberOfWashMixes,resolvedWashMagnetizationTime,resolvedWashAspirationVolume,resolvedWashAspirationPosition,resolvedWashAspirationPositionOffset,resolvedWashCollectionContainer,
					resolvedWashCollectionStorageCondition,resolvedNumberOfWashes,resolvedWashAirDry,resolvedWashAirDryTime,
					resolvedWashMixTipType,
					resolvedWashMixTipMaterial,

					resolvedSecondaryWash,resolvedSecondaryWashBuffer,resolvedSecondaryWashBufferVolume,resolvedSecondaryWashMixTime,resolvedSecondaryWashMixTemperature,resolvedSecondaryWashMix,resolvedSecondaryWashMixType,resolvedSecondaryWashMixRate,
					resolvedSecondaryWashMixVolume,resolvedNumberOfSecondaryWashMixes,resolvedSecondaryWashMagnetizationTime,resolvedSecondaryWashAspirationVolume,resolvedSecondaryWashAspirationPosition,resolvedSecondaryWashAspirationPositionOffset,resolvedSecondaryWashCollectionContainer,
					resolvedSecondaryWashCollectionStorageCondition,resolvedNumberOfSecondaryWashes,resolvedSecondaryWashAirDry,resolvedSecondaryWashAirDryTime,
					resolvedSecondaryWashMixTipType,
					resolvedSecondaryWashMixTipMaterial,

					resolvedTertiaryWash,resolvedTertiaryWashBuffer,resolvedTertiaryWashBufferVolume,resolvedTertiaryWashMixTime,resolvedTertiaryWashMixTemperature,resolvedTertiaryWashMix,resolvedTertiaryWashMixType,resolvedTertiaryWashMixRate,
					resolvedTertiaryWashMixVolume,resolvedNumberOfTertiaryWashMixes,resolvedTertiaryWashMagnetizationTime,resolvedTertiaryWashAspirationVolume,resolvedTertiaryWashAspirationPosition,resolvedTertiaryWashAspirationPositionOffset,resolvedTertiaryWashCollectionContainer,
					resolvedTertiaryWashCollectionStorageCondition,resolvedNumberOfTertiaryWashes,resolvedTertiaryWashAirDry,resolvedTertiaryWashAirDryTime,
					resolvedTertiaryWashMixTipType,
					resolvedTertiaryWashMixTipMaterial,

					resolvedQuaternaryWash,resolvedQuaternaryWashBuffer,resolvedQuaternaryWashBufferVolume,resolvedQuaternaryWashMixTime,resolvedQuaternaryWashMixTemperature,resolvedQuaternaryWashMix,resolvedQuaternaryWashMixType,resolvedQuaternaryWashMixRate,
					resolvedQuaternaryWashMixVolume,resolvedNumberOfQuaternaryWashMixes,resolvedQuaternaryWashMagnetizationTime,resolvedQuaternaryWashAspirationVolume,resolvedQuaternaryWashAspirationPosition,resolvedQuaternaryWashAspirationPositionOffset,resolvedQuaternaryWashCollectionContainer,
					resolvedQuaternaryWashCollectionStorageCondition,resolvedNumberOfQuaternaryWashes,resolvedQuaternaryWashAirDry,resolvedQuaternaryWashAirDryTime,
					resolvedQuaternaryWashMixTipType,
					resolvedQuaternaryWashMixTipMaterial,

					resolvedQuinaryWash,resolvedQuinaryWashBuffer,resolvedQuinaryWashBufferVolume,resolvedQuinaryWashMixTime,resolvedQuinaryWashMixTemperature,resolvedQuinaryWashMix,resolvedQuinaryWashMixType,resolvedQuinaryWashMixRate,
					resolvedQuinaryWashMixVolume,resolvedNumberOfQuinaryWashMixes,resolvedQuinaryWashMagnetizationTime,resolvedQuinaryWashAspirationVolume,resolvedQuinaryWashAspirationPosition,resolvedQuinaryWashAspirationPositionOffset,resolvedQuinaryWashCollectionContainer,
					resolvedQuinaryWashCollectionStorageCondition,resolvedNumberOfQuinaryWashes,resolvedQuinaryWashAirDry,resolvedQuinaryWashAirDryTime,
					resolvedQuinaryWashMixTipType,
					resolvedQuinaryWashMixTipMaterial,

					resolvedSenaryWash,resolvedSenaryWashBuffer,resolvedSenaryWashBufferVolume,resolvedSenaryWashMixTime,resolvedSenaryWashMixTemperature,resolvedSenaryWashMix,resolvedSenaryWashMixType,resolvedSenaryWashMixRate,
					resolvedSenaryWashMixVolume,resolvedNumberOfSenaryWashMixes,resolvedSenaryWashMagnetizationTime,resolvedSenaryWashAspirationVolume,resolvedSenaryWashAspirationPosition,resolvedSenaryWashAspirationPositionOffset,resolvedSenaryWashCollectionContainer,
					resolvedSenaryWashCollectionStorageCondition,resolvedNumberOfSenaryWashes,resolvedSenaryWashAirDry,resolvedSenaryWashAirDryTime,
					resolvedSenaryWashMixTipType,
					resolvedSenaryWashMixTipMaterial,

					resolvedSeptenaryWash,resolvedSeptenaryWashBuffer,resolvedSeptenaryWashBufferVolume,resolvedSeptenaryWashMixTime,resolvedSeptenaryWashMixTemperature,resolvedSeptenaryWashMix,resolvedSeptenaryWashMixType,resolvedSeptenaryWashMixRate,
					resolvedSeptenaryWashMixVolume,resolvedNumberOfSeptenaryWashMixes,resolvedSeptenaryWashMagnetizationTime,resolvedSeptenaryWashAspirationVolume,resolvedSeptenaryWashAspirationPosition,resolvedSeptenaryWashAspirationPositionOffset,resolvedSeptenaryWashCollectionContainer,
					resolvedSeptenaryWashCollectionStorageCondition,resolvedNumberOfSeptenaryWashes,resolvedSeptenaryWashAirDry,resolvedSeptenaryWashAirDryTime,
					resolvedSeptenaryWashMixTipType,
					resolvedSeptenaryWashMixTipMaterial,

					resolvedElution,resolvedElutionBuffer,resolvedElutionBufferVolume,resolvedElutionMixTime,resolvedElutionMixTemperature,resolvedElutionMix,resolvedElutionMixType,resolvedElutionMixRate,
					resolvedElutionMixVolume,resolvedNumberOfElutionMixes,resolvedElutionMagnetizationTime,resolvedElutionAspirationVolume,resolvedElutionAspirationPosition,resolvedElutionAspirationPositionOffset,resolvedElutionCollectionContainer,
					resolvedElutionCollectionStorageCondition,resolvedNumberOfElutions,
					resolvedElutionMixTipType,
					resolvedElutionMixTipMaterial,

					sampleContainer,resolvedSampleContainerLabel,resolvedSampleOutLabel
				},

				(*Initialize the error-tracking variables*)
				{
					multipleTargetsWarning,

					preWashMismatchError,preWashAirDryMismatchError,

					equilibrationMismatchError,equilibrationAirDryMismatchError,

					loadingAirDryMismatchError,

					washMismatchError,washAirDryMismatchError,

					secondaryWashMismatchError,secondaryWashAirDryMismatchError,

					tertiaryWashMismatchError,tertiaryWashAirDryMismatchError,

					quaternaryWashMismatchError,quaternaryWashAirDryMismatchError,

					quinaryWashMismatchError,quinaryWashAirDryMismatchError,

					senaryWashMismatchError,senaryWashAirDryMismatchError,

					septenaryWashMismatchError,septenaryWashAirDryMismatchError,

					elutionMismatchError
				}=Table[False,21];

				(*Look up the option values*)
				{
					resolvedPreparation,
					volume,target,analyteAffinityLabel,magneticBeadAffinityLabel,magneticBeads,magneticBeadVolume,
					magneticBeadCollectionStorageCondition,magnetizationRack,

					preWash,preWashBuffer,preWashBufferVolume,preWashMixTime,preWashMixTemperature,preWashMix,preWashMixType,preWashMixRate,
					preWashMixVolume,numberOfPreWashMixes,preWashMagnetizationTime,preWashAspirationVolume,preWashAspirationPosition, preWashAspirationPositionOffset,numberOfPreWashes,
					preWashAirDry,preWashAirDryTime,
					preWashMixTipType,
					preWashMixTipMaterial,
					preWashCollectionStorageCondition,

					equilibration,equilibrationBuffer,equilibrationBufferVolume,equilibrationMixTime,equilibrationMixTemperature,equilibrationMix,equilibrationMixType,equilibrationMixRate,
					equilibrationMixVolume,numberOfEquilibrationMixes,equilibrationMagnetizationTime,equilibrationAspirationVolume,equilibrationAspirationPosition, equilibrationAspirationPositionOffset,
					equilibrationAirDry,equilibrationAirDryTime,
					equilibrationMixTipType,
					equilibrationMixTipMaterial,
					equilibrationCollectionStorageCondition,

					loadingMixTime,loadingMixTemperature,loadingMix,loadingMixType,loadingMixRate,
					loadingMixVolume,numberOfLoadingMixes,loadingMagnetizationTime,loadingAspirationVolume,loadingAspirationPosition, loadingAspirationPositionOffset,
					loadingAirDry,loadingAirDryTime,
					loadingMixTipType,
					loadingMixTipMaterial,
					loadingCollectionStorageCondition,

					wash,washBuffer,washBufferVolume,washMixTime,washMixTemperature,washMix,washMixType,washMixRate,
					washMixVolume,numberOfWashMixes,washMagnetizationTime,washAspirationVolume,washAspirationPosition,washAspirationPositionOffset,numberOfWashes,
					washAirDry,washAirDryTime,
					washMixTipType,
					washMixTipMaterial,
					washCollectionStorageCondition,

					secondaryWash,secondaryWashBuffer,secondaryWashBufferVolume,secondaryWashMixTime,secondaryWashMixTemperature,secondaryWashMix,secondaryWashMixType,secondaryWashMixRate,
					secondaryWashMixVolume,numberOfSecondaryWashMixes,secondaryWashMagnetizationTime,secondaryWashAspirationVolume,secondaryWashAspirationPosition,secondaryWashAspirationPositionOffset,numberOfSecondaryWashes,
					secondaryWashAirDry,secondaryWashAirDryTime,
					secondaryWashMixTipType,
					secondaryWashMixTipMaterial,
					secondaryWashCollectionStorageCondition,

					tertiaryWash,tertiaryWashBuffer,tertiaryWashBufferVolume,tertiaryWashMixTime,tertiaryWashMixTemperature,tertiaryWashMix,tertiaryWashMixType,tertiaryWashMixRate,
					tertiaryWashMixVolume,numberOfTertiaryWashMixes,tertiaryWashMagnetizationTime,tertiaryWashAspirationVolume,tertiaryWashAspirationPosition,tertiaryWashAspirationPositionOffset,numberOfTertiaryWashes,
					tertiaryWashAirDry,tertiaryWashAirDryTime,
					tertiaryWashMixTipType,
					tertiaryWashMixTipMaterial,
					tertiaryWashCollectionStorageCondition,

					quaternaryWash,quaternaryWashBuffer,quaternaryWashBufferVolume,quaternaryWashMixTime,quaternaryWashMixTemperature,quaternaryWashMix,quaternaryWashMixType,quaternaryWashMixRate,
					quaternaryWashMixVolume,numberOfQuaternaryWashMixes,quaternaryWashMagnetizationTime,quaternaryWashAspirationVolume,quaternaryWashAspirationPosition,quaternaryWashAspirationPositionOffset,numberOfQuaternaryWashes,
					quaternaryWashAirDry,quaternaryWashAirDryTime,
					quaternaryWashMixTipType,
					quaternaryWashMixTipMaterial,
					quaternaryWashCollectionStorageCondition,

					quinaryWash,quinaryWashBuffer,quinaryWashBufferVolume,quinaryWashMixTime,quinaryWashMixTemperature,quinaryWashMix,quinaryWashMixType,quinaryWashMixRate,
					quinaryWashMixVolume,numberOfQuinaryWashMixes,quinaryWashMagnetizationTime,quinaryWashAspirationVolume,quinaryWashAspirationPosition,quinaryWashAspirationPositionOffset,numberOfQuinaryWashes,
					quinaryWashAirDry,quinaryWashAirDryTime,
					quinaryWashMixTipType,
					quinaryWashMixTipMaterial,
					quinaryWashCollectionStorageCondition,

					senaryWash,senaryWashBuffer,senaryWashBufferVolume,senaryWashMixTime,senaryWashMixTemperature,senaryWashMix,senaryWashMixType,senaryWashMixRate,
					senaryWashMixVolume,numberOfSenaryWashMixes,senaryWashMagnetizationTime,senaryWashAspirationVolume,senaryWashAspirationPosition,senaryWashAspirationPositionOffset,numberOfSenaryWashes,
					senaryWashAirDry,senaryWashAirDryTime,
					senaryWashMixTipType,
					senaryWashMixTipMaterial,
					senaryWashCollectionStorageCondition,

					septenaryWash,septenaryWashBuffer,septenaryWashBufferVolume,septenaryWashMixTime,septenaryWashMixTemperature,septenaryWashMix,septenaryWashMixType,septenaryWashMixRate,
					septenaryWashMixVolume,numberOfSeptenaryWashMixes,septenaryWashMagnetizationTime,septenaryWashAspirationVolume,septenaryWashAspirationPosition,septenaryWashAspirationPositionOffset,numberOfSeptenaryWashes,
					septenaryWashAirDry,septenaryWashAirDryTime,
					septenaryWashMixTipType,
					septenaryWashMixTipMaterial,
					septenaryWashCollectionStorageCondition,

					elution,elutionBuffer,elutionBufferVolume,elutionMixTime,elutionMixTemperature,elutionMix,elutionMixType,elutionMixRate,
					elutionMixVolume,numberOfElutionMixes,elutionMagnetizationTime,elutionAspirationVolume,elutionAspirationPosition,elutionAspirationPositionOffset,numberOfElutions,
					elutionMixTipType,
					elutionMixTipMaterial,
					elutionCollectionStorageCondition,

					sampleLabel,sampleContainerLabel,sampleOutLabel,

					preWashCollectionContainer,equilibrationCollectionContainer,loadingCollectionContainer,
					washCollectionContainer,secondaryWashCollectionContainer,tertiaryWashCollectionContainer,
					quaternaryWashCollectionContainer,quinaryWashCollectionContainer,senaryWashCollectionContainer,septenaryWashCollectionContainer,elutionCollectionContainer

				}=Lookup[
					myMapThreadOptions,
					{
						Preparation,
						Volume,Target,AnalyteAffinityLabel,MagneticBeadAffinityLabel,MagneticBeads,MagneticBeadVolume,
						MagneticBeadCollectionStorageCondition,MagnetizationRack,

						PreWash,PreWashBuffer,PreWashBufferVolume,
						PreWashMixTime,PreWashMixTemperature,PreWashMix,PreWashMixType,PreWashMixRate,
						PreWashMixVolume,NumberOfPreWashMixes,PreWashMagnetizationTime,PreWashAspirationVolume,PreWashAspirationPosition, PreWashAspirationPositionOffset,NumberOfPreWashes,
						PreWashAirDry,PreWashAirDryTime,
						PreWashMixTipType,
						PreWashMixTipMaterial,
						PreWashCollectionStorageCondition,

						Equilibration,EquilibrationBuffer,EquilibrationBufferVolume,
						EquilibrationMixTime,EquilibrationMixTemperature,EquilibrationMix,EquilibrationMixType,EquilibrationMixRate,
						EquilibrationMixVolume,NumberOfEquilibrationMixes,EquilibrationMagnetizationTime,EquilibrationAspirationVolume,EquilibrationAspirationPosition, EquilibrationAspirationPositionOffset,
						EquilibrationAirDry,EquilibrationAirDryTime,
						EquilibrationMixTipType,
						EquilibrationMixTipMaterial,
						EquilibrationCollectionStorageCondition,

						LoadingMixTime,LoadingMixTemperature,LoadingMix,LoadingMixType,LoadingMixRate,
						LoadingMixVolume,NumberOfLoadingMixes,LoadingMagnetizationTime,LoadingAspirationVolume,LoadingAspirationPosition, LoadingAspirationPositionOffset,
						LoadingAirDry,LoadingAirDryTime,
						LoadingMixTipType,
						LoadingMixTipMaterial,
						LoadingCollectionStorageCondition,

						Wash,WashBuffer,WashBufferVolume,
						WashMixTime,WashMixTemperature,WashMix,WashMixType,WashMixRate,
						WashMixVolume,NumberOfWashMixes,WashMagnetizationTime,WashAspirationVolume,WashAspirationPosition,WashAspirationPositionOffset,NumberOfWashes,
						WashAirDry,WashAirDryTime,
						WashMixTipType,WashMixTipMaterial,
						WashCollectionStorageCondition,

						SecondaryWash,SecondaryWashBuffer,SecondaryWashBufferVolume,
						SecondaryWashMixTime,SecondaryWashMixTemperature,SecondaryWashMix,SecondaryWashMixType,SecondaryWashMixRate,
						SecondaryWashMixVolume,NumberOfSecondaryWashMixes,SecondaryWashMagnetizationTime,SecondaryWashAspirationVolume,SecondaryWashAspirationPosition,SecondaryWashAspirationPositionOffset,NumberOfSecondaryWashes,
						SecondaryWashAirDry,SecondaryWashAirDryTime,
						SecondaryWashMixTipType,SecondaryWashMixTipMaterial,
						SecondaryWashCollectionStorageCondition,

						TertiaryWash,TertiaryWashBuffer,TertiaryWashBufferVolume,
						TertiaryWashMixTime,TertiaryWashMixTemperature,TertiaryWashMix,TertiaryWashMixType,TertiaryWashMixRate,
						TertiaryWashMixVolume,NumberOfTertiaryWashMixes,TertiaryWashMagnetizationTime,TertiaryWashAspirationVolume,TertiaryWashAspirationPosition,TertiaryWashAspirationPositionOffset,NumberOfTertiaryWashes,
						TertiaryWashAirDry,TertiaryWashAirDryTime,
						TertiaryWashMixTipType,TertiaryWashMixTipMaterial,
						TertiaryWashCollectionStorageCondition,

						QuaternaryWash,QuaternaryWashBuffer,QuaternaryWashBufferVolume,
						QuaternaryWashMixTime,QuaternaryWashMixTemperature,QuaternaryWashMix,QuaternaryWashMixType,QuaternaryWashMixRate,
						QuaternaryWashMixVolume,NumberOfQuaternaryWashMixes,QuaternaryWashMagnetizationTime,QuaternaryWashAspirationVolume,QuaternaryWashAspirationPosition,QuaternaryWashAspirationPositionOffset,NumberOfQuaternaryWashes,
						QuaternaryWashAirDry,QuaternaryWashAirDryTime,
						QuaternaryWashMixTipType,QuaternaryWashMixTipMaterial,
						QuaternaryWashCollectionStorageCondition,

						QuinaryWash,QuinaryWashBuffer,QuinaryWashBufferVolume,
						QuinaryWashMixTime,QuinaryWashMixTemperature,QuinaryWashMix,QuinaryWashMixType,QuinaryWashMixRate,
						QuinaryWashMixVolume,NumberOfQuinaryWashMixes,QuinaryWashMagnetizationTime,QuinaryWashAspirationVolume,QuinaryWashAspirationPosition,QuinaryWashAspirationPositionOffset,NumberOfQuinaryWashes,
						QuinaryWashAirDry,QuinaryWashAirDryTime,
						QuinaryWashMixTipType,QuinaryWashMixTipMaterial,
						QuinaryWashCollectionStorageCondition,

						SenaryWash,SenaryWashBuffer,SenaryWashBufferVolume,
						SenaryWashMixTime,SenaryWashMixTemperature,SenaryWashMix,SenaryWashMixType,SenaryWashMixRate,
						SenaryWashMixVolume,NumberOfSenaryWashMixes,SenaryWashMagnetizationTime,SenaryWashAspirationVolume,SenaryWashAspirationPosition,SenaryWashAspirationPositionOffset,NumberOfSenaryWashes,
						SenaryWashAirDry,SenaryWashAirDryTime,
						SenaryWashMixTipType,SenaryWashMixTipMaterial,
						SenaryWashCollectionStorageCondition,

						SeptenaryWash,SeptenaryWashBuffer,SeptenaryWashBufferVolume,
						SeptenaryWashMixTime,SeptenaryWashMixTemperature,SeptenaryWashMix,SeptenaryWashMixType,SeptenaryWashMixRate,
						SeptenaryWashMixVolume,NumberOfSeptenaryWashMixes,SeptenaryWashMagnetizationTime,SeptenaryWashAspirationVolume,SeptenaryWashAspirationPosition,SeptenaryWashAspirationPositionOffset,NumberOfSeptenaryWashes,
						SeptenaryWashAirDry,SeptenaryWashAirDryTime,
						SeptenaryWashMixTipType,SeptenaryWashMixTipMaterial,
						SeptenaryWashCollectionStorageCondition,

						Elution,ElutionBuffer,ElutionBufferVolume,
						ElutionMixTime,ElutionMixTemperature,ElutionMix,ElutionMixType,ElutionMixRate,
						ElutionMixVolume,NumberOfElutionMixes,ElutionMagnetizationTime,ElutionAspirationVolume,ElutionAspirationPosition,ElutionAspirationPositionOffset,NumberOfElutions,
						ElutionMixTipType,ElutionMixTipMaterial,
						ElutionCollectionStorageCondition,

						SampleLabel,SampleContainerLabel, SampleOutLabel,
						PreWashCollectionContainer,EquilibrationCollectionContainer,LoadingCollectionContainer,
						WashCollectionContainer,SecondaryWashCollectionContainer,TertiaryWashCollectionContainer,
						QuaternaryWashCollectionContainer,QuinaryWashCollectionContainer,SenaryWashCollectionContainer,SeptenaryWashCollectionContainer,ElutionCollectionContainer
					}
				];

				(* Resolve Target *)
				resolvedTarget=If[MatchQ[target,Automatic],

					(* If the option is Automatic, resolve it from Analytes *)
						Module[{analytes,uniqueAnalytes},
							analytes=Download[Flatten[Lookup[samplePacket,Analytes]],Object];

							uniqueAnalytes=If[
								(* If AnalyteAffinityLabel is specified by the user,set the target based on SelectionStrategy *)
								MatchQ[analyteAffinityLabel,Except[Automatic]],
								If[MatchQ[selectionStrategy,Positive],
									(*If selectionStrategy is Positive, the target is the analyteAffinityLabel that binds to the beads*)
									analyteAffinityLabel,
									(*If selectionStrategy is Negative, the target is something other than the analyteAffinityLabel that binds to the beads*)
									DeleteCases[DeleteDuplicates[analytes],ObjectP[analyteAffinityLabel]]
								],
								(* Get non-repeated analytes from the sample*)
								DeleteDuplicates[analytes]
							];

							(* Output Null if there is no unique Analytes *)
							Switch[Length[ToList@uniqueAnalytes],
								0,Null,
								(* If there are >1 unique Analytes, resolve it to the first one *)
								_,First[ToList@uniqueAnalytes]
							]
						],
					(*If the option is specified, accept it*)
					target
				];

				(*Resolve AnalyteAffinityLabel*)
				resolvedAnalyteAffinityLabel=If[MatchQ[analyteAffinityLabel,Automatic],
					(*If the option is Automatic, resolve it*)
					Which[
						(*If SeparationMode is Affinity and the SelectionStrategy is Positive, resolve it to resolvedTarget*)
						MatchQ[separationMode,Affinity]&&MatchQ[selectionStrategy,Positive],
						resolvedTarget,
						(*If SeparationMode is Affinity and the SelectionStrategy is Negative, resolve it to the analyte other than the resolvedTarget*)
						MatchQ[separationMode,Affinity]&&MatchQ[selectionStrategy,Negative],
						Module[{analytes,uniqueAnalytes},
							analytes=Download[Flatten[Lookup[samplePacket,Analytes]],Object];
							(*Get the list of no-repeat analytes with resolvedTarget removed*)
							uniqueAnalytes=DeleteCases[DeleteDuplicates[analytes],resolvedTarget];
							(* Output Null if there is no unique Analytes *)
							Switch[Length[uniqueAnalytes],
								0,Null,
								(* If there are >1 unique Analytes, resolve it to the first one *)
								_,First[uniqueAnalytes]
							]
						],
						(*If SeparationMode is not Affinity, resolve it to Null*)
						True,Null
					],
					(*If the option is specified, accept it*)
					analyteAffinityLabel
				];

				(*Resolve MagneticBeadAffinityLabel*)
				resolvedMagneticBeadAffinityLabel=If[MatchQ[magneticBeadAffinityLabel,Automatic],
					(*If the option is Automatic, resolve it*)
					If[MatchQ[resolvedAnalyteAffinityLabel,IdentityModelP],
						(*If resolvedAnalyteAffinityLabel is an identity model, resolve it from Targets*)
						Module[{targets,uniqueTargets},
							targets=Flatten[Download[resolvedAnalyteAffinityLabel,Targets[Object],Cache->simulatedCache]];
							uniqueTargets=DeleteDuplicates[targets];

							Switch[Length[uniqueTargets],
								0,Null,
								1,First[uniqueTargets],
								(*If there are >1 unique Targets, flip the error switch and resolve it to the first one*)
								_,(multipleTargetsWarning=True;First[uniqueTargets])
							]
						],
						(*If resolvedAnalyteAffinityLabel is not an identity model, resolve it to Null*)
						Null
					],
					(*If the option is specified, accept it*)
					magneticBeadAffinityLabel
				];

				(*Resolve MagneticBeads*)
				resolvedMagneticBead = If[MatchQ[magneticBeads, Automatic],
					(*If the option is Automatic, resolve it*)
					Which[
						(*If SeparationMode is Affinity, and magnetic bead affinity label is an identity model,	resolve based on the affinity label*)
						MatchQ[separationMode, Affinity] && MatchQ[resolvedMagneticBeadAffinityLabel, IdentityModelP],
						(*Resolve it to a magnetic beads model with the affinity label*)
						Module[{magneticBeadIdentityModels, magneticBeadSamples},
							magneticBeadIdentityModels =
								Cases[Flatten[allMagneticBeadIdentityModelPackets],
									KeyValuePattern[
										AffinityLabels -> {___,
											ObjectP[resolvedMagneticBeadAffinityLabel], ___}]];
							magneticBeadSamples =
								Cases[Download[magneticBeadIdentityModels,DefaultSampleModel[Object],Cache->simulatedCache],ObjectReferenceP[]];

							Switch[
								Length[magneticBeadSamples],
								(*No bead found with the identity model *)
								0,Model[Sample,"Mag-Bind Particles CNR (Mag-Bind Viral DNA/RNA Kit)"],
								(*If there are>=1 magneticBeadSamples, resolve it to the first one*)
								_, First[magneticBeadSamples]
							]
						],
						(*separationMode is not Affinity, if resolved Target is an identity model,and also is a nucleic acid (DNA/RNA/plasmid), separationMode is NormalPhase*)
						And[MatchQ[resolvedTarget, IdentityModelP],
							Or[
							MatchQ[resolvedTarget,ObjectP[Model[Molecule, Transcript]]|ObjectP[Model[Molecule, cDNA]]],
							MatchQ[resolvedTarget,ObjectP[Model[Molecule, Oligomer]]] && MatchQ[resolvedTarget[PolymerType],DNA | RNA]],
							MatchQ[separationMode, NormalPhase]
						],
						(* Resolve to Dynabeads MyOne SILANE *)
						Model[Sample, "Dynabeads MyOne SILANE Sample"],

						(* separationMode is reverse phase, if resolved Target is an identity model,
						and also is a peptide or protein *)
						And[
							MatchQ[resolvedTarget, IdentityModelP],
							MatchQ[separationMode, ReversePhase],
							Or[
								MatchQ[resolvedTarget,ObjectP[Model[Molecule,Protein]]],
								MatchQ[resolvedTarget,ObjectP[Model[Molecule,Oligomer]]]&&MatchQ[resolvedTarget[PolymerType],Peptide]
							]
						],
						(* Resolve to MagSi-proteomics C4 *)
						Model[Sample, "MagSi-proteomics C4 sample"],

						(* separationMode is IonExchange,if resolved Target is an identity model,and also is a peptide or protein,
						separation mode is not reverse phase *)
						And[
							MatchQ[resolvedTarget, IdentityModelP],
							MatchQ[separationMode, IonExchange],
							Or[
								MatchQ[resolvedTarget,ObjectP[Model[Molecule, Protein]]],
								MatchQ[resolvedTarget,ObjectP[Model[Molecule, Oligomer]]] &&MatchQ[resolvedTarget[PolymerType],Peptide]
							]
						],
						(* Resolve to MagSi-WCX *)
						Model[Sample, "MagSi-WCX sample"],

						(*Otherwise, i.e. if the resolved Target is not an identity model or is neither nucleic acid nor protein/peptdie, resolve to generic kit*)
						True, Model[Sample,"Mag-Bind Particles CNR (Mag-Bind Viral DNA/RNA Kit)"]
					],
					(*If the option is specified,accept it*)
					magneticBeads];

				(*--PreWash--*)

				(*Check that PreWash options aren't in conflict*)
				unresolvedPreWashOptions = {
					preWashBuffer,preWashBufferVolume,preWashMagnetizationTime,preWashAspirationVolume,preWashAspirationPosition, preWashAspirationPositionOffset,numberOfPreWashes,
					preWashAirDry,preWashAirDryTime,preWashMix,preWashMixType,preWashMixTime,preWashMixRate,numberOfPreWashMixes,
					preWashMixVolume,preWashMixTemperature,preWashCollectionContainer,preWashCollectionStorageCondition,
				preWashMixTipType,preWashMixTipMaterial
				};

				If[
					And[
						!MatchQ[preWash,Automatic],
						Or[
							preWash&&MemberQ[{preWashBuffer,preWashBufferVolume,preWashMagnetizationTime,preWashAspirationVolume,numberOfPreWashes, preWashMix,preWashCollectionContainer},Null],
							!preWash&&MemberQ[unresolvedPreWashOptions,Except[ListableP[Automatic]|ListableP[Null]]]
						]
					],
					preWashMismatchError=True
				];

				(*Resolve PreWash*)
				resolvedPreWash=If[MatchQ[preWash,Automatic],
					(*If the option is Automatic, resolve it*)
					If[MemberQ[unresolvedPreWashOptions,Except[ListableP[Automatic]|ListableP[Null]]],
						True,
						False
					],
					(*If the option is specified, accept it*)
					preWash
				];

				(*Resolve PreWashBuffer*)
				resolvedPreWashBuffer=If[MatchQ[preWashBuffer,Automatic],
					(*If the option is Automatic, resolve it*)
					Which[
						(*If resolvedPreWash is True and ElutionBuffer is specified by the user, resolve it to match the elution buffer.*)
						resolvedPreWash && MatchQ[elutionBuffer,Except[Automatic|Null]],
						elutionBuffer,
						(*If resolvedPreWash is True (and ElutionBuffer is not specified by the user), resolve it to Model[Sample,"Milli-Q water"]*)
						resolvedPreWash,
						Model[Sample,"Milli-Q water"],
						(*If resolvedPreWash is False, resolve it to Null*)
						True,Null
					],
					(*If the option is specified, accept it*)
					preWashBuffer
				];

				(*Resolve PreWashBufferVolume*)
				resolvedPreWashBufferVolume=If[MatchQ[preWashBufferVolume,Automatic],
					(*If the option is Automatic, resolve it*)
					If[resolvedPreWash,
						(*If PreWash is True, use the same amount as the sample to wash. *)
						volume,
						(*If PreWash is False, resolve it to Null*)
						Null
					],
					(*If the option is specified, accept it*)
					preWashBufferVolume
				];


				(*Calculate the volume to mix by adding the prewash buffer volume to the bead volume *)
				preWashVolumeToMix = Total[Cases[{magneticBeadVolume, resolvedPreWashBufferVolume}, VolumeP]];

				(* Resolve the Mix options by calling the helper function *)
				{resolvedPreWashMix, resolvedPreWashMixType, resolvedPreWashMixVolume,
					resolvedPreWashMixTime, resolvedPreWashMixTemperature,
					resolvedPreWashMixRate, resolvedNumberOfPreWashMixes,
					resolvedPreWashMixTipType, resolvedPreWashMixTipMaterial} =
						resolveMixOptionsForStage[
							resolvedPreWash, preWashVolumeToMix,
							resolvedPreparation, preWashMix, preWashMixType, preWashMixVolume,
							preWashMixTime, preWashMixTemperature, preWashMixRate,
							numberOfPreWashMixes, preWashMixTipType, preWashMixTipMaterial
						];


				(*Resolve PreWashMagnetizationTime*)
				resolvedPreWashMagnetizationTime=If[MatchQ[preWashMagnetizationTime,Automatic],
					(*If the option is Automatic, resolve it*)
					If[resolvedPreWash,
						(*If PreWash is True, resolve it to 5 minutes*)
						5 Minute,
						(*If PreWash is False, resolve it to Null*)
						Null
					],
					(*If the option is specified, accept it*)
					preWashMagnetizationTime
				];

				(*Resolve PreWashAspirationVolume*)
				resolvedPreWashAspirationVolume=If[MatchQ[preWashAspirationVolume,Automatic],
					(*If the option is Automatic, resolve it*)
					If[resolvedPreWash,
						(*If PreWash is True, resolve based on the preparation option*)
						If[MatchQ[resolvedPreparation,Manual],
							(* If Manual, can use All *)
							All,
							(* If Robotic, use the resolvedPreWashBufferVolume as All is not valid *)
							resolvedPreWashBufferVolume
						],
						(*If PreWash is False, resolve it to Null*)
						Null
					],
					(*If the option is specified, accept it*)
					preWashAspirationVolume
				];
        (*Resolve PreWash aspiration pipetting options*)
        {resolvedPreWashAspirationPosition, resolvedPreWashAspirationPositionOffset} = resolveAspirationPipettingOptionsOfStage[resolvedPreWash,resolvedPreparation,resolvedMagnetizationRackModel,preWashAspirationPosition, preWashAspirationPositionOffset];

				(*Resolve NumberOfPreWashes*)
				resolvedNumberOfPreWashes=If[MatchQ[numberOfPreWashes,Automatic],
					(*If the option is Automatic, resolve it*)
					If[resolvedPreWash,
						(*If PreWash is True, resolve it to the length of the preWashCollectionContainer*)
						Length[preWashCollectionContainer],
						(*If PreWash is False, resolve it to Null*)
						Null
					],
					(*If the option is specified, accept it*)
					numberOfPreWashes
				];

				(*Check that PreWashAirDryTime isn't in conflict with PreWashAirDry*)
				If[
					Or[
						preWashAirDry&&NullQ[preWashAirDryTime],
						!preWashAirDry&&MatchQ[preWashAirDryTime,Except[Automatic|Null]]
					],
					preWashAirDryMismatchError=True
				];

				(*Resolve PreWashAirDry*)
				resolvedPreWashAirDry=If[MatchQ[preWashAirDry,Automatic],
					(*If the option is Automatic, resolve it*)
					Which[
						(* If PreWashAirDryTime is specified, set PreWashAirDry to True. *)
						MatchQ[preWashAirDryTime, TimeP],
							True,
						(*If PreWash is True, resolve it to False*)
						resolvedPreWash,
							False,
						(*If PreWash is False, resolve it to Null*)
						True,
							Null
					],
					(*If the option is specified, accept it*)
					preWashAirDry
				];

				(*Resolve PreWashAirDryTime*)
				resolvedPreWashAirDryTime=If[MatchQ[preWashAirDryTime,Automatic],
					(*If the option is Automatic, resolve it*)
					If[TrueQ[resolvedPreWashAirDry],
						(*If resolvedPreWashAirDry is True, resolve it to 1 minute*)
						1 Minute,
						(*If resolvedPreWashAirDry is not True, resolve it to Null*)
						Null
					],
					(*If the option is specified, accept it*)
					preWashAirDryTime
				];

				(*Resolve PreWashCollectionContainer*)
				(* NOTE: We can have multiple PreWashCollectionContainers if there are multiple NumberOfPreWashes. *)
				resolvedPreWashCollectionContainer=If[MatchQ[preWashCollectionContainer,ListableP[Automatic]],
					(*If the option is Automatic, resolve it*)
					If[resolvedPreWash,
						(*If PreWash is True, resolve it to an appropriate container*)
						Module[{collectionVolume},
							collectionVolume=If[MatchQ[resolvedPreWashAspirationVolume,All],
								resolvedPreWashBufferVolume,
								resolvedPreWashAspirationVolume
							];
							If[MatchQ[collectionVolume,LessEqualP[3.5 Milliliter]],
								(*MaxVolume of all preferred plates is 3.5 mL*)
								(* If volume is less than 2 mL and Preparation->Robotic, default to 2mL Deep well plate *)
								If[MatchQ[collectionVolume,LessEqualP[2.0 Milliliter]]&&MatchQ[resolvedPreparation,Robotic],
									Table[Model[Container, Plate, "id:L8kPEjkmLbvW"],resolvedNumberOfPreWashes], (* 2 mL plate *)
									Table[PreferredContainer[collectionVolume,Type->Plate],resolvedNumberOfPreWashes]
								],
								Table[PreferredContainer[collectionVolume],resolvedNumberOfPreWashes]
							]
						],
						(*If PreWash is False, resolve it to Null*)
						{Null}
					],
					preWashCollectionContainer
				];

				(*Resolve PreWashCollectionStorageCondition*)
				resolvedPreWashCollectionStorageCondition=If[MatchQ[preWashCollectionStorageCondition,Automatic],
					(*If the option is Automatic, resolve it*)
					If[resolvedPreWash,
						(*If PreWash is True, resolve it to Refrigerator*)
						Refrigerator,
						(*If PreWash is False, resolve it to Null*)
						Null
					],
					(*If the option is specified, accept it*)
					preWashCollectionStorageCondition
				];

				(*--Equilibration--*)
				unresolvedEquilibrationOptions = {
					equilibrationBuffer,equilibrationBufferVolume,equilibrationMagnetizationTime,equilibrationAspirationVolume,equilibrationAspirationPosition, equilibrationAspirationPositionOffset,
					equilibrationAirDry,equilibrationAirDryTime,equilibrationMix,equilibrationMixType,equilibrationMixTime,equilibrationMixRate,numberOfEquilibrationMixes,
					equilibrationMixVolume,equilibrationMixTemperature,equilibrationCollectionContainer,equilibrationCollectionStorageCondition,
					equilibrationMixTipType,
					equilibrationMixTipMaterial
				};

				(*Check that Equilibration options aren't in conflict*)
				If[
					And[
						!MatchQ[equilibration,Automatic],
						Or[
							equilibration&&MemberQ[{equilibrationBuffer,equilibrationBufferVolume,equilibrationMagnetizationTime,equilibrationAspirationVolume,equilibrationMix,equilibrationCollectionContainer},Null],
							!equilibration&&MemberQ[unresolvedEquilibrationOptions,Except[ListableP[Automatic]|ListableP[Null]]]
						]
					],
					equilibrationMismatchError=True
				];

				(*Resolve Equilibration*)
				resolvedEquilibration=If[MatchQ[equilibration,Automatic],
					(*If the option is Automatic, resolve it*)
					If[MemberQ[unresolvedEquilibrationOptions,Except[ListableP[Automatic]|ListableP[Null]]],
						True,
						False
					],
					(*If the option is specified, accept it*)
					equilibration
				];

				(*Resolve EquilibrationBuffer*)
				resolvedEquilibrationBuffer=If[MatchQ[equilibrationBuffer,Automatic],
					(*If the option is Automatic, resolve it*)
					If[resolvedEquilibration,
						(*If Equilibration is True, resolve it to Model[Sample,"Milli-Q water"]*)
						Model[Sample,"Milli-Q water"],
						(*If Equilibration is False, resolve it to Null*)
						Null
					],
					(*If the option is specified, accept it*)
					equilibrationBuffer
				];

				(*Resolve EquilibrationBufferVolume*)
				resolvedEquilibrationBufferVolume=If[MatchQ[equilibrationBufferVolume,Automatic],
					(*If the option is Automatic, resolve it*)
					If[resolvedEquilibration,
						(*If Equilibration is True, resolve it to resolvedPreWashBufferVolume*)
						If[VolumeQ[resolvedPreWashBufferVolume],
							resolvedPreWashBufferVolume,
							volume
						],
						(*If Equilibration is False, resolve it to Null*)
						Null
					],
					(*If the option is specified, accept it*)
					equilibrationBufferVolume
				];

				(*Calculate the volume to mix by adding the equilibration buffer volume to the bead volume *)
				equilibrationVolumeToMix = Total[Cases[{magneticBeadVolume, resolvedEquilibrationBufferVolume}, VolumeP]];

				(* Resolve the Mix options by calling the helper function *)
				{resolvedEquilibrationMix, resolvedEquilibrationMixType, resolvedEquilibrationMixVolume,
					resolvedEquilibrationMixTime, resolvedEquilibrationMixTemperature,
					resolvedEquilibrationMixRate, resolvedNumberOfEquilibrationMixes,
					resolvedEquilibrationMixTipType, resolvedEquilibrationMixTipMaterial} =
						resolveMixOptionsForStage[resolvedEquilibration, equilibrationVolumeToMix,
							resolvedPreparation, equilibrationMix, equilibrationMixType, equilibrationMixVolume,
							equilibrationMixTime, equilibrationMixTemperature, equilibrationMixRate,
							numberOfEquilibrationMixes, equilibrationMixTipType, equilibrationMixTipMaterial];

				(*Resolve EquilibrationMagnetizationTime*)
				resolvedEquilibrationMagnetizationTime=If[MatchQ[equilibrationMagnetizationTime,Automatic],
					(*If the option is Automatic, resolve it*)
					If[resolvedEquilibration,
						(*If Equilibration is True, resolve it to 5 minutes*)
						5 Minute,
						(*If Equilibration is False, resolve it to Null*)
						Null
					],
					(*If the option is specified, accept it*)
					equilibrationMagnetizationTime
				];

				(*Resolve EquilibrationAspirationVolume*)
				resolvedEquilibrationAspirationVolume=If[MatchQ[equilibrationAspirationVolume,Automatic],
					(*If the option is Automatic, resolve it*)
					If[resolvedEquilibration,
						(*If Equilibration is True, resolve based on the preparation option*)
						If[MatchQ[resolvedPreparation,Manual],
							(* If Manual, can use All *)
							All,
							(* If Robotic, use the resolvedEquilibrationBufferVolume as All is not valid *)
							resolvedEquilibrationBufferVolume
						],
						(*If Equilibration is False, resolve it to Null*)
						Null
					],
					(*If the option is specified, accept it*)
					equilibrationAspirationVolume
				];
        
        (*Resolve Equilibration aspiration pipetting options*)
        {resolvedEquilibrationAspirationPosition, resolvedEquilibrationAspirationPositionOffset} = resolveAspirationPipettingOptionsOfStage[resolvedEquilibration,resolvedPreparation,resolvedMagnetizationRackModel,equilibrationAspirationPosition, equilibrationAspirationPositionOffset];

				(*Check that EquilibrationAirDryTime isn't in conflict with EquilibrationAirDry*)
				If[
					Or[
						equilibrationAirDry&&NullQ[equilibrationAirDryTime],
						!equilibrationAirDry&&MatchQ[equilibrationAirDryTime,Except[Automatic|Null]]
					],
					equilibrationAirDryMismatchError=True
				];

				(*Resolve EquilibrationAirDry*)
				resolvedEquilibrationAirDry=If[MatchQ[equilibrationAirDry,Automatic],
					(*If the option is Automatic, resolve it*)
					Which[
						(* If EquilibrationAirDryTime is specified, set EquilibrationAirDry to True. *)
						MatchQ[equilibrationAirDryTime, TimeP],
							True,
						(*If Equilibration is True, resolve it to False*)
						resolvedEquilibration,
							False,
						(*If Equilibration is False, resolve it to Null*)
						True,
							Null
					],
					(*If the option is specified, accept it*)
					equilibrationAirDry
				];

				(*Resolve EquilibrationAirDryTime*)
				resolvedEquilibrationAirDryTime=If[MatchQ[equilibrationAirDryTime,Automatic],
					(*If the option is Automatic, resolve it*)
					If[TrueQ[resolvedEquilibrationAirDry],
						(*If resolvedEquilibrationAirDry is True, resolve it to 1 minute*)
						1 Minute,
						(*If resolvedEquilibrationAirDry is not True, resolve it to Null*)
						Null
					],
					(*If the option is specified, accept it*)
					equilibrationAirDryTime
				];

				(*Resolve EquilibrationCollectionContainer*)
				(* NOTE: We do not have multiple rounds of Equilibration so we can only have one equilibration collection container per sample. *)
				(* However, due to the way the option is expanded in expandIndexMatchedInputsHelper, this will still be a list *)
				resolvedEquilibrationCollectionContainer=If[MatchQ[equilibrationCollectionContainer,ListableP[Automatic]],
					(*If the option is Automatic, resolve it*)
					If[resolvedEquilibration,
						(*If Equilibration is True, resolve it to an appropriate container*)
						Module[{collectionVolume},
							collectionVolume=If[MatchQ[resolvedEquilibrationAspirationVolume,All],
								resolvedEquilibrationBufferVolume,
								resolvedEquilibrationAspirationVolume
							];
							If[MatchQ[collectionVolume,LessEqualP[3.5 Milliliter]],
								(*MaxVolume of all preferred plates is 3.5 mL*)
								(* If volume is less than 2 mL and Preparation->Robotic, default to 2mL Deep well plate *)
								If[MatchQ[collectionVolume,LessEqualP[2.0 Milliliter]]&&MatchQ[resolvedPreparation,Robotic],
									Table[Model[Container, Plate, "id:L8kPEjkmLbvW"],1], (* 2 mL plate *)
									Table[PreferredContainer[collectionVolume,Type->Plate],1]
								],
								Table[PreferredContainer[collectionVolume],1]
							]
						],
						(*If Equilibration is False, resolve it to Null*)
						{Null}
					],
					(*If the option is specified accept it*)
					equilibrationCollectionContainer
				];

				(*Resolve EquilibrationCollectionStorageCondition*)
				resolvedEquilibrationCollectionStorageCondition=If[MatchQ[equilibrationCollectionStorageCondition,Automatic],
					(*If the option is Automatic, resolve it*)
					If[resolvedEquilibration,
						(*If Equilibration is True, resolve it to Refrigerator*)
						Refrigerator,
						(*If Equilibration is False, resolve it to Null*)
						Null
					],
					(*If the option is specified, accept it*)
					equilibrationCollectionStorageCondition
				];

				(*--Loading--*)

			(*Calculate the volume to mix by adding the sample volume to the bead volume *)
			loadingVolumeToMix = Total[Cases[{magneticBeadVolume, volume}, VolumeP]];

			(* Resolve the Mix options by calling the helper function *)
			{resolvedLoadingMix, resolvedLoadingMixType, resolvedLoadingMixVolume,
				resolvedLoadingMixTime, resolvedLoadingMixTemperature,
				resolvedLoadingMixRate, resolvedNumberOfLoadingMixes,
				resolvedLoadingMixTipType, resolvedLoadingMixTipMaterial} =
					resolveMixOptionsForStage[True,loadingVolumeToMix,
						resolvedPreparation, loadingMix, loadingMixType, loadingMixVolume,
						loadingMixTime, loadingMixTemperature, loadingMixRate,
						numberOfLoadingMixes, loadingMixTipType, loadingMixTipMaterial];

				(*Resolve LoadingCollectionContainer*)
				(* NOTE: There is only one round of loading so there is only one loading collection container per sample. *)
				(* However, due to the way the option is expanded in expandIndexMatchedInputsHelper, this will still be a list *)
				resolvedLoadingCollectionContainer=If[MatchQ[loadingCollectionContainer,ListableP[Automatic]],
					(*If the option is Automatic, resolve it*)
					Module[{collectionVolume},
						collectionVolume=If[MatchQ[loadingAspirationVolume,Automatic|All],
							volume,
							loadingAspirationVolume
						];
						If[MatchQ[collectionVolume,LessEqualP[3.5 Milliliter]],
							(*MaxVolume of all preferred plates is 3.5 mL*)
							(* If volume is less than 2 mL and Preparation->Robotic, default to 2mL Deep well plate *)
							If[MatchQ[collectionVolume,LessEqualP[2.0 Milliliter]]&&MatchQ[resolvedPreparation,Robotic],
								Table[Model[Container, Plate, "id:L8kPEjkmLbvW"],1], (* 2 mL plate *)
								Table[PreferredContainer[collectionVolume,Type->Plate],1]
							],
							Table[PreferredContainer[collectionVolume],1]
						]
					],
					(*If the option is specified, accept it*)
					loadingCollectionContainer
				];

				(*Resolve LoadingCollectionStorageCondition*)
				resolvedLoadingCollectionStorageCondition=If[MatchQ[loadingCollectionStorageCondition,Automatic],
					(*If the option is Automatic, resolve it*)
					Refrigerator,
					(*If the option is specified, accept it*)
					loadingCollectionStorageCondition
				];

				(*Check that LoadingAirDryTime isn't in conflict with LoadingAirDry*)
				If[
					MatchQ[
						Or[
							loadingAirDry&&NullQ[loadingAirDryTime],
							!loadingAirDry&&MatchQ[loadingAirDryTime,Except[Automatic|Null]]
						],
						True
					],
					loadingAirDryMismatchError=True
				];

				(*Resolve LoadingAirDry*)
				resolvedLoadingAirDry=If[MatchQ[loadingAirDry,Automatic],
					(*If the option is Automatic, it is set to true*)
					True,
					(*If the option is specified, accept it*)
					loadingAirDry
				];

				(*Resolve LoadingAirDryTime*)
				resolvedLoadingAirDryTime=If[MatchQ[loadingAirDryTime,Automatic],
						(*If the option is Automatic, resolve it*)
						If[TrueQ[loadingAirDry],
							1 Minute,
							Null
						],
						(*If the option is specified, accept it*)
						loadingAirDryTime
				];

				(* resolve LoadingAspirationVolume *)
				resolvedLoadingAspirationVolume=If[MatchQ[loadingAspirationVolume,Automatic],
					(* If the option is Automatic, resolve it based on the resolvedPreparation as Robotic preparation
					 cannot take All as the amount *)
					If[MatchQ[resolvedPreparation,Manual],
						(* If the preparation is Manual, resolve to All *)
						All,
						(* If the preparation is Robotic, resolve to the amount to be transferred in *)
						volume
					],
					(* If the option is specified, leave it *)
					loadingAspirationVolume
				];

        (*Resolve Loading aspiration pipetting options*)
        {resolvedLoadingAspirationPosition, resolvedLoadingAspirationPositionOffset} = resolveAspirationPipettingOptionsOfStage[True,resolvedPreparation,resolvedMagnetizationRackModel,loadingAspirationPosition, loadingAspirationPositionOffset];

				(*Resolve LoadingMagnetizationTime*)
				resolvedLoadingMagnetizationTime=If[MatchQ[loadingMagnetizationTime,Automatic],
					(*If the option is Automatic, resolve it*)
					5 Minute,
					(*If the option is specified, accept it*)
					loadingMagnetizationTime
				];

				(*--Wash--*)
				unresolvedWashOptions = {
					washBuffer,washBufferVolume,washMagnetizationTime,washAspirationVolume,washAspirationPosition,washAspirationPositionOffset,numberOfWashes,
					washAirDry,washAirDryTime,washMix,washMixType,washMixTime,washMixRate,numberOfWashMixes,
					washMixVolume,washMixTemperature,washCollectionContainer,washCollectionStorageCondition,
					washMixTipType,washMixTipMaterial
				};

				(*Check that Wash options aren't in conflict*)
				If[
					And[
						!MatchQ[wash,Automatic],
						Or[
							wash&&MemberQ[{washBuffer,washBufferVolume,washMagnetizationTime,washAspirationVolume,numberOfWashes, washMix,washCollectionContainer},Null],
							!wash&&MemberQ[unresolvedWashOptions,Except[ListableP[Automatic]|ListableP[Null]]]
						]
					],
					washMismatchError=True
				];

				(*Resolve Wash*)
				resolvedWash=If[MatchQ[wash,Automatic],
					(*If the option is Automatic, resolve it*)
					If[MemberQ[unresolvedWashOptions,Except[ListableP[Automatic]|ListableP[Null]]],
						True,
						False
					],
					(*If the option is specified, accept it*)
					wash
				];

				(*Call the helper function to resolve options of the wash stage, excluding mix options*)
				{resolvedWashBuffer,resolvedWashBufferVolume,resolvedWashMagnetizationTime,resolvedWashAspirationVolume,resolvedNumberOfWashes,resolvedWashCollectionContainer,resolvedWashCollectionStorageCondition,resolvedWashAirDry,resolvedWashAirDryTime}=resolveWashStageOptions[resolvedWash,resolvedPreparation,resolvedPreWashBufferVolume,volume,washBuffer,washBufferVolume,washMagnetizationTime,washAspirationVolume, numberOfWashes, washCollectionContainer,washCollectionStorageCondition,washAirDry,washAirDryTime];

				(*Calculate the volume to mix by adding the wash buffer volume to the bead volume *)
				washVolumeToMix = Total[Cases[{magneticBeadVolume, resolvedWashBufferVolume}, VolumeP]];

				(* Resolve the Mix options by calling the helper function *)
				{resolvedWashMix, resolvedWashMixType, resolvedWashMixVolume,
					resolvedWashMixTime, resolvedWashMixTemperature,
					resolvedWashMixRate, resolvedNumberOfWashMixes,
					resolvedWashMixTipType, resolvedWashMixTipMaterial} =
					resolveMixOptionsForStage[resolvedWash, washVolumeToMix,
						resolvedPreparation, washMix, washMixType, washMixVolume,
						washMixTime, washMixTemperature, washMixRate,
						numberOfWashMixes, washMixTipType, washMixTipMaterial];
        
        (*Resolve Wash aspiration pipetting options*)
        {resolvedWashAspirationPosition, resolvedWashAspirationPositionOffset} = resolveAspirationPipettingOptionsOfStage[resolvedWash,resolvedPreparation,resolvedMagnetizationRackModel,washAspirationPosition, washAspirationPositionOffset];

				(*Check that WashAirDryTime isn't in conflict with WashAirDry*)
				If[
					Or[
						washAirDry&&NullQ[washAirDryTime],
						!washAirDry&&MatchQ[washAirDryTime,Except[Automatic|Null]]
					],
					washAirDryMismatchError=True
				];

				(*--SecondaryWash--*)
				unresolvedSecondaryWashOptions = {
					secondaryWashBuffer,secondaryWashBufferVolume,secondaryWashMagnetizationTime,secondaryWashAspirationVolume,secondaryWashAspirationPosition,secondaryWashAspirationPositionOffset,numberOfSecondaryWashes,
					secondaryWashAirDry,secondaryWashAirDryTime,secondaryWashMix,secondaryWashMixType,secondaryWashMixTime,secondaryWashMixRate,numberOfSecondaryWashMixes,
					secondaryWashMixVolume,secondaryWashMixTemperature,secondaryWashCollectionContainer,secondaryWashCollectionStorageCondition,
					secondaryWashMixTipType,secondaryWashMixTipMaterial
				};

				(*Check that SecondaryWash options aren't in conflict*)
				If[
					And[
						!MatchQ[secondaryWash,Automatic],
						Or[
							secondaryWash&&MemberQ[{secondaryWashBuffer,secondaryWashBufferVolume,secondaryWashMagnetizationTime,secondaryWashAspirationVolume,numberOfSecondaryWashes, secondaryWashMix,secondaryWashCollectionContainer},Null],
							!secondaryWash&&MemberQ[unresolvedSecondaryWashOptions,Except[ListableP[Automatic]|ListableP[Null]]]
						]
					],
					secondaryWashMismatchError=True
				];

				(*Resolve SecondaryWash*)
				resolvedSecondaryWash=If[MatchQ[secondaryWash,Automatic],
					(*If the option is Automatic, resolve it*)
					If[MemberQ[unresolvedSecondaryWashOptions,Except[ListableP[Automatic]|ListableP[Null]]],
						True,
						False
					],
					(*If the option is specified, accept it*)
					secondaryWash
				];

				(*Call the helper function to resolve options of the wash stage, excluding mix options*)
				{resolvedSecondaryWashBuffer,resolvedSecondaryWashBufferVolume,resolvedSecondaryWashMagnetizationTime,resolvedSecondaryWashAspirationVolume,resolvedNumberOfSecondaryWashes,resolvedSecondaryWashCollectionContainer,resolvedSecondaryWashCollectionStorageCondition,resolvedSecondaryWashAirDry,resolvedSecondaryWashAirDryTime}=resolveWashStageOptions[resolvedSecondaryWash,resolvedPreparation,resolvedPreWashBufferVolume,volume,secondaryWashBuffer,secondaryWashBufferVolume,secondaryWashMagnetizationTime,secondaryWashAspirationVolume, numberOfSecondaryWashes, secondaryWashCollectionContainer,secondaryWashCollectionStorageCondition,secondaryWashAirDry,secondaryWashAirDryTime];

        (*Resolve SecondaryWash aspiration pipetting options*)
        {resolvedSecondaryWashAspirationPosition, resolvedSecondaryWashAspirationPositionOffset} = resolveAspirationPipettingOptionsOfStage[resolvedSecondaryWash,resolvedPreparation,resolvedMagnetizationRackModel,secondaryWashAspirationPosition, secondaryWashAspirationPositionOffset];

				(*Calculate the volume to mix by adding the secondaryWash buffer volume to the bead volume *)
				secondaryWashVolumeToMix = Total[Cases[{magneticBeadVolume, resolvedSecondaryWashBufferVolume}, VolumeP]];

				(* Resolve the Mix options by calling the helper function *)
				{resolvedSecondaryWashMix, resolvedSecondaryWashMixType, resolvedSecondaryWashMixVolume,
					resolvedSecondaryWashMixTime, resolvedSecondaryWashMixTemperature,
					resolvedSecondaryWashMixRate, resolvedNumberOfSecondaryWashMixes,
					resolvedSecondaryWashMixTipType, resolvedSecondaryWashMixTipMaterial} =
					resolveMixOptionsForStage[resolvedSecondaryWash, secondaryWashVolumeToMix,
						resolvedPreparation, secondaryWashMix, secondaryWashMixType, secondaryWashMixVolume,
						secondaryWashMixTime, secondaryWashMixTemperature, secondaryWashMixRate,
						numberOfSecondaryWashMixes, secondaryWashMixTipType, secondaryWashMixTipMaterial];

				(*Check that SecondaryWashAirDryTime isn't in conflict with SecondaryWashAirDry*)
				If[
					Or[
						secondaryWashAirDry&&NullQ[secondaryWashAirDryTime],
						!secondaryWashAirDry&&MatchQ[secondaryWashAirDryTime,Except[Automatic|Null]]
					],
					secondaryWashAirDryMismatchError=True
				];

				(*--TertiaryWash--*)
				unresolvedTertiaryWashOptions = {
					tertiaryWashBuffer,tertiaryWashBufferVolume,tertiaryWashMagnetizationTime,tertiaryWashAspirationVolume,tertiaryWashAspirationPosition,tertiaryWashAspirationPositionOffset,numberOfTertiaryWashes,
					tertiaryWashAirDry,tertiaryWashAirDryTime,tertiaryWashMix,tertiaryWashMixType,tertiaryWashMixTime,tertiaryWashMixRate,numberOfTertiaryWashMixes,
					tertiaryWashMixVolume,tertiaryWashMixTemperature,tertiaryWashCollectionContainer,tertiaryWashCollectionStorageCondition,
					tertiaryWashMixTipType,tertiaryWashMixTipMaterial
				};

				(*Check that TertiaryWash options aren't in conflict*)
				If[
					And[
						!MatchQ[tertiaryWash,Automatic],
						Or[
							tertiaryWash&&MemberQ[{tertiaryWashBuffer,tertiaryWashBufferVolume,tertiaryWashMagnetizationTime,tertiaryWashAspirationVolume,numberOfTertiaryWashes, tertiaryWashMix,tertiaryWashCollectionContainer},Null],
							!tertiaryWash&&MemberQ[unresolvedTertiaryWashOptions,Except[ListableP[Automatic]|ListableP[Null]]]
						]
					],
					tertiaryWashMismatchError=True
				];

				(*Resolve TertiaryWash*)
				resolvedTertiaryWash=If[MatchQ[tertiaryWash,Automatic],
					(*If the option is Automatic, resolve it*)
					If[MemberQ[unresolvedTertiaryWashOptions,Except[ListableP[Automatic]|ListableP[Null]]],
						True,
						False
					],
					(*If the option is specified, accept it*)
					tertiaryWash
				];

				(*Call the helper function to resolve options of the wash stage, excluding mix options*)
				{resolvedTertiaryWashBuffer,resolvedTertiaryWashBufferVolume,resolvedTertiaryWashMagnetizationTime,resolvedTertiaryWashAspirationVolume,resolvedNumberOfTertiaryWashes,resolvedTertiaryWashCollectionContainer,resolvedTertiaryWashCollectionStorageCondition,resolvedTertiaryWashAirDry,resolvedTertiaryWashAirDryTime}=resolveWashStageOptions[resolvedTertiaryWash,resolvedPreparation,resolvedPreWashBufferVolume,volume,tertiaryWashBuffer,tertiaryWashBufferVolume,tertiaryWashMagnetizationTime,tertiaryWashAspirationVolume, numberOfTertiaryWashes, tertiaryWashCollectionContainer,tertiaryWashCollectionStorageCondition,tertiaryWashAirDry,tertiaryWashAirDryTime];

        (*Resolve TertiaryWash aspiration pipetting options*)
        {resolvedTertiaryWashAspirationPosition, resolvedTertiaryWashAspirationPositionOffset} = resolveAspirationPipettingOptionsOfStage[resolvedTertiaryWash,resolvedPreparation,resolvedMagnetizationRackModel,tertiaryWashAspirationPosition, tertiaryWashAspirationPositionOffset];

				(*Calculate the volume to mix by adding the tertiaryWash buffer volume to the bead volume *)
				tertiaryWashVolumeToMix = Total[Cases[{magneticBeadVolume, resolvedTertiaryWashBufferVolume}, VolumeP]];

				(* Resolve the Mix options by calling the helper function *)
				{resolvedTertiaryWashMix, resolvedTertiaryWashMixType, resolvedTertiaryWashMixVolume,
					resolvedTertiaryWashMixTime, resolvedTertiaryWashMixTemperature,
					resolvedTertiaryWashMixRate, resolvedNumberOfTertiaryWashMixes,
					resolvedTertiaryWashMixTipType, resolvedTertiaryWashMixTipMaterial} =
					resolveMixOptionsForStage[resolvedTertiaryWash, tertiaryWashVolumeToMix,
						resolvedPreparation, tertiaryWashMix, tertiaryWashMixType, tertiaryWashMixVolume,
						tertiaryWashMixTime, tertiaryWashMixTemperature, tertiaryWashMixRate,
						numberOfTertiaryWashMixes, tertiaryWashMixTipType, tertiaryWashMixTipMaterial];

				(*Check that TertiaryWashAirDryTime isn't in conflict with TertiaryWashAirDry*)
				If[
					Or[
						tertiaryWashAirDry&&NullQ[tertiaryWashAirDryTime],
						!tertiaryWashAirDry&&MatchQ[tertiaryWashAirDryTime,Except[Automatic|Null]]
					],
					tertiaryWashAirDryMismatchError=True
				];

				(*--QuaternaryWash--*)
				unresolvedQuaternaryWashOptions = {
					quaternaryWashBuffer,quaternaryWashBufferVolume,quaternaryWashMagnetizationTime,quaternaryWashAspirationVolume,quaternaryWashAspirationPosition,quaternaryWashAspirationPositionOffset,numberOfQuaternaryWashes,
					quaternaryWashAirDry,quaternaryWashAirDryTime,quaternaryWashMix,quaternaryWashMixType,quaternaryWashMixTime,quaternaryWashMixRate,numberOfQuaternaryWashMixes,
					quaternaryWashMixVolume,quaternaryWashMixTemperature,quaternaryWashCollectionContainer,quaternaryWashCollectionStorageCondition,
					quaternaryWashMixTipType,quaternaryWashMixTipMaterial
				};

				(*Check that QuaternaryWash options aren't in conflict*)
				If[
					And[
						!MatchQ[quaternaryWash,Automatic],
						Or[
							quaternaryWash&&MemberQ[{quaternaryWashBuffer,quaternaryWashBufferVolume,quaternaryWashMagnetizationTime,quaternaryWashAspirationVolume,numberOfQuaternaryWashes, quaternaryWashMix,quaternaryWashCollectionContainer},Null],
							!quaternaryWash&&MemberQ[unresolvedQuaternaryWashOptions,Except[ListableP[Automatic]|ListableP[Null]]]
						]
					],
					quaternaryWashMismatchError=True
				];

				(*Resolve QuaternaryWash*)
				resolvedQuaternaryWash=If[MatchQ[quaternaryWash,Automatic],
					(*If the option is Automatic, resolve it*)
					If[MemberQ[unresolvedQuaternaryWashOptions,Except[ListableP[Automatic]|ListableP[Null]]],
						True,
						False
					],
					(*If the option is specified, accept it*)
					quaternaryWash
				];

				(*Call the helper function to resolve options of the wash stage, excluding mix options*)
				{resolvedQuaternaryWashBuffer,resolvedQuaternaryWashBufferVolume,resolvedQuaternaryWashMagnetizationTime,resolvedQuaternaryWashAspirationVolume,resolvedNumberOfQuaternaryWashes,resolvedQuaternaryWashCollectionContainer,resolvedQuaternaryWashCollectionStorageCondition,resolvedQuaternaryWashAirDry,resolvedQuaternaryWashAirDryTime}=resolveWashStageOptions[resolvedQuaternaryWash,resolvedPreparation,resolvedPreWashBufferVolume,volume,quaternaryWashBuffer,quaternaryWashBufferVolume,quaternaryWashMagnetizationTime,quaternaryWashAspirationVolume, numberOfQuaternaryWashes, quaternaryWashCollectionContainer,quaternaryWashCollectionStorageCondition,quaternaryWashAirDry,quaternaryWashAirDryTime];

        (*Resolve QuaternaryWash aspiration pipetting options*)
        {resolvedQuaternaryWashAspirationPosition, resolvedQuaternaryWashAspirationPositionOffset} = resolveAspirationPipettingOptionsOfStage[resolvedQuaternaryWash,resolvedPreparation,resolvedMagnetizationRackModel,quaternaryWashAspirationPosition, quaternaryWashAspirationPositionOffset];

				(*Calculate the volume to mix by adding the quaternaryWash buffer volume to the bead volume *)
				quaternaryWashVolumeToMix = Total[Cases[{magneticBeadVolume, resolvedQuaternaryWashBufferVolume}, VolumeP]];

				(* Resolve the Mix options by calling the helper function *)
				{resolvedQuaternaryWashMix, resolvedQuaternaryWashMixType, resolvedQuaternaryWashMixVolume,
					resolvedQuaternaryWashMixTime, resolvedQuaternaryWashMixTemperature,
					resolvedQuaternaryWashMixRate, resolvedNumberOfQuaternaryWashMixes,
					resolvedQuaternaryWashMixTipType, resolvedQuaternaryWashMixTipMaterial} =
						resolveMixOptionsForStage[resolvedQuaternaryWash, quaternaryWashVolumeToMix,
							resolvedPreparation, quaternaryWashMix, quaternaryWashMixType, quaternaryWashMixVolume,
							quaternaryWashMixTime, quaternaryWashMixTemperature, quaternaryWashMixRate,
							numberOfQuaternaryWashMixes, quaternaryWashMixTipType, quaternaryWashMixTipMaterial];

				(*Check that QuaternaryWashAirDryTime isn't in conflict with QuaternaryWashAirDry*)
				If[
					Or[
						quaternaryWashAirDry&&NullQ[quaternaryWashAirDryTime],
						!quaternaryWashAirDry&&MatchQ[quaternaryWashAirDryTime,Except[Automatic|Null]]
					],
					quaternaryWashAirDryMismatchError=True
				];

				(*--QuinaryWash--*)
				unresolvedQuinaryWashOptions = {
					quinaryWashBuffer,quinaryWashBufferVolume,quinaryWashMagnetizationTime,quinaryWashAspirationVolume,quinaryWashAspirationPosition,quinaryWashAspirationPositionOffset,numberOfQuinaryWashes,
					quinaryWashAirDry,quinaryWashAirDryTime,quinaryWashMix,quinaryWashMixType,quinaryWashMixTime,quinaryWashMixRate,numberOfQuinaryWashMixes,
					quinaryWashMixVolume,quinaryWashMixTemperature,quinaryWashCollectionContainer,quinaryWashCollectionStorageCondition,
					quinaryWashMixTipType,quinaryWashMixTipMaterial
				};

				(*Check that QuinaryWash options aren't in conflict*)
				If[
					And[
						!MatchQ[quinaryWash,Automatic],
						Or[
							quinaryWash&&MemberQ[{quinaryWashBuffer,quinaryWashBufferVolume,quinaryWashMagnetizationTime,quinaryWashAspirationVolume,numberOfQuinaryWashes, quinaryWashMix,quinaryWashCollectionContainer},Null],
							!quinaryWash&&MemberQ[unresolvedQuinaryWashOptions,Except[ListableP[Automatic]|ListableP[Null]]]
						]
					],
					quinaryWashMismatchError=True
				];

				(*Resolve QuinaryWash*)
				resolvedQuinaryWash=If[MatchQ[quinaryWash,Automatic],
					(*If the option is Automatic, resolve it*)
					If[MemberQ[unresolvedQuinaryWashOptions,Except[ListableP[Automatic]|ListableP[Null]]],
						True,
						False
					],
					(*If the option is specified, accept it*)
					quinaryWash
				];

				(*Call the helper function to resolve options of the wash stage, excluding mix options*)
				{resolvedQuinaryWashBuffer,resolvedQuinaryWashBufferVolume,resolvedQuinaryWashMagnetizationTime,resolvedQuinaryWashAspirationVolume,resolvedNumberOfQuinaryWashes,resolvedQuinaryWashCollectionContainer,resolvedQuinaryWashCollectionStorageCondition,resolvedQuinaryWashAirDry,resolvedQuinaryWashAirDryTime}=resolveWashStageOptions[resolvedQuinaryWash,resolvedPreparation,resolvedPreWashBufferVolume,volume,quinaryWashBuffer,quinaryWashBufferVolume,quinaryWashMagnetizationTime,quinaryWashAspirationVolume, numberOfQuinaryWashes, quinaryWashCollectionContainer,quinaryWashCollectionStorageCondition,quinaryWashAirDry,quinaryWashAirDryTime];

        (*Resolve QuinaryWash aspiration pipetting options*)
        {resolvedQuinaryWashAspirationPosition, resolvedQuinaryWashAspirationPositionOffset} = resolveAspirationPipettingOptionsOfStage[resolvedQuinaryWash,resolvedPreparation,resolvedMagnetizationRackModel,quinaryWashAspirationPosition, quinaryWashAspirationPositionOffset];

				(*Calculate the volume to mix by adding the quinaryWash buffer volume to the bead volume *)
					quinaryWashVolumeToMix = Total[Cases[{magneticBeadVolume, resolvedQuinaryWashBufferVolume}, VolumeP]];

				(* Resolve the Mix options by calling the helper function *)
				{resolvedQuinaryWashMix, resolvedQuinaryWashMixType, resolvedQuinaryWashMixVolume,
					resolvedQuinaryWashMixTime, resolvedQuinaryWashMixTemperature,
					resolvedQuinaryWashMixRate, resolvedNumberOfQuinaryWashMixes,
					resolvedQuinaryWashMixTipType, resolvedQuinaryWashMixTipMaterial} =
					resolveMixOptionsForStage[resolvedQuinaryWash, quinaryWashVolumeToMix,
						resolvedPreparation, quinaryWashMix, quinaryWashMixType, quinaryWashMixVolume,
						quinaryWashMixTime, quinaryWashMixTemperature, quinaryWashMixRate,
						numberOfQuinaryWashMixes, quinaryWashMixTipType, quinaryWashMixTipMaterial];

				(*Check that QuinaryWashAirDryTime isn't in conflict with QuinaryWashAirDry*)
				If[
					Or[
						quinaryWashAirDry&&NullQ[quinaryWashAirDryTime],
						!quinaryWashAirDry&&MatchQ[quinaryWashAirDryTime,Except[Automatic|Null]]
					],
					quinaryWashAirDryMismatchError=True
				];

				(*--SenaryWash--*)
				unresolvedSenaryWashOptions = {
					senaryWashBuffer,senaryWashBufferVolume,senaryWashMagnetizationTime,senaryWashAspirationVolume,senaryWashAspirationPosition,senaryWashAspirationPositionOffset,numberOfSenaryWashes,
					senaryWashAirDry,senaryWashAirDryTime,senaryWashMix,senaryWashMixType,senaryWashMixTime,senaryWashMixRate,numberOfSenaryWashMixes,
					senaryWashMixVolume,senaryWashMixTemperature,senaryWashCollectionContainer,senaryWashCollectionStorageCondition,
					senaryWashMixTipType,senaryWashMixTipMaterial
				};

				(*Check that SenaryWash options aren't in conflict*)
				If[
					And[
						!MatchQ[senaryWash,Automatic],
						Or[
							senaryWash&&MemberQ[{senaryWashBuffer,senaryWashBufferVolume,senaryWashMagnetizationTime,senaryWashAspirationVolume,numberOfSenaryWashes,senaryWashMix,senaryWashCollectionContainer},Null],
							!senaryWash&&MemberQ[unresolvedSenaryWashOptions,Except[ListableP[Automatic]|ListableP[Null]]]
						]
					],
					senaryWashMismatchError=True
				];

				(*Resolve SenaryWash*)
				resolvedSenaryWash=If[MatchQ[senaryWash,Automatic],
					(*If the option is Automatic, resolve it*)
					If[MemberQ[unresolvedSenaryWashOptions,Except[ListableP[Automatic]|ListableP[Null]]],
						True,
						False
					],
					(*If the option is specified, accept it*)
					senaryWash
				];

				(*Call the helper function to resolve options of the wash stage, excluding mix options*)
				{resolvedSenaryWashBuffer,resolvedSenaryWashBufferVolume,resolvedSenaryWashMagnetizationTime,resolvedSenaryWashAspirationVolume,resolvedNumberOfSenaryWashes,resolvedSenaryWashCollectionContainer,resolvedSenaryWashCollectionStorageCondition,resolvedSenaryWashAirDry,resolvedSenaryWashAirDryTime}=resolveWashStageOptions[resolvedSenaryWash,resolvedPreparation,resolvedPreWashBufferVolume,volume,senaryWashBuffer,senaryWashBufferVolume,senaryWashMagnetizationTime,senaryWashAspirationVolume, numberOfSenaryWashes, senaryWashCollectionContainer,senaryWashCollectionStorageCondition,senaryWashAirDry,senaryWashAirDryTime];

        (*Resolve SenaryWash aspiration pipetting options*)
        {resolvedSenaryWashAspirationPosition, resolvedSenaryWashAspirationPositionOffset} = resolveAspirationPipettingOptionsOfStage[resolvedSenaryWash,resolvedPreparation,resolvedMagnetizationRackModel,senaryWashAspirationPosition, senaryWashAspirationPositionOffset];

				(*Calculate the volume to mix by adding the senaryWash buffer volume to the bead volume *)
				senaryWashVolumeToMix = Total[Cases[{magneticBeadVolume, resolvedSenaryWashBufferVolume}, VolumeP]];

				(* Resolve the Mix options by calling the helper function *)
				{resolvedSenaryWashMix, resolvedSenaryWashMixType, resolvedSenaryWashMixVolume,
					resolvedSenaryWashMixTime, resolvedSenaryWashMixTemperature,
					resolvedSenaryWashMixRate, resolvedNumberOfSenaryWashMixes,
					resolvedSenaryWashMixTipType, resolvedSenaryWashMixTipMaterial} =
					resolveMixOptionsForStage[resolvedSenaryWash, senaryWashVolumeToMix,
						resolvedPreparation, senaryWashMix, senaryWashMixType, senaryWashMixVolume,
						senaryWashMixTime, senaryWashMixTemperature, senaryWashMixRate,
						numberOfSenaryWashMixes, senaryWashMixTipType, senaryWashMixTipMaterial];

				(*Check that SenaryWashAirDryTime isn't in conflict with SenaryWashAirDry*)
				If[
					Or[
						senaryWashAirDry&&NullQ[senaryWashAirDryTime],
						!senaryWashAirDry&&MatchQ[senaryWashAirDryTime,Except[Automatic|Null]]
					],
					senaryWashAirDryMismatchError=True
				];

				(*--SeptenaryWash--*)
				unresolvedSeptenaryWashOptions = {
					septenaryWashBuffer,septenaryWashBufferVolume,septenaryWashMagnetizationTime,septenaryWashAspirationVolume,septenaryWashAspirationPosition,septenaryWashAspirationPositionOffset,numberOfSeptenaryWashes,
					septenaryWashAirDry,septenaryWashAirDryTime,septenaryWashMix,septenaryWashMixType,septenaryWashMixTime,septenaryWashMixRate,numberOfSeptenaryWashMixes,
					septenaryWashMixVolume,septenaryWashMixTemperature,septenaryWashCollectionContainer,septenaryWashCollectionStorageCondition,
					septenaryWashMixTipType,septenaryWashMixTipMaterial
				};

				(*Check that SeptenaryWash options aren't in conflict*)
				If[
					And[
						!MatchQ[septenaryWash,Automatic],
						Or[
							septenaryWash&&MemberQ[{septenaryWashBuffer,septenaryWashBufferVolume,septenaryWashMagnetizationTime,septenaryWashAspirationVolume,numberOfSeptenaryWashes, septenaryWashMix,septenaryWashCollectionContainer},Null],
							!septenaryWash&&MemberQ[unresolvedSeptenaryWashOptions,Except[ListableP[Automatic]|ListableP[Null]]]
						]
					],
					septenaryWashMismatchError=True
				];

				(*Resolve SeptenaryWash*)
				resolvedSeptenaryWash=If[MatchQ[septenaryWash,Automatic],
					(*If the option is Automatic, resolve it*)
					If[MemberQ[unresolvedSeptenaryWashOptions,Except[ListableP[Automatic]|ListableP[Null]]],
						True,
						False
					],
					(*If the option is specified, accept it*)
					septenaryWash
				];

				(*Call the helper function to resolve options of the wash stage, excluding mix options*)
				{resolvedSeptenaryWashBuffer,resolvedSeptenaryWashBufferVolume,resolvedSeptenaryWashMagnetizationTime,resolvedSeptenaryWashAspirationVolume,resolvedNumberOfSeptenaryWashes,resolvedSeptenaryWashCollectionContainer,resolvedSeptenaryWashCollectionStorageCondition,resolvedSeptenaryWashAirDry,resolvedSeptenaryWashAirDryTime}=resolveWashStageOptions[resolvedSeptenaryWash,resolvedPreparation,resolvedPreWashBufferVolume,volume,septenaryWashBuffer,septenaryWashBufferVolume,septenaryWashMagnetizationTime,septenaryWashAspirationVolume, numberOfSeptenaryWashes, septenaryWashCollectionContainer,septenaryWashCollectionStorageCondition,septenaryWashAirDry,septenaryWashAirDryTime];

        (*Resolve SeptenaryWash aspiration pipetting options*)
        {resolvedSeptenaryWashAspirationPosition, resolvedSeptenaryWashAspirationPositionOffset} = resolveAspirationPipettingOptionsOfStage[resolvedSeptenaryWash,resolvedPreparation,resolvedMagnetizationRackModel,septenaryWashAspirationPosition, septenaryWashAspirationPositionOffset];

				(*Calculate the volume to mix by adding the septenaryWash buffer volume to the bead volume *)
				septenaryWashVolumeToMix = Total[Cases[{magneticBeadVolume, resolvedSeptenaryWashBufferVolume}, VolumeP]];

				(* Resolve the Mix options by calling the helper function *)
				{resolvedSeptenaryWashMix, resolvedSeptenaryWashMixType, resolvedSeptenaryWashMixVolume,
					resolvedSeptenaryWashMixTime, resolvedSeptenaryWashMixTemperature,
					resolvedSeptenaryWashMixRate, resolvedNumberOfSeptenaryWashMixes,
					resolvedSeptenaryWashMixTipType, resolvedSeptenaryWashMixTipMaterial} =
					resolveMixOptionsForStage[resolvedSeptenaryWash, septenaryWashVolumeToMix,
						resolvedPreparation, septenaryWashMix, septenaryWashMixType, septenaryWashMixVolume,
						septenaryWashMixTime, septenaryWashMixTemperature, septenaryWashMixRate,
						numberOfSeptenaryWashMixes, septenaryWashMixTipType, septenaryWashMixTipMaterial];

				(*Check that SeptenaryWashAirDryTime isn't in conflict with SeptenaryWashAirDry*)
				If[
					Or[
						septenaryWashAirDry&&NullQ[septenaryWashAirDryTime],
						!septenaryWashAirDry&&MatchQ[septenaryWashAirDryTime,Except[Automatic|Null]]
					],
					septenaryWashAirDryMismatchError=True
				];

				(*--Elution--*)
				unresolvedElutionOptions = {
					elutionBuffer,elutionBufferVolume,elutionMagnetizationTime,elutionAspirationVolume,elutionAspirationPosition,elutionAspirationPositionOffset,numberOfElutions,
					elutionMix,elutionMixType,elutionMixTime,elutionMixRate,numberOfElutionMixes,
					elutionMixVolume,elutionMixTemperature,elutionCollectionContainer,elutionCollectionStorageCondition,
					elutionMixTipType,elutionMixTipMaterial
				};

				(*Check that Elution options aren't in conflict*)
				If[
					And[
						!MatchQ[elution,Automatic],
						Or[
							elution&&MemberQ[{elutionBuffer,elutionBufferVolume,elutionMagnetizationTime,elutionAspirationVolume,numberOfElutions, elutionMix,elutionCollectionContainer},Null],
							!elution&&MemberQ[unresolvedElutionOptions,Except[ListableP[Automatic]|ListableP[Null]]]
						]
					],
					elutionMismatchError=True
				];

				(*Resolve Elution*)
				resolvedElution=If[MatchQ[elution,Automatic],
					(*If the option is Automatic, resolve it*)
					(* note: if SelectionStrategy is Positive, we MUST elute to get SamplesOut *)
					If[MatchQ[selectionStrategy,Positive]||MemberQ[unresolvedElutionOptions,Except[ListableP[Automatic]|ListableP[Null]]],
						True,
						False
					],
					(*If the option is specified, accept it*)
					elution
				];

				(*Resolve ElutionBuffer*)
				resolvedElutionBuffer=If[MatchQ[elutionBuffer,Automatic],
					(*If the option is Automatic, resolve it*)
					Which[
						(*If resolvedElution is True and PreWashBuffer is specified by the user, resolve it to match the prewash buffer.*)
						resolvedElution && MatchQ[preWashBuffer,Except[Automatic|Null]],
						preWashBuffer,
						(*If resolvedElution is True (and PreWashBuffer is not specified by the user), resolve it to Model[Sample,"Milli-Q water"]*)
						resolvedElution,
						Model[Sample,"Milli-Q water"],
						(*If resolvedElution is False, resolve it to Null*)
						True,Null
					],
					(*If the option is specified, accept it*)
					elutionBuffer
				];

				(*Resolve ElutionBufferVolume*)
				resolvedElutionBufferVolume=If[MatchQ[elutionBufferVolume,Automatic],
					(*If the option is Automatic, resolve it*)
					If[resolvedElution,
						(*If Elution is True, resolve it to volume/10 rounded *)
						SafeRound[volume/10., 0.1 Microliter],
						(*If Elution is False, resolve it to Null*)
						Null
					],
					(*If the option is specified, accept it*)
					elutionBufferVolume
				];

				(*Calculate the volume to mix by adding the elution buffer volume to the bead volume *)
				elutionVolumeToMix = Total[Cases[{magneticBeadVolume, resolvedElutionBufferVolume}, VolumeP]];

				(* Resolve the Mix options by calling the helper function *)
				{resolvedElutionMix, resolvedElutionMixType, resolvedElutionMixVolume,
					resolvedElutionMixTime, resolvedElutionMixTemperature,
					resolvedElutionMixRate, resolvedNumberOfElutionMixes,
					resolvedElutionMixTipType, resolvedElutionMixTipMaterial} =
						resolveMixOptionsForStage[resolvedElution, elutionVolumeToMix,
							resolvedPreparation, elutionMix, elutionMixType, elutionMixVolume,
							elutionMixTime, elutionMixTemperature, elutionMixRate,
							numberOfElutionMixes, elutionMixTipType, elutionMixTipMaterial];

				(*Resolve ElutionMagnetizationTime*)
				resolvedElutionMagnetizationTime=If[MatchQ[elutionMagnetizationTime,Automatic],
					(*If the option is Automatic, resolve it*)
					If[resolvedElution,
						(*If Elution is True, resolve it to 5 minutes*)
						5 Minute,
						(*If Elution is False, resolve it to Null*)
						Null
					],
					(*If the option is specified, accept it*)
					elutionMagnetizationTime
				];

				(*Resolve ElutionAspirationVolume*)
				resolvedElutionAspirationVolume=If[MatchQ[elutionAspirationVolume,Automatic],
					(*If the option is Automatic, resolve it*)
					If[resolvedElution,
						(*If Elution is True, resolve based on the preparation option*)
						If[MatchQ[resolvedPreparation,Manual],
							(* If Manual, can use All *)
							All,
							(* If Robotic, use the resolvedElutionBufferVolume as All is not valid *)
							resolvedElutionBufferVolume
						],
						(*If Elution is False, resolve it to Null*)
						Null
					],
					(*If the option is specified, accept it*)
					elutionAspirationVolume
				];

        (*Resolve Elution aspiration pipetting options*)
        {resolvedElutionAspirationPosition, resolvedElutionAspirationPositionOffset} = resolveAspirationPipettingOptionsOfStage[resolvedElution,resolvedPreparation,resolvedMagnetizationRackModel,elutionAspirationPosition, elutionAspirationPositionOffset];

				(*Resolve NumberOfElutions*)
				resolvedNumberOfElutions=If[MatchQ[numberOfElutions,Automatic],
					(*If the option is Automatic, resolve it*)
					If[resolvedElution,
						(*If Elution is True, resolve it to the length of the elutionCollectionContainer*)
						Length[elutionCollectionContainer],
						(*If Elution is False, resolve it to Null*)
						Null
					],
					(*If the option is specified, accept it*)
					numberOfElutions
				];

				(*Resolve ElutionCollectionContainer*)
				resolvedElutionCollectionContainer=If[MatchQ[elutionCollectionContainer,ListableP[Automatic]],
					(*If the option is Automatic, resolve it*)
					If[resolvedElution,
						(*If Elution is True, resolve it to an appropriate container*)
						Module[{collectionVolume},
							collectionVolume=If[MatchQ[resolvedElutionAspirationVolume,All],
								resolvedElutionBufferVolume,
								resolvedElutionAspirationVolume
							];
							If[MatchQ[collectionVolume,LessEqualP[3.5 Milliliter]],
								(*MaxVolume of all preferred plates is 3.5 mL*)
								(* If volume is less than 2 mL and Preparation->Robotic, default to 2mL Deep well plate *)
								If[MatchQ[collectionVolume,LessEqualP[2.0 Milliliter]]&&MatchQ[resolvedPreparation,Robotic],
									Table[Model[Container, Plate, "id:L8kPEjkmLbvW"],resolvedNumberOfElutions], (* 2 mL plate *)
									Table[PreferredContainer[collectionVolume,Type->Plate],resolvedNumberOfElutions]
								],
								Table[PreferredContainer[collectionVolume],resolvedNumberOfElutions]
							]
						],
						(*If Elution is False, resolve it to Null*)
						{Null}
					],
					elutionCollectionContainer
				];

				(*Resolve ElutionCollectionStorageCondition*)
				resolvedElutionCollectionStorageCondition=If[MatchQ[elutionCollectionStorageCondition,Automatic],
					(*If the option is Automatic, resolve it*)
					If[resolvedElution,
						(*If Elution is True, resolve it to Refrigerator*)
						Refrigerator,
						(*If Elution is False, resolve it to Null*)
						Null
					],
					(*If the option is specified, accept it*)
					elutionCollectionStorageCondition
				];

				(*Return the error-tracking variables and resolved option values*)
				{
					(*Error-tracking variables*)
					(*1*)multipleTargetsWarning,
					(*2*)preWashMismatchError,
					(*3*)preWashAirDryMismatchError,
					(*4*)equilibrationMismatchError,
					(*5*)equilibrationAirDryMismatchError,
					(*6*)loadingAirDryMismatchError,
					(*7*)washMismatchError,
					(*8*)washAirDryMismatchError,
					(*9*)secondaryWashMismatchError,
					(*10*)secondaryWashAirDryMismatchError,
					(*11*)tertiaryWashMismatchError,
					(*12*)tertiaryWashAirDryMismatchError,
					(*13*)quaternaryWashMismatchError,
					(*14*)quaternaryWashAirDryMismatchError,
					(*15*)quinaryWashMismatchError,
					(*16*)quinaryWashAirDryMismatchError,
					(*17*)senaryWashMismatchError,
					(*18*)senaryWashAirDryMismatchError,
					(*19*)septenaryWashMismatchError,
					(*20*)septenaryWashAirDryMismatchError,

					(*21*)elutionMismatchError,

					(*Resolved option values*)

					(*22*)resolvedTarget,
					(*23*)resolvedAnalyteAffinityLabel,
					(*24*)resolvedMagneticBeadAffinityLabel,
					(*25*)Download[resolvedMagneticBead, Object],

					(*26*)resolvedPreWash,
					(*27*)resolvedPreWashBuffer,
					(*28*)resolvedPreWashBufferVolume,
					(*29*)resolvedPreWashMixTime,
					(*30*)resolvedPreWashMixTemperature,
					(*31*)resolvedPreWashMix,
					(*32*)resolvedPreWashMixType,
					(*33*)resolvedPreWashMixRate,
					(*34*)resolvedPreWashMixVolume,
					(*35*)resolvedNumberOfPreWashMixes,
					(*36*)resolvedPreWashMagnetizationTime,
					(*37*)resolvedPreWashAspirationVolume,
					(*38*)resolvedPreWashCollectionContainer,
					(*39*)resolvedPreWashCollectionStorageCondition,
					(*40*)resolvedNumberOfPreWashes,
					(*41*)resolvedPreWashAirDry,
					(*42*)resolvedPreWashAirDryTime,
					(*43*)resolvedPreWashMixTipType,
					(*44*)resolvedPreWashMixTipMaterial,

					(*45*)resolvedEquilibration,
					(*46*)resolvedEquilibrationBuffer,
					(*47*)resolvedEquilibrationBufferVolume,
					(*48*)resolvedEquilibrationMixTime,
					(*49*)resolvedEquilibrationMixTemperature,
					(*50*)resolvedEquilibrationMix,
					(*51*)resolvedEquilibrationMixType,
					(*52*)resolvedEquilibrationMixRate,
					(*53*)resolvedEquilibrationMixVolume,
					(*54*)resolvedNumberOfEquilibrationMixes,
					(*55*)resolvedEquilibrationMagnetizationTime,
					(*56*)resolvedEquilibrationAspirationVolume,
					(*57*)resolvedEquilibrationCollectionContainer,
					(*58*)resolvedEquilibrationCollectionStorageCondition,
					(*59*)resolvedEquilibrationAirDry,
					(*60*)resolvedEquilibrationAirDryTime,
					(*61*)resolvedEquilibrationMixTipType,
					(*62*)resolvedEquilibrationMixTipMaterial,
					(*63*)resolvedEquilibrationCollectionContainer,
					(*64*)resolvedEquilibrationCollectionStorageCondition,

					(*65*)resolvedLoadingMixTime,
					(*66*)resolvedLoadingMixTemperature,
					(*67*)resolvedLoadingMix,
					(*68*)resolvedLoadingMixType,
					(*69*)resolvedLoadingMixRate,
					(*70*)resolvedLoadingMixVolume,
					(*71*)resolvedNumberOfLoadingMixes,
					(*72*)resolvedLoadingMagnetizationTime,
					(*73*)resolvedLoadingAspirationVolume,
					(*74*)resolvedLoadingCollectionContainer,
					(*75*)resolvedLoadingCollectionStorageCondition,
					(*76*)resolvedLoadingAirDry,
					(*77*)resolvedLoadingAirDryTime,
					(*78*)resolvedLoadingMixTipType,
					(*79*)resolvedLoadingMixTipMaterial,

					(*80*)resolvedWash,
					(*81*)resolvedWashBuffer,
					(*82*)resolvedWashBufferVolume,
					(*83*)resolvedWashMixTime,
					(*84*)resolvedWashMixTemperature,
					(*85*)resolvedWashMix,
					(*86*)resolvedWashMixType,
					(*87*)resolvedWashMixRate,
					(*88*)resolvedWashMixVolume,
					(*89*)resolvedNumberOfWashMixes,
					(*90*)resolvedWashMagnetizationTime,
					(*91*)resolvedWashAspirationVolume,
					(*92*)resolvedWashCollectionContainer,
					(*93*)resolvedWashCollectionStorageCondition,
					(*94*)resolvedNumberOfWashes,
					(*95*)resolvedWashAirDry,
					(*96*)resolvedWashAirDryTime,
					(*97*)resolvedWashMixTipType,
					(*98*)resolvedWashMixTipMaterial,

					(*99*)resolvedSecondaryWash,
					(*100*)resolvedSecondaryWashBuffer,
					(*101*)resolvedSecondaryWashBufferVolume,
					(*102*)resolvedSecondaryWashMixTime,
					(*103*)resolvedSecondaryWashMixTemperature,
					(*104*)resolvedSecondaryWashMix,
					(*105*)resolvedSecondaryWashMixType,
					(*106*)resolvedSecondaryWashMixRate,
					(*107*)resolvedSecondaryWashMixVolume,
					(*108*)resolvedNumberOfSecondaryWashMixes,
					(*109*)resolvedSecondaryWashMagnetizationTime,
					(*110*)resolvedSecondaryWashAspirationVolume,
					(*111*)resolvedSecondaryWashCollectionContainer,
					(*112*)resolvedSecondaryWashCollectionStorageCondition,
					(*113*)resolvedNumberOfSecondaryWashes,
					(*114*)resolvedSecondaryWashAirDry,
					(*115*)resolvedSecondaryWashAirDryTime,
					(*116*)resolvedSecondaryWashMixTipType,
					(*117*)resolvedSecondaryWashMixTipMaterial,

					(*118*)resolvedTertiaryWash,
					(*119*)resolvedTertiaryWashBuffer,
					(*120*)resolvedTertiaryWashBufferVolume,
					(*121*)resolvedTertiaryWashMixTime,
					(*122*)resolvedTertiaryWashMixTemperature,
					(*123*)resolvedTertiaryWashMix,
					(*124*)resolvedTertiaryWashMixType,
					(*125*)resolvedTertiaryWashMixRate,
					(*126*)resolvedTertiaryWashMixVolume,
					(*127*)resolvedNumberOfTertiaryWashMixes,
					(*128*)resolvedTertiaryWashMagnetizationTime,
					(*129*)resolvedTertiaryWashAspirationVolume,
					(*130*)resolvedTertiaryWashCollectionContainer,
					(*131*)resolvedTertiaryWashCollectionStorageCondition,
					(*132*)resolvedNumberOfTertiaryWashes,
					(*133*)resolvedTertiaryWashAirDry,
					(*134*)resolvedTertiaryWashAirDryTime,
					(*135*)resolvedTertiaryWashMixTipType,
					(*136*)resolvedTertiaryWashMixTipMaterial,

					(*137*)resolvedQuaternaryWash,
					(*138*)resolvedQuaternaryWashBuffer,
					(*139*)resolvedQuaternaryWashBufferVolume,
					(*140*)resolvedQuaternaryWashMixTime,
					(*141*)resolvedQuaternaryWashMixTemperature,
					(*142*)resolvedQuaternaryWashMix,
					(*143*)resolvedQuaternaryWashMixType,
					(*144*)resolvedQuaternaryWashMixRate,
					(*145*)resolvedQuaternaryWashMixVolume,
					(*146*)resolvedNumberOfQuaternaryWashMixes,
					(*147*)resolvedQuaternaryWashMagnetizationTime,
					(*148*)resolvedQuaternaryWashAspirationVolume,
					(*149*)resolvedQuaternaryWashCollectionContainer,
					(*150*)resolvedQuaternaryWashCollectionStorageCondition,
					(*151*)resolvedNumberOfQuaternaryWashes,
					(*152*)resolvedQuaternaryWashAirDry,
					(*153*)resolvedQuaternaryWashAirDryTime,
					(*154*)resolvedQuaternaryWashMixTipType,
					(*155*)resolvedQuaternaryWashMixTipMaterial,

					(*156*)resolvedQuinaryWash,
					(*157*)resolvedQuinaryWashBuffer,
					(*158*)resolvedQuinaryWashBufferVolume,
					(*159*)resolvedQuinaryWashMixTime,
					(*160*)resolvedQuinaryWashMixTemperature,
					(*161*)resolvedQuinaryWashMix,
					(*162*)resolvedQuinaryWashMixType,
					(*163*)resolvedQuinaryWashMixRate,
					(*164*)resolvedQuinaryWashMixVolume,
					(*165*)resolvedNumberOfQuinaryWashMixes,
					(*166*)resolvedQuinaryWashMagnetizationTime,
					(*167*)resolvedQuinaryWashAspirationVolume,
					(*168*)resolvedQuinaryWashCollectionContainer,
					(*169*)resolvedQuinaryWashCollectionStorageCondition,
					(*170*)resolvedNumberOfQuinaryWashes,
					(*171*)resolvedQuinaryWashAirDry,
					(*172*)resolvedQuinaryWashAirDryTime,
					(*173*)resolvedQuinaryWashMixTipType,
					(*174*)resolvedQuinaryWashMixTipMaterial,

					(*175*)resolvedSenaryWash,
					(*176*)resolvedSenaryWashBuffer,
					(*177*)resolvedSenaryWashBufferVolume,
					(*178*)resolvedSenaryWashMixTime,
					(*179*)resolvedSenaryWashMixTemperature,
					(*180*)resolvedSenaryWashMix,
					(*181*)resolvedSenaryWashMixType,
					(*182*)resolvedSenaryWashMixRate,
					(*183*)resolvedSenaryWashMixVolume,
					(*184*)resolvedNumberOfSenaryWashMixes,
					(*185*)resolvedSenaryWashMagnetizationTime,
					(*186*)resolvedSenaryWashAspirationVolume,
					(*187*)resolvedSenaryWashCollectionContainer,
					(*188*)resolvedSenaryWashCollectionStorageCondition,
					(*189*)resolvedNumberOfSenaryWashes,
					(*190*)resolvedSenaryWashAirDry,
					(*191*)resolvedSenaryWashAirDryTime,
					(*192*)resolvedSenaryWashMixTipType,
					(*193*)resolvedSenaryWashMixTipMaterial,

					(*194*)resolvedSeptenaryWash,
					(*195*)resolvedSeptenaryWashBuffer,
					(*196*)resolvedSeptenaryWashBufferVolume,
					(*197*)resolvedSeptenaryWashMixTime,
					(*198*)resolvedSeptenaryWashMixTemperature,
					(*199*)resolvedSeptenaryWashMix,
					(*200*)resolvedSeptenaryWashMixType,
					(*201*)resolvedSeptenaryWashMixRate,
					(*202*)resolvedSeptenaryWashMixVolume,
					(*203*)resolvedNumberOfSeptenaryWashMixes,
					(*204*)resolvedSeptenaryWashMagnetizationTime,
					(*205*)resolvedSeptenaryWashAspirationVolume,
					(*206*)resolvedSeptenaryWashCollectionContainer,
					(*207*)resolvedSeptenaryWashCollectionStorageCondition,
					(*208*)resolvedNumberOfSeptenaryWashes,
					(*209*)resolvedSeptenaryWashAirDry,
					(*210*)resolvedSeptenaryWashAirDryTime,
					(*211*)resolvedSeptenaryWashMixTipType,
					(*212*)resolvedSeptenaryWashMixTipMaterial,

					(*213*)resolvedElution,
					(*214*)resolvedElutionBuffer,
					(*215*)resolvedElutionBufferVolume,
					(*216*)resolvedElutionMixTime,
					(*217*)resolvedElutionMixTemperature,
					(*218*)resolvedElutionMix,
					(*219*)resolvedElutionMixType,
					(*220*)resolvedElutionMixRate,
					(*221*)resolvedElutionMixVolume,
					(*222*)resolvedNumberOfElutionMixes,
					(*223*)resolvedElutionMagnetizationTime,
					(*224*)resolvedElutionAspirationVolume,
					(*225*)resolvedElutionCollectionContainer,
					(*226*)resolvedElutionCollectionStorageCondition,
					(*227*)resolvedNumberOfElutions,
					(*228*)resolvedElutionMixTipType,
					(*229*)resolvedElutionMixTipMaterial,

          (*230*)resolvedPreWashAspirationPosition,
          (*231*)resolvedPreWashAspirationPositionOffset,
          (*232*)resolvedEquilibrationAspirationPosition,
          (*233*)resolvedEquilibrationAspirationPositionOffset,
          (*234*)resolvedLoadingAspirationPosition,
          (*235*)resolvedLoadingAspirationPositionOffset,
          (*236*)resolvedWashAspirationPosition,
          (*237*)resolvedWashAspirationPositionOffset,
          (*238*)resolvedSecondaryWashAspirationPosition,
          (*239*)resolvedSecondaryWashAspirationPositionOffset,
          (*240*)resolvedTertiaryWashAspirationPosition,
          (*241*)resolvedTertiaryWashAspirationPositionOffset,
          (*242*)resolvedQuaternaryWashAspirationPosition,
          (*243*)resolvedQuaternaryWashAspirationPositionOffset,
          (*244*)resolvedQuinaryWashAspirationPosition,
          (*245*)resolvedQuinaryWashAspirationPositionOffset,
          (*246*)resolvedSenaryWashAspirationPosition,
          (*247*)resolvedSenaryWashAspirationPositionOffset,
          (*248*)resolvedSeptenaryWashAspirationPosition,
          (*249*)resolvedSeptenaryWashAspirationPositionOffset,
          (*250*)resolvedElutionAspirationPosition,
          (*251*)resolvedElutionAspirationPositionOffset
				}
			]
		],
		{flatSimulatedSamplePackets,preResolvedMapThreadFriendlyOptions,resolvedAssayContainers,resolvedMagnetizationRackModels}
	]];

	(* Detect Volume Errors *)
	invalidBufferVolumes=MapThread[
		Function[{sample,preWashBufferVolume,equilibrationBufferVolume,washBufferVolume,secondaryWashBufferVolume,tertiaryWashBufferVolume,quaternaryWashBufferVolume,quinaryWashBufferVolume,senaryWashBufferVolume,septenaryWashBufferVolume,elutionBufferVolume,assayContainer},
			Module[{preWashError,equilibrationError,washError,secondaryWashError,tertiaryWashError,quaternaryWashError,quinaryWashError,senaryWashError,septenaryWashError,elutionError,assayContainerMaxVol},

				(* Get the max volume of the assay container *)
				assayContainerMaxVol = fastAssocLookup[combinedFastAssoc,assayContainer,MaxVolume];

				(* Compare for each stage *)
				preWashError=If[GreaterQ[preWashBufferVolume,assayContainerMaxVol],
					{sample, preWashBufferVolume, "PreWash"},
					Nothing
				];

				equilibrationError=If[GreaterQ[equilibrationBufferVolume,assayContainerMaxVol],
					{sample, equilibrationBufferVolume, "Equilibration"},
					Nothing
				];

				washError=If[GreaterQ[washBufferVolume,assayContainerMaxVol],
					{sample, washBufferVolume, "Wash"},
					Nothing
				];

				secondaryWashError=If[GreaterQ[secondaryWashBufferVolume,assayContainerMaxVol],
					{sample, secondaryWashBufferVolume, "SecondaryWash"},
					Nothing
				];

				tertiaryWashError=If[GreaterQ[tertiaryWashBufferVolume,assayContainerMaxVol],
					{sample, tertiaryWashBufferVolume, "TertiaryWash"},
					Nothing
				];

				quaternaryWashError=If[GreaterQ[quaternaryWashBufferVolume,assayContainerMaxVol],
					{sample, quaternaryWashBufferVolume, "QuaternaryWash"},
					Nothing
				];

				quinaryWashError=If[GreaterQ[quinaryWashBufferVolume,assayContainerMaxVol],
					{sample, quinaryWashBufferVolume, "QuinaryWash"},
					Nothing
				];

				senaryWashError=If[GreaterQ[senaryWashBufferVolume,assayContainerMaxVol],
					{sample, senaryWashBufferVolume, "SenaryWash"},
					Nothing
				];


				septenaryWashError=If[GreaterQ[septenaryWashBufferVolume,assayContainerMaxVol],
					{sample, septenaryWashBufferVolume, "SeptenaryWash"},
					Nothing
				];


				elutionError=If[GreaterQ[elutionBufferVolume,assayContainerMaxVol],
					{sample, elutionBufferVolume, "Elution"},
					Nothing
				];

				{preWashError,equilibrationError,washError,secondaryWashError,tertiaryWashError,quaternaryWashError,quinaryWashError,senaryWashError,septenaryWashError,elutionError}

			]

		],
		{
			flatSimulatedSamples,
			Flatten@resolvedPreWashBufferVolumes,
			Flatten@resolvedEquilibrationBufferVolumes,
			Flatten@resolvedWashBufferVolumes,
			Flatten@resolvedSecondaryWashBufferVolumes,
			Flatten@resolvedTertiaryWashBufferVolumes,
			Flatten@resolvedQuaternaryWashBufferVolumes,
			Flatten@resolvedQuinaryWashBufferVolumes,
			Flatten@resolvedSenaryWashBufferVolumes,
			Flatten@resolvedSeptenaryWashBufferVolumes,
			Flatten@resolvedElutionBufferVolumes,
			Flatten@resolvedAssayContainers
		}
	]/.{{}->Nothing};

	flattenedInvalidBufferVolumes=If[MatchQ[invalidBufferVolumes,{}],
		{},
		Flatten[invalidBufferVolumes,{1,2}]
	];

	invalidBufferVolumesOptions = If[Length[flattenedInvalidBufferVolumes] > 0 && messages,
		Message[Error::InvalidBufferVolume,flattenedInvalidBufferVolumes[[All,1]],flattenedInvalidBufferVolumes[[All,2]],flattenedInvalidBufferVolumes[[All,3]]];
		DeleteDuplicates[((ToExpression[#<>"BufferVolume"])&/@flattenedInvalidBufferVolumes[[All,3]])],
		{}
	];

	invalidBufferVolumeTests = If[Length[flattenedInvalidBufferVolumes] > 0 && gatherTests,
		Module[{passingSamples,failingTest,passingTest},
			passingSamples = Complement[flatSamples,flattenedInvalidBufferVolumes[[All,1]]];

			(* create a test for the non-passing inputs *)
			failingTest=If[Length[flattenedInvalidBufferVolumes]>0,
				Test["BufferVolume option for the following samples "<>ObjectToString[flattenedInvalidBufferVolumes[[All,1]]]<>" does not conflict with chosen assay container:",True,False],
				Nothing
			];

			(* create a test for the passing inputs *)
			passingTest=If[Length[passingSamples]>0,
				Test["BufferVolume option for the following samples "<>ObjectToString[passingSamples]<>" does not conflict with chosen assay container:",True,True],
				Nothing
			];

			{passingTest, failingTest}
		],
		Nothing
	];

	(* Resolve Destination Wells and Collection Container Labels *)
	(* First resolve the storage conditions. *)
	(* Check the storage conditions to make sure an Object[Container] or Model[Container] with a same index does not have multiple storage conditions *)
	storageConditionLookup=<||>;
	allContainers=<||>;

	{conflictingPreWashCollectionStorageConditionInfo,storageConditionLookup,allContainers} = gatherConflictingStorageConditionInfo[resolvedPreWashCollectionStorageConditions,resolvedPreWashCollectionContainers,collapseContainerIndices[preWashCollectionContainerIndices,resolvedPreWashCollectionContainers],storageConditionLookup,allContainers,storageConditionPackets];

	{conflictingEquilibrationCollectionStorageConditionInfo,storageConditionLookup,allContainers} = gatherConflictingStorageConditionInfo[resolvedEquilibrationCollectionStorageConditions,resolvedEquilibrationCollectionContainers,collapseContainerIndices[equilibrationCollectionContainerIndices,resolvedEquilibrationCollectionContainers],storageConditionLookup,allContainers,storageConditionPackets];

	{conflictingLoadingCollectionStorageConditionInfo,storageConditionLookup,allContainers} = gatherConflictingStorageConditionInfo[resolvedLoadingCollectionStorageConditions,resolvedLoadingCollectionContainers,collapseContainerIndices[loadingCollectionContainerIndices,resolvedLoadingCollectionContainers],storageConditionLookup,allContainers,storageConditionPackets];

	{conflictingWashCollectionStorageConditionInfo,storageConditionLookup,allContainers} = gatherConflictingStorageConditionInfo[resolvedWashCollectionStorageConditions,resolvedWashCollectionContainers,collapseContainerIndices[washCollectionContainerIndices,resolvedWashCollectionContainers],storageConditionLookup,allContainers,storageConditionPackets];

	{conflictingSecondaryWashCollectionStorageConditionInfo,storageConditionLookup,allContainers} = gatherConflictingStorageConditionInfo[resolvedSecondaryWashCollectionStorageConditions,resolvedSecondaryWashCollectionContainers,collapseContainerIndices[secondaryWashCollectionContainerIndices,resolvedSecondaryWashCollectionContainers],storageConditionLookup,allContainers,storageConditionPackets];

	{conflictingTertiaryWashCollectionStorageConditionInfo,storageConditionLookup,allContainers} = gatherConflictingStorageConditionInfo[resolvedTertiaryWashCollectionStorageConditions,resolvedTertiaryWashCollectionContainers,collapseContainerIndices[tertiaryWashCollectionContainerIndices,resolvedTertiaryWashCollectionContainers],storageConditionLookup,allContainers,storageConditionPackets];

	{conflictingQuaternaryWashCollectionStorageConditionInfo,storageConditionLookup,allContainers} = gatherConflictingStorageConditionInfo[resolvedQuaternaryWashCollectionStorageConditions,resolvedQuaternaryWashCollectionContainers, collapseContainerIndices[quaternaryWashCollectionContainerIndices,resolvedQuaternaryWashCollectionContainers],storageConditionLookup,allContainers,storageConditionPackets];

	{conflictingQuinaryWashCollectionStorageConditionInfo,storageConditionLookup,allContainers} = gatherConflictingStorageConditionInfo[resolvedQuinaryWashCollectionStorageConditions,resolvedQuinaryWashCollectionContainers, collapseContainerIndices[quinaryWashCollectionContainerIndices,resolvedQuinaryWashCollectionContainers],storageConditionLookup,allContainers,storageConditionPackets];

	{conflictingSenaryWashCollectionStorageConditionInfo,storageConditionLookup,allContainers} = gatherConflictingStorageConditionInfo[resolvedSenaryWashCollectionStorageConditions,resolvedSenaryWashCollectionContainers,collapseContainerIndices[senaryWashCollectionContainerIndices,resolvedSenaryWashCollectionContainers],storageConditionLookup,allContainers,storageConditionPackets];

	{conflictingSeptenaryWashCollectionStorageConditionInfo,storageConditionLookup,allContainers} = gatherConflictingStorageConditionInfo[resolvedSeptenaryWashCollectionStorageConditions,resolvedSeptenaryWashCollectionContainers,collapseContainerIndices[septenaryWashCollectionContainerIndices,resolvedSeptenaryWashCollectionContainers],storageConditionLookup,allContainers,storageConditionPackets];

  (*Needed to collapse collection container indices because it might have been expanded for index matching*)
	{conflictingElutionCollectionStorageConditionInfo,storageConditionLookup,allContainers} = gatherConflictingStorageConditionInfo[resolvedElutionCollectionStorageConditions,resolvedElutionCollectionContainers,
    collapseContainerIndices[elutionCollectionContainerIndices,resolvedElutionCollectionContainers],
    storageConditionLookup,allContainers,storageConditionPackets];

	conflictingCollectionStorageConditionInfo = DeleteDuplicates@Join[
		conflictingPreWashCollectionStorageConditionInfo,
		conflictingEquilibrationCollectionStorageConditionInfo,
		conflictingLoadingCollectionStorageConditionInfo,
		conflictingWashCollectionStorageConditionInfo,
		conflictingSecondaryWashCollectionStorageConditionInfo,
		conflictingTertiaryWashCollectionStorageConditionInfo,
		conflictingQuaternaryWashCollectionStorageConditionInfo,
		conflictingQuinaryWashCollectionStorageConditionInfo,
		conflictingSenaryWashCollectionStorageConditionInfo,
		conflictingSeptenaryWashCollectionStorageConditionInfo,
		conflictingElutionCollectionStorageConditionInfo
	];

	conflictingCollectionStorageConditionOptions=If[messages && Length[conflictingCollectionStorageConditionInfo] > 0,
		Message[Error::CollectionContainerConflictingStorageCondition,conflictingCollectionStorageConditionInfo];
		{PreWashCollectionStorageCondition,EquilibrationCollectionStorageCondition,LoadingCollectionStorageCondition,WashCollectionStorageCondition,SecondaryWashCollectionStorageCondition,TertiaryWashCollectionStorageCondition,QuaternaryWashCollectionStorageCondition,QuinaryWashCollectionStorageCondition,SenaryWashCollectionStorageCondition,SeptenaryWashCollectionStorageCondition,ElutionCollectionStorageCondition},
		{}
	];

	conflictingCollectionStorageConditionTests=If[gatherTests && Length[conflictingCollectionStorageConditionInfo] > 0,
		Module[{passingContainers,failingContainers,failingTest,passingTest},

			(* Enumerate the failing and passing storage container objects *)
			failingContainers = conflictingCollectionStorageConditionInfo;

			passingContainers = Complement[allContainers,conflictingCollectionStorageConditionInfo];

			(* create a test for the non-passing inputs *)
			failingTest=If[Length[failingContainers]>0,
				Test["PreWashCollectionStorageCondition,EquilibrationCollectionStorageCondition,LoadingCollectionStorageCondition,WashCollectionStorageCondition,SecondaryWashCollectionStorageCondition,TertiaryWashCollectionStorageCondition,QuaternaryWashCollectionStorageCondition,QuinaryWashCollectionStorageCondition,SenaryWashCollectionStorageCondition,SeptenaryWashCollectionStorageCondition,ElutionCollectionStorageCondition options for the following containers " <> ObjectToString[failingContainers] <>" are not conflicting:",True,False],
				Nothing
			];

			(* create a test for the passing inputs *)
			passingTest=If[Length[passingContainers]>0,
				Test["PreWashCollectionStorageCondition,EquilibrationCollectionStorageCondition,LoadingCollectionStorageCondition,WashCollectionStorageCondition,SecondaryWashCollectionStorageCondition,TertiaryWashCollectionStorageCondition,QuaternaryWashCollectionStorageCondition,QuinaryWashCollectionStorageCondition,SenaryWashCollectionStorageCondition,SeptenaryWashCollectionStorageCondition,ElutionCollectionStorageCondition options for the following containers " <> ObjectToString[passing] <>" are not conflicting:",True,True],
				Nothing
			];

			{passingTest, failingTest}
		],
		Nothing
	];

	(* If there are Object[Container]'s with multiple specified storage conditions, make them all have the same so errors do not get thrown later on in the simulation function *)
	(* Correct PreWash *)
	correctedPreWashCollectionStorageConditions = correctStorageConditionsOfStage[resolvedPreWashCollectionStorageConditions,resolvedPreWashCollectionContainers,storageConditionLookup];

	(* Correct Equilibration *)
	correctedEquilibrationCollectionStorageConditions = correctStorageConditionsOfStage[resolvedEquilibrationCollectionStorageConditions,resolvedEquilibrationCollectionContainers,storageConditionLookup];

	(* Correct Loading *)
	correctedLoadingCollectionStorageConditions = correctStorageConditionsOfStage[resolvedLoadingCollectionStorageConditions,resolvedLoadingCollectionContainers,storageConditionLookup];

	(* Correct Wash *)
	correctedWashCollectionStorageConditions = correctStorageConditionsOfStage[resolvedWashCollectionStorageConditions,resolvedWashCollectionContainers,storageConditionLookup];

	(* Correct SecondaryWash *)
	correctedSecondaryWashCollectionStorageConditions = correctStorageConditionsOfStage[resolvedSecondaryWashCollectionStorageConditions,resolvedSecondaryWashCollectionContainers,storageConditionLookup];

	(* Correct TertiaryWash *)
	correctedTertiaryWashCollectionStorageConditions = correctStorageConditionsOfStage[resolvedTertiaryWashCollectionStorageConditions,resolvedTertiaryWashCollectionContainers,storageConditionLookup];

	(* Correct QuaternaryWash *)
	correctedQuaternaryWashCollectionStorageConditions = correctStorageConditionsOfStage[resolvedQuaternaryWashCollectionStorageConditions,resolvedQuaternaryWashCollectionContainers,storageConditionLookup];

	(* Correct QuinaryWash *)
	correctedQuinaryWashCollectionStorageConditions = correctStorageConditionsOfStage[resolvedQuinaryWashCollectionStorageConditions,resolvedQuinaryWashCollectionContainers,storageConditionLookup];

	(* Correct SenaryWash *)
	correctedSenaryWashCollectionStorageConditions = correctStorageConditionsOfStage[resolvedSenaryWashCollectionStorageConditions,resolvedSenaryWashCollectionContainers,storageConditionLookup];

	(* Correct SeptenaryWash *)
	correctedSeptenaryWashCollectionStorageConditions = correctStorageConditionsOfStage[resolvedSeptenaryWashCollectionStorageConditions,resolvedSeptenaryWashCollectionContainers,storageConditionLookup];

	(* Correct Elution *)
	correctedElutionCollectionStorageConditions = correctStorageConditionsOfStage[resolvedElutionCollectionStorageConditions,resolvedElutionCollectionContainers,storageConditionLookup];

	(* Error checks to make sure the CollectionContainer, DestinationWell, and CollectionContainerLabel options align with *)
	(* the number of times the stage is supposed to be repeated. If the dimensions are not correct, correct them so further *)
	(* resolving does not error *)
	(* -- PreWash -- *)
	preWashOptionsWithCorrectDims=correctOptionsDimensions[
		simulatedSamples,
    If[EqualQ[Depth[resolvedPreWashCollectionContainers/.ObjectP[]->Null],4],
      resolvedPreWashCollectionContainers,
      unflattenListHelper[resolvedPreWashCollectionContainers,simulatedSamples]],
    preWashDestinationWells,
    If[EqualQ[Depth[preWashCollectionContainerIndices],4],preWashCollectionContainerIndices,
      unflattenListHelper[preWashCollectionContainerIndices,simulatedSamples]],
    preWashCollectionContainerLabels,
		unflattenListHelper[resolvedNumberOfPreWashes,simulatedSamples]/.{Null->1}
	];

	{
		numberOfPreWashesMismatchSamples,
		correctedPreWashCollectionContainers,
		correctedPreWashDestinationWells,
		correctedPreWashCollectionContainerIndices,
		correctedPreWashCollectionContainerLabels
	}={
		Flatten[preWashOptionsWithCorrectDims[[All,All,1]]/.Null->Nothing],
		preWashOptionsWithCorrectDims[[All,All,2]],
		preWashOptionsWithCorrectDims[[All,All,3]],
		preWashOptionsWithCorrectDims[[All,All,4]],
		preWashOptionsWithCorrectDims[[All,All,5]]
	};

	numberOfPreWashMismatchOptions=If[messages && Length[numberOfPreWashesMismatchSamples] > 0,
		Message[Error::NumberOfPreWashesMismatch,numberOfPreWashesMismatchSamples];
		{NumberOfPreWashes},
		{}
	];

	numberOfPreWashMismatchTests=If[gatherTests && Length[numberOfPreWashesMismatchSamples] > 0,
		Module[{passingSamples,failingTest,passingTest},
			passingSamples = Complement[flatSamples,numberOfPreWashesMismatchSamples];

			(* create a test for the non-passing inputs *)
			failingTest=If[Length[numberOfPreWashesMismatchSamples]>0,
				Test["NumberOfPreWashes for the following samples "<>ObjectToString[numberOfPreWashesMismatchSamples]<>" does not have mismatch with the length of PreWashCollectionContainer and PreWashCollectionContainerLabel:",True,False],
				Nothing
			];

			(* create a test for the passing inputs *)
			passingTest=If[Length[passingSamples]>0,
				Test["NumberOfPreWashes for the following samples "<>ObjectToString[passingSamples]<>"  does not have mismatch with the length of PreWashCollectionContainer and PreWashCollectionContainerLabel:",True,True],
				Nothing
			];

			{passingTest, failingTest}
		],
		Nothing
	];

	(* -- Equilibration -- *)
	equilibrationOptionsWithCorrectDims=correctOptionsDimensions[
		simulatedSamples,
    If[EqualQ[Depth[resolvedEquilibrationCollectionContainers/.ObjectP[]->Null],4],
      resolvedEquilibrationCollectionContainers,
      unflattenListHelper[resolvedEquilibrationCollectionContainers,simulatedSamples]],
    equilibrationDestinationWells,
    If[EqualQ[Depth[equilibrationCollectionContainerIndices],4],equilibrationCollectionContainerIndices,
      unflattenListHelper[equilibrationCollectionContainerIndices,simulatedSamples]],
    equilibrationCollectionContainerLabels,
		simulatedSamples/.ObjectP[]->1
	];

	{
		numberOfEquilibrationsMismatchSamples,
		correctedEquilibrationCollectionContainers,
		correctedEquilibrationDestinationWells,
		correctedEquilibrationCollectionContainerIndices,
		correctedEquilibrationCollectionContainerLabels
	}={
		Flatten[equilibrationOptionsWithCorrectDims[[All,All,1]]/.Null->Nothing],
		equilibrationOptionsWithCorrectDims[[All,All,2]],
		equilibrationOptionsWithCorrectDims[[All,All,3]],
		equilibrationOptionsWithCorrectDims[[All,All,4]],
		equilibrationOptionsWithCorrectDims[[All,All,5]]
	};

	numberOfEquilibrationMismatchOptions=If[messages && Length[numberOfEquilibrationsMismatchSamples] > 0,
		Message[Error::NumberOfEquilibrationsMismatch,numberOfEquilibrationsMismatchSamples];
		{EquilibrationCollectionContainer,EquilibrationCollectionContainerLabel},
		{}
	];

	numberOfEquilibrationMismatchTests=If[gatherTests && Length[numberOfEquilibrationsMismatchSamples] > 0,
		Module[{passingSamples,failingTest,passingTest},
			passingSamples = Complement[flatSamples,numberOfEquilibrationsMismatchSamples];

			(* create a test for the non-passing inputs *)
			failingTest=If[Length[numberOfEquilibrationsMismatchSamples]>0,
				Test["EquilibrationCollectionContainer and EquilibrationCollectionContainerLabel options for the following samples for the following samples "<>ObjectToString[numberOfEquilibrationsMismatchSamples]<>" have a valid length:",True,False],
				Nothing
			];

			(* create a test for the passing inputs *)
			passingTest=If[Length[passingSamples]>0,
				Test["EquilibrationCollectionContainer and EquilibrationCollectionContainerLabel options for the following samples for the following samples "<>ObjectToString[passingSamples]<>"  have a valid length:",True,True],
				Nothing
			];

			{passingTest, failingTest}
		],
		Nothing
	];

	(* -- Loading -- *)
	loadingOptionsWithCorrectDims=correctOptionsDimensions[
		simulatedSamples,
    If[EqualQ[Depth[resolvedLoadingCollectionContainers/.ObjectP[]->Null],4],
      resolvedLoadingCollectionContainers,
      unflattenListHelper[resolvedLoadingCollectionContainers,simulatedSamples]],
    loadingDestinationWells,
    If[EqualQ[Depth[loadingCollectionContainerIndices],4],loadingCollectionContainerIndices,
      unflattenListHelper[loadingCollectionContainerIndices,simulatedSamples]],
    loadingCollectionContainerLabels,
		simulatedSamples/.ObjectP[]->1
	];

	{
		numberOfLoadingsMismatchSamples,
		correctedLoadingCollectionContainers,
		correctedLoadingDestinationWells,
		correctedLoadingCollectionContainerIndices,
		correctedLoadingCollectionContainerLabels
	}={
		Flatten[loadingOptionsWithCorrectDims[[All,All,1]]/.Null->Nothing],
		loadingOptionsWithCorrectDims[[All,All,2]],
		loadingOptionsWithCorrectDims[[All,All,3]],
		loadingOptionsWithCorrectDims[[All,All,4]],
		loadingOptionsWithCorrectDims[[All,All,5]]
	};

	numberOfLoadingMismatchOptions=If[messages && Length[numberOfLoadingsMismatchSamples] > 0,
		Message[Error::NumberOfLoadingsMismatch,numberOfLoadingsMismatchSamples];
		{LoadingCollectionContainer,LoadingCollectionContainerLabel},
		{}
	];

	numberOfLoadingMismatchTests=If[gatherTests && Length[numberOfLoadingsMismatchSamples] > 0,
		Module[{passingSamples,failingTest,passingTest},
			passingSamples = Complement[flatSamples,numberOfLoadingsMismatchSamples];

			(* create a test for the non-passing inputs *)
			failingTest=If[Length[numberOfLoadingsMismatchSamples]>0,
				Test["LoadingCollectionContainer and LoadingCollectionContainerLabel options for the following samples for the following samples "<>ObjectToString[numberOfLoadingsMismatchSamples]<>" have a valid length:",True,False],
				Nothing
			];

			(* create a test for the passing inputs *)
			passingTest=If[Length[passingSamples]>0,
				Test["LoadingCollectionContainer and LoadingCollectionContainerLabel options for the following samples for the following samples "<>ObjectToString[passingSamples]<>"  have a valid length:",True,True],
				Nothing
			];

			{passingTest, failingTest}
		],
		Nothing
	];

	(* -- Wash -- *)
	washOptionsWithCorrectDims=correctOptionsDimensions[
		simulatedSamples,
    If[EqualQ[Depth[resolvedWashCollectionContainers/.ObjectP[]->Null],4],
      resolvedWashCollectionContainers,
      unflattenListHelper[resolvedWashCollectionContainers,simulatedSamples]],
    washDestinationWells,
    If[EqualQ[Depth[washCollectionContainerIndices],4],washCollectionContainerIndices,
      unflattenListHelper[washCollectionContainerIndices,simulatedSamples]],
    washCollectionContainerLabels,
		unflattenListHelper[resolvedNumberOfWashes,simulatedSamples]/.{Null->1}
	];

	{
		numberOfWashesMismatchSamples,
		correctedWashCollectionContainers,
		correctedWashDestinationWells,
		correctedWashCollectionContainerIndices,
		correctedWashCollectionContainerLabels
	}={
		Flatten[washOptionsWithCorrectDims[[All,All,1]]/.Null->Nothing],
		washOptionsWithCorrectDims[[All,All,2]],
		washOptionsWithCorrectDims[[All,All,3]],
		washOptionsWithCorrectDims[[All,All,4]],
		washOptionsWithCorrectDims[[All,All,5]]
	};

	numberOfWashMismatchOptions=If[messages && Length[numberOfWashesMismatchSamples] > 0,
		Message[Error::NumberOfWashesMismatch,numberOfWashesMismatchSamples];
		{NumberOfWashes},
		{}
	];

	numberOfWashMismatchTests=If[gatherTests && Length[numberOfWashesMismatchSamples] > 0,
		Module[{passingSamples,failingTest,passingTest},
			passingSamples = Complement[flatSamples,numberOfWashesMismatchSamples];

			(* create a test for the non-passing inputs *)
			failingTest=If[Length[numberOfWashesMismatchSamples]>0,
				Test["NumberOfWashes for the following samples "<>ObjectToString[numberOfWashesMismatchSamples]<>" does not have mismatch with the length of WashCollectionContainer and WashCollectionContainerLabel:",True,False],
				Nothing
			];

			(* create a test for the passing inputs *)
			passingTest=If[Length[passingSamples]>0,
				Test["NumberOfWashes for the following samples "<>ObjectToString[passingSamples]<>"  does not have mismatch with the length of WashCollectionContainer and WashCollectionContainerLabel:",True,True],
				Nothing
			];

			{passingTest, failingTest}
		],
		Nothing
	];

	(* -- SecondaryWash -- *)
	secondaryWashOptionsWithCorrectDims=correctOptionsDimensions[
		simulatedSamples,
    If[EqualQ[Depth[resolvedSecondaryWashCollectionContainers/.ObjectP[]->Null],4],
      resolvedSecondaryWashCollectionContainers,
      unflattenListHelper[resolvedSecondaryWashCollectionContainers,simulatedSamples]],
    secondaryWashDestinationWells,
    If[EqualQ[Depth[secondaryWashCollectionContainerIndices],4],secondaryWashCollectionContainerIndices,
      unflattenListHelper[secondaryWashCollectionContainerIndices,simulatedSamples]],
    secondaryWashCollectionContainerLabels,
		unflattenListHelper[resolvedNumberOfSecondaryWashes,simulatedSamples]/.{Null->1}
	];

	{
		numberOfSecondaryWashesMismatchSamples,
		correctedSecondaryWashCollectionContainers,
		correctedSecondaryWashDestinationWells,
		correctedSecondaryWashCollectionContainerIndices,
		correctedSecondaryWashCollectionContainerLabels
	}={
		Flatten[secondaryWashOptionsWithCorrectDims[[All,All,1]]/.Null->Nothing],
		secondaryWashOptionsWithCorrectDims[[All,All,2]],
		secondaryWashOptionsWithCorrectDims[[All,All,3]],
		secondaryWashOptionsWithCorrectDims[[All,All,4]],
		secondaryWashOptionsWithCorrectDims[[All,All,5]]
	};

	numberOfSecondaryWashMismatchOptions=If[messages && Length[numberOfSecondaryWashesMismatchSamples] > 0,
		Message[Error::NumberOfSecondaryWashesMismatch,numberOfSecondaryWashesMismatchSamples];
		{NumberOfSecondaryWashes},
		{}
	];

	numberOfSecondaryWashMismatchTests=If[gatherTests && Length[numberOfSecondaryWashesMismatchSamples] > 0,
		Module[{passingSamples,failingTest,passingTest},
			passingSamples = Complement[flatSamples,numberOfSecondaryWashesMismatchSamples];

			(* create a test for the non-passing inputs *)
			failingTest=If[Length[numberOfSecondaryWashesMismatchSamples]>0,
				Test["NumberOfSecondaryWashes for the following samples "<>ObjectToString[numberOfSecondaryWashesMismatchSamples]<>" does not have mismatch with the length of SecondaryWashCollectionContainer and SecondaryWashCollectionContainerLabel:",True,False],
				Nothing
			];

			(* create a test for the passing inputs *)
			passingTest=If[Length[passingSamples]>0,
				Test["NumberOfSecondaryWashes for the following samples "<>ObjectToString[passingSamples]<>"  does not have mismatch with the length of SecondaryWashCollectionContainer and SecondaryWashCollectionContainerLabel:",True,True],
				Nothing
			];

			{passingTest, failingTest}
		],
		Nothing
	];

	(* -- TertiaryWash -- *)
	tertiaryWashOptionsWithCorrectDims=correctOptionsDimensions[
		simulatedSamples,
    If[EqualQ[Depth[resolvedTertiaryWashCollectionContainers/.ObjectP[]->Null],4],
      resolvedTertiaryWashCollectionContainers,
      unflattenListHelper[resolvedTertiaryWashCollectionContainers,simulatedSamples]],
    tertiaryWashDestinationWells,
    If[EqualQ[Depth[tertiaryWashCollectionContainerIndices],4],tertiaryWashCollectionContainerIndices,
      unflattenListHelper[tertiaryWashCollectionContainerIndices,simulatedSamples]],
    tertiaryWashCollectionContainerLabels,
		unflattenListHelper[resolvedNumberOfTertiaryWashes,simulatedSamples]/.{Null->1}
	];

	{
		numberOfTertiaryWashesMismatchSamples,
		correctedTertiaryWashCollectionContainers,
		correctedTertiaryWashDestinationWells,
		correctedTertiaryWashCollectionContainerIndices,
		correctedTertiaryWashCollectionContainerLabels
	}={
		Flatten[tertiaryWashOptionsWithCorrectDims[[All,All,1]]/.Null->Nothing],
		tertiaryWashOptionsWithCorrectDims[[All,All,2]],
		tertiaryWashOptionsWithCorrectDims[[All,All,3]],
		tertiaryWashOptionsWithCorrectDims[[All,All,4]],
		tertiaryWashOptionsWithCorrectDims[[All,All,5]]
	};

	numberOfTertiaryWashMismatchOptions=If[messages && Length[numberOfTertiaryWashesMismatchSamples] > 0,
		Message[Error::NumberOfTertiaryWashesMismatch,numberOfTertiaryWashesMismatchSamples];
		{NumberOfTertiaryWashes},
		{}
	];

	numberOfTertiaryWashMismatchTests=If[gatherTests && Length[numberOfTertiaryWashesMismatchSamples] > 0,
		Module[{passingSamples,failingTest,passingTest},
			passingSamples = Complement[flatSamples,numberOfTertiaryWashesMismatchSamples];

			(* create a test for the non-passing inputs *)
			failingTest=If[Length[numberOfTertiaryWashesMismatchSamples]>0,
				Test["NumberOfTertiaryWashes for the following samples "<>ObjectToString[numberOfTertiaryWashesMismatchSamples]<>" does not have mismatch with the length of TertiaryWashCollectionContainer and TertiaryWashCollectionContainerLabel:",True,False],
				Nothing
			];

			(* create a test for the passing inputs *)
			passingTest=If[Length[passingSamples]>0,
				Test["NumberOfTertiaryWashes for the following samples "<>ObjectToString[passingSamples]<>"  does not have mismatch with the length of TertiaryWashCollectionContainer and TertiaryWashCollectionContainerLabel:",True,True],
				Nothing
			];

			{passingTest, failingTest}
		],
		Nothing
	];

	(* -- QuaternaryWash -- *)
	quaternaryWashOptionsWithCorrectDims=correctOptionsDimensions[
		simulatedSamples,
    If[EqualQ[Depth[resolvedQuaternaryWashCollectionContainers/.ObjectP[]->Null],4],
      resolvedQuaternaryWashCollectionContainers,
      unflattenListHelper[resolvedQuaternaryWashCollectionContainers,simulatedSamples]],
    quaternaryWashDestinationWells,
    If[EqualQ[Depth[quaternaryWashCollectionContainerIndices],4],quaternaryWashCollectionContainerIndices,
      unflattenListHelper[quaternaryWashCollectionContainerIndices,simulatedSamples]],
    quaternaryWashCollectionContainerLabels,
		unflattenListHelper[resolvedNumberOfQuaternaryWashes,simulatedSamples]/.{Null->1}
	];

	{
		numberOfQuaternaryWashesMismatchSamples,
		correctedQuaternaryWashCollectionContainers,
		correctedQuaternaryWashDestinationWells,
		correctedQuaternaryWashCollectionContainerIndices,
		correctedQuaternaryWashCollectionContainerLabels
	}={
		Flatten[quaternaryWashOptionsWithCorrectDims[[All,All,1]]/.Null->Nothing],
		quaternaryWashOptionsWithCorrectDims[[All,All,2]],
		quaternaryWashOptionsWithCorrectDims[[All,All,3]],
		quaternaryWashOptionsWithCorrectDims[[All,All,4]],
		quaternaryWashOptionsWithCorrectDims[[All,All,5]]
	};

	numberOfQuaternaryWashMismatchOptions=If[messages && Length[numberOfQuaternaryWashesMismatchSamples] > 0,
		Message[Error::NumberOfQuaternaryWashesMismatch,numberOfQuaternaryWashesMismatchSamples];
		{NumberOfQuaternaryWashes},
		{}
	];

	numberOfQuaternaryWashMismatchTests=If[gatherTests && Length[numberOfQuaternaryWashesMismatchSamples] > 0,
		Module[{passingSamples,failingTest,passingTest},
			passingSamples = Complement[flatSamples,numberOfQuaternaryWashesMismatchSamples];

			(* create a test for the non-passing inputs *)
			failingTest=If[Length[numberOfQuaternaryWashesMismatchSamples]>0,
				Test["NumberOfQuaternaryWashes for the following samples "<>ObjectToString[numberOfQuaternaryWashesMismatchSamples]<>" does not have mismatch with the length of QuaternaryWashCollectionContainer and QuaternaryWashCollectionContainerLabel:",True,False],
				Nothing
			];

			(* create a test for the passing inputs *)
			passingTest=If[Length[passingSamples]>0,
				Test["NumberOfQuaternaryWashes for the following samples "<>ObjectToString[passingSamples]<>"  does not have mismatch with the length of QuaternaryWashCollectionContainer and QuaternaryWashCollectionContainerLabel:",True,True],
				Nothing
			];

			{passingTest, failingTest}
		],
		Nothing
	];

	(* -- QuinaryWash -- *)
	quinaryWashOptionsWithCorrectDims=correctOptionsDimensions[
		simulatedSamples,
    If[EqualQ[Depth[resolvedQuinaryWashCollectionContainers/.ObjectP[]->Null],4],
      resolvedQuinaryWashCollectionContainers,
      unflattenListHelper[resolvedQuinaryWashCollectionContainers,simulatedSamples]],
    quinaryWashDestinationWells,
    If[EqualQ[Depth[quinaryWashCollectionContainerIndices],4],quinaryWashCollectionContainerIndices,
      unflattenListHelper[quinaryWashCollectionContainerIndices,simulatedSamples]],
    quinaryWashCollectionContainerLabels,
		unflattenListHelper[resolvedNumberOfQuinaryWashes,simulatedSamples]/.{Null->1}
	];

	{
		numberOfQuinaryWashesMismatchSamples,
		correctedQuinaryWashCollectionContainers,
		correctedQuinaryWashDestinationWells,
		correctedQuinaryWashCollectionContainerIndices,
		correctedQuinaryWashCollectionContainerLabels
	}={
		Flatten[quinaryWashOptionsWithCorrectDims[[All,All,1]]/.Null->Nothing],
		quinaryWashOptionsWithCorrectDims[[All,All,2]],
		quinaryWashOptionsWithCorrectDims[[All,All,3]],
		quinaryWashOptionsWithCorrectDims[[All,All,4]],
		quinaryWashOptionsWithCorrectDims[[All,All,5]]
	};

	numberOfQuinaryWashMismatchOptions=If[messages && Length[numberOfQuinaryWashesMismatchSamples] > 0,
		Message[Error::NumberOfQuinaryWashesMismatch,numberOfQuinaryWashesMismatchSamples];
		{NumberOfQuinaryWashes},
		{}
	];

	numberOfQuinaryWashMismatchTests=If[gatherTests && Length[numberOfQuinaryWashesMismatchSamples] > 0,
		Module[{passingSamples,failingTest,passingTest},
			passingSamples = Complement[flatSamples,numberOfQuinaryWashesMismatchSamples];

			(* create a test for the non-passing inputs *)
			failingTest=If[Length[numberOfQuinaryWashesMismatchSamples]>0,
				Test["NumberOfQuinaryWashes for the following samples "<>ObjectToString[numberOfQuinaryWashesMismatchSamples]<>" does not have mismatch with the length of QuinaryWashCollectionContainer and QuinaryWashCollectionContainerLabel:",True,False],
				Nothing
			];

			(* create a test for the passing inputs *)
			passingTest=If[Length[passingSamples]>0,
				Test["NumberOfQuinaryWashes for the following samples "<>ObjectToString[passingSamples]<>"  does not have mismatch with the length of QuinaryWashCollectionContainer and QuinaryWashCollectionContainerLabel:",True,True],
				Nothing
			];

			{passingTest, failingTest}
		],
		Nothing
	];

	(* -- SenaryWash -- *)
	senaryWashOptionsWithCorrectDims=correctOptionsDimensions[
		simulatedSamples,
    If[EqualQ[Depth[resolvedSenaryWashCollectionContainers/.ObjectP[]->Null],4],
      resolvedSenaryWashCollectionContainers,
      unflattenListHelper[resolvedSenaryWashCollectionContainers,simulatedSamples]],
    senaryWashDestinationWells,
    If[EqualQ[Depth[senaryWashCollectionContainerIndices],4],senaryWashCollectionContainerIndices,
      unflattenListHelper[senaryWashCollectionContainerIndices,simulatedSamples]],
    senaryWashCollectionContainerLabels,
		unflattenListHelper[resolvedNumberOfSenaryWashes,simulatedSamples]/.{Null->1}
	];

	{
		numberOfSenaryWashesMismatchSamples,
		correctedSenaryWashCollectionContainers,
		correctedSenaryWashDestinationWells,
		correctedSenaryWashCollectionContainerIndices,
		correctedSenaryWashCollectionContainerLabels
	}={
		Flatten[senaryWashOptionsWithCorrectDims[[All,All,1]]/.Null->Nothing],
		senaryWashOptionsWithCorrectDims[[All,All,2]],
		senaryWashOptionsWithCorrectDims[[All,All,3]],
		senaryWashOptionsWithCorrectDims[[All,All,4]],
		senaryWashOptionsWithCorrectDims[[All,All,5]]
	};

	numberOfSenaryWashMismatchOptions=If[messages && Length[numberOfSenaryWashesMismatchSamples] > 0,
		Message[Error::NumberOfSenaryWashesMismatch,numberOfSenaryWashesMismatchSamples];
		{NumberOfSenaryWashes},
		{}
	];

	numberOfSenaryWashMismatchTests=If[gatherTests && Length[numberOfSenaryWashesMismatchSamples] > 0,
		Module[{passingSamples,failingTest,passingTest},
			passingSamples = Complement[flatSamples,numberOfSenaryWashesMismatchSamples];

			(* create a test for the non-passing inputs *)
			failingTest=If[Length[numberOfSenaryWashesMismatchSamples]>0,
				Test["NumberOfSenaryWashes for the following samples "<>ObjectToString[numberOfSenaryWashesMismatchSamples]<>" does not have mismatch with the length of SenaryWashCollectionContainer and SenaryWashCollectionContainerLabel:",True,False],
				Nothing
			];

			(* create a test for the passing inputs *)
			passingTest=If[Length[passingSamples]>0,
				Test["NumberOfSenaryWashes for the following samples "<>ObjectToString[passingSamples]<>"  does not have mismatch with the length of SenaryWashCollectionContainer and SenaryWashCollectionContainerLabel:",True,True],
				Nothing
			];

			{passingTest, failingTest}
		],
		Nothing
	];

	(* -- SeptenaryWash -- *)
	septenaryWashOptionsWithCorrectDims=correctOptionsDimensions[
		simulatedSamples,
    If[EqualQ[Depth[resolvedSeptenaryWashCollectionContainers/.ObjectP[]->Null],4],
      resolvedSeptenaryWashCollectionContainers,
      unflattenListHelper[resolvedSeptenaryWashCollectionContainers,simulatedSamples]],
    septenaryWashDestinationWells,
    If[EqualQ[Depth[septenaryWashCollectionContainerIndices],4],septenaryWashCollectionContainerIndices,
      unflattenListHelper[septenaryWashCollectionContainerIndices,simulatedSamples]],
    septenaryWashCollectionContainerLabels,
		unflattenListHelper[resolvedNumberOfSeptenaryWashes,simulatedSamples]/.{Null->1}
	];

	{
		numberOfSeptenaryWashesMismatchSamples,
		correctedSeptenaryWashCollectionContainers,
		correctedSeptenaryWashDestinationWells,
		correctedSeptenaryWashCollectionContainerIndices,
		correctedSeptenaryWashCollectionContainerLabels
	}={
		Flatten[septenaryWashOptionsWithCorrectDims[[All,All,1]]/.Null->Nothing],
		septenaryWashOptionsWithCorrectDims[[All,All,2]],
		septenaryWashOptionsWithCorrectDims[[All,All,3]],
		septenaryWashOptionsWithCorrectDims[[All,All,4]],
		septenaryWashOptionsWithCorrectDims[[All,All,5]]
	};

	numberOfSeptenaryWashMismatchOptions=If[messages && Length[numberOfSeptenaryWashesMismatchSamples] > 0,
		Message[Error::NumberOfSeptenaryWashesMismatch,numberOfSeptenaryWashesMismatchSamples];
		{NumberOfSeptenaryWashes},
		{}
	];

	numberOfSeptenaryWashMismatchTests=If[gatherTests && Length[numberOfSeptenaryWashesMismatchSamples] > 0,
		Module[{passingSamples,failingTest,passingTest},
			passingSamples = Complement[flatSamples,numberOfSeptenaryWashesMismatchSamples];

			(* create a test for the non-passing inputs *)
			failingTest=If[Length[numberOfSeptenaryWashesMismatchSamples]>0,
				Test["NumberOfSeptenaryWashes for the following samples "<>ObjectToString[numberOfSeptenaryWashesMismatchSamples]<>" does not have mismatch with the length of SeptenaryWashCollectionContainer and SeptenaryWashCollectionContainerLabel:",True,False],
				Nothing
			];

			(* create a test for the passing inputs *)
			passingTest=If[Length[passingSamples]>0,
				Test["NumberOfSeptenaryWashes for the following samples "<>ObjectToString[passingSamples]<>"  does not have mismatch with the length of SeptenaryWashCollectionContainer and SeptenaryWashCollectionContainerLabel:",True,True],
				Nothing
			];

			{passingTest, failingTest}
		],
		Nothing
	];

	(* -- Elution -- *)
  (* Correcting dimension is needed before storage condition checking becuase container can be mismatched in nested length with previously corrected indices and wells*)
  elutionOptionsWithCorrectDims=correctOptionsDimensions[
    simulatedSamples,
    If[EqualQ[Depth[resolvedElutionCollectionContainers/.ObjectP[]->Null],4],
      resolvedElutionCollectionContainers,
      unflattenListHelper[resolvedElutionCollectionContainers,simulatedSamples]],
    elutionDestinationWells,
    If[EqualQ[Depth[elutionCollectionContainerIndices],4],elutionCollectionContainerIndices,
    unflattenListHelper[elutionCollectionContainerIndices,simulatedSamples]],
    elutionCollectionContainerLabels,
    unflattenListHelper[resolvedNumberOfElutions,simulatedSamples]/.{Null->1}
  ];

	{
		numberOfElutionsMismatchSamples,
		correctedElutionCollectionContainers,
		correctedElutionDestinationWells,
		correctedElutionCollectionContainerIndices,
		correctedElutionCollectionContainerLabels
	}={
		Flatten[elutionOptionsWithCorrectDims[[All,All,1]]/.Null->Nothing],
		elutionOptionsWithCorrectDims[[All,All,2]],
		elutionOptionsWithCorrectDims[[All,All,3]],
		elutionOptionsWithCorrectDims[[All,All,4]],
		elutionOptionsWithCorrectDims[[All,All,5]]
	};

	numberOfElutionMismatchOptions=If[messages && Length[numberOfElutionsMismatchSamples] > 0,
		Message[Error::NumberOfElutionsMismatch,numberOfElutionsMismatchSamples];
		{NumberOfElutions},
		{}
	];

	numberOfElutionMismatchTests=If[gatherTests && Length[numberOfElutionsMismatchSamples] > 0,
		Module[{passingSamples,failingTest,passingTest},
			passingSamples = Complement[flatSamples,numberOfElutionsMismatchSamples];

			(* create a test for the non-passing inputs *)
			failingTest=If[Length[numberOfElutionsMismatchSamples]>0,
				Test["NumberOfElutions for the following samples "<>ObjectToString[numberOfElutionsMismatchSamples]<>" does not have mismatch with the length of ElutionCollectionContainer and ElutionCollectionContainerLabel:",True,False],
				Nothing
			];

			(* create a test for the passing inputs *)
			passingTest=If[Length[passingSamples]>0,
				Test["NumberOfElutions for the following samples "<>ObjectToString[passingSamples]<>"  does not have mismatch with the length of ElutionCollectionContainer and ElutionCollectionContainerLabel:",True,True],
				Nothing
			];

			{passingTest, failingTest}
		],
		Nothing
	];

	(* Resolve the collection container labels and destination wells *)
	(* Initiate a lookup to track existing collection containers and available destination wells *)
	collectionContainerLookup = <||>;

	(* Initialize error tracking variables *)
	invalidDestinationWells={}; (* Tuples of well, container, stage *)
	noAvailablePositionsInContainer={}; (* Tuple of container, stage *)

	(* Get the resolved collection containers and resolved destination wells *)
	{
		resolvedPreWashCollectionContainerLabels,
		resolvedPreWashDestinationWells,
		resolvedEquilibrationCollectionContainerLabels,
		resolvedEquilibrationDestinationWells,
		resolvedLoadingCollectionContainerLabels,
		resolvedLoadingDestinationWells,
		resolvedWashCollectionContainerLabels,
		resolvedWashDestinationWells,
		resolvedSecondaryWashCollectionContainerLabels,
		resolvedSecondaryWashDestinationWells,
		resolvedTertiaryWashCollectionContainerLabels,
		resolvedTertiaryWashDestinationWells,
		resolvedQuaternaryWashCollectionContainerLabels,
		resolvedQuaternaryWashDestinationWells,
		resolvedQuinaryWashCollectionContainerLabels,
		resolvedQuinaryWashDestinationWells,
		resolvedSenaryWashCollectionContainerLabels,
		resolvedSenaryWashDestinationWells,
		resolvedSeptenaryWashCollectionContainerLabels,
		resolvedSeptenaryWashDestinationWells,
		resolvedElutionCollectionContainerLabels,
		resolvedElutionDestinationWells
	}=Transpose@MapThread[
		Function[
			{
			preWashCollectionContainersBatch,preWashDestinationWellsBatch,preWashCollectionContainerIndicesBatch,preWashCollectionContainerLabelsBatch,preWashCollectionStorageConditionsBatch,preWashesBatch,
			equilibrationCollectionContainersBatch,equilibrationDestinationWellsBatch,equilibrationCollectionContainerIndicesBatch,equilibrationCollectionContainerLabelsBatch,equilibrationCollectionStorageConditionsBatch,equilibrationsBatch,
			loadingCollectionContainersBatch,loadingDestinationWellsBatch,loadingCollectionContainerIndicesBatch,loadingCollectionContainerLabelsBatch,loadingCollectionStorageConditionsBatch,loadingsBatch,
			washCollectionContainersBatch,washDestinationWellsBatch,washCollectionContainerIndicesBatch,washCollectionContainerLabelsBatch,washCollectionStorageConditionsBatch,washesBatch,
				secondaryWashCollectionContainersBatch,secondaryWashDestinationWellsBatch,secondaryWashCollectionContainerIndicesBatch,secondaryWashCollectionContainerLabelsBatch,secondaryWashCollectionStorageConditionsBatch,secondaryWashesBatch,
				tertiaryWashCollectionContainersBatch,tertiaryWashDestinationWellsBatch,tertiaryWashCollectionContainerIndicesBatch,tertiaryWashCollectionContainerLabelsBatch,tertiaryWashCollectionStorageConditionsBatch,tertiaryWashesBatch,
				quaternaryWashCollectionContainersBatch,quaternaryWashDestinationWellsBatch,quaternaryWashCollectionContainerIndicesBatch,quaternaryWashCollectionContainerLabelsBatch,quaternaryWashCollectionStorageConditionsBatch,quaternaryWashesBatch,
				quinaryWashCollectionContainersBatch,quinaryWashDestinationWellsBatch,quinaryWashCollectionContainerIndicesBatch,quinaryWashCollectionContainerLabelsBatch,quinaryWashCollectionStorageConditionsBatch,quinaryWashesBatch,
				senaryWashCollectionContainersBatch,senaryWashDestinationWellsBatch,senaryWashCollectionContainerIndicesBatch,senaryWashCollectionContainerLabelsBatch,senaryWashCollectionStorageConditionsBatch,senaryWashesBatch,
				septenaryWashCollectionContainersBatch,septenaryWashDestinationWellsBatch,septenaryWashCollectionContainerIndicesBatch,septenaryWashCollectionContainerLabelsBatch,septenaryWashCollectionStorageConditionsBatch,septenaryWashesBatch,
			elutionCollectionContainersBatch,elutionDestinationWellsBatch,elutionCollectionContainerIndicesBatch,elutionCollectionContainerLabelsBatch,elutionCollectionStorageConditionsBatch,elutionsBatch,
			simulatedSamplesBatch
		},
			Module[
				{
					preWashOutput,resolvedPreWashCollectionContainerLabel,resolvedPreWashDestinationWell,
					equilibrationOutput,resolvedEquilibrationCollectionContainerLabel,resolvedEquilibrationDestinationWell,
					loadingOutput,resolvedLoadingCollectionContainerLabel,resolvedLoadingDestinationWell,
					washOutput,resolvedWashCollectionContainerLabel,resolvedWashDestinationWell,
					secondaryWashOutput,resolvedSecondaryWashCollectionContainerLabel,resolvedSecondaryWashDestinationWell,
					tertiaryWashOutput,resolvedTertiaryWashCollectionContainerLabel,resolvedTertiaryWashDestinationWell,
					quaternaryWashOutput,resolvedQuaternaryWashCollectionContainerLabel,resolvedQuaternaryWashDestinationWell,
					quinaryWashOutput,resolvedQuinaryWashCollectionContainerLabel,resolvedQuinaryWashDestinationWell,
					senaryWashOutput,resolvedSenaryWashCollectionContainerLabel,resolvedSenaryWashDestinationWell,
					septenaryWashOutput,resolvedSeptenaryWashCollectionContainerLabel,resolvedSeptenaryWashDestinationWell,
					elutionOutput,resolvedElutionCollectionContainerLabel,resolvedElutionDestinationWell
				},
				(* Resolve stage by stage for each batch *)

				(* -- PreWash -- *)
				{preWashOutput,collectionContainerLookup,invalidDestinationWells,noAvailablePositionsInContainer}=resolveDestinationWellsAndContainerLabelsOfStage[preWashCollectionContainersBatch,preWashDestinationWellsBatch,preWashCollectionContainerIndicesBatch,preWashCollectionContainerLabelsBatch, preWashCollectionStorageConditionsBatch,preWashesBatch,simulatedSamplesBatch,collectionContainerLookup,invalidDestinationWells,noAvailablePositionsInContainer,combinedFastAssoc,"PreWash"];
				{resolvedPreWashCollectionContainerLabel,resolvedPreWashDestinationWell}={preWashOutput[[All,1]],preWashOutput[[All,2]]};

				(* -- Equilibration -- *)
				{equilibrationOutput,collectionContainerLookup,invalidDestinationWells,noAvailablePositionsInContainer}=resolveDestinationWellsAndContainerLabelsOfStage[equilibrationCollectionContainersBatch,equilibrationDestinationWellsBatch,equilibrationCollectionContainerIndicesBatch,equilibrationCollectionContainerLabelsBatch,equilibrationCollectionStorageConditionsBatch,equilibrationsBatch,simulatedSamplesBatch,collectionContainerLookup,invalidDestinationWells,noAvailablePositionsInContainer,combinedFastAssoc,"Equilibration"];
				{resolvedEquilibrationCollectionContainerLabel,resolvedEquilibrationDestinationWell}={equilibrationOutput[[All,1]],equilibrationOutput[[All,2]]};

				(* -- Loading -- *)
				{loadingOutput,collectionContainerLookup,invalidDestinationWells,noAvailablePositionsInContainer}=resolveDestinationWellsAndContainerLabelsOfStage[loadingCollectionContainersBatch,loadingDestinationWellsBatch,loadingCollectionContainerIndicesBatch,loadingCollectionContainerLabelsBatch,loadingCollectionStorageConditionsBatch,loadingsBatch,simulatedSamplesBatch,collectionContainerLookup,invalidDestinationWells,noAvailablePositionsInContainer,combinedFastAssoc,"Loading"];
				{resolvedLoadingCollectionContainerLabel,resolvedLoadingDestinationWell}={loadingOutput[[All,1]],loadingOutput[[All,2]]};

				(* -- Wash -- *)
				{washOutput,collectionContainerLookup,invalidDestinationWells,noAvailablePositionsInContainer}=resolveDestinationWellsAndContainerLabelsOfStage[washCollectionContainersBatch,washDestinationWellsBatch,washCollectionContainerIndicesBatch,washCollectionContainerLabelsBatch,washCollectionStorageConditionsBatch,washesBatch,simulatedSamplesBatch,collectionContainerLookup,invalidDestinationWells,noAvailablePositionsInContainer,combinedFastAssoc,"Wash"];
				{resolvedWashCollectionContainerLabel,resolvedWashDestinationWell}={washOutput[[All,1]],washOutput[[All,2]]};

				(* -- SecondaryWash -- *)
				{secondaryWashOutput,collectionContainerLookup,invalidDestinationWells,noAvailablePositionsInContainer}=resolveDestinationWellsAndContainerLabelsOfStage[secondaryWashCollectionContainersBatch,secondaryWashDestinationWellsBatch,secondaryWashCollectionContainerIndicesBatch,secondaryWashCollectionContainerLabelsBatch,secondaryWashCollectionStorageConditionsBatch,secondaryWashesBatch,simulatedSamplesBatch,collectionContainerLookup,invalidDestinationWells,noAvailablePositionsInContainer,combinedFastAssoc,"SecondaryWash"];
				{resolvedSecondaryWashCollectionContainerLabel,resolvedSecondaryWashDestinationWell}={secondaryWashOutput[[All,1]],secondaryWashOutput[[All,2]]};

				(* -- TertiaryWash -- *)
				{tertiaryWashOutput,collectionContainerLookup,invalidDestinationWells,noAvailablePositionsInContainer}=resolveDestinationWellsAndContainerLabelsOfStage[tertiaryWashCollectionContainersBatch,tertiaryWashDestinationWellsBatch,tertiaryWashCollectionContainerIndicesBatch,tertiaryWashCollectionContainerLabelsBatch,tertiaryWashCollectionStorageConditionsBatch,tertiaryWashesBatch,simulatedSamplesBatch,collectionContainerLookup,invalidDestinationWells,noAvailablePositionsInContainer,combinedFastAssoc,"TertiaryWash"];
				{resolvedTertiaryWashCollectionContainerLabel,resolvedTertiaryWashDestinationWell}={tertiaryWashOutput[[All,1]],tertiaryWashOutput[[All,2]]};

				(* -- QuaternaryWash -- *)
				{quaternaryWashOutput,collectionContainerLookup,invalidDestinationWells,noAvailablePositionsInContainer}=resolveDestinationWellsAndContainerLabelsOfStage[quaternaryWashCollectionContainersBatch,quaternaryWashDestinationWellsBatch,quaternaryWashCollectionContainerIndicesBatch,quaternaryWashCollectionContainerLabelsBatch,quaternaryWashCollectionStorageConditionsBatch,quaternaryWashesBatch,simulatedSamplesBatch,collectionContainerLookup,invalidDestinationWells,noAvailablePositionsInContainer,combinedFastAssoc,"QuaternaryWash"];
				{resolvedQuaternaryWashCollectionContainerLabel,resolvedQuaternaryWashDestinationWell}={quaternaryWashOutput[[All,1]],quaternaryWashOutput[[All,2]]};

				(* -- QuinaryWash -- *)
				{quinaryWashOutput,collectionContainerLookup,invalidDestinationWells,noAvailablePositionsInContainer}=resolveDestinationWellsAndContainerLabelsOfStage[quinaryWashCollectionContainersBatch,quinaryWashDestinationWellsBatch,quinaryWashCollectionContainerIndicesBatch,quinaryWashCollectionContainerLabelsBatch,quinaryWashCollectionStorageConditionsBatch,quinaryWashesBatch,simulatedSamplesBatch,collectionContainerLookup,invalidDestinationWells,noAvailablePositionsInContainer,combinedFastAssoc,"QuinaryWash"];
				{resolvedQuinaryWashCollectionContainerLabel,resolvedQuinaryWashDestinationWell}={quinaryWashOutput[[All,1]],quinaryWashOutput[[All,2]]};

				(* -- SenaryWash -- *)
				{senaryWashOutput,collectionContainerLookup,invalidDestinationWells,noAvailablePositionsInContainer}=resolveDestinationWellsAndContainerLabelsOfStage[senaryWashCollectionContainersBatch,senaryWashDestinationWellsBatch,senaryWashCollectionContainerIndicesBatch,senaryWashCollectionContainerLabelsBatch,senaryWashCollectionStorageConditionsBatch,senaryWashesBatch,simulatedSamplesBatch,collectionContainerLookup,invalidDestinationWells,noAvailablePositionsInContainer,combinedFastAssoc,"SenaryWash"];
				{resolvedSenaryWashCollectionContainerLabel,resolvedSenaryWashDestinationWell}={senaryWashOutput[[All,1]],senaryWashOutput[[All,2]]};


				(* -- SeptenaryWash -- *)
				{septenaryWashOutput,collectionContainerLookup,invalidDestinationWells,noAvailablePositionsInContainer}=resolveDestinationWellsAndContainerLabelsOfStage[septenaryWashCollectionContainersBatch,septenaryWashDestinationWellsBatch,septenaryWashCollectionContainerIndicesBatch,septenaryWashCollectionContainerLabelsBatch,septenaryWashCollectionStorageConditionsBatch,septenaryWashesBatch,simulatedSamplesBatch,collectionContainerLookup,invalidDestinationWells,noAvailablePositionsInContainer,combinedFastAssoc,"SeptenaryWash"];
				{resolvedSeptenaryWashCollectionContainerLabel,resolvedSeptenaryWashDestinationWell}={septenaryWashOutput[[All,1]],septenaryWashOutput[[All,2]]};


				(* -- Elution -- *)
				{elutionOutput,collectionContainerLookup,invalidDestinationWells,noAvailablePositionsInContainer}=resolveDestinationWellsAndContainerLabelsOfStage[elutionCollectionContainersBatch,elutionDestinationWellsBatch,elutionCollectionContainerIndicesBatch,elutionCollectionContainerLabelsBatch,elutionCollectionStorageConditionsBatch,elutionsBatch,simulatedSamplesBatch,collectionContainerLookup,invalidDestinationWells,noAvailablePositionsInContainer,combinedFastAssoc,"Elution"];
				{resolvedElutionCollectionContainerLabel,resolvedElutionDestinationWell}={elutionOutput[[All,1]],elutionOutput[[All,2]]};

				{
					resolvedPreWashCollectionContainerLabel,resolvedPreWashDestinationWell,resolvedEquilibrationCollectionContainerLabel,resolvedEquilibrationDestinationWell,
					resolvedLoadingCollectionContainerLabel,resolvedLoadingDestinationWell,resolvedWashCollectionContainerLabel,resolvedWashDestinationWell,
					resolvedSecondaryWashCollectionContainerLabel,resolvedSecondaryWashDestinationWell,
					resolvedTertiaryWashCollectionContainerLabel,resolvedTertiaryWashDestinationWell,
					resolvedQuaternaryWashCollectionContainerLabel,resolvedQuaternaryWashDestinationWell,
					resolvedQuinaryWashCollectionContainerLabel,resolvedQuinaryWashDestinationWell,
					resolvedSenaryWashCollectionContainerLabel,resolvedSenaryWashDestinationWell,
					resolvedSeptenaryWashCollectionContainerLabel,resolvedSeptenaryWashDestinationWell,
					resolvedElutionCollectionContainerLabel,resolvedElutionDestinationWell
				}
			]
		],
		{
			correctedPreWashCollectionContainers,
			correctedPreWashDestinationWells,
			correctedPreWashCollectionContainerIndices,
			correctedPreWashCollectionContainerLabels,
			unflattenListHelper[correctedPreWashCollectionStorageConditions,simulatedSamples],
			unflattenListHelper[resolvedPreWashes,simulatedSamples],

			correctedEquilibrationCollectionContainers,
			correctedEquilibrationDestinationWells,
			correctedEquilibrationCollectionContainerIndices,
			correctedEquilibrationCollectionContainerLabels,
			unflattenListHelper[correctedEquilibrationCollectionStorageConditions,simulatedSamples],
			unflattenListHelper[resolvedEquilibrations,simulatedSamples],

			correctedLoadingCollectionContainers,
			correctedLoadingDestinationWells,
			correctedEquilibrationCollectionContainerIndices,
			correctedLoadingCollectionContainerLabels,
			unflattenListHelper[correctedLoadingCollectionStorageConditions,simulatedSamples],
			unflattenListHelper[ConstantArray[True,Length[flatSamples]],simulatedSamples],

			correctedWashCollectionContainers,
			correctedWashDestinationWells,
			correctedWashCollectionContainerIndices,
			correctedWashCollectionContainerLabels,
			unflattenListHelper[correctedWashCollectionStorageConditions,simulatedSamples],
			unflattenListHelper[resolvedWashes,simulatedSamples],

			correctedSecondaryWashCollectionContainers,
			correctedSecondaryWashDestinationWells,
			correctedSecondaryWashCollectionContainerIndices,
			correctedSecondaryWashCollectionContainerLabels,
			unflattenListHelper[correctedSecondaryWashCollectionStorageConditions,simulatedSamples],
			unflattenListHelper[resolvedSecondaryWashes,simulatedSamples],

			correctedTertiaryWashCollectionContainers,
			correctedTertiaryWashDestinationWells,
			correctedTertiaryWashCollectionContainerIndices,
			correctedTertiaryWashCollectionContainerLabels,
			unflattenListHelper[correctedTertiaryWashCollectionStorageConditions,simulatedSamples],
			unflattenListHelper[resolvedTertiaryWashes,simulatedSamples],

			correctedQuaternaryWashCollectionContainers,
			correctedQuaternaryWashDestinationWells,
			correctedQuaternaryWashCollectionContainerIndices,
			correctedQuaternaryWashCollectionContainerLabels,
			unflattenListHelper[correctedQuaternaryWashCollectionStorageConditions,simulatedSamples],
			unflattenListHelper[resolvedQuaternaryWashes,simulatedSamples],

			correctedQuinaryWashCollectionContainers,
			correctedQuinaryWashDestinationWells,
			correctedQuinaryWashCollectionContainerIndices,
			correctedQuinaryWashCollectionContainerLabels,
			unflattenListHelper[correctedQuinaryWashCollectionStorageConditions,simulatedSamples],
			unflattenListHelper[resolvedQuinaryWashes,simulatedSamples],

			correctedSenaryWashCollectionContainers,
			correctedSenaryWashDestinationWells,
			correctedSenaryWashCollectionContainerIndices,
			correctedSenaryWashCollectionContainerLabels,
			unflattenListHelper[correctedSenaryWashCollectionStorageConditions,simulatedSamples],
			unflattenListHelper[resolvedSenaryWashes,simulatedSamples],

			correctedSeptenaryWashCollectionContainers,
			correctedSeptenaryWashDestinationWells,
			correctedSeptenaryWashCollectionContainerIndices,
			correctedSeptenaryWashCollectionContainerLabels,
			unflattenListHelper[correctedSeptenaryWashCollectionStorageConditions,simulatedSamples],
			unflattenListHelper[resolvedSeptenaryWashes,simulatedSamples],

			correctedElutionCollectionContainers,
			correctedElutionDestinationWells,
			correctedElutionCollectionContainerIndices,
			correctedElutionCollectionContainerLabels,
			unflattenListHelper[correctedElutionCollectionStorageConditions,simulatedSamples],
			unflattenListHelper[resolvedElutions,simulatedSamples],

			simulatedSamples
		}
	];

	(* Error handling for invalidDestinationWells *)
	invalidDestinationWellsOptions=If[messages && Length[invalidDestinationWells] > 0,
		Message[Error::InvalidDestinationWells, invalidDestinationWells[[All,1]], invalidDestinationWells[[All,2]], invalidDestinationWells[[All,3]]];
		(ToExpression[ToString[#]<>"DestinationWell"])&/@DeleteDuplicates[invalidDestinationWells[[All,3]]],
		{}
	];

	invalidDestinationWellsTests=If[gatherTests && Length[invalidDestinationWells] > 0,
		Module[{passingSamples,failingTest,passingTest},
			passingSamples = Complement[flatSimulatedSamples,invalidDestinationWells[[All,4]]];

			(* create a test for the non-passing inputs *)
			failingTest=If[Length[invalidDestinationWells]>0,
			Test["DestinationWell options for the following samples "<>ObjectToString[invalidDestinationWells[[All,4]]]<>" are valid:",True,False],
				Nothing
			];

			(* create a test for the passing inputs *)
			passingTest=If[Length[passingSamples]>0,
			Test["DestinationWell options for the following samples "<>ObjectToString[passingSamples]<>" are valid:",True,True],
				Nothing
			];

			{passingTest, failingTest}
		],
		Nothing
	];

	(* Warning handling for noAvailablePositionsInContainer *)
	If[messages && Length[noAvailablePositionsInContainer] > 0,
		Message[Warning::NoAvailablePositionsInContainer, noAvailablePositionsInContainer[[All,1]], noAvailablePositionsInContainer[[All,2]]]
	];

	noAvailablePositionsInContainerTests=If[gatherTests && Length[noAvailablePositionsInContainer] > 0,
		Module[{passingSamples,failingTest,passingTest},
			passingSamples = Complement[flatSimulatedSamples,noAvailablePositionsInContainer[[All,3]]];

			(* create a test for the non-passing inputs *)
			failingTest=If[Length[noAvailablePositionsInContainer]>0,
				Test["For the following samples "<>ObjectToString[noAvailablePositionsInContainer[[All,3]]]<>" the collection container has available positions:",True,False],
				Nothing
			];

			(* create a test for the passing inputs *)
			passingTest=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples]<>" the collection container has available positions:",True,True],
				Nothing
			];

			{passingTest, failingTest}
		],
		Nothing
	];

	(* Resolve SampleLabel *)
	resolvedSampleLabels= Module[
		{uniqueSamples,uniqueUserLabels,sampleLabelLookup,labelPrefix},
		(* get the unique samples in *)
		uniqueSamples=DeleteDuplicates[flatSamples];
		(* get the unique strings in user input*)
		uniqueUserLabels=DeleteDuplicates[DeleteCases[Flatten@sampleLabels,Automatic|Null]];
		(*If the specified sample labels is one string, use it as a label prefix, otherwise use "MBS Sample" as prefix*)
		labelPrefix=If[MatchQ[Length@uniqueUserLabels,1],
			FirstCase[uniqueUserLabels,_String,"MBS Sample"],
			"MBS Sample"];
		(* create a lookup of unique sample to label *)
		sampleLabelLookup=(#->CreateUniqueLabel[labelPrefix])&/@uniqueSamples;
		(*If there is same amount of unique samples and user specified labels, return the user specified*)
		If[MatchQ[Length@uniqueSamples,Length@uniqueUserLabels],
			sampleLabels,
			(* replace samples with their label *)
			myNestedSamples/.sample:ObjectP[Object[Sample]]:>Lookup[sampleLabelLookup,sample]
		]
	];

	(* Resolve SampleContainerLabel *)
	resolvedSampleContainerLabels=Module[
		{uniqueSamples,uniqueUserLabels,uniqueSampleContainers,labelPrefix,sampleContainerLookup,containerLabelLookup},
		(* get the unique samples in containers *)
		uniqueSamples=DeleteDuplicates[flatSamples];
		(* get the unique strings in user input*)
		uniqueUserLabels=DeleteDuplicates[DeleteCases[Flatten@sampleContainerLabels,Automatic|Null]];
		(* create a lookup of sample to container *)
		sampleContainerLookup=(#->Download[fastAssocLookup[combinedFastAssoc,#,Container],Object])&/@uniqueSamples;
		(* get the unique sample containers*)
		uniqueSampleContainers=DeleteDuplicates[Values[sampleContainerLookup]];
		(*If the specified sample container labels is one string, use it as a label prefix, otherwise use "MBS SampleContainer" as prefix*)
		labelPrefix=If[MatchQ[Length@uniqueUserLabels,1],
			FirstCase[uniqueUserLabels,_String,"MBS SampleContainer"],
			"MBS SampleContainer"];
		(* create a lookup of container to label *)
		containerLabelLookup=(#->CreateUniqueLabel[labelPrefix])&/@Values[sampleContainerLookup];
		(*If there is same amount of unique sample containers and user specified labels, return the user specified*)
		If[MatchQ[Length@uniqueSampleContainers,Length@uniqueUserLabels],
			sampleContainerLabels,
			(* replace samples with their container's label *)
			myNestedSamples/.sample:ObjectP[Object[Sample]]:>Lookup[containerLabelLookup,Lookup[sampleContainerLookup,sample]]
		]
	];

	(* If SamplesOutLabels has Automatic, resolve it *)
	resolvedSampleOutLabels=If[MemberQ[Flatten@Lookup[mbsOptions,SampleOutLabel],Automatic],
		(* Resolve SampleOutContainerLabel based on the selectionStrategy*)
		If[MatchQ[selectionStrategy,Positive],
			resolvedElutionDestinationWells/.well_String:>CreateUniqueLabel["MBS Sample Out"],
			resolvedLoadingDestinationWells/.well_String:>CreateUniqueLabel["MBS Sample Out"]
		],
		(* Otherwise, leave it as is *)
		Lookup[mbsOptions,SampleOutLabel] /. {Automatic -> CreateUniqueLabel["MBS Sample Out"]}
	];

	(* Resolve ContainerOutLabel based on the SelectionStrategy *)
	resolvedContainerOutLabels=If[MemberQ[Flatten@containerOutLabels,Automatic],
		If[MatchQ[selectionStrategy,Positive],
			resolvedElutionCollectionContainerLabels,
			resolvedLoadingCollectionContainerLabels
		],
		(* Otherwise, leave it as is *)
		containerOutLabels /. {Automatic -> CreateUniqueLabel["MBS Container Out"]}
	];

	(* 1. MixType Batching warnings. *)
	(* NOTE: Because the options in the mapthread were flattened all batch information was lost. So do error checking here. *)

	(* -- PreWash -- Make a lookup from container to samples with conflicting MixType options *)
	invalidPreWashMixTypeContainerToSampleLookup=If[!MatchQ[resolvedPreWashMixTypes,{Null..}],
		checkInvalidMixTypeForContainer[simulatedSamples,resolvedPreWashMixTypes,flatSimulatedSamplePackets],
		Nothing
	];

	preWashMixTypeWarnings=If[!MatchQ[invalidPreWashMixTypeContainerToSampleLookup,Alternatives[Nothing,{}]],
		True,
		False];

	If[preWashMixTypeWarnings && messages,
		Message[Warning::PreWashMixStowaways,ObjectToString[Values[invalidPreWashMixTypeContainerToSampleLookup]],ObjectToString[Keys[invalidPreWashMixTypeContainerToSampleLookup]]]
	];

	invalidPreWashMixTypeTests = If[preWashMixTypeWarnings && gatherTests,
		Module[{failingSamples,failingContainers,passingSamples,passingContainers,passingTest,failingTest},

			failingSamples = Flatten@Values[invalidPreWashMixTypeContainerToSampleLookup];
			failingContainers = Keys[invalidPreWashMixTypeContainerToSampleLookup];
			passingSamples = Complement[flatSimulatedSamples,failingSamples];
			passingContainers = Download[Lookup[Cases[flatSimulatedSamplePackets,KeyValuePattern[Object->#]][[1]],Container],Object]&/@passingSamples;

			(* create a test for the non-passing inputs *)
			failingTest=If[Length[failingSamples]>0,
				Test["PreWashMixType option for the following samples "<>ObjectToString[failingSamples]<>" in container(s) "<>ObjectToString[failingContainers]<>", are not conflicting:",True,False],
				Nothing
			];

			(* create a test for the passing inputs *)
			passingTest=If[Length[passingSamples]>0,
				Test["PreWashMixType option for the following samples "<>ObjectToString[passingSamples]<>" in container(s) "<>ObjectToString[passingContainers]<>", are not conflicting:",True,True],
				Nothing
			];

			{passingTest,failingTest}
		],
		Nothing
	];

	(* -- Equilibration -- Make a lookup from container to samples with conflicting MixType options *)
	invalidEquilibrationMixTypeContainerToSampleLookup=If[!MatchQ[resolvedEquilibrationMixTypes,{Null..}],
		checkInvalidMixTypeForContainer[simulatedSamples,resolvedEquilibrationMixTypes,flatSimulatedSamplePackets],
		Nothing];
	equilibrationMixTypeWarnings=If[!MatchQ[invalidEquilibrationMixTypeContainerToSampleLookup,Alternatives[Nothing,{}]],
		True,
		False];

	If[equilibrationMixTypeWarnings && messages,
		Message[Warning::EquilibrationMixStowaways,ObjectToString[Values[invalidEquilibrationMixTypeContainerToSampleLookup]],ObjectToString[Keys[invalidEquilibrationMixTypeContainerToSampleLookup]]]
	];

	invalidEquilibrationMixTypeTests = If[equilibrationMixTypeWarnings && gatherTests,
		Module[{failingSamples,failingContainers,passingSamples,passingContainers,passingTest,failingTest},

			failingSamples = Flatten@Values[invalidEquilibrationMixTypeContainerToSampleLookup];
			failingContainers = Keys[invalidEquilibrationMixTypeContainerToSampleLookup];
			passingSamples = Complement[flatSimulatedSamples,failingSamples];
			passingContainers = Download[Lookup[Cases[flatSimulatedSamplePackets,KeyValuePattern[Object->#]][[1]],Container],Object]&/@passingSamples;

			(* create a test for the non-passing inputs *)
			failingTest=If[Length[failingSamples]>0,
				Test["EquilibrationMixType option for the following samples "<>ObjectToString[failingSamples]<>" in container(s) "<>ObjectToString[failingContainers]<>", are not conflicting:",True,False],
				Nothing
			];

			(* create a test for the passing inputs *)
			passingTest=If[Length[passingSamples]>0,
				Test["EquilibrationMixType option for the following samples "<>ObjectToString[passingSamples]<>" in container(s) "<>ObjectToString[passingContainers]<>", are not conflicting:",True,True],
				Nothing
			];

			{passingTest,failingTest}
		],
		Nothing
	];

	(* -- Loading -- Make a lookup from container to samples with conflicting MixType options *)
	invalidLoadingMixTypeContainerToSampleLookup=If[!MatchQ[resolvedLoadingMixTypes,{Null..}],
		checkInvalidMixTypeForContainer[simulatedSamples,resolvedLoadingMixTypes,flatSimulatedSamplePackets],
		Nothing];
	loadingMixTypeWarnings=If[!MatchQ[invalidLoadingMixTypeContainerToSampleLookup,Alternatives[Nothing,{}]],
		True,
		False];

	If[loadingMixTypeWarnings && messages,
		Message[Warning::LoadingMixStowaways,ObjectToString[Values[invalidLoadingMixTypeContainerToSampleLookup]],ObjectToString[Keys[invalidLoadingMixTypeContainerToSampleLookup]]]
	];

	invalidLoadingMixTypeTests = If[loadingMixTypeWarnings && gatherTests,
		Module[{failingSamples,failingContainers,passingSamples,passingContainers,passingTest,failingTest},

			failingSamples = Flatten@Values[invalidLoadingMixTypeContainerToSampleLookup];
			failingContainers = Keys[invalidLoadingMixTypeContainerToSampleLookup];
			passingSamples = Complement[flatSimulatedSamples,failingSamples];
			passingContainers = Download[Lookup[Cases[flatSimulatedSamplePackets,KeyValuePattern[Object->#]][[1]],Container],Object]&/@passingSamples;

			(* create a test for the non-passing inputs *)
			failingTest=If[Length[failingSamples]>0,
				Test["LoadingMixType option for the following samples "<>ObjectToString[failingSamples]<>" in container(s) "<>ObjectToString[failingContainers]<>", are not conflicting:",True,False],
				Nothing
			];

			(* create a test for the passing inputs *)
			passingTest=If[Length[passingSamples]>0,
				Test["LoadingMixType option for the following samples "<>ObjectToString[passingSamples]<>" in container(s) "<>ObjectToString[passingContainers]<>", are not conflicting:",True,True],
				Nothing
			];

			{passingTest,failingTest}
		],
		Nothing
	];

	(* -- Wash -- Make a lookup from container to samples with conflicting MixType options *)
	invalidWashMixTypeContainerToSampleLookup=If[!MatchQ[resolvedWashMixTypes,{Null..}],
		checkInvalidMixTypeForContainer[simulatedSamples,resolvedWashMixTypes,flatSimulatedSamplePackets],
		Nothing];
	washMixTypeWarnings=If[!MatchQ[invalidWashMixTypeContainerToSampleLookup,Alternatives[Nothing,{}]],
		True,
		False];

	If[washMixTypeWarnings && messages,
		Message[Warning::WashMixStowaways,ObjectToString[Values[invalidWashMixTypeContainerToSampleLookup]],ObjectToString[Keys[invalidWashMixTypeContainerToSampleLookup]]]
	];

	invalidWashMixTypeTests = If[washMixTypeWarnings && gatherTests,
		Module[{failingSamples,failingContainers,passingSamples,passingContainers,passingTest,failingTest},

			failingSamples = Flatten@Values[invalidWashMixTypeContainerToSampleLookup];
			failingContainers = Keys[invalidWashMixTypeContainerToSampleLookup];
			passingSamples = Complement[flatSimulatedSamples,failingSamples];
			passingContainers = Download[Lookup[Cases[flatSimulatedSamplePackets,KeyValuePattern[Object->#]][[1]],Container],Object]&/@passingSamples;

			(* create a test for the non-passing inputs *)
			failingTest=If[Length[failingSamples]>0,
				Test["WashMixType option for the following samples "<>ObjectToString[failingSamples]<>" in container(s) "<>ObjectToString[failingContainers]<>", are not conflicting:",True,False],
				Nothing
			];

			(* create a test for the passing inputs *)
			passingTest=If[Length[passingSamples]>0,
				Test["WashMixType option for the following samples "<>ObjectToString[passingSamples]<>" in container(s) "<>ObjectToString[passingContainers]<>", are not conflicting:",True,True],
				Nothing
			];

			{passingTest,failingTest}
		],
		Nothing
	];

	(* -- SecondaryWash -- Make a lookup from container to samples with conflicting MixType options *)
	invalidSecondaryWashMixTypeContainerToSampleLookup=If[!MatchQ[resolvedSecondaryWashMixTypes,{Null..}],
		checkInvalidMixTypeForContainer[simulatedSamples,resolvedSecondaryWashMixTypes,flatSimulatedSamplePackets],
		Nothing];
	secondaryWashMixTypeWarnings=If[!MatchQ[invalidSecondaryWashMixTypeContainerToSampleLookup,Alternatives[Nothing,{}]],
		True,
		False];

	If[secondaryWashMixTypeWarnings && messages,
		Message[Warning::SecondaryWashMixStowaways,ObjectToString[Values[invalidSecondaryWashMixTypeContainerToSampleLookup]],ObjectToString[Keys[invalidSecondaryWashMixTypeContainerToSampleLookup]]]
	];

	invalidSecondaryWashMixTypeTests = If[secondaryWashMixTypeWarnings && gatherTests,
		Module[{failingSamples,failingContainers,passingSamples,passingContainers,passingTest,failingTest},

			failingSamples = Flatten@Values[invalidSecondaryWashMixTypeContainerToSampleLookup];
			failingContainers = Keys[invalidSecondaryWashMixTypeContainerToSampleLookup];
			passingSamples = Complement[flatSimulatedSamples,failingSamples];
			passingContainers = Download[Lookup[Cases[flatSimulatedSamplePackets,KeyValuePattern[Object->#]][[1]],Container],Object]&/@passingSamples;

			(* create a test for the non-passing inputs *)
			failingTest=If[Length[failingSamples]>0,
				Test["SecondaryWashMixType option for the following samples "<>ObjectToString[failingSamples]<>" in container(s) "<>ObjectToString[failingContainers]<>", are not conflicting:",True,False],
				Nothing
			];

			(* create a test for the passing inputs *)
			passingTest=If[Length[passingSamples]>0,
				Test["SecondaryWashMixType option for the following samples "<>ObjectToString[passingSamples]<>" in container(s) "<>ObjectToString[passingContainers]<>", are not conflicting:",True,True],
				Nothing
			];

			{passingTest,failingTest}
		],
		Nothing
	];

	(* -- TertiaryWash -- Make a lookup from container to samples with conflicting MixType options *)
	invalidTertiaryWashMixTypeContainerToSampleLookup=If[!MatchQ[resolvedTertiaryWashMixTypes,{Null..}],
		checkInvalidMixTypeForContainer[simulatedSamples,resolvedTertiaryWashMixTypes,flatSimulatedSamplePackets],
		Nothing];
	tertiaryWashMixTypeWarnings=If[!MatchQ[invalidTertiaryWashMixTypeContainerToSampleLookup,Alternatives[Nothing,{}]],
		True,
		False];

	If[tertiaryWashMixTypeWarnings && messages,
		Message[Warning::TertiaryWashMixStowaways,ObjectToString[Values[invalidTertiaryWashMixTypeContainerToSampleLookup]],ObjectToString[Keys[invalidTertiaryWashMixTypeContainerToSampleLookup]]]
	];

	invalidTertiaryWashMixTypeTests = If[tertiaryWashMixTypeWarnings && gatherTests,
		Module[{failingSamples,failingContainers,passingSamples,passingContainers,passingTest,failingTest},

			failingSamples = Flatten@Values[invalidTertiaryWashMixTypeContainerToSampleLookup];
			failingContainers = Keys[invalidTertiaryWashMixTypeContainerToSampleLookup];
			passingSamples = Complement[flatSimulatedSamples,failingSamples];
			passingContainers = Download[Lookup[Cases[flatSimulatedSamplePackets,KeyValuePattern[Object->#]][[1]],Container],Object]&/@passingSamples;

			(* create a test for the non-passing inputs *)
			failingTest=If[Length[failingSamples]>0,
				Test["TertiaryWashMixType option for the following samples "<>ObjectToString[failingSamples]<>" in container(s) "<>ObjectToString[failingContainers]<>", are not conflicting:",True,False],
				Nothing
			];

			(* create a test for the passing inputs *)
			passingTest=If[Length[passingSamples]>0,
				Test["TertiaryWashMixType option for the following samples "<>ObjectToString[passingSamples]<>" in container(s) "<>ObjectToString[passingContainers]<>", are not conflicting:",True,True],
				Nothing
			];

			{passingTest,failingTest}
		],
		Nothing
	];

	(* -- QuaternaryWash -- Make a lookup from container to samples with conflicting MixType options *)
	invalidQuaternaryWashMixTypeContainerToSampleLookup=If[!MatchQ[resolvedQuaternaryWashMixTypes,{Null..}],
		checkInvalidMixTypeForContainer[simulatedSamples,resolvedQuaternaryWashMixTypes,flatSimulatedSamplePackets],
		Nothing];
	quaternaryWashMixTypeWarnings=If[!MatchQ[invalidQuaternaryWashMixTypeContainerToSampleLookup,Alternatives[Nothing,{}]],
		True,
		False];

	If[quaternaryWashMixTypeWarnings && messages,
		Message[Warning::QuaternaryWashMixStowaways,ObjectToString[Values[invalidQuaternaryWashMixTypeContainerToSampleLookup]],ObjectToString[Keys[invalidQuaternaryWashMixTypeContainerToSampleLookup]]]
	];

	invalidQuaternaryWashMixTypeTests = If[quaternaryWashMixTypeWarnings && gatherTests,
		Module[{failingSamples,failingContainers,passingSamples,passingContainers,passingTest,failingTest},

			failingSamples = Flatten@Values[invalidQuaternaryWashMixTypeContainerToSampleLookup];
			failingContainers = Keys[invalidQuaternaryWashMixTypeContainerToSampleLookup];
			passingSamples = Complement[flatSimulatedSamples,failingSamples];
			passingContainers = Download[Lookup[Cases[flatSimulatedSamplePackets,KeyValuePattern[Object->#]][[1]],Container],Object]&/@passingSamples;

			(* create a test for the non-passing inputs *)
			failingTest=If[Length[failingSamples]>0,
				Test["QuaternaryWashMixType option for the following samples "<>ObjectToString[failingSamples]<>" in container(s) "<>ObjectToString[failingContainers]<>", are not conflicting:",True,False],
				Nothing
			];

			(* create a test for the passing inputs *)
			passingTest=If[Length[passingSamples]>0,
				Test["QuaternaryWashMixType option for the following samples "<>ObjectToString[passingSamples]<>" in container(s) "<>ObjectToString[passingContainers]<>", are not conflicting:",True,True],
				Nothing
			];

			{passingTest,failingTest}
		],
		Nothing
	];

	(* -- QuinaryWash -- Make a lookup from container to samples with conflicting MixType options *)
	invalidQuinaryWashMixTypeContainerToSampleLookup=If[!MatchQ[resolvedQuinaryWashMixTypes,{Null..}],
		checkInvalidMixTypeForContainer[simulatedSamples,resolvedQuinaryWashMixTypes,flatSimulatedSamplePackets],
		Nothing];
	quinaryWashMixTypeWarnings=If[!MatchQ[invalidQuinaryWashMixTypeContainerToSampleLookup,Alternatives[Nothing,{}]],
		True,
		False];

	If[quinaryWashMixTypeWarnings && messages,
		Message[Warning::QuinaryWashMixStowaways,ObjectToString[Values[invalidQuinaryWashMixTypeContainerToSampleLookup]],ObjectToString[Keys[invalidQuinaryWashMixTypeContainerToSampleLookup]]]
	];

	invalidQuinaryWashMixTypeTests = If[quinaryWashMixTypeWarnings && gatherTests,
		Module[{failingSamples,failingContainers,passingSamples,passingContainers,passingTest,failingTest},

			failingSamples = Flatten@Values[invalidQuinaryWashMixTypeContainerToSampleLookup];
			failingContainers = Keys[invalidQuinaryWashMixTypeContainerToSampleLookup];
			passingSamples = Complement[flatSimulatedSamples,failingSamples];
			passingContainers = Download[Lookup[Cases[flatSimulatedSamplePackets,KeyValuePattern[Object->#]][[1]],Container],Object]&/@passingSamples;

			(* create a test for the non-passing inputs *)
			failingTest=If[Length[failingSamples]>0,
				Test["QuinaryWashMixType option for the following samples "<>ObjectToString[failingSamples]<>" in container(s) "<>ObjectToString[failingContainers]<>", are not conflicting:",True,False],
				Nothing
			];

			(* create a test for the passing inputs *)
			passingTest=If[Length[passingSamples]>0,
				Test["QuinaryWashMixType option for the following samples "<>ObjectToString[passingSamples]<>" in container(s) "<>ObjectToString[passingContainers]<>", are not conflicting:",True,True],
				Nothing
			];

			{passingTest,failingTest}
		],
		Nothing
	];

	(* -- SenaryWash -- Make a lookup from container to samples with conflicting MixType options *)
	invalidSenaryWashMixTypeContainerToSampleLookup=If[!MatchQ[resolvedSenaryWashMixTypes,{Null..}],
		checkInvalidMixTypeForContainer[simulatedSamples,resolvedSenaryWashMixTypes,flatSimulatedSamplePackets],
		Nothing];
	senaryWashMixTypeWarnings=If[!MatchQ[invalidSenaryWashMixTypeContainerToSampleLookup,Alternatives[Nothing,{}]],
		True,
		False];

	If[senaryWashMixTypeWarnings && messages,
		Message[Warning::SenaryWashMixStowaways,ObjectToString[Values[invalidSenaryWashMixTypeContainerToSampleLookup]],ObjectToString[Keys[invalidSenaryWashMixTypeContainerToSampleLookup]]]
	];

	invalidSenaryWashMixTypeTests = If[senaryWashMixTypeWarnings && gatherTests,
		Module[{failingSamples,failingContainers,passingSamples,passingContainers,passingTest,failingTest},

			failingSamples = Flatten@Values[invalidSenaryWashMixTypeContainerToSampleLookup];
			failingContainers = Keys[invalidSenaryWashMixTypeContainerToSampleLookup];
			passingSamples = Complement[flatSimulatedSamples,failingSamples];
			passingContainers = Download[Lookup[Cases[flatSimulatedSamplePackets,KeyValuePattern[Object->#]][[1]],Container],Object]&/@passingSamples;

			(* create a test for the non-passing inputs *)
			failingTest=If[Length[failingSamples]>0,
				Test["SenaryWashMixType option for the following samples "<>ObjectToString[failingSamples]<>" in container(s) "<>ObjectToString[failingContainers]<>", are not conflicting:",True,False],
				Nothing
			];

			(* create a test for the passing inputs *)
			passingTest=If[Length[passingSamples]>0,
				Test["SenaryWashMixType option for the following samples "<>ObjectToString[passingSamples]<>" in container(s) "<>ObjectToString[passingContainers]<>", are not conflicting:",True,True],
				Nothing
			];

			{passingTest,failingTest}
		],
		Nothing
	];

	(* -- SeptenaryWash -- Make a lookup from container to samples with conflicting MixType options *)
	invalidSeptenaryWashMixTypeContainerToSampleLookup=If[!MatchQ[resolvedSeptenaryWashMixTypes,{Null..}],
		checkInvalidMixTypeForContainer[simulatedSamples,resolvedSeptenaryWashMixTypes,flatSimulatedSamplePackets],
		Nothing];
	septenaryWashMixTypeWarnings=If[!MatchQ[invalidSeptenaryWashMixTypeContainerToSampleLookup,Alternatives[Nothing,{}]],
		True,
		False];

	If[septenaryWashMixTypeWarnings && messages,
		Message[Warning::SeptenaryWashMixStowaways,ObjectToString[Values[invalidSeptenaryWashMixTypeContainerToSampleLookup]],ObjectToString[Keys[invalidSeptenaryWashMixTypeContainerToSampleLookup]]]
	];

	invalidSeptenaryWashMixTypeTests = If[septenaryWashMixTypeWarnings && gatherTests,
		Module[{failingSamples,failingContainers,passingSamples,passingContainers,passingTest,failingTest},

			failingSamples = Flatten@Values[invalidSeptenaryWashMixTypeContainerToSampleLookup];
			failingContainers = Keys[invalidSeptenaryWashMixTypeContainerToSampleLookup];
			passingSamples = Complement[flatSimulatedSamples,failingSamples];
			passingContainers = Download[Lookup[Cases[flatSimulatedSamplePackets,KeyValuePattern[Object->#]][[1]],Container],Object]&/@passingSamples;

			(* create a test for the non-passing inputs *)
			failingTest=If[Length[failingSamples]>0,
				Test["SeptenaryWashMixType option for the following samples "<>ObjectToString[failingSamples]<>" in container(s) "<>ObjectToString[failingContainers]<>", are not conflicting:",True,False],
				Nothing
			];

			(* create a test for the passing inputs *)
			passingTest=If[Length[passingSamples]>0,
				Test["SeptenaryWashMixType option for the following samples "<>ObjectToString[passingSamples]<>" in container(s) "<>ObjectToString[passingContainers]<>", are not conflicting:",True,True],
				Nothing
			];

			{passingTest,failingTest}
		],
		Nothing
	];


	(* -- Elution -- Make a lookup from container to samples with conflicting MixType options *)
	invalidElutionMixTypeContainerToSampleLookup=If[!MatchQ[resolvedElutionMixTypes,{Null..}],
		checkInvalidMixTypeForContainer[simulatedSamples,resolvedElutionMixTypes,flatSimulatedSamplePackets],
		Nothing];
	elutionMixTypeWarnings=If[!MatchQ[invalidElutionMixTypeContainerToSampleLookup,Alternatives[Nothing,{}]],
		True,
		False];

	If[elutionMixTypeWarnings && messages,
		Message[Warning::ElutionMixStowaways,ObjectToString[Values[invalidElutionMixTypeContainerToSampleLookup]],ObjectToString[Keys[invalidElutionMixTypeContainerToSampleLookup]]]
	];

	invalidElutionMixTypeTests = If[elutionMixTypeWarnings && gatherTests,
		Module[{failingSamples,failingContainers,passingSamples,passingContainers,passingTest,failingTest},

			failingSamples = Flatten@Values[invalidElutionMixTypeContainerToSampleLookup];
			failingContainers = Keys[invalidElutionMixTypeContainerToSampleLookup];
			passingSamples = Complement[flatSimulatedSamples,failingSamples];
			passingContainers = Download[Lookup[Cases[flatSimulatedSamplePackets,KeyValuePattern[Object->#]][[1]],Container],Object]&/@passingSamples;

			(* create a test for the non-passing inputs *)
			failingTest=If[Length[failingSamples]>0,
				Test["ElutionMixType option for the following samples "<>ObjectToString[failingSamples]<>" in container(s) "<>ObjectToString[failingContainers]<>", are not conflicting:",True,False],
				Nothing
			];

			(* create a test for the passing inputs *)
			passingTest=If[Length[passingSamples]>0,
				Test["ElutionMixType option for the following samples "<>ObjectToString[passingSamples]<>" in container(s) "<>ObjectToString[passingContainers]<>", are not conflicting:",True,True],
				Nothing
			];

			{passingTest,failingTest}
		],
		Nothing
	];

	(* 2. Air Dry Batching warnings *)
	(* PreWash *)
	preWashAirDryWarnings=checkConflictingAirDryOfStage[simulatedSamples,resolvedPreWashAirDries];

	If[Length[preWashAirDryWarnings]>0 && messages,
		Message[Warning::PreWashAirDryStowaways,preWashAirDryWarnings[[All,1]],preWashAirDryWarnings[[All,3]],preWashAirDryWarnings[[All,2]]]
	];

	invalidPreWashAirDryWarningTests = If[Length[preWashAirDryWarnings]>0 && gatherTests,
		Module[{failingSamples,passingSamples,passingTest,failingTest},

			failingSamples = Flatten@(preWashAirDryWarnings[[All,1]]);
			passingSamples = Complement[flatSimulatedSamples,failingSamples];

			(* create a test for the non-passing inputs *)
			failingTest=If[Length[failingSamples]>0,
				Test["PreWashAirDry option for the following samples "<>ObjectToString[failingSamples] <> "is not conflicting with other samples in their batch:",True,False],
				Nothing
			];

			(* create a test for the passing inputs *)
			passingTest=If[Length[passingSamples]>0,
				Test["PreWashAirDry option for the following samples "<>ObjectToString[passingSamples] <> "is not conflicting with other samples in their batch:",True,True],
				Nothing
			];

			{passingTest,failingTest}
		],
		Nothing
	];

	(* Equilibration *)
	equilibrationAirDryWarnings=checkConflictingAirDryOfStage[simulatedSamples,resolvedEquilibrationAirDries];

	If[Length[equilibrationAirDryWarnings]>0 && messages,
		Message[Warning::EquilibrationAirDryStowaways,equilibrationAirDryWarnings[[All,1]],equilibrationAirDryWarnings[[All,3]],equilibrationAirDryWarnings[[All,2]]]
	];

	invalidEquilibrationAirDryWarningTests = If[Length[equilibrationAirDryWarnings]>0 && gatherTests,
		Module[{failingSamples,passingSamples,passingTest,failingTest},

			failingSamples = Flatten@(equilibrationAirDryWarnings[[All,1]]);
			passingSamples = Complement[flatSimulatedSamples,failingSamples];

			(* create a test for the non-passing inputs *)
			failingTest=If[Length[failingSamples]>0,
				Test["EquilibrationAirDry option for the following samples "<>ObjectToString[failingSamples] <> "is not conflicting with other samples in their batch:",True,False],
				Nothing
			];

			(* create a test for the passing inputs *)
			passingTest=If[Length[passingSamples]>0,
				Test["EquilibrationAirDry option for the following samples "<>ObjectToString[passingSamples] <> "is not conflicting with other samples in their batch:",True,True],
				Nothing
			];

			{passingTest,failingTest}
		],
		Nothing
	];

	(* Loading *)
	loadingAirDryWarnings=checkConflictingAirDryOfStage[simulatedSamples,resolvedLoadingAirDries];

	If[Length[loadingAirDryWarnings]>0 && messages,
		Message[Warning::LoadingAirDryStowaways,loadingAirDryWarnings[[All,1]],loadingAirDryWarnings[[All,3]],loadingAirDryWarnings[[All,2]]]
	];

	invalidLoadingAirDryWarningTests = If[Length[loadingAirDryWarnings]>0 && gatherTests,
		Module[{failingSamples,passingSamples,passingTest,failingTest},

			failingSamples = Flatten@(loadingAirDryWarnings[[All,1]]);
			passingSamples = Complement[flatSimulatedSamples,failingSamples];

			(* create a test for the non-passing inputs *)
			failingTest=If[Length[failingSamples]>0,
				Test["LoadingAirDry option for the following samples "<>ObjectToString[failingSamples] <> "is not conflicting with other samples in their batch:",True,False],
				Nothing
			];

			(* create a test for the passing inputs *)
			passingTest=If[Length[passingSamples]>0,
				Test["LoadingAirDry option for the following samples "<>ObjectToString[passingSamples] <> "is not conflicting with other samples in their batch:",True,True],
				Nothing
			];

			{passingTest,failingTest}
		],
		Nothing
	];

	(* Wash *)
	washAirDryWarnings=checkConflictingAirDryOfStage[simulatedSamples,resolvedWashAirDries];

	If[Length[washAirDryWarnings]>0 && messages,
		Message[Warning::WashAirDryStowaways,washAirDryWarnings[[All,1]],washAirDryWarnings[[All,3]],washAirDryWarnings[[All,2]]]
	];

	invalidWashAirDryWarningTests = If[Length[washAirDryWarnings]>0 && gatherTests,
		Module[{failingSamples,passingSamples,passingTest,failingTest},

			failingSamples = Flatten@(washAirDryWarnings[[All,1]]);
			passingSamples = Complement[flatSimulatedSamples,failingSamples];

			(* create a test for the non-passing inputs *)
			failingTest=If[Length[failingSamples]>0,
				Test["WashAirDry option for the following samples "<>ObjectToString[failingSamples] <> "is not conflicting with other samples in their batch:",True,False],
				Nothing
			];

			(* create a test for the passing inputs *)
			passingTest=If[Length[passingSamples]>0,
				Test["WashAirDry option for the following samples "<>ObjectToString[passingSamples] <> "is not conflicting with other samples in their batch:",True,True],
				Nothing
			];

			{passingTest,failingTest}
		],
		Nothing
	];

	(* SecondaryWash *)
	secondaryWashAirDryWarnings=checkConflictingAirDryOfStage[simulatedSamples,resolvedSecondaryWashAirDries];

	If[Length[secondaryWashAirDryWarnings]>0 && messages,
		Message[Warning::SecondaryWashAirDryStowaways,secondaryWashAirDryWarnings[[All,1]],secondaryWashAirDryWarnings[[All,3]],secondaryWashAirDryWarnings[[All,2]]]
	];

	invalidSecondaryWashAirDryWarningTests = If[Length[secondaryWashAirDryWarnings]>0 && gatherTests,
		Module[{failingSamples,passingSamples,passingTest,failingTest},

			failingSamples = Flatten@(secondaryWashAirDryWarnings[[All,1]]);
			passingSamples = Complement[flatSimulatedSamples,failingSamples];

			(* create a test for the non-passing inputs *)
			failingTest=If[Length[failingSamples]>0,
				Test["SecondaryWashAirDry option for the following samples "<>ObjectToString[failingSamples] <> "is not conflicting with other samples in their batch:",True,False],
				Nothing
			];

			(* create a test for the passing inputs *)
			passingTest=If[Length[passingSamples]>0,
				Test["SecondaryWashAirDry option for the following samples "<>ObjectToString[passingSamples] <> "is not conflicting with other samples in their batch:",True,True],
				Nothing
			];

			{passingTest,failingTest}
		],
		Nothing
	];

	(* TertiaryWash *)
	tertiaryWashAirDryWarnings=checkConflictingAirDryOfStage[simulatedSamples,resolvedTertiaryWashAirDries];

	If[Length[tertiaryWashAirDryWarnings]>0 && messages,
		Message[Warning::TertiaryWashAirDryStowaways,tertiaryWashAirDryWarnings[[All,1]],tertiaryWashAirDryWarnings[[All,3]],tertiaryWashAirDryWarnings[[All,2]]]
	];

	invalidTertiaryWashAirDryWarningTests = If[Length[tertiaryWashAirDryWarnings]>0 && gatherTests,
		Module[{failingSamples,passingSamples,passingTest,failingTest},

			failingSamples = Flatten@(tertiaryWashAirDryWarnings[[All,1]]);
			passingSamples = Complement[flatSimulatedSamples,failingSamples];

			(* create a test for the non-passing inputs *)
			failingTest=If[Length[failingSamples]>0,
				Test["TertiaryWashAirDry option for the following samples "<>ObjectToString[failingSamples] <> "is not conflicting with other samples in their batch:",True,False],
				Nothing
			];

			(* create a test for the passing inputs *)
			passingTest=If[Length[passingSamples]>0,
				Test["TertiaryWashAirDry option for the following samples "<>ObjectToString[passingSamples] <> "is not conflicting with other samples in their batch:",True,True],
				Nothing
			];

			{passingTest,failingTest}
		],
		Nothing
	];

	(* QuaternaryWash *)
	quaternaryWashAirDryWarnings=checkConflictingAirDryOfStage[simulatedSamples,resolvedQuaternaryWashAirDries];

	If[Length[quaternaryWashAirDryWarnings]>0 && messages,
		Message[Warning::QuaternaryWashAirDryStowaways,quaternaryWashAirDryWarnings[[All,1]],quaternaryWashAirDryWarnings[[All,3]],quaternaryWashAirDryWarnings[[All,2]]]
	];

	invalidQuaternaryWashAirDryWarningTests = If[Length[quaternaryWashAirDryWarnings]>0 && gatherTests,
		Module[{failingSamples,passingSamples,passingTest,failingTest},

			failingSamples = Flatten@(quaternaryWashAirDryWarnings[[All,1]]);
			passingSamples = Complement[flatSimulatedSamples,failingSamples];

			(* create a test for the non-passing inputs *)
			failingTest=If[Length[failingSamples]>0,
				Test["QuaternaryWashAirDry option for the following samples "<>ObjectToString[failingSamples] <> "is not conflicting with other samples in their batch:",True,False],
				Nothing
			];

			(* create a test for the passing inputs *)
			passingTest=If[Length[passingSamples]>0,
				Test["QuaternaryWashAirDry option for the following samples "<>ObjectToString[passingSamples] <> "is not conflicting with other samples in their batch:",True,True],
				Nothing
			];

			{passingTest,failingTest}
		],
		Nothing
	];

	(* QuinaryWash *)
	quinaryWashAirDryWarnings=checkConflictingAirDryOfStage[simulatedSamples,resolvedQuinaryWashAirDries];

	If[Length[quinaryWashAirDryWarnings]>0 && messages,
		Message[Warning::QuinaryWashAirDryStowaways,quinaryWashAirDryWarnings[[All,1]],quinaryWashAirDryWarnings[[All,3]],quinaryWashAirDryWarnings[[All,2]]]
	];

	invalidQuinaryWashAirDryWarningTests = If[Length[quinaryWashAirDryWarnings]>0 && gatherTests,
		Module[{failingSamples,passingSamples,passingTest,failingTest},

			failingSamples = Flatten@(quinaryWashAirDryWarnings[[All,1]]);
			passingSamples = Complement[flatSimulatedSamples,failingSamples];

			(* create a test for the non-passing inputs *)
			failingTest=If[Length[failingSamples]>0,
				Test["QuinaryWashAirDry option for the following samples "<>ObjectToString[failingSamples] <> "is not conflicting with other samples in their batch:",True,False],
				Nothing
			];

			(* create a test for the passing inputs *)
			passingTest=If[Length[passingSamples]>0,
				Test["QuinaryWashAirDry option for the following samples "<>ObjectToString[passingSamples] <> "is not conflicting with other samples in their batch:",True,True],
				Nothing
			];

			{passingTest,failingTest}
		],
		Nothing
	];
	(* SenaryWash *)
	senaryWashAirDryWarnings=checkConflictingAirDryOfStage[simulatedSamples,resolvedSenaryWashAirDries];

	If[Length[senaryWashAirDryWarnings]>0 && messages,
		Message[Warning::SenaryWashAirDryStowaways,senaryWashAirDryWarnings[[All,1]],senaryWashAirDryWarnings[[All,3]],senaryWashAirDryWarnings[[All,2]]]
	];

	invalidSenaryWashAirDryWarningTests = If[Length[senaryWashAirDryWarnings]>0 && gatherTests,
		Module[{failingSamples,passingSamples,passingTest,failingTest},

			failingSamples = Flatten@(senaryWashAirDryWarnings[[All,1]]);
			passingSamples = Complement[flatSimulatedSamples,failingSamples];

			(* create a test for the non-passing inputs *)
			failingTest=If[Length[failingSamples]>0,
				Test["SenaryWashAirDry option for the following samples "<>ObjectToString[failingSamples] <> "is not conflicting with other samples in their batch:",True,False],
				Nothing
			];

			(* create a test for the passing inputs *)
			passingTest=If[Length[passingSamples]>0,
				Test["SenaryWashAirDry option for the following samples "<>ObjectToString[passingSamples] <> "is not conflicting with other samples in their batch:",True,True],
				Nothing
			];

			{passingTest,failingTest}
		],
		Nothing
	];


	(* SeptenaryWash *)
	septenaryWashAirDryWarnings=checkConflictingAirDryOfStage[simulatedSamples,resolvedSeptenaryWashAirDries];

	If[Length[septenaryWashAirDryWarnings]>0 && messages,
		Message[Warning::SeptenaryWashAirDryStowaways,septenaryWashAirDryWarnings[[All,1]],septenaryWashAirDryWarnings[[All,3]],septenaryWashAirDryWarnings[[All,2]]]
	];

	invalidSeptenaryWashAirDryWarningTests = If[Length[septenaryWashAirDryWarnings]>0 && gatherTests,
		Module[{failingSamples,passingSamples,passingTest,failingTest},

			failingSamples = Flatten@(septenaryWashAirDryWarnings[[All,1]]);
			passingSamples = Complement[flatSimulatedSamples,failingSamples];

			(* create a test for the non-passing inputs *)
			failingTest=If[Length[failingSamples]>0,
				Test["SeptenaryWashAirDry option for the following samples "<>ObjectToString[failingSamples] <> "is not conflicting with other samples in their batch:",True,False],
				Nothing
			];

			(* create a test for the passing inputs *)
			passingTest=If[Length[passingSamples]>0,
				Test["SeptenaryWashAirDry option for the following samples "<>ObjectToString[passingSamples] <> "is not conflicting with other samples in their batch:",True,True],
				Nothing
			];

			{passingTest,failingTest}
		],
		Nothing
	];


	(*--Warning::MultipleAnalytes--*)

	(*If there are multipleAnalytesWarnings and we are throwing messages and not in Engine, throw a warning message*)
	multipleAnalytesWarnings=MapThread[
		Function[{samplePacket,affinityLabelInput,targetInput},
			Module[{analytes,uniqueAnalytes},
			(* Check the Analytes only if affinityLabel and target wer resolved rather than specified by user and Affinity mode is used *)
			If[MatchQ[affinityLabelInput,Automatic]&&MatchQ[targetInput,Automatic]&&MatchQ[separationMode,Affinity],
				analytes=Download[Flatten[Lookup[samplePacket,Analytes]],Object];
				uniqueAnalytes=DeleteDuplicates[analytes];
				(*If there are >1 unique Analytes, output True, otherwise output Nothing*)
				If[MatchQ[Length[uniqueAnalytes],GreaterP[1]],
					True,
					False],
				(* Output Nothing if affinityLabel is specified by user or separation mode is not Affinity *)
				False
				]
			]
		],
		{flatSimulatedSamplePackets,Flatten@analyteAffinityLabels,Flatten@targets}
	];

	If[MemberQ[multipleAnalytesWarnings,True]&&messages&&notInEngine,
		Message[Warning::MultipleAnalytes,ObjectToString[PickList[flatSimulatedSamples,multipleAnalytesWarnings],Cache->simulatedCache]];
		];

	(*If we are gathering tests, create a test*)
	multipleAnalytesTest=If[gatherTests,
		Module[
			{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the samples that fail this test*)
			failingSamples=PickList[flatSimulatedSamples,multipleAnalytesWarnings];

			(*Get the samples that pass this test*)
			passingSamples=Complement[flatSimulatedSamples,failingSamples];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", there are not multiple analytes:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", there are not multiple analytes:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];

	(*--Warning::MultipleTargetTypes--*)

	(*If there are multipleTargetTypesWarnings and we are throwing messages and not in Engine, throw a warning message*)
	multipleTargetTypesWarnings=MapThread[
		Function[{samplePacket,targetInput},
			Module[{analytes,uniqueAnalytes,analyteProteins,analyteNucleicAcids},
				(* Check the Target molecule types only if Target was resolved rather than specified by user*)
				If[MatchQ[targetInput,Automatic],
					analytes=Download[Flatten[Lookup[samplePacket,Analytes]],Object];
					(* Get non-repeated analytes from the sample*)
					uniqueAnalytes=DeleteDuplicates[analytes];
					(* Get a count of proteins and peptides in uniqueAnalytes *)
					analyteProteins=Length[Cases[uniqueAnalytes,ObjectP[Model[Molecule, Protein]]]] +
         		Length[Cases[Download[Cases[uniqueAnalytes,ObjectP[Model[Molecule, Oligomer]]]], KeyValuePattern[PolymerType->Peptide]]];
					(* Get a count of DNA and RNA in uniqueAnalytes *)
					analyteNucleicAcids=Length[Cases[uniqueAnalytes,ObjectP[Model[Molecule,cDNA]]]] +
							Length[Cases[uniqueAnalytes,ObjectP[Model[Molecule,Transcript]]]] +
							Length[Cases[Download[Cases[uniqueAnalytes,ObjectP[Model[Molecule,Oligomer]]]],KeyValuePattern[PolymerType->Alternatives[DNA,RNA]]]];
					(* Output True if BOTH counts are above zero, otherwise output Nothing *)
					If[analyteProteins>0 && analyteNucleicAcids>0,
						True,
						False],
					(*If the option is user specified, no need to check analyte types *)
					False
				]
			]
		],
		{flatSimulatedSamplePackets,Flatten@targets}
	];

	If[MemberQ[multipleTargetTypesWarnings,True]&&messages&&notInEngine,
		Message[Warning::MultipleTargetTypes,ObjectToString[PickList[flatSimulatedSamples,multipleTargetTypesWarnings],Cache->simulatedCache]];
	];

	(*If we are gathering tests, create a test*)
	multipleTargetTypesTest=If[gatherTests,
		Module[
			{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the samples that fail this test*)
			failingSamples=PickList[flatSimulatedSamples,multipleTargetTypesWarnings];

			(*Get the samples that pass this test*)
			passingSamples=Complement[flatSimulatedSamples,failingSamples];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", there are not multiple types of molecules in Analytes:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", there are not multiple types of molecules in Analytes:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];

	(*--Warning::MultipleTargets--*)

	(*If there are multipleTargetsWarnings and we are throwing messages and not in Engine, throw a warning message*)
	If[MemberQ[multipleTargetsWarnings,True]&&messages&&notInEngine,
		Message[Warning::MultipleTargets,ObjectToString[PickList[flatSimulatedSamples,multipleTargetsWarnings],Cache->simulatedCache]];
	];

	(*If we are gathering tests, create a test*)
	multipleTargetsTest=If[gatherTests,
		Module[
			{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the samples that fail this test*)
			failingSamples=PickList[resolvedAnalyteAffinityLabels,multipleTargetsWarnings];

			(*Get the samples that pass this test*)
			passingSamples=PickList[resolvedAnalyteAffinityLabels,multipleTargetsWarnings,False];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following analytes "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", there are not multiple targets:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following analytes "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", there are not multiple targets:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];

	(*--Warning::GeneralResolvedMagneticBeads--*)


	(*If there are multipleAnalytesWarnings and we are throwing messages and not in Engine, throw a warning message*)
	generalResolvedMagneticBeadsWarnings=MapThread[
		Function[{samplePacket,magneticBeadInput,resolvedMagneticBead},
				(* Check the resolved MagneticBeads only if MagneticBeads was resolved rather than specified by user*)
				If[MatchQ[magneticBeadInput,Automatic],
					(*If the resolvedMagneticBeads is the generic one, i.e. Model[Sample, "Mag-Bind Particles CNR (Mag-Bind Viral DNA/RNA Kit)"], turn on the warning *)
					If[MatchQ[resolvedMagneticBead,ObjectP[Model[Sample, "Mag-Bind Particles CNR (Mag-Bind Viral DNA/RNA Kit)"]]],
						True,
						False
					],
					(*If the option is user specified, no need to check*)
					False
				]
		],
			{flatSimulatedSamplePackets,Flatten@magneticBeads,Flatten@resolvedMagneticBeads}
		];

	If[MemberQ[generalResolvedMagneticBeadsWarnings,True]&&messages&&notInEngine,
	Message[Warning::GeneralResolvedMagneticBeads,ObjectToString[PickList[flatSimulatedSamples,generalResolvedMagneticBeadsWarnings],Cache->simulatedCache]];
	];

	(*If we are gathering tests, create a test*)
	generalResolvedMagneticBeadsTest=If[gatherTests,
		Module[
			{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the samples that fail this test*)
			failingSamples=PickList[flatSimulatedSamples,generalResolvedMagneticBeadsWarnings];

			(*Get the samples that pass this test*)
			passingSamples=Complement[flatSimulatedSamples,failingSamples];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
			Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", the automatically resolved magnetic beads are not the generic one:",False,True],
			Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
			Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", the automatically resolved magnetic beads are not the generic one:",True,True],
			Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];

	(*==PreWash==*)

	(*--Error::PreWashMismatch--*)

	(*If there are preWashMismatchErrors and we are throwing messages, throw an error message*)
	preWashMismatchOptions=If[MemberQ[preWashMismatchErrors,True]&&messages,
		(
		Message[Error::PreWashMismatch,ObjectToString[PickList[flatSimulatedSamples,preWashMismatchErrors],Cache->simulatedCache]];
		Select[Options[ExperimentMagneticBeadSeparation][[All, 1]], StringContainsQ[ToString[#], "PreWash"] &]
		),
		{}
	];

	(*If we are gathering tests, create a test*)
	preWashMismatchTest=If[gatherTests,
		Module[
			{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the inputs that fail this test*)
			failingSamples=PickList[flatSimulatedSamples,preWashMismatchErrors];

		(*Get the inputs that pass this test*)
		passingSamples=PickList[flatSimulatedSamples,preWashMismatchErrors,False];

		(*Create a test for the non-passing inputs*)
		failingSampleTests=If[Length[failingSamples]>0,
		Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", the PreWash options are not in conflict with PreWash:",False,True],
		Nothing
		];

		(*Create a test for the passing inputs*)
		passingSampleTests=If[Length[passingSamples]>0,
		Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", the PreWash options are not in conflict with PreWash:",True,True],
		Nothing
		];

		(*Return the created tests*)
		{failingSampleTests,passingSampleTests}
		],
		Nothing
	];


	(*--Error::PreWashMixMismatch--*)
	unresolvedPreWashMixOptions= Lookup[mbsOptionsAssociationFlat,
		{PreWashMix, PreWashMixType, PreWashMixTime, PreWashMixRate,NumberOfPreWashMixes, PreWashMixVolume, PreWashMixTemperature, PreWashMixTipType, PreWashMixTipMaterial}];

	preWashMixMismatchErrors=checkMixMismatchErrorOfStage[flatSimulatedSamples,unresolvedPreWashMixOptions];

	(*If there are preWashMixMismatchErrors and we are throwing messages, throw an error message*)
	preWashMixMismatchOptions=If[MemberQ[preWashMixMismatchErrors,True]&&messages,
		(
			Message[Error::PreWashMixMismatch,ObjectToString[PickList[flatSimulatedSamples,preWashMixMismatchErrors],Cache->simulatedCache]];
			{
			PreWashMix, PreWashMixType, PreWashMixTime, PreWashMixRate,NumberOfPreWashMixes, PreWashMixVolume, PreWashMixTemperature, PreWashMixTipType, PreWashMixTipMaterial
			}
		),
		{}
	];

	(*If we are gathering tests, create a test*)
	preWashMixMismatchTest=If[gatherTests,
		Module[{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the inputs that fail this test*)
			failingSamples=PickList[flatSimulatedSamples,preWashMixMismatchErrors];

			(*Get the inputs that pass this test*)
			passingSamples=PickList[flatSimulatedSamples,preWashMixMismatchErrors,False];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", the PreWashMix options are not in conflict with PreWashMix:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", the PreWashMix options are not in conflict with PreWashMix:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];

	(*--Warning::invalidPreWashMixTipType--*)
	invalidPreWashMixTipTypeErrors=checkInvalidMixTipTypeOfStage[
		flatSimulatedSamples,
		Flatten[Lookup[mbsOptionsAssociationFlat,PreWashMixTipType]],
		Flatten[resolvedPreWashMixVolumes]
	];

	(*If there are invalidPreWashMixTipTypeErrors and we are throwing messages, throw an error message*)
	invalidPreWashMixTipTypeOptions=If[Length[invalidPreWashMixTipTypeErrors]>0&&messages,
		(
			Message[Error::InvalidPreWashMixTipType,
					ObjectToString[invalidPreWashMixTipTypeErrors[[All,1]]],
					invalidPreWashMixTipTypeErrors[[All,2]]
				];
			{
				PreWashMixTipType
			}
		),
		{}
	];

	(*If we are gathering tests, create a test*)
	validPreWashMixTipTypeTest=If[gatherTests,
		Module[{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the inputs that fail this test*)
			failingSamples=invalidPreWashMixTipTypeErrors[[All,1]];

			(*Get the inputs that pass this test*)
			passingSamples=Complement[flatSimulatedSamples,failingSamples];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", if mix by Pipette and PreWashMixVolume is no larger than 970 Microliter, the PreWashMixTipType is WideBore:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", if mix by Pipette and PreWashMixVolume is no larger than 970 Microliter, the PreWashMixTipType is WideBore:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];


	(*Error::PreWashMixNoTip*)
	preWashMixNoTipErrors=checkMixNoTipErrorOfStage[
		flatSimulatedSamples,
		Lookup[mbsOptionsAssociationFlat,PreWashMixTipType],
		Flatten[resolvedPreWashMixTipTypes],
		Lookup[mbsOptionsAssociationFlat,PreWashMixTipMaterial],
		Flatten[resolvedPreWashMixTipMaterials],
		Flatten[resolvedPreWashMixVolumes],
    resolvedPreparation
	];

	(*If there are preWashMixNoTipErrors and we are throwing messages, throw an error message*)
	invalidPreWashMixTipOptions=If[Length[preWashMixNoTipErrors]>0&&messages,
		Message[Error::PreWashMixNoTip,
			ObjectToString[preWashMixNoTipErrors[[All,1]]],
			preWashMixNoTipErrors[[All,2]],
			preWashMixNoTipErrors[[All,3]],
			preWashMixNoTipErrors[[All,4]]];
		{PreWashMixTipType,PreWashMixTipMaterial,PreWashMixVolume},
		{}
	];

	(*If we are gathering tests, create a test*)
	validPreWashMixTipTest=If[gatherTests,
		Module[{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the inputs that fail this test*)
			failingSamples=preWashMixNoTipErrors[[All,1]];

			(*Get the inputs that pass this test*)
			passingSamples=Complement[flatSimulatedSamples,failingSamples];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", there are tips found given the PreWashMixTipType and PreWashMixTipMaterial for the PreWashMixVolume:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", there are tips found given the PreWashMixTipType and PreWashMixTipMaterial for the PreWashMixVolume:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];


	(*--Error::PreWashMixNoInstrument--*)
	preWashMixNoInstrumentErrors = checkMixNoInstrumentErrorsOfStage[
		Flatten@resolvedAssayContainers,
		Flatten@resolvedMagneticBeadVolumes,
		Flatten@resolvedPreWashMixes,
		Flatten@resolvedPreWashBufferVolumes,
		Flatten@resolvedPreWashMixTypes,
		Flatten@resolvedPreWashMixRates,
		Flatten@resolvedPreWashMixTemperatures
	];

	invalidPreWashMixInstrumentOptions=If[
		MemberQ[preWashMixNoInstrumentErrors,True]&&messages&&notInEngine,
		Message[Error::PreWashMixNoInstrument,ObjectToString[PickList[flatSimulatedSamples,preWashMixNoInstrumentErrors],Cache->simulatedCache]];
		{PreWashMixType,PreWashMixRate,PreWashMixTemperature},
		{}
	];

	(*If we are gathering tests, create a test*)
	validPreWashMixInstrumentTest=If[gatherTests,
		Module[
			{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the samples that fail this test*)
			failingSamples=PickList[flatSimulatedSamples,preWashMixNoInstrumentErrors];

			(*Get the samples that pass this test*)
			passingSamples=Complement[flatSimulatedSamples,failingSamples];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", at least one eligible mixing instrument is found given the resolved mixing options during PreWash:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", at least one eligible mixing instrument is found given the resolved mixing options during PreWash:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];

  (*--Error::PreWashAspirationPipettingMismatch--*)

  preWashAspirationPipettingMismatchErrors=checkAspirationPipettingMismatchErrorOfStage[flatSimulatedSamples,Lookup[mbsOptionsAssociationFlat,{PreWashAspirationPosition, PreWashAspirationPositionOffset}]];

  (*If there are preWashMixMismatchErrors and we are throwing messages, throw an error message*)
  preWashAspirationPipettingMismatchOptions=If[MemberQ[preWashAspirationPipettingMismatchErrors,True]&&messages,
    (
      Message[Error::PreWashAspirationPipettingOptionsMismatch,ObjectToString[PickList[flatSimulatedSamples,preWashAspirationPipettingMismatchErrors],Cache->simulatedCache]];
      {
        PreWashAspirationPosition, PreWashAspirationPositionOffset
      }
    ),
    {}
  ];

  (*If we are gathering tests, create a test*)
  preWashAspirationPipettingMismatchTests=If[gatherTests,
    Module[{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

      (*Get the inputs that fail this test*)
      failingSamples=PickList[flatSimulatedSamples,preWashAspirationPipettingMismatchErrors];

      (*Get the inputs that pass this test*)
      passingSamples=PickList[flatSimulatedSamples,preWashAspirationPipettingMismatchErrors,False];

      (*Create a test for the non-passing inputs*)
      failingSampleTests=If[Length[failingSamples]>0,
        Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", the PreWashAspirationPosition options are not in conflict with PreWashAspirationPositionOffset:",False,True],
        Nothing
      ];

      (*Create a test for the passing inputs*)
      passingSampleTests=If[Length[passingSamples]>0,
        Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", the PreWashAspirationPosition options are not in conflict with PreWashAspirationPositionOffset:",True,True],
        Nothing
      ];

      (*Return the created tests*)
      {failingSampleTests,passingSampleTests}
    ],
    Nothing
  ];

	(*--Error::PreWashAirDryMismatch--*)

	(*If there are preWashAirDryMismatchErrors and we are throwing messages, throw an error message*)
	preWashAirDryMismatchOptions=If[MemberQ[preWashAirDryMismatchErrors,True]&&messages,
		(Message[Error::PreWashAirDryMismatch,ObjectToString[PickList[flatSimulatedSamples,preWashAirDryMismatchErrors],Cache->simulatedCache]];
		{PreWashAirDry,PreWashAirDryTime}
		),
		{}
	];

	(*If we are gathering tests, create a test*)
	preWashAirDryMismatchTest=If[gatherTests,
		Module[
			{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the inputs that fail this test*)
			failingSamples=PickList[flatSimulatedSamples,preWashAirDryMismatchErrors];

			(*Get the inputs that pass this test*)
			passingSamples=PickList[flatSimulatedSamples,preWashAirDryMismatchErrors,False];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", PreWashAirDryTime is not in conflict with PreWashAirDry:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", PreWashAirDryTime is not in conflict with PreWashAirDry:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];

	(*==Equilibration==*)

	(*--Error::EquilibrationMismatch--*)

	(*If there are equilibrationMismatchErrors and we are throwing messages, throw an error message*)
	equilibrationMismatchOptions=If[MemberQ[equilibrationMismatchErrors,True]&&messages,
		(
			Message[Error::EquilibrationMismatch,ObjectToString[PickList[flatSimulatedSamples,equilibrationMismatchErrors],Cache->simulatedCache]];
			Select[Options[ExperimentMagneticBeadSeparation][[All, 1]], StringContainsQ[ToString[#], "Equilibration"] &]
		),
		{}
	];

	(*If we are gathering tests, create a test*)
	equilibrationMismatchTest=If[gatherTests,
		Module[
			{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

	(*Get the inputs that fail this test*)
			failingSamples=PickList[flatSimulatedSamples,equilibrationMismatchErrors];

	(*Get the inputs that pass this test*)
			passingSamples=PickList[flatSimulatedSamples,equilibrationMismatchErrors,False];

	(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", the Equilibration options are not in conflict with Equilibration:",False,True],
				Nothing
			];

	(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", the Equilibration options are not in conflict with Equilibration:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];

	(*--Error::EquilibrationMixMismatch--*)
	unresolvedEquilibrationMixOptions= Lookup[mbsOptionsAssociationFlat,
		{EquilibrationMix, EquilibrationMixType, EquilibrationMixTime, EquilibrationMixRate,NumberOfEquilibrationMixes, EquilibrationMixVolume, EquilibrationMixTemperature, EquilibrationMixTipType, EquilibrationMixTipMaterial}];

	equilibrationMixMismatchErrors=checkMixMismatchErrorOfStage[flatSimulatedSamples,unresolvedEquilibrationMixOptions];

	(*If there are equilibrationMixMismatchErrors and we are throwing messages, throw an error message*)
	equilibrationMixMismatchOptions=If[MemberQ[equilibrationMixMismatchErrors,True]&&messages,
		(
			Message[Error::EquilibrationMixMismatch,ObjectToString[PickList[flatSimulatedSamples,equilibrationMixMismatchErrors],Cache->simulatedCache]];
			{
				EquilibrationMix, EquilibrationMixType, EquilibrationMixTime, EquilibrationMixRate,NumberOfEquilibrationMixes, EquilibrationMixVolume, EquilibrationMixTemperature, EquilibrationMixTipType, EquilibrationMixTipMaterial
			}
		),
		{}
	];

	(*If we are gathering tests, create a test*)
	equilibrationMixMismatchTest=If[gatherTests,
		Module[
			{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the inputs that fail this test*)
			failingSamples=PickList[flatSimulatedSamples,equilibrationMixMismatchErrors];

			(*Get the inputs that pass this test*)
			passingSamples=PickList[flatSimulatedSamples,equilibrationMixMismatchErrors,False];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", the EquilibrationMix options are not in conflict with EquilibrationMix:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", the EquilibrationMix options are not in conflict with EquilibrationMix:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];


	(*--Warning::invalidEquilibrationMixTipType--*)
	invalidEquilibrationMixTipTypeErrors=checkInvalidMixTipTypeOfStage[
		flatSimulatedSamples,
		Flatten[Lookup[mbsOptionsAssociationFlat,EquilibrationMixTipType]],
		Flatten[resolvedEquilibrationMixVolumes]
	];

	(*If there are invalidEquilibrationMixTipTypeErrors and we are throwing messages, throw an error message*)
	invalidEquilibrationMixTipTypeOptions=If[Length[invalidEquilibrationMixTipTypeErrors]>0&&messages,
		(
			Message[Error::InvalidEquilibrationMixTipType,
				ObjectToString[invalidEquilibrationMixTipTypeErrors[[All,1]]],
				invalidEquilibrationMixTipTypeErrors[[All,2]]
			];
			{
				EquilibrationMixTipType
			}
		),
		{}
	];

	(*If we are gathering tests, create a test*)
	validEquilibrationMixTipTypeTest=If[gatherTests,
		Module[{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the inputs that fail this test*)
			failingSamples=invalidEquilibrationMixTipTypeErrors[[All,1]];

			(*Get the inputs that pass this test*)
			passingSamples=Complement[flatSimulatedSamples,failingSamples];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", if mix by Pipette and EquilibrationMixVolume is no larger than 970 Microliter, the EquilibrationMixTipType is WideBore:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", if mix by Pipette and EquilibrationMixVolume is no larger than 970 Microliter, the EquilibrationMixTipType is WideBore:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];


	(*Error::EquilibrationMixNoTip*)
	equilibrationMixNoTipErrors=checkMixNoTipErrorOfStage[
		flatSimulatedSamples,
		Lookup[mbsOptionsAssociationFlat,EquilibrationMixTipType],
		Flatten[resolvedEquilibrationMixTipTypes],
		Lookup[mbsOptionsAssociationFlat,EquilibrationMixTipMaterial],
		Flatten[resolvedEquilibrationMixTipMaterials],
		Flatten[resolvedEquilibrationMixVolumes],
    resolvedPreparation
	];

	(*If there are equilibrationMixNoTipErrors and we are throwing messages, throw an error message*)
	invalidEquilibrationMixTipOptions=If[Length[equilibrationMixNoTipErrors]>0&&messages,
		Message[Error::EquilibrationMixNoTip,
			ObjectToString[equilibrationMixNoTipErrors[[All,1]]],
			equilibrationMixNoTipErrors[[All,2]],
			equilibrationMixNoTipErrors[[All,3]],
			equilibrationMixNoTipErrors[[All,4]]];
		{EquilibrationMixTipType,EquilibrationMixTipMaterial,EquilibrationMixVolume},
		{}
	];
	(*If we are gathering tests, create a test*)
	validEquilibrationMixTipTest=If[gatherTests,
		Module[{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the inputs that fail this test*)
			failingSamples=equilibrationMixNoTipErrors[[All,1]];

			(*Get the inputs that pass this test*)
			passingSamples=Complement[flatSimulatedSamples,failingSamples];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", there are tips found given the EquilibrationMixTipType and EquilibrationMixTipMaterial for the EquilibrationMixVolume:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", there are tips found given the EquilibrationMixTipType and EquilibrationMixTipMaterial for the EquilibrationMixVolume:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];


	(*--Error::EquilibrationMixNoInstrument--*)
	equilibrationMixNoInstrumentErrors = checkMixNoInstrumentErrorsOfStage[
		Flatten@resolvedAssayContainers,
		Flatten@resolvedMagneticBeadVolumes,
		Flatten@resolvedEquilibrationMixes,
		Flatten@resolvedEquilibrationBufferVolumes,
		Flatten@resolvedEquilibrationMixTypes,
		Flatten@resolvedEquilibrationMixRates,
		Flatten@resolvedEquilibrationMixTemperatures
	];

	invalidEquilibrationMixInstrumentOptions=If[
		MemberQ[equilibrationMixNoInstrumentErrors,True]&&messages&&notInEngine,
		Message[Error::EquilibrationMixNoInstrument,ObjectToString[PickList[flatSimulatedSamples,equilibrationMixNoInstrumentErrors],Cache->simulatedCache]];
		{EquilibrationMixType,EquilibrationMixRate,EquilibrationMixTemperature},
		{}
	];

	(*If we are gathering tests, create a test*)
	validEquilibrationMixInstrumentTest=If[gatherTests,
		Module[
			{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the samples that fail this test*)
			failingSamples=PickList[flatSimulatedSamples,equilibrationMixNoInstrumentErrors];

			(*Get the samples that pass this test*)
			passingSamples=Complement[flatSimulatedSamples,failingSamples];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", at least one eligible mixing instrument is found given the resolved mixing options during Equilibration:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", at least one eligible mixing instrument is found given the resolved mixing options during Equilibration:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];
  (*--Error::EquilibrationAspirationPipettingMismatch--*)

  equilibrationAspirationPipettingMismatchErrors=checkAspirationPipettingMismatchErrorOfStage[flatSimulatedSamples,Lookup[mbsOptionsAssociationFlat,{EquilibrationAspirationPosition, EquilibrationAspirationPositionOffset}]];

  (*If there are equilibrationMixMismatchErrors and we are throwing messages, throw an error message*)
  equilibrationAspirationPipettingMismatchOptions=If[MemberQ[equilibrationAspirationPipettingMismatchErrors,True]&&messages,
    (
      Message[Error::EquilibrationAspirationPipettingOptionsMismatch,ObjectToString[PickList[flatSimulatedSamples,equilibrationAspirationPipettingMismatchErrors],Cache->simulatedCache]];
      {
        EquilibrationAspirationPosition, EquilibrationAspirationPositionOffset
      }
    ),
    {}
  ];

  (*If we are gathering tests, create a test*)
  equilibrationAspirationPipettingMismatchTests=If[gatherTests,
    Module[{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

      (*Get the inputs that fail this test*)
      failingSamples=PickList[flatSimulatedSamples,equilibrationAspirationPipettingMismatchErrors];

      (*Get the inputs that pass this test*)
      passingSamples=PickList[flatSimulatedSamples,equilibrationAspirationPipettingMismatchErrors,False];

      (*Create a test for the non-passing inputs*)
      failingSampleTests=If[Length[failingSamples]>0,
        Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", the EquilibrationAspirationPosition options are not in conflict with EquilibrationAspirationPositionOffset:",False,True],
        Nothing
      ];

      (*Create a test for the passing inputs*)
      passingSampleTests=If[Length[passingSamples]>0,
        Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", the EquilibrationAspirationPosition options are not in conflict with EquilibrationAspirationPositionOffset:",True,True],
        Nothing
      ];

      (*Return the created tests*)
      {failingSampleTests,passingSampleTests}
    ],
    Nothing
  ];

	(*--Error::EquilibrationAirDryMismatch--*)

	(*If there are equilibrationAirDryMismatchErrors and we are throwing messages, throw an error message*)
	equilibrationAirDryMismatchOptions=If[MemberQ[equilibrationAirDryMismatchErrors,True]&&messages,
		(
			Message[Error::EquilibrationAirDryMismatch,ObjectToString[PickList[flatSimulatedSamples,equilibrationAirDryMismatchErrors],Cache->simulatedCache]];
			{EquilibrationAirDry,EquilibrationAirDryTime}
		),
		{}
	];

	(*If we are gathering tests, create a test*)
	equilibrationAirDryMismatchTest=If[gatherTests,
		Module[
			{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the inputs that fail this test*)
			failingSamples=PickList[flatSimulatedSamples,equilibrationAirDryMismatchErrors];

			(*Get the inputs that pass this test*)
			passingSamples=PickList[flatSimulatedSamples,equilibrationAirDryMismatchErrors,False];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", EquilibrationAirDryTime is not in conflict with EquilibrationAirDry:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", EquilibrationAirDryTime is not in conflict with EquilibrationAirDry:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];

	(*==Loading==*)
	(*--Error::LoadingMixMismatch--*)
	unresolvedLoadingMixOptions= Lookup[mbsOptionsAssociationFlat,
		{LoadingMix, LoadingMixType, LoadingMixTime, LoadingMixRate,NumberOfLoadingMixes, LoadingMixVolume, LoadingMixTemperature, LoadingMixTipType, LoadingMixTipMaterial}];

	loadingMixMismatchErrors=checkMixMismatchErrorOfStage[flatSimulatedSamples,unresolvedLoadingMixOptions];

	(*If there are loadingMixMismatchErrors and we are throwing messages, throw an error message*)
	loadingMixMismatchOptions=If[MemberQ[loadingMixMismatchErrors,True]&&messages,
		(
			Message[Error::LoadingMixMismatch,ObjectToString[PickList[flatSimulatedSamples,loadingMixMismatchErrors],Cache->simulatedCache]];
			{
				LoadingMix, LoadingMixType, LoadingMixTime, LoadingMixRate,NumberOfLoadingMixes, LoadingMixVolume, LoadingMixTemperature, LoadingMixTipType, LoadingMixTipMaterial
			}
		),
		{}
	];

	(*If we are gathering tests, create a test*)
	loadingMixMismatchTest=If[gatherTests,
		Module[
			{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the inputs that fail this test*)
			failingSamples=PickList[flatSimulatedSamples,loadingMixMismatchErrors];

			(*Get the inputs that pass this test*)
			passingSamples=PickList[flatSimulatedSamples,loadingMixMismatchErrors,False];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", the LoadingMix options are not in conflict with LoadingMix:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", the LoadingMix options are not in conflict with LoadingMix:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];


	(*--Warning::invalidLoadingMixTipType--*)
	invalidLoadingMixTipTypeErrors=checkInvalidMixTipTypeOfStage[
		flatSimulatedSamples,
		Flatten[Lookup[mbsOptionsAssociationFlat,LoadingMixTipType]],
		Flatten[resolvedLoadingMixVolumes]
	];

	(*If there are invalidLoadingMixTipTypeErrors and we are throwing messages, throw an error message*)
	invalidLoadingMixTipTypeOptions=If[Length[invalidLoadingMixTipTypeErrors]>0&&messages,
		(
			Message[Error::InvalidLoadingMixTipType,
				ObjectToString[invalidLoadingMixTipTypeErrors[[All,1]]],
				invalidLoadingMixTipTypeErrors[[All,2]]
			];
			{
				LoadingMixTipType
			}
		),
		{}
	];

	(*If we are gathering tests, create a test*)
	validLoadingMixTipTypeTest=If[gatherTests,
		Module[{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the inputs that fail this test*)
			failingSamples=invalidLoadingMixTipTypeErrors[[All,1]];

			(*Get the inputs that pass this test*)
			passingSamples=Complement[flatSimulatedSamples,failingSamples];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", if mix by Pipette and LoadingMixVolume is no larger than 970 Microliter, the LoadingMixTipType is WideBore:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", if mix by Pipette and LoadingMixVolume is no larger than 970 Microliter, the LoadingMixTipType is WideBore:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];


	(*Error::LoadingMixNoTip*)
	loadingMixNoTipErrors=checkMixNoTipErrorOfStage[
		flatSimulatedSamples,
		Lookup[mbsOptionsAssociationFlat,LoadingMixTipType],
		Flatten[resolvedLoadingMixTipTypes],
		Lookup[mbsOptionsAssociationFlat,LoadingMixTipMaterial],
		Flatten[resolvedLoadingMixTipMaterials],
		Flatten[resolvedLoadingMixVolumes],
    resolvedPreparation
	];

	(*If there are loadingMixNoTipErrors and we are throwing messages, throw an error message*)
	invalidLoadingMixTipOptions=If[Length[loadingMixNoTipErrors]>0&&messages,
		Message[Error::LoadingMixNoTip,
			ObjectToString[loadingMixNoTipErrors[[All,1]]],
			loadingMixNoTipErrors[[All,2]],
			loadingMixNoTipErrors[[All,3]],
			loadingMixNoTipErrors[[All,4]]];
		{LoadingMixTipType,LoadingMixTipMaterial,LoadingMixVolume},
		{}
	];

	(*If we are gathering tests, create a test*)
	validLoadingMixTipTest=If[gatherTests,
		Module[{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the inputs that fail this test*)
			failingSamples=loadingMixNoTipErrors[[All,1]];

			(*Get the inputs that pass this test*)
			passingSamples=Complement[flatSimulatedSamples,failingSamples];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", there are tips found given the LoadingMixTipType and LoadingMixTipMaterial for the LoadingMixVolume:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", there are tips found given the LoadingMixTipType and LoadingMixTipMaterial for the LoadingMixVolume:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];


	(*--Error::LoadingMixNoInstrument--*)
	loadingMixNoInstrumentErrors = checkMixNoInstrumentErrorsOfStage[
		Flatten@resolvedAssayContainers,
		Flatten@resolvedMagneticBeadVolumes,
		Flatten@resolvedLoadingMixes,
		Flatten@resolvedVolumes,
		Flatten@resolvedLoadingMixTypes,
		Flatten@resolvedLoadingMixRates,
		Flatten@resolvedLoadingMixTemperatures
	];

	invalidLoadingMixInstrumentOptions=If[
		MemberQ[loadingMixNoInstrumentErrors,True]&&messages&&notInEngine,
		Message[Error::LoadingMixNoInstrument,ObjectToString[PickList[flatSimulatedSamples,loadingMixNoInstrumentErrors],Cache->simulatedCache]];
		{LoadingMixType,LoadingMixRate,LoadingMixTemperature},
		{}
	];

	(*If we are gathering tests, create a test*)
	validLoadingMixInstrumentTest=If[gatherTests,
		Module[
			{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the samples that fail this test*)
			failingSamples=PickList[flatSimulatedSamples,loadingMixNoInstrumentErrors];

			(*Get the samples that pass this test*)
			passingSamples=Complement[flatSimulatedSamples,failingSamples];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", at least one eligible mixing instrument is found given the resolved mixing options during Loading:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", at least one eligible mixing instrument is found given the resolved mixing options during Loading:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];

  (*--Error::LoadingAspirationPipettingMismatch--*)

  loadingAspirationPipettingMismatchErrors=checkAspirationPipettingMismatchErrorOfStage[flatSimulatedSamples,Lookup[mbsOptionsAssociationFlat,{LoadingAspirationPosition, LoadingAspirationPositionOffset}]];

  (*If there are loadingMixMismatchErrors and we are throwing messages, throw an error message*)
  loadingAspirationPipettingMismatchOptions=If[MemberQ[loadingAspirationPipettingMismatchErrors,True]&&messages,
    (
      Message[Error::LoadingAspirationPipettingOptionsMismatch,ObjectToString[PickList[flatSimulatedSamples,loadingAspirationPipettingMismatchErrors],Cache->simulatedCache]];
      {
        LoadingAspirationPosition, LoadingAspirationPositionOffset
      }
    ),
    {}
  ];

  (*If we are gathering tests, create a test*)
  loadingAspirationPipettingMismatchTests=If[gatherTests,
    Module[{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

      (*Get the inputs that fail this test*)
      failingSamples=PickList[flatSimulatedSamples,loadingAspirationPipettingMismatchErrors];

      (*Get the inputs that pass this test*)
      passingSamples=PickList[flatSimulatedSamples,loadingAspirationPipettingMismatchErrors,False];

      (*Create a test for the non-passing inputs*)
      failingSampleTests=If[Length[failingSamples]>0,
        Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", the LoadingAspirationPosition options are not in conflict with LoadingAspirationPositionOffset:",False,True],
        Nothing
      ];

      (*Create a test for the passing inputs*)
      passingSampleTests=If[Length[passingSamples]>0,
        Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", the LoadingAspirationPosition options are not in conflict with LoadingAspirationPositionOffset:",True,True],
        Nothing
      ];

      (*Return the created tests*)
      {failingSampleTests,passingSampleTests}
    ],
    Nothing
  ];
  
	(*--Error::LoadingAirDryMismatch--*)

	(*If there are loadingAirDryMismatchErrors and we are throwing messages, throw an error message*)
	loadingAirDryMismatchOptions=If[MemberQ[loadingAirDryMismatchErrors,True]&&messages,
		(
			Message[Error::LoadingAirDryMismatch,ObjectToString[PickList[flatSimulatedSamples,loadingAirDryMismatchErrors],Cache->simulatedCache]];
			{LoadingAirDry,LoadingAirDryTime}
		),
		{}
	];

	(*If we are gathering tests, create a test*)
	loadingAirDryMismatchTest=If[gatherTests,
		Module[
			{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the inputs that fail this test*)
			failingSamples=PickList[flatSimulatedSamples,loadingAirDryMismatchErrors];

			(*Get the inputs that pass this test*)
			passingSamples=PickList[flatSimulatedSamples,loadingAirDryMismatchErrors,False];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", LoadingAirDryTime is not in conflict with LoadingAirDry:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", LoadingAirDryTime is not in conflict with LoadingAirDry:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];

	(*==Wash==*)
	(*--Error::WashMismatch--*)

	(*If there are washMismatchErrors and we are throwing messages, throw an error message*)
	washMismatchOptions=If[MemberQ[washMismatchErrors,True]&&messages,
		(
			Message[Error::WashMismatch,ObjectToString[PickList[flatSimulatedSamples,washMismatchErrors],Cache->simulatedCache]];
			Select[Options[ExperimentMagneticBeadSeparation][[All, 1]], StringContainsQ[ToString[#], "Wash"] &]
		),
		{}
	];

	(*If we are gathering tests, create a test*)
	washMismatchTest=If[gatherTests,
		Module[
			{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the inputs that fail this test*)
			failingSamples=PickList[flatSimulatedSamples,washMismatchErrors];

			(*Get the inputs that pass this test*)
			passingSamples=PickList[flatSimulatedSamples,washMismatchErrors,False];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", the Wash options are not in conflict with Wash:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", the Wash options are not in conflict with Wash:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];

	(*--Error::WashMixMismatch--*)

	unresolvedWashMixOptions= Lookup[mbsOptionsAssociationFlat,
		{WashMix, WashMixType, WashMixTime, WashMixRate,NumberOfWashMixes, WashMixVolume, WashMixTemperature, WashMixTipType, WashMixTipMaterial}];

	washMixMismatchErrors=checkMixMismatchErrorOfStage[flatSimulatedSamples,unresolvedWashMixOptions];

	(*If there are washMixMismatchErrors and we are throwing messages, throw an error message*)
	washMixMismatchOptions=If[MemberQ[washMixMismatchErrors,True]&&messages,
		(
			Message[Error::WashMixMismatch,ObjectToString[PickList[flatSimulatedSamples,washMixMismatchErrors],Cache->simulatedCache]];
			{
				WashMix, WashMixType, WashMixTime, WashMixRate,NumberOfWashMixes, WashMixVolume, WashMixTemperature, WashMixTipType, WashMixTipMaterial
			}
		),
		{}
	];

	(*If we are gathering tests, create a test*)
	washMixMismatchTest=If[gatherTests,
		Module[
			{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the inputs that fail this test*)
			failingSamples=PickList[flatSimulatedSamples,washMixMismatchErrors];

			(*Get the inputs that pass this test*)
			passingSamples=PickList[flatSimulatedSamples,washMixMismatchErrors,False];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", the WashMix options are not in conflict with WashMix:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", the WashMix options are not in conflict with WashMix:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];


	(*--Warning::invalidWashMixTipType--*)
	invalidWashMixTipTypeErrors=checkInvalidMixTipTypeOfStage[
		flatSimulatedSamples,
		Flatten[Lookup[mbsOptionsAssociationFlat,WashMixTipType]],
		Flatten[resolvedWashMixVolumes]
	];

	(*If there are invalidWashMixTipTypeErrors and we are throwing messages, throw an error message*)
	invalidWashMixTipTypeOptions=If[Length[invalidWashMixTipTypeErrors]>0&&messages,
		(
			Message[Error::InvalidWashMixTipType,
				ObjectToString[invalidWashMixTipTypeErrors[[All,1]]],
				invalidWashMixTipTypeErrors[[All,2]]
			];
			{
				WashMixTipType
			}
		),
		{}
	];

	(*If we are gathering tests, create a test*)
	validWashMixTipTypeTest=If[gatherTests,
		Module[{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the inputs that fail this test*)
			failingSamples=invalidWashMixTipTypeErrors[[All,1]];

			(*Get the inputs that pass this test*)
			passingSamples=Complement[flatSimulatedSamples,failingSamples];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", if mix by Pipette and WashMixVolume is no larger than 970 Microliter, the WashMixTipType is WideBore:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", if mix by Pipette and WashMixVolume is no larger than 970 Microliter, the WashMixTipType is WideBore:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];


	(*Error::WashMixNoTip*)
	washMixNoTipErrors=checkMixNoTipErrorOfStage[
		flatSimulatedSamples,
		Lookup[mbsOptionsAssociationFlat,WashMixTipType],
		Flatten[resolvedWashMixTipTypes],
		Lookup[mbsOptionsAssociationFlat,WashMixTipMaterial],
		Flatten[resolvedWashMixTipMaterials],
		Flatten[resolvedWashMixVolumes],
    resolvedPreparation
	];

	(*If there are washMixNoTipErrors and we are throwing messages, throw an error message*)
	invalidWashMixTipOptions=If[Length[washMixNoTipErrors]>0&&messages,
		Message[Error::WashMixNoTip,
			ObjectToString[washMixNoTipErrors[[All,1]]],
			washMixNoTipErrors[[All,2]],
			washMixNoTipErrors[[All,3]],
			washMixNoTipErrors[[All,4]]];
		{WashMixTipType,WashMixTipMaterial,WashMixVolume},
		{}
	];

	(*If we are gathering tests, create a test*)
	validWashMixTipTest=If[gatherTests,
		Module[{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the inputs that fail this test*)
			failingSamples=washMixNoTipErrors[[All,1]];

			(*Get the inputs that pass this test*)
			passingSamples=Complement[flatSimulatedSamples,failingSamples];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", there are tips found given the WashMixTipType and WashMixTipMaterial for the WashMixVolume:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", there are tips found given the WashMixTipType and WashMixTipMaterial for the WashMixVolume:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];


	(*--Error::WashMixNoInstrument--*)
	washMixNoInstrumentErrors = checkMixNoInstrumentErrorsOfStage[
		Flatten@resolvedAssayContainers,
		Flatten@resolvedMagneticBeadVolumes,
		Flatten@resolvedWashMixes,
		Flatten@resolvedWashBufferVolumes,
		Flatten@resolvedWashMixTypes,
		Flatten@resolvedWashMixRates,
		Flatten@resolvedWashMixTemperatures
	];

	invalidWashMixInstrumentOptions=If[
		MemberQ[washMixNoInstrumentErrors,True]&&messages&&notInEngine,
		Message[Error::WashMixNoInstrument,ObjectToString[PickList[flatSimulatedSamples,washMixNoInstrumentErrors],Cache->simulatedCache]];
		{WashMixType,WashMixRate,WashMixTemperature},
		{}
	];

	(*If we are gathering tests, create a test*)
	validWashMixInstrumentTest=If[gatherTests,
		Module[
			{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the samples that fail this test*)
			failingSamples=PickList[flatSimulatedSamples,washMixNoInstrumentErrors];

			(*Get the samples that pass this test*)
			passingSamples=Complement[flatSimulatedSamples,failingSamples];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", at least one eligible mixing instrument is found given the resolved mixing options during Wash:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", at least one eligible mixing instrument is found given the resolved mixing options during Wash:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];

  (*--Error::WashAspirationPipettingMismatch--*)

  washAspirationPipettingMismatchErrors=checkAspirationPipettingMismatchErrorOfStage[flatSimulatedSamples,Lookup[mbsOptionsAssociationFlat,{WashAspirationPosition, WashAspirationPositionOffset}]];

  (*If there are washMixMismatchErrors and we are throwing messages, throw an error message*)
  washAspirationPipettingMismatchOptions=If[MemberQ[washAspirationPipettingMismatchErrors,True]&&messages,
    (
      Message[Error::WashAspirationPipettingOptionsMismatch,ObjectToString[PickList[flatSimulatedSamples,washAspirationPipettingMismatchErrors],Cache->simulatedCache]];
      {
        WashAspirationPosition, WashAspirationPositionOffset
      }
    ),
    {}
  ];

  (*If we are gathering tests, create a test*)
  washAspirationPipettingMismatchTests=If[gatherTests,
    Module[{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

      (*Get the inputs that fail this test*)
      failingSamples=PickList[flatSimulatedSamples,washAspirationPipettingMismatchErrors];

      (*Get the inputs that pass this test*)
      passingSamples=PickList[flatSimulatedSamples,washAspirationPipettingMismatchErrors,False];

      (*Create a test for the non-passing inputs*)
      failingSampleTests=If[Length[failingSamples]>0,
        Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", the WashAspirationPosition options are not in conflict with WashAspirationPositionOffset:",False,True],
        Nothing
      ];

      (*Create a test for the passing inputs*)
      passingSampleTests=If[Length[passingSamples]>0,
        Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", the WashAspirationPosition options are not in conflict with WashAspirationPositionOffset:",True,True],
        Nothing
      ];

      (*Return the created tests*)
      {failingSampleTests,passingSampleTests}
    ],
    Nothing
  ];
  

	(*--Error::WashAirDryMismatch--*)

	(*If there are washAirDryMismatchErrors and we are throwing messages, throw an error message*)
	washAirDryMismatchOptions=If[MemberQ[washAirDryMismatchErrors,True]&&messages,
		(
			Message[Error::WashAirDryMismatch,ObjectToString[PickList[flatSimulatedSamples,washAirDryMismatchErrors],Cache->simulatedCache]];
			{WashAirDry,WashAirDryTime}
		),
		{}
	];

	(*If we are gathering tests, create a test*)
	washAirDryMismatchTest=If[gatherTests,
		Module[
			{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the inputs that fail this test*)
			failingSamples=PickList[flatSimulatedSamples,washAirDryMismatchErrors];

			(*Get the inputs that pass this test*)
			passingSamples=PickList[flatSimulatedSamples,washAirDryMismatchErrors,False];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", WashAirDryTime is not in conflict with WashAirDry:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", WashAirDryTime is not in conflict with WashAirDry:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];


	(*==SecondaryWash==*)
	(*--Error::SecondaryWashMismatch--*)

	(*If there are secondaryWashMismatchErrors and we are throwing messages, throw an error message*)
	secondaryWashMismatchOptions=If[MemberQ[secondaryWashMismatchErrors,True]&&messages,
		(
			Message[Error::SecondaryWashMismatch,ObjectToString[PickList[flatSimulatedSamples,secondaryWashMismatchErrors],Cache->simulatedCache]];
			Select[Options[ExperimentMagneticBeadSeparation][[All, 1]], StringContainsQ[ToString[#], "SecondaryWash"] &]
		),
		{}
	];

	(*If we are gathering tests, create a test*)
	secondaryWashMismatchTest=If[gatherTests,
		Module[
			{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the inputs that fail this test*)
			failingSamples=PickList[flatSimulatedSamples,secondaryWashMismatchErrors];

			(*Get the inputs that pass this test*)
			passingSamples=PickList[flatSimulatedSamples,secondaryWashMismatchErrors,False];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", the SecondaryWash options are not in conflict with SecondaryWash:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", the SecondaryWash options are not in conflict with SecondaryWash:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];

	(*--Error::SecondaryWashMixMismatch--*)

	unresolvedSecondaryWashMixOptions= Lookup[mbsOptionsAssociationFlat,
		{SecondaryWashMix, SecondaryWashMixType, SecondaryWashMixTime, SecondaryWashMixRate,NumberOfSecondaryWashMixes, SecondaryWashMixVolume, SecondaryWashMixTemperature, SecondaryWashMixTipType, SecondaryWashMixTipMaterial}];

	secondaryWashMixMismatchErrors=checkMixMismatchErrorOfStage[flatSimulatedSamples,unresolvedSecondaryWashMixOptions];

	(*If there are secondaryWashMixMismatchErrors and we are throwing messages, throw an error message*)
	secondaryWashMixMismatchOptions=If[MemberQ[secondaryWashMixMismatchErrors,True]&&messages,
		(
			Message[Error::SecondaryWashMixMismatch,ObjectToString[PickList[flatSimulatedSamples,secondaryWashMixMismatchErrors],Cache->simulatedCache]];
			{
				SecondaryWashMix, SecondaryWashMixType, SecondaryWashMixTime, SecondaryWashMixRate,NumberOfSecondaryWashMixes, SecondaryWashMixVolume, SecondaryWashMixTemperature, SecondaryWashMixTipType, SecondaryWashMixTipMaterial
			}
		),
		{}
	];

	(*If we are gathering tests, create a test*)
	secondaryWashMixMismatchTest=If[gatherTests,
		Module[
			{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the inputs that fail this test*)
			failingSamples=PickList[flatSimulatedSamples,secondaryWashMixMismatchErrors];

			(*Get the inputs that pass this test*)
			passingSamples=PickList[flatSimulatedSamples,secondaryWashMixMismatchErrors,False];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", the SecondaryWashMix options are not in conflict with SecondaryWashMix:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", the SecondaryWashMix options are not in conflict with SecondaryWashMix:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];


	(*--Warning::invalidSecondaryWashMixTipType--*)
	invalidSecondaryWashMixTipTypeErrors=checkInvalidMixTipTypeOfStage[
		flatSimulatedSamples,
		Flatten[Lookup[mbsOptionsAssociationFlat,SecondaryWashMixTipType]],
		Flatten[resolvedSecondaryWashMixVolumes]
	];

	(*If there are invalidSecondaryWashMixTipTypeErrors and we are throwing messages, throw an error message*)
	invalidSecondaryWashMixTipTypeOptions=If[Length[invalidSecondaryWashMixTipTypeErrors]>0&&messages,
		(
			Message[Error::InvalidSecondaryWashMixTipType,
				ObjectToString[invalidSecondaryWashMixTipTypeErrors[[All,1]]],
				invalidSecondaryWashMixTipTypeErrors[[All,2]]
			];
			{
				SecondaryWashMixTipType
			}
		),
		{}
	];

	(*If we are gathering tests, create a test*)
	validSecondaryWashMixTipTypeTest=If[gatherTests,
		Module[{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the inputs that fail this test*)
			failingSamples=invalidSecondaryWashMixTipTypeErrors[[All,1]];

			(*Get the inputs that pass this test*)
			passingSamples=Complement[flatSimulatedSamples,failingSamples];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", if mix by Pipette and SecondaryWashMixVolume is no larger than 970 Microliter, the SecondaryWashMixTipType is WideBore:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", if mix by Pipette and SecondaryWashMixVolume is no larger than 970 Microliter, the SecondaryWashMixTipType is WideBore:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];


	(*Error::SecondaryWashMixNoTip*)
	secondaryWashMixNoTipErrors=checkMixNoTipErrorOfStage[
		flatSimulatedSamples,
		Lookup[mbsOptionsAssociationFlat,SecondaryWashMixTipType],
		Flatten[resolvedSecondaryWashMixTipTypes],
		Lookup[mbsOptionsAssociationFlat,SecondaryWashMixTipMaterial],
		Flatten[resolvedSecondaryWashMixTipMaterials],
		Flatten[resolvedSecondaryWashMixVolumes],
    resolvedPreparation
	];

	(*If there are secondaryWashMixNoTipErrors and we are throwing messages, throw an error message*)
	invalidSecondaryWashMixTipOptions=If[Length[secondaryWashMixNoTipErrors]>0&&messages,
		Message[Error::SecondaryWashMixNoTip,
			ObjectToString[secondaryWashMixNoTipErrors[[All,1]]],
			secondaryWashMixNoTipErrors[[All,2]],
			secondaryWashMixNoTipErrors[[All,3]],
			secondaryWashMixNoTipErrors[[All,4]]];
		{SecondaryWashMixTipType,SecondaryWashMixTipMaterial,SecondaryWashMixVolume},
		{}
	];

	(*If we are gathering tests, create a test*)
	validSecondaryWashMixTipTest=If[gatherTests,
		Module[{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the inputs that fail this test*)
			failingSamples=secondaryWashMixNoTipErrors[[All,1]];

			(*Get the inputs that pass this test*)
			passingSamples=Complement[flatSimulatedSamples,failingSamples];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", there are tips found given the SecondaryWashMixTipType and SecondaryWashMixTipMaterial for the SecondaryWashMixVolume:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", there are tips found given the SecondaryWashMixTipType and SecondaryWashMixTipMaterial for the SecondaryWashMixVolume:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];

	(*--Error::SecondaryWashMixNoInstrument--*)
	secondaryWashMixNoInstrumentErrors = checkMixNoInstrumentErrorsOfStage[
		Flatten@resolvedAssayContainers,
		Flatten@resolvedMagneticBeadVolumes,
		Flatten@resolvedSecondaryWashMixes,
		Flatten@resolvedSecondaryWashBufferVolumes,
		Flatten@resolvedSecondaryWashMixTypes,
		Flatten@resolvedSecondaryWashMixRates,
		Flatten@resolvedSecondaryWashMixTemperatures
	];

	invalidSecondaryWashMixInstrumentOptions=If[
		MemberQ[secondaryWashMixNoInstrumentErrors,True]&&messages&&notInEngine,
		Message[Error::SecondaryWashMixNoInstrument,ObjectToString[PickList[flatSimulatedSamples,secondaryWashMixNoInstrumentErrors],Cache->simulatedCache]];
		{SecondaryWashMixType,SecondaryWashMixRate,SecondaryWashMixTemperature},
		{}
	];

	(*If we are gathering tests, create a test*)
	validSecondaryWashMixInstrumentTest=If[gatherTests,
		Module[
			{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the samples that fail this test*)
			failingSamples=PickList[flatSimulatedSamples,secondaryWashMixNoInstrumentErrors];

			(*Get the samples that pass this test*)
			passingSamples=Complement[flatSimulatedSamples,failingSamples];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", at least one eligible mixing instrument is found given the resolved mixing options during SecondaryWash:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", at least one eligible mixing instrument is found given the resolved mixing options during SecondaryWash:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];

  (*--Error::SecondaryWashAspirationPipettingMismatch--*)

  secondaryWashAspirationPipettingMismatchErrors=checkAspirationPipettingMismatchErrorOfStage[flatSimulatedSamples,Lookup[mbsOptionsAssociationFlat,{SecondaryWashAspirationPosition, SecondaryWashAspirationPositionOffset}]];

  (*If there are secondaryWashMixMismatchErrors and we are throwing messages, throw an error message*)
  secondaryWashAspirationPipettingMismatchOptions=If[MemberQ[secondaryWashAspirationPipettingMismatchErrors,True]&&messages,
    (
      Message[Error::SecondaryWashAspirationPipettingOptionsMismatch,ObjectToString[PickList[flatSimulatedSamples,secondaryWashAspirationPipettingMismatchErrors],Cache->simulatedCache]];
      {
        SecondaryWashAspirationPosition, SecondaryWashAspirationPositionOffset
      }
    ),
    {}
  ];

  (*If we are gathering tests, create a test*)
  secondaryWashAspirationPipettingMismatchTests=If[gatherTests,
    Module[{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

      (*Get the inputs that fail this test*)
      failingSamples=PickList[flatSimulatedSamples,secondaryWashAspirationPipettingMismatchErrors];

      (*Get the inputs that pass this test*)
      passingSamples=PickList[flatSimulatedSamples,secondaryWashAspirationPipettingMismatchErrors,False];

      (*Create a test for the non-passing inputs*)
      failingSampleTests=If[Length[failingSamples]>0,
        Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", the SecondaryWashAspirationPosition options are not in conflict with SecondaryWashAspirationPositionOffset:",False,True],
        Nothing
      ];

      (*Create a test for the passing inputs*)
      passingSampleTests=If[Length[passingSamples]>0,
        Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", the SecondaryWashAspirationPosition options are not in conflict with SecondaryWashAspirationPositionOffset:",True,True],
        Nothing
      ];

      (*Return the created tests*)
      {failingSampleTests,passingSampleTests}
    ],
    Nothing
  ];
  

	(*--Error::SecondaryWashAirDryMismatch--*)

	(*If there are secondaryWashAirDryMismatchErrors and we are throwing messages, throw an error message*)
	secondaryWashAirDryMismatchOptions=If[MemberQ[secondaryWashAirDryMismatchErrors,True]&&messages,
		(
			Message[Error::SecondaryWashAirDryMismatch,ObjectToString[PickList[flatSimulatedSamples,secondaryWashAirDryMismatchErrors],Cache->simulatedCache]];
			{SecondaryWashAirDry,SecondaryWashAirDryTime}
		),
		{}
	];

	(*If we are gathering tests, create a test*)
	secondaryWashAirDryMismatchTest=If[gatherTests,
		Module[
			{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the inputs that fail this test*)
			failingSamples=PickList[flatSimulatedSamples,secondaryWashAirDryMismatchErrors];

			(*Get the inputs that pass this test*)
			passingSamples=PickList[flatSimulatedSamples,secondaryWashAirDryMismatchErrors,False];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", SecondaryWashAirDryTime is not in conflict with SecondaryWashAirDry:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", SecondaryWashAirDryTime is not in conflict with SecondaryWashAirDry:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];


	(*==TertiaryWash==*)
	(*--Error::TertiaryWashMismatch--*)

	(*If there are tertiaryWashMismatchErrors and we are throwing messages, throw an error message*)
	tertiaryWashMismatchOptions=If[MemberQ[tertiaryWashMismatchErrors,True]&&messages,
		(
			Message[Error::TertiaryWashMismatch,ObjectToString[PickList[flatSimulatedSamples,tertiaryWashMismatchErrors],Cache->simulatedCache]];
			Select[Options[ExperimentMagneticBeadSeparation][[All, 1]], StringContainsQ[ToString[#], "TertiaryWash"] &]
		),
		{}
	];

	(*If we are gathering tests, create a test*)
	tertiaryWashMismatchTest=If[gatherTests,
		Module[
			{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the inputs that fail this test*)
			failingSamples=PickList[flatSimulatedSamples,tertiaryWashMismatchErrors];

			(*Get the inputs that pass this test*)
			passingSamples=PickList[flatSimulatedSamples,tertiaryWashMismatchErrors,False];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", the TertiaryWash options are not in conflict with TertiaryWash:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", the TertiaryWash options are not in conflict with TertiaryWash:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];

	(*--Error::TertiaryWashMixMismatch--*)

	unresolvedTertiaryWashMixOptions= Lookup[mbsOptionsAssociationFlat,
		{TertiaryWashMix, TertiaryWashMixType, TertiaryWashMixTime, TertiaryWashMixRate,NumberOfTertiaryWashMixes, TertiaryWashMixVolume, TertiaryWashMixTemperature, TertiaryWashMixTipType, TertiaryWashMixTipMaterial}];

	tertiaryWashMixMismatchErrors=checkMixMismatchErrorOfStage[flatSimulatedSamples,unresolvedTertiaryWashMixOptions];

	(*If there are tertiaryWashMixMismatchErrors and we are throwing messages, throw an error message*)
	tertiaryWashMixMismatchOptions=If[MemberQ[tertiaryWashMixMismatchErrors,True]&&messages,
		(
			Message[Error::TertiaryWashMixMismatch,ObjectToString[PickList[flatSimulatedSamples,tertiaryWashMixMismatchErrors],Cache->simulatedCache]];
			{
				TertiaryWashMix, TertiaryWashMixType, TertiaryWashMixTime, TertiaryWashMixRate,NumberOfTertiaryWashMixes, TertiaryWashMixVolume, TertiaryWashMixTemperature, TertiaryWashMixTipType, TertiaryWashMixTipMaterial
			}
		),
		{}
	];

	(*If we are gathering tests, create a test*)
	tertiaryWashMixMismatchTest=If[gatherTests,
		Module[
			{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the inputs that fail this test*)
			failingSamples=PickList[flatSimulatedSamples,tertiaryWashMixMismatchErrors];

			(*Get the inputs that pass this test*)
			passingSamples=PickList[flatSimulatedSamples,tertiaryWashMixMismatchErrors,False];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", the TertiaryWashMix options are not in conflict with TertiaryWashMix:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", the TertiaryWashMix options are not in conflict with TertiaryWashMix:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];


	(*--Warning::invalidTertiaryWashMixTipType--*)
	invalidTertiaryWashMixTipTypeErrors=checkInvalidMixTipTypeOfStage[
		flatSimulatedSamples,
		Flatten[Lookup[mbsOptionsAssociationFlat,TertiaryWashMixTipType]],
		Flatten[resolvedTertiaryWashMixVolumes]
	];

	(*If there are invalidTertiaryWashMixTipTypeErrors and we are throwing messages, throw an error message*)
	invalidTertiaryWashMixTipTypeOptions=If[Length[invalidTertiaryWashMixTipTypeErrors]>0&&messages,
		(
			Message[Error::InvalidTertiaryWashMixTipType,
				ObjectToString[invalidTertiaryWashMixTipTypeErrors[[All,1]]],
				invalidTertiaryWashMixTipTypeErrors[[All,2]]
			];
			{
				TertiaryWashMixTipType
			}
		),
		{}
	];

	(*If we are gathering tests, create a test*)
	validTertiaryWashMixTipTypeTest=If[gatherTests,
		Module[{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the inputs that fail this test*)
			failingSamples=invalidTertiaryWashMixTipTypeErrors[[All,1]];

			(*Get the inputs that pass this test*)
			passingSamples=Complement[flatSimulatedSamples,failingSamples];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", if mix by Pipette and TertiaryWashMixVolume is no larger than 970 Microliter, the TertiaryWashMixTipType is WideBore:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", if mix by Pipette and TertiaryWashMixVolume is no larger than 970 Microliter, the TertiaryWashMixTipType is WideBore:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];


	(*Error::TertiaryWashMixNoTip*)
	tertiaryWashMixNoTipErrors=checkMixNoTipErrorOfStage[
		flatSimulatedSamples,
		Lookup[mbsOptionsAssociationFlat,TertiaryWashMixTipType],
		Flatten[resolvedTertiaryWashMixTipTypes],
		Lookup[mbsOptionsAssociationFlat,TertiaryWashMixTipMaterial],
		Flatten[resolvedTertiaryWashMixTipMaterials],
		Flatten[resolvedTertiaryWashMixVolumes],
    resolvedPreparation
	];

	(*If there are tertiaryWashMixNoTipErrors and we are throwing messages, throw an error message*)
	invalidTertiaryWashMixTipOptions=If[Length[tertiaryWashMixNoTipErrors]>0&&messages,
		Message[Error::TertiaryWashMixNoTip,
			ObjectToString[tertiaryWashMixNoTipErrors[[All,1]]],
			tertiaryWashMixNoTipErrors[[All,2]],
			tertiaryWashMixNoTipErrors[[All,3]],
			tertiaryWashMixNoTipErrors[[All,4]]];
		{TertiaryWashMixTipType,TertiaryWashMixTipMaterial,TertiaryWashMixVolume},
		{}
	];

	(*If we are gathering tests, create a test*)
	validTertiaryWashMixTipTest=If[gatherTests,
		Module[{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the inputs that fail this test*)
			failingSamples=tertiaryWashMixNoTipErrors[[All,1]];

			(*Get the inputs that pass this test*)
			passingSamples=Complement[flatSimulatedSamples,failingSamples];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", there are tips found given the TertiaryWashMixTipType and TertiaryWashMixTipMaterial for the TertiaryWashMixVolume:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", there are tips found given the TertiaryWashMixTipType and TertiaryWashMixTipMaterial for the TertiaryWashMixVolume:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];


	(*--Error::TertiaryWashMixNoInstrument--*)
	tertiaryWashMixNoInstrumentErrors = checkMixNoInstrumentErrorsOfStage[
		Flatten@resolvedAssayContainers,
		Flatten@resolvedMagneticBeadVolumes,
		Flatten@resolvedTertiaryWashMixes,
		Flatten@resolvedTertiaryWashBufferVolumes,
		Flatten@resolvedTertiaryWashMixTypes,
		Flatten@resolvedTertiaryWashMixRates,
		Flatten@resolvedTertiaryWashMixTemperatures
	];

	invalidTertiaryWashMixInstrumentOptions=If[
		MemberQ[tertiaryWashMixNoInstrumentErrors,True]&&messages&&notInEngine,
		Message[Error::TertiaryWashMixNoInstrument,ObjectToString[PickList[flatSimulatedSamples,tertiaryWashMixNoInstrumentErrors],Cache->simulatedCache]];
		{TertiaryWashMixType,TertiaryWashMixRate,TertiaryWashMixTemperature},
		{}
	];

	(*If we are gathering tests, create a test*)
	validTertiaryWashMixInstrumentTest=If[gatherTests,
		Module[
			{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the samples that fail this test*)
			failingSamples=PickList[flatSimulatedSamples,tertiaryWashMixNoInstrumentErrors];

			(*Get the samples that pass this test*)
			passingSamples=Complement[flatSimulatedSamples,failingSamples];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", at least one eligible mixing instrument is found given the resolved mixing options during TertiaryWash:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", at least one eligible mixing instrument is found given the resolved mixing options during TertiaryWash:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];

  (*--Error::TertiaryWashAspirationPipettingMismatch--*)

  tertiaryWashAspirationPipettingMismatchErrors=checkAspirationPipettingMismatchErrorOfStage[flatSimulatedSamples,Lookup[mbsOptionsAssociationFlat,{TertiaryWashAspirationPosition, TertiaryWashAspirationPositionOffset}]];

  (*If there are tertiaryWashMixMismatchErrors and we are throwing messages, throw an error message*)
  tertiaryWashAspirationPipettingMismatchOptions=If[MemberQ[tertiaryWashAspirationPipettingMismatchErrors,True]&&messages,
    (
      Message[Error::TertiaryWashAspirationPipettingOptionsMismatch,ObjectToString[PickList[flatSimulatedSamples,tertiaryWashAspirationPipettingMismatchErrors],Cache->simulatedCache]];
      {
        TertiaryWashAspirationPosition, TertiaryWashAspirationPositionOffset
      }
    ),
    {}
  ];

  (*If we are gathering tests, create a test*)
  tertiaryWashAspirationPipettingMismatchTests=If[gatherTests,
    Module[{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

      (*Get the inputs that fail this test*)
      failingSamples=PickList[flatSimulatedSamples,tertiaryWashAspirationPipettingMismatchErrors];

      (*Get the inputs that pass this test*)
      passingSamples=PickList[flatSimulatedSamples,tertiaryWashAspirationPipettingMismatchErrors,False];

      (*Create a test for the non-passing inputs*)
      failingSampleTests=If[Length[failingSamples]>0,
        Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", the TertiaryWashAspirationPosition options are not in conflict with TertiaryWashAspirationPositionOffset:",False,True],
        Nothing
      ];

      (*Create a test for the passing inputs*)
      passingSampleTests=If[Length[passingSamples]>0,
        Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", the TertiaryWashAspirationPosition options are not in conflict with TertiaryWashAspirationPositionOffset:",True,True],
        Nothing
      ];

      (*Return the created tests*)
      {failingSampleTests,passingSampleTests}
    ],
    Nothing
  ];
  

	(*--Error::TertiaryWashAirDryMismatch--*)

	(*If there are tertiaryWashAirDryMismatchErrors and we are throwing messages, throw an error message*)
	tertiaryWashAirDryMismatchOptions=If[MemberQ[tertiaryWashAirDryMismatchErrors,True]&&messages,
		(
			Message[Error::TertiaryWashAirDryMismatch,ObjectToString[PickList[flatSimulatedSamples,tertiaryWashAirDryMismatchErrors],Cache->simulatedCache]];
			{TertiaryWashAirDry,TertiaryWashAirDryTime}
		),
		{}
	];

	(*If we are gathering tests, create a test*)
	tertiaryWashAirDryMismatchTest=If[gatherTests,
		Module[
			{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the inputs that fail this test*)
			failingSamples=PickList[flatSimulatedSamples,tertiaryWashAirDryMismatchErrors];

			(*Get the inputs that pass this test*)
			passingSamples=PickList[flatSimulatedSamples,tertiaryWashAirDryMismatchErrors,False];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", TertiaryWashAirDryTime is not in conflict with TertiaryWashAirDry:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", TertiaryWashAirDryTime is not in conflict with TertiaryWashAirDry:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];


	(*==QuaternaryWash==*)
	(*--Error::QuaternaryWashMismatch--*)

	(*If there are quaternaryWashMismatchErrors and we are throwing messages, throw an error message*)
	quaternaryWashMismatchOptions=If[MemberQ[quaternaryWashMismatchErrors,True]&&messages,
		(
			Message[Error::QuaternaryWashMismatch,ObjectToString[PickList[flatSimulatedSamples,quaternaryWashMismatchErrors],Cache->simulatedCache]];
			Select[Options[ExperimentMagneticBeadSeparation][[All, 1]], StringContainsQ[ToString[#], "QuaternaryWash"] &]
		),
		{}
	];

	(*If we are gathering tests, create a test*)
	quaternaryWashMismatchTest=If[gatherTests,
		Module[
			{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the inputs that fail this test*)
			failingSamples=PickList[flatSimulatedSamples,quaternaryWashMismatchErrors];

			(*Get the inputs that pass this test*)
			passingSamples=PickList[flatSimulatedSamples,quaternaryWashMismatchErrors,False];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", the QuaternaryWash options are not in conflict with QuaternaryWash:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", the QuaternaryWash options are not in conflict with QuaternaryWash:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];

	(*--Error::QuaternaryWashMixMismatch--*)

	unresolvedQuaternaryWashMixOptions= Lookup[mbsOptionsAssociationFlat,
		{QuaternaryWashMix, QuaternaryWashMixType, QuaternaryWashMixTime, QuaternaryWashMixRate,NumberOfQuaternaryWashMixes, QuaternaryWashMixVolume, QuaternaryWashMixTemperature, QuaternaryWashMixTipType, QuaternaryWashMixTipMaterial}];

	quaternaryWashMixMismatchErrors=checkMixMismatchErrorOfStage[flatSimulatedSamples,unresolvedQuaternaryWashMixOptions];

	(*If there are quaternaryWashMixMismatchErrors and we are throwing messages, throw an error message*)
	quaternaryWashMixMismatchOptions=If[MemberQ[quaternaryWashMixMismatchErrors,True]&&messages,
		(
			Message[Error::QuaternaryWashMixMismatch,ObjectToString[PickList[flatSimulatedSamples,quaternaryWashMixMismatchErrors],Cache->simulatedCache]];
			{
				QuaternaryWashMix, QuaternaryWashMixType, QuaternaryWashMixTime, QuaternaryWashMixRate,NumberOfQuaternaryWashMixes, QuaternaryWashMixVolume, QuaternaryWashMixTemperature, QuaternaryWashMixTipType, QuaternaryWashMixTipMaterial
			}
		),
		{}
	];

	(*If we are gathering tests, create a test*)
	quaternaryWashMixMismatchTest=If[gatherTests,
		Module[
			{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the inputs that fail this test*)
			failingSamples=PickList[flatSimulatedSamples,quaternaryWashMixMismatchErrors];

			(*Get the inputs that pass this test*)
			passingSamples=PickList[flatSimulatedSamples,quaternaryWashMixMismatchErrors,False];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", the QuaternaryWashMix options are not in conflict with QuaternaryWashMix:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", the QuaternaryWashMix options are not in conflict with QuaternaryWashMix:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];


	(*--Warning::invalidQuaternaryWashMixTipType--*)
	invalidQuaternaryWashMixTipTypeErrors=checkInvalidMixTipTypeOfStage[
		flatSimulatedSamples,
		Flatten[Lookup[mbsOptionsAssociationFlat,QuaternaryWashMixTipType]],
		Flatten[resolvedQuaternaryWashMixVolumes]
	];

	(*If there are invalidQuaternaryWashMixTipTypeErrors and we are throwing messages, throw an error message*)
	invalidQuaternaryWashMixTipTypeOptions=If[Length[invalidQuaternaryWashMixTipTypeErrors]>0&&messages,
		(
			Message[Error::InvalidQuaternaryWashMixTipType,
				ObjectToString[invalidQuaternaryWashMixTipTypeErrors[[All,1]]],
				invalidQuaternaryWashMixTipTypeErrors[[All,2]]
			];
			{
				QuaternaryWashMixTipType
			}
		),
		{}
	];

	(*If we are gathering tests, create a test*)
	validQuaternaryWashMixTipTypeTest=If[gatherTests,
		Module[{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the inputs that fail this test*)
			failingSamples=invalidQuaternaryWashMixTipTypeErrors[[All,1]];

			(*Get the inputs that pass this test*)
			passingSamples=Complement[flatSimulatedSamples,failingSamples];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", if mix by Pipette and QuaternaryWashMixVolume is no larger than 970 Microliter, the QuaternaryWashMixTipType is WideBore:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", if mix by Pipette and QuaternaryWashMixVolume is no larger than 970 Microliter, the QuaternaryWashMixTipType is WideBore:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];

	(*Error::QuaternaryWashMixNoTip*)
	quaternaryWashMixNoTipErrors=checkMixNoTipErrorOfStage[
		flatSimulatedSamples,
		Lookup[mbsOptionsAssociationFlat,QuaternaryWashMixTipType],
		Flatten[resolvedQuaternaryWashMixTipTypes],
		Lookup[mbsOptionsAssociationFlat,QuaternaryWashMixTipMaterial],
		Flatten[resolvedQuaternaryWashMixTipMaterials],
		Flatten[resolvedQuaternaryWashMixVolumes],
    resolvedPreparation
	];

	(*If there are quaternaryWashMixNoTipErrors and we are throwing messages, throw an error message*)
	invalidQuaternaryWashMixTipOptions=If[Length[quaternaryWashMixNoTipErrors]>0&&messages,
		Message[Error::QuaternaryWashMixNoTip,
			ObjectToString[quaternaryWashMixNoTipErrors[[All,1]]],
			quaternaryWashMixNoTipErrors[[All,2]],
			quaternaryWashMixNoTipErrors[[All,3]],
			quaternaryWashMixNoTipErrors[[All,4]]];
		{QuaternaryWashMixTipType,QuaternaryWashMixTipMaterial,QuaternaryWashMixVolume},
		{}
	];

	(*If we are gathering tests, create a test*)
	validQuaternaryWashMixTipTest=If[gatherTests,
		Module[{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the inputs that fail this test*)
			failingSamples=quaternaryWashMixNoTipErrors[[All,1]];

			(*Get the inputs that pass this test*)
			passingSamples=Complement[flatSimulatedSamples,failingSamples];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", there are tips found given the QuaternaryWashMixTipType and QuaternaryWashMixTipMaterial for the QuaternaryWashMixVolume:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", there are tips found given the QuaternaryWashMixTipType and QuaternaryWashMixTipMaterial for the QuaternaryWashMixVolume:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];


	(*--Error::QuaternaryWashMixNoInstrument--*)
	quaternaryWashMixNoInstrumentErrors =checkMixNoInstrumentErrorsOfStage[
		Flatten@resolvedAssayContainers,
		Flatten@resolvedMagneticBeadVolumes,
		Flatten@resolvedQuaternaryWashMixes,
		Flatten@resolvedQuaternaryWashBufferVolumes,
		Flatten@resolvedQuaternaryWashMixTypes,
		Flatten@resolvedQuaternaryWashMixRates,
		Flatten@resolvedQuaternaryWashMixTemperatures
	];

	invalidQuaternaryWashMixInstrumentOptions=If[
		MemberQ[quaternaryWashMixNoInstrumentErrors,True]&&messages&&notInEngine,
		Message[Error::QuaternaryWashMixNoInstrument,ObjectToString[PickList[flatSimulatedSamples,quaternaryWashMixNoInstrumentErrors],Cache->simulatedCache]];
		{QuaternaryWashMixType,QuaternaryWashMixRate,QuaternaryWashMixTemperature},
		{}
	];

	(*If we are gathering tests, create a test*)
	validQuaternaryWashMixInstrumentTest=If[gatherTests,
		Module[
			{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the samples that fail this test*)
			failingSamples=PickList[flatSimulatedSamples,quaternaryWashMixNoInstrumentErrors];

			(*Get the samples that pass this test*)
			passingSamples=Complement[flatSimulatedSamples,failingSamples];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", at least one eligible mixing instrument is found given the resolved mixing options during QuaternaryWash:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", at least one eligible mixing instrument is found given the resolved mixing options during QuaternaryWash:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];

  (*--Error::QuaternaryWashAspirationPipettingMismatch--*)

  quaternaryWashAspirationPipettingMismatchErrors=checkAspirationPipettingMismatchErrorOfStage[flatSimulatedSamples,Lookup[mbsOptionsAssociationFlat,{QuaternaryWashAspirationPosition, QuaternaryWashAspirationPositionOffset}]];

  (*If there are quaternaryWashMixMismatchErrors and we are throwing messages, throw an error message*)
  quaternaryWashAspirationPipettingMismatchOptions=If[MemberQ[quaternaryWashAspirationPipettingMismatchErrors,True]&&messages,
    (
      Message[Error::QuaternaryWashAspirationPipettingOptionsMismatch,ObjectToString[PickList[flatSimulatedSamples,quaternaryWashAspirationPipettingMismatchErrors],Cache->simulatedCache]];
      {
        QuaternaryWashAspirationPosition, QuaternaryWashAspirationPositionOffset
      }
    ),
    {}
  ];

  (*If we are gathering tests, create a test*)
  quaternaryWashAspirationPipettingMismatchTests=If[gatherTests,
    Module[{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

      (*Get the inputs that fail this test*)
      failingSamples=PickList[flatSimulatedSamples,quaternaryWashAspirationPipettingMismatchErrors];

      (*Get the inputs that pass this test*)
      passingSamples=PickList[flatSimulatedSamples,quaternaryWashAspirationPipettingMismatchErrors,False];

      (*Create a test for the non-passing inputs*)
      failingSampleTests=If[Length[failingSamples]>0,
        Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", the QuaternaryWashAspirationPosition options are not in conflict with QuaternaryWashAspirationPositionOffset:",False,True],
        Nothing
      ];

      (*Create a test for the passing inputs*)
      passingSampleTests=If[Length[passingSamples]>0,
        Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", the QuaternaryWashAspirationPosition options are not in conflict with QuaternaryWashAspirationPositionOffset:",True,True],
        Nothing
      ];

      (*Return the created tests*)
      {failingSampleTests,passingSampleTests}
    ],
    Nothing
  ];
  

	(*--Error::QuaternaryWashAirDryMismatch--*)

	(*If there are quaternaryWashAirDryMismatchErrors and we are throwing messages, throw an error message*)
	quaternaryWashAirDryMismatchOptions=If[MemberQ[quaternaryWashAirDryMismatchErrors,True]&&messages,
		(
			Message[Error::QuaternaryWashAirDryMismatch,ObjectToString[PickList[flatSimulatedSamples,quaternaryWashAirDryMismatchErrors],Cache->simulatedCache]];
			{QuaternaryWashAirDry,QuaternaryWashAirDryTime}
		),
		{}
	];

	(*If we are gathering tests, create a test*)
	quaternaryWashAirDryMismatchTest=If[gatherTests,
		Module[
			{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the inputs that fail this test*)
			failingSamples=PickList[flatSimulatedSamples,quaternaryWashAirDryMismatchErrors];

			(*Get the inputs that pass this test*)
			passingSamples=PickList[flatSimulatedSamples,quaternaryWashAirDryMismatchErrors,False];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", QuaternaryWashAirDryTime is not in conflict with QuaternaryWashAirDry:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", QuaternaryWashAirDryTime is not in conflict with QuaternaryWashAirDry:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];


	(*==QuinaryWash==*)
	(*--Error::QuinaryWashMismatch--*)

	(*If there are quinaryWashMismatchErrors and we are throwing messages, throw an error message*)
	quinaryWashMismatchOptions=If[MemberQ[quinaryWashMismatchErrors,True]&&messages,
		(
			Message[Error::QuinaryWashMismatch,ObjectToString[PickList[flatSimulatedSamples,quinaryWashMismatchErrors],Cache->simulatedCache]];
			Select[Options[ExperimentMagneticBeadSeparation][[All, 1]], StringContainsQ[ToString[#], "QuinaryWash"] &]
		),
		{}
	];

	(*If we are gathering tests, create a test*)
	quinaryWashMismatchTest=If[gatherTests,
		Module[
			{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the inputs that fail this test*)
			failingSamples=PickList[flatSimulatedSamples,quinaryWashMismatchErrors];

			(*Get the inputs that pass this test*)
			passingSamples=PickList[flatSimulatedSamples,quinaryWashMismatchErrors,False];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", the QuinaryWash options are not in conflict with QuinaryWash:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", the QuinaryWash options are not in conflict with QuinaryWash:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];

	(*--Error::QuinaryWashMixMismatch--*)

	unresolvedQuinaryWashMixOptions= Lookup[mbsOptionsAssociationFlat,
		{QuinaryWashMix, QuinaryWashMixType, QuinaryWashMixTime, QuinaryWashMixRate,NumberOfQuinaryWashMixes, QuinaryWashMixVolume, QuinaryWashMixTemperature, QuinaryWashMixTipType, QuinaryWashMixTipMaterial}];

	quinaryWashMixMismatchErrors=checkMixMismatchErrorOfStage[flatSimulatedSamples,unresolvedQuinaryWashMixOptions];

	(*If there are quinaryWashMixMismatchErrors and we are throwing messages, throw an error message*)
	quinaryWashMixMismatchOptions=If[MemberQ[quinaryWashMixMismatchErrors,True]&&messages,
		(
			Message[Error::QuinaryWashMixMismatch,ObjectToString[PickList[flatSimulatedSamples,quinaryWashMixMismatchErrors],Cache->simulatedCache]];
			{
				QuinaryWashMix, QuinaryWashMixType, QuinaryWashMixTime, QuinaryWashMixRate,NumberOfQuinaryWashMixes, QuinaryWashMixVolume, QuinaryWashMixTemperature, QuinaryWashMixTipType, QuinaryWashMixTipMaterial
			}
		),
		{}
	];

	(*If we are gathering tests, create a test*)
	quinaryWashMixMismatchTest=If[gatherTests,
		Module[
			{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the inputs that fail this test*)
			failingSamples=PickList[flatSimulatedSamples,quinaryWashMixMismatchErrors];

			(*Get the inputs that pass this test*)
			passingSamples=PickList[flatSimulatedSamples,quinaryWashMixMismatchErrors,False];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", the QuinaryWashMix options are not in conflict with QuinaryWashMix:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", the QuinaryWashMix options are not in conflict with QuinaryWashMix:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];


	(*--Warning::invalidQuinaryWashMixTipType--*)
	invalidQuinaryWashMixTipTypeErrors=checkInvalidMixTipTypeOfStage[
		flatSimulatedSamples,
		Flatten[Lookup[mbsOptionsAssociationFlat,QuinaryWashMixTipType]],
		Flatten[resolvedQuinaryWashMixVolumes]
	];

	(*If there are invalidQuinaryWashMixTipTypeErrors and we are throwing messages, throw an error message*)
	invalidQuinaryWashMixTipTypeOptions=If[Length[invalidQuinaryWashMixTipTypeErrors]>0&&messages,
		(
			Message[Error::InvalidQuinaryWashMixTipType,
				ObjectToString[invalidQuinaryWashMixTipTypeErrors[[All,1]]],
				invalidQuinaryWashMixTipTypeErrors[[All,2]]
			];
			{
				QuinaryWashMixTipType
			}
		),
		{}
	];

	(*If we are gathering tests, create a test*)
	validQuinaryWashMixTipTypeTest=If[gatherTests,
		Module[{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the inputs that fail this test*)
			failingSamples=invalidQuinaryWashMixTipTypeErrors[[All,1]];

			(*Get the inputs that pass this test*)
			passingSamples=Complement[flatSimulatedSamples,failingSamples];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", if mix by Pipette and QuinaryWashMixVolume is no larger than 970 Microliter, the QuinaryWashMixTipType is WideBore:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", if mix by Pipette and QuinaryWashMixVolume is no larger than 970 Microliter, the QuinaryWashMixTipType is WideBore:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];

	(*Error::QuinaryWashMixNoTip*)
	quinaryWashMixNoTipErrors=checkMixNoTipErrorOfStage[
		flatSimulatedSamples,
		Lookup[mbsOptionsAssociationFlat,QuinaryWashMixTipType],
		Flatten[resolvedQuinaryWashMixTipTypes],
		Lookup[mbsOptionsAssociationFlat,QuinaryWashMixTipMaterial],
		Flatten[resolvedQuinaryWashMixTipMaterials],
		Flatten[resolvedQuinaryWashMixVolumes],
    resolvedPreparation
	];

	(*If there are quinaryWashMixNoTipErrors and we are throwing messages, throw an error message*)
	invalidQuinaryWashMixTipOptions=If[Length[quinaryWashMixNoTipErrors]>0&&messages,
		Message[Error::QuinaryWashMixNoTip,
			ObjectToString[quinaryWashMixNoTipErrors[[All,1]]],
			quinaryWashMixNoTipErrors[[All,2]],
			quinaryWashMixNoTipErrors[[All,3]],
			quinaryWashMixNoTipErrors[[All,4]]];
		{QuinaryWashMixTipType,QuinaryWashMixTipMaterial,QuinaryWashMixVolume},
		{}
	];

	(*If we are gathering tests, create a test*)
	validQuinaryWashMixTipTest=If[gatherTests,
		Module[{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the inputs that fail this test*)
			failingSamples=quinaryWashMixNoTipErrors[[All,1]];

			(*Get the inputs that pass this test*)
			passingSamples=Complement[flatSimulatedSamples,failingSamples];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", there are tips found given the QuinaryWashMixTipType and QuinaryWashMixTipMaterial for the QuinaryWashMixVolume:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", there are tips found given the QuinaryWashMixTipType and QuinaryWashMixTipMaterial for the QuinaryWashMixVolume:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];


	(*--Error::QuinaryWashMixNoInstrument--*)
	quinaryWashMixNoInstrumentErrors = checkMixNoInstrumentErrorsOfStage[
		Flatten@resolvedAssayContainers,
		Flatten@resolvedMagneticBeadVolumes,
		Flatten@resolvedQuinaryWashMixes,
		Flatten@resolvedQuinaryWashBufferVolumes,
		Flatten@resolvedQuinaryWashMixTypes,
		Flatten@resolvedQuinaryWashMixRates,
		Flatten@resolvedQuinaryWashMixTemperatures
	];

	invalidQuinaryWashMixInstrumentOptions=If[
		MemberQ[quinaryWashMixNoInstrumentErrors,True]&&messages&&notInEngine,
		Message[Error::QuinaryWashMixNoInstrument,ObjectToString[PickList[flatSimulatedSamples,quinaryWashMixNoInstrumentErrors],Cache->simulatedCache]];
		{QuinaryWashMixType,QuinaryWashMixRate,QuinaryWashMixTemperature},
		{}
	];

	(*If we are gathering tests, create a test*)
	validQuinaryWashMixInstrumentTest=If[gatherTests,
		Module[
			{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the samples that fail this test*)
			failingSamples=PickList[flatSimulatedSamples,quinaryWashMixNoInstrumentErrors];

			(*Get the samples that pass this test*)
			passingSamples=Complement[flatSimulatedSamples,failingSamples];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", at least one eligible mixing instrument is found given the resolved mixing options during QuinaryWash:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", at least one eligible mixing instrument is found given the resolved mixing options during QuinaryWash:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];

  (*--Error::QuinaryWashAspirationPipettingMismatch--*)

  quinaryWashAspirationPipettingMismatchErrors=checkAspirationPipettingMismatchErrorOfStage[flatSimulatedSamples,Lookup[mbsOptionsAssociationFlat,{QuinaryWashAspirationPosition, QuinaryWashAspirationPositionOffset}]];

  (*If there are quinaryWashMixMismatchErrors and we are throwing messages, throw an error message*)
  quinaryWashAspirationPipettingMismatchOptions=If[MemberQ[quinaryWashAspirationPipettingMismatchErrors,True]&&messages,
    (
      Message[Error::QuinaryWashAspirationPipettingOptionsMismatch,ObjectToString[PickList[flatSimulatedSamples,quinaryWashAspirationPipettingMismatchErrors],Cache->simulatedCache]];
      {
        QuinaryWashAspirationPosition, QuinaryWashAspirationPositionOffset
      }
    ),
    {}
  ];

  (*If we are gathering tests, create a test*)
  quinaryWashAspirationPipettingMismatchTests=If[gatherTests,
    Module[{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

      (*Get the inputs that fail this test*)
      failingSamples=PickList[flatSimulatedSamples,quinaryWashAspirationPipettingMismatchErrors];

      (*Get the inputs that pass this test*)
      passingSamples=PickList[flatSimulatedSamples,quinaryWashAspirationPipettingMismatchErrors,False];

      (*Create a test for the non-passing inputs*)
      failingSampleTests=If[Length[failingSamples]>0,
        Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", the QuinaryWashAspirationPosition options are not in conflict with QuinaryWashAspirationPositionOffset:",False,True],
        Nothing
      ];

      (*Create a test for the passing inputs*)
      passingSampleTests=If[Length[passingSamples]>0,
        Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", the QuinaryWashAspirationPosition options are not in conflict with QuinaryWashAspirationPositionOffset:",True,True],
        Nothing
      ];

      (*Return the created tests*)
      {failingSampleTests,passingSampleTests}
    ],
    Nothing
  ];
  

	(*--Error::QuinaryWashAirDryMismatch--*)

	(*If there are quinaryWashAirDryMismatchErrors and we are throwing messages, throw an error message*)
	quinaryWashAirDryMismatchOptions=If[MemberQ[quinaryWashAirDryMismatchErrors,True]&&messages,
		(
			Message[Error::QuinaryWashAirDryMismatch,ObjectToString[PickList[flatSimulatedSamples,quinaryWashAirDryMismatchErrors],Cache->simulatedCache]];
			{QuinaryWashAirDry,QuinaryWashAirDryTime}
		),
		{}
	];

	(*If we are gathering tests, create a test*)
	quinaryWashAirDryMismatchTest=If[gatherTests,
		Module[
			{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the inputs that fail this test*)
			failingSamples=PickList[flatSimulatedSamples,quinaryWashAirDryMismatchErrors];

			(*Get the inputs that pass this test*)
			passingSamples=PickList[flatSimulatedSamples,quinaryWashAirDryMismatchErrors,False];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", QuinaryWashAirDryTime is not in conflict with QuinaryWashAirDry:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", QuinaryWashAirDryTime is not in conflict with QuinaryWashAirDry:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];

	(*==SenaryWash==*)
	(*--Error::SenaryWashMismatch--*)

	(*If there are senaryWashMismatchErrors and we are throwing messages, throw an error message*)
	senaryWashMismatchOptions=If[MemberQ[senaryWashMismatchErrors,True]&&messages,
		(
			Message[Error::SenaryWashMismatch,ObjectToString[PickList[flatSimulatedSamples,senaryWashMismatchErrors],Cache->simulatedCache]];
			Select[Options[ExperimentMagneticBeadSeparation][[All, 1]], StringContainsQ[ToString[#], "SenaryWash"] &]
		),
		{}
	];

	(*If we are gathering tests, create a test*)
	senaryWashMismatchTest=If[gatherTests,
		Module[
			{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the inputs that fail this test*)
			failingSamples=PickList[flatSimulatedSamples,senaryWashMismatchErrors];

			(*Get the inputs that pass this test*)
			passingSamples=PickList[flatSimulatedSamples,senaryWashMismatchErrors,False];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", the SenaryWash options are not in conflict with SenaryWash:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", the SenaryWash options are not in conflict with SenaryWash:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];

	(*--Error::SenaryWashMixMismatch--*)

	unresolvedSenaryWashMixOptions= Lookup[mbsOptionsAssociationFlat,
		{SenaryWashMix, SenaryWashMixType, SenaryWashMixTime, SenaryWashMixRate,NumberOfSenaryWashMixes, SenaryWashMixVolume, SenaryWashMixTemperature, SenaryWashMixTipType, SenaryWashMixTipMaterial}];

	senaryWashMixMismatchErrors=checkMixMismatchErrorOfStage[flatSimulatedSamples,unresolvedSenaryWashMixOptions];

	(*If there are senaryWashMixMismatchErrors and we are throwing messages, throw an error message*)
	senaryWashMixMismatchOptions=If[MemberQ[senaryWashMixMismatchErrors,True]&&messages,
		(
			Message[Error::SenaryWashMixMismatch,ObjectToString[PickList[flatSimulatedSamples,senaryWashMixMismatchErrors],Cache->simulatedCache]];
			{
				SenaryWashMix, SenaryWashMixType, SenaryWashMixTime, SenaryWashMixRate,NumberOfSenaryWashMixes, SenaryWashMixVolume, SenaryWashMixTemperature, SenaryWashMixTipType, SenaryWashMixTipMaterial
			}
		),
		{}
	];

	(*If we are gathering tests, create a test*)
	senaryWashMixMismatchTest=If[gatherTests,
		Module[
			{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the inputs that fail this test*)
			failingSamples=PickList[flatSimulatedSamples,senaryWashMixMismatchErrors];

			(*Get the inputs that pass this test*)
			passingSamples=PickList[flatSimulatedSamples,senaryWashMixMismatchErrors,False];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", the SenaryWashMix options are not in conflict with SenaryWashMix:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", the SenaryWashMix options are not in conflict with SenaryWashMix:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];


	(*--Warning::invalidSenaryWashMixTipType--*)
	invalidSenaryWashMixTipTypeErrors=checkInvalidMixTipTypeOfStage[
		flatSimulatedSamples,
		Flatten[Lookup[mbsOptionsAssociationFlat,SenaryWashMixTipType]],
		Flatten[resolvedSenaryWashMixVolumes]
	];

	(*If there are invalidSenaryWashMixTipTypeErrors and we are throwing messages, throw an error message*)
	invalidSenaryWashMixTipTypeOptions=If[Length[invalidSenaryWashMixTipTypeErrors]>0&&messages,
		(
			Message[Error::InvalidSenaryWashMixTipType,
				ObjectToString[invalidSenaryWashMixTipTypeErrors[[All,1]]],
				invalidSenaryWashMixTipTypeErrors[[All,2]]
			];
			{
				SenaryWashMixTipType
			}
		),
		{}
	];

	(*If we are gathering tests, create a test*)
	validSenaryWashMixTipTypeTest=If[gatherTests,
		Module[{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the inputs that fail this test*)
			failingSamples=invalidSenaryWashMixTipTypeErrors[[All,1]];

			(*Get the inputs that pass this test*)
			passingSamples=Complement[flatSimulatedSamples,failingSamples];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", if mix by Pipette and SenaryWashMixVolume is no larger than 970 Microliter, the SenaryWashMixTipType is WideBore:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", if mix by Pipette and SenaryWashMixVolume is no larger than 970 Microliter, the SenaryWashMixTipType is WideBore:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];

	(*Error::SenaryWashMixNoTip*)
	senaryWashMixNoTipErrors=checkMixNoTipErrorOfStage[
		flatSimulatedSamples,
		Lookup[mbsOptionsAssociationFlat,SenaryWashMixTipType],
		Flatten[resolvedSenaryWashMixTipTypes],
		Lookup[mbsOptionsAssociationFlat,SenaryWashMixTipMaterial],
		Flatten[resolvedSenaryWashMixTipMaterials],
		Flatten[resolvedSenaryWashMixVolumes],
    resolvedPreparation
	];

	(*If there are senaryWashMixNoTipErrors and we are throwing messages, throw an error message*)
	invalidSenaryWashMixTipOptions=If[Length[senaryWashMixNoTipErrors]>0&&messages,
		Message[Error::SenaryWashMixNoTip,
			ObjectToString[senaryWashMixNoTipErrors[[All,1]]],
			senaryWashMixNoTipErrors[[All,2]],
			senaryWashMixNoTipErrors[[All,3]],
			senaryWashMixNoTipErrors[[All,4]]];
		{SenaryWashMixTipType,SenaryWashMixTipMaterial,SenaryWashMixVolume},
		{}
	];

	(*If we are gathering tests, create a test*)
	validSenaryWashMixTipTest=If[gatherTests,
		Module[{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the inputs that fail this test*)
			failingSamples=senaryWashMixNoTipErrors[[All,1]];

			(*Get the inputs that pass this test*)
			passingSamples=Complement[flatSimulatedSamples,failingSamples];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", there are tips found given the SenaryWashMixTipType and SenaryWashMixTipMaterial for the SenaryWashMixVolume:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", there are tips found given the SenaryWashMixTipType and SenaryWashMixTipMaterial for the SenaryWashMixVolume:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];


	(*--Error::SenaryWashMixNoInstrument--*)
	senaryWashMixNoInstrumentErrors = checkMixNoInstrumentErrorsOfStage[
			Flatten@resolvedAssayContainers,
			Flatten@resolvedMagneticBeadVolumes,
			Flatten@resolvedSenaryWashMixes,
			Flatten@resolvedSenaryWashBufferVolumes,
			Flatten@resolvedSenaryWashMixTypes,
			Flatten@resolvedSenaryWashMixRates,
			Flatten@resolvedSenaryWashMixTemperatures
		];

	invalidSenaryWashMixInstrumentOptions=If[
		MemberQ[senaryWashMixNoInstrumentErrors,True]&&messages&&notInEngine,
		Message[Error::SenaryWashMixNoInstrument,ObjectToString[PickList[flatSimulatedSamples,senaryWashMixNoInstrumentErrors],Cache->simulatedCache]];
		{SenaryWashMixType,SenaryWashMixRate,SenaryWashMixTemperature},
		{}
	];

	(*If we are gathering tests, create a test*)
	validSenaryWashMixInstrumentTest=If[gatherTests,
		Module[
			{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the samples that fail this test*)
			failingSamples=PickList[flatSimulatedSamples,senaryWashMixNoInstrumentErrors];

			(*Get the samples that pass this test*)
			passingSamples=Complement[flatSimulatedSamples,failingSamples];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", at least one eligible mixing instrument is found given the resolved mixing options during SenaryWash:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", at least one eligible mixing instrument is found given the resolved mixing options during SenaryWash:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];

  (*--Error::SenaryWashAspirationPipettingMismatch--*)

  senaryWashAspirationPipettingMismatchErrors=checkAspirationPipettingMismatchErrorOfStage[flatSimulatedSamples,Lookup[mbsOptionsAssociationFlat,{SenaryWashAspirationPosition, SenaryWashAspirationPositionOffset}]];

  (*If there are senaryWashMixMismatchErrors and we are throwing messages, throw an error message*)
  senaryWashAspirationPipettingMismatchOptions=If[MemberQ[senaryWashAspirationPipettingMismatchErrors,True]&&messages,
    (
      Message[Error::SenaryWashAspirationPipettingOptionsMismatch,ObjectToString[PickList[flatSimulatedSamples,senaryWashAspirationPipettingMismatchErrors],Cache->simulatedCache]];
      {
        SenaryWashAspirationPosition, SenaryWashAspirationPositionOffset
      }
    ),
    {}
  ];

  (*If we are gathering tests, create a test*)
  senaryWashAspirationPipettingMismatchTests=If[gatherTests,
    Module[{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

      (*Get the inputs that fail this test*)
      failingSamples=PickList[flatSimulatedSamples,senaryWashAspirationPipettingMismatchErrors];

      (*Get the inputs that pass this test*)
      passingSamples=PickList[flatSimulatedSamples,senaryWashAspirationPipettingMismatchErrors,False];

      (*Create a test for the non-passing inputs*)
      failingSampleTests=If[Length[failingSamples]>0,
        Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", the SenaryWashAspirationPosition options are not in conflict with SenaryWashAspirationPositionOffset:",False,True],
        Nothing
      ];

      (*Create a test for the passing inputs*)
      passingSampleTests=If[Length[passingSamples]>0,
        Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", the SenaryWashAspirationPosition options are not in conflict with SenaryWashAspirationPositionOffset:",True,True],
        Nothing
      ];

      (*Return the created tests*)
      {failingSampleTests,passingSampleTests}
    ],
    Nothing
  ];
  

	(*--Error::SenaryWashAirDryMismatch--*)

	(*If there are senaryWashAirDryMismatchErrors and we are throwing messages, throw an error message*)
	senaryWashAirDryMismatchOptions=If[MemberQ[senaryWashAirDryMismatchErrors,True]&&messages,
		(
			Message[Error::SenaryWashAirDryMismatch,ObjectToString[PickList[flatSimulatedSamples,senaryWashAirDryMismatchErrors],Cache->simulatedCache]];
			{SenaryWashAirDry,SenaryWashAirDryTime}
		),
		{}
	];

	(*If we are gathering tests, create a test*)
	senaryWashAirDryMismatchTest=If[gatherTests,
		Module[
			{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the inputs that fail this test*)
			failingSamples=PickList[flatSimulatedSamples,senaryWashAirDryMismatchErrors];

			(*Get the inputs that pass this test*)
			passingSamples=PickList[flatSimulatedSamples,senaryWashAirDryMismatchErrors,False];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", SenaryWashAirDryTime is not in conflict with SenaryWashAirDry:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", SenaryWashAirDryTime is not in conflict with SenaryWashAirDry:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];

	(*==SeptenaryWash==*)
	(*--Error::SeptenaryWashMismatch--*)

	(*If there are septenaryWashMismatchErrors and we are throwing messages, throw an error message*)
	septenaryWashMismatchOptions=If[MemberQ[septenaryWashMismatchErrors,True]&&messages,
		(
			Message[Error::SeptenaryWashMismatch,ObjectToString[PickList[flatSimulatedSamples,septenaryWashMismatchErrors],Cache->simulatedCache]];
			Select[Options[ExperimentMagneticBeadSeparation][[All, 1]], StringContainsQ[ToString[#], "SeptenaryWash"] &]
		),
		{}
	];

	(*If we are gathering tests, create a test*)
	septenaryWashMismatchTest=If[gatherTests,
		Module[
			{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the inputs that fail this test*)
			failingSamples=PickList[flatSimulatedSamples,septenaryWashMismatchErrors];

			(*Get the inputs that pass this test*)
			passingSamples=PickList[flatSimulatedSamples,septenaryWashMismatchErrors,False];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", the SeptenaryWash options are not in conflict with SeptenaryWash:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", the SeptenaryWash options are not in conflict with SeptenaryWash:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];

	(*--Error::SeptenaryWashMixMismatch--*)

	unresolvedSeptenaryWashMixOptions= Lookup[mbsOptionsAssociationFlat,
		{SeptenaryWashMix, SeptenaryWashMixType, SeptenaryWashMixTime, SeptenaryWashMixRate,NumberOfSeptenaryWashMixes, SeptenaryWashMixVolume, SeptenaryWashMixTemperature, SeptenaryWashMixTipType, SeptenaryWashMixTipMaterial}];

	septenaryWashMixMismatchErrors=checkMixMismatchErrorOfStage[flatSimulatedSamples,unresolvedSeptenaryWashMixOptions];

	(*If there are septenaryWashMixMismatchErrors and we are throwing messages, throw an error message*)
	septenaryWashMixMismatchOptions=If[MemberQ[septenaryWashMixMismatchErrors,True]&&messages,
		(
			Message[Error::SeptenaryWashMixMismatch,ObjectToString[PickList[flatSimulatedSamples,septenaryWashMixMismatchErrors],Cache->simulatedCache]];
			{
				SeptenaryWashMix, SeptenaryWashMixType, SeptenaryWashMixTime, SeptenaryWashMixRate,NumberOfSeptenaryWashMixes, SeptenaryWashMixVolume, SeptenaryWashMixTemperature, SeptenaryWashMixTipType, SeptenaryWashMixTipMaterial
			}
		),
		{}
	];

	(*If we are gathering tests, create a test*)
	septenaryWashMixMismatchTest=If[gatherTests,
		Module[
			{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the inputs that fail this test*)
			failingSamples=PickList[flatSimulatedSamples,septenaryWashMixMismatchErrors];

			(*Get the inputs that pass this test*)
			passingSamples=PickList[flatSimulatedSamples,septenaryWashMixMismatchErrors,False];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", the SeptenaryWashMix options are not in conflict with SeptenaryWashMix:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", the SeptenaryWashMix options are not in conflict with SeptenaryWashMix:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];


	(*--Warning::invalidSeptenaryWashMixTipType--*)
	invalidSeptenaryWashMixTipTypeErrors=checkInvalidMixTipTypeOfStage[
		flatSimulatedSamples,
		Flatten[Lookup[mbsOptionsAssociationFlat,SeptenaryWashMixTipType]],
		Flatten[resolvedSeptenaryWashMixVolumes]
	];

	(*If there are invalidSeptenaryWashMixTipTypeErrors and we are throwing messages, throw an error message*)
	invalidSeptenaryWashMixTipTypeOptions=If[Length[invalidSeptenaryWashMixTipTypeErrors]>0&&messages,
		(
			Message[Error::InvalidSeptenaryWashMixTipType,
				ObjectToString[invalidSeptenaryWashMixTipTypeErrors[[All,1]]],
				invalidSeptenaryWashMixTipTypeErrors[[All,2]]
			];
			{
				SeptenaryWashMixTipType
			}
		),
		{}
	];

	(*If we are gathering tests, create a test*)
	validSeptenaryWashMixTipTypeTest=If[gatherTests,
		Module[{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the inputs that fail this test*)
			failingSamples=invalidSeptenaryWashMixTipTypeErrors[[All,1]];

			(*Get the inputs that pass this test*)
			passingSamples=Complement[flatSimulatedSamples,failingSamples];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", if mix by Pipette and SeptenaryWashMixVolume is no larger than 970 Microliter, the SeptenaryWashMixTipType is WideBore:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", if mix by Pipette and SeptenaryWashMixVolume is no larger than 970 Microliter, the SeptenaryWashMixTipType is WideBore:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];

	(*Error::SeptenaryWashMixNoTip*)
	septenaryWashMixNoTipErrors=checkMixNoTipErrorOfStage[
		flatSimulatedSamples,
		Lookup[mbsOptionsAssociationFlat,SeptenaryWashMixTipType],
		Flatten[resolvedSeptenaryWashMixTipTypes],
		Lookup[mbsOptionsAssociationFlat,SeptenaryWashMixTipMaterial],
		Flatten[resolvedSeptenaryWashMixTipMaterials],
		Flatten[resolvedSeptenaryWashMixVolumes],
    resolvedPreparation
	];

	(*If there are septenaryWashMixNoTipErrors and we are throwing messages, throw an error message*)
	invalidSeptenaryWashMixTipOptions=If[Length[septenaryWashMixNoTipErrors]>0&&messages,
		Message[Error::SeptenaryWashMixNoTip,
			ObjectToString[septenaryWashMixNoTipErrors[[All,1]]],
			septenaryWashMixNoTipErrors[[All,2]],
			septenaryWashMixNoTipErrors[[All,3]],
			septenaryWashMixNoTipErrors[[All,4]]];
		{SeptenaryWashMixTipType,SeptenaryWashMixTipMaterial,SeptenaryWashMixVolume},
		{}
	];

	(*If we are gathering tests, create a test*)
	validSeptenaryWashMixTipTest=If[gatherTests,
		Module[{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the inputs that fail this test*)
			failingSamples=septenaryWashMixNoTipErrors[[All,1]];

			(*Get the inputs that pass this test*)
			passingSamples=Complement[flatSimulatedSamples,failingSamples];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", there are tips found given the SeptenaryWashMixTipType and SeptenaryWashMixTipMaterial for the SeptenaryWashMixVolume:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", there are tips found given the SeptenaryWashMixTipType and SeptenaryWashMixTipMaterial for the SeptenaryWashMixVolume:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];


	(*--Error::SeptenaryWashMixNoInstrument--*)
	septenaryWashMixNoInstrumentErrors =checkMixNoInstrumentErrorsOfStage[
		Flatten@resolvedAssayContainers,
		Flatten@resolvedMagneticBeadVolumes,
		Flatten@resolvedSeptenaryWashMixes,
		Flatten@resolvedSeptenaryWashBufferVolumes,
		Flatten@resolvedSeptenaryWashMixTypes,
		Flatten@resolvedSeptenaryWashMixRates,
		Flatten@resolvedSeptenaryWashMixTemperatures
	];

	invalidSeptenaryWashMixInstrumentOptions=If[
		MemberQ[septenaryWashMixNoInstrumentErrors,True]&&messages&&notInEngine,
		Message[Error::SeptenaryWashMixNoInstrument,ObjectToString[PickList[flatSimulatedSamples,septenaryWashMixNoInstrumentErrors],Cache->simulatedCache]];
		{SeptenaryWashMixType,SeptenaryWashMixRate,SeptenaryWashMixTemperature},
		{}
	];

	(*If we are gathering tests, create a test*)
	validSeptenaryWashMixInstrumentTest=If[gatherTests,
		Module[
			{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the samples that fail this test*)
			failingSamples=PickList[flatSimulatedSamples,septenaryWashMixNoInstrumentErrors];

			(*Get the samples that pass this test*)
			passingSamples=Complement[flatSimulatedSamples,failingSamples];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", at least one eligible mixing instrument is found given the resolved mixing options during SeptenaryWash:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", at least one eligible mixing instrument is found given the resolved mixing options during SeptenaryWash:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];

  (*--Error::SeptenaryWashAspirationPipettingMismatch--*)

  septenaryWashAspirationPipettingMismatchErrors=checkAspirationPipettingMismatchErrorOfStage[flatSimulatedSamples,Lookup[mbsOptionsAssociationFlat,{SeptenaryWashAspirationPosition, SeptenaryWashAspirationPositionOffset}]];

  (*If there are septenaryWashMixMismatchErrors and we are throwing messages, throw an error message*)
  septenaryWashAspirationPipettingMismatchOptions=If[MemberQ[septenaryWashAspirationPipettingMismatchErrors,True]&&messages,
    (
      Message[Error::SeptenaryWashAspirationPipettingOptionsMismatch,ObjectToString[PickList[flatSimulatedSamples,septenaryWashAspirationPipettingMismatchErrors],Cache->simulatedCache]];
      {
        SeptenaryWashAspirationPosition, SeptenaryWashAspirationPositionOffset
      }
    ),
    {}
  ];

  (*If we are gathering tests, create a test*)
  septenaryWashAspirationPipettingMismatchTests=If[gatherTests,
    Module[{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

      (*Get the inputs that fail this test*)
      failingSamples=PickList[flatSimulatedSamples,septenaryWashAspirationPipettingMismatchErrors];

      (*Get the inputs that pass this test*)
      passingSamples=PickList[flatSimulatedSamples,septenaryWashAspirationPipettingMismatchErrors,False];

      (*Create a test for the non-passing inputs*)
      failingSampleTests=If[Length[failingSamples]>0,
        Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", the SeptenaryWashAspirationPosition options are not in conflict with SeptenaryWashAspirationPositionOffset:",False,True],
        Nothing
      ];

      (*Create a test for the passing inputs*)
      passingSampleTests=If[Length[passingSamples]>0,
        Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", the SeptenaryWashAspirationPosition options are not in conflict with SeptenaryWashAspirationPositionOffset:",True,True],
        Nothing
      ];

      (*Return the created tests*)
      {failingSampleTests,passingSampleTests}
    ],
    Nothing
  ];
  

	(*--Error::SeptenaryWashAirDryMismatch--*)

	(*If there are septenaryWashAirDryMismatchErrors and we are throwing messages, throw an error message*)
	septenaryWashAirDryMismatchOptions=If[MemberQ[septenaryWashAirDryMismatchErrors,True]&&messages,
		(
			Message[Error::SeptenaryWashAirDryMismatch,ObjectToString[PickList[flatSimulatedSamples,septenaryWashAirDryMismatchErrors],Cache->simulatedCache]];
			{SeptenaryWashAirDry,SeptenaryWashAirDryTime}
		),
		{}
	];

	(*If we are gathering tests, create a test*)
	septenaryWashAirDryMismatchTest=If[gatherTests,
		Module[
			{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the inputs that fail this test*)
			failingSamples=PickList[flatSimulatedSamples,septenaryWashAirDryMismatchErrors];

			(*Get the inputs that pass this test*)
			passingSamples=PickList[flatSimulatedSamples,septenaryWashAirDryMismatchErrors,False];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", SeptenaryWashAirDryTime is not in conflict with SeptenaryWashAirDry:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", SeptenaryWashAirDryTime is not in conflict with SeptenaryWashAirDry:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];


	(*==Elution==*)

	(*--Error::ElutionMismatch--*)

	(*If there are elutionMismatchErrors and we are throwing messages, throw an error message*)
	elutionMismatchOptions=If[MemberQ[elutionMismatchErrors,True]&&messages,
		(
			Message[Error::ElutionMismatch,ObjectToString[PickList[flatSimulatedSamples,elutionMismatchErrors],Cache->simulatedCache]];
			Select[Options[ExperimentMagneticBeadSeparation][[All, 1]], StringContainsQ[ToString[#], "Elution"] &]
		),
		{}
	];

	(*If we are gathering tests, create a test*)
	elutionMismatchTest=If[gatherTests,
		Module[
			{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the inputs that fail this test*)
			failingSamples=PickList[flatSimulatedSamples,elutionMismatchErrors];

			(*Get the inputs that pass this test*)
			passingSamples=PickList[flatSimulatedSamples,elutionMismatchErrors,False];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", the Elution options are not in conflict with Elution:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", the Elution options are not in conflict with Elution:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];

	(*--Error::ElutionMixMismatch--*)

	unresolvedElutionMixOptions= Lookup[mbsOptionsAssociationFlat,
		{ElutionMix, ElutionMixType, ElutionMixTime, ElutionMixRate,NumberOfElutionMixes, ElutionMixVolume, ElutionMixTemperature, ElutionMixTipType, ElutionMixTipMaterial}];

	elutionMixMismatchErrors=checkMixMismatchErrorOfStage[flatSimulatedSamples,unresolvedElutionMixOptions];

	(*If there are elutionMixMismatchErrors and we are throwing messages, throw an error message*)
	elutionMixMismatchOptions=If[MemberQ[elutionMixMismatchErrors,True]&&messages,
		(
			Message[Error::ElutionMixMismatch,ObjectToString[PickList[flatSimulatedSamples,elutionMixMismatchErrors],Cache->simulatedCache]];
			{
				ElutionMix, ElutionMixType, ElutionMixTime, ElutionMixRate,NumberOfElutionMixes, ElutionMixVolume, ElutionMixTemperature, ElutionMixTipType, ElutionMixTipMaterial
			}
		),
		{}
	];

	(*If we are gathering tests, create a test*)
	elutionMixMismatchTest=If[gatherTests,
		Module[
			{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the inputs that fail this test*)
			failingSamples=PickList[flatSimulatedSamples,elutionMixMismatchErrors];

			(*Get the inputs that pass this test*)
			passingSamples=PickList[flatSimulatedSamples,elutionMixMismatchErrors,False];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", the ElutionMix options are not in conflict with ElutionMix:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", the ElutionMix options are not in conflict with ElutionMix:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];


	(*--Warning::invalidElutionMixTipType--*)
	invalidElutionMixTipTypeErrors=checkInvalidMixTipTypeOfStage[
		flatSimulatedSamples,
		Flatten[Lookup[mbsOptionsAssociationFlat,ElutionMixTipType]],
		Flatten[resolvedElutionMixVolumes]
	];

	(*If there are invalidElutionMixTipTypeErrors and we are throwing messages, throw an error message*)
	invalidElutionMixTipTypeOptions=If[Length[invalidElutionMixTipTypeErrors]>0&&messages,
		(
			Message[Error::InvalidElutionMixTipType,
				ObjectToString[invalidElutionMixTipTypeErrors[[All,1]]],
				invalidElutionMixTipTypeErrors[[All,2]]
			];
			{
				ElutionMixTipType
			}
		),
		{}
	];

	(*If we are gathering tests, create a test*)
	validElutionMixTipTypeTest=If[gatherTests,
		Module[{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the inputs that fail this test*)
			failingSamples=invalidElutionMixTipTypeErrors[[All,1]];

			(*Get the inputs that pass this test*)
			passingSamples=Complement[flatSimulatedSamples,failingSamples];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", if mix by Pipette and ElutionMixVolume is no larger than 970 Microliter, the ElutionMixTipType is WideBore:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", if mix by Pipette and ElutionMixVolume is no larger than 970 Microliter, the ElutionMixTipType is WideBore:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];

	(*Error::ElutionMixNoTip*)
	elutionMixNoTipErrors=checkMixNoTipErrorOfStage[
		flatSimulatedSamples,
		Lookup[mbsOptionsAssociationFlat,ElutionMixTipType],
		Flatten[resolvedElutionMixTipTypes],
		Lookup[mbsOptionsAssociationFlat,ElutionMixTipMaterial],
		Flatten[resolvedElutionMixTipMaterials],
		Flatten[resolvedElutionMixVolumes],
    resolvedPreparation
	];

	(*If there are elutionMixNoTipErrors and we are throwing messages, throw an error message*)
	invalidElutionMixTipOptions=If[Length[elutionMixNoTipErrors]>0&&messages,
		Message[Error::ElutionMixNoTip,
			ObjectToString[elutionMixNoTipErrors[[All,1]]],
			elutionMixNoTipErrors[[All,2]],
			elutionMixNoTipErrors[[All,3]],
			elutionMixNoTipErrors[[All,4]]];
		{ElutionMixTipType,ElutionMixTipMaterial,ElutionMixVolume},
		{}
	];

	(*If we are gathering tests, create a test*)
	validElutionMixTipTest=If[gatherTests,
		Module[{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the inputs that fail this test*)
			failingSamples=elutionMixNoTipErrors[[All,1]];

			(*Get the inputs that pass this test*)
			passingSamples=Complement[flatSimulatedSamples,failingSamples];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", there are tips found given the ElutionMixTipType and ElutionMixTipMaterial for the ElutionMixVolume:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", there are tips found given the ElutionMixTipType and ElutionMixTipMaterial for the ElutionMixVolume:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];

	(*--Error::ElutionMixNoInstrument--*)
	elutionMixNoInstrumentErrors = checkMixNoInstrumentErrorsOfStage[
		Flatten@resolvedAssayContainers,
		Flatten@resolvedMagneticBeadVolumes,
		Flatten@resolvedElutionMixes,
		Flatten@resolvedElutionBufferVolumes,
		Flatten@resolvedElutionMixTypes,
		Flatten@resolvedElutionMixRates,
		Flatten@resolvedElutionMixTemperatures
	];

	invalidElutionMixInstrumentOptions=If[
		MemberQ[elutionMixNoInstrumentErrors,True]&&messages&&notInEngine,
		Message[Error::ElutionMixNoInstrument,ObjectToString[PickList[flatSimulatedSamples,elutionMixNoInstrumentErrors],Cache->simulatedCache]];
		{ElutionMixType,ElutionMixRate,ElutionMixTemperature},
		{}
	];

	(*If we are gathering tests, create a test*)
	validElutionMixInstrumentTest=If[gatherTests,
		Module[
			{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

			(*Get the samples that fail this test*)
			failingSamples=PickList[flatSimulatedSamples,elutionMixNoInstrumentErrors];

			(*Get the samples that pass this test*)
			passingSamples=Complement[flatSimulatedSamples,failingSamples];

			(*Create a test for the non-passing inputs*)
			failingSampleTests=If[Length[failingSamples]>0,
				Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", at least one eligible mixing instrument is found given the resolved mixing options during Elution:",False,True],
				Nothing
			];

			(*Create a test for the passing inputs*)
			passingSampleTests=If[Length[passingSamples]>0,
				Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", at least one eligible mixing instrument is found given the resolved mixing options during Elution:",True,True],
				Nothing
			];

			(*Return the created tests*)
			{failingSampleTests,passingSampleTests}
		],
		Nothing
	];

  (*--Error::ElutionAspirationPipettingMismatch--*)

  elutionAspirationPipettingMismatchErrors=checkAspirationPipettingMismatchErrorOfStage[flatSimulatedSamples,Lookup[mbsOptionsAssociationFlat,{ElutionAspirationPosition, ElutionAspirationPositionOffset}]];

  (*If there are elutionMixMismatchErrors and we are throwing messages, throw an error message*)
  elutionAspirationPipettingMismatchOptions=If[MemberQ[elutionAspirationPipettingMismatchErrors,True]&&messages,
    (
      Message[Error::ElutionAspirationPipettingOptionsMismatch,ObjectToString[PickList[flatSimulatedSamples,elutionAspirationPipettingMismatchErrors],Cache->simulatedCache]];
      {
        ElutionAspirationPosition, ElutionAspirationPositionOffset
      }
    ),
    {}
  ];

  (*If we are gathering tests, create a test*)
  elutionAspirationPipettingMismatchTests=If[gatherTests,
    Module[{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

      (*Get the inputs that fail this test*)
      failingSamples=PickList[flatSimulatedSamples,elutionAspirationPipettingMismatchErrors];

      (*Get the inputs that pass this test*)
      passingSamples=PickList[flatSimulatedSamples,elutionAspirationPipettingMismatchErrors,False];

      (*Create a test for the non-passing inputs*)
      failingSampleTests=If[Length[failingSamples]>0,
        Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", the ElutionAspirationPosition options are not in conflict with ElutionAspirationPositionOffset:",False,True],
        Nothing
      ];

      (*Create a test for the passing inputs*)
      passingSampleTests=If[Length[passingSamples]>0,
        Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", the ElutionAspirationPosition options are not in conflict with ElutionAspirationPositionOffset:",True,True],
        Nothing
      ];

      (*Return the created tests*)
      {failingSampleTests,passingSampleTests}
    ],
    Nothing
  ];
  

		(*==InvalidXXWashErrors (checks if a wash stage occurs after a True for the previous wash stage)==*)

		(*--Error::invalidSecondaryWashError--*)
		invalidSecondaryWashErrors=checkInvalidMultipleWashStageError[flatSimulatedSamples,resolvedWashes,resolvedSecondaryWashes];

		(*If there are invalidSecondaryWashErrors and we are throwing messages, throw an error message*)
		invalidSecondaryWashOptions=If[MemberQ[invalidSecondaryWashErrors,True]&&messages,
			(
				Message[Error::InvalidSecondaryWash,ObjectToString[PickList[flatSimulatedSamples,invalidSecondaryWashErrors],Cache->simulatedCache]];
				Select[Options[ExperimentMagneticBeadSeparation][[All, 1]], StringContainsQ[ToString[#], "SecondaryWash"] &]
			),
			{}
		];
		(*If we are gathering tests, create a test*)
		validSecondaryWashTest=If[gatherTests,
			Module[
				{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

				(*Get the inputs that fail this test*)
				failingSamples=PickList[flatSimulatedSamples,invalidSecondaryWashErrors];

				(*Get the inputs that pass this test*)
				passingSamples=PickList[flatSimulatedSamples,invalidSecondaryWashErrors,False];

				(*Create a test for the non-passing inputs*)
				failingSampleTests=If[Length[failingSamples]>0,
					Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", the SecondaryWash is either carried out after Wash or not carried out:",False,True],
					Nothing
				];

				(*Create a test for the passing inputs*)
				passingSampleTests=If[Length[passingSamples]>0,
					Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", the SecondaryWash is either carried out after Wash or not carried out:",True,True],
					Nothing
				];

				(*Return the created tests*)
				{failingSampleTests,passingSampleTests}
			],
			Nothing
		];

		(*--Error::invalidTertiaryWashError--*)
		invalidTertiaryWashErrors=checkInvalidMultipleWashStageError[flatSimulatedSamples,resolvedSecondaryWashes,resolvedTertiaryWashes];

		(*If there are invalidTertiaryWashErrors and we are throwing messages, throw an error message*)
		invalidTertiaryWashOptions=If[MemberQ[invalidTertiaryWashErrors,True]&&messages,
			(
				Message[Error::InvalidTertiaryWash,ObjectToString[PickList[flatSimulatedSamples,invalidTertiaryWashErrors],Cache->simulatedCache]];
				Select[Options[ExperimentMagneticBeadSeparation][[All, 1]], StringContainsQ[ToString[#], "TertiaryWash"] &]
			),
			{}
		];
		(*If we are gathering tests, create a test*)
		validTertiaryWashTest=If[gatherTests,
			Module[
				{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

				(*Get the inputs that fail this test*)
				failingSamples=PickList[flatSimulatedSamples,invalidTertiaryWashErrors];

				(*Get the inputs that pass this test*)
				passingSamples=PickList[flatSimulatedSamples,invalidTertiaryWashErrors,False];

				(*Create a test for the non-passing inputs*)
				failingSampleTests=If[Length[failingSamples]>0,
					Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", the TertiaryWash is either carried out after SecondaryWash or not carried out:",False,True],
					Nothing
				];

				(*Create a test for the passing inputs*)
				passingSampleTests=If[Length[passingSamples]>0,
					Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", the TertiaryWash is either carried out after SecondaryWash or not carried out:",True,True],
					Nothing
				];

				(*Return the created tests*)
				{failingSampleTests,passingSampleTests}
			],
			Nothing
		];

		(*--Error::invalidQuaternaryWashError--*)
		invalidQuaternaryWashErrors= checkInvalidMultipleWashStageError[flatSimulatedSamples,resolvedTertiaryWashes,resolvedQuaternaryWashes];

		(*If there are invalidQuaternaryWashErrors and we are throwing messages, throw an error message*)
		invalidQuaternaryWashOptions=If[MemberQ[invalidQuaternaryWashErrors,True]&&messages,
			(
				Message[Error::InvalidQuaternaryWash,ObjectToString[PickList[flatSimulatedSamples,invalidQuaternaryWashErrors],Cache->simulatedCache]];
				Select[Options[ExperimentMagneticBeadSeparation][[All, 1]], StringContainsQ[ToString[#], "QuaternaryWash"] &]
			),
			{}
		];
		(*If we are gathering tests, create a test*)
		validQuaternaryWashTest=If[gatherTests,
			Module[
				{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

				(*Get the inputs that fail this test*)
				failingSamples=PickList[flatSimulatedSamples,invalidQuaternaryWashErrors];

				(*Get the inputs that pass this test*)
				passingSamples=PickList[flatSimulatedSamples,invalidQuaternaryWashErrors,False];

				(*Create a test for the non-passing inputs*)
				failingSampleTests=If[Length[failingSamples]>0,
					Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", the QuaternaryWash is either carried out after TertiaryWash or not carried out:",False,True],
					Nothing
				];

				(*Create a test for the passing inputs*)
				passingSampleTests=If[Length[passingSamples]>0,
					Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", the QuaternaryWash is either carried out after TertiaryWash or not carried out:",True,True],
					Nothing
				];

				(*Return the created tests*)
				{failingSampleTests,passingSampleTests}
			],
			Nothing
		];

		(*--Error::invalidQuinaryWashError--*)
		invalidQuinaryWashErrors=checkInvalidMultipleWashStageError[flatSimulatedSamples,resolvedQuaternaryWashes,resolvedQuinaryWashes];

		(*If there are invalidQuinaryWashErrors and we are throwing messages, throw an error message*)
		invalidQuinaryWashOptions=If[MemberQ[invalidQuinaryWashErrors,True]&&messages,
			(
				Message[Error::InvalidQuinaryWash,ObjectToString[PickList[flatSimulatedSamples,invalidQuinaryWashErrors],Cache->simulatedCache]];
				Select[Options[ExperimentMagneticBeadSeparation][[All, 1]], StringContainsQ[ToString[#], "QuinaryWash"] &]
			),
			{}
		];
		(*If we are gathering tests, create a test*)
		validQuinaryWashTest=If[gatherTests,
			Module[
				{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

				(*Get the inputs that fail this test*)
				failingSamples=PickList[flatSimulatedSamples,invalidQuinaryWashErrors];

				(*Get the inputs that pass this test*)
				passingSamples=PickList[flatSimulatedSamples,invalidQuinaryWashErrors,False];

				(*Create a test for the non-passing inputs*)
				failingSampleTests=If[Length[failingSamples]>0,
					Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", the QuinaryWash is either carried out after QuaternaryWash or not carried out:",False,True],
					Nothing
				];

				(*Create a test for the passing inputs*)
				passingSampleTests=If[Length[passingSamples]>0,
					Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", the QuinaryWash is either carried out after QuaternaryWash or not carried out:",True,True],
					Nothing
				];

				(*Return the created tests*)
				{failingSampleTests,passingSampleTests}
			],
			Nothing
		];

		(*--Error::invalidSenaryWashError--*)
		invalidSenaryWashErrors=checkInvalidMultipleWashStageError[flatSimulatedSamples,resolvedWashes,resolvedSenaryWashes];

		(*If there are invalidSenaryWashErrors and we are throwing messages, throw an error message*)
		invalidSenaryWashOptions=If[MemberQ[invalidSenaryWashErrors,True]&&messages,
			(
				Message[Error::InvalidSenaryWash,ObjectToString[PickList[flatSimulatedSamples,invalidSenaryWashErrors],Cache->simulatedCache]];
				Select[Options[ExperimentMagneticBeadSeparation][[All, 1]], StringContainsQ[ToString[#], "SenaryWash"] &]
			),
			{}
		];
		(*If we are gathering tests, create a test*)
		validSenaryWashTest=If[gatherTests,
			Module[
				{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

				(*Get the inputs that fail this test*)
				failingSamples=PickList[flatSimulatedSamples,invalidSenaryWashErrors];

				(*Get the inputs that pass this test*)
				passingSamples=PickList[flatSimulatedSamples,invalidSenaryWashErrors,False];

				(*Create a test for the non-passing inputs*)
				failingSampleTests=If[Length[failingSamples]>0,
					Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", the SenaryWash is either carried out after Wash or not carried out:",False,True],
					Nothing
				];

				(*Create a test for the passing inputs*)
				passingSampleTests=If[Length[passingSamples]>0,
					Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", the SenaryWash is either carried out after Wash or not carried out:",True,True],
					Nothing
				];

				(*Return the created tests*)
				{failingSampleTests,passingSampleTests}
			],
			Nothing
		];

		(*--Error::invalidSeptenaryWashError--*)
		invalidSeptenaryWashErrors=checkInvalidMultipleWashStageError[flatSimulatedSamples,resolvedWashes,resolvedSeptenaryWashes];

		(*If there are invalidSeptenaryWashErrors and we are throwing messages, throw an error message*)
		invalidSeptenaryWashOptions=If[MemberQ[invalidSeptenaryWashErrors,True]&&messages,
			(
				Message[Error::InvalidSeptenaryWash,ObjectToString[PickList[flatSimulatedSamples,invalidSeptenaryWashErrors],Cache->simulatedCache]];
				Select[Options[ExperimentMagneticBeadSeparation][[All, 1]], StringContainsQ[ToString[#], "SeptenaryWash"] &]
			),
			{}
		];
		(*If we are gathering tests, create a test*)
		validSeptenaryWashTest=If[gatherTests,
			Module[
				{failingSamples,passingSamples,failingSampleTests,passingSampleTests},

				(*Get the inputs that fail this test*)
				failingSamples=PickList[flatSimulatedSamples,invalidSeptenaryWashErrors];

				(*Get the inputs that pass this test*)
				passingSamples=PickList[flatSimulatedSamples,invalidSeptenaryWashErrors,False];

				(*Create a test for the non-passing inputs*)
				failingSampleTests=If[Length[failingSamples]>0,
					Test["For the following samples "<>ObjectToString[failingSamples,Cache->simulatedCache]<>", the SeptenaryWash is either carried out after Wash or not carried out:",False,True],
					Nothing
				];

				(*Create a test for the passing inputs*)
				passingSampleTests=If[Length[passingSamples]>0,
					Test["For the following samples "<>ObjectToString[passingSamples,Cache->simulatedCache]<>", the SeptenaryWash is either carried out after Wash or not carried out:",True,True],
					Nothing
				];

				(*Return the created tests*)
				{failingSampleTests,passingSampleTests}
			],
			Nothing
		];

		(*--Warning::MaxTimeParallelProcessing--*)
		(* In our compiler, we pick the Max of the time, temperature and mix rate options for Parallel processing. We want to warn the users about this. *)
		(* NOTE: This check happens across batches *)
		optionsAllSameQ=Flatten@Map[
			Function[{flattenedOptionList},
				SameQ@@DeleteCases[#,Automatic|Null]&/@unflattenListHelper[flattenedOptionList,myNestedSamples]
			],
			{
				resolvedPreWashMixTimes,resolvedPreWashMixTemperatures,resolvedPreWashMixRates,resolvedPreWashMagnetizationTimes,resolvedPreWashAirDryTimes,
				resolvedEquilibrationMixTimes,resolvedEquilibrationMixTemperatures,resolvedEquilibrationMixRates,resolvedEquilibrationMagnetizationTimes,resolvedEquilibrationAirDryTimes,
				resolvedLoadingMixTimes,resolvedLoadingMixTemperatures,resolvedLoadingMagnetizationTimes,resolvedLoadingMixRates,resolvedLoadingAirDryTimes,
				resolvedWashMixTimes,resolvedWashMixTemperatures,resolvedWashMixRates,resolvedWashMagnetizationTimes,resolvedWashAirDryTimes,
				resolvedSecondaryWashMixTimes,resolvedSecondaryWashMixTemperatures,resolvedSecondaryWashMixRates,resolvedSecondaryWashMagnetizationTimes,resolvedSecondaryWashAirDryTimes,
				resolvedTertiaryWashMixTimes,resolvedTertiaryWashMixTemperatures,resolvedTertiaryWashMixRates,resolvedTertiaryWashMagnetizationTimes,resolvedTertiaryWashAirDryTimes,
				resolvedQuaternaryWashMixTimes,resolvedQuaternaryWashMixTemperatures,resolvedQuaternaryWashMixRates,resolvedQuaternaryWashMagnetizationTimes,resolvedQuaternaryWashAirDryTimes,
				resolvedQuinaryWashMixTimes,resolvedQuinaryWashMixTemperatures,resolvedQuinaryWashMixRates,resolvedQuinaryWashMagnetizationTimes,resolvedQuinaryWashAirDryTimes,
				resolvedSenaryWashMixTimes,resolvedSenaryWashMixTemperatures,resolvedSenaryWashMixRates,resolvedSenaryWashMagnetizationTimes,resolvedSenaryWashAirDryTimes,
				resolvedSeptenaryWashMixTimes,resolvedSeptenaryWashMixTemperatures,resolvedSeptenaryWashMixRates,resolvedSeptenaryWashMagnetizationTimes,resolvedSeptenaryWashAirDryTimes,
				resolvedElutionMixTimes,resolvedElutionMixTemperatures,resolvedElutionMixRates,resolvedElutionMagnetizationTimes
			}
		];

		maxOptionRequestedQ=And[
			MemberQ[optionsAllSameQ,False],
			MatchQ[resolvedProcessingOrder,Parallel|Batch]
		];

		If[maxOptionRequestedQ&&messages,
			Message[Warning::MaxTimeParallelProcessing];
		];

		parallelMaxOptionTest=Warning["Under Parallel ProcessingOrder, the maximum processing time, temperature, mix rate of each step for the samples will be used for all the samples even if different settings are provided:",False,maxOptionRequestedQ];

		(*---Resolve aliquot options---*)

		(*Resolve RequiredAliquotContainers*)
		targetContainers=Null;

		(*Resolve aliquot options and make tests*)
		{resolvedAliquotOptions,aliquotTests}=If[gatherTests,
			resolvePooledAliquotOptions[
				ExperimentMagneticBeadSeparation,
				myNestedSamples,
				Flatten@simulatedSamples,
				ReplaceRule[myOptions,resolvedSamplePrepOptions],
				Cache->simulatedCache,
				RequiredAliquotAmounts->Null,
				RequiredAliquotContainers->targetContainers,
				Output->{Result,Tests}
			],
			{
				resolvePooledAliquotOptions[
					ExperimentMagneticBeadSeparation,
					myNestedSamples,
					Flatten@simulatedSamples,
					ReplaceRule[myOptions,resolvedSamplePrepOptions],
					Cache->simulatedCache,
					RequiredAliquotAmounts->Null,
					RequiredAliquotContainers->targetContainers,
					Output->Result
				],
				{}
			}
		];

		(*---Resolve Post Processing Options---*)
		resolvedPostProcessingOptions=resolvePostProcessingOptions[myOptions];


		(*---Resolve Email---*)

		(*True if it's a parent protocol, and False if it's a subprotocol*)
		resolvedEmail=Which[
			MatchQ[Lookup[myOptions,Email],Automatic]&&NullQ[parentProtocol],True,
			MatchQ[Lookup[myOptions,Email],Automatic]&&MatchQ[parentProtocol,ObjectP[ProtocolTypes[]]],False,
			True,Lookup[myOptions,Email]
		];

		(*---Check our invalid input and invalid option variables and throw Error::InvalidInput or Error::InvalidOption if necessary---*)
		invalidInputs=DeleteDuplicates[Flatten[{
			discardedInvalidInputs,
			solidInvalidInputs
		}]];
		invalidOptions=DeleteDuplicates[Flatten[{
			invalidProcessingOrderOptions,
			invalidNameOptions,
			separationModeMismatchOptions,
			invalidBufferVolumesOptions,
			conflictingCollectionStorageConditionOptions,
			invalidDestinationWellsOptions,
			preWashMismatchOptions,
			numberOfPreWashMismatchOptions,
			preWashMixMismatchOptions,
			invalidPreWashMixTipTypeOptions,
			invalidPreWashMixTipOptions,
			invalidPreWashMixInstrumentOptions,
			preWashAirDryMismatchOptions,
      preWashAspirationPipettingMismatchOptions,
			numberOfEquilibrationMismatchOptions,
			equilibrationMismatchOptions,
			equilibrationMixMismatchOptions,
			invalidEquilibrationMixTipTypeOptions,
			invalidEquilibrationMixTipOptions,
			invalidEquilibrationMixInstrumentOptions,
			equilibrationAirDryMismatchOptions,
      equilibrationAspirationPipettingMismatchOptions,
			numberOfLoadingMismatchOptions,
			loadingMixMismatchOptions,
			invalidLoadingMixTipTypeOptions,
			invalidLoadingMixTipOptions,
			invalidLoadingMixInstrumentOptions,
			loadingAirDryMismatchOptions,
      loadingAspirationPipettingMismatchOptions,
			washMismatchOptions,
			numberOfWashMismatchOptions,
			washMixMismatchOptions,
			invalidWashMixTipTypeOptions,
			invalidWashMixTipOptions,
			invalidWashMixInstrumentOptions,
			washAirDryMismatchOptions,
      washAspirationPipettingMismatchOptions,
			secondaryWashMismatchOptions,
			numberOfSecondaryWashMismatchOptions,
			secondaryWashMixMismatchOptions,
			invalidSecondaryWashMixTipTypeOptions,
			invalidSecondaryWashMixTipOptions,
			invalidSecondaryWashMixInstrumentOptions,
			secondaryWashAirDryMismatchOptions,
      secondaryWashAspirationPipettingMismatchOptions,
			invalidSecondaryWashOptions,
			tertiaryWashMismatchOptions,
			numberOfTertiaryWashMismatchOptions,
			tertiaryWashMixMismatchOptions,
			invalidTertiaryWashMixTipTypeOptions,
			invalidTertiaryWashMixTipOptions,
			invalidTertiaryWashMixInstrumentOptions,
			tertiaryWashAirDryMismatchOptions,
      tertiaryWashAspirationPipettingMismatchOptions,
			invalidTertiaryWashOptions,
			quaternaryWashMismatchOptions,
			numberOfQuaternaryWashMismatchOptions,
			quaternaryWashMixMismatchOptions,
			invalidQuaternaryWashMixTipTypeOptions,
			invalidQuaternaryWashMixTipOptions,
			invalidQuaternaryWashMixInstrumentOptions,
			quaternaryWashAirDryMismatchOptions,
      quaternaryWashAspirationPipettingMismatchOptions,
			invalidQuaternaryWashOptions,
			quinaryWashMismatchOptions,
			numberOfQuinaryWashMismatchOptions,
			quinaryWashMixMismatchOptions,
			invalidQuinaryWashMixTipTypeOptions,
			invalidQuinaryWashMixTipOptions,
			invalidQuinaryWashMixInstrumentOptions,
			quinaryWashAirDryMismatchOptions,
      quinaryWashAspirationPipettingMismatchOptions,
			invalidQuinaryWashOptions,
			senaryWashMismatchOptions,
			numberOfSenaryWashMismatchOptions,
			senaryWashMixMismatchOptions,
			invalidSenaryWashMixTipTypeOptions,
			invalidSenaryWashMixTipOptions,
			invalidSenaryWashMixInstrumentOptions,
			senaryWashAirDryMismatchOptions,
      senaryWashAspirationPipettingMismatchOptions,
			invalidSenaryWashOptions,
			septenaryWashMismatchOptions,
			numberOfSeptenaryWashMismatchOptions,
			septenaryWashMixMismatchOptions,
			invalidSeptenaryWashMixTipTypeOptions,
			invalidSeptenaryWashMixTipOptions,
			invalidSeptenaryWashMixInstrumentOptions,
			septenaryWashAirDryMismatchOptions,
      septenaryWashAspirationPipettingMismatchOptions,
			invalidSeptenaryWashOptions,
			elutionMismatchOptions,
      numberOfElutionMismatchOptions,
			elutionMixMismatchOptions,
			invalidElutionMixTipTypeOptions,
			invalidElutionMixTipOptions,
			invalidElutionMixInstrumentOptions,
      elutionAspirationPipettingMismatchOptions,
			If[MatchQ[preparationResult,$Failed],{Preparation},{}]
		}]];

		(*Throw Error::InvalidInput if there are invalid inputs*)
		If[Length[invalidInputs]>0&&messages,
			Message[Error::InvalidInput,ObjectToString[invalidInputs,Cache->simulatedCache]]
		];

		(*Throw Error::InvalidOption if there are invalid options*)
		If[Length[invalidOptions]>0&&messages,
			Message[Error::InvalidOption,invalidOptions]
		];

		(*---Return our resolved options and tests---*)
		(* NOTE: Any variables that were resolved in a map thread need to be unflattened in order to correctly match  *)
		(* the nestedness of the input samples again *)
		(*Gather the resolved options (pre-collapsed; that is happening outside the function)*)
		resolvedOptions=ReplaceRule[Normal[updatedRoundedMBSOptions,Association],
			Flatten[
				{
					Volume->unflattenListHelper[resolvedVolumes,myNestedSamples],
					MagneticBeadVolume->unflattenListHelper[resolvedMagneticBeadVolumes,myNestedSamples],
					Preparation->resolvedPreparation,
					ProcessingOrder->resolvedProcessingOrder,
					MagnetizationRack->unflattenListHelper[resolvedMagnetizationRacks,myNestedSamples],
					Target->unflattenListHelper[resolvedTargets,myNestedSamples],
					AnalyteAffinityLabel->unflattenListHelper[resolvedAnalyteAffinityLabels,myNestedSamples],
					MagneticBeadAffinityLabel->unflattenListHelper[resolvedMagneticBeadAffinityLabels,myNestedSamples],
					MagneticBeads->unflattenListHelper[resolvedMagneticBeads,myNestedSamples],
					MagneticBeadCollectionStorageCondition->unflattenListHelper[magneticBeadCollectionStorageConditions,myNestedSamples],
					(* PreWash *)
					PreWash->unflattenListHelper[resolvedPreWashes,myNestedSamples],
					PreWashBuffer->unflattenListHelper[resolvedPreWashBuffers,myNestedSamples],
					PreWashBufferVolume->unflattenListHelper[resolvedPreWashBufferVolumes,myNestedSamples],
					PreWashMix->unflattenListHelper[resolvedPreWashMixes,myNestedSamples],
					PreWashMixType->unflattenListHelper[resolvedPreWashMixTypes,myNestedSamples],
					PreWashMixTime->unflattenListHelper[resolvedPreWashMixTimes,myNestedSamples],
					PreWashMixRate->unflattenListHelper[resolvedPreWashMixRates,myNestedSamples],
					NumberOfPreWashMixes->unflattenListHelper[resolvedNumberOfPreWashMixes,myNestedSamples],
					PreWashMixVolume->unflattenListHelper[resolvedPreWashMixVolumes,myNestedSamples],
					PreWashMixTemperature->unflattenListHelper[resolvedPreWashMixTemperatures,myNestedSamples],
					PreWashMixTipType->unflattenListHelper[resolvedPreWashMixTipTypes,myNestedSamples],
					PreWashMixTipMaterial->unflattenListHelper[resolvedPreWashMixTipMaterials,myNestedSamples],
					PreWashMagnetizationTime->unflattenListHelper[resolvedPreWashMagnetizationTimes,myNestedSamples],
					PreWashAspirationVolume->unflattenListHelper[resolvedPreWashAspirationVolumes,myNestedSamples],
          PreWashAspirationPosition->unflattenListHelper[resolvedPreWashAspirationPositions,myNestedSamples],
          PreWashAspirationPositionOffset->unflattenListHelper[resolvedPreWashAspirationPositionOffsets,myNestedSamples],
					PreWashCollectionContainer->correctedPreWashCollectionContainers,
					PreWashCollectionStorageCondition->unflattenListHelper[correctedPreWashCollectionStorageConditions,myNestedSamples],
					NumberOfPreWashes->unflattenListHelper[resolvedNumberOfPreWashes,myNestedSamples],
					PreWashAirDry->unflattenListHelper[resolvedPreWashAirDries,myNestedSamples],
					PreWashAirDryTime->unflattenListHelper[resolvedPreWashAirDryTimes,myNestedSamples],
					(* Equilibration *)
					Equilibration->unflattenListHelper[resolvedEquilibrations,myNestedSamples],
					EquilibrationBuffer->unflattenListHelper[resolvedEquilibrationBuffers,myNestedSamples],
					EquilibrationBufferVolume->unflattenListHelper[resolvedEquilibrationBufferVolumes,myNestedSamples],
					EquilibrationMix->unflattenListHelper[resolvedEquilibrationMixes,myNestedSamples],
					EquilibrationMixType->unflattenListHelper[resolvedEquilibrationMixTypes,myNestedSamples],
					EquilibrationMixTime->unflattenListHelper[resolvedEquilibrationMixTimes,myNestedSamples],
					EquilibrationMixRate->unflattenListHelper[resolvedEquilibrationMixRates,myNestedSamples],
					NumberOfEquilibrationMixes->unflattenListHelper[resolvedNumberOfEquilibrationMixes,myNestedSamples],
					EquilibrationMixVolume->unflattenListHelper[resolvedEquilibrationMixVolumes,myNestedSamples],
					EquilibrationMixTemperature->unflattenListHelper[resolvedEquilibrationMixTemperatures,myNestedSamples],
					EquilibrationMixTipType->unflattenListHelper[resolvedEquilibrationMixTipTypes,myNestedSamples],
					EquilibrationMixTipMaterial->unflattenListHelper[resolvedEquilibrationMixTipMaterials,myNestedSamples],
					EquilibrationMagnetizationTime->unflattenListHelper[resolvedEquilibrationMagnetizationTimes,myNestedSamples],
					EquilibrationAspirationVolume->unflattenListHelper[resolvedEquilibrationAspirationVolumes,myNestedSamples],
          EquilibrationAspirationPosition->unflattenListHelper[resolvedEquilibrationAspirationPositions,myNestedSamples],
          EquilibrationAspirationPositionOffset->unflattenListHelper[resolvedEquilibrationAspirationPositionOffsets,myNestedSamples],
					EquilibrationCollectionContainer->correctedEquilibrationCollectionContainers,
					EquilibrationCollectionStorageCondition->unflattenListHelper[correctedEquilibrationCollectionStorageConditions,myNestedSamples],
					EquilibrationAirDry->unflattenListHelper[resolvedEquilibrationAirDries,myNestedSamples],
					EquilibrationAirDryTime->unflattenListHelper[resolvedEquilibrationAirDryTimes,myNestedSamples],
					(* Loading *)
					LoadingMix->unflattenListHelper[resolvedLoadingMixes,myNestedSamples],
					LoadingMixType->unflattenListHelper[resolvedLoadingMixTypes,myNestedSamples],
					LoadingMixTime->unflattenListHelper[resolvedLoadingMixTimes,myNestedSamples],
					LoadingMixRate->unflattenListHelper[resolvedLoadingMixRates,myNestedSamples],
					NumberOfLoadingMixes->unflattenListHelper[resolvedNumberOfLoadingMixes,myNestedSamples],
					LoadingMixVolume->unflattenListHelper[resolvedLoadingMixVolumes,myNestedSamples],
					LoadingMixTemperature->unflattenListHelper[resolvedLoadingMixTemperatures,myNestedSamples],
					LoadingMixTipType->unflattenListHelper[resolvedLoadingMixTipTypes,myNestedSamples],
					LoadingMixTipMaterial->unflattenListHelper[resolvedLoadingMixTipMaterials,myNestedSamples],
					LoadingMagnetizationTime->unflattenListHelper[resolvedLoadingMagnetizationTimes,myNestedSamples],
					LoadingAspirationVolume->unflattenListHelper[resolvedLoadingAspirationVolumes,myNestedSamples],
          LoadingAspirationPosition->unflattenListHelper[resolvedLoadingAspirationPositions,myNestedSamples],
          LoadingAspirationPositionOffset->unflattenListHelper[resolvedLoadingAspirationPositionOffsets,myNestedSamples],
					LoadingCollectionContainer->correctedLoadingCollectionContainers,
					LoadingCollectionStorageCondition->unflattenListHelper[correctedLoadingCollectionStorageConditions,myNestedSamples],
					LoadingAirDry->unflattenListHelper[resolvedLoadingAirDries,myNestedSamples],
					LoadingAirDryTime->unflattenListHelper[resolvedLoadingAirDryTimes,myNestedSamples],
					(* Wash *)
					Wash->unflattenListHelper[resolvedWashes,myNestedSamples],
					WashBuffer->unflattenListHelper[resolvedWashBuffers,myNestedSamples],
					WashBufferVolume->unflattenListHelper[resolvedWashBufferVolumes,myNestedSamples],
					WashMix->unflattenListHelper[resolvedWashMixes,myNestedSamples],
					WashMixType->unflattenListHelper[resolvedWashMixTypes,myNestedSamples],
					WashMixTime->unflattenListHelper[resolvedWashMixTimes,myNestedSamples],
					WashMixRate->unflattenListHelper[resolvedWashMixRates,myNestedSamples],
					NumberOfWashMixes->unflattenListHelper[resolvedNumberOfWashMixes,myNestedSamples],
					WashMixVolume->unflattenListHelper[resolvedWashMixVolumes,myNestedSamples],
					WashMixTemperature->unflattenListHelper[resolvedWashMixTemperatures,myNestedSamples],
					WashMixTipType->unflattenListHelper[resolvedWashMixTipTypes,myNestedSamples],
					WashMixTipMaterial->unflattenListHelper[resolvedWashMixTipMaterials,myNestedSamples],
					WashMagnetizationTime->unflattenListHelper[resolvedWashMagnetizationTimes,myNestedSamples],
					WashAspirationVolume->unflattenListHelper[resolvedWashAspirationVolumes,myNestedSamples],
          WashAspirationPosition->unflattenListHelper[resolvedWashAspirationPositions,myNestedSamples],
          WashAspirationPositionOffset->unflattenListHelper[resolvedWashAspirationPositionOffsets,myNestedSamples],
					WashCollectionContainer->correctedWashCollectionContainers,
					WashCollectionStorageCondition->unflattenListHelper[correctedWashCollectionStorageConditions,myNestedSamples],
					NumberOfWashes->unflattenListHelper[resolvedNumberOfWashes,myNestedSamples],
					WashAirDry->unflattenListHelper[resolvedWashAirDries,myNestedSamples],
					WashAirDryTime->unflattenListHelper[resolvedWashAirDryTimes,myNestedSamples],
					(* SecondaryWash *)
					SecondaryWash->unflattenListHelper[resolvedSecondaryWashes,myNestedSamples],
					SecondaryWashBuffer->unflattenListHelper[resolvedSecondaryWashBuffers,myNestedSamples],
					SecondaryWashBufferVolume->unflattenListHelper[resolvedSecondaryWashBufferVolumes,myNestedSamples],
					SecondaryWashMix->unflattenListHelper[resolvedSecondaryWashMixes,myNestedSamples],
					SecondaryWashMixType->unflattenListHelper[resolvedSecondaryWashMixTypes,myNestedSamples],
					SecondaryWashMixTime->unflattenListHelper[resolvedSecondaryWashMixTimes,myNestedSamples],
					SecondaryWashMixRate->unflattenListHelper[resolvedSecondaryWashMixRates,myNestedSamples],
					NumberOfSecondaryWashMixes->unflattenListHelper[resolvedNumberOfSecondaryWashMixes,myNestedSamples],
					SecondaryWashMixVolume->unflattenListHelper[resolvedSecondaryWashMixVolumes,myNestedSamples],
					SecondaryWashMixTemperature->unflattenListHelper[resolvedSecondaryWashMixTemperatures,myNestedSamples],
					SecondaryWashMixTipType->unflattenListHelper[resolvedSecondaryWashMixTipTypes,myNestedSamples],
					SecondaryWashMixTipMaterial->unflattenListHelper[resolvedSecondaryWashMixTipMaterials,myNestedSamples],
					SecondaryWashMagnetizationTime->unflattenListHelper[resolvedSecondaryWashMagnetizationTimes,myNestedSamples],
					SecondaryWashAspirationVolume->unflattenListHelper[resolvedSecondaryWashAspirationVolumes,myNestedSamples],
          SecondaryWashAspirationPosition->unflattenListHelper[resolvedSecondaryWashAspirationPositions,myNestedSamples],
          SecondaryWashAspirationPositionOffset->unflattenListHelper[resolvedSecondaryWashAspirationPositionOffsets,myNestedSamples],
					SecondaryWashCollectionContainer->correctedSecondaryWashCollectionContainers,
					SecondaryWashCollectionStorageCondition->unflattenListHelper[correctedSecondaryWashCollectionStorageConditions,myNestedSamples],
					NumberOfSecondaryWashes->unflattenListHelper[resolvedNumberOfSecondaryWashes,myNestedSamples],
					SecondaryWashAirDry->unflattenListHelper[resolvedSecondaryWashAirDries,myNestedSamples],
					SecondaryWashAirDryTime->unflattenListHelper[resolvedSecondaryWashAirDryTimes,myNestedSamples],
					(* TertiaryWash *)
					TertiaryWash->unflattenListHelper[resolvedTertiaryWashes,myNestedSamples],
					TertiaryWashBuffer->unflattenListHelper[resolvedTertiaryWashBuffers,myNestedSamples],
					TertiaryWashBufferVolume->unflattenListHelper[resolvedTertiaryWashBufferVolumes,myNestedSamples],
					TertiaryWashMix->unflattenListHelper[resolvedTertiaryWashMixes,myNestedSamples],
					TertiaryWashMixType->unflattenListHelper[resolvedTertiaryWashMixTypes,myNestedSamples],
					TertiaryWashMixTime->unflattenListHelper[resolvedTertiaryWashMixTimes,myNestedSamples],
					TertiaryWashMixRate->unflattenListHelper[resolvedTertiaryWashMixRates,myNestedSamples],
					NumberOfTertiaryWashMixes->unflattenListHelper[resolvedNumberOfTertiaryWashMixes,myNestedSamples],
					TertiaryWashMixVolume->unflattenListHelper[resolvedTertiaryWashMixVolumes,myNestedSamples],
					TertiaryWashMixTemperature->unflattenListHelper[resolvedTertiaryWashMixTemperatures,myNestedSamples],
					TertiaryWashMixTipType->unflattenListHelper[resolvedTertiaryWashMixTipTypes,myNestedSamples],
					TertiaryWashMixTipMaterial->unflattenListHelper[resolvedTertiaryWashMixTipMaterials,myNestedSamples],
					TertiaryWashMagnetizationTime->unflattenListHelper[resolvedTertiaryWashMagnetizationTimes,myNestedSamples],
					TertiaryWashAspirationVolume->unflattenListHelper[resolvedTertiaryWashAspirationVolumes,myNestedSamples],
          TertiaryWashAspirationPosition->unflattenListHelper[resolvedTertiaryWashAspirationPositions,myNestedSamples],
          TertiaryWashAspirationPositionOffset->unflattenListHelper[resolvedTertiaryWashAspirationPositionOffsets,myNestedSamples],
					TertiaryWashCollectionContainer->correctedTertiaryWashCollectionContainers,
					TertiaryWashCollectionStorageCondition->unflattenListHelper[correctedTertiaryWashCollectionStorageConditions,myNestedSamples],
					NumberOfTertiaryWashes->unflattenListHelper[resolvedNumberOfTertiaryWashes,myNestedSamples],
					TertiaryWashAirDry->unflattenListHelper[resolvedTertiaryWashAirDries,myNestedSamples],
					TertiaryWashAirDryTime->unflattenListHelper[resolvedTertiaryWashAirDryTimes,myNestedSamples],
					(* QuaternaryWash *)
					QuaternaryWash->unflattenListHelper[resolvedQuaternaryWashes,myNestedSamples],
					QuaternaryWashBuffer->unflattenListHelper[resolvedQuaternaryWashBuffers,myNestedSamples],
					QuaternaryWashBufferVolume->unflattenListHelper[resolvedQuaternaryWashBufferVolumes,myNestedSamples],
					QuaternaryWashMix->unflattenListHelper[resolvedQuaternaryWashMixes,myNestedSamples],
					QuaternaryWashMixType->unflattenListHelper[resolvedQuaternaryWashMixTypes,myNestedSamples],
					QuaternaryWashMixTime->unflattenListHelper[resolvedQuaternaryWashMixTimes,myNestedSamples],
					QuaternaryWashMixRate->unflattenListHelper[resolvedQuaternaryWashMixRates,myNestedSamples],
					NumberOfQuaternaryWashMixes->unflattenListHelper[resolvedNumberOfQuaternaryWashMixes,myNestedSamples],
					QuaternaryWashMixVolume->unflattenListHelper[resolvedQuaternaryWashMixVolumes,myNestedSamples],
					QuaternaryWashMixTemperature->unflattenListHelper[resolvedQuaternaryWashMixTemperatures,myNestedSamples],
					QuaternaryWashMixTipType->unflattenListHelper[resolvedQuaternaryWashMixTipTypes,myNestedSamples],
					QuaternaryWashMixTipMaterial->unflattenListHelper[resolvedQuaternaryWashMixTipMaterials,myNestedSamples],
					QuaternaryWashMagnetizationTime->unflattenListHelper[resolvedQuaternaryWashMagnetizationTimes,myNestedSamples],
					QuaternaryWashAspirationVolume->unflattenListHelper[resolvedQuaternaryWashAspirationVolumes,myNestedSamples],
          QuaternaryWashAspirationPosition->unflattenListHelper[resolvedQuaternaryWashAspirationPositions,myNestedSamples],
          QuaternaryWashAspirationPositionOffset->unflattenListHelper[resolvedQuaternaryWashAspirationPositionOffsets,myNestedSamples],
					QuaternaryWashCollectionContainer->correctedQuaternaryWashCollectionContainers,
					QuaternaryWashCollectionStorageCondition->unflattenListHelper[correctedQuaternaryWashCollectionStorageConditions,myNestedSamples],
					NumberOfQuaternaryWashes->unflattenListHelper[resolvedNumberOfQuaternaryWashes,myNestedSamples],
					QuaternaryWashAirDry->unflattenListHelper[resolvedQuaternaryWashAirDries,myNestedSamples],
					QuaternaryWashAirDryTime->unflattenListHelper[resolvedQuaternaryWashAirDryTimes,myNestedSamples],
					(* QuinaryWash *)
					QuinaryWash->unflattenListHelper[resolvedQuinaryWashes,myNestedSamples],
					QuinaryWashBuffer->unflattenListHelper[resolvedQuinaryWashBuffers,myNestedSamples],
					QuinaryWashBufferVolume->unflattenListHelper[resolvedQuinaryWashBufferVolumes,myNestedSamples],
					QuinaryWashMix->unflattenListHelper[resolvedQuinaryWashMixes,myNestedSamples],
					QuinaryWashMixType->unflattenListHelper[resolvedQuinaryWashMixTypes,myNestedSamples],
					QuinaryWashMixTime->unflattenListHelper[resolvedQuinaryWashMixTimes,myNestedSamples],
					QuinaryWashMixRate->unflattenListHelper[resolvedQuinaryWashMixRates,myNestedSamples],
					NumberOfQuinaryWashMixes->unflattenListHelper[resolvedNumberOfQuinaryWashMixes,myNestedSamples],
					QuinaryWashMixVolume->unflattenListHelper[resolvedQuinaryWashMixVolumes,myNestedSamples],
					QuinaryWashMixTemperature->unflattenListHelper[resolvedQuinaryWashMixTemperatures,myNestedSamples],
					QuinaryWashMixTipType->unflattenListHelper[resolvedQuinaryWashMixTipTypes,myNestedSamples],
					QuinaryWashMixTipMaterial->unflattenListHelper[resolvedQuinaryWashMixTipMaterials,myNestedSamples],
					QuinaryWashMagnetizationTime->unflattenListHelper[resolvedQuinaryWashMagnetizationTimes,myNestedSamples],
					QuinaryWashAspirationVolume->unflattenListHelper[resolvedQuinaryWashAspirationVolumes,myNestedSamples],
          QuinaryWashAspirationPosition->unflattenListHelper[resolvedQuinaryWashAspirationPositions,myNestedSamples],
          QuinaryWashAspirationPositionOffset->unflattenListHelper[resolvedQuinaryWashAspirationPositionOffsets,myNestedSamples],
					QuinaryWashCollectionContainer->correctedQuinaryWashCollectionContainers,
					QuinaryWashCollectionStorageCondition->unflattenListHelper[correctedQuinaryWashCollectionStorageConditions,myNestedSamples],
					NumberOfQuinaryWashes->unflattenListHelper[resolvedNumberOfQuinaryWashes,myNestedSamples],
					QuinaryWashAirDry->unflattenListHelper[resolvedQuinaryWashAirDries,myNestedSamples],
					QuinaryWashAirDryTime->unflattenListHelper[resolvedQuinaryWashAirDryTimes,myNestedSamples],
					(* SenaryWash *)
					SenaryWash->unflattenListHelper[resolvedSenaryWashes,myNestedSamples],
					SenaryWashBuffer->unflattenListHelper[resolvedSenaryWashBuffers,myNestedSamples],
					SenaryWashBufferVolume->unflattenListHelper[resolvedSenaryWashBufferVolumes,myNestedSamples],
					SenaryWashMix->unflattenListHelper[resolvedSenaryWashMixes,myNestedSamples],
					SenaryWashMixType->unflattenListHelper[resolvedSenaryWashMixTypes,myNestedSamples],
					SenaryWashMixTime->unflattenListHelper[resolvedSenaryWashMixTimes,myNestedSamples],
					SenaryWashMixRate->unflattenListHelper[resolvedSenaryWashMixRates,myNestedSamples],
					NumberOfSenaryWashMixes->unflattenListHelper[resolvedNumberOfSenaryWashMixes,myNestedSamples],
					SenaryWashMixVolume->unflattenListHelper[resolvedSenaryWashMixVolumes,myNestedSamples],
					SenaryWashMixTemperature->unflattenListHelper[resolvedSenaryWashMixTemperatures,myNestedSamples],
					SenaryWashMixTipType->unflattenListHelper[resolvedSenaryWashMixTipTypes,myNestedSamples],
					SenaryWashMixTipMaterial->unflattenListHelper[resolvedSenaryWashMixTipMaterials,myNestedSamples],
					SenaryWashMagnetizationTime->unflattenListHelper[resolvedSenaryWashMagnetizationTimes,myNestedSamples],
					SenaryWashAspirationVolume->unflattenListHelper[resolvedSenaryWashAspirationVolumes,myNestedSamples],
          SenaryWashAspirationPosition->unflattenListHelper[resolvedSenaryWashAspirationPositions,myNestedSamples],
          SenaryWashAspirationPositionOffset->unflattenListHelper[resolvedSenaryWashAspirationPositionOffsets,myNestedSamples],
					SenaryWashCollectionContainer->correctedSenaryWashCollectionContainers,
					SenaryWashCollectionStorageCondition->unflattenListHelper[correctedSenaryWashCollectionStorageConditions,myNestedSamples],
					NumberOfSenaryWashes->unflattenListHelper[resolvedNumberOfSenaryWashes,myNestedSamples],
					SenaryWashAirDry->unflattenListHelper[resolvedSenaryWashAirDries,myNestedSamples],
					SenaryWashAirDryTime->unflattenListHelper[resolvedSenaryWashAirDryTimes,myNestedSamples],
					(* SeptenaryWash *)
					SeptenaryWash->unflattenListHelper[resolvedSeptenaryWashes,myNestedSamples],
					SeptenaryWashBuffer->unflattenListHelper[resolvedSeptenaryWashBuffers,myNestedSamples],
					SeptenaryWashBufferVolume->unflattenListHelper[resolvedSeptenaryWashBufferVolumes,myNestedSamples],
					SeptenaryWashMix->unflattenListHelper[resolvedSeptenaryWashMixes,myNestedSamples],
					SeptenaryWashMixType->unflattenListHelper[resolvedSeptenaryWashMixTypes,myNestedSamples],
					SeptenaryWashMixTime->unflattenListHelper[resolvedSeptenaryWashMixTimes,myNestedSamples],
					SeptenaryWashMixRate->unflattenListHelper[resolvedSeptenaryWashMixRates,myNestedSamples],
					NumberOfSeptenaryWashMixes->unflattenListHelper[resolvedNumberOfSeptenaryWashMixes,myNestedSamples],
					SeptenaryWashMixVolume->unflattenListHelper[resolvedSeptenaryWashMixVolumes,myNestedSamples],
					SeptenaryWashMixTemperature->unflattenListHelper[resolvedSeptenaryWashMixTemperatures,myNestedSamples],
					SeptenaryWashMixTipType->unflattenListHelper[resolvedSeptenaryWashMixTipTypes,myNestedSamples],
					SeptenaryWashMixTipMaterial->unflattenListHelper[resolvedSeptenaryWashMixTipMaterials,myNestedSamples],
					SeptenaryWashMagnetizationTime->unflattenListHelper[resolvedSeptenaryWashMagnetizationTimes,myNestedSamples],
					SeptenaryWashAspirationVolume->unflattenListHelper[resolvedSeptenaryWashAspirationVolumes,myNestedSamples],
          SeptenaryWashAspirationPosition->unflattenListHelper[resolvedSeptenaryWashAspirationPositions,myNestedSamples],
          SeptenaryWashAspirationPositionOffset->unflattenListHelper[resolvedSeptenaryWashAspirationPositionOffsets,myNestedSamples],
					SeptenaryWashCollectionContainer->correctedSeptenaryWashCollectionContainers,
					SeptenaryWashCollectionStorageCondition->unflattenListHelper[correctedSeptenaryWashCollectionStorageConditions,myNestedSamples],
					NumberOfSeptenaryWashes->unflattenListHelper[resolvedNumberOfSeptenaryWashes,myNestedSamples],
					SeptenaryWashAirDry->unflattenListHelper[resolvedSeptenaryWashAirDries,myNestedSamples],
					SeptenaryWashAirDryTime->unflattenListHelper[resolvedSeptenaryWashAirDryTimes,myNestedSamples],
					(* Elution *)
					Elution->unflattenListHelper[resolvedElutions,myNestedSamples],
					ElutionBuffer->unflattenListHelper[resolvedElutionBuffers,myNestedSamples],
					ElutionBufferVolume->unflattenListHelper[resolvedElutionBufferVolumes,myNestedSamples],
					ElutionMix->unflattenListHelper[resolvedElutionMixes,myNestedSamples],
					ElutionMixType->unflattenListHelper[resolvedElutionMixTypes,myNestedSamples],
					ElutionMixTime->unflattenListHelper[resolvedElutionMixTimes,myNestedSamples],
					ElutionMixRate->unflattenListHelper[resolvedElutionMixRates,myNestedSamples],
					NumberOfElutionMixes->unflattenListHelper[resolvedNumberOfElutionMixes,myNestedSamples],
					ElutionMixVolume->unflattenListHelper[resolvedElutionMixVolumes,myNestedSamples],
					ElutionMixTemperature->unflattenListHelper[resolvedElutionMixTemperatures,myNestedSamples],
					ElutionMixTipType->unflattenListHelper[resolvedElutionMixTipTypes,myNestedSamples],
					ElutionMixTipMaterial->unflattenListHelper[resolvedElutionMixTipMaterials,myNestedSamples],
					ElutionMagnetizationTime->unflattenListHelper[resolvedElutionMagnetizationTimes,myNestedSamples],
					ElutionAspirationVolume->unflattenListHelper[resolvedElutionAspirationVolumes,myNestedSamples],
          ElutionAspirationPosition->unflattenListHelper[resolvedElutionAspirationPositions,myNestedSamples],
          ElutionAspirationPositionOffset->unflattenListHelper[resolvedElutionAspirationPositionOffsets,myNestedSamples],
					ElutionCollectionContainer->correctedElutionCollectionContainers,
					ElutionCollectionStorageCondition->unflattenListHelper[correctedElutionCollectionStorageConditions,myNestedSamples],
					NumberOfElutions->unflattenListHelper[resolvedNumberOfElutions,myNestedSamples],
					(* Labels *)
					AssayContainer->unflattenListHelper[resolvedAssayContainers,myNestedSamples],
					SampleLabel->resolvedSampleLabels,
					SampleContainerLabel->resolvedSampleContainerLabels,
					SampleOutLabel->resolvedSampleOutLabels,
					ContainerOutLabel->resolvedContainerOutLabels,
					PreWashCollectionContainerLabel->resolvedPreWashCollectionContainerLabels,
					EquilibrationCollectionContainerLabel->resolvedEquilibrationCollectionContainerLabels,
					LoadingCollectionContainerLabel->resolvedLoadingCollectionContainerLabels,
					WashCollectionContainerLabel->resolvedWashCollectionContainerLabels,
					SecondaryWashCollectionContainerLabel->resolvedSecondaryWashCollectionContainerLabels,
					TertiaryWashCollectionContainerLabel->resolvedTertiaryWashCollectionContainerLabels,
					QuaternaryWashCollectionContainerLabel->resolvedQuaternaryWashCollectionContainerLabels,
					QuinaryWashCollectionContainerLabel->resolvedQuinaryWashCollectionContainerLabels,
					SenaryWashCollectionContainerLabel->resolvedSenaryWashCollectionContainerLabels,
					SeptenaryWashCollectionContainerLabel->resolvedSeptenaryWashCollectionContainerLabels,
					ElutionCollectionContainerLabel->resolvedElutionCollectionContainerLabels,
					(* Hidden options: destination wells and indices *)
					PreWashDestinationWell->resolvedPreWashDestinationWells,
					PreWashCollectionContainerIndex->unflattenListHelper[preWashCollectionContainerIndices,myNestedSamples],
					EquilibrationDestinationWell->resolvedEquilibrationDestinationWells,
					EquilibrationCollectionContainerIndex->unflattenListHelper[equilibrationCollectionContainerIndices,myNestedSamples],
					LoadingDestinationWell->resolvedLoadingDestinationWells,
					LoadingCollectionContainerIndex->unflattenListHelper[loadingCollectionContainerIndices,myNestedSamples],
					WashDestinationWell->resolvedWashDestinationWells,
					WashCollectionContainerIndex->unflattenListHelper[washCollectionContainerIndices,myNestedSamples],
					SecondaryWashDestinationWell->resolvedSecondaryWashDestinationWells,
					SecondaryWashCollectionContainerIndex->unflattenListHelper[secondaryWashCollectionContainerIndices,myNestedSamples],
					TertiaryWashDestinationWell->resolvedTertiaryWashDestinationWells,
					TertiaryWashCollectionContainerIndex->unflattenListHelper[tertiaryWashCollectionContainerIndices,myNestedSamples],
					QuaternaryWashDestinationWell->resolvedQuaternaryWashDestinationWells,
					QuaternaryWashCollectionContainerIndex->unflattenListHelper[quaternaryWashCollectionContainerIndices,myNestedSamples],
					QuinaryWashDestinationWell->resolvedQuinaryWashDestinationWells,
					QuinaryWashCollectionContainerIndex->unflattenListHelper[quinaryWashCollectionContainerIndices,myNestedSamples],
					SenaryWashDestinationWell->resolvedSenaryWashDestinationWells,
					SenaryWashCollectionContainerIndex->unflattenListHelper[senaryWashCollectionContainerIndices,myNestedSamples],
					SeptenaryWashDestinationWell->resolvedSeptenaryWashDestinationWells,
					SeptenaryWashCollectionContainerIndex->unflattenListHelper[septenaryWashCollectionContainerIndices,myNestedSamples],
					ElutionDestinationWell->resolvedElutionDestinationWells,
					ElutionCollectionContainerIndex->unflattenListHelper[elutionCollectionContainerIndices,myNestedSamples],
          UnresolvedMagnetizationRack -> unflattenListHelper[(unresolvedMagnetizationRacks/.ObjectP[{Model[Container, Rack],Object[Container, Rack]}]->Null),myNestedSamples],(*This hidden option is only used to pass information for RSP and RCP, the container rack is not allowed pattern for the accepting field*)

					(*Shared options*)
					resolvedSamplePrepOptions,
					resolvedAliquotOptions,
					resolvedPostProcessingOptions,
					Email->resolvedEmail,
					WorkCell->resolvedWorkCell
				}
			]
		];

		(*Gather the tests*)
		allTests=Cases[Flatten[{
			validProcessingOrderTest,
			samplePrepTests,
			discardedTest,
			solidTest,
			precisionTests,
			validNameTest,
			separationModeMatchTest,

			multipleAnalytesTest,
			multipleTargetsTest,
			multipleTargetTypesTest,
			generalResolvedMagneticBeadsTest,

			numberOfPreWashMismatchTests,
			invalidPreWashMixTypeTests,
			invalidPreWashAirDryWarningTests,
			preWashMismatchTest,
			preWashMixMismatchTest,
			validPreWashMixTipTypeTest,
			validPreWashMixTipTest,
			validPreWashMixInstrumentTest,
			preWashAirDryMismatchTest,
      preWashAspirationPipettingMismatchTests,

			numberOfEquilibrationMismatchTests,
			invalidEquilibrationMixTypeTests,
			invalidEquilibrationAirDryWarningTests,
			equilibrationMismatchTest,
			equilibrationMixMismatchTest,
			validEquilibrationMixTipTypeTest,
			validEquilibrationMixTipTest,
			validEquilibrationMixInstrumentTest,
			equilibrationAirDryMismatchTest,
      equilibrationAspirationPipettingMismatchTests,

			numberOfLoadingMismatchTests,
			invalidLoadingMixTypeTests,
			invalidLoadingAirDryWarningTests,
			loadingMixMismatchTest,
			validLoadingMixTipTypeTest,
			validLoadingMixTipTest,
			validLoadingMixInstrumentTest,
			loadingAirDryMismatchTest,
      loadingAspirationPipettingMismatchTests,

			numberOfWashMismatchTests,
			invalidWashMixTypeTests,
			invalidWashAirDryWarningTests,
			washMismatchTest,
			washMixMismatchTest,
			validWashMixTipTypeTest,
			validWashMixTipTest,
			validWashMixInstrumentTest,
			washAirDryMismatchTest,
      washAspirationPipettingMismatchTests,

			numberOfSecondaryWashMismatchTests,
			invalidSecondaryWashMixTypeTests,
			invalidSecondaryWashAirDryWarningTests,
			secondaryWashMismatchTest,
			secondaryWashMixMismatchTest,
			validSecondaryWashMixTipTypeTest,
			validSecondaryWashMixTipTest,
			validSecondaryWashMixInstrumentTest,
			secondaryWashAirDryMismatchTest,
			validSecondaryWashTest,
      secondaryWashAspirationPipettingMismatchTests,

			numberOfTertiaryWashMismatchTests,
			invalidTertiaryWashMixTypeTests,
			invalidTertiaryWashAirDryWarningTests,
			tertiaryWashMismatchTest,
			tertiaryWashMixMismatchTest,
			validTertiaryWashMixTipTypeTest,
			validTertiaryWashMixTipTest,
			validTertiaryWashMixInstrumentTest,
			tertiaryWashAirDryMismatchTest,
			validTertiaryWashTest,
      tertiaryWashAspirationPipettingMismatchTests,

			numberOfQuaternaryWashMismatchTests,
			invalidQuaternaryWashMixTypeTests,
			invalidQuaternaryWashAirDryWarningTests,
			quaternaryWashMismatchTest,
			quaternaryWashMixMismatchTest,
			validQuaternaryWashMixTipTypeTest,
			validQuaternaryWashMixTipTest,
			validQuaternaryWashMixInstrumentTest,
			quaternaryWashAirDryMismatchTest,
			validQuaternaryWashTest,
      quaternaryWashAspirationPipettingMismatchTests,

			numberOfQuinaryWashMismatchTests,
			invalidQuinaryWashMixTypeTests,
			invalidQuinaryWashAirDryWarningTests,
			quinaryWashMismatchTest,
			quinaryWashMixMismatchTest,
			validQuinaryWashMixTipTypeTest,
			validQuinaryWashMixTipTest,
			validQuinaryWashMixInstrumentTest,
			quinaryWashAirDryMismatchTest,
			validQuinaryWashTest,
      quinaryWashAspirationPipettingMismatchTests,

			numberOfSenaryWashMismatchTests,
			invalidSenaryWashMixTypeTests,
			invalidSenaryWashAirDryWarningTests,
			senaryWashMismatchTest,
			senaryWashMixMismatchTest,
			validSenaryWashMixTipTypeTest,
			validSenaryWashMixTipTest,
			validSenaryWashMixInstrumentTest,
			senaryWashAirDryMismatchTest,
			validSenaryWashTest,
      senaryWashAspirationPipettingMismatchTests,

			numberOfSeptenaryWashMismatchTests,
			invalidSeptenaryWashMixTypeTests,
			invalidSeptenaryWashAirDryWarningTests,
			septenaryWashMismatchTest,
			septenaryWashMixMismatchTest,
			validSeptenaryWashMixTipTypeTest,
			validSeptenaryWashMixTipTest,
			validSeptenaryWashMixInstrumentTest,
			septenaryWashAirDryMismatchTest,
			validSeptenaryWashTest,
      septenaryWashAspirationPipettingMismatchTests,

			numberOfElutionMismatchTests,
			invalidElutionMixTypeTests,
			elutionMismatchTest,
			elutionMixMismatchTest,
			validElutionMixTipTypeTest,
			validElutionMixTipTest,
			validElutionMixInstrumentTest,
      elutionAspirationPipettingMismatchTests,

			aliquotTests,
			preparationTest,
			invalidBufferVolumeTests,
			conflictingCollectionStorageConditionTests,



			invalidDestinationWellsTests,
			noAvailablePositionsInContainerTests,

			parallelMaxOptionTest

		}],_EmeraldTest];

		(*Generate the result output rule: if not returning result, result rule is just Null*)
		resultRule=Result->If[MemberQ[output,Result],
			resolvedOptions,
			Null
		];

		(*Generate the tests output rule*)
		testsRule=Tests->If[gatherTests,
			allTests,
			Null
		];

		(*Return the output as we desire it*)
		outputSpecification/.{resultRule,testsRule}
	];


(* ::Subsubsection::Closed:: *)
(*experimentMagneticBeadSeparationResourcePackets*)


DefineOptions[experimentMagneticBeadSeparationResourcePackets,
	Options:>{
		CacheOption,
		HelperOutputOption,
		SimulationOption
	}
];


experimentMagneticBeadSeparationResourcePackets[
	myNestedSamples:ListableP[{ObjectP[Object[Sample]]..}],
	myUnresolvedOptions:{___Rule},
	myResolvedOptions:{___Rule},
	myOptions:OptionsPattern[experimentMagneticBeadSeparationResourcePackets]
]:=Module[
	{
		unresolvedOptionsNoHidden,resolvedOptionsNoHidden,outputSpecification,output,gatherTests,messages,inheritedCache,inheritedFastAssoc,
		nestedSamplesWithReplicates,resolvedOptionsWithReplicates,flatSamplesWithReplicates,prependReplicateNumber,

		preparation,volumes,magneticBeads,magneticBeadVolumes,magnetizationRacks,unresolvedMagnetizationRacks,sampleLabels,separationMode,selectionStrategy,analyteAffinityLabels,targets,
		sampleContainerLabels,assayContainers,parentProtocol,sampleOutLabels,containerOutLabels, magneticBeadAffinityLabels,numberOfReplicates,

		(* Get needed options *)
		preWashes,preWashBuffers,preWashBufferVolumes,preWashMagnetizationTimes,preWashAspirationVolumes,numberOfPreWashes,
		preWashAirDries,preWashAirDryTimes,preWashMixes,preWashMixTypes,preWashMixTimes,preWashMixRates,numberOfPreWashMixes,
		preWashMixVolumes,preWashMixTemperatures,preWashCollectionContainers,preWashCollectionContainerIndices,preWashCollectionStorageConditions, preWashMixTipTypes,preWashMixTipMaterials,preWashDestinationWells,
		preWashCollectionContainerLabels,

		equilibrations,equilibrationBuffers,equilibrationBufferVolumes,equilibrationMagnetizationTimes,equilibrationAspirationVolumes,
		equilibrationAirDries,equilibrationAirDryTimes,equilibrationMixes,equilibrationMixTypes,equilibrationMixTimes,equilibrationMixRates,numberOfEquilibrationMixes,
		equilibrationMixVolumes,equilibrationMixTemperatures,equilibrationCollectionContainers,equilibrationCollectionContainerIndices,equilibrationCollectionStorageConditions,
		equilibrationMixTipTypes,equilibrationMixTipMaterials,equilibrationDestinationWells,
		equilibrationCollectionContainerLabels,

		loadingMagnetizationTimes,loadingAspirationVolumes,
		loadingAirDries,loadingAirDryTimes,loadingMixes,loadingMixTypes,loadingMixTimes,loadingMixRates,numberOfLoadingMixes,
		loadingMixVolumes,loadingMixTemperatures,loadingCollectionContainers,loadingCollectionContainerIndices,loadingCollectionStorageConditions,loadingMixTipTypes,loadingMixTipMaterials,loadingDestinationWells,
		loadingCollectionContainerLabels,

		washes,washBuffers,washBufferVolumes,washMagnetizationTimes,washAspirationVolumes,numberOfWashes,
		washAirDries,washAirDryTimes,washMixes,washMixTypes,washMixTimes,washMixRates,numberOfWashMixes,
		washMixVolumes,washMixTemperatures,washCollectionContainers,washCollectionContainerIndices,washCollectionStorageConditions,washMixTipTypes, washMixTipMaterials,washDestinationWells,
		washCollectionContainerLabels,

		secondaryWashes,secondaryWashBuffers,secondaryWashBufferVolumes,secondaryWashMagnetizationTimes,secondaryWashAspirationVolumes,numberOfSecondaryWashes,
		secondaryWashAirDries,secondaryWashAirDryTimes,secondaryWashMixes,secondaryWashMixTypes,secondaryWashMixTimes,secondaryWashMixRates,numberOfSecondaryWashMixes,
		secondaryWashMixVolumes,secondaryWashMixTemperatures,secondaryWashCollectionContainers,secondaryWashCollectionContainerIndices,secondaryWashCollectionStorageConditions,secondaryWashMixTipTypes, secondaryWashMixTipMaterials,secondaryWashDestinationWells,
		secondaryWashCollectionContainerLabels,

		tertiaryWashes,tertiaryWashBuffers,tertiaryWashBufferVolumes,tertiaryWashMagnetizationTimes,tertiaryWashAspirationVolumes,numberOfTertiaryWashes,
		tertiaryWashAirDries,tertiaryWashAirDryTimes,tertiaryWashMixes,tertiaryWashMixTypes,tertiaryWashMixTimes,tertiaryWashMixRates,numberOfTertiaryWashMixes,
		tertiaryWashMixVolumes,tertiaryWashMixTemperatures,tertiaryWashCollectionContainers,tertiaryWashCollectionContainerIndices,tertiaryWashCollectionStorageConditions, tertiaryWashMixTipTypes, tertiaryWashMixTipMaterials,tertiaryWashDestinationWells,
		tertiaryWashCollectionContainerLabels,

		quaternaryWashes,quaternaryWashBuffers,quaternaryWashBufferVolumes,quaternaryWashMagnetizationTimes,quaternaryWashAspirationVolumes,numberOfQuaternaryWashes,
		quaternaryWashAirDries,quaternaryWashAirDryTimes,quaternaryWashMixes,quaternaryWashMixTypes,quaternaryWashMixTimes,quaternaryWashMixRates,numberOfQuaternaryWashMixes,
		quaternaryWashMixVolumes,quaternaryWashMixTemperatures,quaternaryWashCollectionContainers,quaternaryWashCollectionContainerIndices,quaternaryWashCollectionStorageConditions,quaternaryWashMixTipTypes, quaternaryWashMixTipMaterials,quaternaryWashDestinationWells,
		quaternaryWashCollectionContainerLabels,

		quinaryWashes,quinaryWashBuffers,quinaryWashBufferVolumes,quinaryWashMagnetizationTimes,quinaryWashAspirationVolumes,numberOfQuinaryWashes,
		quinaryWashAirDries,quinaryWashAirDryTimes,quinaryWashMixes,quinaryWashMixTypes,quinaryWashMixTimes,quinaryWashMixRates,numberOfQuinaryWashMixes,
		quinaryWashMixVolumes,quinaryWashMixTemperatures,quinaryWashCollectionContainers,quinaryWashCollectionContainerIndices,quinaryWashCollectionStorageConditions,quinaryWashMixTipTypes, quinaryWashMixTipMaterials,quinaryWashDestinationWells,
		quinaryWashCollectionContainerLabels,

		senaryWashes,senaryWashBuffers,senaryWashBufferVolumes,senaryWashMagnetizationTimes,senaryWashAspirationVolumes,numberOfSenaryWashes,
		senaryWashAirDries,senaryWashAirDryTimes,senaryWashMixes,senaryWashMixTypes,senaryWashMixTimes,senaryWashMixRates,numberOfSenaryWashMixes,
		senaryWashMixVolumes,senaryWashMixTemperatures,senaryWashCollectionContainers,senaryWashCollectionContainerIndices,senaryWashCollectionStorageConditions, senaryWashMixTipTypes, senaryWashMixTipMaterials,senaryWashDestinationWells,
		senaryWashCollectionContainerLabels,

		septenaryWashes,septenaryWashBuffers,septenaryWashBufferVolumes,septenaryWashMagnetizationTimes,septenaryWashAspirationVolumes,numberOfSeptenaryWashes,
		septenaryWashAirDries,septenaryWashAirDryTimes,septenaryWashMixes,septenaryWashMixTypes,septenaryWashMixTimes,septenaryWashMixRates,numberOfSeptenaryWashMixes,
		septenaryWashMixVolumes,septenaryWashMixTemperatures,septenaryWashCollectionContainers,septenaryWashCollectionContainerIndices,septenaryWashCollectionStorageConditions,septenaryWashMixTipTypes, septenaryWashMixTipMaterials,septenaryWashDestinationWells,
		septenaryWashCollectionContainerLabels,

		elutions,elutionBuffers,elutionBufferVolumes,elutionMagnetizationTimes,elutionAspirationVolumes,numberOfElutions,
		elutionMixes,elutionMixTypes,elutionMixTimes,elutionMixRates,numberOfElutionMixes,
		elutionMixVolumes,elutionMixTemperatures,elutionCollectionContainers,elutionCollectionContainerIndices,elutionCollectionStorageConditions,elutionMixTipTypes,elutionMixTipMaterials,elutionDestinationWells,
		elutionCollectionContainerLabels,

    (*Aspiration pipetting options*)
    preWashAspirationPositions, preWashAspirationPositionOffsets, equilibrationAspirationPositions, equilibrationAspirationPositionOffsets, loadingAspirationPositions, loadingAspirationPositionOffsets, washAspirationPositions, washAspirationPositionOffsets, secondaryWashAspirationPositions, secondaryWashAspirationPositionOffsets, tertiaryWashAspirationPositions, tertiaryWashAspirationPositionOffsets, quaternaryWashAspirationPositions, quaternaryWashAspirationPositionOffsets, quinaryWashAspirationPositions, quinaryWashAspirationPositionOffsets, senaryWashAspirationPositions, senaryWashAspirationPositionOffsets, septenaryWashAspirationPositions, septenaryWashAspirationPositionOffsets, elutionAspirationPositions, elutionAspirationPositionOffsets,


		(* For resource generation *)
		assayContainerLookup,assayContainerMapOutput,assayContainerLabels,assayWells,
		otherResources,uniqueAssayPlateResourceLookup,

		uniqueSampleResourceLookup,uniquePlateResourceLookup,flattenedContainers,flattenedContainerLabels,preWashCollectionContainerResources,equilibrationCollectionContainerResources,loadingCollectionContainerResources,washCollectionContainerResources,secondaryWashCollectionContainerResources,tertiaryWashCollectionContainerResources,quaternaryWashCollectionContainerResources,quinaryWashCollectionContainerResources,senaryWashCollectionContainerResources,septenaryWashCollectionContainerResources,elutionCollectionContainerResources,
		uniqueSamplesInResources, samplesInResources, samplesInResourcesReplacementRules,

		flatPreWashCollectionContainers,flatEquilibrationCollectionContainers,flatLoadingCollectionContainers,flatWashCollectionContainers,flatSecondaryWashCollectionContainers,flatTertiaryWashCollectionContainers,flatQuaternaryWashCollectionContainers,flatQuinaryWashCollectionContainers,flatSenaryWashCollectionContainers,flatSeptenaryWashCollectionContainers,flatElutionCollectionContainers,

		(* after preparation split *)
		protocolPacket,allUnitOperationPackets,currentSimulation,runTime,allResourceBlobs,resourcesOk,resourceTests,
		previewRule,optionsRule,resultRule,testsRule,simulationRule,experimentFunction
	},

	(*Get the collapsed unresolved index-matching options that don't include hidden options*)
	unresolvedOptionsNoHidden=RemoveHiddenOptions[ExperimentMagneticBeadSeparation,myUnresolvedOptions];

	(*Get the collapsed resolved index-matching options that don't include hidden options*)
	resolvedOptionsNoHidden=Quiet[
		CollapseIndexMatchedOptions[
			ExperimentMagneticBeadSeparation,
			RemoveHiddenOptions[ExperimentMagneticBeadSeparation,myResolvedOptions],
			Ignore->myUnresolvedOptions,
			Messages->False
		],
		{Warning::CannotCollapse}
	];

	(*Determine the requested output format of this function*)
	outputSpecification=OptionValue[Output];
	output=ToList[outputSpecification];

	(*Determine if we should keep a running list of tests to return to the user*)
	gatherTests=MemberQ[output,Tests];
	messages=!gatherTests;

	(* get the inherited cache and simulation *)
	{inheritedCache,currentSimulation}=Lookup[SafeOptions[experimentMagneticBeadSeparationResourcePackets,ToList[myOptions]],{Cache,Simulation}];

	(* Create faster version of the cache to improve speed *)
	inheritedFastAssoc=makeFastAssocFromCache[inheritedCache];

	(*Expand index-matched inputs according to NumberOfReplicates*)
	{nestedSamplesWithReplicates,resolvedOptionsWithReplicates}=expandNumberOfReplicates[ExperimentMagneticBeadSeparation,myNestedSamples,myResolvedOptions];

	(*Flatten nestedSamplesWithReplicates*)
	flatSamplesWithReplicates=Flatten[nestedSamplesWithReplicates];

	(*Look up the resolved option values we need*)
	{
		preparation,volumes,magneticBeads,magneticBeadVolumes,magnetizationRacks,unresolvedMagnetizationRacks,separationMode,selectionStrategy,analyteAffinityLabels,targets,
		sampleLabels,sampleContainerLabels,assayContainers,parentProtocol,sampleOutLabels,containerOutLabels, magneticBeadAffinityLabels,numberOfReplicates,

		preWashes,preWashBuffers,preWashBufferVolumes,preWashMagnetizationTimes,preWashAspirationVolumes,numberOfPreWashes,
		preWashAirDries,preWashAirDryTimes,preWashMixes,preWashMixTypes,preWashMixTimes,preWashMixRates,numberOfPreWashMixes,
		preWashMixVolumes,preWashMixTemperatures,preWashCollectionContainers,preWashCollectionContainerIndices,preWashCollectionStorageConditions, preWashMixTipTypes,preWashMixTipMaterials,preWashDestinationWells,
		preWashCollectionContainerLabels,

		equilibrations,equilibrationBuffers,equilibrationBufferVolumes,equilibrationMagnetizationTimes,equilibrationAspirationVolumes,
		equilibrationAirDries,equilibrationAirDryTimes,equilibrationMixes,equilibrationMixTypes,equilibrationMixTimes,equilibrationMixRates,numberOfEquilibrationMixes,
		equilibrationMixVolumes,equilibrationMixTemperatures,equilibrationCollectionContainers,equilibrationCollectionContainerIndices,equilibrationCollectionStorageConditions,
		equilibrationMixTipTypes,equilibrationMixTipMaterials,equilibrationDestinationWells,
		equilibrationCollectionContainerLabels,

		loadingMagnetizationTimes,loadingAspirationVolumes,
		loadingAirDries,loadingAirDryTimes,loadingMixes,loadingMixTypes,loadingMixTimes,loadingMixRates,numberOfLoadingMixes,
		loadingMixVolumes,loadingMixTemperatures,loadingCollectionContainers,loadingCollectionContainerIndices,loadingCollectionStorageConditions,
		loadingMixTipTypes,	loadingMixTipMaterials,loadingDestinationWells,	loadingCollectionContainerLabels,

		washes,washBuffers,washBufferVolumes,washMagnetizationTimes,washAspirationVolumes,numberOfWashes,
		washAirDries,washAirDryTimes,washMixes,washMixTypes,washMixTimes,washMixRates,numberOfWashMixes,
		washMixVolumes,washMixTemperatures,washCollectionContainers,washCollectionContainerIndices,washCollectionStorageConditions,washMixTipTypes,washMixTipMaterials,washDestinationWells,washCollectionContainerLabels,

		secondaryWashes,secondaryWashBuffers,secondaryWashBufferVolumes,secondaryWashMagnetizationTimes,secondaryWashAspirationVolumes,numberOfSecondaryWashes,
		secondaryWashAirDries,secondaryWashAirDryTimes,secondaryWashMixes,secondaryWashMixTypes,secondaryWashMixTimes,secondaryWashMixRates,numberOfSecondaryWashMixes,
		secondaryWashMixVolumes,secondaryWashMixTemperatures,secondaryWashCollectionContainers,secondaryWashCollectionContainerIndices,secondaryWashCollectionStorageConditions,secondaryWashMixTipTypes,secondaryWashMixTipMaterials,secondaryWashDestinationWells,secondaryWashCollectionContainerLabels,

		tertiaryWashes,tertiaryWashBuffers,tertiaryWashBufferVolumes,tertiaryWashMagnetizationTimes,tertiaryWashAspirationVolumes,numberOfTertiaryWashes,
		tertiaryWashAirDries,tertiaryWashAirDryTimes,tertiaryWashMixes,tertiaryWashMixTypes,tertiaryWashMixTimes,tertiaryWashMixRates,numberOfTertiaryWashMixes,
		tertiaryWashMixVolumes,tertiaryWashMixTemperatures,tertiaryWashCollectionContainers,tertiaryWashCollectionContainerIndices,tertiaryWashCollectionStorageConditions,tertiaryWashMixTipTypes,tertiaryWashMixTipMaterials,tertiaryWashDestinationWells,tertiaryWashCollectionContainerLabels,

		quaternaryWashes,quaternaryWashBuffers,quaternaryWashBufferVolumes,quaternaryWashMagnetizationTimes,quaternaryWashAspirationVolumes,numberOfQuaternaryWashes,
		quaternaryWashAirDries,quaternaryWashAirDryTimes,quaternaryWashMixes,quaternaryWashMixTypes,quaternaryWashMixTimes,quaternaryWashMixRates,numberOfQuaternaryWashMixes,
		quaternaryWashMixVolumes,quaternaryWashMixTemperatures,quaternaryWashCollectionContainers,quaternaryWashCollectionContainerIndices,quaternaryWashCollectionStorageConditions,quaternaryWashMixTipTypes,quaternaryWashMixTipMaterials,quaternaryWashDestinationWells,quaternaryWashCollectionContainerLabels,

		quinaryWashes,quinaryWashBuffers,quinaryWashBufferVolumes,quinaryWashMagnetizationTimes,quinaryWashAspirationVolumes,numberOfQuinaryWashes,
		quinaryWashAirDries,quinaryWashAirDryTimes,quinaryWashMixes,quinaryWashMixTypes,quinaryWashMixTimes,quinaryWashMixRates,numberOfQuinaryWashMixes,
		quinaryWashMixVolumes,quinaryWashMixTemperatures,quinaryWashCollectionContainers,quinaryWashCollectionContainerIndices,quinaryWashCollectionStorageConditions,quinaryWashMixTipTypes,quinaryWashMixTipMaterials,quinaryWashDestinationWells,quinaryWashCollectionContainerLabels,

		senaryWashes,senaryWashBuffers,senaryWashBufferVolumes,senaryWashMagnetizationTimes,senaryWashAspirationVolumes,numberOfSenaryWashes,
		senaryWashAirDries,senaryWashAirDryTimes,senaryWashMixes,senaryWashMixTypes,senaryWashMixTimes,senaryWashMixRates,numberOfSenaryWashMixes,
		senaryWashMixVolumes,senaryWashMixTemperatures,senaryWashCollectionContainers,senaryWashCollectionContainerIndices,senaryWashCollectionStorageConditions,senaryWashMixTipTypes,senaryWashMixTipMaterials,senaryWashDestinationWells,senaryWashCollectionContainerLabels,

		septenaryWashes,septenaryWashBuffers,septenaryWashBufferVolumes,septenaryWashMagnetizationTimes,septenaryWashAspirationVolumes,numberOfSeptenaryWashes,
		septenaryWashAirDries,septenaryWashAirDryTimes,septenaryWashMixes,septenaryWashMixTypes,septenaryWashMixTimes,septenaryWashMixRates,numberOfSeptenaryWashMixes,
		septenaryWashMixVolumes,septenaryWashMixTemperatures,septenaryWashCollectionContainers,septenaryWashCollectionContainerIndices,septenaryWashCollectionStorageConditions,septenaryWashMixTipTypes,septenaryWashMixTipMaterials,septenaryWashDestinationWells,septenaryWashCollectionContainerLabels,

		elutions,elutionBuffers,elutionBufferVolumes,elutionMagnetizationTimes,elutionAspirationVolumes,numberOfElutions,
		elutionMixes,elutionMixTypes,elutionMixTimes,elutionMixRates,numberOfElutionMixes,
		elutionMixVolumes,elutionMixTemperatures,elutionCollectionContainers,elutionCollectionContainerIndices,elutionCollectionStorageConditions, elutionMixTipTypes,elutionMixTipMaterials,elutionDestinationWells,	elutionCollectionContainerLabels,

    preWashAspirationPositions, preWashAspirationPositionOffsets, equilibrationAspirationPositions, equilibrationAspirationPositionOffsets, loadingAspirationPositions, loadingAspirationPositionOffsets, washAspirationPositions, washAspirationPositionOffsets, secondaryWashAspirationPositions, secondaryWashAspirationPositionOffsets, tertiaryWashAspirationPositions, tertiaryWashAspirationPositionOffsets, quaternaryWashAspirationPositions, quaternaryWashAspirationPositionOffsets, quinaryWashAspirationPositions, quinaryWashAspirationPositionOffsets, senaryWashAspirationPositions, senaryWashAspirationPositionOffsets, septenaryWashAspirationPositions, septenaryWashAspirationPositionOffsets, elutionAspirationPositions, elutionAspirationPositionOffsets

		}=Lookup[resolvedOptionsWithReplicates,
		{
			Preparation, Volume, MagneticBeads, MagneticBeadVolume, MagnetizationRack, UnresolvedMagnetizationRack, SeparationMode, SelectionStrategy, AnalyteAffinityLabel, Target,
			SampleLabel, SampleContainerLabel, AssayContainer, ParentProtocol, SampleOutLabel, ContainerOutLabel, MagneticBeadAffinityLabel,NumberOfReplicates,

			PreWash, PreWashBuffer, PreWashBufferVolume, PreWashMagnetizationTime, PreWashAspirationVolume, NumberOfPreWashes,
			PreWashAirDry, PreWashAirDryTime, PreWashMix, PreWashMixType, PreWashMixTime, PreWashMixRate, NumberOfPreWashMixes,
			PreWashMixVolume, PreWashMixTemperature, PreWashCollectionContainer, PreWashCollectionContainerIndex, PreWashCollectionStorageCondition, PreWashMixTipType, PreWashMixTipMaterial, PreWashDestinationWell,
			PreWashCollectionContainerLabel,

			Equilibration, EquilibrationBuffer, EquilibrationBufferVolume, EquilibrationMagnetizationTime, EquilibrationAspirationVolume,
			EquilibrationAirDry, EquilibrationAirDryTime, EquilibrationMix, EquilibrationMixType, EquilibrationMixTime, EquilibrationMixRate, NumberOfEquilibrationMixes,
			EquilibrationMixVolume, EquilibrationMixTemperature, EquilibrationCollectionContainer, EquilibrationCollectionContainerIndex, EquilibrationCollectionStorageCondition,
			EquilibrationMixTipType, EquilibrationMixTipMaterial, EquilibrationDestinationWell,
			EquilibrationCollectionContainerLabel,

			LoadingMagnetizationTime, LoadingAspirationVolume,
			LoadingAirDry, LoadingAirDryTime, LoadingMix, LoadingMixType, LoadingMixTime, LoadingMixRate, NumberOfLoadingMixes,
			LoadingMixVolume, LoadingMixTemperature, LoadingCollectionContainer, LoadingCollectionContainerIndex, LoadingCollectionStorageCondition, LoadingMixTipType, LoadingMixTipMaterial, LoadingDestinationWell,
			LoadingCollectionContainerLabel,

			Wash, WashBuffer, WashBufferVolume, WashMagnetizationTime, WashAspirationVolume, NumberOfWashes,
			WashAirDry, WashAirDryTime, WashMix, WashMixType, WashMixTime, WashMixRate, NumberOfWashMixes,
			WashMixVolume, WashMixTemperature, WashCollectionContainer, WashCollectionContainerIndex, WashCollectionStorageCondition, WashMixTipType, WashMixTipMaterial, WashDestinationWell,
			WashCollectionContainerLabel,

			SecondaryWash, SecondaryWashBuffer, SecondaryWashBufferVolume, SecondaryWashMagnetizationTime, SecondaryWashAspirationVolume, NumberOfSecondaryWashes,
			SecondaryWashAirDry, SecondaryWashAirDryTime, SecondaryWashMix, SecondaryWashMixType, SecondaryWashMixTime, SecondaryWashMixRate, NumberOfSecondaryWashMixes,
			SecondaryWashMixVolume, SecondaryWashMixTemperature, SecondaryWashCollectionContainer, SecondaryWashCollectionContainerIndex, SecondaryWashCollectionStorageCondition, SecondaryWashMixTipType, SecondaryWashMixTipMaterial, SecondaryWashDestinationWell,
			SecondaryWashCollectionContainerLabel,

			TertiaryWash, TertiaryWashBuffer, TertiaryWashBufferVolume, TertiaryWashMagnetizationTime, TertiaryWashAspirationVolume, NumberOfTertiaryWashes,
			TertiaryWashAirDry, TertiaryWashAirDryTime, TertiaryWashMix, TertiaryWashMixType, TertiaryWashMixTime, TertiaryWashMixRate, NumberOfTertiaryWashMixes,
			TertiaryWashMixVolume, TertiaryWashMixTemperature, TertiaryWashCollectionContainer, TertiaryWashCollectionContainerIndex, TertiaryWashCollectionStorageCondition, TertiaryWashMixTipType, TertiaryWashMixTipMaterial, TertiaryWashDestinationWell,
			TertiaryWashCollectionContainerLabel,

			QuaternaryWash, QuaternaryWashBuffer, QuaternaryWashBufferVolume, QuaternaryWashMagnetizationTime, QuaternaryWashAspirationVolume, NumberOfQuaternaryWashes,
			QuaternaryWashAirDry, QuaternaryWashAirDryTime, QuaternaryWashMix, QuaternaryWashMixType, QuaternaryWashMixTime, QuaternaryWashMixRate, NumberOfQuaternaryWashMixes,
			QuaternaryWashMixVolume, QuaternaryWashMixTemperature, QuaternaryWashCollectionContainer, QuaternaryWashCollectionContainerIndex, QuaternaryWashCollectionStorageCondition, QuaternaryWashMixTipType, QuaternaryWashMixTipMaterial, QuaternaryWashDestinationWell,
			QuaternaryWashCollectionContainerLabel,

			QuinaryWash, QuinaryWashBuffer, QuinaryWashBufferVolume, QuinaryWashMagnetizationTime, QuinaryWashAspirationVolume, NumberOfQuinaryWashes,
			QuinaryWashAirDry, QuinaryWashAirDryTime, QuinaryWashMix, QuinaryWashMixType, QuinaryWashMixTime, QuinaryWashMixRate, NumberOfQuinaryWashMixes,
			QuinaryWashMixVolume, QuinaryWashMixTemperature, QuinaryWashCollectionContainer, QuinaryWashCollectionContainerIndex, QuinaryWashCollectionStorageCondition, QuinaryWashMixTipType, QuinaryWashMixTipMaterial, QuinaryWashDestinationWell,
			QuinaryWashCollectionContainerLabel,

			SenaryWash, SenaryWashBuffer, SenaryWashBufferVolume, SenaryWashMagnetizationTime, SenaryWashAspirationVolume, NumberOfSenaryWashes,
			SenaryWashAirDry, SenaryWashAirDryTime, SenaryWashMix, SenaryWashMixType, SenaryWashMixTime, SenaryWashMixRate, NumberOfSenaryWashMixes,
			SenaryWashMixVolume, SenaryWashMixTemperature, SenaryWashCollectionContainer, SenaryWashCollectionContainerIndex, SenaryWashCollectionStorageCondition, SenaryWashMixTipType, SenaryWashMixTipMaterial, SenaryWashDestinationWell,
			SenaryWashCollectionContainerLabel,

			SeptenaryWash, SeptenaryWashBuffer, SeptenaryWashBufferVolume, SeptenaryWashMagnetizationTime, SeptenaryWashAspirationVolume, NumberOfSeptenaryWashes,
			SeptenaryWashAirDry, SeptenaryWashAirDryTime, SeptenaryWashMix, SeptenaryWashMixType, SeptenaryWashMixTime, SeptenaryWashMixRate, NumberOfSeptenaryWashMixes,
			SeptenaryWashMixVolume, SeptenaryWashMixTemperature, SeptenaryWashCollectionContainer, SeptenaryWashCollectionContainerIndex, SeptenaryWashCollectionStorageCondition, SeptenaryWashMixTipType, SeptenaryWashMixTipMaterial, SeptenaryWashDestinationWell,
			SeptenaryWashCollectionContainerLabel,

			Elution, ElutionBuffer, ElutionBufferVolume, ElutionMagnetizationTime, ElutionAspirationVolume, NumberOfElutions,
			ElutionMix, ElutionMixType, ElutionMixTime, ElutionMixRate, NumberOfElutionMixes,
			ElutionMixVolume, ElutionMixTemperature, ElutionCollectionContainer, ElutionCollectionContainerIndex, ElutionCollectionStorageCondition, ElutionMixTipType, ElutionMixTipMaterial, ElutionDestinationWell,
			ElutionCollectionContainerLabel,

      PreWashAspirationPosition, PreWashAspirationPositionOffset,
      EquilibrationAspirationPosition, EquilibrationAspirationPositionOffset,
      LoadingAspirationPosition, LoadingAspirationPositionOffset,
      WashAspirationPosition, WashAspirationPositionOffset,
      SecondaryWashAspirationPosition, SecondaryWashAspirationPositionOffset,
      TertiaryWashAspirationPosition, TertiaryWashAspirationPositionOffset,
      QuaternaryWashAspirationPosition, QuaternaryWashAspirationPositionOffset,
      QuinaryWashAspirationPosition, QuinaryWashAspirationPositionOffset,
      SenaryWashAspirationPosition, SenaryWashAspirationPositionOffset,
      SeptenaryWashAspirationPosition, SeptenaryWashAspirationPositionOffset,
      ElutionAspirationPosition, ElutionAspirationPositionOffset
		}
	];

	(* Resolve AssayContainerLabels and Wells *)
	assayContainerLookup=<||>;

	assayContainerMapOutput=Map[
		Function[{assayContainer},
			Module[{availableContainerInfo},

				availableContainerInfo=Lookup[
					assayContainerLookup,
					assayContainer,
					Null
				];

				(* Was there an available container? (Matching object/model and available positions) *)
				If[!NullQ[availableContainerInfo]&&Length[Lookup[availableContainerInfo,AvailablePositions]]>0,

					(* Yes there was an available container *)
					Module[{containerLabel,availablePositions,usedPositions,positionToUse},

						(* Get the info about the object *)
						{containerLabel,availablePositions,usedPositions} = Lookup[availableContainerInfo, {Label,AvailablePositions,UsedPositions}];

						(* If the user specified a destination well, use it otherwise default to the first available position *)
						positionToUse=First[availablePositions];

						(* update the lookup with new container information *)
						assayContainerLookup=AssociateTo[
							assayContainerLookup,
							assayContainer->{
								Label->containerLabel,
								AvailablePositions->Rest[availablePositions],
								UsedPositions->Flatten[{usedPositions,positionToUse}]
							}
						];

						(* return the resolved collection container label and destination well *)
						{containerLabel,positionToUse}
					],

					(* No there was no an available container *)
					Module[{containerLabel,allowedPositions,positionToOccupy,positionsAvailable},

						(* Create a new label for the plate if one is not given *)
						containerLabel=CreateUniqueLabel["MBS assay container"];

						(* get all allowed wells in the container. *)
						allowedPositions=Lookup[fastAssocLookup[inheritedFastAssoc,assayContainer,Positions],Name];

						(* get the positions to use for this sample and positions available after occupying *)
						positionToOccupy=First[allowedPositions];

						(* Remove the new occupied position from the available positions *)
						positionsAvailable=Rest[allowedPositions];

						(* Update the lookup with the new plate information *)
						assayContainerLookup=AssociateTo[assayContainerLookup,
							assayContainer->{Label->containerLabel,AvailablePositions->positionsAvailable,UsedPositions->{positionToOccupy}}
						];

						(* return the resolved collection container label and destination well *)
						{containerLabel,positionToOccupy}
					]
				]
			]
		],
		assayContainers,
		{2}
	];

	assayContainerLabels=assayContainerMapOutput[[All,All,1]];
	assayWells=assayContainerMapOutput[[All,All,2]];

	(* Define helper functions for generating resources for unique samples/containers *)
	(*Generate a resource for each unique sample, returning a lookup table of sample->resource*)
	uniqueSampleResourceLookup[uniqueSamplesAndVolumes_Association]:=KeyValueMap[
		Function[{object,amount},
			Module[{objectRef,containers},
				(* make sure out object is in reference form *)
				objectRef=Download[object,Object];
				(* create resource *)
				If[MatchQ[objectRef,ObjectReferenceP[]]&&MatchQ[amount,VolumeP],
					(*If we need to make a resource, figure out which liquid handler compatible containers can be used for this resource*)
					(
						containers=PreferredContainer[amount,LiquidHandlerCompatible->True,All->True];
						(*Return a resource rule*)
						object->Resource[Sample->object,Amount->amount,Name->ToString[Unique[]],Container->First[containers]]
					),

					(*If we don't need to make a resource, return a rule with the same object*)
					object->object
				]
			]
		],
		uniqueSamplesAndVolumes
	];

	(* Create Resources for SamplesIn *)
	(* Create a lookup of each unique sample to a resource of that sample *)
	uniqueSamplesInResources=(#->Resource[Sample->#, Name->CreateUUID[]]&)/@DeleteDuplicates[Download[flatSamplesWithReplicates, Object]];

	(* Use the lookup to create a flat resource list *)
	samplesInResources=(Download[flatSamplesWithReplicates, Object])/.uniqueSamplesInResources;

	(* Create a resource replace rule lookup for use in the Robotic Case before UploadUnitOperation *)
	samplesInResourcesReplacementRules=(Resource[KeyValuePattern[Sample->#[[1]][Sample]]]->#)&/@samplesInResources;

	(* Convert any format of resolved collection containers to flattened Object or Model of collection containers *)
	flatPreWashCollectionContainers=flattenCollectionContainersOfStage[preWashCollectionContainers];
	flatEquilibrationCollectionContainers=flattenCollectionContainersOfStage[equilibrationCollectionContainers];
	flatLoadingCollectionContainers=flattenCollectionContainersOfStage[loadingCollectionContainers];
	flatWashCollectionContainers=flattenCollectionContainersOfStage[washCollectionContainers];
	flatSecondaryWashCollectionContainers=flattenCollectionContainersOfStage[secondaryWashCollectionContainers];
	flatTertiaryWashCollectionContainers=flattenCollectionContainersOfStage[tertiaryWashCollectionContainers];
	flatQuaternaryWashCollectionContainers=flattenCollectionContainersOfStage[quaternaryWashCollectionContainers];
	flatQuinaryWashCollectionContainers=flattenCollectionContainersOfStage[quinaryWashCollectionContainers];
	flatSenaryWashCollectionContainers=flattenCollectionContainersOfStage[senaryWashCollectionContainers];
	flatSeptenaryWashCollectionContainers=flattenCollectionContainersOfStage[septenaryWashCollectionContainers];
	flatElutionCollectionContainers=flattenCollectionContainersOfStage[elutionCollectionContainers];

	(* Flatten all the containers and labels *)
	flattenedContainers=Flatten@Join[
		flatPreWashCollectionContainers,
		flatEquilibrationCollectionContainers,
		flatLoadingCollectionContainers,
		flatWashCollectionContainers,
		flatSecondaryWashCollectionContainers,
		flatTertiaryWashCollectionContainers,
		flatQuaternaryWashCollectionContainers,
		flatQuinaryWashCollectionContainers,
		flatSenaryWashCollectionContainers,
		flatSeptenaryWashCollectionContainers,
		flatElutionCollectionContainers,
		assayContainers
	];

  (* === Correct labels if needed. === *)
  (* If NumberOfReplicates > 1, correct labels so each replicate uses its own plates *)
  numberOfReplicates=Lookup[resolvedOptionsWithReplicates,NumberOfReplicates];

  {
    preWashCollectionContainerLabels,
    equilibrationCollectionContainerLabels,
    loadingCollectionContainerLabels,
    washCollectionContainerLabels,
    secondaryWashCollectionContainerLabels,
    tertiaryWashCollectionContainerLabels,
    quaternaryWashCollectionContainerLabels,
    quinaryWashCollectionContainerLabels,
    senaryWashCollectionContainerLabels,
    septenaryWashCollectionContainerLabels,
    elutionCollectionContainerLabels,
    sampleOutLabels,
    assayContainerLabels
  }=If[MatchQ[numberOfReplicates,GreaterP[1]],
    Module[{replicateIndices,prependedAssayContainerLabels},
      (* Determine the "replicate indices" based on the number of replicates and number of batches *)
      replicateIndices=Flatten@ConstantArray[Range[numberOfReplicates],Length[myNestedSamples]];

      (* Define helper function to go through the collection container label options and prepend replicate number *)
      (* Note: leave the original samples alone then have Replicate Number 1, Replicate Number 2, etc. *)
      prependReplicateNumber[collectionContainerLabels_]:=MapThread[
        Function[{labelsBatch,index},
          Map[
            Function[{labelRepeats},
              (If[!NullQ[#],If[MatchQ[index,1],#,"Replicate Number " <> ToString[index-1] <> " " <> #], Null])&/@labelRepeats
            ],
            labelsBatch
          ]
        ],
        {collectionContainerLabels,replicateIndices}
      ];

      (* Prepend to assay container labels separately because they have 1 less layer of nesting *)
      prependedAssayContainerLabels=MapThread[
        Function[{assayContainerLabelsBatch,assayWellsBatch,index},
          MapThread[
            Function[{assayContainerLabel, assayWell},
              (If[!NullQ[assayContainerLabel],
                (*We don't want to prepend the label to indicate a different assay container if we are at original sample or we are just aliquoting replicate into another well on the same plate*)
                If[MatchQ[index,1]||!MatchQ[assayWell,"A1"],
                  assayContainerLabel,
                  "Replicate Number " <> ToString[index-1] <> " " <> assayContainerLabel],
                Null
              ])
            ],
            {assayContainerLabelsBatch,assayWellsBatch}
          ]
        ],
        {assayContainerLabels,assayWells,replicateIndices}
      ];

      (* Do Prepend *)
      {
        prependReplicateNumber[preWashCollectionContainerLabels],
        prependReplicateNumber[equilibrationCollectionContainerLabels],
        prependReplicateNumber[loadingCollectionContainerLabels],
        prependReplicateNumber[washCollectionContainerLabels],
        prependReplicateNumber[secondaryWashCollectionContainerLabels],
        prependReplicateNumber[tertiaryWashCollectionContainerLabels],
        prependReplicateNumber[quaternaryWashCollectionContainerLabels],
        prependReplicateNumber[quinaryWashCollectionContainerLabels],
        prependReplicateNumber[senaryWashCollectionContainerLabels],
        prependReplicateNumber[septenaryWashCollectionContainerLabels],
        prependReplicateNumber[elutionCollectionContainerLabels],
        prependReplicateNumber[sampleOutLabels],
        prependedAssayContainerLabels
      }
    ],
    {
      preWashCollectionContainerLabels,
      equilibrationCollectionContainerLabels,
      loadingCollectionContainerLabels,
      washCollectionContainerLabels,
      secondaryWashCollectionContainerLabels,
      tertiaryWashCollectionContainerLabels,
      quaternaryWashCollectionContainerLabels,
      quinaryWashCollectionContainerLabels,
      senaryWashCollectionContainerLabels,
      septenaryWashCollectionContainerLabels,
      elutionCollectionContainerLabels,
      sampleOutLabels,
      assayContainerLabels
    }
  ];

  flattenedContainerLabels=Flatten@Join[
		preWashCollectionContainerLabels,
		equilibrationCollectionContainerLabels,
		loadingCollectionContainerLabels,
		washCollectionContainerLabels,
		secondaryWashCollectionContainerLabels,
		tertiaryWashCollectionContainerLabels,
		quaternaryWashCollectionContainerLabels,
		quinaryWashCollectionContainerLabels,
		senaryWashCollectionContainerLabels,
		septenaryWashCollectionContainerLabels,
		elutionCollectionContainerLabels,
		assayContainerLabels
	];

	(*Generate a resource for each unique plate, returning a lookup table of plate->resource*)
	uniquePlateResourceLookup=<||>;

	{preWashCollectionContainerResources,uniquePlateResourceLookup}=generateCollectionContainerResourcesOfStage[flatPreWashCollectionContainers,Flatten@preWashCollectionContainerIndices,Flatten@preWashCollectionContainerLabels,uniquePlateResourceLookup];

	{equilibrationCollectionContainerResources,uniquePlateResourceLookup}=generateCollectionContainerResourcesOfStage[flatEquilibrationCollectionContainers,Flatten@equilibrationCollectionContainerIndices,Flatten@equilibrationCollectionContainerLabels,uniquePlateResourceLookup];

	{loadingCollectionContainerResources,uniquePlateResourceLookup}=generateCollectionContainerResourcesOfStage[flatLoadingCollectionContainers,Flatten@loadingCollectionContainerIndices,Flatten@loadingCollectionContainerLabels,uniquePlateResourceLookup];

	{washCollectionContainerResources,uniquePlateResourceLookup}=generateCollectionContainerResourcesOfStage[flatWashCollectionContainers,Flatten@washCollectionContainerIndices,Flatten@washCollectionContainerLabels,uniquePlateResourceLookup];

	{secondaryWashCollectionContainerResources,uniquePlateResourceLookup}=generateCollectionContainerResourcesOfStage[flatSecondaryWashCollectionContainers,Flatten@secondaryWashCollectionContainerIndices,Flatten@secondaryWashCollectionContainerLabels,uniquePlateResourceLookup];

	{tertiaryWashCollectionContainerResources,uniquePlateResourceLookup}=generateCollectionContainerResourcesOfStage[flatTertiaryWashCollectionContainers,Flatten@tertiaryWashCollectionContainerIndices,Flatten@tertiaryWashCollectionContainerLabels,uniquePlateResourceLookup];

	{quaternaryWashCollectionContainerResources,uniquePlateResourceLookup}=generateCollectionContainerResourcesOfStage[flatQuaternaryWashCollectionContainers,Flatten@quaternaryWashCollectionContainerIndices,Flatten@quaternaryWashCollectionContainerLabels,uniquePlateResourceLookup];

	{quinaryWashCollectionContainerResources,uniquePlateResourceLookup}=generateCollectionContainerResourcesOfStage[flatQuinaryWashCollectionContainers,Flatten@quinaryWashCollectionContainerIndices,Flatten@quinaryWashCollectionContainerLabels,uniquePlateResourceLookup];

	{senaryWashCollectionContainerResources,uniquePlateResourceLookup}=generateCollectionContainerResourcesOfStage[flatSenaryWashCollectionContainers,Flatten@senaryWashCollectionContainerIndices,Flatten@senaryWashCollectionContainerLabels,uniquePlateResourceLookup];

	{septenaryWashCollectionContainerResources,uniquePlateResourceLookup}=generateCollectionContainerResourcesOfStage[flatSeptenaryWashCollectionContainers,Flatten@septenaryWashCollectionContainerIndices,Flatten@septenaryWashCollectionContainerLabels,uniquePlateResourceLookup];

	{elutionCollectionContainerResources,uniquePlateResourceLookup}=generateCollectionContainerResourcesOfStage[flatElutionCollectionContainers,Flatten@elutionCollectionContainerIndices,Flatten@elutionCollectionContainerLabels,uniquePlateResourceLookup];


	(* --- Create the protocol packet --- *)
	(* make unit operation packets for the UOs we just made here *)
	{protocolPacket, allUnitOperationPackets, currentSimulation, runTime} = If[MatchQ[preparation,Manual],
		Module[
			{
				containersIn,uniqueContainersIn,magneticBeadVolumeRules,uniqueMagneticBeadsAndVolumesAssoc,uniqueAssayPlates,
				preWashBufferVolumeRules,uniquePreWashBuffersAndVolumesAssoc,
				equilibrationBufferVolumeRules,uniqueEquilibrationBuffersAndVolumesAssoc,

				washBufferVolumeRules,uniqueWashBuffersAndVolumesAssoc,
				secondaryWashBufferVolumeRules,uniqueSecondaryWashBuffersAndVolumesAssoc,
				tertiaryWashBufferVolumeRules,uniqueTertiaryWashBuffersAndVolumesAssoc,
				quaternaryWashBufferVolumeRules,uniqueQuaternaryWashBuffersAndVolumesAssoc,
				quinaryWashBufferVolumeRules,uniqueQuinaryWashBuffersAndVolumesAssoc,
				senaryWashBufferVolumeRules,uniqueSenaryWashBuffersAndVolumesAssoc,
				septenaryWashBufferVolumeRules,uniqueSeptenaryWashBuffersAndVolumesAssoc,
				elutionBufferVolumeRules,uniqueElutionBuffersAndVolumesAssoc,
				packet, prepPacket
			},

			(*---Generate all the resources for the experiment---*)

			(*--Download container information--*)
			containersIn=Quiet[
				Download[
					Flatten[myNestedSamples],
					Container[Object],
					Cache->inheritedCache,
					Simulation->currentSimulation
				],
				{Download::FieldDoesntExist}
			];

			(* get the unique container in *)
			uniqueContainersIn=DeleteDuplicates[Flatten[containersIn]];

			(*--Generate MagneticBeads resources--*)


			(*Generate sample volume rules*)
			magneticBeadVolumeRules=Flatten@MapThread[
				Function[{magneticBeadsBatch,magneticBeadsVolumesBatch},
					MapThread[
						Rule,
						{magneticBeadsBatch,magneticBeadsVolumesBatch}
					]
				],
				{magneticBeads,magneticBeadVolumes}
			];

			(*Merge any entries with duplicate keys, totaling the values*)
			uniqueMagneticBeadsAndVolumesAssoc=Merge[magneticBeadVolumeRules,Total];

			(* Get the unique assay plates *)
			uniqueAssayPlates=DeleteDuplicates[
				Cases[assayContainers,ObjectP[Model[Container,Plate]],{2}],
				SameObjectQ
			];

			(*--Generate PreWashBuffer resources--*)

			(*Generate sample volume rules*)
			preWashBufferVolumeRules=Flatten@MapThread[
				Function[{preWashBuffersBatch,preWashBufferVolumesBatch,numberOfPreWashesBatch},
					MapThread[
						#1->1.1*#2*#3&,
						{preWashBuffersBatch,preWashBufferVolumesBatch,numberOfPreWashesBatch}
					]
				],
				{preWashBuffers,preWashBufferVolumes,numberOfPreWashes}
			];

			(*Merge any entries with duplicate keys, totaling the values*)
			uniquePreWashBuffersAndVolumesAssoc=Merge[preWashBufferVolumeRules,Total];

			(*--Generate EquilibrationBuffer resources--*)

			(*Generate sample volume rules*)
			equilibrationBufferVolumeRules=Flatten@MapThread[
				Function[{equilibrationBuffersBatch,equilibrationBufferVolumesBatch},
					MapThread[
						Rule,
						{equilibrationBuffersBatch,equilibrationBufferVolumesBatch}
					]
				],
				{equilibrationBuffers,equilibrationBufferVolumes}
			];

			(*Merge any entries with duplicate keys, totaling the values*)
			uniqueEquilibrationBuffersAndVolumesAssoc=Merge[equilibrationBufferVolumeRules,Total];



			(*--Generate WashBuffer resources--*)

			(*Generate sample volume rules*)
			washBufferVolumeRules=Flatten@MapThread[
				Function[{washBuffersBatch,washBufferVolumesBatch,numberOfWashesBatch},
					MapThread[
						#1->1.1*#2*#3&,
						{washBuffersBatch,washBufferVolumesBatch,numberOfWashesBatch}
					]
				],
				{washBuffers,washBufferVolumes,numberOfWashes}
			];

			(*Merge any entries with duplicate keys, totaling the values*)
			uniqueWashBuffersAndVolumesAssoc=Merge[washBufferVolumeRules,Total];


			(*--Generate SecondaryWashBuffer resources--*)

			(*Generate sample volume rules*)
			secondaryWashBufferVolumeRules=Flatten@MapThread[
				Function[{secondaryWashBuffersBatch,secondaryWashBufferVolumesBatch,numberOfSecondaryWashesBatch},
					MapThread[
						#1->1.1*#2*#3&,
						{secondaryWashBuffersBatch,secondaryWashBufferVolumesBatch,numberOfSecondaryWashesBatch}
					]
				],
				{secondaryWashBuffers,secondaryWashBufferVolumes,numberOfSecondaryWashes}
			];

			(*Merge any entries with duplicate keys, totaling the values*)
			uniqueSecondaryWashBuffersAndVolumesAssoc=Merge[secondaryWashBufferVolumeRules,Total];


			(*--Generate TertiaryWashBuffer resources--*)

			(*Generate sample volume rules*)
			tertiaryWashBufferVolumeRules=Flatten@MapThread[
				Function[{tertiaryWashBuffersBatch,tertiaryWashBufferVolumesBatch,numberOfTertiaryWashesBatch},
					MapThread[
						#1->1.1*#2*#3&,
						{tertiaryWashBuffersBatch,tertiaryWashBufferVolumesBatch,numberOfTertiaryWashesBatch}
					]
				],
				{tertiaryWashBuffers,tertiaryWashBufferVolumes,numberOfTertiaryWashes}
			];

			(*Merge any entries with duplicate keys, totaling the values*)
			uniqueTertiaryWashBuffersAndVolumesAssoc=Merge[tertiaryWashBufferVolumeRules,Total];

			(*--Generate QuaternaryWashBuffer resources--*)

			(*Generate sample volume rules*)
			quaternaryWashBufferVolumeRules=Flatten@MapThread[
				Function[{quaternaryWashBuffersBatch,quaternaryWashBufferVolumesBatch,numberOfQuaternaryWashesBatch},
					MapThread[
						#1->1.1*#2*#3&,
						{quaternaryWashBuffersBatch,quaternaryWashBufferVolumesBatch,numberOfQuaternaryWashesBatch}
					]
				],
				{quaternaryWashBuffers,quaternaryWashBufferVolumes,numberOfQuaternaryWashes}
			];

			(*Merge any entries with duplicate keys, totaling the values*)
			uniqueQuaternaryWashBuffersAndVolumesAssoc=Merge[quaternaryWashBufferVolumeRules,Total];


			(*--Generate QuinaryWashBuffer resources--*)

			(*Generate sample volume rules*)
			quinaryWashBufferVolumeRules=Flatten@MapThread[
				Function[{quinaryWashBuffersBatch,quinaryWashBufferVolumesBatch,numberOfQuinaryWashesBatch},
					MapThread[
						#1->1.1*#2*#3&,
						{quinaryWashBuffersBatch,quinaryWashBufferVolumesBatch,numberOfQuinaryWashesBatch}
					]
				],
				{quinaryWashBuffers,quinaryWashBufferVolumes,numberOfQuinaryWashes}
			];

			(*Merge any entries with duplicate keys, totaling the values*)
			uniqueQuinaryWashBuffersAndVolumesAssoc=Merge[quinaryWashBufferVolumeRules,Total];

			(*--Generate SenaryWashBuffer resources--*)

			(*Generate sample volume rules*)
			senaryWashBufferVolumeRules=Flatten@MapThread[
				Function[{senaryWashBuffersBatch,senaryWashBufferVolumesBatch,numberOfSenaryWashesBatch},
					MapThread[
						#1->1.1*#2*#3&,
						{senaryWashBuffersBatch,senaryWashBufferVolumesBatch,numberOfSenaryWashesBatch}
					]
				],
				{senaryWashBuffers,senaryWashBufferVolumes,numberOfSenaryWashes}
			];

			(*Merge any entries with duplicate keys, totaling the values*)
			uniqueSenaryWashBuffersAndVolumesAssoc=Merge[senaryWashBufferVolumeRules,Total];


			(*--Generate SeptenaryWashBuffer resources--*)

			(*Generate sample volume rules*)
			septenaryWashBufferVolumeRules=Flatten@MapThread[
				Function[{septenaryWashBuffersBatch,septenaryWashBufferVolumesBatch,numberOfSeptenaryWashesBatch},
					MapThread[
						#1->1.1*#2*#3&,
						{septenaryWashBuffersBatch,septenaryWashBufferVolumesBatch,numberOfSeptenaryWashesBatch}
					]
				],
				{septenaryWashBuffers,septenaryWashBufferVolumes,numberOfSeptenaryWashes}
			];

			(*Merge any entries with duplicate keys, totaling the values*)
			uniqueSeptenaryWashBuffersAndVolumesAssoc=Merge[septenaryWashBufferVolumeRules,Total];


			(*--Generate ElutionBuffer resources--*)

			(*Generate sample volume rules*)
			elutionBufferVolumeRules=Flatten@MapThread[
				Function[{elutionBuffersBatch,elutionBufferVolumesBatch,numberOfElutionsBatch},
					MapThread[
						#1->1.1*#2*#3&,
						{elutionBuffersBatch,elutionBufferVolumesBatch,numberOfElutionsBatch}
					]
				],
				{elutionBuffers,elutionBufferVolumes,numberOfElutions}
			];

			(*Merge any entries with duplicate keys, totaling the values*)
			uniqueElutionBuffersAndVolumesAssoc=Merge[elutionBufferVolumeRules,Total];

			(*Generate a resource for each unique plate, returning a lookup table of plate->resource*)
			uniqueAssayPlateResourceLookup[uniquePlates_List]:=Map[
				#->Resource[Sample->#,Name->ToString[Unique[]]]&,
				Download[uniquePlates,Object]
			];

			(* Create our ExperimentMBS protocol packet *)
			packet = <|
				(* === Organizational Information === *)
				Object->CreateID[Object[Protocol,MagneticBeadSeparation]],
				Type->Object[Protocol,MagneticBeadSeparation],
				Replace[SamplesIn]->Map[Link[#,Protocols]&,samplesInResources],
				Replace[ContainersIn]->Map[Link[Resource[Sample->#],Protocols]&,uniqueContainersIn],
				Author-> If[MatchQ[parentProtocol,Null],
					Link[$PersonID,ProtocolsAuthored]
				],
				ParentProtocol-> If[MatchQ[parentProtocol,ObjectP[ProtocolTypes[]]],
					Link[parentProtocol,Subprotocols]
				],
				Name->Lookup[myResolvedOptions,Name],

				(* === Options Handling === *)
				UnresolvedOptions->RemoveHiddenOptions[ExperimentMagneticBeadSeparation,myUnresolvedOptions],
				ResolvedOptions->myResolvedOptions,

				(* === Method Information === *)
				Replace[NestedIndexMatchingSamplesIn]->nestedSamplesWithReplicates,
				SelectionStrategy -> Lookup[resolvedOptionsWithReplicates,SelectionStrategy],
				SeparationMode -> Lookup[resolvedOptionsWithReplicates,SeparationMode],
				ProcessingOrder -> Lookup[resolvedOptionsWithReplicates,ProcessingOrder],
				Replace[Volumes]->Flatten@volumes,
				Replace[AnalyteAffinityLabels]->Map[Link[#]&,Flatten[Lookup[resolvedOptionsWithReplicates,AnalyteAffinityLabel]]],
				Replace[Targets]->Map[Link[#]&,Flatten[Lookup[resolvedOptionsWithReplicates,Target]]],
				Replace[MagneticBeadAffinityLabels]->Map[Link[#]&,Flatten[Lookup[resolvedOptionsWithReplicates,MagneticBeadAffinityLabel]]],
				Replace[MagneticBeads]->Flatten@Map[Link[#]&,Replace[magneticBeads,uniqueSampleResourceLookup[uniqueMagneticBeadsAndVolumesAssoc],{2}],{2}],
				Replace[MagneticBeadVolumes]->Flatten@Lookup[resolvedOptionsWithReplicates,MagneticBeadVolume],
				Replace[MagnetizationRacks]->Map[Link[#]&,Flatten[magnetizationRacks]],
				Replace[AssayContainers]->Flatten@Map[
					If[MatchQ[#,ObjectP[]],
						(*vessels*)
						Link[Resource[Sample->#,Name->ToString[Unique[]]]],
						(*plates*)
						Link[#]
					]&,
					Replace[assayContainers,uniqueAssayPlateResourceLookup[uniqueAssayPlates],{2}],
					{2}
				],
				Replace[AssayWells]->Flatten[assayWells],
				Replace[BatchLengths]->Length/@nestedSamplesWithReplicates,

				(* === Resources === *)
				Replace[Checkpoints]->{
					{"Preparing Samples",45 Minute,"Preprocessing, such as incubation, mixing, centrifuging, and aliquoting, is performed.",Link[Resource[Operator->Model[User,Emerald,Operator,"Level 1"],Time->45 Minute]]},
					{"Picking Resources",45 Minute,"Samples required to execute this protocol are gathered from storage.",Link[Resource[Operator->Model[User,Emerald,Operator,"Level 1"],Time->45 Minute]]},
					{"Performing Separations",3 Hour,"Targets are isolated using magnetic beads.",Link[Resource[Operator->Model[User,Emerald,Operator,"Level 1"],Time->3 Hour]]},
					{"Returning Materials",1 Hour,"Samples are returned to storage.",Link[Resource[Operator->Model[User,Emerald,Operator,"Level 1"],Time->1 Hour]]}
				},

				(*===Sample Storage===*)
				Replace[MagneticBeadCollectionStorageConditions]->Flatten@Lookup[resolvedOptionsWithReplicates,MagneticBeadCollectionStorageCondition],
				Replace[PreWashCollectionStorageConditions]->Flatten@Lookup[resolvedOptionsWithReplicates,PreWashCollectionStorageCondition],
				Replace[EquilibrationCollectionStorageConditions]->Flatten@Lookup[resolvedOptionsWithReplicates,EquilibrationCollectionStorageCondition],
				Replace[LoadingCollectionStorageConditions]->Flatten@Lookup[resolvedOptionsWithReplicates,LoadingCollectionStorageCondition],
				Replace[WashCollectionStorageConditions]->Flatten@Lookup[resolvedOptionsWithReplicates,WashCollectionStorageCondition],
				Replace[SecondaryWashCollectionStorageConditions]->Flatten@Lookup[resolvedOptionsWithReplicates,SecondaryWashCollectionStorageCondition],
				Replace[TertiaryWashCollectionStorageConditions]->Flatten@Lookup[resolvedOptionsWithReplicates,TertiaryWashCollectionStorageCondition],
				Replace[QuaternaryWashCollectionStorageConditions]->Flatten@Lookup[resolvedOptionsWithReplicates,QuaternaryWashCollectionStorageCondition],
				Replace[QuinaryWashCollectionStorageConditions]->Flatten@Lookup[resolvedOptionsWithReplicates,QuinaryWashCollectionStorageCondition],
				Replace[SenaryWashCollectionStorageConditions]->Flatten@Lookup[resolvedOptionsWithReplicates,SenaryWashCollectionStorageCondition],
				Replace[SeptenaryWashCollectionStorageConditions]->Flatten@Lookup[resolvedOptionsWithReplicates,SeptenaryWashCollectionStorageCondition],
				Replace[ElutionCollectionStorageConditions]->Flatten@Lookup[resolvedOptionsWithReplicates,ElutionCollectionStorageCondition],

				(* === Pre-Wash === *)
				Replace[PreWashes]->Flatten@Lookup[resolvedOptionsWithReplicates,PreWash],
				Replace[PreWashBuffers]->Flatten@Map[Link[#]&,Replace[preWashBuffers,uniqueSampleResourceLookup[uniquePreWashBuffersAndVolumesAssoc],{2}],{2}],
				Replace[PreWashBufferVolumes]->Flatten@Lookup[resolvedOptionsWithReplicates,PreWashBufferVolume],
				Replace[PreWashMagnetizationTimes]->Flatten@Lookup[resolvedOptionsWithReplicates,PreWashMagnetizationTime],
				Replace[PreWashAspirationVolumes]->Flatten@MapThread[
					Function[{preWashAspirationVolumesBatch,preWashBufferVolumesBatch},
						MapThread[
							If[MatchQ[#1,All],#2,#1]&,
							{preWashAspirationVolumesBatch,preWashBufferVolumesBatch}
						]
					],
					{Lookup[resolvedOptionsWithReplicates,PreWashAspirationVolume],Lookup[resolvedOptionsWithReplicates,PreWashBufferVolume]}
				],
				Replace[NumberOfPreWashes]->Flatten@Lookup[resolvedOptionsWithReplicates,NumberOfPreWashes],
				Replace[PreWashAirDries]->Flatten@Lookup[resolvedOptionsWithReplicates,PreWashAirDry],
				Replace[PreWashAirDryTimes]->Flatten@Lookup[resolvedOptionsWithReplicates,PreWashAirDryTime],
				Replace[PreWashMixes]->Flatten@Lookup[resolvedOptionsWithReplicates,PreWashMix],
				Replace[PreWashMixTypes]->Flatten@Lookup[resolvedOptionsWithReplicates,PreWashMixType],
				Replace[PreWashMixTimes]->Flatten@Lookup[resolvedOptionsWithReplicates,PreWashMixTime],
				Replace[PreWashMixRates]->Flatten@Lookup[resolvedOptionsWithReplicates,PreWashMixRate],
				Replace[NumberOfPreWashMixes]->Flatten@Lookup[resolvedOptionsWithReplicates,NumberOfPreWashMixes],
				Replace[PreWashMixVolumes]->Flatten@Lookup[resolvedOptionsWithReplicates,PreWashMixVolume],
				Replace[PreWashMixTemperatures]->Flatten@Lookup[resolvedOptionsWithReplicates,PreWashMixTemperature]/.{Ambient->$AmbientTemperature},
				Replace[PreWashCollectionContainers]->Flatten@Map[Link[#]&,preWashCollectionContainerResources],
				Replace[PreWashDestinationWells]->Flatten@Lookup[resolvedOptionsWithReplicates,PreWashDestinationWell],
				Replace[PreWashCollectionStorageConditions]->Flatten@Lookup[resolvedOptionsWithReplicates,PreWashCollectionStorageCondition],
				Replace[PreWashMixTipTypes]->Flatten@Lookup[resolvedOptionsWithReplicates,PreWashMixTipType],
				Replace[PreWashMixTipMaterials]->Flatten@Lookup[resolvedOptionsWithReplicates,PreWashMixTipMaterial],

				(* === Equilibration === *)
				Replace[Equilibrations]->Flatten@Lookup[resolvedOptionsWithReplicates,Equilibration],
				Replace[EquilibrationBuffers]->Flatten@Map[Link[#]&,Replace[equilibrationBuffers,uniqueSampleResourceLookup[uniqueEquilibrationBuffersAndVolumesAssoc],{2}],{2}],
				Replace[EquilibrationBufferVolumes]->Flatten@Lookup[resolvedOptionsWithReplicates,EquilibrationBufferVolume],
				Replace[EquilibrationMagnetizationTimes]->Flatten@Lookup[resolvedOptionsWithReplicates,EquilibrationMagnetizationTime],
				Replace[EquilibrationAspirationVolumes]->Flatten@MapThread[
					Function[{equilibrationAspirationVolumesBatch,equilibrationBufferVolumesBatch},
						MapThread[
							If[MatchQ[#1,All],#2,#1]&,
							{equilibrationAspirationVolumesBatch,equilibrationBufferVolumesBatch}
						]
					],
					{Lookup[resolvedOptionsWithReplicates,EquilibrationAspirationVolume],Lookup[resolvedOptionsWithReplicates,EquilibrationBufferVolume]}
				],
				Replace[EquilibrationAirDries]->Flatten@Lookup[resolvedOptionsWithReplicates,EquilibrationAirDry],
				Replace[EquilibrationAirDryTimes]->Flatten@Lookup[resolvedOptionsWithReplicates,EquilibrationAirDryTime],
				Replace[EquilibrationMixes]->Flatten@Lookup[resolvedOptionsWithReplicates,EquilibrationMix],
				Replace[EquilibrationMixTypes]->Flatten@Lookup[resolvedOptionsWithReplicates,EquilibrationMixType],
				Replace[EquilibrationMixTimes]->Flatten@Lookup[resolvedOptionsWithReplicates,EquilibrationMixTime],
				Replace[EquilibrationMixRates]->Flatten@Lookup[resolvedOptionsWithReplicates,EquilibrationMixRate],
				Replace[NumberOfEquilibrationMixes]->Flatten@Lookup[resolvedOptionsWithReplicates,NumberOfEquilibrationMixes],
				Replace[EquilibrationMixVolumes]->Flatten@Lookup[resolvedOptionsWithReplicates,EquilibrationMixVolume],
				Replace[EquilibrationMixTemperatures]->Flatten@Lookup[resolvedOptionsWithReplicates,EquilibrationMixTemperature]/.{Ambient->$AmbientTemperature},
				Replace[EquilibrationCollectionContainers]->Flatten@Map[Link[#]&,equilibrationCollectionContainerResources],
				Replace[EquilibrationDestinationWells]->Flatten@Lookup[resolvedOptionsWithReplicates,EquilibrationDestinationWell],
				Replace[EquilibrationCollectionStorageConditions]->Flatten@Lookup[resolvedOptionsWithReplicates,EquilibrationCollectionStorageCondition],
				Replace[EquilibrationMixTipTypes]->Flatten@Lookup[resolvedOptionsWithReplicates,EquilibrationMixTipType],
				Replace[EquilibrationMixTipMaterials]->Flatten@Lookup[resolvedOptionsWithReplicates,EquilibrationMixTipMaterial],

				(* === Loading === *)
				Replace[LoadingMagnetizationTimes]->Flatten@Lookup[resolvedOptionsWithReplicates,LoadingMagnetizationTime],
				Replace[LoadingAspirationVolumes]->Flatten@MapThread[
					Function[{loadingAspirationVolumesBatch,loadingBufferVolumesBatch},
						MapThread[
							If[MatchQ[#1,All],#2,#1]&,
							{loadingAspirationVolumesBatch,loadingBufferVolumesBatch}
						]
					],
					{Lookup[resolvedOptionsWithReplicates,LoadingAspirationVolume],Lookup[resolvedOptionsWithReplicates,Volume]}
				],
				Replace[LoadingAirDries]->Flatten@Lookup[resolvedOptionsWithReplicates,LoadingAirDry],
				Replace[LoadingAirDryTimes]->Flatten@Lookup[resolvedOptionsWithReplicates,LoadingAirDryTime],
				Replace[LoadingMixes]->Flatten@Lookup[resolvedOptionsWithReplicates,LoadingMix],
				Replace[LoadingMixTypes]->Flatten@Lookup[resolvedOptionsWithReplicates,LoadingMixType],
				Replace[LoadingMixTimes]->Flatten@Lookup[resolvedOptionsWithReplicates,LoadingMixTime],
				Replace[LoadingMixRates]->Flatten@Lookup[resolvedOptionsWithReplicates,LoadingMixRate],
				Replace[NumberOfLoadingMixes]->Flatten@Lookup[resolvedOptionsWithReplicates,NumberOfLoadingMixes],
				Replace[LoadingMixVolumes]->Flatten@Lookup[resolvedOptionsWithReplicates,LoadingMixVolume],
				Replace[LoadingMixTemperatures]->Flatten@Lookup[resolvedOptionsWithReplicates,LoadingMixTemperature]/.{Ambient->$AmbientTemperature},
				Replace[LoadingCollectionContainers]->Flatten@Map[Link[#]&,loadingCollectionContainerResources],
				Replace[LoadingDestinationWells]->Flatten@Lookup[resolvedOptionsWithReplicates,LoadingDestinationWell],
				Replace[LoadingCollectionStorageConditions]->Flatten@Lookup[resolvedOptionsWithReplicates,LoadingCollectionStorageCondition],
				Replace[LoadingMixTipTypes]->Flatten@Lookup[resolvedOptionsWithReplicates,LoadingMixTipType],
				Replace[LoadingMixTipMaterials]->Flatten@Lookup[resolvedOptionsWithReplicates,LoadingMixTipMaterial],

				(* === Wash === *)
				Replace[Washes]->Flatten@Lookup[resolvedOptionsWithReplicates,Wash],
				Replace[WashBuffers]->Flatten@Map[Link[#]&,Replace[washBuffers,uniqueSampleResourceLookup[uniqueWashBuffersAndVolumesAssoc],{2}],{2}],
				Replace[WashBufferVolumes]->Flatten@Lookup[resolvedOptionsWithReplicates,WashBufferVolume],
				Replace[WashMagnetizationTimes]->Flatten@Lookup[resolvedOptionsWithReplicates,WashMagnetizationTime],
				Replace[WashAspirationVolumes]->Flatten@MapThread[
					Function[{washAspirationVolumesBatch,washBufferVolumesBatch},
						MapThread[
							If[MatchQ[#1,All],#2,#1]&,
							{washAspirationVolumesBatch,washBufferVolumesBatch}
						]
					],
					{Lookup[resolvedOptionsWithReplicates,WashAspirationVolume],Lookup[resolvedOptionsWithReplicates,WashBufferVolume]}
				],
				Replace[NumberOfWashes]->Flatten@Lookup[resolvedOptionsWithReplicates,NumberOfWashes],
				Replace[WashAirDries]->Flatten@Lookup[resolvedOptionsWithReplicates,WashAirDry],
				Replace[WashAirDryTimes]->Flatten@Lookup[resolvedOptionsWithReplicates,WashAirDryTime],
				Replace[WashMixes]->Flatten@Lookup[resolvedOptionsWithReplicates,WashMix],
				Replace[WashMixTypes]->Flatten@Lookup[resolvedOptionsWithReplicates,WashMixType],
				Replace[WashMixTimes]->Flatten@Lookup[resolvedOptionsWithReplicates,WashMixTime],
				Replace[WashMixRates]->Flatten@Lookup[resolvedOptionsWithReplicates,WashMixRate],
				Replace[NumberOfWashMixes]->Flatten@Lookup[resolvedOptionsWithReplicates,NumberOfWashMixes],
				Replace[WashMixVolumes]->Flatten@Lookup[resolvedOptionsWithReplicates,WashMixVolume],
				Replace[WashMixTemperatures]->Flatten@Lookup[resolvedOptionsWithReplicates,WashMixTemperature]/.{Ambient->$AmbientTemperature},
				Replace[WashCollectionContainers]->Flatten@Map[Link[#]&,washCollectionContainerResources],
				Replace[WashDestinationWells]->Flatten@Lookup[resolvedOptionsWithReplicates,WashDestinationWell],
				Replace[WashCollectionStorageConditions]->Flatten@Lookup[resolvedOptionsWithReplicates,WashCollectionStorageCondition],
				Replace[WashMixTipTypes]->Flatten@Lookup[resolvedOptionsWithReplicates,WashMixTipType],
				Replace[WashMixTipMaterials]->Flatten@Lookup[resolvedOptionsWithReplicates,WashMixTipMaterial],

				(* === SecondaryWash === *)
				Replace[SecondaryWashes]->Flatten@Lookup[resolvedOptionsWithReplicates,SecondaryWash],
				Replace[SecondaryWashBuffers]->Flatten@Map[Link[#]&,Replace[secondaryWashBuffers,uniqueSampleResourceLookup[uniqueSecondaryWashBuffersAndVolumesAssoc],{2}],{2}],
				Replace[SecondaryWashBufferVolumes]->Flatten@Lookup[resolvedOptionsWithReplicates,SecondaryWashBufferVolume],
				Replace[SecondaryWashMagnetizationTimes]->Flatten@Lookup[resolvedOptionsWithReplicates,SecondaryWashMagnetizationTime],
				Replace[SecondaryWashAspirationVolumes]->Flatten@MapThread[
					Function[{secondaryWashAspirationVolumesBatch,secondaryWashBufferVolumesBatch},
						MapThread[
							If[MatchQ[#1,All],#2,#1]&,
							{secondaryWashAspirationVolumesBatch,secondaryWashBufferVolumesBatch}
						]
					],
					{Lookup[resolvedOptionsWithReplicates,SecondaryWashAspirationVolume],Lookup[resolvedOptionsWithReplicates,SecondaryWashBufferVolume]}
				],
				Replace[NumberOfSecondaryWashes]->Flatten@Lookup[resolvedOptionsWithReplicates,NumberOfSecondaryWashes],
				Replace[SecondaryWashAirDries]->Flatten@Lookup[resolvedOptionsWithReplicates,SecondaryWashAirDry],
				Replace[SecondaryWashAirDryTimes]->Flatten@Lookup[resolvedOptionsWithReplicates,SecondaryWashAirDryTime],
				Replace[SecondaryWashMixes]->Flatten@Lookup[resolvedOptionsWithReplicates,SecondaryWashMix],
				Replace[SecondaryWashMixTypes]->Flatten@Lookup[resolvedOptionsWithReplicates,SecondaryWashMixType],
				Replace[SecondaryWashMixTimes]->Flatten@Lookup[resolvedOptionsWithReplicates,SecondaryWashMixTime],
				Replace[SecondaryWashMixRates]->Flatten@Lookup[resolvedOptionsWithReplicates,SecondaryWashMixRate],
				Replace[NumberOfSecondaryWashMixes]->Flatten@Lookup[resolvedOptionsWithReplicates,NumberOfSecondaryWashMixes],
				Replace[SecondaryWashMixVolumes]->Flatten@Lookup[resolvedOptionsWithReplicates,SecondaryWashMixVolume],
				Replace[SecondaryWashMixTemperatures]->Flatten@Lookup[resolvedOptionsWithReplicates,SecondaryWashMixTemperature]/.{Ambient->$AmbientTemperature},
				Replace[SecondaryWashCollectionContainers]->Flatten@Map[Link[#]&,secondaryWashCollectionContainerResources],
				Replace[SecondaryWashDestinationWells]->Flatten@Lookup[resolvedOptionsWithReplicates,SecondaryWashDestinationWell],
				Replace[SecondaryWashCollectionStorageConditions]->Flatten@Lookup[resolvedOptionsWithReplicates,SecondaryWashCollectionStorageCondition],
				Replace[SecondaryWashMixTipTypes]->Flatten@Lookup[resolvedOptionsWithReplicates,SecondaryWashMixTipType],
				Replace[SecondaryWashMixTipMaterials]->Flatten@Lookup[resolvedOptionsWithReplicates,SecondaryWashMixTipMaterial],

				(* === TertiaryWash === *)
				Replace[TertiaryWashes]->Flatten@Lookup[resolvedOptionsWithReplicates,TertiaryWash],
				Replace[TertiaryWashBuffers]->Flatten@Map[Link[#]&,Replace[tertiaryWashBuffers,uniqueSampleResourceLookup[uniqueTertiaryWashBuffersAndVolumesAssoc],{2}],{2}],
				Replace[TertiaryWashBufferVolumes]->Flatten@Lookup[resolvedOptionsWithReplicates,TertiaryWashBufferVolume],
				Replace[TertiaryWashMagnetizationTimes]->Flatten@Lookup[resolvedOptionsWithReplicates,TertiaryWashMagnetizationTime],
				Replace[TertiaryWashAspirationVolumes]->Flatten@MapThread[
					Function[{tertiaryWashAspirationVolumesBatch,tertiaryWashBufferVolumesBatch},
						MapThread[
							If[MatchQ[#1,All],#2,#1]&,
							{tertiaryWashAspirationVolumesBatch,tertiaryWashBufferVolumesBatch}
						]
					],
					{Lookup[resolvedOptionsWithReplicates,TertiaryWashAspirationVolume],Lookup[resolvedOptionsWithReplicates,TertiaryWashBufferVolume]}
				],
				Replace[NumberOfTertiaryWashes]->Flatten@Lookup[resolvedOptionsWithReplicates,NumberOfTertiaryWashes],
				Replace[TertiaryWashAirDries]->Flatten@Lookup[resolvedOptionsWithReplicates,TertiaryWashAirDry],
				Replace[TertiaryWashAirDryTimes]->Flatten@Lookup[resolvedOptionsWithReplicates,TertiaryWashAirDryTime],
				Replace[TertiaryWashMixes]->Flatten@Lookup[resolvedOptionsWithReplicates,TertiaryWashMix],
				Replace[TertiaryWashMixTypes]->Flatten@Lookup[resolvedOptionsWithReplicates,TertiaryWashMixType],
				Replace[TertiaryWashMixTimes]->Flatten@Lookup[resolvedOptionsWithReplicates,TertiaryWashMixTime],
				Replace[TertiaryWashMixRates]->Flatten@Lookup[resolvedOptionsWithReplicates,TertiaryWashMixRate],
				Replace[NumberOfTertiaryWashMixes]->Flatten@Lookup[resolvedOptionsWithReplicates,NumberOfTertiaryWashMixes],
				Replace[TertiaryWashMixVolumes]->Flatten@Lookup[resolvedOptionsWithReplicates,TertiaryWashMixVolume],
				Replace[TertiaryWashMixTemperatures]->Flatten@Lookup[resolvedOptionsWithReplicates,TertiaryWashMixTemperature]/.{Ambient->$AmbientTemperature},
				Replace[TertiaryWashCollectionContainers]->Flatten@Map[Link[#]&,tertiaryWashCollectionContainerResources],
				Replace[TertiaryWashDestinationWells]->Flatten@Lookup[resolvedOptionsWithReplicates,TertiaryWashDestinationWell],
				Replace[TertiaryWashCollectionStorageConditions]->Flatten@Lookup[resolvedOptionsWithReplicates,TertiaryWashCollectionStorageCondition],
				Replace[TertiaryWashMixTipTypes]->Flatten@Lookup[resolvedOptionsWithReplicates,TertiaryWashMixTipType],
				Replace[TertiaryWashMixTipMaterials]->Flatten@Lookup[resolvedOptionsWithReplicates,TertiaryWashMixTipMaterial],

				(* === QuaternaryWash === *)
				Replace[QuaternaryWashes]->Flatten@Lookup[resolvedOptionsWithReplicates,QuaternaryWash],
				Replace[QuaternaryWashBuffers]->Flatten@Map[Link[#]&,Replace[quaternaryWashBuffers,uniqueSampleResourceLookup[uniqueQuaternaryWashBuffersAndVolumesAssoc],{2}],{2}],
				Replace[QuaternaryWashBufferVolumes]->Flatten@Lookup[resolvedOptionsWithReplicates,QuaternaryWashBufferVolume],
				Replace[QuaternaryWashMagnetizationTimes]->Flatten@Lookup[resolvedOptionsWithReplicates,QuaternaryWashMagnetizationTime],
				Replace[QuaternaryWashAspirationVolumes]->Flatten@MapThread[
					Function[{quaternaryWashAspirationVolumesBatch,quaternaryWashBufferVolumesBatch},
						MapThread[
							If[MatchQ[#1,All],#2,#1]&,
							{quaternaryWashAspirationVolumesBatch,quaternaryWashBufferVolumesBatch}
						]
					],
					{Lookup[resolvedOptionsWithReplicates,QuaternaryWashAspirationVolume],Lookup[resolvedOptionsWithReplicates,QuaternaryWashBufferVolume]}
				],
				Replace[NumberOfQuaternaryWashes]->Flatten@Lookup[resolvedOptionsWithReplicates,NumberOfQuaternaryWashes],
				Replace[QuaternaryWashAirDries]->Flatten@Lookup[resolvedOptionsWithReplicates,QuaternaryWashAirDry],
				Replace[QuaternaryWashAirDryTimes]->Flatten@Lookup[resolvedOptionsWithReplicates,QuaternaryWashAirDryTime],
				Replace[QuaternaryWashMixes]->Flatten@Lookup[resolvedOptionsWithReplicates,QuaternaryWashMix],
				Replace[QuaternaryWashMixTypes]->Flatten@Lookup[resolvedOptionsWithReplicates,QuaternaryWashMixType],
				Replace[QuaternaryWashMixTimes]->Flatten@Lookup[resolvedOptionsWithReplicates,QuaternaryWashMixTime],
				Replace[QuaternaryWashMixRates]->Flatten@Lookup[resolvedOptionsWithReplicates,QuaternaryWashMixRate],
				Replace[NumberOfQuaternaryWashMixes]->Flatten@Lookup[resolvedOptionsWithReplicates,NumberOfQuaternaryWashMixes],
				Replace[QuaternaryWashMixVolumes]->Flatten@Lookup[resolvedOptionsWithReplicates,QuaternaryWashMixVolume],
				Replace[QuaternaryWashMixTemperatures]->Flatten@Lookup[resolvedOptionsWithReplicates,QuaternaryWashMixTemperature]/.{Ambient->$AmbientTemperature},
				Replace[QuaternaryWashCollectionContainers]->Flatten@Map[Link[#]&,quaternaryWashCollectionContainerResources],
				Replace[QuaternaryWashDestinationWells]->Flatten@Lookup[resolvedOptionsWithReplicates,QuaternaryWashDestinationWell],
				Replace[QuaternaryWashCollectionStorageConditions]->Flatten@Lookup[resolvedOptionsWithReplicates,QuaternaryWashCollectionStorageCondition],
				Replace[QuaternaryWashMixTipTypes]->Flatten@Lookup[resolvedOptionsWithReplicates,QuaternaryWashMixTipType],
				Replace[QuaternaryWashMixTipMaterials]->Flatten@Lookup[resolvedOptionsWithReplicates,QuaternaryWashMixTipMaterial],

				(* === QuinaryWash === *)
				Replace[QuinaryWashes]->Flatten@Lookup[resolvedOptionsWithReplicates,QuinaryWash],
				Replace[QuinaryWashBuffers]->Flatten@Map[Link[#]&,Replace[quinaryWashBuffers,uniqueSampleResourceLookup[uniqueQuinaryWashBuffersAndVolumesAssoc],{2}],{2}],
				Replace[QuinaryWashBufferVolumes]->Flatten@Lookup[resolvedOptionsWithReplicates,QuinaryWashBufferVolume],
				Replace[QuinaryWashMagnetizationTimes]->Flatten@Lookup[resolvedOptionsWithReplicates,QuinaryWashMagnetizationTime],
				Replace[QuinaryWashAspirationVolumes]->Flatten@MapThread[
					Function[{quinaryWashAspirationVolumesBatch,quinaryWashBufferVolumesBatch},
						MapThread[
							If[MatchQ[#1,All],#2,#1]&,
							{quinaryWashAspirationVolumesBatch,quinaryWashBufferVolumesBatch}
						]
					],
					{Lookup[resolvedOptionsWithReplicates,QuinaryWashAspirationVolume],Lookup[resolvedOptionsWithReplicates,QuinaryWashBufferVolume]}
				],
				Replace[NumberOfQuinaryWashes]->Flatten@Lookup[resolvedOptionsWithReplicates,NumberOfQuinaryWashes],
				Replace[QuinaryWashAirDries]->Flatten@Lookup[resolvedOptionsWithReplicates,QuinaryWashAirDry],
				Replace[QuinaryWashAirDryTimes]->Flatten@Lookup[resolvedOptionsWithReplicates,QuinaryWashAirDryTime],
				Replace[QuinaryWashMixes]->Flatten@Lookup[resolvedOptionsWithReplicates,QuinaryWashMix],
				Replace[QuinaryWashMixTypes]->Flatten@Lookup[resolvedOptionsWithReplicates,QuinaryWashMixType],
				Replace[QuinaryWashMixTimes]->Flatten@Lookup[resolvedOptionsWithReplicates,QuinaryWashMixTime],
				Replace[QuinaryWashMixRates]->Flatten@Lookup[resolvedOptionsWithReplicates,QuinaryWashMixRate],
				Replace[NumberOfQuinaryWashMixes]->Flatten@Lookup[resolvedOptionsWithReplicates,NumberOfQuinaryWashMixes],
				Replace[QuinaryWashMixVolumes]->Flatten@Lookup[resolvedOptionsWithReplicates,QuinaryWashMixVolume],
				Replace[QuinaryWashMixTemperatures]->Flatten@Lookup[resolvedOptionsWithReplicates,QuinaryWashMixTemperature]/.{Ambient->$AmbientTemperature},
				Replace[QuinaryWashCollectionContainers]->Flatten@Map[Link[#]&,quinaryWashCollectionContainerResources],
				Replace[QuinaryWashDestinationWells]->Flatten@Lookup[resolvedOptionsWithReplicates,QuinaryWashDestinationWell],
				Replace[QuinaryWashCollectionStorageConditions]->Flatten@Lookup[resolvedOptionsWithReplicates,QuinaryWashCollectionStorageCondition],
				Replace[QuinaryWashMixTipTypes]->Flatten@Lookup[resolvedOptionsWithReplicates,QuinaryWashMixTipType],
				Replace[QuinaryWashMixTipMaterials]->Flatten@Lookup[resolvedOptionsWithReplicates,QuinaryWashMixTipMaterial],

				(* === SenaryWash === *)
				Replace[SenaryWashes]->Flatten@Lookup[resolvedOptionsWithReplicates,SenaryWash],
				Replace[SenaryWashBuffers]->Flatten@Map[Link[#]&,Replace[senaryWashBuffers,uniqueSampleResourceLookup[uniqueSenaryWashBuffersAndVolumesAssoc],{2}],{2}],
				Replace[SenaryWashBufferVolumes]->Flatten@Lookup[resolvedOptionsWithReplicates,SenaryWashBufferVolume],
				Replace[SenaryWashMagnetizationTimes]->Flatten@Lookup[resolvedOptionsWithReplicates,SenaryWashMagnetizationTime],
				Replace[SenaryWashAspirationVolumes]->Flatten@MapThread[
					Function[{senaryWashAspirationVolumesBatch,senaryWashBufferVolumesBatch},
						MapThread[
							If[MatchQ[#1,All],#2,#1]&,
							{senaryWashAspirationVolumesBatch,senaryWashBufferVolumesBatch}
						]
					],
					{Lookup[resolvedOptionsWithReplicates,SenaryWashAspirationVolume],Lookup[resolvedOptionsWithReplicates,SenaryWashBufferVolume]}
				],
				Replace[NumberOfSenaryWashes]->Flatten@Lookup[resolvedOptionsWithReplicates,NumberOfSenaryWashes],
				Replace[SenaryWashAirDries]->Flatten@Lookup[resolvedOptionsWithReplicates,SenaryWashAirDry],
				Replace[SenaryWashAirDryTimes]->Flatten@Lookup[resolvedOptionsWithReplicates,SenaryWashAirDryTime],
				Replace[SenaryWashMixes]->Flatten@Lookup[resolvedOptionsWithReplicates,SenaryWashMix],
				Replace[SenaryWashMixTypes]->Flatten@Lookup[resolvedOptionsWithReplicates,SenaryWashMixType],
				Replace[SenaryWashMixTimes]->Flatten@Lookup[resolvedOptionsWithReplicates,SenaryWashMixTime],
				Replace[SenaryWashMixRates]->Flatten@Lookup[resolvedOptionsWithReplicates,SenaryWashMixRate],
				Replace[NumberOfSenaryWashMixes]->Flatten@Lookup[resolvedOptionsWithReplicates,NumberOfSenaryWashMixes],
				Replace[SenaryWashMixVolumes]->Flatten@Lookup[resolvedOptionsWithReplicates,SenaryWashMixVolume],
				Replace[SenaryWashMixTemperatures]->Flatten@Lookup[resolvedOptionsWithReplicates,SenaryWashMixTemperature]/.{Ambient->$AmbientTemperature},
				Replace[SenaryWashCollectionContainers]->Flatten@Map[Link[#]&,senaryWashCollectionContainerResources],
				Replace[SenaryWashDestinationWells]->Flatten@Lookup[resolvedOptionsWithReplicates,SenaryWashDestinationWell],
				Replace[SenaryWashCollectionStorageConditions]->Flatten@Lookup[resolvedOptionsWithReplicates,SenaryWashCollectionStorageCondition],
				Replace[SenaryWashMixTipTypes]->Flatten@Lookup[resolvedOptionsWithReplicates,SenaryWashMixTipType],
				Replace[SenaryWashMixTipMaterials]->Flatten@Lookup[resolvedOptionsWithReplicates,SenaryWashMixTipMaterial],

				(* === SeptenaryWash === *)
				Replace[SeptenaryWashes]->Flatten@Lookup[resolvedOptionsWithReplicates,SeptenaryWash],
				Replace[SeptenaryWashBuffers]->Flatten@Map[Link[#]&,Replace[septenaryWashBuffers,uniqueSampleResourceLookup[uniqueSeptenaryWashBuffersAndVolumesAssoc],{2}],{2}],
				Replace[SeptenaryWashBufferVolumes]->Flatten@Lookup[resolvedOptionsWithReplicates,SeptenaryWashBufferVolume],
				Replace[SeptenaryWashMagnetizationTimes]->Flatten@Lookup[resolvedOptionsWithReplicates,SeptenaryWashMagnetizationTime],
				Replace[SeptenaryWashAspirationVolumes]->Flatten@MapThread[
					Function[{septenaryWashAspirationVolumesBatch,septenaryWashBufferVolumesBatch},
						MapThread[
							If[MatchQ[#1,All],#2,#1]&,
							{septenaryWashAspirationVolumesBatch,septenaryWashBufferVolumesBatch}
						]
					],
					{Lookup[resolvedOptionsWithReplicates,SeptenaryWashAspirationVolume],Lookup[resolvedOptionsWithReplicates,SeptenaryWashBufferVolume]}
				],
				Replace[NumberOfSeptenaryWashes]->Flatten@Lookup[resolvedOptionsWithReplicates,NumberOfSeptenaryWashes],
				Replace[SeptenaryWashAirDries]->Flatten@Lookup[resolvedOptionsWithReplicates,SeptenaryWashAirDry],
				Replace[SeptenaryWashAirDryTimes]->Flatten@Lookup[resolvedOptionsWithReplicates,SeptenaryWashAirDryTime],
				Replace[SeptenaryWashMixes]->Flatten@Lookup[resolvedOptionsWithReplicates,SeptenaryWashMix],
				Replace[SeptenaryWashMixTypes]->Flatten@Lookup[resolvedOptionsWithReplicates,SeptenaryWashMixType],
				Replace[SeptenaryWashMixTimes]->Flatten@Lookup[resolvedOptionsWithReplicates,SeptenaryWashMixTime],
				Replace[SeptenaryWashMixRates]->Flatten@Lookup[resolvedOptionsWithReplicates,SeptenaryWashMixRate],
				Replace[NumberOfSeptenaryWashMixes]->Flatten@Lookup[resolvedOptionsWithReplicates,NumberOfSeptenaryWashMixes],
				Replace[SeptenaryWashMixVolumes]->Flatten@Lookup[resolvedOptionsWithReplicates,SeptenaryWashMixVolume],
				Replace[SeptenaryWashMixTemperatures]->Flatten@Lookup[resolvedOptionsWithReplicates,SeptenaryWashMixTemperature]/.{Ambient->$AmbientTemperature},
				Replace[SeptenaryWashCollectionContainers]->Flatten@Map[Link[#]&,septenaryWashCollectionContainerResources],
				Replace[SeptenaryWashDestinationWells]->Flatten@Lookup[resolvedOptionsWithReplicates,SeptenaryWashDestinationWell],
				Replace[SeptenaryWashCollectionStorageConditions]->Flatten@Lookup[resolvedOptionsWithReplicates,SeptenaryWashCollectionStorageCondition],
				Replace[SeptenaryWashMixTipTypes]->Flatten@Lookup[resolvedOptionsWithReplicates,SeptenaryWashMixTipType],
				Replace[SeptenaryWashMixTipMaterials]->Flatten@Lookup[resolvedOptionsWithReplicates,SeptenaryWashMixTipMaterial],

				(* === Elution === *)
				Replace[Elutions]->Flatten@Lookup[resolvedOptionsWithReplicates,Elution],
				Replace[ElutionBuffers]->Flatten@Map[Link[#]&,Replace[elutionBuffers,uniqueSampleResourceLookup[uniqueElutionBuffersAndVolumesAssoc],{2}],{2}],
				Replace[ElutionBufferVolumes]->Flatten@Lookup[resolvedOptionsWithReplicates,ElutionBufferVolume],
				Replace[ElutionMagnetizationTimes]->Flatten@Lookup[resolvedOptionsWithReplicates,ElutionMagnetizationTime],
				Replace[ElutionAspirationVolumes]->Flatten@MapThread[
					Function[{elutionAspirationVolumesBatch,elutionBufferVolumesBatch},
						MapThread[
							If[MatchQ[#1,All],#2,#1]&,
							{elutionAspirationVolumesBatch,elutionBufferVolumesBatch}
						]
					],
					{Lookup[resolvedOptionsWithReplicates,ElutionAspirationVolume],Lookup[resolvedOptionsWithReplicates,ElutionBufferVolume]}
				],
				Replace[NumberOfElutions]->Flatten@Lookup[resolvedOptionsWithReplicates,NumberOfElutions],
				Replace[ElutionMixes]->Flatten@Lookup[resolvedOptionsWithReplicates,ElutionMix],
				Replace[ElutionMixTypes]->Flatten@Lookup[resolvedOptionsWithReplicates,ElutionMixType],
				Replace[ElutionMixTimes]->Flatten@Lookup[resolvedOptionsWithReplicates,ElutionMixTime],
				Replace[ElutionMixRates]->Flatten@Lookup[resolvedOptionsWithReplicates,ElutionMixRate],
				Replace[NumberOfElutionMixes]->Flatten@Lookup[resolvedOptionsWithReplicates,NumberOfElutionMixes],
				Replace[ElutionMixVolumes]->Flatten@Lookup[resolvedOptionsWithReplicates,ElutionMixVolume],
				Replace[ElutionMixTemperatures]->Flatten@Lookup[resolvedOptionsWithReplicates,ElutionMixTemperature]/.{Ambient->$AmbientTemperature},
				Replace[ElutionCollectionContainers]->Flatten@Map[Link[#]&,elutionCollectionContainerResources],
				Replace[ElutionDestinationWells]->Flatten@Lookup[resolvedOptionsWithReplicates,ElutionDestinationWell],
				Replace[ElutionCollectionStorageConditions]->Flatten@Lookup[resolvedOptionsWithReplicates,ElutionCollectionStorageCondition],
				Replace[ElutionMixTipTypes]->Flatten@Lookup[resolvedOptionsWithReplicates,ElutionMixTipType],
				Replace[ElutionMixTipMaterials]->Flatten@Lookup[resolvedOptionsWithReplicates,ElutionMixTipMaterial]
			|>;

			(* Get our sample prep fields. *)
			prepPacket=populateSamplePrepFields[myNestedSamples,myResolvedOptions,Cache->inheritedCache,Simulation->currentSimulation];

			(* Return *)
			{Join[packet, prepPacket], {}, currentSimulation, Null}
		],
		Module[
			{
				newLabelSampleUO, oldResourceToNewResourceRules, magneticBeadSourceVolumeLookup,bufferLabelLookup,preWashBufferLabels,equilibrationBufferLabels,washBufferLabels,elutionBufferLabels,
				magneticBeadLabelLookup,magneticBeadLabels,labelPrimitives,magneticBeadPrimitives,
				preWashPrimitives,equilibrationPrimitives,loadingPrimitives,washPrimitives,elutionPrimitives,
				secondaryWashBufferLabels,secondaryWashPrimitives,
				tertiaryWashBufferLabels,tertiaryWashPrimitives,
				quaternaryWashBufferLabels,quaternaryWashPrimitives,
				quinaryWashBufferLabels,quinaryWashPrimitives,
				senaryWashBufferLabels,senaryWashPrimitives,
				septenaryWashBufferLabels,septenaryWashPrimitives,
				samplesToLabelSampleOut,
				sampleOutLabelingPrimitive,allPrimitives,roboticUnitOperationPackets,roboticSimulation,updateCompositionRoboticSimulation,
				roboticRunTime,outputUnitOperationPacket,myNormalizedResolvedOptions,simulatedObjectsToLabel,expandedResolvedOptionsWithLabels,simulatedSamplesWithLabels,
				roboticUnitOperationPacketsCorrectedResources
			},


			(* === Generate all of the primitives we need. === *)

			(* get the new label sample unit operation if it exists; need to replace the models in it with the sample resources we've already created/simulated *)
			{newLabelSampleUO, oldResourceToNewResourceRules} = If[MatchQ[Lookup[myResolvedOptions, PreparatoryUnitOperations], {_[_LabelSample]}],
				generateLabelSampleUO[
					Lookup[myResolvedOptions, PreparatoryUnitOperations][[1, 1]],
					currentSimulation,
					samplesInResources
				],
				{Null, {}}
			];

			(* Create labels for all unique buffer/buffer containers *)
			bufferLabelLookup = <||>; (* buffer-><|label->{label, amount, containerLabel} |>*)

			(* If they exist, add the prewash buffers to the container lookup *)
			{preWashBufferLabels,bufferLabelLookup}=simulateWashStageBufferLabels[preWashes,preWashBuffers,preWashBufferVolumes,numberOfPreWashes,bufferLabelLookup];

			(* If they exist, add the equilibration buffers to the container lookup *)
			equilibrationBufferLabels=MapThread[
				Function[{doStageBatch,bufferBatch, volumeBatch},
					MapThread[
						Function[{doStage,buffer,volume},
							Module[{currentBufferInfo,bufferFromLookup},

								If[doStage,
									(* Make sure the buffer is a canonical object *)
									buffer=Download[buffer,Object];
									(* See if this buffer already exists in the lookup and there is an instance that can hold the needed volume *)
									bufferFromLookup=Lookup[bufferLabelLookup,buffer,<||>];
									currentBufferInfo=FirstCase[bufferFromLookup,_?(LessEqualQ[#[[2]] + volume, 50 Milliliter] &),Null];

									If[!NullQ[currentBufferInfo],

										(* If the buffer already exists *)
										Module[{label, amount, containerLabel,newAssoc},

											(* Extract current info *)
											{label, amount, containerLabel}=currentBufferInfo;

											(* Add to the amount *)
											newAssoc=<|label->{label,amount+SafeRound[volume*1.05, 1 Microliter],containerLabel}|>;
											bufferLabelLookup=AssociateTo[bufferLabelLookup,
												buffer->AssociateTo[bufferFromLookup,newAssoc]
											];

											(* Return the label *)
											{label}
										],

										(* If the buffer does not exist in the lookup *)
										Module[{newLabel,newContainerLabel,newAssoc},

											(* Create new labels *)
											newLabel=CreateUniqueLabel["MBS Buffer"];
											newContainerLabel=CreateUniqueLabel["MBS Buffer Container"];

											(* Add to the lookup *)
											newAssoc=<|newLabel->{newLabel,SafeRound[volume*1.05, 1 Microliter],newContainerLabel}|>;
											bufferLabelLookup=AssociateTo[bufferLabelLookup,
												buffer->AssociateTo[bufferFromLookup,newAssoc]
											];

											(* Return the new label *)
											{newLabel}
										]
									]
								]
							]
						],
						{doStageBatch,bufferBatch, volumeBatch}
					]
				],
				{
					equilibrations,equilibrationBuffers,equilibrationBufferVolumes
				}
			];

			{washBufferLabels,bufferLabelLookup}=simulateWashStageBufferLabels[washes,washBuffers,washBufferVolumes,numberOfWashes,bufferLabelLookup];

			{secondaryWashBufferLabels,bufferLabelLookup}=simulateWashStageBufferLabels[secondaryWashes,secondaryWashBuffers,secondaryWashBufferVolumes,numberOfSecondaryWashes,bufferLabelLookup];

			{tertiaryWashBufferLabels,bufferLabelLookup}=simulateWashStageBufferLabels[tertiaryWashes,tertiaryWashBuffers,tertiaryWashBufferVolumes,numberOfTertiaryWashes,bufferLabelLookup];

			{quaternaryWashBufferLabels,bufferLabelLookup}=simulateWashStageBufferLabels[quaternaryWashes,quaternaryWashBuffers,quaternaryWashBufferVolumes,numberOfQuaternaryWashes,bufferLabelLookup];

			{quinaryWashBufferLabels,bufferLabelLookup}=simulateWashStageBufferLabels[quinaryWashes,quinaryWashBuffers,quinaryWashBufferVolumes,numberOfQuinaryWashes,bufferLabelLookup];

			{senaryWashBufferLabels,bufferLabelLookup}=simulateWashStageBufferLabels[senaryWashes,senaryWashBuffers,senaryWashBufferVolumes,numberOfSenaryWashes,bufferLabelLookup];

			{septenaryWashBufferLabels,bufferLabelLookup}=simulateWashStageBufferLabels[septenaryWashes,septenaryWashBuffers,septenaryWashBufferVolumes,numberOfSeptenaryWashes,bufferLabelLookup];

			{elutionBufferLabels,bufferLabelLookup}=simulateWashStageBufferLabels[elutions,elutionBuffers,elutionBufferVolumes,numberOfElutions,bufferLabelLookup];

			magneticBeadLabelLookup=<||>;
			(* Make labels for magnetic beads/magnetic bead containers *)
			magneticBeadLabels=MapThread[
				Function[{magneticBeadBatch, volumeBatch},
					MapThread[
						Function[{magneticBead,volume},
							Module[{currentMagneticBeadInfo,magneticBeadFromLookup},
								(* See if this magneticBead already exists in the lookup and there is an instance that can hold the needed volume *)
								magneticBeadFromLookup=Lookup[magneticBeadLabelLookup,magneticBead,<||>];
								currentMagneticBeadInfo=FirstCase[magneticBeadFromLookup,_?(LessEqualQ[#[[2]] + volume, 50 Milliliter] &),Null];

								If[!NullQ[currentMagneticBeadInfo],

									(* If the magneticBead already exists *)
									Module[{label, amount, containerLabel,newAssoc},

										(* Extract current info *)
										{label, amount, containerLabel}=currentMagneticBeadInfo;

										(* Add to the amount *)
										newAssoc=<|label->{label,amount+SafeRound[volume*1.05, 1 Microliter],containerLabel}|>;
										magneticBeadLabelLookup=AssociateTo[magneticBeadLabelLookup,
											magneticBead->AssociateTo[magneticBeadFromLookup,newAssoc]
										];

										(* Return the label *)
										label
									],

									(* If the magneticBead does not exist in the lookup *)
									Module[{newLabel,newContainerLabel,newAssoc},

										(* Create new labels *)
										newLabel=CreateUniqueLabel["MBS MagneticBead"];
										newContainerLabel=CreateUniqueLabel["MBS MagneticBead Container"];

										(* Add to the lookup *)
										newAssoc=<|newLabel->{newLabel,SafeRound[volume*1.05, 1 Microliter],newContainerLabel}|>;
										magneticBeadLabelLookup=AssociateTo[magneticBeadLabelLookup,
											magneticBead->AssociateTo[magneticBeadFromLookup,newAssoc]
										];

										(* Return the new label *)
										newLabel
									]
								]
							]
						],
						{magneticBeadBatch, volumeBatch}
					]
				],
				{magneticBeads,magneticBeadVolumes}
			];

			(* Check the source volume of the magnetic beads, in order to resolve a default aspirationMixVolume for the magneticBeadPrimitives *)
			magneticBeadSourceVolumeLookup = Map[
				Function[{magneticBead},
					Module[{beadAssoc,beadLabel,sourceVolume},
						(*Look up the association for the bead object*)
						beadAssoc = Lookup[magneticBeadLabelLookup,magneticBead];

						(*Lookup the label of the magnetic bead object*)
						beadLabel = Keys[beadAssoc][[1]];
            (* Determine our source volume based on if the sample is object or model.*)
						sourceVolume = If[MatchQ[magneticBead,ObjectP[Object[Sample]]],
							(*If the bead is a sample, use its Volume*)
							fastAssocLookup[inheritedFastAssoc,magneticBead,Volume],
							(* Otherwise the bead is a model, we use the combined volumes requested in resource and that will be our source volume when aspirating the beads. But should no less than 20 microliter, otherwise we wouldn't be able to aspirate with any widebore tips. *)
							Max[Lookup[beadAssoc,beadLabel][[2]], 20 Microliter]
						];
						(*Output the rule of magnetic bead label -> source volume*)
						beadLabel -> sourceVolume
					]
				],
				DeleteDuplicates[Flatten@magneticBeads]
			];

			(* --- Generate Label Primitives --- *)
			labelPrimitives=Module[
				{
					allUniqueLabelSampleLabels,allUniqueLabelSampleSamples,allUniqueLabelSampleContainerLabels,allUniqueLabelSampleAmounts,
					allUniqueLabelContainerLabels,allUniqueLabelContainerContainers
				},

				(* Gather LabelSampleInputs *)
				{allUniqueLabelSampleLabels,allUniqueLabelSampleSamples,allUniqueLabelSampleContainerLabels,allUniqueLabelSampleAmounts}=Module[
					{
						magneticBeadsInfo,bufferInfo,flattenedSamples,flattenedLabels,
						flattenedContainerLabels,flattenedAmounts,connectedTuples,uniqueValidTuples,
						labelTotalAmountLookup,uniqueValidTuplesNullVolumes
					},

					(* get magnetic bead and buffer data from lookup *)
					magneticBeadsInfo=Flatten[KeyValueMap[
						Function[{beads, instances},
							KeyValueMap[
								(Prepend[#2,beads])&,
								instances
							]
						],
						magneticBeadLabelLookup
					],1];

					bufferInfo=If[MatchQ[bufferLabelLookup,<||>],
						{{{},{},{},{}}},
						Flatten[KeyValueMap[
							Function[{buffer, instances},
								KeyValueMap[
									(Prepend[#2,buffer])&,
									instances
								]
							],
							bufferLabelLookup
						],1]
					];

					(* Flatten all components *)
					flattenedSamples=Flatten@Join[{nestedSamplesWithReplicates, magneticBeadsInfo[[All,1]], bufferInfo[[All,1]]}];
					flattenedLabels=Flatten@Join[{sampleLabels, magneticBeadsInfo[[All,2]], bufferInfo[[All,2]]}];
					flattenedContainerLabels=Flatten@Join[{sampleContainerLabels,magneticBeadsInfo[[All,4]],bufferInfo[[All,4]]}];
					flattenedAmounts=Flatten@Join[{volumes,magneticBeadsInfo[[All,3]],bufferInfo[[All,3]]}];

					(* Link everything together *)
					connectedTuples=Transpose[{flattenedSamples,flattenedLabels,flattenedContainerLabels,flattenedAmounts}];

					(* Only keep unique and valid tuples *)
					uniqueValidTuples=DeleteDuplicates@Cases[connectedTuples,{ObjectP[{Object[Sample],Model[Sample]}],_String,_String,VolumeP}];

					(* Create a lookup of Label -> Total required volume *)
					labelTotalAmountLookup=GroupBy[uniqueValidTuples,First->Last,Total];

					(* If the sample is an object set the volume to Null *)
					uniqueValidTuplesNullVolumes=Map[
						Function[{tuple},
							If[MatchQ[tuple[[1]], ObjectP[Object[Sample]]],
								Join[tuple[[1;;3]],{Null}],
								tuple
							]
						],
						uniqueValidTuples
					];

					{
						uniqueValidTuplesNullVolumes[[All,2]],
						uniqueValidTuplesNullVolumes[[All,1]],
						uniqueValidTuplesNullVolumes[[All,3]],
						uniqueValidTuplesNullVolumes[[All,4]] /.labelTotalAmountLookup
					}
				];

				(* Gather Label container inputs *)
				{allUniqueLabelContainerContainers,allUniqueLabelContainerLabels} = Module[
					{connectedContainersAndLabels,uniqueContainersAndLabels},


					(* Link the containers with their label *)
					connectedContainersAndLabels=Transpose[{flattenedContainers,flattenedContainerLabels}];

					(* Only keep unique and valid pairs *)
					uniqueContainersAndLabels=DeleteDuplicates@Cases[connectedContainersAndLabels,{ObjectP[{Object[Container],Model[Container]}],_String}];

					(* Extract the containers and labels *)
					{uniqueContainersAndLabels[[All,1]],uniqueContainersAndLabels[[All,2]]}

				];

				(* Return single LabelSample and LabelContainer Primitive *)
				{
					LabelSample[
						Label -> allUniqueLabelSampleLabels,
						Sample -> allUniqueLabelSampleSamples,
						ContainerLabel -> allUniqueLabelSampleContainerLabels,
						Amount -> allUniqueLabelSampleAmounts
					],

					LabelContainer[
						Label -> allUniqueLabelContainerLabels,
						Container -> allUniqueLabelContainerContainers
					]
				}
			];

			(* Do a mapthread for each stage (and the magnetic beads) over the batches to generate the primitives *)
			(* They will threaded together correctly at the end *)

			(* --- Magnetic Beads --- *)
			magneticBeadPrimitives=MapThread[
				Function[
					{
						assayContainerLabelsBatch,assayWellsBatch,magneticBeadLabelsBatch,magneticBeadVolumesBatch
					},
					Transfer[
						Source->magneticBeadLabelsBatch,
						Destination->Transpose[{assayWellsBatch,assayContainerLabelsBatch}],
						Amount->magneticBeadVolumesBatch,
						TipType->WideBore,
						AspirationMix->True,
						AspirationMixType->Pipette,
						NumberOfAspirationMixes->20,
						AspirationMixVolume->(Min[SafeRound[0.6*#,1*Microliter],300*Microliter]&/@Lookup[magneticBeadSourceVolumeLookup,magneticBeadLabelsBatch])
					]
				],
				{
					assayContainerLabels,assayWells,magneticBeadLabels,magneticBeadVolumes
				}
			];

			(* --- PreWash --- *)
			preWashPrimitives=generateWashStagePrimitivesInResourcePacket[preWashes,preWashBufferVolumes,preWashMagnetizationTimes,preWashAspirationVolumes,preWashAspirationPositions, preWashAspirationPositionOffsets,numberOfPreWashes, preWashAirDries,preWashAirDryTimes,preWashMixes,preWashMixTypes,preWashMixTimes,preWashMixRates,numberOfPreWashMixes, preWashMixVolumes,preWashMixTemperatures, preWashMixTipTypes,preWashMixTipMaterials,preWashDestinationWells,preWashCollectionContainerLabels,assayContainerLabels,assayWells,magnetizationRacks,unresolvedMagnetizationRacks,preWashBufferLabels];

			(* --- Equilibration --- *)
			equilibrationPrimitives=MapThread[
			Function[
			{
				equilibrationsBatch,equilibrationBuffersBatch,equilibrationBufferVolumesBatch,equilibrationMagnetizationTimesBatch,equilibrationAspirationVolumesBatch,equilibrationAspirationPositionsBatch,equilibrationAspirationPositionOffsetsBatch,
				equilibrationAirDriesBatch,equilibrationAirDryTimesBatch,equilibrationMixesBatch,equilibrationMixTypesBatch,equilibrationMixTimesBatch,equilibrationMixRatesBatch,numberOfEquilibrationMixesBatch,
				equilibrationMixVolumesBatch,equilibrationMixTemperaturesBatch,equilibrationCollectionContainersBatch,equilibrationCollectionStorageConditionsBatch,
				equilibrationMixTipTypesBatch,
				equilibrationMixTipMaterialsBatch,equilibrationDestinationWellsBatch,
				equilibrationCollectionContainerLabelsBatch,assayContainerLabelsBatch,assayWellsBatch,magnetizationRacksBatch,unresolvedMagnetizationRacksBatch,equilibrationBufferLabelsBatch
			},
				Module[{mixingBools,airDryingBools},

					(* See what samples we use this round *)
					mixingBools=MapThread[And[#1,#2]&,{equilibrationsBatch,equilibrationMixesBatch}];

					(* Pick the times of the samples which are air drying *)
					airDryingBools=MapThread[And[#1,#2]&,{equilibrationsBatch,equilibrationAirDriesBatch}];

					If[Or@@equilibrationsBatch,
						{
							(* Transfer equilibrationBuffer into assay container *)
							Transfer[
								Source->PickList[equilibrationBufferLabelsBatch,equilibrationsBatch][[All,1]],
								Destination->Transpose[{PickList[assayWellsBatch,equilibrationsBatch],PickList[assayContainerLabelsBatch,equilibrationsBatch]}],
								Amount->PickList[equilibrationBufferVolumesBatch,equilibrationsBatch],
								MultichannelTransfer->False
							],
							(* Mix if necessary. Only choosing the samples that we are using this round and that we mix *)
							If[Or@@mixingBools,
								Mix[
									Sample->Transpose[{PickList[assayWellsBatch,mixingBools],PickList[assayContainerLabelsBatch,mixingBools]}],
									MixType->PickList[equilibrationMixTypesBatch,mixingBools],
									Time->PickList[equilibrationMixTimesBatch,mixingBools],
									MixRate->PickList[equilibrationMixRatesBatch,mixingBools],
									NumberOfMixes->PickList[numberOfEquilibrationMixesBatch,mixingBools],
									MixVolume->PickList[equilibrationMixVolumesBatch,mixingBools],
                  MixFlowRate->Replace[PickList[equilibrationMixTypesBatch,mixingBools],{Except[Pipette]->Null,Pipette->500 Microliter/Second},2],(*give it a higher default than in Mix which is only 100 Microliter/Second*)
                  MixPosition -> Replace[PickList[equilibrationMixTypesBatch,mixingBools],{Except[Pipette]->Null,Pipette->Bottom},2],(*give it a default other than in Mix which is LiquidLevel*)
                  MixPositionOffset-> Replace[PickList[equilibrationMixTypesBatch,mixingBools],{Except[Pipette]->Null,Pipette->1 Millimeter},2],(*give it a smaller default other than in Mix which is 2mm*)
									Temperature->PickList[equilibrationMixTemperaturesBatch,mixingBools],
									TipType->PickList[equilibrationMixTipTypesBatch,mixingBools],
									TipMaterial->PickList[equilibrationMixTipMaterialsBatch,mixingBools]
								],
								Nothing
							],
							(* Move to the magnet then transfer to collection container *)
							Transfer[
								Source->Transpose[{PickList[assayWellsBatch,equilibrationsBatch],PickList[assayContainerLabelsBatch,equilibrationsBatch]}],
								Destination->Transpose[{PickList[equilibrationDestinationWellsBatch,equilibrationsBatch][[All,1]],PickList[equilibrationCollectionContainerLabelsBatch,equilibrationsBatch][[All,1]]}],
								Amount->PickList[equilibrationAspirationVolumesBatch,equilibrationsBatch],
								Magnetization->True,
								MagnetizationTime->PickList[equilibrationMagnetizationTimesBatch,equilibrationsBatch],
								MagnetizationRack->PickList[magnetizationRacksBatch, equilibrationsBatch],
								UnresolvedMagnetizationRackFromParentProtocol -> PickList[unresolvedMagnetizationRacksBatch,equilibrationsBatch],
								AspirationPosition->PickList[equilibrationAspirationPositionsBatch,equilibrationsBatch],
								AspirationPositionOffset->PickList[equilibrationAspirationPositionOffsetsBatch,equilibrationsBatch],
								AspirationMix -> False,
								MultichannelTransfer->False
							],
							(* Generate a Wait primitive if we are asked to air dry *)
							If[Length[PickList[equilibrationAirDryTimesBatch,airDryingBools]]>0,
								Wait[Duration->Max[PickList[equilibrationAirDryTimesBatch,airDryingBools]]],
								Nothing
							]
						},
						{}
					]
				]
			],
				{
					equilibrations,equilibrationBuffers,equilibrationBufferVolumes,equilibrationMagnetizationTimes,equilibrationAspirationVolumes,equilibrationAspirationPositions,equilibrationAspirationPositionOffsets,
					equilibrationAirDries,equilibrationAirDryTimes,equilibrationMixes,equilibrationMixTypes,equilibrationMixTimes,equilibrationMixRates,numberOfEquilibrationMixes,
					equilibrationMixVolumes,equilibrationMixTemperatures,equilibrationCollectionContainers,equilibrationCollectionStorageConditions,
					equilibrationMixTipTypes,
					equilibrationMixTipMaterials,equilibrationDestinationWells,
					equilibrationCollectionContainerLabels,assayContainerLabels,assayWells,magnetizationRacks,unresolvedMagnetizationRacks,equilibrationBufferLabels
				}
			];

			(* --- Loading --- *)
			loadingPrimitives=MapThread[
				Function[
					{
						volumesBatch,loadingMagnetizationTimesBatch,loadingAspirationVolumesBatch,loadingAspirationPositionsBatch,loadingAspirationPositionOffsetsBatch,
						loadingAirDriesBatch,loadingAirDryTimesBatch,loadingMixesBatch,loadingMixTypesBatch,loadingMixTimesBatch,loadingMixRatesBatch,numberOfLoadingMixesBatch,
						loadingMixVolumesBatch,loadingMixTemperaturesBatch,loadingCollectionContainersBatch,loadingCollectionStorageConditionsBatch,
						loadingMixTipTypesBatch,
						loadingMixTipMaterialsBatch,loadingDestinationWellsBatch,
						loadingCollectionContainerLabelsBatch,assayContainerLabelsBatch,assayWellsBatch,magnetizationRacksBatch,unresolvedMagnetizationRacksBatch,sampleLabelsBatch,sampleOutLabelsBatch
					},
					{
						(* Transfer loadingBuffer into assay container *)
						Transfer[
							Source->sampleLabelsBatch,
							Destination->Transpose[{assayWellsBatch,assayContainerLabelsBatch}],
							Amount->volumesBatch,
							MultichannelTransfer->False
						],
						(* Mix if necessary. Once again, combine into a single primitive if we can (all samples are being mixed) *)
						If[Or@@loadingMixesBatch,
							Mix[
								Sample->Transpose[{PickList[assayWellsBatch,loadingMixesBatch],PickList[assayContainerLabelsBatch,loadingMixesBatch]}],
								MixType->PickList[loadingMixTypesBatch,loadingMixesBatch],
								Time->PickList[loadingMixTimesBatch,loadingMixesBatch],
								MixRate->PickList[loadingMixRatesBatch,loadingMixesBatch],
								NumberOfMixes->PickList[numberOfLoadingMixesBatch,loadingMixesBatch],
								MixVolume->PickList[loadingMixVolumesBatch,loadingMixesBatch],
								MixFlowRate->Replace[PickList[loadingMixTypesBatch,loadingMixesBatch],{Except[Pipette]->Null,Pipette->500 Microliter/Second},2],(*give it a higher default than in Mix which is only 100 Microliter/Second*)
								MixPosition -> Replace[PickList[loadingMixTypesBatch,loadingMixesBatch],{Except[Pipette]->Null,Pipette->Bottom},2],(*give it a default other than in Mix which is LiquidLevel*)
								MixPositionOffset-> Replace[PickList[loadingMixTypesBatch,loadingMixesBatch],{Except[Pipette]->Null,Pipette->1 Millimeter},2],(*give it a smaller default other than in Mix which is 2mm*)
								Temperature->PickList[loadingMixTemperaturesBatch,loadingMixesBatch],
								TipType->PickList[loadingMixTipTypesBatch,loadingMixesBatch],
								TipMaterial->PickList[loadingMixTipMaterialsBatch,loadingMixesBatch]
							],
							Nothing
						],
						(* Move to the magnet then transfer to collection container *)
						Transfer[
							Source->Transpose[{assayWellsBatch,assayContainerLabelsBatch}],
							Destination->Transpose[{loadingDestinationWellsBatch[[All,1]],loadingCollectionContainerLabelsBatch[[All,1]]}],
							If[MatchQ[selectionStrategy,Positive],
								DestinationLabel->Automatic,
								DestinationLabel->sampleOutLabelsBatch[[All,1]]
							],
							Amount->loadingAspirationVolumesBatch,
							Magnetization->True,
							MagnetizationTime->loadingMagnetizationTimesBatch,
							MagnetizationRack->magnetizationRacksBatch,
							UnresolvedMagnetizationRackFromParentProtocol -> unresolvedMagnetizationRacksBatch,
							AspirationPosition->loadingAspirationPositionsBatch,
							AspirationPositionOffset->loadingAspirationPositionOffsetsBatch,
							AspirationMix -> False,
							MultichannelTransfer->False
						],
						(* Generate a Wait primitive if we are asked to air dry *)
						If[Length[PickList[loadingAirDryTimesBatch,loadingAirDriesBatch]]>0,
							Wait[Duration->Max[PickList[loadingAirDryTimesBatch,loadingAirDriesBatch]]],
							Nothing
						]
					}
				],
				{
					volumes,loadingMagnetizationTimes,loadingAspirationVolumes,loadingAspirationPositions,loadingAspirationPositionOffsets,
					loadingAirDries,loadingAirDryTimes,loadingMixes,loadingMixTypes,loadingMixTimes,loadingMixRates,numberOfLoadingMixes,
					loadingMixVolumes,loadingMixTemperatures,loadingCollectionContainers,loadingCollectionStorageConditions,
					loadingMixTipTypes,
					loadingMixTipMaterials,loadingDestinationWells,
					loadingCollectionContainerLabels,assayContainerLabels,assayWells,magnetizationRacks,unresolvedMagnetizationRacks,sampleLabels,sampleOutLabels
				}
			];

			(* --- Wash --- *)
			washPrimitives=generateWashStagePrimitivesInResourcePacket[washes,washBufferVolumes,washMagnetizationTimes,washAspirationVolumes,washAspirationPositions, washAspirationPositionOffsets,numberOfWashes, washAirDries,washAirDryTimes,washMixes,washMixTypes,washMixTimes,washMixRates,numberOfWashMixes, washMixVolumes,washMixTemperatures, washMixTipTypes,washMixTipMaterials,washDestinationWells,washCollectionContainerLabels,assayContainerLabels,assayWells,magnetizationRacks,unresolvedMagnetizationRacks,washBufferLabels];
			(* --- SecondaryWash --- *)
			secondaryWashPrimitives=generateWashStagePrimitivesInResourcePacket[secondaryWashes,secondaryWashBufferVolumes,secondaryWashMagnetizationTimes,secondaryWashAspirationVolumes,secondaryWashAspirationPositions, secondaryWashAspirationPositionOffsets,numberOfSecondaryWashes, secondaryWashAirDries,secondaryWashAirDryTimes,secondaryWashMixes,secondaryWashMixTypes,secondaryWashMixTimes,secondaryWashMixRates,numberOfSecondaryWashMixes, secondaryWashMixVolumes,secondaryWashMixTemperatures, secondaryWashMixTipTypes,secondaryWashMixTipMaterials,secondaryWashDestinationWells,secondaryWashCollectionContainerLabels,assayContainerLabels,assayWells,magnetizationRacks,unresolvedMagnetizationRacks,secondaryWashBufferLabels];
			(* --- TertiaryWash --- *)
			tertiaryWashPrimitives=generateWashStagePrimitivesInResourcePacket[tertiaryWashes,tertiaryWashBufferVolumes,tertiaryWashMagnetizationTimes,tertiaryWashAspirationVolumes,tertiaryWashAspirationPositions, tertiaryWashAspirationPositionOffsets,numberOfTertiaryWashes, tertiaryWashAirDries,tertiaryWashAirDryTimes,tertiaryWashMixes,tertiaryWashMixTypes,tertiaryWashMixTimes,tertiaryWashMixRates,numberOfTertiaryWashMixes, tertiaryWashMixVolumes,tertiaryWashMixTemperatures, tertiaryWashMixTipTypes,tertiaryWashMixTipMaterials,tertiaryWashDestinationWells,tertiaryWashCollectionContainerLabels,assayContainerLabels,assayWells,magnetizationRacks,unresolvedMagnetizationRacks,tertiaryWashBufferLabels];
			(* --- QuaternaryWash --- *)
			quaternaryWashPrimitives=generateWashStagePrimitivesInResourcePacket[quaternaryWashes,quaternaryWashBufferVolumes,quaternaryWashMagnetizationTimes,quaternaryWashAspirationVolumes,quaternaryWashAspirationPositions, quaternaryWashAspirationPositionOffsets,numberOfQuaternaryWashes, quaternaryWashAirDries,quaternaryWashAirDryTimes,quaternaryWashMixes,quaternaryWashMixTypes,quaternaryWashMixTimes,quaternaryWashMixRates,numberOfQuaternaryWashMixes, quaternaryWashMixVolumes,quaternaryWashMixTemperatures, quaternaryWashMixTipTypes,quaternaryWashMixTipMaterials,quaternaryWashDestinationWells,quaternaryWashCollectionContainerLabels,assayContainerLabels,assayWells,magnetizationRacks,unresolvedMagnetizationRacks,quaternaryWashBufferLabels];
			(* --- QuinaryWash --- *)
			quinaryWashPrimitives=generateWashStagePrimitivesInResourcePacket[quinaryWashes,quinaryWashBufferVolumes,quinaryWashMagnetizationTimes,quinaryWashAspirationVolumes,quinaryWashAspirationPositions, quinaryWashAspirationPositionOffsets,numberOfQuinaryWashes, quinaryWashAirDries,quinaryWashAirDryTimes,quinaryWashMixes,quinaryWashMixTypes,quinaryWashMixTimes,quinaryWashMixRates,numberOfQuinaryWashMixes, quinaryWashMixVolumes,quinaryWashMixTemperatures, quinaryWashMixTipTypes,quinaryWashMixTipMaterials,quinaryWashDestinationWells,quinaryWashCollectionContainerLabels,assayContainerLabels,assayWells,magnetizationRacks,unresolvedMagnetizationRacks,quinaryWashBufferLabels];
			(* --- SenaryWash --- *)
			senaryWashPrimitives=generateWashStagePrimitivesInResourcePacket[senaryWashes,senaryWashBufferVolumes,senaryWashMagnetizationTimes,senaryWashAspirationVolumes,senaryWashAspirationPositions, senaryWashAspirationPositionOffsets,numberOfSenaryWashes, senaryWashAirDries,senaryWashAirDryTimes,senaryWashMixes,senaryWashMixTypes,senaryWashMixTimes,senaryWashMixRates,numberOfSenaryWashMixes, senaryWashMixVolumes,senaryWashMixTemperatures, senaryWashMixTipTypes,senaryWashMixTipMaterials,senaryWashDestinationWells,senaryWashCollectionContainerLabels,assayContainerLabels,assayWells,magnetizationRacks,unresolvedMagnetizationRacks,senaryWashBufferLabels];
			(* --- SeptenaryWash --- *)
			septenaryWashPrimitives=generateWashStagePrimitivesInResourcePacket[septenaryWashes,septenaryWashBufferVolumes,septenaryWashMagnetizationTimes,septenaryWashAspirationVolumes,septenaryWashAspirationPositions, septenaryWashAspirationPositionOffsets,numberOfSeptenaryWashes, septenaryWashAirDries,septenaryWashAirDryTimes,septenaryWashMixes,septenaryWashMixTypes,septenaryWashMixTimes,septenaryWashMixRates,numberOfSeptenaryWashMixes, septenaryWashMixVolumes,septenaryWashMixTemperatures, septenaryWashMixTipTypes,septenaryWashMixTipMaterials,septenaryWashDestinationWells,septenaryWashCollectionContainerLabels,assayContainerLabels,assayWells,magnetizationRacks,unresolvedMagnetizationRacks,septenaryWashBufferLabels];

			(* --- Elution --- *)
			elutionPrimitives=MapThread[
				Function[
					{
						elutionsBatch,elutionBuffersBatch,elutionBufferVolumesBatch,elutionMagnetizationTimesBatch,elutionAspirationVolumesBatch,
						elutionAspirationPositionsBatch, elutionAspirationPositionOffsetsBatch, numberOfElutionsBatch,
						elutionMixesBatch,elutionMixTypesBatch,elutionMixTimesBatch,elutionMixRatesBatch,numberOfElutionMixesBatch,
						elutionMixVolumesBatch,elutionMixTemperaturesBatch,elutionCollectionContainersBatch,elutionCollectionStorageConditionsBatch,
						elutionMixTipTypesBatch, elutionMixTipMaterialsBatch,elutionDestinationWellsBatch,
						elutionCollectionContainerLabelsBatch,assayContainerLabelsBatch,assayWellsBatch,magnetizationRacksBatch,
						unresolvedMagnetizationRacksBatch,elutionBufferLabelsBatch,sampleOutLabelsBatch
					},
					Module[{maxNumElutions,numberOfElutionsBatchBools,mixingBools},
						(* Get the max number of times we are Elutioning in this batch *)
						maxNumElutions=Max[DeleteCases[numberOfElutionsBatch,Null],{0}];

						(* Table that number of elutions *)
						Table[

							(* See what samples we use this round *)
							numberOfElutionsBatchBools=(LessEqualQ[i,#])&/@numberOfElutionsBatch;
							mixingBools=MapThread[(LessEqualQ[i,#1]&&TrueQ[#2])&,{numberOfElutionsBatch,elutionMixesBatch}];

							If[Or@@numberOfElutionsBatchBools,
								{
									(* Transfer elutionBuffer into assay container *)
									Transfer[
										Source->PickList[elutionBufferLabelsBatch,numberOfElutionsBatchBools][[All,i]],
										Destination->Transpose[{PickList[assayWellsBatch,numberOfElutionsBatchBools],PickList[assayContainerLabelsBatch,numberOfElutionsBatchBools]}],
										Amount->PickList[elutionBufferVolumesBatch,numberOfElutionsBatchBools],
										MultichannelTransfer->False
									],
									(* Mix if necessary. Only choosing the samples that we are using this round and that we mix *)
									If[Or@@mixingBools,
										Mix[
											Sample->Transpose[{PickList[assayWellsBatch,numberOfElutionsBatchBools],PickList[assayContainerLabelsBatch,numberOfElutionsBatchBools]}],
											MixType->PickList[elutionMixTypesBatch,mixingBools],
											Time->PickList[elutionMixTimesBatch,mixingBools],
											MixRate->PickList[elutionMixRatesBatch,mixingBools],
											NumberOfMixes->PickList[numberOfElutionMixesBatch,mixingBools],
											MixVolume->PickList[elutionMixVolumesBatch,mixingBools],
											MixFlowRate->Replace[PickList[elutionMixTypesBatch,mixingBools],{Except[Pipette]->Null,Pipette->500 Microliter/Second},2],(*give it a higher default than in Mix which is only 100 Microliter/Second*)
											MixPosition -> Replace[PickList[elutionMixTypesBatch,mixingBools],{Except[Pipette]->Null,Pipette->Bottom},2],(*give it a default other than in Mix which is LiquidLevel*)
											MixPositionOffset-> Replace[PickList[elutionMixTypesBatch,mixingBools],{Except[Pipette]->Null,Pipette->1 Millimeter},2],(*give it a smaller default other than in Mix which is 2mm*)
											Temperature->PickList[elutionMixTemperaturesBatch,mixingBools],
											TipType->PickList[elutionMixTipTypesBatch,mixingBools],
											TipMaterial->PickList[elutionMixTipMaterialsBatch,mixingBools]
										],
										Nothing
									],
									(* Move to the magnet then transfer to collection container *)
									Transfer[
										Source->Transpose[{PickList[assayWellsBatch,numberOfElutionsBatchBools],PickList[assayContainerLabelsBatch,numberOfElutionsBatchBools]}],
										Destination->Transpose[{PickList[elutionDestinationWellsBatch,numberOfElutionsBatchBools][[All,i]],PickList[elutionCollectionContainerLabelsBatch,numberOfElutionsBatchBools][[All,i]]}],
										If[MatchQ[selectionStrategy,Positive],
											DestinationLabel->PickList[sampleOutLabelsBatch,numberOfElutionsBatchBools][[All,i]],
											DestinationLabel->Automatic
										],
										Amount->PickList[elutionAspirationVolumesBatch,numberOfElutionsBatchBools],
										Magnetization->True,
										MagnetizationTime->PickList[elutionMagnetizationTimesBatch,numberOfElutionsBatchBools],
										MagnetizationRack->PickList[magnetizationRacksBatch,numberOfElutionsBatchBools],
										UnresolvedMagnetizationRackFromParentProtocol -> PickList[unresolvedMagnetizationRacksBatch,numberOfElutionsBatchBools],
										AspirationPosition->PickList[elutionAspirationPositionsBatch,numberOfElutionsBatchBools],
										AspirationPositionOffset->PickList[elutionAspirationPositionOffsetsBatch,numberOfElutionsBatchBools],
										AspirationMix -> False,
										MultichannelTransfer->False
									]
								},
								Nothing
							],
							{i,1,maxNumElutions}
						]
					]
				],
				{
					elutions,elutionBuffers,elutionBufferVolumes,elutionMagnetizationTimes,elutionAspirationVolumes,elutionAspirationPositions, elutionAspirationPositionOffsets,numberOfElutions,
					elutionMixes,elutionMixTypes,elutionMixTimes,elutionMixRates,numberOfElutionMixes,
					elutionMixVolumes,elutionMixTemperatures,elutionCollectionContainers,elutionCollectionStorageConditions,
					elutionMixTipTypes,elutionMixTipMaterials,elutionDestinationWells,
					elutionCollectionContainerLabels,assayContainerLabels,assayWells,magnetizationRacks,unresolvedMagnetizationRacks,elutionBufferLabels,
					sampleOutLabels
				}
			];

			(* Label the samples out (based on selectionStrategy) with a LabelSample Primitive so the sample can be used in downstream unit ops *)
			samplesToLabelSampleOut=If[MatchQ[selectionStrategy,Positive],
				MapThread[
					Function[{containerBatch,wellBatch},
						Sequence@@MapThread[
							Function[{containers,wells},
								Sequence@@Transpose[{wells,containers}]
							],
							{containerBatch,wellBatch}
						]
					],
					{elutionCollectionContainerLabels,elutionDestinationWells}
				],
				MapThread[
					Function[{containerBatch,wellBatch},
						Sequence@@MapThread[
							Function[{containers,wells},
								Sequence@@Transpose[{wells,containers}]
							],
							{containerBatch,wellBatch}
						]
					],
					{loadingCollectionContainerLabels,loadingDestinationWells}
				]
			];

			sampleOutLabelingPrimitive=LabelSample[
				Sample->samplesToLabelSampleOut,
				Label-> Flatten@sampleOutLabels
			];

			(* Thread the primitives together in the correct order *)
			allPrimitives=Flatten[
				Join[
					labelPrimitives,
					magneticBeadPrimitives,
					MapThread[
						Join[#1,#2,#3,#4,#5,#6,#7,#8,#9,#10,#11]&,
						{preWashPrimitives,equilibrationPrimitives,loadingPrimitives,washPrimitives,secondaryWashPrimitives, tertiaryWashPrimitives, quaternaryWashPrimitives, quinaryWashPrimitives, senaryWashPrimitives, septenaryWashPrimitives,elutionPrimitives}
					],
					{sampleOutLabelingPrimitive}
				]
			];

			(* mapping between workcell name and experiment function *)
			experimentFunction = Lookup[$WorkCellToExperimentFunction, Lookup[myResolvedOptions, WorkCell], ExperimentRoboticSamplePreparation];

			(* Get our robotic unit operation packets. *)
			{{roboticUnitOperationPackets,roboticRunTime}, roboticSimulation}=experimentFunction[
				allPrimitives,
				UnitOperationPackets -> True,
				Output->{Result, Simulation},
				FastTrack -> Lookup[resolvedOptionsWithReplicates, FastTrack],
				ParentProtocol -> Lookup[resolvedOptionsWithReplicates, ParentProtocol],
				Name -> Lookup[resolvedOptionsWithReplicates, Name],
				Simulation -> currentSimulation,
				Upload -> False,
				ImageSample -> Lookup[resolvedOptionsWithReplicates, ImageSample],
				MeasureVolume -> Lookup[resolvedOptionsWithReplicates, MeasureVolume],
				MeasureWeight -> Lookup[resolvedOptionsWithReplicates, MeasureWeight],
				Priority -> Lookup[resolvedOptionsWithReplicates, Priority],
				StartDate -> Lookup[resolvedOptionsWithReplicates, StartDate],
				HoldOrder -> Lookup[resolvedOptionsWithReplicates, HoldOrder],
				QueuePosition -> Lookup[resolvedOptionsWithReplicates, QueuePosition],
				CoverAtEnd -> False
			];

			(* Figure out composition of samples here. Later use label sample, sample->samplelabel, composition ->overwrite composition
			call it one more time for only label samples. Feed down and add it to the packet. *)
			updateCompositionRoboticSimulation= Module[
				{workingSampleCompositions,magneticBeadsCompositions, magneticBeadResins,
					allCollectionContainerLabels, containerSampleInfoPackets, containerContentsPackets,
					sampleLabelsToUpdate,samplesToUpdate,compositionsToUpdate,compositionsToUpdateNoTime,
					loadingSamplesToUpdate,loadingSampleLabelsToUpdate,loadingCompositionsToUpdate,
					elutionSamplesToUpdate,elutionSampleLabelsToUpdate,elutionCompositionsToUpdate,
					preWashSamplesToUpdate,preWashSampleLabelsToUpdate,preWashCompositionsToUpdate,
					equilibrationSamplesToUpdate,equilibrationSampleLabelsToUpdate,equilibrationCompositionsToUpdate,
					washSamplesToUpdate,washSampleLabelsToUpdate,washCompositionsToUpdate,
					secondaryWashSamplesToUpdate,secondaryWashSampleLabelsToUpdate,secondaryWashCompositionsToUpdate,
					tertiaryWashSamplesToUpdate,tertiaryWashSampleLabelsToUpdate,tertiaryWashCompositionsToUpdate,
					quaternaryWashSamplesToUpdate,quaternaryWashSampleLabelsToUpdate,quaternaryWashCompositionsToUpdate,
					quinaryWashSamplesToUpdate,quinaryWashSampleLabelsToUpdate,quinaryWashCompositionsToUpdate,
					senaryWashSamplesToUpdate,senaryWashSampleLabelsToUpdate,senaryWashCompositionsToUpdate,
					septenaryWashSamplesToUpdate,septenaryWashSampleLabelsToUpdate,septenaryWashCompositionsToUpdate,
					newLabelSamplePrimitives
				},
				(*Gather all the collection container labels for use in the download*)
				allCollectionContainerLabels=DeleteCases[
					DeleteDuplicates[
						Flatten[{preWashCollectionContainerLabels,equilibrationCollectionContainerLabels,loadingCollectionContainerLabels,washCollectionContainerLabels,secondaryWashCollectionContainerLabels,tertiaryWashCollectionContainerLabels,quaternaryWashCollectionContainerLabels,quinaryWashCollectionContainerLabels,senaryWashCollectionContainerLabels,septenaryWashCollectionContainerLabels,elutionCollectionContainerLabels}]
					],
					Null
				];

				(*Make one big download call to get information from robotic simulation*)
				{
					workingSampleCompositions,
					magneticBeadsCompositions,
					containerSampleInfoPackets,
					containerContentsPackets
				}=Quiet[
					Download[
						{
							LookupLabeledObject[roboticSimulation,Flatten[sampleLabels]],
							Flatten@magneticBeads,
							LookupLabeledObject[roboticSimulation,Flatten[allCollectionContainerLabels]],
							LookupLabeledObject[roboticSimulation,Flatten[allCollectionContainerLabels]]
						},
						{
							List[Composition],
							List[Composition],
							List@Packet[Contents[[All,2]][{Volume,Composition}]],
							List@Packet[Object,Contents]
						},
						Simulation->roboticSimulation
					],
					{Download::FieldDoesntExist,Download::NotLinkField}
				];

				(*Get the magnetic bead resin from the compositions*)
				magneticBeadResins=FirstCase[Flatten[#],ObjectP[Model[Resin]],Null]&/@magneticBeadsCompositions;

				(*===Loading===*)
				{loadingSamplesToUpdate,loadingSampleLabelsToUpdate,loadingCompositionsToUpdate} = updateSamplesCompositionOfStage[
					sampleLabels,Loading,
					loadingDestinationWells, loadingCollectionContainerLabels, workingSampleCompositions,volumes,analyteAffinityLabels,targets,magneticBeadResins,
					separationMode,selectionStrategy,
					(*Downloaded packets*)
					containerSampleInfoPackets,containerContentsPackets,roboticSimulation
				];

				(*===Elution===*)
				{elutionSamplesToUpdate,elutionSampleLabelsToUpdate,elutionCompositionsToUpdate}= Module[{listOfSampleLabelsToUpdate,listOfSamplesToUpdate,listOfCompositionsToUpdate},
					listOfSampleLabelsToUpdate= {};
					listOfSamplesToUpdate= {};
					listOfCompositionsToUpdate= {};
					MapThread[
						Function[
							{
								destinationWellsBatch,
								collectionContainerLabelsBatch,
								workingSampleCompositionsBatch,
								volumesBatch,
								analyteAffinityLabelsBatch,
								targetsBatch,
								magneticBeadResinsBatch
							},
							MapThread[
								Function[
									{
										destinationWells,
										collectionContainerLabels,
										workingSampleComposition,
										volume,
										analyteAffinityLabel,
										target,
										magneticBeadResin
									},

									(*The first round of elution sample is assumed to get almost all eluted molecules at the calculated concentration, while the rest of rounds gets residual eluted molecules at unknown concentration*)

									Module[{sampleContainer,sampleToAdjust,sampleLabelToAdjust,updatedComposition},
										(*look up the fake object id of the collection container*)
										sampleContainer=LookupLabeledObject[roboticSimulation,First[collectionContainerLabels]];

										(*look up the fake sample id of the collected sample to adjust its composition*)
										sampleToAdjust=FirstCase[
											Lookup[fetchPacketFromCache[sampleContainer, Flatten@containerContentsPackets], Contents,Null],
											{First[destinationWells],x_}:>LinkedObject[x]
										];
										(*look up the label of the simulated sample*)
										sampleLabelToAdjust=LookupObjectLabel[roboticSimulation,sampleToAdjust];

										(* Call the helper function to calculate updated compositions*)
										updatedComposition=updateMBSSampleComposition[
											separationMode,
											selectionStrategy,
											workingSampleComposition,
											volume,
											analyteAffinityLabel,
											target,
											magneticBeadResin,
											(*collected elution sample volume*)
											Lookup[fetchPacketFromCache[sampleToAdjust, Flatten@containerSampleInfoPackets], Volume,Null],
											(*collected elution sample composition*)
											Lookup[fetchPacketFromCache[sampleToAdjust, Flatten@containerSampleInfoPackets], Composition,Null],
											Elution
										];
										(*Return the samples to adjust and updated composition*)
										If[!NullQ[sampleLabelToAdjust],
											listOfSampleLabelsToUpdate=AppendTo[listOfSampleLabelsToUpdate,sampleLabelToAdjust];
											listOfSamplesToUpdate=AppendTo[listOfSamplesToUpdate,sampleToAdjust];
											listOfCompositionsToUpdate=AppendTo[listOfCompositionsToUpdate,updatedComposition];
										]
									];
									If[GreaterQ[Length[destinationWells],1],
										(*If there are multiple elutions*)
										(*The rest of rounds gets residual eluted molecules at unknown concentration*)
										MapThread[
											Function[
												{destinationWell,collectionContainerLabel},
												Module[{sampleContainer,sampleToAdjust,sampleLabelToAdjust,updatedComposition},
													(*look up the fake object id of the collection container*)
													sampleContainer=LookupLabeledObject[roboticSimulation,collectionContainerLabel];
													(*look up the fake sample id of the collected sample to adjust its composition*)
													sampleToAdjust=FirstCase[
														Lookup[fetchPacketFromCache[sampleContainer, Flatten@containerContentsPackets], Contents,Null],
														{destinationWell,x_}:>LinkedObject[x]
													];
													(*look up the label of the simulated sample*)
													sampleLabelToAdjust=LookupObjectLabel[roboticSimulation,sampleToAdjust];

													(* Call the helper function to calculate updated compositions*)
													updatedComposition=updateMBSSampleComposition[
														separationMode,
														selectionStrategy,
														workingSampleComposition,
														volume,
														analyteAffinityLabel,
														target,
														magneticBeadResin,
														(*collected elution sample volume*)
														Lookup[fetchPacketFromCache[sampleToAdjust, Flatten@containerSampleInfoPackets], Volume,Null],
														(*collected elution sample composition*)
														Lookup[fetchPacketFromCache[sampleToAdjust, Flatten@containerSampleInfoPackets], Composition,Null],
														AdditionalElution
													];

													(*Return the samples to adjust and updated composition*)
													If[!NullQ[sampleLabelToAdjust],
														AppendTo[listOfSampleLabelsToUpdate,sampleLabelToAdjust];
														AppendTo[listOfSamplesToUpdate,sampleToAdjust];
														AppendTo[listOfCompositionsToUpdate,updatedComposition];
													]
												]
											],
											{Rest[destinationWells],Rest[collectionContainerLabels]}
										]
									]
								],
								{
									destinationWellsBatch,
									collectionContainerLabelsBatch,
									workingSampleCompositionsBatch,
									volumesBatch,
									analyteAffinityLabelsBatch,
									targetsBatch,
									magneticBeadResinsBatch
								}
							];
						],
						{
							elutionDestinationWells,
							elutionCollectionContainerLabels,
							unflattenListHelper[workingSampleCompositions,sampleLabels],
							volumes,
							analyteAffinityLabels,
							targets,
							unflattenListHelper[magneticBeadResins,sampleLabels]
						}
					];
					(*Return the updated lists*)
					{listOfSamplesToUpdate,listOfSampleLabelsToUpdate,listOfCompositionsToUpdate}
				];
				(*===PreWash===*)
				{preWashSamplesToUpdate,preWashSampleLabelsToUpdate,preWashCompositionsToUpdate} = updateSamplesCompositionOfStage[
					sampleLabels,PreWash,
					preWashDestinationWells, preWashCollectionContainerLabels, workingSampleCompositions,volumes,analyteAffinityLabels,targets,magneticBeadResins,
					separationMode,selectionStrategy,
					(*Downloaded packets*)
					containerSampleInfoPackets,containerContentsPackets,roboticSimulation
				];

				(*===Equilibration===*)
				{equilibrationSamplesToUpdate,equilibrationSampleLabelsToUpdate,equilibrationCompositionsToUpdate} = updateSamplesCompositionOfStage[
					sampleLabels,Equilibration,
					equilibrationDestinationWells, equilibrationCollectionContainerLabels, workingSampleCompositions,volumes,analyteAffinityLabels,targets,magneticBeadResins,
					separationMode,selectionStrategy,
					(*Downloaded packets*)
					containerSampleInfoPackets,containerContentsPackets,roboticSimulation
				];
				(*===Wash===*)
				{washSamplesToUpdate,washSampleLabelsToUpdate,washCompositionsToUpdate} = updateSamplesCompositionOfStage[
					sampleLabels,Wash,
					washDestinationWells, washCollectionContainerLabels, workingSampleCompositions,volumes,analyteAffinityLabels,targets,magneticBeadResins,
					separationMode,selectionStrategy,
					(*Downloaded packets*)
					containerSampleInfoPackets,containerContentsPackets,roboticSimulation
				];

				(*===SecondaryWash===*)
				{secondaryWashSamplesToUpdate,secondaryWashSampleLabelsToUpdate,secondaryWashCompositionsToUpdate} = updateSamplesCompositionOfStage[
					sampleLabels,Wash,
					secondaryWashDestinationWells, secondaryWashCollectionContainerLabels, workingSampleCompositions,volumes,analyteAffinityLabels,targets,magneticBeadResins,
					separationMode,selectionStrategy,
					(*Downloaded packets*)
					containerSampleInfoPackets,containerContentsPackets,roboticSimulation
				];

				(*===TertiaryWash===*)
				{tertiaryWashSamplesToUpdate,tertiaryWashSampleLabelsToUpdate,tertiaryWashCompositionsToUpdate} = updateSamplesCompositionOfStage[
					sampleLabels,Wash,
					tertiaryWashDestinationWells, tertiaryWashCollectionContainerLabels, workingSampleCompositions,volumes,analyteAffinityLabels,targets,magneticBeadResins,
					separationMode,selectionStrategy,
					(*Downloaded packets*)
					containerSampleInfoPackets,containerContentsPackets,roboticSimulation
				];

				(*===QuaternaryWash===*)
				{quaternaryWashSamplesToUpdate,quaternaryWashSampleLabelsToUpdate,quaternaryWashCompositionsToUpdate} = updateSamplesCompositionOfStage[
					sampleLabels,Wash,
					quaternaryWashDestinationWells, quaternaryWashCollectionContainerLabels, workingSampleCompositions,volumes,analyteAffinityLabels,targets,magneticBeadResins,
					separationMode,selectionStrategy,
					(*Downloaded packets*)
					containerSampleInfoPackets,containerContentsPackets,roboticSimulation
				];

				(*===QuinaryWash===*)
				{quinaryWashSamplesToUpdate,quinaryWashSampleLabelsToUpdate,quinaryWashCompositionsToUpdate} = updateSamplesCompositionOfStage[
					sampleLabels,Wash,
					quinaryWashDestinationWells, quinaryWashCollectionContainerLabels, workingSampleCompositions,volumes,analyteAffinityLabels,targets,magneticBeadResins,
					separationMode,selectionStrategy,
					(*Downloaded packets*)
					containerSampleInfoPackets,containerContentsPackets,roboticSimulation
				];

				(*===SenaryWash===*)
				{senaryWashSamplesToUpdate,senaryWashSampleLabelsToUpdate,senaryWashCompositionsToUpdate} = updateSamplesCompositionOfStage[
					sampleLabels,Wash,
					senaryWashDestinationWells, senaryWashCollectionContainerLabels, workingSampleCompositions,volumes,analyteAffinityLabels,targets,magneticBeadResins,
					separationMode,selectionStrategy,
					(*Downloaded packets*)
					containerSampleInfoPackets,containerContentsPackets,roboticSimulation
				];

				(*===SeptenaryWash===*)
				{septenaryWashSamplesToUpdate,septenaryWashSampleLabelsToUpdate,septenaryWashCompositionsToUpdate} = updateSamplesCompositionOfStage[
					sampleLabels,Wash,
					septenaryWashDestinationWells, septenaryWashCollectionContainerLabels, workingSampleCompositions,volumes,analyteAffinityLabels,targets,magneticBeadResins,
					separationMode,selectionStrategy,
					(*Downloaded packets*)
					containerSampleInfoPackets,containerContentsPackets,roboticSimulation
				];

				sampleLabelsToUpdate=Join[
					preWashSampleLabelsToUpdate, equilibrationSampleLabelsToUpdate, loadingSampleLabelsToUpdate, washSampleLabelsToUpdate, secondaryWashSampleLabelsToUpdate, tertiaryWashSampleLabelsToUpdate, quaternaryWashSampleLabelsToUpdate, quinaryWashSampleLabelsToUpdate, senaryWashSampleLabelsToUpdate, septenaryWashSampleLabelsToUpdate, elutionSampleLabelsToUpdate
				];

				compositionsToUpdate=Join[
					preWashCompositionsToUpdate, equilibrationCompositionsToUpdate, loadingCompositionsToUpdate, washCompositionsToUpdate, secondaryWashCompositionsToUpdate, tertiaryWashCompositionsToUpdate, quaternaryWashCompositionsToUpdate, quinaryWashCompositionsToUpdate, senaryWashCompositionsToUpdate, septenaryWashCompositionsToUpdate, elutionCompositionsToUpdate
				];

        compositionsToUpdateNoTime=compositionsToUpdate[[All,All,{1,2}]];


				(*Update the compositions in simulation*)
				newLabelSamplePrimitives=LabelSample[
					Sample->sampleLabelsToUpdate,
					Label->sampleLabelsToUpdate,
					Composition->compositionsToUpdateNoTime/.x:ObjectP[]:>Link[x]
				];

				experimentFunction[
					newLabelSamplePrimitives,
					UnitOperationPackets -> False,
					Output->Simulation,
					Simulation -> roboticSimulation,
					Upload -> False
				]
			];
			(*Update the simulation with new compositions
			roboticSimulation=UpdateSimulation[roboticSimulation,updateCompositionRoboticSimulation];*)
			(* Replace the Resources in the roboticUnitOperationPackets that correspond to the input samples with the *)
			(* resource with a name created at the beginning of the resource packets function. This is to prevent duplicate *)
			(* resources being generated when the input Sample has to be Aliquoted to a new container *)
			roboticUnitOperationPacketsCorrectedResources=roboticUnitOperationPackets/.samplesInResourcesReplacementRules;
			myNormalizedResolvedOptions=ReplaceRule[
				myResolvedOptions,
				{
					PreWashCollectionContainer->normalizeResolvedContainersForUnitOperation[Lookup[myResolvedOptions,PreWashCollectionContainer]],
					PreWashDestinationWell->normalizeResolvedContainersForUnitOperation[Lookup[myResolvedOptions,PreWashDestinationWell]],
					PreWashCollectionContainerIndex->normalizeResolvedContainersForUnitOperation[Lookup[myResolvedOptions,PreWashCollectionContainerIndex]],
					EquilibrationCollectionContainer->normalizeResolvedContainersForUnitOperation[Lookup[myResolvedOptions,EquilibrationCollectionContainer]],
					EquilibrationDestinationWell->normalizeResolvedContainersForUnitOperation[Lookup[myResolvedOptions,EquilibrationDestinationWell]],
					EquilibrationCollectionContainerIndex->normalizeResolvedContainersForUnitOperation[Lookup[myResolvedOptions,EquilibrationCollectionContainerIndex]],
					LoadingCollectionContainer->normalizeResolvedContainersForUnitOperation[Lookup[myResolvedOptions,LoadingCollectionContainer]],
					LoadingDestinationWell->normalizeResolvedContainersForUnitOperation[Lookup[myResolvedOptions,LoadingDestinationWell]],
					LoadingCollectionContainerIndex->normalizeResolvedContainersForUnitOperation[Lookup[myResolvedOptions,LoadingCollectionContainerIndex]],
					WashCollectionContainer->normalizeResolvedContainersForUnitOperation[Lookup[myResolvedOptions,WashCollectionContainer]],
					WashDestinationWell->normalizeResolvedContainersForUnitOperation[Lookup[myResolvedOptions,WashDestinationWell]],
					WashCollectionContainerIndex->normalizeResolvedContainersForUnitOperation[Lookup[myResolvedOptions,WashCollectionContainerIndex]],
					SecondaryWashCollectionContainer->normalizeResolvedContainersForUnitOperation[Lookup[myResolvedOptions,SecondaryWashCollectionContainer]],
					SecondaryWashDestinationWell->normalizeResolvedContainersForUnitOperation[Lookup[myResolvedOptions,SecondaryWashDestinationWell]],
					SecondaryWashCollectionContainerIndex->normalizeResolvedContainersForUnitOperation[Lookup[myResolvedOptions,SecondaryWashCollectionContainerIndex]],
					TertiaryWashCollectionContainer->normalizeResolvedContainersForUnitOperation[Lookup[myResolvedOptions,TertiaryWashCollectionContainer]],
					TertiaryWashDestinationWell->normalizeResolvedContainersForUnitOperation[Lookup[myResolvedOptions,TertiaryWashDestinationWell]],
					TertiaryWashCollectionContainerIndex->normalizeResolvedContainersForUnitOperation[Lookup[myResolvedOptions,TertiaryWashCollectionContainerIndex]],
					QuaternaryWashCollectionContainer->normalizeResolvedContainersForUnitOperation[Lookup[myResolvedOptions,QuaternaryWashCollectionContainer]],
					QuaternaryWashDestinationWell->normalizeResolvedContainersForUnitOperation[Lookup[myResolvedOptions,QuaternaryWashDestinationWell]],
					QuaternaryWashCollectionContainerIndex->normalizeResolvedContainersForUnitOperation[Lookup[myResolvedOptions,QuaternaryWashCollectionContainerIndex]],
					QuinaryWashCollectionContainer->normalizeResolvedContainersForUnitOperation[Lookup[myResolvedOptions,QuinaryWashCollectionContainer]],
					QuinaryWashDestinationWell->normalizeResolvedContainersForUnitOperation[Lookup[myResolvedOptions,QuinaryWashDestinationWell]],
					QuinaryWashCollectionContainerIndex->normalizeResolvedContainersForUnitOperation[Lookup[myResolvedOptions,QuinaryWashCollectionContainerIndex]],
					SenaryWashCollectionContainer->normalizeResolvedContainersForUnitOperation[Lookup[myResolvedOptions,SenaryWashCollectionContainer]],
					SenaryWashDestinationWell->normalizeResolvedContainersForUnitOperation[Lookup[myResolvedOptions,SenaryWashDestinationWell]],
					SenaryWashCollectionContainerIndex->normalizeResolvedContainersForUnitOperation[Lookup[myResolvedOptions,SenaryWashCollectionContainerIndex]],
					SeptenaryWashCollectionContainer->normalizeResolvedContainersForUnitOperation[Lookup[myResolvedOptions,SeptenaryWashCollectionContainer]],
					SeptenaryWashDestinationWell->normalizeResolvedContainersForUnitOperation[Lookup[myResolvedOptions,SeptenaryWashDestinationWell]],
					SeptenaryWashCollectionContainerIndex->normalizeResolvedContainersForUnitOperation[Lookup[myResolvedOptions,SeptenaryWashCollectionContainerIndex]],
					ElutionCollectionContainer->normalizeResolvedContainersForUnitOperation[Lookup[myResolvedOptions,ElutionCollectionContainer]],
					ElutionDestinationWell->normalizeResolvedContainersForUnitOperation[Lookup[myResolvedOptions,ElutionDestinationWell]],
					ElutionCollectionContainerIndex->normalizeResolvedContainersForUnitOperation[Lookup[myResolvedOptions,ElutionCollectionContainerIndex]]
				}
			];

			(* determine which objects in the simulation are simulated and make replace rules for those *)
			simulatedObjectsToLabel = If[NullQ[roboticSimulation],
				{},
				Module[{allObjectsInSimulation, simulatedQ},
					(* Get all objects out of our simulation. *)
					allObjectsInSimulation = Download[Lookup[roboticSimulation[[1]], Labels][[All, 2]], Object];

					(* Figure out which objects are simulated. *)
					simulatedQ = Experiment`Private`simulatedObjectQs[allObjectsInSimulation, roboticSimulation];

					(Reverse /@ PickList[Lookup[roboticSimulation[[1]], Labels], simulatedQ]) /. {link_Link :> Download[link, Object]}
				]
			];

			(* get the resolved options with simulated objects replaced with labels *)
			expandedResolvedOptionsWithLabels = myNormalizedResolvedOptions /. simulatedObjectsToLabel;

			simulatedSamplesWithLabels = myNestedSamples /. simulatedObjectsToLabel;

			(* Create our own output unit operation packet, linking up the "sub" robotic unit operation objects. *)
			outputUnitOperationPacket=UploadUnitOperation[
				Module[{nonHiddenOptions},
					nonHiddenOptions=allowedKeysForUnitOperationType[Object[UnitOperation,MagneticBeadSeparation]];
					(* Override any options with resource. *)
					{
						If[NullQ[newLabelSampleUO], Nothing, newLabelSampleUO],
						MagneticBeadSeparation@Join[
						Cases[expandedResolvedOptionsWithLabels, Verbatim[Rule][Alternatives @@ nonHiddenOptions, _]],
						{
							Sample -> simulatedSamplesWithLabels,
							SampleResources -> samplesInResources /. oldResourceToNewResourceRules,
							RoboticUnitOperations -> (Link /@ Lookup[roboticUnitOperationPacketsCorrectedResources, Object])
						}
					]}
				],
				UnitOperationType->Output,
				Upload->False
			];

			(* NOTE: Should probably use SimulateResources[...] here but this is quicker. *)
			roboticSimulation=UpdateSimulation[
				updateCompositionRoboticSimulation,
				Module[{protocolPacket},
					protocolPacket=<|
						Object->SimulateCreateID[Object[Protocol,RoboticSamplePreparation]],
						Replace[OutputUnitOperations]->(Link[Lookup[outputUnitOperationPacket,Object], Protocol]),
						ResolvedOptions->{}
					|>;

					SimulateResources[protocolPacket, ToList@outputUnitOperationPacket, ParentProtocol->Lookup[myResolvedOptions, ParentProtocol, Null], Simulation->currentSimulation]
				]
			];

			(* since we are putting this UO inside RSP, we should re-do the LabelFields so they link via RoboticUnitOperations *)
			roboticSimulation=If[Length[roboticUnitOperationPackets]==0,
				roboticSimulation,
				updateLabelFieldReferences[roboticSimulation,RoboticUnitOperations]
			];

			(* Return back our packets and simulation. *)
			{
				Null,
				Flatten[{outputUnitOperationPacket, roboticUnitOperationPackets}],
				roboticSimulation,
				(* Add 10 min to the sub RoboticUnitOperations *)
				(roboticRunTime+10Minute)
			}
		]
	];

	(* make list of all the resources we need to check in FRQ *)
	allResourceBlobs = If[MatchQ[preparation, Manual],
		DeleteDuplicates[Cases[Flatten[Values[protocolPacket]],_Resource,Infinity]],
		{}
	];

	(* Verify we can satisfy all our resources *)
	{resourcesOk,resourceTests}=Which[
		(* NOTE: If we're robotic, the framework will call FRQ for us. *)
		MatchQ[$ECLApplication,Engine] || MatchQ[preparation, Robotic],
		{True,{}},
		gatherTests,
			Resources`Private`fulfillableResourceQ[allResourceBlobs,Output->{Result,Tests},FastTrack->Lookup[myResolvedOptions,FastTrack],Site->Lookup[myResolvedOptions,Site],Cache->inheritedCache,Simulation->currentSimulation],
		True,
			{Resources`Private`fulfillableResourceQ[allResourceBlobs,FastTrack->Lookup[myResolvedOptions,FastTrack],Site->Lookup[myResolvedOptions,Site],Messages->messages,Cache->inheritedCache,Simulation->currentSimulation],Null}
	];

	(* --- Output --- *)
	(* generate the Preview option; that is always Null *)
	previewRule=Preview->Null;

	(* generate the options output rule *)
	optionsRule=Options->If[MemberQ[output,Options],
		resolvedOptionsNoHidden,
		Null
	];

	(* generate the tests rule *)
	testsRule=Tests->If[gatherTests,
		resourceTests,
		{}
	];

	(* generate the Result output rule *)
	(* if not returning Result, or the resources are not fulfillable, Results rule is just $Failed *)
	resultRule=Result->If[MemberQ[output,Result]&&TrueQ[resourcesOk],
		{Flatten[{protocolPacket,allUnitOperationPackets}], currentSimulation, runTime},
		$Failed
	];

	(* generate the simulation rule *)
	simulationRule=Simulation->currentSimulation;

	(* return the output as we desire it *)
	outputSpecification/.{previewRule,optionsRule,resultRule,testsRule}
];


(* ::Subsubsection::Closed:: *)
(*resolveExperimentMagneticBeadSeparationWorkCell*)



resolveExperimentMagneticBeadSeparationWorkCell[
	mySemiNestedInputs:ListableP[ListableP[ObjectP[{Object[Sample],Object[Container],Model[Sample]}]|_String|{LocationPositionP,_String|ObjectP[Object[Container]]}]],
	myOptions:OptionsPattern[]
]:=Module[
	{workCell,rateOptions,tempOptions},

	workCell=Lookup[myOptions,WorkCell,Automatic];
	rateOptions=Flatten[
		{
			Lookup[myOptions, PreWashMixRate],
			Lookup[myOptions, EquilibrationMixRate],
			Lookup[myOptions, LoadingMixRate],
			Lookup[myOptions, WashMixRate],
			Lookup[myOptions, SecondaryWashMixRate],
			Lookup[myOptions, TertiaryWashMixRate],
			Lookup[myOptions, QuaternaryWashMixRate],
			Lookup[myOptions, QuinaryWashMixRate],
			Lookup[myOptions, SenaryWashMixRate],
			Lookup[myOptions, SeptenaryWashMixRate],
			Lookup[myOptions, ElutionMixRate]
		}];
	tempOptions=Flatten[
		{
			Lookup[myOptions, PreWashMixTemperature],
			Lookup[myOptions, EquilibrationMixTemperature],
			Lookup[myOptions, LoadingMixTemperature],
			Lookup[myOptions, WashMixTemperature],
			Lookup[myOptions, SecondaryWashMixTemperature],
			Lookup[myOptions, TertiaryWashMixTemperature],
			Lookup[myOptions, QuaternaryWashMixTemperature],
			Lookup[myOptions, QuinaryWashMixTemperature],
			Lookup[myOptions, SenaryWashMixTemperature],
			Lookup[myOptions, SeptenaryWashMixTemperature],
			Lookup[myOptions, ElutionMixTemperature]
		}];

	(* Determine the WorkCell that can be used *)
	If[MatchQ[workCell,Except[Automatic]],
		{workCell},
		Which[
			MemberQ[rateOptions, GreaterP[$MaxBioSTARMixRate]],
			{STAR},
			MemberQ[rateOptions, LessP[$MinBioSTARMixRate]],
			{STAR},

			(* NOTE: The bioSTAR/microbioSTAR can achieve the full 0 C - 110 C temperature range. The STARs/STARlets can only do 0 C - 105 C. *)
			MemberQ[tempOptions, GreaterP[$MaxSTARIncubationTemperature]],
			{bioSTAR, microbioSTAR},
			True,
			(* All*)
			{STAR,bioSTAR,microbioSTAR}
		]
	]
];


(* ::Subsection::Closed:: *)
(*ExperimentMagneticBeadSeparationOptions*)


DefineOptions[ExperimentMagneticBeadSeparationOptions,
	Options:>{
		{
			OptionName->OutputFormat,
			Default->Table,
			AllowNull->False,
			Widget->Widget[Type->Enumeration,Pattern:>Alternatives[Table,List]],
			Description->"Indicates whether the function returns a table or a list of the options."
		}
	},
	SharedOptions:>{ExperimentMagneticBeadSeparation}
];


ExperimentMagneticBeadSeparationOptions[
	myInputs:ListableP[ListableP[ObjectP[{Object[Sample],Object[Container],Model[Sample]}]|_String]],
	myOptions:OptionsPattern[ExperimentMagneticBeadSeparationOptions]
]:=Module[
	{listedOptions,preparedOptions,resolvedOptions},

	(*Get the options as a list*)
	listedOptions=ToList[myOptions];

	(*Send in the correct Output option and remove the OutputFormat option*)
	preparedOptions=Normal[KeyDrop[Append[listedOptions,Output->Options],{OutputFormat}],Association];

	resolvedOptions=ExperimentMagneticBeadSeparation[myInputs,preparedOptions];

	(*Return the option as a list or table*)
	If[MatchQ[OptionDefault[OptionValue[OutputFormat]],Table]&&MatchQ[resolvedOptions,{(_Rule|_RuleDelayed)..}],
		LegacySLL`Private`optionsToTable[resolvedOptions,ExperimentMagneticBeadSeparation],
		resolvedOptions
	]
];


(* ::Subsection::Closed:: *)
(*ExperimentMagneticBeadSeparationPreview*)


DefineOptions[ExperimentMagneticBeadSeparationPreview,
	SharedOptions:>{ExperimentMagneticBeadSeparation}
];


ExperimentMagneticBeadSeparationPreview[
	myInputs:ListableP[ListableP[ObjectP[{Object[Sample],Object[Container],Model[Sample]}]|_String]],
	myOptions:OptionsPattern[ExperimentMagneticBeadSeparationPreview]
]:=Module[
	{listedOptions},

	(*Get the options as a list*)
	listedOptions=ToList[myOptions];

	ExperimentMagneticBeadSeparation[myInputs,ReplaceRule[listedOptions,Output->Preview]]
];


(* ::Subsection::Closed:: *)
(*ValidMagneticBeadSeparationQ*)


DefineOptions[ValidExperimentMagneticBeadSeparationQ,
	Options:>{VerboseOption,OutputFormatOption},
	SharedOptions:>{ExperimentMagneticBeadSeparation}
];


ValidExperimentMagneticBeadSeparationQ[
	myInputs:ListableP[ListableP[ObjectP[{Object[Sample],Object[Container],Model[Sample]}]|_String]],
	myOptions:OptionsPattern[ValidExperimentMagneticBeadSeparationQ]
]:=Module[
	{listedOptions,preparedOptions,experimentMagneticBeadSeparationTests,initialTestDescription,allTests,verbose,outputFormat},

	(*Get the options as a list*)
	listedOptions=ToList[myOptions];

	(*Remove the output option before passing to the core function because it doesn't make sense here*)
	preparedOptions=DeleteCases[listedOptions,(Output|Verbose|OutputFormat)->_];

	(*Call the ExperimentMagneticBeadSeparation function to get a list of tests*)
	experimentMagneticBeadSeparationTests=Quiet[
		ExperimentMagneticBeadSeparation[myInputs,Append[preparedOptions,Output->Tests]],
		{LinkObject::linkd,LinkObject::linkn}
	];

	(*Define the general test description*)
	initialTestDescription="All provided options and inputs match their provided patterns (no further testing can proceed if this test fails):";

	(*Make a list of all of the tests, including the blanket test*)
	allTests=If[MatchQ[experimentMagneticBeadSeparationTests,$Failed],
		{Test[initialTestDescription,False,True]},
		Module[{initialTest,validObjectBooleans,voqWarnings},

			(*Generate the initial test, which should pass if we got this far*)
			initialTest=Test[initialTestDescription,True,True];

			(*Create warnings for invalid objects*)
			validObjectBooleans=ValidObjectQ[Cases[Flatten[myInputs],ObjectP[]],OutputFormat->Boolean];

			voqWarnings=MapThread[
				Warning[StringJoin[ToString[#1,InputForm]," is valid (run ValidObjectQ for more detailed information):"],
					#2,
					True
				]&,
				{Cases[Flatten[myInputs],ObjectP[]],validObjectBooleans}
			];

			(*Get all the tests/warnings*)
			Cases[Flatten[{initialTest,experimentMagneticBeadSeparationTests,voqWarnings}],_EmeraldTest]
		]
	];

	(*Look up the test-running options*)
	{verbose,outputFormat}=Quiet[OptionDefault[OptionValue[{Verbose,OutputFormat}]],OptionValue::nodef];

	(*Run the tests as requested*)
	Lookup[RunUnitTest[<|"ValidExperimentMagneticBeadSeparationQ"->allTests|>,Verbose->verbose,
		OutputFormat->outputFormat],"ValidExperimentMagneticBeadSeparationQ"]
];


(* ::Subsection:: *)
(*Simulation*)


(* ::Subsubsection:: *)
(*simulateExperimentMagneticBeadSeparation*)


DefineOptions[simulateExperimentMagneticBeadSeparation,
	Options:>{CacheOption,SimulationOption}
];

simulateExperimentMagneticBeadSeparation[
	myProtocolPacket:(PacketP[Object[Protocol, MagneticBeadSeparation], {Object, ResolvedOptions}]|$Failed|Null),
	myUnitOperationPackets:({PacketP[]...}|$Failed),
	myNestedSamples:ListableP[{ObjectP[Object[Sample]]..}],
	myResolvedOptions:{_Rule..},
	myResolutionOptions:OptionsPattern[simulateExperimentMagneticBeadSeparation]
] := Module[
	{
		inheritedCache, inheritedFastAssoc, currentSimulation, protocolObject, resolvedPreparation,

		(* Downloaded info *)
		workingSamples,volumes,magneticBeads,magneticBeadVolumes,magnetizationRacks,assayContainers,assayWells,separationMode,analyteAffinityLabels,targets,magneticBeadAffinityLabels,selectionStrategy,samplesOut,
		preWashes,preWashBuffers,preWashBufferVolumes,preWashAspirationVolumes,numberOfPreWashes,preWashCollectionContainers,preWashCollectionStorageConditions,preWashDestinationWells,
		equilibrations,equilibrationBuffers,equilibrationBufferVolumes,equilibrationAspirationVolumes,equilibrationCollectionContainers,equilibrationCollectionStorageConditions,equilibrationDestinationWells,
		loadingAspirationVolumes,loadingCollectionContainers,loadingCollectionStorageConditions,loadingDestinationWells,
		washes,washBuffers,washBufferVolumes,washAspirationVolumes,numberOfWashes,washCollectionContainers,washCollectionStorageConditions,washDestinationWells,
		secondaryWashes,secondaryWashBuffers,secondaryWashBufferVolumes,secondaryWashAspirationVolumes,numberOfSecondaryWashes,secondaryWashCollectionContainers,secondaryWashCollectionStorageConditions,secondaryWashDestinationWells,
		tertiaryWashes,tertiaryWashBuffers,tertiaryWashBufferVolumes,tertiaryWashAspirationVolumes,numberOfTertiaryWashes,tertiaryWashCollectionContainers,tertiaryWashCollectionStorageConditions,tertiaryWashDestinationWells,
		quaternaryWashes,quaternaryWashBuffers,quaternaryWashBufferVolumes,quaternaryWashAspirationVolumes,numberOfQuaternaryWashes,quaternaryWashCollectionContainers,quaternaryWashCollectionStorageConditions,quaternaryWashDestinationWells,
		quinaryWashes,quinaryWashBuffers,quinaryWashBufferVolumes,quinaryWashAspirationVolumes,numberOfQuinaryWashes,quinaryWashCollectionContainers,quinaryWashCollectionStorageConditions,quinaryWashDestinationWells,
		senaryWashes,senaryWashBuffers,senaryWashBufferVolumes,senaryWashAspirationVolumes,numberOfSenaryWashes,senaryWashCollectionContainers,senaryWashCollectionStorageConditions,senaryWashDestinationWells,
		septenaryWashes,septenaryWashBuffers,septenaryWashBufferVolumes,septenaryWashAspirationVolumes,numberOfSeptenaryWashes,septenaryWashCollectionContainers,septenaryWashCollectionStorageConditions,septenaryWashDestinationWells,
		elutions,elutionBuffers,elutionBufferVolumes,elutionAspirationVolumes,numberOfElutions,elutionCollectionContainers,elutionCollectionStorageConditions,elutionDestinationWells,

		(* updated cache creation *)
		combinedCache,combinedFastAssoc,

		(* collected sources dests amts *)
		magneticBeadTuples,preWashTuples,flattenedPreWashTuples,equilibrationTuples,loadingTuples,washTuples,flattenedWashTuples,secondaryWashTuples,flattenedSecondaryWashTuples,tertiaryWashTuples,flattenedTertiaryWashTuples,quaternaryWashTuples,flattenedQuaternaryWashTuples,quinaryWashTuples,flattenedQuinaryWashTuples,senaryWashTuples,flattenedSenaryWashTuples,septenaryWashTuples,flattenedSeptenaryWashTuples,elutionTuples,flattenedElutionTuples,

		(* Simulating the Transfers *)
		groupedTuples,tuplesWithCorrectFormat,destNoSampleFunc,destinationsWithoutSamples,uploadSamplePackets,containerPackets,tuplesWithAllObjectSamples,
		uploadSampleTransferPackets,simulatedSamplesOut,simulatedLabels
	},

	(* Get simulation and cache *)
	{inheritedCache, currentSimulation} = Lookup[ToList[myResolutionOptions], {Cache,Simulation}, {}];

	(* Create a faster version of the cache to improve speed *)
	inheritedFastAssoc=makeFastAssocFromCache[inheritedCache];

	(* Get our protocol ID. This should already be in our protocol packet, unless the resource packets failed. *)
	protocolObject=Which[
		(* NOTE: If myProtocolPacket is $Failed, we had a problem in the option resolver. *)
		MatchQ[myProtocolPacket, $Failed],
		SimulateCreateID[Object[Protocol,MagneticBeadSeparation]],
		True,
		Lookup[myProtocolPacket, Object]
	];

	(* Lookup our resolved preparation. *)
	resolvedPreparation=Lookup[myResolvedOptions, Preparation];

	(* Simulate the fulfillment of all resources by the procedure. *)
	(* NOTE: We won't actually get back a resource packet if there was a problem during option resolution. In that case, *)
	(* just make a shell of a protocol object so that we can return something back. *)
	currentSimulation=Which[
	(* If we have a $Failed for the protocol packet, that means that we had a problem in option resolving *)
	(* and skipped resource packet generation. *)
		MatchQ[myProtocolPacket, $Failed],

		Module[
			{
				(* Option values *)
				magneticBeads,magneticBeadVolumes,assayContainers,volumes,aliquotAmounts,magnetizationRacks,
				preWashes,preWashBuffers,preWashBufferVolumes,numberOfPreWashes,preWashCollectionContainers,preWashCollectionContainerLabels,preWashCollectionStorageConditions,
				equilibrations,equilibrationBuffers,equilibrationBufferVolumes,equilibrationCollectionContainers,equilibrationCollectionContainerLabels,equilibrationCollectionStorageConditions,
				loadingCollectionContainers,loadingCollectionContainerLabels,loadingCollectionStorageConditions,
				washes,washBuffers,washBufferVolumes,numberOfWashes,washCollectionContainers,washCollectionContainerLabels,washCollectionStorageConditions,
				elutions,elutionBuffers,elutionBufferVolumes,numberOfElutions,elutionCollectionContainers,elutionCollectionContainerLabels,elutionCollectionStorageConditions,
				preWashCollectionContainerIndices,equilibrationCollectionContainerIndices,loadingCollectionContainerIndices,washCollectionContainerIndices,elutionCollectionContainerIndices,
				secondaryWashCollectionContainers,secondaryWashCollectionContainerIndices, secondaryWashCollectionStorageConditions, secondaryWashes,
				tertiaryWashCollectionContainers, tertiaryWashCollectionContainerIndices, tertiaryWashCollectionStorageConditions, tertiaryWashes,
				quaternaryWashCollectionContainers, quaternaryWashCollectionContainerIndices,  quaternaryWashCollectionStorageConditions, quaternaryWashes,
				quinaryWashCollectionContainers,  quinaryWashCollectionContainerIndices, quinaryWashCollectionStorageConditions, quinaryWashes,
				senaryWashCollectionContainers,  senaryWashCollectionContainerIndices, senaryWashCollectionStorageConditions, senaryWashes,
				septenaryWashCollectionContainers, septenaryWashCollectionContainerIndices,  septenaryWashCollectionStorageConditions, septenaryWashes,

				secondaryWashCollectionContainerLabels, secondaryWashDestinationWells, tertiaryWashCollectionContainerLabels, tertiaryWashDestinationWells, quaternaryWashCollectionContainerLabels, quaternaryWashDestinationWells, quinaryWashCollectionContainerLabels, quinaryWashDestinationWells, senaryWashCollectionContainerLabels, senaryWashDestinationWells, septenaryWashCollectionContainerLabels, septenaryWashDestinationWells,

				collectionContainerLookup,

				containersIn,uniqueContainersIn,uniqueSamplesInResources,samplesInResources,
				magneticBeadVolumeRules,uniqueMagneticBeadsAndVolumesAssoc,
				assayContainerLookup,assayContainerMapOutput,assayWells,uniqueAssayPlates,
				preWashBufferVolumeRules,uniquePreWashBuffersAndVolumesAssoc,flatPreWashCollectionContainers,uniqueFlatPreWashCollectionPlates,
				equilibrationBufferVolumeRules,uniqueEquilibrationBuffersAndVolumesAssoc,flatEquilibrationCollectionContainers,
				uniqueFlatEquilibrationCollectionPlates,flatLoadingCollectionContainers,uniqueFlatLoadingCollectionPlates,
				washBufferVolumeRules,uniqueWashBuffersAndVolumesAssoc,flatWashCollectionContainers,uniqueFlatWashCollectionPlates,
				secondaryWashBufferVolumeRules,uniqueSecondaryWashBuffersAndVolumesAssoc,flatSecondaryWashCollectionContainers,uniqueFlatSecondaryWashCollectionPlates,
				tertiaryWashBufferVolumeRules,uniqueTertiaryWashBuffersAndVolumesAssoc,flatTertiaryWashCollectionContainers,uniqueFlatTertiaryWashCollectionPlates,
				quaternaryWashBufferVolumeRules,uniqueQuaternaryWashBuffersAndVolumesAssoc,flatQuaternaryWashCollectionContainers,uniqueFlatQuaternaryWashCollectionPlates,
				quinaryWashBufferVolumeRules,uniqueQuinaryWashBuffersAndVolumesAssoc,flatQuinaryWashCollectionContainers,uniqueFlatQuinaryWashCollectionPlates,
				senaryWashBufferVolumeRules,uniqueSenaryWashBuffersAndVolumesAssoc,flatSenaryWashCollectionContainers,uniqueFlatSenaryWashCollectionPlates,
				septenaryWashBufferVolumeRules,uniqueSeptenaryWashBuffersAndVolumesAssoc,flatSeptenaryWashCollectionContainers,uniqueFlatSeptenaryWashCollectionPlates,

				convertedPreWashCollectionContainers,convertedEquilibrationCollectionContainers,convertedLoadingCollectionContainers,convertedWashCollectionContainers,convertedSecondaryWashCollectionContainers,convertedTertiaryWashCollectionContainers,
				convertedQuaternaryWashCollectionContainers,convertedQuinaryWashCollectionContainers,convertedSenaryWashCollectionContainers,convertedSeptenaryWashCollectionContainers,convertedElutionCollectionContainers,

				preWashCollectionContainerResources,equilibrationCollectionContainerResources,loadingCollectionContainerResources,washCollectionContainerResources,secondaryWashCollectionContainerResources,tertiaryWashCollectionContainerResources,quaternaryWashCollectionContainerResources,quinaryWashCollectionContainerResources,senaryWashCollectionContainerResources,septenaryWashCollectionContainerResources,elutionCollectionContainerResources,

				elutionBufferVolumeRules,
				uniqueElutionBuffersAndVolumesAssoc,flatElutionCollectionContainers,uniqueFlatElutionCollectionPlates,uniqueSampleResourceLookup,uniquePlateResourceLookup,uniqueAssayPlateResourceLookup,
				protocolPacket
			},

			(* Look up the option values we need *)
			{
				magneticBeads,magneticBeadVolumes,assayContainers,volumes,aliquotAmounts,magnetizationRacks,
				preWashes,preWashBuffers,preWashBufferVolumes,numberOfPreWashes,preWashCollectionContainers,preWashDestinationWells,preWashCollectionContainerLabels,preWashCollectionStorageConditions,
				equilibrations,equilibrationBuffers,equilibrationBufferVolumes,equilibrationCollectionContainers,equilibrationDestinationWells,equilibrationCollectionContainerLabels,equilibrationCollectionStorageConditions,
				loadingCollectionContainers,loadingDestinationWells,loadingCollectionContainerLabels,loadingCollectionStorageConditions,
				washes,washBuffers,washBufferVolumes,numberOfWashes,washCollectionContainers,washDestinationWells,washCollectionContainerLabels,washCollectionStorageConditions,
				elutions,elutionBuffers,elutionBufferVolumes,numberOfElutions,elutionCollectionContainers,elutionDestinationWells,elutionCollectionContainerLabels,elutionCollectionStorageConditions,

				preWashCollectionContainerIndices,equilibrationCollectionContainerIndices,loadingCollectionContainerIndices,washCollectionContainerIndices,elutionCollectionContainerIndices,

				secondaryWashes,secondaryWashBuffers,secondaryWashBufferVolumes,numberOfSecondaryWashes,secondaryWashCollectionContainers, secondaryWashDestinationWells, secondaryWashCollectionContainerIndices, secondaryWashCollectionContainerLabels, secondaryWashCollectionStorageConditions,
				tertiaryWashes,tertiaryWashBuffers,tertiaryWashBufferVolumes,numberOfTertiaryWashes,tertiaryWashCollectionContainers, tertiaryWashDestinationWells, tertiaryWashCollectionContainerIndices, tertiaryWashCollectionContainerLabels, tertiaryWashCollectionStorageConditions,
				quaternaryWashes,quaternaryWashBuffers,quaternaryWashBufferVolumes,numberOfQuaternaryWashes,quaternaryWashCollectionContainers, quaternaryWashDestinationWells, quaternaryWashCollectionContainerIndices, quaternaryWashCollectionContainerLabels, quaternaryWashCollectionStorageConditions,
				quinaryWashes, quinaryWashBuffers, quinaryWashBufferVolumes,numberOfQuinaryWashes,quinaryWashCollectionContainers, quinaryWashDestinationWells, quinaryWashCollectionContainerIndices, quinaryWashCollectionContainerLabels, quinaryWashCollectionStorageConditions,
				senaryWashes,senaryWashBuffers,senaryWashBufferVolumes,numberOfSenaryWashes,senaryWashCollectionContainers, senaryWashDestinationWells, senaryWashCollectionContainerIndices, senaryWashCollectionContainerLabels, senaryWashCollectionStorageConditions,
				septenaryWashes,septenaryWashBuffers,septenaryWashBufferVolumes,numberOfSeptenaryWashes,septenaryWashCollectionContainers, septenaryWashDestinationWells, septenaryWashCollectionContainerIndices, septenaryWashCollectionContainerLabels, septenaryWashCollectionStorageConditions
			}=Lookup[
				myResolvedOptions,
				{
					MagneticBeads,MagneticBeadVolume,AssayContainer,Volume,AliquotAmount,MagnetizationRack,
					PreWash,PreWashBuffer,PreWashBufferVolume,NumberOfPreWashes,PreWashCollectionContainer,PreWashDestinationWell,PreWashCollectionContainerLabel,PreWashCollectionStorageCondition,
					Equilibration,EquilibrationBuffer,EquilibrationBufferVolume,EquilibrationCollectionContainer,EquilibrationDestinationWell,EquilibrationCollectionContainerLabel,EquilibrationCollectionStorageCondition,
					LoadingCollectionContainer,LoadingDestinationWell, LoadingCollectionContainerLabel,LoadingCollectionStorageCondition,
					Wash,WashBuffer,WashBufferVolume,NumberOfWashes,WashCollectionContainer,WashDestinationWell,WashCollectionContainerLabel,WashCollectionStorageCondition,
					Elution,ElutionBuffer,ElutionBufferVolume,NumberOfElutions,ElutionCollectionContainer,ElutionDestinationWell,ElutionCollectionContainerLabel,ElutionCollectionStorageCondition,

					PreWashCollectionContainerIndex,EquilibrationCollectionContainerIndex,LoadingCollectionContainerIndex,WashCollectionContainerIndex,ElutionCollectionContainerIndex,

					SecondaryWash,SecondaryWashBuffer,SecondaryWashBufferVolume,NumberOfSecondaryWashes,SecondaryWashCollectionContainer,SecondaryWashDestinationWell,SecondaryWashCollectionContainerIndex,SecondaryWashCollectionContainerLabel,SecondaryWashCollectionStorageCondition,
					TertiaryWash,TertiaryWashBuffer,TertiaryWashBufferVolume,NumberOfTertiaryWashes,TertiaryWashCollectionContainer,TertiaryWashDestinationWell,TertiaryWashCollectionContainerIndex,TertiaryWashCollectionContainerLabel,TertiaryWashCollectionStorageCondition,
					QuaternaryWash,QuaternaryWashBuffer,QuaternaryWashBufferVolume,NumberOfQuaternaryWashes,QuaternaryWashCollectionContainer,QuaternaryWashDestinationWell,QuaternaryWashCollectionContainerIndex,QuaternaryWashCollectionContainerLabel,QuaternaryWashCollectionStorageCondition,
					QuinaryWash,QuinaryWashBuffer,QuinaryWashBufferVolume,NumberOfQuinaryWashes,QuinaryWashCollectionContainer,QuinaryWashDestinationWell,QuinaryWashCollectionContainerIndex,QuinaryWashCollectionContainerLabel,QuinaryWashCollectionStorageCondition,
					SenaryWash,SenaryWashBuffer,SenaryWashBufferVolume,NumberOfSenaryWashes,SenaryWashCollectionContainer,SenaryWashDestinationWell,SenaryWashCollectionContainerIndex,SenaryWashCollectionContainerLabel,SenaryWashCollectionStorageCondition,
					SeptenaryWash,SeptenaryWashBuffer,SeptenaryWashBufferVolume,NumberOfSeptenaryWashes,SeptenaryWashCollectionContainer,SeptenaryWashDestinationWell,SeptenaryWashCollectionContainerIndex,SeptenaryWashCollectionContainerLabel,SeptenaryWashCollectionStorageCondition
				}
			];
			(*Normalize container format to container object only, with the original nesty-ness*)
			convertedPreWashCollectionContainers=normalizeResolvedContainersForSimulation[preWashCollectionContainers];
			convertedEquilibrationCollectionContainers=normalizeResolvedContainersForSimulation[equilibrationCollectionContainers];
			convertedLoadingCollectionContainers=normalizeResolvedContainersForSimulation[loadingCollectionContainers];
			convertedWashCollectionContainers=normalizeResolvedContainersForSimulation[washCollectionContainers];
			convertedSecondaryWashCollectionContainers=normalizeResolvedContainersForSimulation[secondaryWashCollectionContainers];
			convertedTertiaryWashCollectionContainers=normalizeResolvedContainersForSimulation[tertiaryWashCollectionContainers];
			convertedQuaternaryWashCollectionContainers=normalizeResolvedContainersForSimulation[quaternaryWashCollectionContainers];
			convertedQuinaryWashCollectionContainers=normalizeResolvedContainersForSimulation[quinaryWashCollectionContainers];
			convertedSenaryWashCollectionContainers=normalizeResolvedContainersForSimulation[senaryWashCollectionContainers];
			convertedSeptenaryWashCollectionContainers=normalizeResolvedContainersForSimulation[septenaryWashCollectionContainers];
			convertedElutionCollectionContainers=normalizeResolvedContainersForSimulation[elutionCollectionContainers];
			(* NOTE: THIS LOGIC IS COPIED FROM THE OPTION RESOLVER SO IF CHANGES ARE MADE IT NEEDS TO BE KEPT IN SYNC *)
			(* Initiate a lookup to track existing collection containers and available destination wells *)
			collectionContainerLookup = <||>;

			(* Get the resolved collection containers and resolved destination wells *)
			(* NOTE: We will only use the destination wells from this but it is easiest to use the same logic that also resolves the labels *)
			{
				preWashCollectionContainerLabels,
				preWashDestinationWells,
				equilibrationCollectionContainerLabels,
				equilibrationDestinationWells,
				loadingCollectionContainerLabels,
				loadingDestinationWells,
				washCollectionContainerLabels,
				washDestinationWells,
				secondaryWashCollectionContainerLabels,
				secondaryWashDestinationWells,
				tertiaryWashCollectionContainerLabels,
				tertiaryWashDestinationWells,
				quaternaryWashCollectionContainerLabels,
				quaternaryWashDestinationWells,
				quinaryWashCollectionContainerLabels,
				quinaryWashDestinationWells,
				senaryWashCollectionContainerLabels,
				senaryWashDestinationWells,
				septenaryWashCollectionContainerLabels,
				septenaryWashDestinationWells,
				elutionCollectionContainerLabels,
				elutionDestinationWells
			}=Transpose@MapThread[
				Function[
					{
						preWashCollectionContainersBatch,preWashDestinationWellsBatch,preWashCollectionContainerIndicesBatch,preWashCollectionContainerLabelsBatch,preWashCollectionStorageConditionsBatch,preWashesBatch,
						equilibrationCollectionContainersBatch,equilibrationDestinationWellsBatch,equilibrationCollectionContainerIndicesBatch,equilibrationCollectionContainerLabelsBatch,equilibrationCollectionStorageConditionsBatch,equilibrationsBatch,
						loadingCollectionContainersBatch,loadingDestinationWellsBatch,loadingCollectionContainerIndicesBatch,loadingCollectionContainerLabelsBatch,loadingCollectionStorageConditionsBatch,loadingsBatch,
						washCollectionContainersBatch,washDestinationWellsBatch,washCollectionContainerIndicesBatch,washCollectionContainerLabelsBatch,washCollectionStorageConditionsBatch,washesBatch,
						secondaryWashCollectionContainersBatch,secondaryWashDestinationWellsBatch,secondaryWashCollectionContainerIndicesBatch,secondaryWashCollectionContainerLabelsBatch,secondaryWashCollectionStorageConditionsBatch,secondaryWashesBatch,
						tertiaryWashCollectionContainersBatch,tertiaryWashDestinationWellsBatch,tertiaryWashCollectionContainerIndicesBatch,tertiaryWashCollectionContainerLabelsBatch,tertiaryWashCollectionStorageConditionsBatch,tertiaryWashesBatch,
						quaternaryWashCollectionContainersBatch,quaternaryWashDestinationWellsBatch,quaternaryWashCollectionContainerIndicesBatch,quaternaryWashCollectionContainerLabelsBatch,quaternaryWashCollectionStorageConditionsBatch,quaternaryWashesBatch,
						quinaryWashCollectionContainersBatch,quinaryWashDestinationWellsBatch,quinaryWashCollectionContainerIndicesBatch,quinaryWashCollectionContainerLabelsBatch,quinaryWashCollectionStorageConditionsBatch,quinaryWashesBatch,
						senaryWashCollectionContainersBatch,senaryWashDestinationWellsBatch,senaryWashCollectionContainerIndicesBatch,senaryWashCollectionContainerLabelsBatch,senaryWashCollectionStorageConditionsBatch,senaryWashesBatch,
						septenaryWashCollectionContainersBatch,septenaryWashDestinationWellsBatch,septenaryWashCollectionContainerIndicesBatch,septenaryWashCollectionContainerLabelsBatch,septenaryWashCollectionStorageConditionsBatch,septenaryWashesBatch,
						elutionCollectionContainersBatch,elutionDestinationWellsBatch,elutionCollectionContainerIndicesBatch,elutionCollectionContainerLabelsBatch,elutionCollectionStorageConditionsBatch,elutionsBatch,
						simulatedSamplesBatch
					},

					Module[
						{
							preWashOutput,resolvedPreWashCollectionContainerLabel,resolvedPreWashDestinationWell,
							equilibrationOutput,resolvedEquilibrationCollectionContainerLabel,resolvedEquilibrationDestinationWell,
							loadingOutput,resolvedLoadingCollectionContainerLabel,resolvedLoadingDestinationWell,
							washOutput,resolvedWashCollectionContainerLabel,resolvedWashDestinationWell,
							secondaryWashOutput,resolvedSecondaryWashCollectionContainerLabel,resolvedSecondaryWashDestinationWell,
							tertiaryWashOutput,resolvedTertiaryWashCollectionContainerLabel,resolvedTertiaryWashDestinationWell,
							quaternaryWashOutput,resolvedQuaternaryWashCollectionContainerLabel,resolvedQuaternaryWashDestinationWell,
							quinaryWashOutput,resolvedQuinaryWashCollectionContainerLabel,resolvedQuinaryWashDestinationWell,
							senaryWashOutput,resolvedSenaryWashCollectionContainerLabel,resolvedSenaryWashDestinationWell,
							septenaryWashOutput,resolvedSeptenaryWashCollectionContainerLabel,resolvedSeptenaryWashDestinationWell,
							elutionOutput,resolvedElutionCollectionContainerLabel,resolvedElutionDestinationWell
						},
						(* Resolve stage by stage for each batch *)

						(* -- PreWash -- *)
						{preWashOutput,collectionContainerLookup} = simulateDestinationWellsAndContainerLabelsOfStage[preWashCollectionContainersBatch,preWashDestinationWellsBatch,preWashCollectionContainerIndicesBatch,preWashCollectionContainerLabelsBatch,preWashCollectionStorageConditionsBatch,preWashesBatch,simulatedSamplesBatch,collectionContainerLookup,inheritedFastAssoc];

						{resolvedPreWashCollectionContainerLabel,resolvedPreWashDestinationWell}={preWashOutput[[All,1]],preWashOutput[[All,2]]};

						(* -- Equilibration -- *)
						{equilibrationOutput,collectionContainerLookup} = simulateDestinationWellsAndContainerLabelsOfStage[equilibrationCollectionContainersBatch,equilibrationDestinationWellsBatch,equilibrationCollectionContainerIndicesBatch,equilibrationCollectionContainerLabelsBatch,equilibrationCollectionStorageConditionsBatch,equilibrationsBatch,simulatedSamplesBatch,collectionContainerLookup,inheritedFastAssoc];

						{resolvedEquilibrationCollectionContainerLabel,resolvedEquilibrationDestinationWell}={equilibrationOutput[[All,1]],equilibrationOutput[[All,2]]};

						(* -- Loading -- *)
						{loadingOutput,collectionContainerLookup} = simulateDestinationWellsAndContainerLabelsOfStage[loadingCollectionContainersBatch,loadingDestinationWellsBatch,loadingCollectionContainerIndicesBatch,loadingCollectionContainerLabelsBatch,loadingCollectionStorageConditionsBatch,loadingsBatch,simulatedSamplesBatch,collectionContainerLookup,inheritedFastAssoc];

						{resolvedLoadingCollectionContainerLabel,resolvedLoadingDestinationWell}={loadingOutput[[All,1]],loadingOutput[[All,2]]};

						(* -- Wash -- *)
						{washOutput,collectionContainerLookup} = simulateDestinationWellsAndContainerLabelsOfStage[washCollectionContainersBatch,washDestinationWellsBatch,washCollectionContainerIndicesBatch,washCollectionContainerLabelsBatch,washCollectionStorageConditionsBatch,washesBatch,simulatedSamplesBatch,collectionContainerLookup,inheritedFastAssoc];

						{resolvedWashCollectionContainerLabel,resolvedWashDestinationWell}={washOutput[[All,1]],washOutput[[All,2]]};

						(* -- SecondaryWash -- *)
						{secondaryWashOutput,collectionContainerLookup} = simulateDestinationWellsAndContainerLabelsOfStage[secondaryWashCollectionContainersBatch,secondaryWashDestinationWellsBatch,secondaryWashCollectionContainerIndicesBatch,secondaryWashCollectionContainerLabelsBatch,secondaryWashCollectionStorageConditionsBatch,secondaryWashesBatch,simulatedSamplesBatch,collectionContainerLookup,inheritedFastAssoc];

						{resolvedSecondaryWashCollectionContainerLabel,resolvedSecondaryWashDestinationWell}={secondaryWashOutput[[All,1]],secondaryWashOutput[[All,2]]};

						(* -- TertiaryWash -- *)
						{tertiaryWashOutput,collectionContainerLookup} = simulateDestinationWellsAndContainerLabelsOfStage[tertiaryWashCollectionContainersBatch,tertiaryWashDestinationWellsBatch,tertiaryWashCollectionContainerIndicesBatch,tertiaryWashCollectionContainerLabelsBatch,tertiaryWashCollectionStorageConditionsBatch,tertiaryWashesBatch,simulatedSamplesBatch,collectionContainerLookup,inheritedFastAssoc];

						{resolvedTertiaryWashCollectionContainerLabel,resolvedTertiaryWashDestinationWell}={tertiaryWashOutput[[All,1]],tertiaryWashOutput[[All,2]]};

						(* -- QuaternaryWash -- *)
						{quaternaryWashOutput,collectionContainerLookup} = simulateDestinationWellsAndContainerLabelsOfStage[quaternaryWashCollectionContainersBatch,quaternaryWashDestinationWellsBatch,quaternaryWashCollectionContainerIndicesBatch,quaternaryWashCollectionContainerLabelsBatch,quaternaryWashCollectionStorageConditionsBatch,quaternaryWashesBatch,simulatedSamplesBatch,collectionContainerLookup,inheritedFastAssoc];

						{resolvedQuaternaryWashCollectionContainerLabel,resolvedQuaternaryWashDestinationWell}={quaternaryWashOutput[[All,1]],quaternaryWashOutput[[All,2]]};

						(* -- QuinaryWash -- *)
						{quinaryWashOutput,collectionContainerLookup} = simulateDestinationWellsAndContainerLabelsOfStage[quinaryWashCollectionContainersBatch,quinaryWashDestinationWellsBatch,quinaryWashCollectionContainerIndicesBatch,quinaryWashCollectionContainerLabelsBatch,quinaryWashCollectionStorageConditionsBatch,quinaryWashesBatch,simulatedSamplesBatch,collectionContainerLookup,inheritedFastAssoc];

						{resolvedQuinaryWashCollectionContainerLabel,resolvedQuinaryWashDestinationWell}={quinaryWashOutput[[All,1]],quinaryWashOutput[[All,2]]};

						(* -- SenaryWash -- *)
						{senaryWashOutput,collectionContainerLookup} = simulateDestinationWellsAndContainerLabelsOfStage[senaryWashCollectionContainersBatch,senaryWashDestinationWellsBatch,senaryWashCollectionContainerIndicesBatch,senaryWashCollectionContainerLabelsBatch,senaryWashCollectionStorageConditionsBatch,senaryWashesBatch,simulatedSamplesBatch,collectionContainerLookup,inheritedFastAssoc];

						{resolvedSenaryWashCollectionContainerLabel,resolvedSenaryWashDestinationWell}={senaryWashOutput[[All,1]],senaryWashOutput[[All,2]]};

						(* -- SeptenaryWash -- *)
						{septenaryWashOutput,collectionContainerLookup} = simulateDestinationWellsAndContainerLabelsOfStage[septenaryWashCollectionContainersBatch,septenaryWashDestinationWellsBatch,septenaryWashCollectionContainerIndicesBatch,septenaryWashCollectionContainerLabelsBatch,septenaryWashCollectionStorageConditionsBatch,septenaryWashesBatch,simulatedSamplesBatch,collectionContainerLookup,inheritedFastAssoc];

						{resolvedSeptenaryWashCollectionContainerLabel,resolvedSeptenaryWashDestinationWell}={septenaryWashOutput[[All,1]],septenaryWashOutput[[All,2]]};

						(* -- Elution -- *)
						{elutionOutput,collectionContainerLookup} = simulateDestinationWellsAndContainerLabelsOfStage[elutionCollectionContainersBatch,elutionDestinationWellsBatch,elutionCollectionContainerIndicesBatch,elutionCollectionContainerLabelsBatch,elutionCollectionStorageConditionsBatch,elutionsBatch,simulatedSamplesBatch,collectionContainerLookup,inheritedFastAssoc];

						{resolvedElutionCollectionContainerLabel,resolvedElutionDestinationWell}={elutionOutput[[All,1]],elutionOutput[[All,2]]};
						{
							resolvedPreWashCollectionContainerLabel,resolvedPreWashDestinationWell,resolvedEquilibrationCollectionContainerLabel,resolvedEquilibrationDestinationWell,
							resolvedLoadingCollectionContainerLabel,resolvedLoadingDestinationWell,resolvedWashCollectionContainerLabel,resolvedWashDestinationWell,
							resolvedSecondaryWashCollectionContainerLabel,resolvedSecondaryWashDestinationWell,
							resolvedTertiaryWashCollectionContainerLabel,resolvedTertiaryWashDestinationWell,
							resolvedQuaternaryWashCollectionContainerLabel,resolvedQuaternaryWashDestinationWell,
							resolvedQuinaryWashCollectionContainerLabel,resolvedQuinaryWashDestinationWell,
							resolvedSenaryWashCollectionContainerLabel,resolvedSenaryWashDestinationWell,
							resolvedSeptenaryWashCollectionContainerLabel,resolvedSeptenaryWashDestinationWell,
							resolvedElutionCollectionContainerLabel,resolvedElutionDestinationWell
						}
					]
				],
				{
					convertedPreWashCollectionContainers,
					preWashDestinationWells,
					preWashCollectionContainerIndices,
					preWashCollectionContainerLabels,
					preWashCollectionStorageConditions,
					preWashes,

					convertedEquilibrationCollectionContainers,
					equilibrationDestinationWells,
					equilibrationCollectionContainerIndices,
					equilibrationCollectionContainerLabels,
					equilibrationCollectionStorageConditions,
					equilibrations,

					convertedLoadingCollectionContainers,
					loadingDestinationWells,
					loadingCollectionContainerIndices,
					loadingCollectionContainerLabels,
					loadingCollectionStorageConditions,
					myNestedSamples/.ObjectP[]->True,

					convertedWashCollectionContainers,
					washDestinationWells,
					washCollectionContainerIndices,
					washCollectionContainerLabels,
					washCollectionStorageConditions,
					washes,

					convertedSecondaryWashCollectionContainers,
					secondaryWashDestinationWells,
					secondaryWashCollectionContainerIndices,
					secondaryWashCollectionContainerLabels,
					secondaryWashCollectionStorageConditions,
					secondaryWashes,

					convertedTertiaryWashCollectionContainers,
					tertiaryWashDestinationWells,
					tertiaryWashCollectionContainerIndices,
					tertiaryWashCollectionContainerLabels,
					tertiaryWashCollectionStorageConditions,
					tertiaryWashes,

					convertedQuaternaryWashCollectionContainers,
					quaternaryWashDestinationWells,
					quaternaryWashCollectionContainerIndices,
					quaternaryWashCollectionContainerLabels,
					quaternaryWashCollectionStorageConditions,
					quaternaryWashes,

					convertedQuinaryWashCollectionContainers,
					quinaryWashDestinationWells,
					quinaryWashCollectionContainerIndices,
					quinaryWashCollectionContainerLabels,
					quinaryWashCollectionStorageConditions,
					quinaryWashes,

					convertedSenaryWashCollectionContainers,
					senaryWashDestinationWells,
					senaryWashCollectionContainerIndices,
					senaryWashCollectionContainerLabels,
					senaryWashCollectionStorageConditions,
					senaryWashes,

					convertedSeptenaryWashCollectionContainers,
					septenaryWashDestinationWells,
					septenaryWashCollectionContainerIndices,
					septenaryWashCollectionContainerLabels,
					septenaryWashCollectionStorageConditions,
					septenaryWashes,

					convertedElutionCollectionContainers,
					elutionDestinationWells,
					elutionCollectionContainerIndices,
					elutionCollectionContainerLabels,
					elutionCollectionStorageConditions,
					elutions,

					myNestedSamples
				}
			];
			(* NOTE: THIS LOGIC IS COPIED FROM THE RESOURCE PACKETS SO IF CHANGES ARE MADE IT NEEDS TO BE KEPT IN SYNC *)
			(*---Generate all the resources for the experiment---*)

			(*--Download container information--*)

			containersIn=Quiet[
				Download[
							Flatten[myNestedSamples],
							Container[Object],
							Cache->inheritedCache,
							Simulation->currentSimulation
				],
				{Download::FieldDoesntExist}
			];

			(* get the unique container in *)
			uniqueContainersIn=DeleteDuplicates[Flatten[containersIn]];

			(* Resolve AssayContainerLabels and Wells *)
			assayContainerLookup=<||>;
			assayContainerMapOutput=Map[
				Function[{assayContainer},
					If[MatchQ[assayContainer,ObjectP[{Model[Container],Object[Container]}]],
						Module[{availableContainerInfo},

							availableContainerInfo=Lookup[
								assayContainerLookup,
								assayContainer,
								Null
							];

							(* Was there an available container? (Matching object/model and available positions) *)
							If[!NullQ[availableContainerInfo]&&Length[Lookup[availableContainerInfo,AvailablePositions]]>0,

								(* Yes there was an available container *)
								Module[{containerLabel,availablePositions,usedPositions,positionToUse},

									(* Get the info about the object *)
									{containerLabel,availablePositions,usedPositions} = Lookup[availableContainerInfo, {Label,AvailablePositions,UsedPositions}];

									(* If the user specified a destination well, use it otherwise default to the first available position *)
									positionToUse=First[availablePositions];

									(* update the lookup with new container information *)
									assayContainerLookup=AssociateTo[
										assayContainerLookup,
										assayContainer->{
											Label->containerLabel,
											AvailablePositions->Rest[availablePositions],
											UsedPositions->Flatten[{usedPositions,positionToUse}]
										}
									];

									(* return the resolved collection container label and destination well *)
									{containerLabel,positionToUse}

								],

								(* No there was no an available container *)
								Module[{containerLabel,allowedPositions,positionToOccupy,positionsAvailable},

									(* Create a new label for the plate if one is not given *)
									containerLabel=CreateUniqueLabel["MBS assay container"];

									(* get all allowed wells in the container. *)
									allowedPositions=Lookup[fastAssocLookup[inheritedFastAssoc,assayContainer,Positions],Name];

									(* get the positions to use for this sample and positions available after occupying *)
									positionToOccupy=First[allowedPositions];

									(* Remove the new occupied position from the available positions *)
									positionsAvailable=Rest[allowedPositions];

									(* Update the lookup with the new plate information *)
									assayContainerLookup=AssociateTo[assayContainerLookup,
										assayContainer->{Label->containerLabel,AvailablePositions->positionsAvailable,UsedPositions->{positionToOccupy}}
									];

									(* return the resolved collection container label and destination well *)
									{containerLabel,positionToOccupy}
								]
							]
						],
						{"Bad Container Label","A1"}
					]
				],
				assayContainers,
				{2}
			];

			assayWells=assayContainerMapOutput[[All,All,2]];

			(* Get the unique assay plates *)
			uniqueAssayPlates=DeleteDuplicates[
				Cases[assayContainers,ObjectP[Model[Container,Plate]],{2}],
				SameObjectQ
			];

			(*--Generate SamplesIn resources--*)

			uniqueSamplesInResources=(#->Resource[Sample->#, Name->CreateUUID[]]&)/@DeleteDuplicates[Download[Flatten@myNestedSamples, Object]];
			samplesInResources=(Download[Flatten@myNestedSamples, Object])/.uniqueSamplesInResources;

			(*--Generate MagneticBeads resources--*)

			(*Generate sample volume rules*)
			magneticBeadVolumeRules=Flatten@MapThread[
				Function[{magneticBeadsBatch,magneticBeadsVolumesBatch},
					MapThread[
						Rule,
						{magneticBeadsBatch,magneticBeadsVolumesBatch}
					]
				],
				{magneticBeads,magneticBeadVolumes/.{Null->0 Microliter,Automatic->0 Microliter}}
			];

			(*Merge any entries with duplicate keys, totaling the values*)
			uniqueMagneticBeadsAndVolumesAssoc=KeyDrop[Merge[magneticBeadVolumeRules,Total],{Null,Automatic}];

			(*--Generate PreWashBuffer resources--*)

			(*Generate sample volume rules*)
			preWashBufferVolumeRules=Flatten@MapThread[
				Function[{preWashBuffersBatch,preWashBufferVolumesBatch,numberOfPreWashesBatch},
					MapThread[
						#1->1.1*#2*#3&,
						{preWashBuffersBatch,preWashBufferVolumesBatch,numberOfPreWashesBatch}
					]
				],
				{preWashBuffers,preWashBufferVolumes/.{Null->0 Microliter,Automatic->0 Microliter},numberOfPreWashes/.{Null->0,Automatic->0}}
			];

			(*Merge any entries with duplicate keys, totaling the values*)
			uniquePreWashBuffersAndVolumesAssoc=KeyDrop[Merge[preWashBufferVolumeRules,Total],{Null,Automatic}];


			(*--Generate EquilibrationBuffer resources--*)

			(*Generate sample volume rules*)
			equilibrationBufferVolumeRules=Flatten@MapThread[
				Function[{equilibrationBuffersBatch,equilibrationBufferVolumesBatch},
					MapThread[
						Rule,
						{equilibrationBuffersBatch,equilibrationBufferVolumesBatch}
					]
				],
				{equilibrationBuffers,equilibrationBufferVolumes/.{Null->0 Microliter,Automatic->0 Microliter}}
			];

			(*Merge any entries with duplicate keys, totaling the values*)
			uniqueEquilibrationBuffersAndVolumesAssoc=KeyDrop[Merge[equilibrationBufferVolumeRules,Total],{Null,Automatic}];



			(*--Generate WashBuffer resources--*)

			(*Generate sample volume rules*)
			washBufferVolumeRules=Flatten@MapThread[
			Function[{washBuffersBatch,washBufferVolumesBatch,numberOfWashesBatch},
				MapThread[
					#1->1.1*#2*#3&,
					{washBuffersBatch,washBufferVolumesBatch,numberOfWashesBatch}
				]
			],
			{washBuffers,washBufferVolumes/.{Null->0 Microliter,Automatic->0 Microliter},numberOfWashes/.{Null->0,Automatic->0}}
			];

			(*Merge any entries with duplicate keys, totaling the values*)
			uniqueWashBuffersAndVolumesAssoc=KeyDrop[Merge[washBufferVolumeRules,Total],{Null,Automatic}];

			(*--Generate SecondaryWashBuffer resources--*)

			(*Generate sample volume rules*)
			secondaryWashBufferVolumeRules=Flatten@MapThread[
				Function[{secondaryWashBuffersBatch,secondaryWashBufferVolumesBatch,numberOfSecondaryWashesBatch},
					MapThread[
						#1->1.1*#2*#3&,
						{secondaryWashBuffersBatch,secondaryWashBufferVolumesBatch,numberOfSecondaryWashesBatch}
					]
				],
				{secondaryWashBuffers,secondaryWashBufferVolumes/.{Null->0 Microliter,Automatic->0 Microliter},numberOfSecondaryWashes/.{Null->0,Automatic->0}}
			];

			(*Merge any entries with duplicate keys, totaling the values*)
			uniqueSecondaryWashBuffersAndVolumesAssoc=KeyDrop[Merge[secondaryWashBufferVolumeRules,Total],{Null,Automatic}];


			(*--Generate TertiaryWashBuffer resources--*)

			(*Generate sample volume rules*)
			tertiaryWashBufferVolumeRules=Flatten@MapThread[
				Function[{tertiaryWashBuffersBatch,tertiaryWashBufferVolumesBatch,numberOfTertiaryWashesBatch},
					MapThread[
						#1->1.1*#2*#3&,
						{tertiaryWashBuffersBatch,tertiaryWashBufferVolumesBatch,numberOfTertiaryWashesBatch}
					]
				],
				{tertiaryWashBuffers,tertiaryWashBufferVolumes/.{Null->0 Microliter,Automatic->0 Microliter},numberOfTertiaryWashes/.{Null->0,Automatic->0}}
			];

			(*Merge any entries with duplicate keys, totaling the values*)
			uniqueTertiaryWashBuffersAndVolumesAssoc=KeyDrop[Merge[tertiaryWashBufferVolumeRules,Total],{Null,Automatic}];


			(*--Generate QuaternaryWashBuffer resources--*)

			(*Generate sample volume rules*)
			quaternaryWashBufferVolumeRules=Flatten@MapThread[
				Function[{quaternaryWashBuffersBatch,quaternaryWashBufferVolumesBatch,numberOfQuaternaryWashesBatch},
					MapThread[
						#1->1.1*#2*#3&,
						{quaternaryWashBuffersBatch,quaternaryWashBufferVolumesBatch,numberOfQuaternaryWashesBatch}
					]
				],
				{quaternaryWashBuffers,quaternaryWashBufferVolumes/.{Null->0 Microliter,Automatic->0 Microliter},numberOfQuaternaryWashes/.{Null->0,Automatic->0}}
			];

			(*Merge any entries with duplicate keys, totaling the values*)
			uniqueQuaternaryWashBuffersAndVolumesAssoc=KeyDrop[Merge[quaternaryWashBufferVolumeRules,Total],{Null,Automatic}];


			(*--Generate QuinaryWashBuffer resources--*)

			(*Generate sample volume rules*)
			quinaryWashBufferVolumeRules=Flatten@MapThread[
				Function[{quinaryWashBuffersBatch,quinaryWashBufferVolumesBatch,numberOfQuinaryWashesBatch},
					MapThread[
						#1->1.1*#2*#3&,
						{quinaryWashBuffersBatch,quinaryWashBufferVolumesBatch,numberOfQuinaryWashesBatch}
					]
				],
				{quinaryWashBuffers,quinaryWashBufferVolumes/.{Null->0 Microliter,Automatic->0 Microliter},numberOfQuinaryWashes/.{Null->0,Automatic->0}}
			];

			(*Merge any entries with duplicate keys, totaling the values*)
			uniqueQuinaryWashBuffersAndVolumesAssoc=KeyDrop[Merge[quinaryWashBufferVolumeRules,Total],{Null,Automatic}];


			(*--Generate SenaryWashBuffer resources--*)

			(*Generate sample volume rules*)
			senaryWashBufferVolumeRules=Flatten@MapThread[
				Function[{senaryWashBuffersBatch,senaryWashBufferVolumesBatch,numberOfSenaryWashesBatch},
					MapThread[
						#1->1.1*#2*#3&,
						{senaryWashBuffersBatch,senaryWashBufferVolumesBatch,numberOfSenaryWashesBatch}
					]
				],
				{senaryWashBuffers,senaryWashBufferVolumes/.{Null->0 Microliter,Automatic->0 Microliter},numberOfSenaryWashes/.{Null->0,Automatic->0}}
			];

			(*Merge any entries with duplicate keys, totaling the values*)
			uniqueSenaryWashBuffersAndVolumesAssoc=KeyDrop[Merge[senaryWashBufferVolumeRules,Total],{Null,Automatic}];

			(*--Generate SeptenaryWashBuffer resources--*)

			(*Generate sample volume rules*)
			septenaryWashBufferVolumeRules=Flatten@MapThread[
				Function[{septenaryWashBuffersBatch,septenaryWashBufferVolumesBatch,numberOfSeptenaryWashesBatch},
					MapThread[
						#1->1.1*#2*#3&,
						{septenaryWashBuffersBatch,septenaryWashBufferVolumesBatch,numberOfSeptenaryWashesBatch}
					]
				],
				{septenaryWashBuffers,septenaryWashBufferVolumes/.{Null->0 Microliter,Automatic->0 Microliter},numberOfSeptenaryWashes/.{Null->0,Automatic->0}}
			];

			(*Merge any entries with duplicate keys, totaling the values*)
			uniqueSeptenaryWashBuffersAndVolumesAssoc=KeyDrop[Merge[septenaryWashBufferVolumeRules,Total],{Null,Automatic}];


			(*--Generate ElutionBuffer resources--*)

			(*Generate sample volume rules*)
			elutionBufferVolumeRules=Flatten@MapThread[
				Function[{elutionBuffersBatch,elutionBufferVolumesBatch,numberOfElutionsBatch},
					MapThread[
						#1->1.1*#2*#3&,
						{elutionBuffersBatch,elutionBufferVolumesBatch,numberOfElutionsBatch}
					]
				],
				{elutionBuffers,elutionBufferVolumes/.{Null->0 Microliter,Automatic->0 Microliter},numberOfElutions/.{Null->0,Automatic->0}}
			];

			(*Merge any entries with duplicate keys, totaling the values*)
			uniqueElutionBuffersAndVolumesAssoc=KeyDrop[Merge[elutionBufferVolumeRules,Total],{Null,Automatic}];


			(*Generate a resource for each unique sample, returning a lookup table of sample->resource*)
			uniqueSampleResourceLookup[uniqueSamplesAndVolumes_Association]:=KeyValueMap[
				Function[{object,amount},
					Module[{objectRef,containers},
					(* make sure out object is in reference form *)
						objectRef=Download[object,Object];

						(* create resource *)
						If[MatchQ[objectRef,ObjectReferenceP[]]&&MatchQ[amount,VolumeP],
							(*If we need to make a resource, figure out which liquid handler compatible containers can be used for this resource*)
							(
								containers=PreferredContainer[amount,LiquidHandlerCompatible->True,All->True];
								(*Return a resource rule*)
								object->Resource[Sample->object,Amount->amount,Name->ToString[Unique[]],Container->containers]
							),

							(*If we don't need to make a resource, return a rule with the same object*)
							object->object
						]
					]
				],
				uniqueSamplesAndVolumes
			];
			(*Generate a resource for each unique plate, returning a lookup table of plate->resource*)
			uniquePlateResourceLookup=<||>;

			{preWashCollectionContainerResources,uniquePlateResourceLookup}=generateCollectionContainerResourcesOfStage[
				Flatten@convertedPreWashCollectionContainers,
				Flatten@preWashCollectionContainerIndices,
				Flatten@preWashCollectionContainerLabels,
				uniquePlateResourceLookup
			];

			{equilibrationCollectionContainerResources,uniquePlateResourceLookup}=generateCollectionContainerResourcesOfStage[
				Flatten@convertedEquilibrationCollectionContainers,
				Flatten@equilibrationCollectionContainerIndices,
				Flatten@equilibrationCollectionContainerLabels,
				uniquePlateResourceLookup
			];

			{loadingCollectionContainerResources,uniquePlateResourceLookup}=generateCollectionContainerResourcesOfStage[
				Flatten@convertedLoadingCollectionContainers,
				Flatten@loadingCollectionContainerIndices,
				Flatten@loadingCollectionContainerLabels,
				uniquePlateResourceLookup
			];

			{washCollectionContainerResources,uniquePlateResourceLookup}=generateCollectionContainerResourcesOfStage[
				Flatten@convertedWashCollectionContainers,
				Flatten@washCollectionContainerIndices,
				Flatten@washCollectionContainerLabels,
				uniquePlateResourceLookup
			];

			{secondaryWashCollectionContainerResources,uniquePlateResourceLookup}=generateCollectionContainerResourcesOfStage[
				Flatten@convertedSecondaryWashCollectionContainers,
				Flatten@secondaryWashCollectionContainerIndices,
				Flatten@secondaryWashCollectionContainerLabels,
				uniquePlateResourceLookup
			];

			{tertiaryWashCollectionContainerResources,uniquePlateResourceLookup}=generateCollectionContainerResourcesOfStage[
				Flatten@convertedTertiaryWashCollectionContainers,
				Flatten@tertiaryWashCollectionContainerIndices,
				Flatten@tertiaryWashCollectionContainerLabels,
				uniquePlateResourceLookup
			];

			{quaternaryWashCollectionContainerResources,uniquePlateResourceLookup}=generateCollectionContainerResourcesOfStage[
				Flatten@convertedQuaternaryWashCollectionContainers,
				Flatten@quaternaryWashCollectionContainerIndices,
				Flatten@quaternaryWashCollectionContainerLabels,
				uniquePlateResourceLookup
			];

			{quinaryWashCollectionContainerResources,uniquePlateResourceLookup}=generateCollectionContainerResourcesOfStage[
				Flatten@convertedQuinaryWashCollectionContainers,
				Flatten@quinaryWashCollectionContainerIndices,
				Flatten@quinaryWashCollectionContainerLabels,
				uniquePlateResourceLookup
			];

			{senaryWashCollectionContainerResources,uniquePlateResourceLookup}=generateCollectionContainerResourcesOfStage[
				Flatten@convertedSenaryWashCollectionContainers,
				Flatten@senaryWashCollectionContainerIndices,
				Flatten@senaryWashCollectionContainerLabels,
				uniquePlateResourceLookup
			];

			{septenaryWashCollectionContainerResources,uniquePlateResourceLookup}=generateCollectionContainerResourcesOfStage[
				Flatten@convertedSeptenaryWashCollectionContainers,
				Flatten@septenaryWashCollectionContainerIndices,
				Flatten@septenaryWashCollectionContainerLabels,
				uniquePlateResourceLookup
			];

			{elutionCollectionContainerResources,uniquePlateResourceLookup}=generateCollectionContainerResourcesOfStage[
				Flatten@convertedElutionCollectionContainers,
				Flatten@elutionCollectionContainerIndices,
				Flatten@elutionCollectionContainerLabels,
				uniquePlateResourceLookup
			];

			(*Generate a resource for each unique plate, returning a lookup table of plate->resource*)
			uniqueAssayPlateResourceLookup[uniquePlates_List]:=Map[
				#->Resource[Sample->#,Name->ToString[Unique[]]]&,
				Download[uniquePlates,Object]
			];


			(* Make this like the manual resource packets case *)
			protocolPacket = <|
				(* === Organizational Information === *)
				Object->protocolObject,
				Type->Object[Protocol,MagneticBeadSeparation],
				ResolvedOptions->myResolvedOptions,
				Replace[SamplesIn]->Map[Link[#,Protocols]&,samplesInResources],
				Replace[ContainersIn]->Map[Link[Resource[Sample->#],Protocols]&,uniqueContainersIn],

				(* === Method Information === *)
				SelectionStrategy -> Lookup[myResolvedOptions,SelectionStrategy],
				SeparationMode -> Lookup[myResolvedOptions,SeparationMode],
				ProcessingOrder -> Lookup[myResolvedOptions,ProcessingOrder],
				Replace[Volumes]->Flatten@volumes,
				Replace[AnalyteAffinityLabels]->Map[Link[#]&,Flatten[Lookup[myResolvedOptions,AnalyteAffinityLabel]]],
				Replace[Targets]->Map[Link[#]&,Flatten[Lookup[myResolvedOptions,Target]]],
				Replace[MagneticBeadAffinityLabels]->Map[Link[#]&,Flatten[Lookup[myResolvedOptions,MagneticBeadAffinityLabel]]],
				Replace[MagneticBeads]->Flatten@Map[Link[#]&,Replace[magneticBeads,uniqueSampleResourceLookup[uniqueMagneticBeadsAndVolumesAssoc],{2}],{2}],
				Replace[MagneticBeadVolumes]->Flatten@Lookup[myResolvedOptions,MagneticBeadVolume],
				Replace[MagnetizationRacks]->Map[Link[#]&,Flatten[magnetizationRacks]],
				Replace[AssayContainers]->Flatten@Map[
					If[MatchQ[#,ObjectP[]],
						(*vessels*)
						Link[Resource[Sample->#,Name->ToString[Unique[]]]],
						(*plates*)
						Link[#]
					]&,
					Replace[assayContainers,uniqueAssayPlateResourceLookup[uniqueAssayPlates],{2}],
					{2}
				],
				Replace[AssayWells]->Flatten[assayWells],
				Replace[BatchLengths]->Length/@(myNestedSamples),

				(* === Pre-Wash === *)
				Replace[PreWashes]->Flatten@Lookup[myResolvedOptions,PreWash],
				Replace[PreWashBuffers]->Flatten@Map[Link[#]&,Replace[preWashBuffers,uniqueSampleResourceLookup[uniquePreWashBuffersAndVolumesAssoc],{2}],{2}],
				Replace[PreWashBufferVolumes]->Flatten@Lookup[myResolvedOptions,PreWashBufferVolume],
				Replace[PreWashAspirationVolumes]->Flatten@MapThread[
					Function[{preWashAspirationVolumesBatch,preWashBufferVolumesBatch},
						MapThread[
							If[MatchQ[#1,All],#2,#1]&,
							{preWashAspirationVolumesBatch,preWashBufferVolumesBatch}
						]
					],
					{Lookup[myResolvedOptions,PreWashAspirationVolume],Lookup[myResolvedOptions,PreWashBufferVolume]}
				],
				Replace[NumberOfPreWashes]->Flatten@Lookup[myResolvedOptions,NumberOfPreWashes],
				Replace[PreWashCollectionContainers]->Flatten@Map[Link[#]&,preWashCollectionContainerResources],
				Replace[PreWashDestinationWells]->Flatten@Lookup[myResolvedOptions,PreWashDestinationWell],
				Replace[PreWashCollectionStorageConditions]->Flatten@preWashCollectionStorageConditions,

				(* === Equilibration === *)
				Replace[Equilibrations]->Flatten@Lookup[myResolvedOptions,Equilibration],
				Replace[EquilibrationBuffers]->Flatten@Map[Link[#]&,Replace[equilibrationBuffers,uniqueSampleResourceLookup[uniqueEquilibrationBuffersAndVolumesAssoc],{2}],{2}],
				Replace[EquilibrationBufferVolumes]->Flatten@Lookup[myResolvedOptions,EquilibrationBufferVolume],
				Replace[EquilibrationAspirationVolumes]->Flatten@MapThread[
					Function[{equilibrationAspirationVolumesBatch,equilibrationBufferVolumesBatch},
						MapThread[
							If[MatchQ[#1,All],#2,#1]&,
							{equilibrationAspirationVolumesBatch,equilibrationBufferVolumesBatch}
						]
					],
					{Lookup[myResolvedOptions,EquilibrationAspirationVolume],Lookup[myResolvedOptions,EquilibrationBufferVolume]}
				],
				Replace[EquilibrationCollectionContainers]->Flatten@Map[Link[#]&,equilibrationCollectionContainerResources],
				Replace[EquilibrationDestinationWells]->Flatten@Lookup[myResolvedOptions,EquilibrationDestinationWell],
				Replace[EquilibrationCollectionStorageConditions]->Flatten@equilibrationCollectionStorageConditions,

				(* === Loading === *)
				Replace[LoadingAspirationVolumes]->Flatten@MapThread[
					Function[{loadingAspirationVolumesBatch,loadingBufferVolumesBatch},
						MapThread[
							If[MatchQ[#1,All],#2,#1]&,
							{loadingAspirationVolumesBatch,loadingBufferVolumesBatch}
						]
					],
					{Lookup[myResolvedOptions,LoadingAspirationVolume],Lookup[myResolvedOptions,Volume]}
				],
				Replace[LoadingCollectionContainers]->Flatten@Map[Link[#]&,loadingCollectionContainerResources],
				Replace[LoadingDestinationWells]->Flatten@Lookup[myResolvedOptions,LoadingDestinationWell],
				Replace[LoadingCollectionStorageConditions]->Flatten@loadingCollectionStorageConditions,

				(* === Wash === *)
				Replace[Washes]->Flatten@Lookup[myResolvedOptions,Wash],
				Replace[WashBuffers]->Flatten@Map[Link[#]&,Replace[washBuffers,uniqueSampleResourceLookup[uniqueWashBuffersAndVolumesAssoc],{2}],{2}],
				Replace[WashBufferVolumes]->Flatten@Lookup[myResolvedOptions,WashBufferVolume],
				Replace[WashAspirationVolumes]->Flatten@MapThread[
					Function[{washAspirationVolumesBatch,washBufferVolumesBatch},
						MapThread[
							If[MatchQ[#1,All],#2,#1]&,
							{washAspirationVolumesBatch,washBufferVolumesBatch}
						]
					],
					{Lookup[myResolvedOptions,WashAspirationVolume],Lookup[myResolvedOptions,WashBufferVolume]}
				],
				Replace[NumberOfWashes]->Flatten@Lookup[myResolvedOptions,NumberOfWashes],
				Replace[WashCollectionContainers]->Flatten@Map[Link[#]&,washCollectionContainerResources],
				Replace[WashDestinationWells]->Flatten@Lookup[myResolvedOptions,WashDestinationWell],
				Replace[WashCollectionStorageConditions]->Flatten@washCollectionStorageConditions,

				(* === SecondaryWash === *)
				Replace[SecondaryWashes]->Flatten@Lookup[myResolvedOptions,SecondaryWash],
				Replace[SecondaryWashBuffers]->Flatten@Map[Link[#]&,Replace[secondaryWashBuffers,uniqueSampleResourceLookup[uniqueSecondaryWashBuffersAndVolumesAssoc],{2}],{2}],
				Replace[SecondaryWashBufferVolumes]->Flatten@Lookup[myResolvedOptions,SecondaryWashBufferVolume],
				Replace[SecondaryWashAspirationVolumes]->Flatten@MapThread[
					Function[{secondaryWashAspirationVolumesBatch,secondaryWashBufferVolumesBatch},
						MapThread[
							If[MatchQ[#1,All],#2,#1]&,
							{secondaryWashAspirationVolumesBatch,secondaryWashBufferVolumesBatch}
						]
					],
					{Lookup[myResolvedOptions,SecondaryWashAspirationVolume],Lookup[myResolvedOptions,SecondaryWashBufferVolume]}
				],
				Replace[NumberOfSecondaryWashes]->Flatten@Lookup[myResolvedOptions,NumberOfSecondaryWashes],
				Replace[SecondaryWashCollectionContainers]->Flatten@Map[Link[#]&,secondaryWashCollectionContainerResources],
				Replace[SecondaryWashDestinationWells]->Flatten@Lookup[myResolvedOptions,SecondaryWashDestinationWell],
				Replace[SecondaryWashCollectionStorageConditions]->Flatten@secondaryWashCollectionStorageConditions,

				(* === TertiaryWash === *)
				Replace[TertiaryWashes]->Flatten@Lookup[myResolvedOptions,TertiaryWash],
				Replace[TertiaryWashBuffers]->Flatten@Map[Link[#]&,Replace[tertiaryWashBuffers,uniqueSampleResourceLookup[uniqueTertiaryWashBuffersAndVolumesAssoc],{2}],{2}],
				Replace[TertiaryWashBufferVolumes]->Flatten@Lookup[myResolvedOptions,TertiaryWashBufferVolume],
				Replace[TertiaryWashAspirationVolumes]->Flatten@MapThread[
					Function[{tertiaryWashAspirationVolumesBatch,tertiaryWashBufferVolumesBatch},
						MapThread[
							If[MatchQ[#1,All],#2,#1]&,
							{tertiaryWashAspirationVolumesBatch,tertiaryWashBufferVolumesBatch}
						]
					],
					{Lookup[myResolvedOptions,TertiaryWashAspirationVolume],Lookup[myResolvedOptions,TertiaryWashBufferVolume]}
				],
				Replace[NumberOfTertiaryWashes]->Flatten@Lookup[myResolvedOptions,NumberOfTertiaryWashes],
				Replace[TertiaryWashCollectionContainers]->Flatten@Map[Link[#]&,tertiaryWashCollectionContainerResources],
				Replace[TertiaryWashDestinationWells]->Flatten@Lookup[myResolvedOptions,TertiaryWashDestinationWell],
				Replace[TertiaryWashCollectionStorageConditions]->Flatten@tertiaryWashCollectionStorageConditions,

				(* === QuaternaryWash === *)
				Replace[QuaternaryWashes]->Flatten@Lookup[myResolvedOptions,QuaternaryWash],
				Replace[QuaternaryWashBuffers]->Flatten@Map[Link[#]&,Replace[quaternaryWashBuffers,uniqueSampleResourceLookup[uniqueQuaternaryWashBuffersAndVolumesAssoc],{2}],{2}],
				Replace[QuaternaryWashBufferVolumes]->Flatten@Lookup[myResolvedOptions,QuaternaryWashBufferVolume],
				Replace[QuaternaryWashAspirationVolumes]->Flatten@MapThread[
					Function[{quaternaryWashAspirationVolumesBatch,quaternaryWashBufferVolumesBatch},
						MapThread[
							If[MatchQ[#1,All],#2,#1]&,
							{quaternaryWashAspirationVolumesBatch,quaternaryWashBufferVolumesBatch}
						]
					],
					{Lookup[myResolvedOptions,QuaternaryWashAspirationVolume],Lookup[myResolvedOptions,QuaternaryWashBufferVolume]}
				],
				Replace[NumberOfQuaternaryWashes]->Flatten@Lookup[myResolvedOptions,NumberOfQuaternaryWashes],
				Replace[QuaternaryWashCollectionContainers]->Flatten@Map[Link[#]&,quaternaryWashCollectionContainerResources],
				Replace[QuaternaryWashDestinationWells]->Flatten@Lookup[myResolvedOptions,QuaternaryWashDestinationWell],
				Replace[QuaternaryWashCollectionStorageConditions]->Flatten@quaternaryWashCollectionStorageConditions,

				(* === QuinaryWash === *)
				Replace[QuinaryWashes]->Flatten@Lookup[myResolvedOptions,QuinaryWash],
				Replace[QuinaryWashBuffers]->Flatten@Map[Link[#]&,Replace[quinaryWashBuffers,uniqueSampleResourceLookup[uniqueQuinaryWashBuffersAndVolumesAssoc],{2}],{2}],
				Replace[QuinaryWashBufferVolumes]->Flatten@Lookup[myResolvedOptions,QuinaryWashBufferVolume],
				Replace[QuinaryWashAspirationVolumes]->Flatten@MapThread[
					Function[{quinaryWashAspirationVolumesBatch,quinaryWashBufferVolumesBatch},
						MapThread[
							If[MatchQ[#1,All],#2,#1]&,
							{quinaryWashAspirationVolumesBatch,quinaryWashBufferVolumesBatch}
						]
					],
					{Lookup[myResolvedOptions,QuinaryWashAspirationVolume],Lookup[myResolvedOptions,QuinaryWashBufferVolume]}
				],
				Replace[NumberOfQuinaryWashes]->Flatten@Lookup[myResolvedOptions,NumberOfQuinaryWashes],
				Replace[QuinaryWashCollectionContainers]->Flatten@Map[Link[#]&,quinaryWashCollectionContainerResources],
				Replace[QuinaryWashDestinationWells]->Flatten@Lookup[myResolvedOptions,QuinaryWashDestinationWell],
				Replace[QuinaryWashCollectionStorageConditions]->Flatten@quinaryWashCollectionStorageConditions,

				(* === SenaryWash === *)
				Replace[SenaryWashes]->Flatten@Lookup[myResolvedOptions,SenaryWash],
				Replace[SenaryWashBuffers]->Flatten@Map[Link[#]&,Replace[senaryWashBuffers,uniqueSampleResourceLookup[uniqueSenaryWashBuffersAndVolumesAssoc],{2}],{2}],
				Replace[SenaryWashBufferVolumes]->Flatten@Lookup[myResolvedOptions,SenaryWashBufferVolume],
				Replace[SenaryWashAspirationVolumes]->Flatten@MapThread[
					Function[{senaryWashAspirationVolumesBatch,senaryWashBufferVolumesBatch},
						MapThread[
							If[MatchQ[#1,All],#2,#1]&,
							{senaryWashAspirationVolumesBatch,senaryWashBufferVolumesBatch}
						]
					],
					{Lookup[myResolvedOptions,SenaryWashAspirationVolume],Lookup[myResolvedOptions,SenaryWashBufferVolume]}
				],
				Replace[NumberOfSenaryWashes]->Flatten@Lookup[myResolvedOptions,NumberOfSenaryWashes],
				Replace[SenaryWashCollectionContainers]->Flatten@Map[Link[#]&,senaryWashCollectionContainerResources],
				Replace[SenaryWashDestinationWells]->Flatten@Lookup[myResolvedOptions,SenaryWashDestinationWell],
				Replace[SenaryWashCollectionStorageConditions]->Flatten@senaryWashCollectionStorageConditions,

				(* === SeptenaryWash === *)
				Replace[SeptenaryWashes]->Flatten@Lookup[myResolvedOptions,SeptenaryWash],
				Replace[SeptenaryWashBuffers]->Flatten@Map[Link[#]&,Replace[septenaryWashBuffers,uniqueSampleResourceLookup[uniqueSeptenaryWashBuffersAndVolumesAssoc],{2}],{2}],
				Replace[SeptenaryWashBufferVolumes]->Flatten@Lookup[myResolvedOptions,SeptenaryWashBufferVolume],
				Replace[SeptenaryWashAspirationVolumes]->Flatten@MapThread[
					Function[{septenaryWashAspirationVolumesBatch,septenaryWashBufferVolumesBatch},
						MapThread[
							If[MatchQ[#1,All],#2,#1]&,
							{septenaryWashAspirationVolumesBatch,septenaryWashBufferVolumesBatch}
						]
					],
					{Lookup[myResolvedOptions,SeptenaryWashAspirationVolume],Lookup[myResolvedOptions,SeptenaryWashBufferVolume]}
				],
				Replace[NumberOfSeptenaryWashes]->Flatten@Lookup[myResolvedOptions,NumberOfSeptenaryWashes],
				Replace[SeptenaryWashCollectionContainers]->Flatten@Map[Link[#]&,septenaryWashCollectionContainerResources],
				Replace[SeptenaryWashDestinationWells]->Flatten@Lookup[myResolvedOptions,SeptenaryWashDestinationWell],
				Replace[SeptenaryWashCollectionStorageConditions]->Flatten@septenaryWashCollectionStorageConditions,

				(* === Elution === *)
				Replace[Elutions]->Flatten@Lookup[myResolvedOptions,Elution],
				Replace[ElutionBuffers]->Flatten@Map[Link[#]&,Replace[elutionBuffers,uniqueSampleResourceLookup[uniqueElutionBuffersAndVolumesAssoc],{2}],{2}],
				Replace[ElutionBufferVolumes]->Flatten@Lookup[myResolvedOptions,ElutionBufferVolume],
				Replace[ElutionAspirationVolumes]->Flatten@MapThread[
					Function[{elutionAspirationVolumesBatch,elutionBufferVolumesBatch},
						MapThread[
							If[MatchQ[#1,All],#2,#1]&,
							{elutionAspirationVolumesBatch,elutionBufferVolumesBatch}
						]
					],
					{Lookup[myResolvedOptions,ElutionAspirationVolume],Lookup[myResolvedOptions,ElutionBufferVolume]}
				],
				Replace[NumberOfElutions]->Flatten@Lookup[myResolvedOptions,NumberOfElutions],
				Replace[ElutionCollectionContainers]->Flatten@Map[Link[#]&,elutionCollectionContainerResources],
				Replace[ElutionDestinationWells]->Flatten@Lookup[myResolvedOptions,ElutionDestinationWell],
				Replace[ElutionCollectionStorageConditions]->Flatten@elutionCollectionStorageConditions
			|>;

			SimulateResources[
				protocolPacket,
				Simulation->Lookup[ToList[myResolutionOptions], Simulation, Null],
				PooledSamplesIn->myNestedSamples
			]
		],
		(* Otherwise, our resource packets went fine and we have an Object[Protocol, MagneticBeadSeparation]. *)
		True,
		SimulateResources[
			myProtocolPacket,
			ParentProtocol->Lookup[myResolvedOptions, ParentProtocol, Null],
			Simulation->Lookup[ToList[myResolutionOptions], Simulation, Null],
			PooledSamplesIn->myNestedSamples
		]
	];


	(* Here we will always have an Object[Protocol,MagneticBeadSeparation]. Extract the necessary fields from the protocol object *)
	{
		workingSamples,volumes,magneticBeads,magneticBeadVolumes,magnetizationRacks,assayContainers,assayWells,separationMode,analyteAffinityLabels,targets,magneticBeadAffinityLabels,selectionStrategy,samplesOut,
		preWashes,preWashBuffers,preWashBufferVolumes,preWashAspirationVolumes,numberOfPreWashes,preWashCollectionContainers,preWashCollectionStorageConditions,preWashDestinationWells,
		equilibrations,equilibrationBuffers,equilibrationBufferVolumes,equilibrationAspirationVolumes,equilibrationCollectionContainers,equilibrationCollectionStorageConditions,equilibrationDestinationWells,
		loadingAspirationVolumes,loadingCollectionContainers,loadingCollectionStorageConditions,loadingDestinationWells,
		washes,washBuffers,washBufferVolumes,washAspirationVolumes,numberOfWashes,washCollectionContainers,washCollectionStorageConditions,washDestinationWells,
		secondaryWashes,secondaryWashBuffers,secondaryWashBufferVolumes,secondaryWashAspirationVolumes,numberOfSecondaryWashes,secondaryWashCollectionContainers,secondaryWashCollectionStorageConditions,secondaryWashDestinationWells,
		tertiaryWashes,tertiaryWashBuffers,tertiaryWashBufferVolumes,tertiaryWashAspirationVolumes,numberOfTertiaryWashes,tertiaryWashCollectionContainers,tertiaryWashCollectionStorageConditions,tertiaryWashDestinationWells,
		quaternaryWashes,quaternaryWashBuffers,quaternaryWashBufferVolumes,quaternaryWashAspirationVolumes,numberOfQuaternaryWashes,quaternaryWashCollectionContainers,quaternaryWashCollectionStorageConditions,quaternaryWashDestinationWells,
		quinaryWashes,quinaryWashBuffers,quinaryWashBufferVolumes,quinaryWashAspirationVolumes,numberOfQuinaryWashes,quinaryWashCollectionContainers,quinaryWashCollectionStorageConditions,quinaryWashDestinationWells,
		senaryWashes,senaryWashBuffers,senaryWashBufferVolumes,senaryWashAspirationVolumes,numberOfSenaryWashes,senaryWashCollectionContainers,senaryWashCollectionStorageConditions,senaryWashDestinationWells,
		septenaryWashes,septenaryWashBuffers,septenaryWashBufferVolumes,septenaryWashAspirationVolumes,numberOfSeptenaryWashes,septenaryWashCollectionContainers,septenaryWashCollectionStorageConditions,septenaryWashDestinationWells,
		elutions,elutionBuffers,elutionBufferVolumes,elutionAspirationVolumes,numberOfElutions,elutionCollectionContainers,elutionCollectionStorageConditions,elutionDestinationWells,
		containerPackets
	}= Module[
		{
			baseInfo,preWashInfo,equilibrationInfo,loadingInfo,washInfo,secondaryWashInfo,tertiaryWashInfo,quaternaryWashInfo,quinaryWashInfo,senaryWashInfo,septenaryWashInfo,elutionInfo,assayContainerPacket,
			preWashContainerPacket,equilibrationContainerPacket,loadingContainerPacket,washContainerPacket,secondaryWashContainerPacket,tertiaryWashContainerPacket,quaternaryWashContainerPacket,quinaryWashContainerPacket,senaryWashContainerPacket,septenaryWashContainerPacket, elutionContainerPacket,combinedContainerPackets,batchLengths,unflattenedBaseInfo,
			unflattenedPreWashInfo,unflattenedEquilibrationInfo, unflattenedLoadingInfo,unflattenedWashInfo,unflattenedSecondaryWashInfo,unflattenedTertiaryWashInfo,unflattenedQuaternaryWashInfo,unflattenedQuinaryWashInfo,unflattenedSenaryWashInfo,unflattenedSeptenaryWashInfo,unflattenedElutionInfo
		},

		(* Download the needed info *)
		{
			baseInfo,
			preWashInfo,
			equilibrationInfo,
			loadingInfo,
			washInfo,secondaryWashInfo,
			tertiaryWashInfo,
			quaternaryWashInfo,
			quinaryWashInfo,
			senaryWashInfo,
			septenaryWashInfo,
			elutionInfo,
			assayContainerPacket,
			preWashContainerPacket,
			equilibrationContainerPacket,
			loadingContainerPacket,
			washContainerPacket,
			secondaryWashContainerPacket,
			tertiaryWashContainerPacket,
			quaternaryWashContainerPacket,
			quinaryWashContainerPacket,
			senaryWashContainerPacket,
			septenaryWashContainerPacket,
			elutionContainerPacket
		}=Quiet[
			Download[
				protocolObject,
				{
					Packet[BatchLengths,WorkingSamples,Volumes,MagneticBeads,MagneticBeadVolumes,MagnetizationRacks,AssayContainers,AssayWells,SeparationMode,AnalyteAffinityLabels,Targets,MagneticBeadAffinityLabels,SelectionStrategy,SamplesOut],
					Packet[PreWashes,PreWashBuffers,PreWashBufferVolumes,PreWashAspirationVolumes,NumberOfPreWashes,PreWashCollectionContainers,PreWashCollectionStorageConditions,PreWashDestinationWells],
					Packet[Equilibrations,EquilibrationBuffers,EquilibrationBufferVolumes,EquilibrationAspirationVolumes,EquilibrationCollectionContainers,EquilibrationCollectionStorageConditions,EquilibrationDestinationWells],
					Packet[LoadingAspirationVolumes,LoadingCollectionContainers,LoadingCollectionStorageConditions,LoadingDestinationWells],
					Packet[Washes,WashBuffers,WashBufferVolumes,WashAspirationVolumes,NumberOfWashes,WashCollectionContainers,WashCollectionStorageConditions,WashDestinationWells],
					Packet[SecondaryWashes,SecondaryWashBuffers,SecondaryWashBufferVolumes,SecondaryWashAspirationVolumes,NumberOfSecondaryWashes,SecondaryWashCollectionContainers,SecondaryWashCollectionStorageConditions,SecondaryWashDestinationWells],
					Packet[TertiaryWashes,TertiaryWashBuffers,TertiaryWashBufferVolumes,TertiaryWashAspirationVolumes,NumberOfTertiaryWashes,TertiaryWashCollectionContainers,TertiaryWashCollectionStorageConditions,TertiaryWashDestinationWells],
					Packet[QuaternaryWashes,QuaternaryWashBuffers,QuaternaryWashBufferVolumes,QuaternaryWashAspirationVolumes,NumberOfQuaternaryWashes,QuaternaryWashCollectionContainers,QuaternaryWashCollectionStorageConditions,QuaternaryWashDestinationWells],
					Packet[QuinaryWashes,QuinaryWashBuffers,QuinaryWashBufferVolumes,QuinaryWashAspirationVolumes,NumberOfQuinaryWashes,QuinaryWashCollectionContainers,QuinaryWashCollectionStorageConditions,QuinaryWashDestinationWells],
					Packet[SenaryWashes,SenaryWashBuffers,SenaryWashBufferVolumes,SenaryWashAspirationVolumes,NumberOfSenaryWashes,SenaryWashCollectionContainers,SenaryWashCollectionStorageConditions,SenaryWashDestinationWells],
					Packet[SeptenaryWashes,SeptenaryWashBuffers,SeptenaryWashBufferVolumes,SeptenaryWashAspirationVolumes,NumberOfSeptenaryWashes,SeptenaryWashCollectionContainers,SeptenaryWashCollectionStorageConditions,SeptenaryWashDestinationWells],
					Packet[Elutions,ElutionBuffers,ElutionBufferVolumes,ElutionAspirationVolumes,NumberOfElutions,ElutionCollectionContainers,ElutionCollectionStorageConditions,ElutionDestinationWells],
					Packet[AssayContainers[{Contents, AllowedPositions}]],
					Packet[PreWashCollectionContainers[{Contents, AllowedPositions}]],
					Packet[EquilibrationCollectionContainers[{Contents, AllowedPositions}]],
					Packet[LoadingCollectionContainers[{Contents, AllowedPositions}]],
					Packet[WashCollectionContainers[{Contents, AllowedPositions}]],
					Packet[SecondaryWashCollectionContainers[{Contents, AllowedPositions}]],
					Packet[TertiaryWashCollectionContainers[{Contents, AllowedPositions}]],
					Packet[QuaternaryWashCollectionContainers[{Contents, AllowedPositions}]],
					Packet[QuinaryWashCollectionContainers[{Contents, AllowedPositions}]],
					Packet[SenaryWashCollectionContainers[{Contents, AllowedPositions}]],
					Packet[SeptenaryWashCollectionContainers[{Contents, AllowedPositions}]],
					Packet[ElutionCollectionContainers[{Contents, AllowedPositions}]]
				},
				Cache->inheritedCache,
				Simulation->currentSimulation
			],
			{
				Download::NotLinkField,Download::FieldDoesntExist
			}
		];

		(* combine container info *)
		combinedContainerPackets = FlattenCachePackets[{assayContainerPacket, preWashContainerPacket, equilibrationContainerPacket,loadingContainerPacket,washContainerPacket,secondaryWashContainerPacket,tertiaryWashContainerPacket,quaternaryWashContainerPacket,quinaryWashContainerPacket,senaryWashContainerPacket,septenaryWashContainerPacket,elutionContainerPacket}];

		(* Unflatten the needed info *)
		batchLengths=Lookup[baseInfo,BatchLengths];

		unflattenedBaseInfo=KeyValueMap[
			Which[
				MatchQ[#1,WorkingSamples],
				#2,
				MatchQ[#1,Object|ID|Type],
				Nothing,
				MatchQ[#2,_List]&&!MatchQ[#2,{}],
				TakeList[#2,batchLengths],
				True,
				#2
			]&,
			Rest[baseInfo]
		];
		unflattenedPreWashInfo=KeyValueMap[
			Which[
				MatchQ[#1,PreWashCollectionContainers|PreWashDestinationWells],
				TakeList[TakeList[#2,Lookup[preWashInfo,NumberOfPreWashes]/.Null->1],batchLengths],
				MatchQ[#1,Object|Type|ID],
				Nothing,
				True,
				TakeList[#2,batchLengths]
			]&,
			preWashInfo
		];
		unflattenedEquilibrationInfo=KeyValueMap[
			Which[
				MatchQ[#1,EquilibrationCollectionContainers|EquilibrationDestinationWells],
				Map[Function[{batch},({#})&/@batch],TakeList[#2,batchLengths]],
				MatchQ[#1,Object|Type|ID],
				Nothing,
				True,
				TakeList[#2,batchLengths]
			]&,
			equilibrationInfo
		];
		unflattenedLoadingInfo=KeyValueMap[
			Which[
				MatchQ[#1,LoadingCollectionContainers|LoadingDestinationWells],
				Map[Function[{batch},({#})&/@batch],TakeList[#2,batchLengths]],
				MatchQ[#1,Object|Type|ID],
				Nothing,
				True,
				TakeList[#2,batchLengths]
			]&,
			loadingInfo
		];
		unflattenedWashInfo=KeyValueMap[
			Which[
				MatchQ[#1,WashCollectionContainers|WashDestinationWells],
				TakeList[TakeList[#2,Lookup[washInfo,NumberOfWashes]/.Null->1],batchLengths],
				MatchQ[#1,Object|Type|ID],
				Nothing,
				True,
				TakeList[#2,batchLengths]
			]&,
			washInfo
		];
		unflattenedSecondaryWashInfo=KeyValueMap[
			Which[
				MatchQ[#1,SecondaryWashCollectionContainers|SecondaryWashDestinationWells],
				TakeList[TakeList[#2,Lookup[secondaryWashInfo,NumberOfSecondaryWashes]/.Null->1],batchLengths],
				MatchQ[#1,Object|Type|ID],
				Nothing,
				True,
				TakeList[#2,batchLengths]
			]&,
			secondaryWashInfo
		];
		unflattenedTertiaryWashInfo=KeyValueMap[
			Which[
				MatchQ[#1,TertiaryWashCollectionContainers|TertiaryWashDestinationWells],
				TakeList[TakeList[#2,Lookup[tertiaryWashInfo,NumberOfTertiaryWashes]/.Null->1],batchLengths],
				MatchQ[#1,Object|Type|ID],
				Nothing,
				True,
				TakeList[#2,batchLengths]
			]&,
			tertiaryWashInfo
		];
		unflattenedQuaternaryWashInfo=KeyValueMap[
			Which[
				MatchQ[#1,QuaternaryWashCollectionContainers|QuaternaryWashDestinationWells],
				TakeList[TakeList[#2,Lookup[quaternaryWashInfo,NumberOfQuaternaryWashes]/.Null->1],batchLengths],
				MatchQ[#1,Object|Type|ID],
				Nothing,
				True,
				TakeList[#2,batchLengths]
			]&,
			quaternaryWashInfo
		];
		unflattenedQuinaryWashInfo=KeyValueMap[
			Which[
				MatchQ[#1,QuinaryWashCollectionContainers|QuinaryWashDestinationWells],
				TakeList[TakeList[#2,Lookup[quinaryWashInfo,NumberOfQuinaryWashes]/.Null->1],batchLengths],
				MatchQ[#1,Object|Type|ID],
				Nothing,
				True,
				TakeList[#2,batchLengths]
			]&,
			quinaryWashInfo
		];
		unflattenedSenaryWashInfo=KeyValueMap[
			Which[
				MatchQ[#1,SenaryWashCollectionContainers|SenaryWashDestinationWells],
				TakeList[TakeList[#2,Lookup[senaryWashInfo,NumberOfSenaryWashes]/.Null->1],batchLengths],
				MatchQ[#1,Object|Type|ID],
				Nothing,
				True,
				TakeList[#2,batchLengths]
			]&,
			senaryWashInfo
		];
		unflattenedSeptenaryWashInfo=KeyValueMap[
			Which[
				MatchQ[#1,SeptenaryWashCollectionContainers|SeptenaryWashDestinationWells],
				TakeList[TakeList[#2,Lookup[septenaryWashInfo,NumberOfSeptenaryWashes]/.Null->1],batchLengths],
				MatchQ[#1,Object|Type|ID],
				Nothing,
				True,
				TakeList[#2,batchLengths]
			]&,
			septenaryWashInfo
		];
		unflattenedElutionInfo=KeyValueMap[
			Which[
				MatchQ[#1,ElutionCollectionContainers|ElutionDestinationWells],
				TakeList[TakeList[#2,Lookup[elutionInfo,NumberOfElutions]/.Null->1],batchLengths],
				MatchQ[#1,Object|Type|ID],
				Nothing,
				True,
				TakeList[#2,batchLengths]
			]&,
			elutionInfo
		];

		Append[
			Flatten[
				{
					unflattenedBaseInfo,
					(* PreWash *)
					unflattenedPreWashInfo,
					(* Equilibration *)
					unflattenedEquilibrationInfo,
					(* Loading *)
					unflattenedLoadingInfo,
					(* Wash *)
					unflattenedWashInfo,
					(* SecondaryWash *)
					unflattenedSecondaryWashInfo,
					(* TertiaryWash *)
					unflattenedTertiaryWashInfo,
					(* QuaternaryWash *)
					unflattenedQuaternaryWashInfo,
					(* QuinaryWash *)
					unflattenedQuinaryWashInfo,
					(* SenaryWash *)
					unflattenedSenaryWashInfo,
					(* SeptenaryWash *)
					unflattenedSeptenaryWashInfo,
					(* Elution *)
					unflattenedElutionInfo
				},
				{1,2}
			],
			combinedContainerPackets
		]
	];

	(* Add the container packets to the cache *)
	combinedCache = FlattenCachePackets[{inheritedCache,containerPackets}];

	combinedFastAssoc = makeFastAssocFromCache[combinedCache];

	(* Create tuples that UploadSampleTransfer can accept *)
	(* --- Magnetic Beads --- *)
	magneticBeadTuples=Flatten[MapThread[
		Function[
			{
				assayContainersBatch,assayWellsBatch,magneticBeadsBatch,magneticBeadVolumesBatch
			},
			Join@@{
				MapThread[
					{#1,#2,#3}&,
					{
						magneticBeadsBatch,
						Transpose[{assayWellsBatch,assayContainersBatch}],
						magneticBeadVolumesBatch
					}
				]
			}
		],
		{
			assayContainers,assayWells,magneticBeads,magneticBeadVolumes
		}
	],
		1
	];

	flattenedPreWashTuples=simulateWashStageTuples[preWashes,preWashBuffers,preWashBufferVolumes,preWashAspirationVolumes,numberOfPreWashes,preWashCollectionContainers,preWashDestinationWells,assayContainers,assayWells];

	equilibrationTuples=Flatten[MapThread[
		Function[
			{
				equilibrationsBatch,equilibrationBuffersBatch,equilibrationBufferVolumesBatch,equilibrationAspirationVolumesBatch,equilibrationCollectionContainersBatch,
				equilibrationCollectionStorageConditionsBatch,equilibrationDestinationWellsBatch,
				assayContainersBatch,assayWellsBatch,magnetizationRacksBatch
			},
			Module[{},

				If[Or@@equilibrationsBatch,
					Join@@{
						MapThread[
							{#1,#2,#3}&,
							{
								PickList[equilibrationBuffersBatch,equilibrationsBatch],
								Transpose[{PickList[assayWellsBatch,equilibrationsBatch],PickList[assayContainersBatch,equilibrationsBatch]}],
								PickList[equilibrationBufferVolumesBatch,equilibrationsBatch]
							}
						],
						MapThread[
							{#1,#2,#3}&,
							{
								Transpose[{PickList[assayWellsBatch,equilibrationsBatch],PickList[assayContainersBatch,equilibrationsBatch]}],
								Transpose[{PickList[equilibrationDestinationWellsBatch,equilibrationsBatch][[All,1]],PickList[equilibrationCollectionContainersBatch,equilibrationsBatch][[All,1]]}],
								PickList[equilibrationAspirationVolumesBatch,equilibrationsBatch]
							}
						]
					},
					{}
				]
			]
		],
		{
			equilibrations,equilibrationBuffers,equilibrationBufferVolumes,equilibrationAspirationVolumes,
			equilibrationCollectionContainers,equilibrationCollectionStorageConditions,equilibrationDestinationWells,
			assayContainers,assayWells,magnetizationRacks
		}
	],
		1
	];

	loadingTuples=Flatten[MapThread[
		Function[
			{
				volumesBatch,loadingAspirationVolumesBatch,loadingCollectionContainersBatch,
				loadingDestinationWellsBatch,assayContainersBatch,assayWellsBatch,workingSamplesBatch
			},

			Join@@{
				(* Transfer loadingBuffer into assay container Move to the magnet then transfer to collection container *)
				MapThread[
					{#1,#2,#3}&,
					{
						workingSamplesBatch,
						Transpose[{assayWellsBatch,assayContainersBatch}],
						volumesBatch
					}
				],
				MapThread[
					{#1,#2,#3}&,
					{
						Transpose[{assayWellsBatch,assayContainersBatch}],
						Transpose[{loadingDestinationWellsBatch[[All,1]],loadingCollectionContainersBatch[[All,1]]}],
						loadingAspirationVolumesBatch
					}
				]
			}
		],
		{
			volumes,loadingAspirationVolumes,loadingCollectionContainers,loadingDestinationWells,
			assayContainers,assayWells,workingSamples
		}
	],
		1
	];

	flattenedWashTuples=simulateWashStageTuples[washes,washBuffers,washBufferVolumes,washAspirationVolumes,numberOfWashes,washCollectionContainers,washDestinationWells,assayContainers,assayWells];

	flattenedSecondaryWashTuples=simulateWashStageTuples[secondaryWashes,secondaryWashBuffers,secondaryWashBufferVolumes,secondaryWashAspirationVolumes,numberOfSecondaryWashes,secondaryWashCollectionContainers,secondaryWashDestinationWells,assayContainers,assayWells];

	flattenedTertiaryWashTuples=simulateWashStageTuples[tertiaryWashes,tertiaryWashBuffers,tertiaryWashBufferVolumes,tertiaryWashAspirationVolumes,numberOfTertiaryWashes,tertiaryWashCollectionContainers,tertiaryWashDestinationWells,assayContainers,assayWells];

	flattenedQuaternaryWashTuples=simulateWashStageTuples[quaternaryWashes,quaternaryWashBuffers,quaternaryWashBufferVolumes,quaternaryWashAspirationVolumes,numberOfQuaternaryWashes,quaternaryWashCollectionContainers,quaternaryWashDestinationWells,assayContainers,assayWells];

	flattenedQuinaryWashTuples=simulateWashStageTuples[quinaryWashes,quinaryWashBuffers,quinaryWashBufferVolumes,quinaryWashAspirationVolumes,numberOfQuinaryWashes,quinaryWashCollectionContainers,quinaryWashDestinationWells,assayContainers,assayWells];

	flattenedSenaryWashTuples=simulateWashStageTuples[senaryWashes,senaryWashBuffers,senaryWashBufferVolumes,senaryWashAspirationVolumes,numberOfSenaryWashes,senaryWashCollectionContainers,senaryWashDestinationWells,assayContainers,assayWells];

	flattenedSeptenaryWashTuples=simulateWashStageTuples[septenaryWashes,septenaryWashBuffers,septenaryWashBufferVolumes,septenaryWashAspirationVolumes,numberOfSeptenaryWashes,septenaryWashCollectionContainers,septenaryWashDestinationWells,assayContainers,assayWells];

	elutionTuples=MapThread[
		Function[
			{
				elutionsBatch,elutionBuffersBatch,elutionBufferVolumesBatch,elutionAspirationVolumesBatch,numberOfElutionsBatch,elutionCollectionContainersBatch,
				elutionDestinationWellsBatch,assayContainersBatch,assayWellsBatch
			},

			Module[{maxNumElutions,numberOfElutionsBatchBools},
				(* Get the max number of times we are Elutioning in this batch *)
				maxNumElutions=Max[DeleteCases[numberOfElutionsBatch,Null],{0}];

				(* Table that number of prewashes *)
				Table[

					(* See what samples we use this round *)
					numberOfElutionsBatchBools=(LessEqualQ[i,#])&/@numberOfElutionsBatch;

					If[Or@@numberOfElutionsBatchBools,
						Join@@{
							(* Transfer elutionBuffer into assay container, then move to the magnet then transfer to collection container *)
							MapThread[
								{#1,#2,#3}&,
								{
									PickList[elutionBuffersBatch,numberOfElutionsBatchBools],
									Transpose[{PickList[assayWellsBatch,numberOfElutionsBatchBools],PickList[assayContainersBatch,numberOfElutionsBatchBools]}],
									PickList[elutionBufferVolumesBatch,numberOfElutionsBatchBools]
								}
							],
							MapThread[
								{#1,#2,#3}&,
								{
									Transpose[{PickList[assayWellsBatch,numberOfElutionsBatchBools],PickList[assayContainersBatch,numberOfElutionsBatchBools]}],
									Transpose[{PickList[elutionDestinationWellsBatch,numberOfElutionsBatchBools][[All,i]],PickList[elutionCollectionContainersBatch,numberOfElutionsBatchBools][[All,i]]}],
									PickList[elutionAspirationVolumesBatch,numberOfElutionsBatchBools]
								}
							]
						},
						Nothing
					],
					{i,1,maxNumElutions}
				]
			]
		],
		{
			elutions,elutionBuffers,elutionBufferVolumes,elutionAspirationVolumes,numberOfElutions,elutionCollectionContainers,
			elutionDestinationWells,assayContainers,assayWells
		}
	];

	flattenedElutionTuples=If[MatchQ[elutionTuples,ListableP[{}]],
		{},
		Flatten[elutionTuples,{1,2,3}]
	];

	(* Gather sources/destination/amounts together *)
	groupedTuples=Join[magneticBeadTuples,flattenedPreWashTuples,equilibrationTuples,loadingTuples,flattenedWashTuples,flattenedSecondaryWashTuples,flattenedTertiaryWashTuples,flattenedQuaternaryWashTuples,flattenedQuinaryWashTuples,flattenedSenaryWashTuples,flattenedSeptenaryWashTuples,flattenedElutionTuples];

	(* Filter out transfers that are not in a valid form (they just won't be simulated) or the destination position is invalid *)
	tuplesWithCorrectFormat=Map[
		If[MatchQ[#[[2]],{_String,ObjectP[Object[Container]]}],
			Module[{container,desiredPos,model,positions},
				container=#[[2,2]];
				desiredPos=#[[2,1]];
				positions=fastAssocLookup[combinedFastAssoc,container,AllowedPositions];
				If[MemberQ[List@@positions,desiredPos],
					#,
					Nothing
				]
			],
			#
		]&,
		Cases[groupedTuples,{ObjectP[Object[Sample]]|{_String,ObjectP[Object[Container]]},ObjectP[Object[Sample]]|{_String,ObjectP[Object[Container]]},GreaterP[0 Microliter]}]
	];

	(* Upload "Empty" sample to any destination samples that do not already have a sample *)

	(* Define function to pick out destinations that do not have a sample *)
	destNoSampleFunc = Function[{destination},
		Module[{contents},
			(* If the destination is not a {Well, Container} there is already a sample *)
			If[MatchQ[destination,{_String,ObjectP[Object[Container]]}],
				(* If the destination is a {Well,Container} check if the Well is in the Contents of the container *)
				contents = fastAssocLookup[combinedFastAssoc,destination[[2]],Contents];

				(* If the contents are Null there is no sample in the well *)
				If[MatchQ[contents,Null|$Failed],
					True,
					(* If there are contents check if the well is already occupied *)
					!MemberQ[contents[[All,1]],destination[[1]]]
				],
				False
			]
		]
	];

	(* Pick out destinations that do not have a sample *)
	destinationsWithoutSamples = Select[tuplesWithCorrectFormat[[All,2]],destNoSampleFunc];

	(* Upload an empty sample to them *)
	uploadSamplePackets=UploadSample[
		(* NOTE: UploadSample takes in {} instead of Null if there is no model. *)
		ConstantArray[{}, Length[destinationsWithoutSamples]],(* temp fix but we still need to handle model-less case *)
		destinationsWithoutSamples,
		State->Liquid,
		InitialAmount->ConstantArray[Null, Length[destinationsWithoutSamples]],
		UpdatedBy->protocolObject,
		Simulation->currentSimulation,
		SimulationMode -> True,
		FastTrack->True,
		Upload->False
	];

	(* Update our simulation. *)
	currentSimulation=UpdateSimulation[currentSimulation, Simulation[uploadSamplePackets]];

	(* Retrieve samples inside all containers *)
	containerPackets=Download[
		(* All source/destination containers that are not already specified as samples *)
		DeleteDuplicates[Cases[Flatten[tuplesWithCorrectFormat,1],{_String,ObjectP[Object[Container]]}][[All,2]]],
		Packet[Contents],
		Cache->inheritedCache,
		Simulation->currentSimulation
	];

	(* convert all destinations and sources into Object[Sample] form *)
	tuplesWithAllObjectSamples=tuplesWithCorrectFormat/.{{well_String,container:ObjectP[Object[Container]]}:>Download[FirstCase[Lookup[fetchPacketFromCache[container,containerPackets],Contents],{well,_}][[2]],Object]};

	(* Call UploadSampleTransfer *)
	uploadSampleTransferPackets=UploadSampleTransfer[
		tuplesWithAllObjectSamples[[All,1]],
		tuplesWithAllObjectSamples[[All,2]],
		tuplesWithAllObjectSamples[[All,3]],
		Upload->False,
		FastTrack->True,
		Simulation->currentSimulation
	];

	(* UpdateSimulation *)
	currentSimulation=UpdateSimulation[currentSimulation,Simulation[uploadSampleTransferPackets]];

	(* Determine the simulated samples out *)
	simulatedSamplesOut=If[MatchQ[selectionStrategy,Positive],
		MapThread[
			Function[{containerBatch,wellBatch},
				MapThread[
					Function[{containers,wells},
						Map[
							Download[FirstCase[Lookup[fetchPacketFromCache[#[[2]],containerPackets],Contents,Null],{#[[1]],_},{Null,Null}][[2]],Object]&,
							Transpose[{wells,containers}]
						]
					],
					{containerBatch,wellBatch}
				]
			],
			{elutionCollectionContainers,elutionDestinationWells}
		],
		MapThread[
			Function[{containerBatch,wellBatch},
				MapThread[
					Function[{containers,wells},
						Map[
							Download[FirstCase[Lookup[fetchPacketFromCache[#[[2]],containerPackets],Contents,Null],{#[[1]],_},{Null,Null}][[2]],Object]&,
							Transpose[{wells,containers}]
						]
					],
					{containerBatch,wellBatch}
				]
			],
			{loadingCollectionContainers,loadingDestinationWells}
		]
	]/.{Null->Nothing};

	(* Label options *)
	simulatedLabels=Simulation[
		Labels->Join[
			Rule@@@Cases[
				Transpose[{Lookup[myResolvedOptions, SampleLabel], workingSamples}],
				{_String, ObjectP[]}
			],
			Rule@@@Cases[
				Transpose[{Lookup[myResolvedOptions, SampleContainerLabel], fastAssocLookup[combinedFastAssoc,#,Container]&/@workingSamples}],
				{_String, ObjectP[]}
			],
			Rule@@@Cases[
				Transpose[{Take[Flatten@Lookup[myResolvedOptions, SampleOutLabel],Length[Flatten@simulatedSamplesOut]], Flatten@simulatedSamplesOut}],
				{_String, ObjectP[]}
			],
			Rule@@@Cases[
				Transpose[{Flatten@Lookup[myResolvedOptions, ContainerOutLabel],If[MatchQ[selectionStrategy,Positive],Flatten[elutionCollectionContainers],Flatten[loadingCollectionContainers]]}],
				{_String, ObjectP[]}
			],
			Rule@@@Cases[
				Transpose[{Flatten@normalizeResolvedContainersForSimulation[Lookup[myResolvedOptions, PreWashCollectionContainer]],Flatten[preWashCollectionContainers]}],
				{_String, ObjectP[]}
			],
			Rule@@@Cases[
				Transpose[{Flatten@normalizeResolvedContainersForSimulation[Lookup[myResolvedOptions, EquilibrationCollectionContainer]],Flatten[equilibrationCollectionContainers]}],
				{_String, ObjectP[]}
			],
			Rule@@@Cases[
				Transpose[{Flatten@normalizeResolvedContainersForSimulation[Lookup[myResolvedOptions, LoadingCollectionContainer]],Flatten[loadingCollectionContainers]}],
				{_String, ObjectP[]}
			],
			Rule@@@Cases[
				Transpose[{Flatten@normalizeResolvedContainersForSimulation[Lookup[myResolvedOptions, WashCollectionContainer]],Flatten[washCollectionContainers]}],
				{_String, ObjectP[]}
			],
			Rule@@@Cases[
				Transpose[{Flatten@normalizeResolvedContainersForSimulation[Lookup[myResolvedOptions, SecondaryWashCollectionContainer]],Flatten[secondaryWashCollectionContainers]}],
				{_String, ObjectP[]}
			],
			Rule@@@Cases[
				Transpose[{Flatten@normalizeResolvedContainersForSimulation[Lookup[myResolvedOptions, TertiaryWashCollectionContainer]],Flatten[tertiaryWashCollectionContainers]}],
				{_String, ObjectP[]}
			],
			Rule@@@Cases[
				Transpose[{Flatten@normalizeResolvedContainersForSimulation[Lookup[myResolvedOptions, QuaternaryWashCollectionContainer]],Flatten[quaternaryWashCollectionContainers]}],
				{_String, ObjectP[]}
			],
			Rule@@@Cases[
				Transpose[{Flatten@normalizeResolvedContainersForSimulation[Lookup[myResolvedOptions, QuinaryWashCollectionContainer]],Flatten[quinaryWashCollectionContainers]}],
				{_String, ObjectP[]}
			],
			Rule@@@Cases[
				Transpose[{Flatten@normalizeResolvedContainersForSimulation[Lookup[myResolvedOptions, SenaryWashCollectionContainer]],Flatten[senaryWashCollectionContainers]}],
				{_String, ObjectP[]}
			],
			Rule@@@Cases[
				Transpose[{Flatten@normalizeResolvedContainersForSimulation[Lookup[myResolvedOptions, SeptenaryWashCollectionContainer]],Flatten[septenaryWashCollectionContainers]}],
				{_String, ObjectP[]}
			],
			Rule@@@Cases[
				Transpose[{Flatten@normalizeResolvedContainersForSimulation[Lookup[myResolvedOptions, ElutionCollectionContainer]],Flatten[elutionCollectionContainers]}],
				{_String, ObjectP[]}
			]
		],
		LabelFields->If[MatchQ[resolvedPreparation, Manual],
			Join[
				Rule@@@Cases[
					Transpose[{Flatten@Lookup[myResolvedOptions, SampleLabel], (Field[Protocol[SampleResources][[#]]]&)/@Range[Length[Flatten[workingSamples]]]}],
					{_String, _}
				],
				Rule@@@Cases[
					Transpose[{Flatten@Lookup[myResolvedOptions, SampleContainerLabel], (Field[Protocol[SampleResources][[#]][Container]]&)/@Range[Length[Flatten[workingSamples]]]}],
					{_String, _}
				],
				Rule@@@Cases[
					Transpose[{Flatten@Lookup[myResolvedOptions, SampleOutLabel], (Field[Protocol[SamplesOut[[#]]]]&)/@Range[Length[Flatten@simulatedSamplesOut]]}],
					{_String, _}
				],
				Rule@@@Cases[
					Transpose[{
						Flatten@Lookup[myResolvedOptions, ContainerOutLabel],
						If[MatchQ[selectionStrategy,Positive],
							(Field[Protocol[ElutionCollectionContainer[[#]]]]&)/@Range[Length[Flatten[elutionCollectionContainers]]],
							(Field[Protocol[LoadingCollectionContainer[[#]]]]&)/@Range[Length[Flatten[loadingCollectionContainers]]]
						]}],
					{_String, _}
				],
				Rule@@@Cases[
					Transpose[{Flatten@Lookup[myResolvedOptions, PreWashCollectionContainerLabel], (Field[Protocol[PreWashCollectionContainer[[#]]]]&)/@Range[Length[Flatten[preWashCollectionContainers]]]}],
					{_String, _}
				],
				Rule@@@Cases[
					Transpose[{Flatten@Lookup[myResolvedOptions, EquilibrationCollectionContainerLabel], (Field[Protocol[EquilibrationCollectionContainer[[#]]]]&)/@Range[Length[Flatten[equilibrationCollectionContainers]]]}],
					{_String, _}
				],
				Rule@@@Cases[
					Transpose[{Flatten@Lookup[myResolvedOptions, LoadingCollectionContainerLabel], (Field[Protocol[LoadingCollectionContainer[[#]]]]&)/@Range[Length[Flatten[loadingCollectionContainers]]]}],
					{_String, _}
				],
				Rule@@@Cases[
					Transpose[{Flatten@Lookup[myResolvedOptions, WashCollectionContainerLabel], (Field[Protocol[WashCollectionContainer[[#]]]]&)/@Range[Length[Flatten[washCollectionContainers]]]}],
					{_String, _}
				],
				Rule@@@Cases[
					Transpose[{Flatten@Lookup[myResolvedOptions, SecondaryWashCollectionContainerLabel], (Field[Protocol[SecondaryWashCollectionContainer[[#]]]]&)/@Range[Length[Flatten[secondaryWashCollectionContainers]]]}],
					{_String, _}
				],
				Rule@@@Cases[
					Transpose[{Flatten@Lookup[myResolvedOptions, TertiaryWashCollectionContainerLabel], (Field[Protocol[TertiaryWashCollectionContainer[[#]]]]&)/@Range[Length[Flatten[tertiaryWashCollectionContainers]]]}],
					{_String, _}
				],
				Rule@@@Cases[
					Transpose[{Flatten@Lookup[myResolvedOptions, QuaternaryWashCollectionContainerLabel], (Field[Protocol[QuaternaryWashCollectionContainer[[#]]]]&)/@Range[Length[Flatten[quaternaryWashCollectionContainers]]]}],
					{_String, _}
				],
				Rule@@@Cases[
					Transpose[{Flatten@Lookup[myResolvedOptions, QuinaryWashCollectionContainerLabel], (Field[Protocol[QuinaryWashCollectionContainer[[#]]]]&)/@Range[Length[Flatten[quinaryWashCollectionContainers]]]}],
					{_String, _}
				],
				Rule@@@Cases[
					Transpose[{Flatten@Lookup[myResolvedOptions, SenaryWashCollectionContainerLabel], (Field[Protocol[SenaryWashCollectionContainer[[#]]]]&)/@Range[Length[Flatten[senaryWashCollectionContainers]]]}],
					{_String, _}
				],
				Rule@@@Cases[
					Transpose[{Flatten@Lookup[myResolvedOptions, SeptenaryWashCollectionContainerLabel], (Field[Protocol[SeptenaryWashCollectionContainer[[#]]]]&)/@Range[Length[Flatten[septenaryWashCollectionContainers]]]}],
					{_String, _}
				],
				Rule@@@Cases[
					Transpose[{Flatten@Lookup[myResolvedOptions, ElutionCollectionContainerLabel], (Field[Protocol[ElutionCollectionContainer[[#]]]]&)/@Range[Length[Flatten[elutionCollectionContainers]]]}],
					{_String, _}
				]
			],
			{}
		]
	];
	{
		protocolObject,
		UpdateSimulation[currentSimulation, simulatedLabels]
	}
];
