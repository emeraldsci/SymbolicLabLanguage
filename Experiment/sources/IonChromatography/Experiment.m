(* ::Package:: *)

(* ::Text:: *)
(*\[Copyright] 2011-2023 Emerald Cloud Lab, Inc.*)


(* ::Subsection::Closed:: *)
(*ExperimentIonChromatography Options*)


DefineOptions[ExperimentIonChromatography,
	Options :> {

		(* --- Instrument Configuration Options --- *)
		IndexMatching[
			IndexMatchingInput -> "experiment samples",
			{
				OptionName -> AnalysisChannel,
				Default -> Automatic,
				Description -> "The flow path into which the sample is injected. CationChannel and AnionChannel employ suppressed conductivity detection for common cations and anions respectively whereas ElectrochemicalChannel employs electrochemical and/or UV detection for polysaccharides and beyond.",
				ResolutionDescription -> "Automatically set from the Composition and/or Analytes of the Samples. If the sample contains any oligomer, this option will automatically set to ElectrochemicalChannel. If the sample consists of two or more analytes in the common cation list (Lithium, Sodium, Ammonium, Potassium, Magnesium, and Calcium), this option will automatically set to CationChannel. If the sample consists of two or more analytes in the common anion list (Fluoride, Chloride, Bromide, Nitrate, Sulfate, and Phosphate), this option will automatically set to AnionChannel. If a sample meets both cation and anion criteria or if neither Composition nor Analytes is specified for the sample, this option defaults to AnionChannel.",
				AllowNull -> False,
				Widget -> Widget[
					Type -> Enumeration,
					Pattern :> AnalysisChannelP
				],
				Category -> "General"
			}
		],
		{
			OptionName -> Instrument,
			Default -> Automatic,
			Description -> "The measurement device on which the protocol is to be run.",
			ResolutionDescription -> "Automatically set to instrument with the specified AnalysisChannel.",
			AllowNull -> False,
			Widget -> Widget[
				Type -> Object,
				Pattern :> ObjectP[{Model[Instrument, IonChromatography], Object[Instrument, IonChromatography]}]
			],
			Category -> "General"
		},


		(* ================================================ *)
		(* === Double channel ICS 6000 Specific Options === *)
		(* ================================================ *)

		IndexMatching[
			IndexMatchingParent -> AnionSamples,
			{
				OptionName -> AnionSamples,
				Default -> Automatic,
				Description -> "A list of samples to be injected into the flow path of AnionChannel.",
				ResolutionDescription -> "Automatically compiled from samples with AnalysisChannel set to AnionChannel.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Object,
					Pattern :> ObjectP[{Model[Sample], Object[Sample]}]
				],
				Category -> "General"
			}
		],
		IndexMatching[
			IndexMatchingParent -> CationSamples,
			{
				OptionName -> CationSamples,
				Default -> Automatic,
				Description -> "A list of samples to be injected into the flow path of CationChannel.",
				ResolutionDescription -> "Automatically compiled from samples with AnalysisChannel set to CationChannel.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Object,
					Pattern :> ObjectP[{Model[Sample], Object[Sample]}]
				],
				Category -> "General"
			}
		],
		{
			OptionName -> AnionColumn,
			Default -> Automatic,
			Description -> "A device with positively-charged resin through which the buffer and AnionSamples flow. It adsorbs and separates negatively-charged molecules within the sample based on the properties of the buffers, samples, and column temperature.",
			ResolutionDescription -> "Automatically set to a column model in stock with positively-charged stationary phase.",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Object,
				Pattern :> ObjectP[{Model[Item, Column], Object[Item, Column]}]
			],
			Category -> "General"
		},
		{
			OptionName -> CationColumn,
			Default -> Automatic,
			Description -> "A device with negatively-charged resin through which the buffer and CationSamples flow. It adsorbs and separates position-charged molecules within the sample based on the properties of the buffers, samples, and column temperature.",
			ResolutionDescription -> "Automatically set to a column model in stock with negatively-charged stationary phase.",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Object,
				Pattern :> ObjectP[{Model[Item, Column], Object[Item, Column]}]
			],
			Category -> "General"
		},
		{
			OptionName -> AnionGuardColumn,
			Default -> Automatic,
			Description -> "A protective device placed in the flow path before the AnionColumn in order to adsorb fouling contaminants and, thus, preserve the AnionColumn lifetime.",
			ResolutionDescription -> "Automatically set from the column model's PreferredGuardColumn.",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Object,
				Pattern :> ObjectP[{Model[Item, Column], Object[Item, Column]}]
			],
			Category -> "General"
		},
		{
			OptionName -> CationGuardColumn,
			Default -> Automatic,
			Description -> "A protective device placed in the flow path before the CationColumn in order to adsorb fouling contaminants and, thus, preserve the CationColumn lifetime.",
			ResolutionDescription -> "Automatically set from the column model's PreferredGuardColumn.",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Object,
				Pattern :> ObjectP[{Model[Item, Column], Object[Item, Column]}]
			],
			Category -> "General"
		},
		IndexMatching[
			IndexMatchingParent -> AnionSamples,
			{
				OptionName -> AnionColumnTemperature,
				Default -> Automatic,
				Description -> "The temperature the AnionColumn is held to throughout the separation and measurement.",
				ResolutionDescription -> "Automatically set from the temperature within the AnionGradient option; otherwise, Ambient temperature is used.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Quantity,
						Pattern :> RangeP[10 Celsius, 70 Celsius],
						Units -> Celsius
					],
					Widget[
						Type -> Enumeration,
						Pattern :> Alternatives[Ambient]
					]
				],
				Category -> "General"
			}
		],
		IndexMatching[
			IndexMatchingParent -> CationSamples,
			{
				OptionName -> CationColumnTemperature,
				Default -> Automatic,
				Description -> "The temperature the CationColumn is held to throughout the separation and measurement.",
				ResolutionDescription -> "Automatically set from the temperature within the CationGradient option; otherwise, Ambient temperature is used.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Quantity,
						Pattern :> RangeP[10 Celsius, 70 Celsius],
						Units -> Celsius
					],
					Widget[
						Type -> Enumeration,
						Pattern :> Alternatives[Ambient]
					]
				],
				Category -> "General"
			}
		],
		IndexMatching[
			IndexMatchingParent -> AnionSamples,
			{
				OptionName -> AnionInjectionVolume,
				Default -> Automatic,
				Description -> "The physical quantity of AnionSamples loaded into the anion channel flow path for measurement. We recommend that injection volumes either be equal to the sample loop volume (10 uL) or less than or equal to one half of the sample loop volume (5 uL). Injection volumes between 5 and 10 uL may have lower accuracy and precision.",
				ResolutionDescription -> "Automatically set from Instrument and takes into account Instrument dead volume and AnionSamples' volume.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Microliter, 10 Microliter],
					Units -> Microliter
				],
				Category -> "General"
			}
		],
		IndexMatching[
			IndexMatchingParent -> CationSamples,
			{
				OptionName -> CationInjectionVolume,
				Default -> Automatic,
				Description -> "The physical quantity of CationSamples loaded into the cation channel flow path for measurement. We recommend that injection volumes either be equal to the sample loop volume (10 uL) or less than or equal to one half of the sample loop volume (5 uL). Injection volumes between 5 and 10 uL may have lower accuracy and precision.",
				ResolutionDescription -> "Automatically set from Instrument and takes into account Instrument dead volume and CationSamples' volume.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Microliter, 10 Microliter],
					Units -> Microliter
				],
				Category -> "General"
			}
		],


		(* ================================================ *)
		(* === Single channel ICS 6000 Specific Options === *)
		(* ================================================ *)
		{
			OptionName -> Detector,
			Default -> Automatic,
			Description -> "The type measurement to employ. For ElectrochemicalChannel, we currently offer UVVis (measures the absorbance of a single wavelength of light) and Electrochemical (measures the current generated in the oxidation and reduction of the analyte).",
			ResolutionDescription -> "Automatically set to both Electrochemical and UVVis detectors if ElectrochemicalChannel is used.",
			AllowNull -> True,
			Widget -> Alternatives[
				Widget[
					Type -> Enumeration,
					Pattern :> IonChromatographyDetectorTypeP (* Electrochemical|UVVis *)
				],
				Adder[
					Widget[
						Type -> Enumeration,
						Pattern :> IonChromatographyDetectorTypeP
					],
					Orientation -> Vertical
				]
			],
			Category -> "General"
		},
		{
			OptionName -> Column,
			Default -> Automatic,
			Description -> "A device with electrically-charged resin through which the buffer and input samples flow. It adsorbs and separates molecules within the sample based on the properties of the buffers, samples, and column temperature.",
			ResolutionDescription -> "Automatically set to a column model in stock for carbohydrate analysis unless otherwise specified.",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Object,
				Pattern :> ObjectP[{Model[Item, Column], Object[Item, Column]}]
			],
			Category -> "General"
		},
		{
			OptionName -> GuardColumn,
			Default -> Automatic,
			Description -> "A protective device placed in the flow path before the Column in order to adsorb fouling contaminants and, thus, preserve the Column lifetime.",
			ResolutionDescription -> "Automatically set from the Column model's PreferredGuardColumn.",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Object,
				Pattern :> ObjectP[{Model[Item, Column], Object[Item, Column]}]
			],
			Category -> "General"
		},
		IndexMatching[
			IndexMatchingParent -> ElectrochemicalSamples,
			{
				OptionName -> ElectrochemicalSamples,
				Default -> Automatic,
				Description -> "A list of samples to be injected into the flow path of ElectrochemicalChannel.",
				ResolutionDescription -> "Automatically compiled from samples with AnalysisChannel set to ElectrochemicalChannel.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Object,
					Pattern :> ObjectP[{Model[Sample], Object[Sample]}]
				],
				Category -> "Hidden"
			},
			{
				OptionName -> ColumnTemperature,
				Default -> Automatic,
				Description -> "The temperature the Column, which is used in the electrochemical channel flow path, is held to throughout the separation and measurement.",
				ResolutionDescription -> "Automatically set from the temperature within the Gradient option; otherwise, Ambient temperature is used.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Quantity,
						Pattern :> RangeP[10 Celsius, 70 Celsius],
						Units -> Celsius
					],
					Widget[
						Type -> Enumeration,
						Pattern :> Alternatives[Ambient]
					]
				],
				Category -> "General"
			},
			{
				OptionName -> InjectionVolume,
				Default -> Automatic,
				Description -> "The physical quantity of sample loaded into the electrochemical channel flow path for measurement. We recommend that injection volumes either be equal to the sample loop volume (25 uL) or less than or equal to one half of the sample loop volume (12.5 uL). Injection volumes between 12.5 and 25 uL may have lower accuracy and precision.",
				ResolutionDescription -> "Automatically set from Instrument and takes into account Instrument dead volume and the volume of the samples to be analyzed in the electrochemical channel.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Microliter, 25 Microliter],
					Units -> Microliter
				],
				Category -> "General"
			}
		],

		(* --- Buffer Options --- *)

		(* ====================== *)
		(* === Common options === *)
		(* ====================== *)
		{
			OptionName -> BufferA,
			Default -> Automatic,
			Description -> "The solvent pumped through channel A of the flow path. For instrument having more than one analysis channels, BufferA is only pumped into the cation channel. The anion channel features an eluent generator in the flow path capable of generating up to 100 Millimolar of Potassium Hydroxide through hydrolysis of deionized water.",
			ResolutionDescription -> "Automatically set from the objects specified by the Gradient option for the instrument with ElectrochemicalChannel or CationGradient option for the instrument with AnionChannel and CationChannel. If Gradient or CationGradient option is not specified, this option defaults to 500 mM Sodium Hydroxide for samples injected into ElectrochemicalChannel and 50 mM Methanesulfonic Acid for those injected into CationChannel.",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Object,
				Pattern :> ObjectP[{Object[Sample], Model[Sample]}]
			],
			Category -> "General"
		},
		{
			OptionName -> BufferAStorageCondition,
			Default -> Automatic,
			Description -> "The conditions under which BufferA used by this experiment should be stored after the protocol is completed. If this option is set to Null when BufferA is specified, BufferA will be stored according to the Models' DefaultStorageCondition.",
			ResolutionDescription -> "Automatically set based on the final volume of BufferA. If the final volume is more than 500 Milliliter, BufferA will be stored according to the Models' DefaultStorageCondition. Otherwise, BufferA will be disposed.",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Enumeration,
				Pattern :> SampleStorageTypeP | Disposal
			],
			Category -> "General"
		},
		{
			OptionName -> BufferB,
			Default -> Automatic,
			Description -> "The solvent pumped through channel B of the flow path. For instrument having more than one analysis channels, BufferB is only pumped into the cation channel. The anion channel features an eluent generator in the flow path capable of generating up to 100 Millimolar of Potassium Hydroxide through hydrolysis of deionized water.",
			ResolutionDescription -> "Automatically set from the objects specified by the Gradient option for the instrument with ElectrochemicalChannel or CationGradient option for the instrument with AnionChannel and CationChannel. If Gradient or CationGradient option is not specified, this option defaults to 500 mM Sodium Acetate for samples injected into ElectrochemicalChannel and Milli-Q water for those injected into CationChannel.",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Object,
				Pattern :> ObjectP[{Object[Sample], Model[Sample]}]
			],
			Category -> "General"
		},
		{
			OptionName -> BufferBStorageCondition,
			Default -> Automatic,
			Description -> "The conditions under which BufferB used by this experiment should be stored after the protocol is completed. If this option is set to Null when BufferB is specified, BufferB will be stored according to the Models' DefaultStorageCondition.",
			ResolutionDescription -> "Automatically set based on the final volume of BufferB. If the final volume is more than 500 Milliliter, BufferB will be stored according to the Models' DefaultStorageCondition. Otherwise, BufferB will be disposed.",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Enumeration,
				Pattern :> SampleStorageTypeP | Disposal
			],
			Category -> "General"
		},
		{
			OptionName -> BufferC,
			Default -> Automatic,
			Description -> "The solvent pumped through channel C of the flow path. For instrument having more than one analysis channels, BufferC is only pumped into the cation channel. The anion channel features an eluent generator in the flow path capable of generating up to 100 Millimolar of Potassium Hydroxide through hydrolysis of deionized water.",
			ResolutionDescription -> "Automatically set from the objects specified by the Gradient option for the instrument with ElectrochemicalChannel or CationGradient option for the instrument with AnionChannel and CationChannel. If Gradient or CationGradient option is not specified, this option defaults to Milli-Q water for samples injected into ElectrochemicalChannel or CationChannel.",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Object,
				Pattern :> ObjectP[{Object[Sample], Model[Sample]}]
			],
			Category -> "General"
		},
		{
			OptionName -> BufferCStorageCondition,
			Default -> Automatic,
			Description -> "The conditions under which BufferC used by this experiment should be stored after the protocol is completed. If this option is set to Null when BufferC is specified, BufferC will be stored according to the Models' DefaultStorageCondition.",
			ResolutionDescription -> "Automatically set based on the final volume of BufferC. If the final volume is more than 500 Milliliter, BufferC will be stored according to the Models' DefaultStorageCondition. Otherwise, BufferC will be disposed.",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Enumeration,
				Pattern :> SampleStorageTypeP | Disposal
			],
			Category -> "General"
		},
		{
			OptionName -> BufferD,
			Default -> Automatic,
			Description -> "The solvent pumped through channel D of the flow path. For instrument having more than one analysis channels, BufferD is only pumped into the cation channel. The anion channel features an eluent generator in the flow path capable of generating up to 100 Millimolar of Potassium Hydroxide through hydrolysis of deionized water.",
			ResolutionDescription -> "Automatically set from the objects specified by the Gradient option for single-channel instrument and CationGradient option for dual-channel instrument.",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Object,
				Pattern :> ObjectP[{Object[Sample], Model[Sample]}]
			],
			Category -> "General"
		},
		{
			OptionName -> BufferDStorageCondition,
			Default -> Automatic,
			Description -> "The conditions under which BufferD used by this experiment should be stored after the protocol is completed. If this option is set to Null when BufferC is specified, BufferD will be stored according to the Models' DefaultStorageCondition.",
			ResolutionDescription -> "Automatically set based on the final volume of BufferD. If the final volume is more than 500 Milliliter, BufferD will be stored according to the Models' DefaultStorageCondition. Otherwise, BufferD will be disposed.",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Enumeration,
				Pattern :> SampleStorageTypeP | Disposal
			],
			Category -> "General"
		},
		{
			OptionName -> NumberOfReplicates,
			Default -> Null,
			Description -> "The number of times to repeat measurements on each provided sample(s). If Aliquot->True, this also indicates the number of times each provided sample will be aliquoted.",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Number,
				Pattern :> GreaterP[0, 1]
			],
			Category -> "General"
		},


		(* --- Gradient Category --- *)

		(* ====================== *)
		(* === Common options === *)
		(* ====================== *)

		(* None *)

		(* ================================================ *)
		(* === Double channel ICS 6000 Specific Options === *)
		(* ================================================ *)

		IndexMatching[
			IndexMatchingParent -> AnionSamples,
			{
				OptionName -> EluentGradient,
				Default -> Automatic,
				Description -> "The concentration of the eluent, potassium hydroxide, that is automatically generated within the flow in anion channel, defined for specific time points. The composition is linearly interpolated for the intervening periods between the defined time points. For example for EluentGradient->{{0 Minute, 0 Millimolar},{30 Minute, 100 Millimolar}}, the eluent concentration in the flow will rise such that at 15 minutes, the concentration should be 50 Millimolar. Since eluent generator is only integrated in anion channel, this option is not applicable to cation samples. Gradient for cation samples can be set in CationGradientA, CationGradientB, CationGradientC, CationGradientD, and CationGradient options.",
				ResolutionDescription -> "Automatically set from AnionGradient option.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Quantity,
						Pattern :> RangeP[0 Millimolar, 100 Millimolar],
						Units -> Millimolar
					],
					Adder[
						{
							"Time" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Minute, 4320 Minute],
								Units -> {Minute, {Second, Minute}}
							],
							"Eluent Concentration" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Millimolar, 100 Millimolar],
								Units -> Millimolar
							]
						},
						Orientation -> Vertical
					]
				]
			},
			{
				OptionName -> AnionFlowRate,
				Default -> Automatic,
				Description -> "The speed of the fluid through the pump for anion channel. This speed is linearly interpolated such that consecutive entries of {Time, AnionFlowRate} will define the intervening fluid speed. For example, {{0 Minute, 0.3 Milliliter/Minute},{30 Minute, 0.5 Milliliter/Minute}} means flow rate of 0.4 Milliliter/Minute at 15 minutes into the run.",
				ResolutionDescription -> "Automatically set from AnionColumn or taken from the method given in the AnionGradient option. If neither option is specified, the smaller flow rate between the minumum flow rate of the resolved AnionColumn and that of the resolved Instrument will be used.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Quantity,
						Pattern :> RangeP[0 Milliliter / Minute, 10 Milliliter / Minute],
						Units -> CompoundUnit[
							{1, {Milliliter, {Milliliter, Liter}}},
							{-1, {Minute, {Minute, Second}}}
						]
					],
					Adder[
						{
							"Time" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Minute, 4320 Minute],
								Units -> {Minute, {Second, Minute}}
							],
							"Flow Rate" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Milliliter / Minute, 10 Milliliter / Minute],
								Units -> CompoundUnit[
									{1, {Milliliter, {Milliliter, Liter}}},
									{-1, {Minute, {Minute, Second}}}
								]
							]
						},
						Orientation -> Vertical
					]
				],
				Category -> "Gradient"
			}
		],
		IndexMatching[
			IndexMatchingParent -> AnionSamples,
			{
				OptionName -> AnionGradientStart,
				Default -> Null,
				Description -> "A shorthand option to specify the starting eluent concentration in the fluid flow for anion channel.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Millimolar, 100 Millimolar],
					Units -> Millimolar
				],
				Category -> "Gradient"
			},
			{
				OptionName -> AnionGradientEnd,
				Default -> Null,
				Description -> "A shorthand option to specify the final eluent concentration in the fluid flow for anion channel.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Millimolar, 100 Millimolar],
					Units -> Millimolar
				],
				Category -> "Gradient"
			},
			{
				OptionName -> AnionGradientDuration,
				Default -> Null,
				Description -> "A shorthand option to specify the total time of the gradient run for anion channel.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Minute, 4320 Minute],
					Units -> {Minute, {Minute, Second}}
				],
				Category -> "Gradient"
			},
			{
				OptionName -> AnionEquilibrationTime,
				Default -> Null,
				Description -> "A shorthand option to specify the duration of equilibration for anion channel at the starting eluent concentration at the onset of the gradient.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Minute, 4320 Minute],
					Units -> {Minute, {Minute, Second}}
				],
				Category -> "Gradient"
			},
			{
				OptionName -> AnionFlushTime,
				Default -> Null,
				Description -> "A shorthand option to specify the duration of buffer flush for anion channel at the end of the gradient.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Minute, 4320 Minute],
					Units -> {Minute, {Minute, Second}}
				],
				Category -> "Gradient"
			},
			{
				OptionName -> AnionGradient,
				Default -> Automatic,
				Description -> "The concentration of the eluent, potassium hydroxide, over time in the fluid flow for anion channel. Specific parameters of an object can be overridden by specific options for EluentGradient.",
				ResolutionDescription -> "Automatically set to match all specified options related to AnionGradient (e.g. EluentGradient, AnionFlowRate, AnionGradientStart, AnionGradientEnd, AnionGradientDuration, AnionEquilibrateTime, AnionFlushTime). If none of the options is specified, the following default gradient will be used: {{0 Minute, 10 Millimolar, DefaultAnionFlowRate},{0.1 Minute, 10 Millimolar, DefaultAnionFlowRate}, {12 Minute, 22 Millimolar, DefaultAnionFlowRate}, {20 Minute, 50 Millimolar, DefaultAnionFlowRate}, {20.5 Minute], 50 Millimolar, DefaultAnionFlowRate}, {20.6 Minute, 10 Millimolar, DefaultFlowRate}, {27 Minute, 10 Millimolar, DefaultAnionFlowRate}}.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Object,
						Pattern :> ObjectP[Object[Method, IonChromatographyGradient]]
					],
					Adder[
						{
							"Time" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Minute, 4320 Minute],
								Units -> {Minute, {Second, Minute}}
							],
							"Eluent Concentration" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Millimolar, 100 Millimolar],
								Units -> Millimolar
							],
							"Flow Rate" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Milliliter / Minute, 10 Milliliter / Minute],
								Units -> CompoundUnit[
									{1, {Milliliter, {Milliliter, Liter}}},
									{-1, {Minute, {Minute, Second}}}
								]
							]
						},
						Orientation -> Vertical
					]
				],
				Category -> "Gradient"
			}
		],
		IndexMatching[
			IndexMatchingParent -> CationSamples,
			{
				OptionName -> CationGradientA,
				Default -> Automatic,
				Description -> "The composition of Buffer A within the flow in cation channel, defined for specific time points. The composition is linearly interpolated for the intervening periods between the defined time points. For example for CationGradientA->{{0 Minute, 0 Percent},{30 Minute, 100 Percent}}, the percentage of BufferA in the flow will rise such that at 15 minutes, the composition should be 50*Percent. Since BufferA is only pumped into cation channel, this option is not applicable to anion samples. Gradient for anion samples can be set in EluentGradient and AnionGradient options.",
				ResolutionDescription -> "Automatically set from CationGradient option or implicitly determined from CationGradientB, CationGradientC, and CationGradientD options such that the composition of Buffer A, B, C and D sums up to 100 Percent throughout the gradient.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Quantity,
						Pattern :> RangeP[0 Percent, 100 Percent],
						Units -> Percent
					],
					Adder[
						{
							"Time" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Minute, 4320 Minute],
								Units -> {Minute, {Second, Minute}}
							],
							"Buffer A Composition" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Percent, 100 Percent],
								Units -> Percent
							]
						},
						Orientation -> Vertical
					]
				],
				Category -> "Gradient"
			},
			{
				OptionName -> CationGradientB,
				Default -> Automatic,
				Description -> "The composition of Buffer B within the flow in cation channel, defined for specific time points. The composition is linearly interpolated for the intervening periods between the defined time points. For example for CationGradientB->{{0 Minute, 0 Percent},{30 Minute, 100 Percent}}, the percentage of BufferB in the flow will rise such that at 15 minutes, the composition should be 50*Percent. Since BufferB is only pumped into cation channel, this option is not applicable to anion samples. Gradient for anion samples can be set in EluentGradient and AnionGradient options.",
				ResolutionDescription -> "Automatically set from CationGradient option or implicitly determined from CationGradientA, CationGradientC, and CationGradientD options such that the composition of Buffer A, B, C and D sums up to 100 Percent throughout the gradient.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Quantity,
						Pattern :> RangeP[0 Percent, 100 Percent],
						Units -> Percent
					],
					Adder[
						{
							"Time" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Minute, 4320 Minute],
								Units -> {Minute, {Second, Minute}}
							],
							"Buffer B Composition" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Percent, 100 Percent],
								Units -> Percent
							]
						},
						Orientation -> Vertical
					]
				],
				Category -> "Gradient"
			},
			{
				OptionName -> CationGradientC,
				Default -> Automatic,
				Description -> "The composition of Buffer C within the flow in cation channel, defined for specific time points. The composition is linearly interpolated for the intervening periods between the defined time points. For example for CationGradientC->{{0 Minute, 0 Percent},{30 Minute, 100 Percent}}, the percentage of BufferC in the flow will rise such that at 15 minutes, the composition should be 50*Percent. Since BufferC is only pumped into cation channel, this option is not applicable to anion samples. Gradient for anion samples can be set in EluentGradient and AnionGradient options.",
				ResolutionDescription -> "Automatically set from CationGradient option or implicitly determined from CationGradientA, CationGradientB, and CationGradientD options such that the composition of Buffer A, B, C and D sums up to 100 Percent throughout the gradient.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Quantity,
						Pattern :> RangeP[0 Percent, 100 Percent],
						Units -> Percent
					],
					Adder[
						{
							"Time" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Minute, 4320 Minute],
								Units -> {Minute, {Second, Minute}}
							],
							"Buffer C Composition" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Percent, 100 Percent],
								Units -> Percent
							]
						},
						Orientation -> Vertical
					]
				],
				Category -> "Gradient"
			},
			{
				OptionName -> CationGradientD,
				Default -> Automatic,
				Description -> "The composition of Buffer D within the flow in cation channel, defined for specific time points. The composition is linearly interpolated for the intervening periods between the defined time points. For example for CationGradientD->{{0 Minute, 0 Percent},{30 Minute, 100 Percent}}, the percentage of BufferD in the flow will rise such that at 15 minutes, the composition should be 50*Percent. Since BufferD is only pumped into cation channel, this option is not applicable to anion samples. Gradient for anion samples can be set in EluentGradient and AnionGradient options.",
				ResolutionDescription -> "Automatically set from CationGradient option or implicitly determined from CationGradientA, CationGradientB, and CationGradientC options such that the composition of Buffer A, B, C and D sums up to 100 Percent throughout the gradient.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Quantity,
						Pattern :> RangeP[0 Percent, 100 Percent],
						Units -> Percent
					],
					Adder[
						{
							"Time" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Minute, 4320 Minute],
								Units -> {Minute, {Second, Minute}}
							],
							"Buffer D Composition" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Percent, 100 Percent],
								Units -> Percent
							]
						},
						Orientation -> Vertical
					]
				],
				Category -> "Gradient"
			},
			{
				OptionName -> CationFlowRate,
				Default -> Automatic,
				Description -> "The speed of the fluid through the pump for cation channel. This speed is linearly interpolated such that consecutive entries of {Time, CationFlowRate} will define the intervening fluid speed. For example, {{0 Minute, 0.3 Milliliter/Minute},{30 Minute, 0.5 Milliliter/Minute}} means flow rate of 0.4 Milliliter/Minute at 15 minutes into the run.",
				ResolutionDescription -> "Automatically set from CationColumn or taken from the method given in the CationGradient option. If neither option is specified, the smaller flow rate between the minumum flow rate of the resolved CationColumn and that of the resolved Instrument will be used.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Quantity,
						Pattern :> RangeP[0 Milliliter / Minute, 10 Milliliter / Minute],
						Units -> CompoundUnit[
							{1, {Milliliter, {Milliliter, Liter}}},
							{-1, {Minute, {Minute, Second}}}
						]
					],
					Adder[
						{
							"Time" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Minute, 4320 Minute],
								Units -> {Minute, {Second, Minute}}
							],
							"Flow Rate" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Milliliter / Minute, 10 Milliliter / Minute],
								Units -> CompoundUnit[
									{1, {Milliliter, {Milliliter, Liter}}},
									{-1, {Minute, {Minute, Second}}}
								]
							]
						},
						Orientation -> Vertical
					]
				],
				Category -> "Gradient"
			}
		],
		IndexMatching[
			IndexMatchingParent -> CationSamples,
			{
				OptionName -> CationGradientStart,
				Default -> Null,
				Description -> "A shorthand option to specify the starting BufferB composition in the fluid flow for cation channel.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Percent, 100 Percent],
					Units -> Percent
				],
				Category -> "Gradient"
			},
			{
				OptionName -> CationGradientEnd,
				Default -> Null,
				Description -> "A shorthand option to specify the final BufferB composition in the fluid flow for cation channel.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Percent, 100 Percent],
					Units -> Percent
				],
				Category -> "Gradient"
			},
			{
				OptionName -> CationGradientDuration,
				Default -> Null,
				Description -> "A shorthand option to specify the total time of the gradient run for cation channel.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Minute, 4320 Minute],
					Units -> {Minute, {Minute, Second}}
				],
				Category -> "Gradient"
			},
			{
				OptionName -> CationEquilibrationTime,
				Default -> Null,
				Description -> "A shorthand option to specify the duration of equilibration for cation channel at the starting buffer composition at the onset of the gradient.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Minute, 4320 Minute],
					Units -> {Minute, {Minute, Second}}
				],
				Category -> "Gradient"
			},
			{
				OptionName -> CationFlushTime,
				Default -> Null,
				Description -> "A shorthand option to specify the duration of buffer flush for cation channel at the end of the gradient.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Minute, 4320 Minute],
					Units -> {Minute, {Minute, Second}}
				],
				Category -> "Gradient"
			},
			{
				OptionName -> CationGradient,
				Default -> Automatic,
				Description -> "The buffer composition over time in the fluid flow for cation channel. Specific parameters of an object can be overridden by specific options for CationGradientA, CationGradientB, CationGradientC, and CationGradientD.",
				ResolutionDescription -> "Automatically set to match all specified options releated to CationGradient (e.g. CationGradientA, CationGradientB, CationGradientC, CationGradientD, CationFlowRate, CationGradientStart, CationGradientEnd, CationGradientDuration, CationEquilibrateTime, and CationFlushTime). If none of the options is specified, the following default gradient will be used: {{0 Minute, 60 Percent, 40 Percent, 0 Percent, 0 Percent, DefaultCationFlowRate}, {23 Minute, 60 Percent, 40 Percent, 0 Percent, 0 Percent, DefaultCationFlowRate}}.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Object,
						Pattern :> ObjectP[Object[Method, IonChromatographyGradient]]
					],
					Adder[
						{
							"Time" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Minute, 4320 Minute],
								Units -> {Minute, {Second, Minute}}
							],
							"Buffer A Composition" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Percent, 100 Percent],
								Units -> Percent
							],
							"Buffer B Composition" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Percent, 100 Percent],
								Units -> Percent
							],
							"Buffer C Composition" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Percent, 100 Percent],
								Units -> Percent
							],
							"Buffer D Composition" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Percent, 100 Percent],
								Units -> Percent
							],
							"Flow Rate" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Milliliter / Minute, 10 Milliliter / Minute],
								Units -> CompoundUnit[
									{1, {Milliliter, {Milliliter, Liter}}},
									{-1, {Minute, {Minute, Second}}}
								]
							]
						},
						Orientation -> Vertical
					]
				],
				Category -> "Gradient"
			}
		],

		(* ================================================ *)
		(* === Single channel ICS 6000 Specific Options === *)
		(* ================================================ *)

		IndexMatching[
			IndexMatchingInput -> "experiment samples",
			{
				OptionName -> GradientA,
				Default -> Automatic,
				Description -> "The composition of Buffer A within the flow the instrument, defined for specific time points. The composition is linearly interpolated for the intervening periods between the defined time points. For example for GradientA->{{0 Minute, 0 Percent},{30 Minute, 100 Percent}}, the percentage of BufferA in the flow will rise such that at 15 minutes, the composition should be 50*Percent.",
				ResolutionDescription -> "Automatically set from Gradient option or implicitly determined from GradientB, GradientC, and GradientD options such that the composition of Buffer A, B, C and D sums up to 100 Percent throughout the gradient.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Quantity,
						Pattern :> RangeP[0 Percent, 100 Percent],
						Units -> Percent
					],
					Adder[
						{
							"Time" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Minute, 4320 Minute],
								Units -> {Minute, {Second, Minute}}
							],
							"Buffer A Composition" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Percent, 100 Percent],
								Units -> Percent
							]
						},
						Orientation -> Vertical
					]
				],
				Category -> "Gradient"
			},
			{
				OptionName -> GradientB,
				Default -> Automatic,
				Description -> "The composition of Buffer B within the flow the instrument, defined for specific time points. The composition is linearly interpolated for the intervening periods between the defined time points. For example for GradientB->{{0 Minute, 0 Percent},{30 Minute, 100 Percent}}, the percentage of BufferB in the flow will rise such that at 15 minutes, the composition should be 50*Percent.",
				ResolutionDescription -> "Automatically set from Gradient option or implicitly determined from GradientA, GradientC, and GradientD options such that the composition of Buffer A, B, C and D sums up to 100 Percent throughout the gradient.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Quantity,
						Pattern :> RangeP[0 Percent, 100 Percent],
						Units -> Percent
					],
					Adder[
						{
							"Time" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Minute, 4320 Minute],
								Units -> {Minute, {Second, Minute}}
							],
							"Buffer B Composition" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Percent, 100 Percent],
								Units -> Percent
							]
						},
						Orientation -> Vertical
					]
				],
				Category -> "Gradient"
			},
			{
				OptionName -> GradientC,
				Default -> Automatic,
				Description -> "The composition of Buffer C within the flow of the instrument, defined for specific time points. The composition is linearly interpolated for the intervening periods between the defined time points. For example for GradientC->{{0 Minute, 0 Percent},{30 Minute, 100 Percent}}, the percentage of BufferC in the flow will rise such that at 15 minutes, the composition should be 50*Percent.",
				ResolutionDescription -> "Automatically set from Gradient option or implicitly determined from GradientA, GradientB, and GradientD options such that the composition of Buffer A, B, C and D sums up to 100 Percent throughout the gradient.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Quantity,
						Pattern :> RangeP[0 Percent, 100 Percent],
						Units -> Percent
					],
					Adder[
						{
							"Time" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Minute, 4320 Minute],
								Units -> {Minute, {Second, Minute}}
							],
							"Buffer C Composition" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Percent, 100 Percent],
								Units -> Percent
							]
						},
						Orientation -> Vertical
					]
				],
				Category -> "Gradient"
			},
			{
				OptionName -> GradientD,
				Default -> Automatic,
				Description -> "The composition of Buffer D within the flow of the instrument, defined for specific time points. The composition is linearly interpolated for the intervening periods between the defined time points. For example for GradientD->{{0 Minute, 0 Percent},{30 Minute, 100 Percent}}, the percentage of BufferD in the flow will rise such that at 15 minutes, the composition should be 50*Percent.",
				ResolutionDescription -> "Automatically set from Gradient option or implicitly determined from GradientA, GradientB, and GradientC options such that the composition of Buffer A, B, C and D sums up to 100 Percent throughout the gradient.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Quantity,
						Pattern :> RangeP[0 Percent, 100 Percent],
						Units -> Percent
					],
					Adder[
						{
							"Time" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Minute, 4320 Minute],
								Units -> {Minute, {Second, Minute}}
							],
							"Buffer D Composition" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Percent, 100 Percent],
								Units -> Percent
							]
						},
						Orientation -> Vertical
					]
				],
				Category -> "Gradient"
			},
			{
				OptionName -> FlowRate,
				Default -> Automatic,
				Description -> "The speed of the fluid through the pump. This speed is linearly interpolated such that consecutive entries of {Time, Flow Rate} will define the intervening fluid speed. For example, {{0 Minute, 0.3 Milliliter/Minute},{30 Minute, 0.5 Milliliter/Minute}} means flow rate of 0.4 Milliliter/Minute at 15 minutes into the run.",
				ResolutionDescription -> "Automatically set from the method given in the Gradient option. If neither option is specified, the smaller flow rate between the minumum flow rate of the resolved Column and that of the resolved Instrument will be used.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Quantity,
						Pattern :> RangeP[0 Milliliter / Minute, 10 Milliliter / Minute],
						Units -> CompoundUnit[
							{1, {Milliliter, {Milliliter, Liter}}},
							{-1, {Minute, {Minute, Second}}}
						]
					],
					Adder[
						{
							"Time" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Minute, 4320 Minute],
								Units -> {Minute, {Second, Minute}}
							],
							"Flow Rate" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Milliliter / Minute, 10 Milliliter / Minute],
								Units -> CompoundUnit[
									{1, {Milliliter, {Milliliter, Liter}}},
									{-1, {Minute, {Minute, Second}}}
								]
							]
						},
						Orientation -> Vertical
					]
				],
				Category -> "Gradient"
			},
			{
				OptionName -> GradientStart,
				Default -> Null,
				Description -> "A shorthand option to specify the starting BufferB concentration in the fluid flow of the instrument.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Percent, 100 Percent],
					Units -> Percent
				],
				Category -> "Gradient"
			},
			{
				OptionName -> GradientEnd,
				Default -> Null,
				Description -> "A shorthand option to specify the final BufferB concentration in the fluid flow of the instrument.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Percent, 100 Percent],
					Units -> Percent
				],
				Category -> "Gradient"
			},
			{
				OptionName -> GradientDuration,
				Default -> Null,
				Description -> "A shorthand option to specify the total time of the gradient run.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Minute, 4320 Minute],
					Units -> {Minute, {Minute, Second}}
				],
				Category -> "Gradient"
			},
			{
				OptionName -> EquilibrationTime,
				Default -> Null,
				Description -> "A shorthand option to specify the duration of equilibration at the starting buffer concentration at the onset of the gradient.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Minute, 4320 Minute],
					Units -> {Minute, {Minute, Second}}
				],
				Category -> "Gradient"
			},
			{
				OptionName -> FlushTime,
				Default -> Null,
				Description -> "A shorthand option to specify the duration of buffer flush at the end of the gradient.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Minute, 4320 Minute],
					Units -> {Minute, {Minute, Second}}
				],
				Category -> "Gradient"
			},
			{
				OptionName -> Gradient,
				Default -> Automatic,
				Description -> "The concentration of buffer over time in the fluid flow of the instrument. Specific parameters of an object can be overridden by specific options for GradientA, GradientB, GradientC, and GradientD.",
				ResolutionDescription -> "Automatically set to match all specified options related to Gradient (e.g. GradientA, GradientB, GradientC, GradientD, FlowRate, GradientStart, GradientEnd, GradientDuration, EquilibrateTime, FlushTime).", (* TODO: add default gradient *)
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Object,
						Pattern :> ObjectP[Object[Method, Gradient]]
					],
					Adder[
						{
							"Time" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Minute, 4320 Minute],
								Units -> {Minute, {Second, Minute}}
							],
							"Buffer A Composition" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Percent, 100 Percent],
								Units -> Percent
							],
							"Buffer B Composition" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Percent, 100 Percent],
								Units -> Percent
							],
							"Buffer C Composition" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Percent, 100 Percent],
								Units -> Percent
							],
							"Buffer D Composition" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Percent, 100 Percent],
								Units -> Percent
							],
							"Flow Rate" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Milliliter / Minute, 10 Milliliter / Minute],
								Units -> CompoundUnit[
									{1, {Milliliter, {Milliliter, Liter}}},
									{-1, {Minute, {Minute, Second}}}
								]
							]
						},
						Orientation -> Vertical
					]
				],
				Category -> "Gradient"
			}
		],


		(* --- Detector Parameters Category --- *)

		(* ====================== *)
		(* === Common options === *)
		(* ====================== *)

		(* None *)

		(* ================================================ *)
		(* === Double channel ICS 6000 Specific Options === *)
		(* ================================================ *)

		IndexMatching[
			IndexMatchingParent -> AnionSamples,
			{
				(*Because we recently changed the suppressor, and it only work with constant current mode. So we can no longer give the user the choice of Dynamic/Legacy mode. But according to tech support, it is possible when we swap to another set of suppressor in future, we can choose the mode and voltage again.*)
				OptionName -> AnionSuppressorMode,
				Default -> Automatic,
				Description -> "The operation method of the anion suppressor. Under DynamicMode, constant voltage is supplied to the suppressor with variable current while under LegacyMode, constant current is supplied.",
				ResolutionDescription -> "This option will be set to DynamicMode if SuppressorVoltage is specified or LegacyMode if SuppressorCurrent is specified. If none of the suppressor related options are set, this option will automatically be set to LegacyMode.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Enumeration,
					Pattern :> SuppressorModeP
				],
				Category -> "Hidden"
			},
			{
				OptionName -> AnionSuppressorVoltage,
				Default -> Null,
				Description -> "The electrical potential difference applied to the AnionSuppressor. This option is set to the factory recommended voltage of the suppressor unless otherwise specified.",
				ResolutionDescription -> "This option will be set to Null if AnionSuppressorMode is LegacyMode. Otherwise, this option will be set to the factory recommended voltage of the suppressor.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 * Volt, 10 * Volt],
					Units -> Volt
				],
				Category -> "Hidden"
			},
			{
				OptionName -> AnionSuppressorCurrent,
				Default -> Automatic,
				Description -> "The electrical current supplied to the AnionSuppressor module where high-conducting buffer is replaced by low-conducting water through electrolysis and chemical reactions.",
				ResolutionDescription -> "This option will be calculated by multiplying flow rate, maximum eluent concentration and suppressor specific factor (2.47 for anion suppressor).",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Milliampere, 100 Milliampere],
					Units -> Milliampere
				],
				Category -> "Detection"
			},
			{
				OptionName -> AnionDetectionTemperature,
				Default -> Automatic,
				Description -> "The temperature of the oven where conductivity of the AnionSamples is measured.",
				ResolutionDescription -> "This option will automatically be set to Ambient if AnionChannel is in use and Null if not.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Quantity,
						Pattern :> RangeP[15 Celsius, 35 Celsius],
						Units -> Celsius
					],
					Widget[
						Type -> Enumeration,
						Pattern :> Alternatives[Ambient]
					]
				],
				Category -> "Detection"
			}
		],
		IndexMatching[
			IndexMatchingParent -> CationSamples,
			{
				OptionName -> CationSuppressorMode,
				Default -> Automatic,
				Description -> "The operation method of the CationSuppressor. Under DynamicMode, constant voltage is supplied to the suppressor with variable current while under LegacyMode, constant current is supplied.",
				ResolutionDescription -> "This option will be set to DynamicMode if SuppressorVoltage is specified or LegacyMode if SuppressorCurrent is specified. If none of the suppressor related options are set, this option will automatically be set to DynamicMode.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Enumeration,
					Pattern :> SuppressorModeP
				],
				Category -> "Hidden"
			},
			{
				OptionName -> CationSuppressorVoltage,
				Default -> Null,
				Description -> "The electrical potential difference applied to the CationSuppressor. This option is set to the factory recommended voltage of the suppressor unless otherwise specified.",
				ResolutionDescription -> "This option will be set to Null if CationSuppressorMode is LegacyMode. Otherwise, this option will be set to the factory recommended voltage of the suppressor.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 * Volt, 10 * Volt],
					Units -> Volt
				],
				Category -> "Hidden"
			},
			{
				OptionName -> CationSuppressorCurrent,
				Default -> Automatic,
				Description -> "The electrical current supplied to the CationSuppressor module where high-conducting Buffer is replaced by low-conducting water through electrolysis and chemical reactions.",
				ResolutionDescription -> "This option will be calculated by multiplying flow rate, maximum buffer concentration and suppressor specific factor (2.94 for cation suppressor).",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Milliampere, 100 Milliampere],
					Units -> Milliampere
				],
				Category -> "Detection"
			},
			{
				OptionName -> CationDetectionTemperature,
				Default -> Automatic,
				Description -> "The temperature of the oven where conductivity of the CationSamples is measured.",
				ResolutionDescription -> "This option will automatically be set to Ambient if CationChannel is in use and Null if not.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Quantity,
						Pattern :> RangeP[15 Celsius, 35 Celsius],
						Units -> Celsius
					],
					Widget[
						Type -> Enumeration,
						Pattern :> Alternatives[Ambient]
					]
				],
				Category -> "Detection"
			}
		],

		(* ================================================ *)
		(* === Single channel ICS 6000 Specific Options === *)
		(* ================================================ *)

		IndexMatching[
			IndexMatchingInput -> "experiment samples",

			(* - UV detection options - *)
			{
				OptionName -> AbsorbanceWavelength,
				Default -> Automatic,
				Description -> "The physical properties of light passed through the flow for the UVVis Detector. Up to 4 separate wavelengths may be specified.",
				ResolutionDescription -> "Automatically set to 280 Nanometer if the UVVis detector is used in the protocol.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Quantity,
						Pattern :> RangeP[190 Nanometer, 900 Nanometer],
						Units -> Nanometer
					],
					Adder[
						Widget[
							Type -> Quantity,
							Pattern :> RangeP[190 Nanometer, 900 Nanometer],
							Units -> Nanometer
						]
					]
				],
				Category -> "Detection"
			},
			{
				OptionName -> AbsorbanceSamplingRate,
				Default -> Automatic,
				Description -> "Indicates the frequency of absorbance measurement. Lower values will be less susceptible to noise but will record less frequently across time.",
				ResolutionDescription -> "Automatically set based on the number of wavelengths specified. Default AbsorbanceSamplingRate is 10/Second for measurement at a single wavelength and 1/Second for measurements at multiple wavelengths.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Quantity,
					Pattern :> RangeP[0.2 / Second, 100 / Second],
					Units -> 1 / Second
				],
				Category -> "Detection"
			},

			(* - Electrochemical detection options - *)
			{
				OptionName -> ElectrochemicalDetectionMode,
				Default -> Automatic,
				Description -> "Specifies the mode of operation for the electrochemical detector, including DC Amperometric Detection, Pulsed Amperometric Detection, and Integrated Pulsed Amperometric Detection. In DC Amperometric Detection, a constant voltage is applied. In contrast, Pulsed Amperometric Detections first apply a working potential followed by higher or lower potentials that are used for cleaning the electrode. Further, Integrated Amperometric Detection integrates current over a single potential whereas Integrated Pulsed Amperometric Detection integrates current over two or more potentials.",
				ResolutionDescription -> "Automatically set based on the VoltageProfile or the WaveformProfile specified. If neither option is specified, this option defaults to Pulsed Amperometry.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Enumeration,
					Pattern :> ElectrochemicalDetectionModeP (* DCAmperometricDetection|PulsedAmperometricDetection|IntegratedPulsedAmperometricDetection *)
				],
				Category -> "Detection"
			}
		],
		{
			OptionName -> pHCalibration,
			Default -> Automatic,
			Description -> "Indicates whether the reference electrode (combination pH-Ag/AgCl electrode) needs to be calibrated against standard pH solutions before samples are injected.",
			ResolutionDescription -> "Automatically set to False if electrochemical detector is used. Otherwise resolves to Null.",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Enumeration,
				Pattern :> BooleanP
			],
			Category -> "Detection"
		},
		{
			OptionName -> NeutralpHCalibrationBuffer,
			Default -> Automatic,
			Description -> "The solution with a neutral pH (pH=7) used during the pH electrode calibration.",
			ResolutionDescription -> "Automatically set to the reference solution with a pH of 7 if pHCalibration is True.",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Object,
				Pattern :> ObjectP[{Model[Sample], Object[Sample]}]
			],
			Category -> "Detection"
		},
		{
			OptionName -> SecondarypHCalibrationBuffer,
			Default -> Automatic,
			Description -> "The additional solution, either acidic or basic, used to create the second point on the pH calibration curve.",
			ResolutionDescription -> "Automatically set to the reference solution with a pH value of 10 if pHCalibration is True.",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Object,
				Pattern :> ObjectP[{Model[Sample], Object[Sample]}]
			],
			Category -> "Detection"
		},
		{
			OptionName -> SecondarypHCalibrationBufferTarget,
			Default -> Automatic,
			Description -> "The expected pH value of the additional solution used in the pH electrode calibration.",
			ResolutionDescription -> "Automatically set to pH of the specified SecondarypHCalibrationBuffer if pHCalibration is True.",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Number,
				Pattern :> RangeP[0, 14]
			],
			Category -> "Detection"
		},
		{
			OptionName -> WorkingElectrode,
			Default -> Automatic,
			Description -> "The electrode where the analytes undergo reduction or oxidation recations due to the potential difference applied.",
			ResolutionDescription -> "Automatically set to Model[Item, Electrode, \"Disposable Gold on PTFE Electrode\"] if electrochemical detection is employed.",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Object,
				Pattern :> ObjectP[{Object[Item, Electrode], Model[Item, Electrode]}] (* TODO: add catalog path *)
			],
			Category -> "Detection"
		},
		{
			OptionName -> WorkingElectrodeStorageCondition,
			Default -> Automatic,
			Description -> "The conditions under which the WorkingElectrode used by this experiment should be stored after the protocol is completed. If this option is set to Null when WorkingElectrode is specified, WorkingElectrode will be stored according to the Models' DefaultStorageCondition.",
			ResolutionDescription -> "Automatically set to Models' DefaultStorageCondition if WorkingElectrode is specified.",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Enumeration,
				Pattern :> SampleStorageTypeP | Disposal
			],
			Category -> "Detection"
		},
		IndexMatching[
			IndexMatchingInput -> "experiment samples",
			{
				OptionName -> ReferenceElectrodeMode,
				Default -> Automatic,
				Description -> "The operating mode (either pH or AgCl) of the pH-Ag/AgCl reference electrode. The pH-Ag/AgCl reference electrode offers two distinct modes of operation: it can function as a \"pH\" reference for monitoring buffer pH or serve as an \"AgCl\" reference with a constant potential in electrochemical cells.",
				ResolutionDescription -> "Automatically set from Waveform method object. If Waveform is not specified, this option defaults to AgCl.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Enumeration,
					Pattern :> ReferenceElectrodeModeP (* AgCl|pH *)
				],
				Category -> "Detection"
			},
			{
				OptionName -> VoltageProfile,
				Default -> Automatic,
				Description -> "The time-dependent voltage setting throughout the measurement when for an ElectrochemicalDetector.",
				ResolutionDescription -> "Automatically set to 0.1 Volt for DCAmperometry. If any other ElectrochemicalDetectionMode is used, this option will set to Null.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Quantity,
						Pattern :> RangeP[-2.048 Volt, 2.047 Volt],
						Units -> Volt
					],
					Adder[
						{
							"Time" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Minute, 4320 Minute],
								Units -> {Minute, {Second, Minute}}
							],
							"Voltage" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[-2.048 Volt, 2.047 Volt],
								Units -> {Volt, {Volt, Milli * Volt}}
							]
						},
						Orientation -> Vertical
					]
				],
				Category -> "Detection"
			},
			{
				OptionName -> WaveformProfile,
				Default -> Automatic,
				Description -> "A series of time-dependent voltage setting (waveform) that will be repeated over the duration of the analysis.",
				ResolutionDescription -> "Automatically set to repeat a single waveform defined for either Pulsed Amperometric Detection or Integrated Pulsed Amperometric Detection over the entire run.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Object,
						Pattern :> ObjectP[Object[Method, Waveform]]
					],
					Adder[
						{

							"Waveform Time" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Second, 2 Second],
								Units -> Second
							],
							"Voltage" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[-2.048 Volt, 2.047 Volt],
								Units -> Volt
							],
							"Interpolation" -> Widget[
								Type -> Enumeration,
								Pattern :> BooleanP
							],
							"Integration" -> Widget[
								Type -> Enumeration,
								Pattern :> BooleanP
							]
						},
						Orientation -> Vertical
					],
					Adder[
						{
							"Time" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Minute, 4320 Minute],
								Units -> {Minute, {Second, Minute}}
							],
							"Waveform" -> Widget[
								Type -> Object,
								Pattern :> ObjectP[Object[Method, Waveform]]
							]
						},
						Orientation -> Vertical
					],
					Adder[
						{
							"Time" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Minute, 4320 Minute],
								Units -> {Minute, {Second, Minute}}
							],
							"Waveform" -> Adder[
								{
									"Waveform Time" -> Widget[
										Type -> Quantity,
										Pattern :> RangeP[0 Second, 2 Second],
										Units -> Second
									],
									"Voltage" -> Widget[
										Type -> Quantity,
										Pattern :> RangeP[-2.048 Volt, 2.047 Volt],
										Units -> Volt
									],
									"Interpolation" -> Widget[
										Type -> Enumeration,
										Pattern :> BooleanP
									],
									"Integration" -> Widget[
										Type -> Enumeration,
										Pattern :> BooleanP
									]
								},
								Orientation -> Vertical
							]
						},
						Orientation -> Vertical
					]
				],
				Category -> "Detection"
			},
			{
				OptionName -> ElectrochemicalSamplingRate,
				Default -> Automatic,
				Description -> "Indicates the frequency of amperometric measurement. Lower values will be less susceptible to noise but will record less frequently across time.",
				ResolutionDescription -> "Automatically set to 1/waveform duration if a single waveform is specified. If multiple waveforms are specified, this option is set to 1 over the longest waveform duration. If no waveform is specified, this option is set to 2/Second.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Quantity,
					Pattern :> RangeP[0.2 / Second, 100 / Second],
					Units -> 1 / Second
				],
				Category -> "Detection"
			},
			{
				OptionName -> DetectionTemperature,
				Default -> Automatic,
				Description -> "The temperature of the detection oven where the eletrochemical detection takes place.",
				ResolutionDescription -> "This option will automatically be set to Ambient if electrochemical detector is used.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Quantity,
						Pattern :> RangeP[15 Celsius, 35 Celsius],
						Units -> Celsius
					],
					Widget[
						Type -> Enumeration,
						Pattern :> Alternatives[Ambient]
					]
				],
				Category -> "Detection"
			}
		],


		(* --- Standard Category --- *)

		(* ====================== *)
		(* === Common options === *)
		(* ====================== *)

		IndexMatching[
			IndexMatchingParent -> Standard,
			{
				OptionName -> Standard,
				Default -> Automatic,
				Description -> "A reference compound to inject to the instrument, often used for quantification or to check internal measurement consistency.",
				ResolutionDescription -> "Automatically copied over from InjectionTable, otherwise set to Null.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Object,
					Pattern :> ObjectP[{Model[Sample], Object[Sample]}]
				],
				Category -> "Standard"
			},
			{
				OptionName -> StandardStorageCondition,
				Default -> Automatic,
				Description -> "The conditions under which any Standard used by this experiment should be stored after the protocol is completed. If this option is left as Automatic when Standard samples are specified, the Standard samples will be stored according to their Models' DefaultStorageCondition.",
				ResolutionDescription -> "Automatically set based on the final volume of Standard samples. If the final volume is more than 500 Microliter, Standard samples will be stored according to the Models' DefaultStorageCondition. Otherwise, Standard samples will be disposed.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Enumeration,
						Pattern :> SampleStorageTypeP | Disposal
					]
				],
				Category -> "Standard"
			}
		],

		(* ================================================ *)
		(* === Double channel ICS 6000 Specific Options === *)
		(* ================================================ *)

		IndexMatching[
			IndexMatchingParent -> Standard,
			{
				OptionName -> StandardAnalysisChannel,
				Default -> Automatic,
				Description -> "The flow path into which the Standard is injected. CationChannel and AnionChannel employ suppressed conductivity detection for common cations and anions respectively whereas ElectrochemicalChannel employs electrochemical and/or UV detection for polysaccharides and beyond.",
				ResolutionDescription -> "Automatically set from the Composition and/or Analytes of the Standard. If the sample contains any oligomer, this option will automatically set to ElectrochemicalChannel. If the sample consists of two or more analytes in the common cation list (Lithium, Sodium, Ammonium, Potassium, Magnesium, and Calcium), this option will automatically set to CationChannel. If the sample consists of two or more analytes in the common anion list (Fluoride, Chloride, Bromide, Nitrate, Sulfate, and Phosphate), this option will automatically set to AnionChannel. If a sample meets both cation and anion criteria or if neither Composition nor Analytes is specified for the sample, this option defaults to AnionChannel.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Enumeration,
					Pattern :> AnalysisChannelP
				],
				Category -> "Standard"
			}
		],
		IndexMatching[
			IndexMatchingParent -> AnionStandard,
			{
				OptionName -> AnionStandard,
				Default -> Automatic,
				Description -> "A list of reference compounds to be injected into the anion channel of the instrument.",
				ResolutionDescription -> "Automatically compiled from Standard with StandardAnalysisChannel set to AnionChannel.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Object,
					Pattern :> ObjectP[{Model[Sample], Object[Sample]}] (* TODO: add catalog folder *)
				],
				Category -> "Standard"
			}
		],
		{
			OptionName -> AnionStandardFrequency,
			Default -> Automatic,
			Description -> "Specify the frequency at which AnionStandard measurements will be inserted among samples.",
			ResolutionDescription -> "Automatically set to FirstAndLast when any AnionStandard option is specified.",
			AllowNull -> True,
			Widget -> Alternatives[
				Widget[
					Type -> Enumeration,
					Pattern :> None | First | Last | FirstAndLast | GradientChange
				],
				Widget[
					Type -> Number,
					Pattern :> GreaterP[0, 1]
				]
			],
			Category -> "Standard"
		},
		IndexMatching[
			IndexMatchingParent -> CationStandard,
			{
				OptionName -> CationStandard,
				Default -> Automatic,
				Description -> "A list of reference compounds to be injected into the cation channel of the instrument.",
				ResolutionDescription -> "Automatically compiled from Standard with StandardAnalysisChannel set to CationChannel.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Object,
					Pattern :> ObjectP[{Model[Sample], Object[Sample]}] (* TODO: add catalog folder *)
				],
				Category -> "Standard"
			}
		],
		{
			OptionName -> CationStandardFrequency,
			Default -> Automatic,
			Description -> "Specify the frequency at which CationStandard measurements will be inserted among samples.",
			ResolutionDescription -> "Automatically set to FirstAndLast when any CationStandard option is specified.",
			AllowNull -> True,
			Widget -> Alternatives[
				Widget[
					Type -> Enumeration,
					Pattern :> None | First | Last | FirstAndLast | GradientChange
				],
				Widget[
					Type -> Number,
					Pattern :> GreaterP[0, 1]
				]
			],
			Category -> "Standard"
		},
		IndexMatching[
			IndexMatchingParent -> AnionStandard,
			{
				OptionName -> AnionStandardInjectionVolume,
				Default -> Automatic,
				Description -> "The physical quantity of each AnionStandard to inject into the system. We recommend that injection volumes either be equal to the sample loop volume (10 uL) or less than or equal to one half of the sample loop volume (5 uL). Injection volumes between 5 and 10 uL may have lower accuracy and precision.",
				ResolutionDescription -> "Automatically set to the first value of AnionInjectionVolume.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Microliter, 10 Microliter],
					Units -> Microliter
				],
				Category -> "Standard"
			},
			{
				OptionName -> AnionStandardColumnTemperature,
				Default -> Automatic,
				Description -> "The temperature the AnionColumn is held to throughout the AnionStandard run and measurement.",
				ResolutionDescription -> "Automatically set from AnionColumnTemperature or taken from the AnionStandardGradient option.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Quantity,
						Pattern :> RangeP[10 Celsius, 70 Celsius],
						Units -> Celsius
					],
					Widget[
						Type -> Enumeration,
						Pattern :> Alternatives[Ambient]
					]
				],
				Category -> "Standard"
			}
		],
		IndexMatching[
			IndexMatchingParent -> CationStandard,
			{
				OptionName -> CationStandardInjectionVolume,
				Default -> Automatic,
				Description -> "The physical quantity of each CationStandard to inject into the system. We recommend that injection volumes either be equal to the sample loop volume (10 uL) or less than or equal to one half of the sample loop volume (5 uL). Injection volumes between 5 and 10 uL may have lower accuracy and precision.",
				ResolutionDescription -> "Automatically set to the first value of CationInjectionVolume.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Microliter, 10 Microliter],
					Units -> Microliter
				],
				Category -> "Standard"
			},
			{
				OptionName -> CationStandardColumnTemperature,
				Default -> Automatic,
				Description -> "The temperature the CationColumn is held to throughout the CationStandard run and measurement.",
				ResolutionDescription -> "Automatically set from CationColumnTemperature or taken from the CationStandardGradient option.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Quantity,
						Pattern :> RangeP[10 Celsius, 70 Celsius],
						Units -> Celsius
					],
					Widget[
						Type -> Enumeration,
						Pattern :> Alternatives[Ambient]
					]
				],
				Category -> "Standard"
			}
		],
		IndexMatching[
			IndexMatchingParent -> AnionStandard,
			{
				OptionName -> StandardEluentGradient,
				Default -> Automatic,
				Description -> "The concentration of the eluent, potassium hydroxide, that is automatically generated within the flow path for AnionStandard samples, defined for specific time points. The composition is linearly interpolated for the intervening periods between the defined time points. For example for StandardEluentGradient->{{0 Minute, 0 Millimolar},{30 Minute, 100 Millimolar}}, the eluent concentration in the flow will rise such that at 15 minutes, the eluent concentration should be 50 Millimolar. Since eluent generator is only integrated in anion channel, this option is not applicable to cation standards. Gradient for cation standards can be set in CationStandardGradientA, CationStandardGradientB, CationStandardGradientC, CationStandardGradientD, and CationStandardGradient options.",
				ResolutionDescription -> "Automatically set from AnionStandardGradient option.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Quantity,
						Pattern :> RangeP[0 Millimolar, 100 Millimolar],
						Units -> Millimolar
					],
					Adder[
						{
							"Time" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Minute, 4320 Minute],
								Units -> {Minute, {Second, Minute}}
							],
							"Eluent Concentration" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Millimolar, 100 Millimolar],
								Units -> Millimolar
							]
						},
						Orientation -> Vertical
					]
				]
			},
			{
				OptionName -> AnionStandardFlowRate,
				Default -> Automatic,
				Description -> "The speed of the fluid through the system for AnionStandard samples.",
				ResolutionDescription -> "Automatically set from AnionColumn, and FlowRate specified in the AnionInjectionTable or taken from the method given in the AnionStandardGradient option.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Quantity,
						Pattern :> RangeP[0 Milliliter / Minute, 10 Milliliter / Minute],
						Units -> CompoundUnit[
							{1, {Milliliter, {Milliliter, Liter}}},
							{-1, {Minute, {Minute, Second}}}
						]
					],
					Adder[
						{
							"Time" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Minute, 4320 Minute],
								Units -> {Minute, {Second, Minute}}
							],
							"Flow Rate" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Milliliter / Minute, 10 Milliliter / Minute],
								Units -> CompoundUnit[
									{1, {Milliliter, {Milliliter, Liter}}},
									{-1, {Minute, {Minute, Second}}}
								]
							]
						},
						Orientation -> Vertical
					]
				],
				Category -> "Standard"
			},
			{
				OptionName -> AnionStandardGradientStart,
				Default -> Null,
				Description -> "A shorthand option to specify the starting eluent concentration in the fluid flow of the instrument for AnionStandard samples.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Millimolar, 100 Millimolar],
					Units -> Millimolar
				],
				Category -> "Standard"
			},
			{
				OptionName -> AnionStandardGradientEnd,
				Default -> Null,
				Description -> "A shorthand option to specify the final eluent concentration in the fluid flow of the instrument for AnionStandard samples.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Millimolar, 100 Millimolar],
					Units -> Millimolar
				],
				Category -> "Standard"
			},
			{
				OptionName -> AnionStandardGradientDuration,
				Default -> Null,
				Description -> "A shorthand option to specify the total time it takes to run the AnionStandard gradient.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Minute, 4320 Minute],
					Units -> {Minute, {Minute, Second}}
				],
				Category -> "Standard"
			},
			{
				OptionName -> AnionStandardGradient,
				Default -> Automatic,
				Description -> "The concentration of the eluent, potassium hydroxide, over time in the fluid flow for AnionStandard samples. Specific parameters of an object can be overridden by specific options for StandardEluentGradient. Since eluent generator is only integrated in anion channel, this option is not applicable to cation standards. Gradient for cation standards can be set in CationStandardGradientA, CationStandardGradientB, CationStandardGradientC, CationStandardGradientD, and CationStandardGradient options.",
				ResolutionDescription -> "Automatically set to match all specified options related to AnionStandardGradient (e.g. StandardEluentGradient, AnionStandardFlowRate, AnionStandardGradientDuration). If none of the options is specified, the first value of AnionGradient will be used.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Object,
						Pattern :> ObjectP[Object[Method, IonChromatographyGradient]]
					],
					Adder[
						{
							"Time" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Minute, 4320 Minute],
								Units -> {Minute, {Second, Minute}}
							],
							"Eluent Concentration" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Millimolar, 100 Millimolar],
								Units -> Millimolar
							],
							"Flow Rate" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Milliliter / Minute, 10 Milliliter / Minute],
								Units -> CompoundUnit[
									{1, {Milliliter, {Milliliter, Liter}}},
									{-1, {Minute, {Minute, Second}}}
								]
							]
						},
						Orientation -> Vertical
					]
				],
				Category -> "Standard"
			},
			{
				OptionName -> AnionStandardSuppressorMode,
				Default -> Automatic,
				Description -> "The operation method of the AnionSuppressor for standard samples. Under DynamicMode, constant voltage is supplied to the suppressor with variable current while under LegacyMode, constant current is supplied.",
				ResolutionDescription -> "This option will be set to DynamicMode if SuppressorVoltage is specified or LegacyMode if SuppressorCurrent is specified. If none of the suppressor related options are set, this option will automatically be set to LegacyMode.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Enumeration,
					Pattern :> SuppressorModeP
				],
				Category -> "Hidden"
			},
			{
				OptionName -> AnionStandardSuppressorVoltage,
				Default -> Null,
				Description -> "The electrical potential difference applied to the AnionSuppressor for standard samples. This option is set to the factory recommended voltage of the suppressor unless otherwise specified.",
				ResolutionDescription -> "This option will be set to Null if AnionStandardSuppressorMode is LegacyMode or Null. Otherwise, this option will be set to the factory recommended voltage of the suppressor.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 * Volt, 10 * Volt],
					Units -> Volt
				],
				Category -> "Hidden"
			},
			{
				OptionName -> AnionStandardSuppressorCurrent,
				Default -> Automatic,
				Description -> "The electrical current supplied to the AnionSuppressor module for AnionStandard samples before conductivity measurement.",
				ResolutionDescription -> "This option will be calculated by multiplying flow rate, maximum eluent concentration and suppressor specific factor (2.47 for anion suppressor).",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Milliampere, 150 Milliampere],
					Units -> Milliampere
				],
				Category -> "Standard"
			},
			{
				OptionName -> AnionStandardDetectionTemperature,
				Default -> Automatic,
				Description -> "The temperature of the oven where conductivity of the AnionStandard sample is measured.",
				ResolutionDescription -> "Automatically set to the first value of the AnionDetectionTemperature.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Quantity,
						Pattern :> RangeP[15 Celsius, 35 Celsius],
						Units -> Celsius
					],
					Widget[
						Type -> Enumeration,
						Pattern :> Alternatives[Ambient]
					]
				],
				Category -> "Standard"
			}
		],
		IndexMatching[
			IndexMatchingParent -> CationStandard,
			{
				OptionName -> CationStandardGradientA,
				Default -> Automatic,
				Description -> "The composition of Buffer A within the flow for CationStandard samples, defined for specific time points. The composition is linearly interpolated for the intervening periods between the defined time points. For example for CationStandardGradientA->{{0 Minute, 0 Percent},{30 Minute, 100 Percent}}, the percentage of BufferA in the flow will rise such that at 15 minutes, the composition should be 50*Percent. Since BufferA is only pumped into cation channel, this option is not applicable to anion standards. Gradient for anion standards can be set in StandardEluentGradient and AnionStandardGradient options.",
				ResolutionDescription -> "Automatically set from CationStandardGradient option or implicitly determined from CationStandardGradientB, CationStandardGradientC, and CationStandardGradientD options such that composition of BufferA, B, C, and D sums up to 100 Percent throughout the gradient.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Quantity,
						Pattern :> RangeP[0 Percent, 100 Percent],
						Units -> Percent
					],
					Adder[
						{
							"Time" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Minute, 4320 Minute],
								Units -> {Minute, {Second, Minute}}
							],
							"Buffer A Composition" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Percent, 100 Percent],
								Units -> Percent
							]
						},
						Orientation -> Vertical
					]
				],
				Category -> "Standard"
			},
			{
				OptionName -> CationStandardGradientB,
				Default -> Automatic,
				Description -> "The composition of Buffer B within the flow for CationStandard samples, defined for specific time points. The composition is linearly interpolated for the intervening periods between the defined time points. For example for CationStandardGradientB->{{0 Minute, 0 Percent},{30 Minute, 100 Percent}}, the percentage of BufferB in the flow will rise such that at 15 minutes, the composition should be 50*Percent. Since BufferB is only pumped into cation channel, this option is not applicable to anion standards. Gradient for anion standards can be set in StandardEluentGradient and AnionStandardGradient options.",
				ResolutionDescription -> "Automatically set from CationStandardGradient option or implicitly determined from CationStandardGradientA, CationStandardGradientC, and CationStandardGradientD options such that composition of BufferA, B, C, and D sums up to 100 Percent throughout the gradient.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Quantity,
						Pattern :> RangeP[0 Percent, 100 Percent],
						Units -> Percent
					],
					Adder[
						{
							"Time" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Minute, 4320 Minute],
								Units -> {Minute, {Second, Minute}}
							],
							"Buffer B Composition" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Percent, 100 Percent],
								Units -> Percent
							]
						},
						Orientation -> Vertical
					]
				],
				Category -> "Standard"
			},
			{
				OptionName -> CationStandardGradientC,
				Default -> Automatic,
				Description -> "The composition of Buffer C within the flow for CationStandard samples, defined for specific time points. The composition is linearly interpolated for the intervening periods between the defined time points. For example for CationStandardGradientC->{{0 Minute, 0 Percent},{30 Minute, 100 Percent}}, the percentage of BufferC in the flow will rise such that at 15 minutes, the composition should be 50*Percent. Since BufferC is only pumped into cation channel, this option is not applicable to anion standards. Gradient for anion standards can be set in StandardEluentGradient and AnionStandardGradient options.",
				ResolutionDescription -> "Automatically set from CationStandardGradient option or implicitly determined from CationStandardGradientA, CationStandardGradientB, and CationStandardGradientD options such that composition of BufferA, B, C, and D sums up to 100 Percent throughout the gradient.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Quantity,
						Pattern :> RangeP[0 Percent, 100 Percent],
						Units -> Percent
					],
					Adder[
						{
							"Time" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Minute, 4320 Minute],
								Units -> {Minute, {Second, Minute}}
							],
							"Buffer C Composition" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Percent, 100 Percent],
								Units -> Percent
							]
						},
						Orientation -> Vertical
					]
				],
				Category -> "Standard"
			},
			{
				OptionName -> CationStandardGradientD,
				Default -> Automatic,
				Description -> "The composition of Buffer D within the flow for CationStandard samples, defined for specific time points. The composition is linearly interpolated for the intervening periods between the defined time points. For example for CationStandardGradientD->{{0 Minute, 0 Percent},{30 Minute, 100 Percent}}, the percentage of BufferD in the flow will rise such that at 15 minutes, the composition should be 50*Percent. Since BufferD is only pumped into cation channel, this option is not applicable to anion standards. Gradient for anion standards can be set in StandardEluentGradient and AnionStandardGradient options.",
				ResolutionDescription -> "Automatically set from CationStandardGradient option or implicitly determined from CationStandardGradientA, CationStandardGradientB, and CationStandardGradientC options such that composition of BufferA, B, C, and D sums up to 100 Percent throughout the gradient.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Quantity,
						Pattern :> RangeP[0 Percent, 100 Percent],
						Units -> Percent
					],
					Adder[
						{
							"Time" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Minute, 4320 Minute],
								Units -> {Minute, {Second, Minute}}
							],
							"Buffer D Composition" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Percent, 100 Percent],
								Units -> Percent
							]
						},
						Orientation -> Vertical
					]
				],
				Category -> "Standard"
			},
			{
				OptionName -> CationStandardFlowRate,
				Default -> Automatic,
				Description -> "The speed of the fluid through the system for CationStandard samples.",
				ResolutionDescription -> "Automatically set from CationColumn, and FlowRate specified in the CationInjectionTable or taken from the method given in the CationStandardGradient option.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Quantity,
						Pattern :> RangeP[0 Milliliter / Minute, 10 Milliliter / Minute],
						Units -> CompoundUnit[
							{1, {Milliliter, {Milliliter, Liter}}},
							{-1, {Minute, {Minute, Second}}}
						]
					],
					Adder[
						{
							"Time" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Minute, 4320 Minute],
								Units -> {Minute, {Second, Minute}}
							],
							"Flow Rate" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Milliliter / Minute, 10 Milliliter / Minute],
								Units -> CompoundUnit[
									{1, {Milliliter, {Milliliter, Liter}}},
									{-1, {Minute, {Minute, Second}}}
								]
							]
						},
						Orientation -> Vertical
					]
				],
				Category -> "Standard"
			},
			{
				OptionName -> CationStandardGradientStart,
				Default -> Null,
				Description -> "A shorthand option to specify the starting BufferB concentration in the fluid flow of the instrument for CationStandard samples.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Percent, 100 Percent],
					Units -> Percent
				],
				Category -> "Standard"
			},
			{
				OptionName -> CationStandardGradientEnd,
				Default -> Null,
				Description -> "A shorthand option to specify the final BufferB concentration in the fluid flow of the instrument for CationStandard samples.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Percent, 100 Percent],
					Units -> Percent
				],
				Category -> "Standard"
			},
			{
				OptionName -> CationStandardGradientDuration,
				Default -> Null,
				Description -> "A shorthand option to specify the total time it takes to run the CationStandard gradient.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Minute, 4320 Minute],
					Units -> {Minute, {Minute, Second}}
				],
				Category -> "Standard"
			},
			{
				OptionName -> CationStandardGradient,
				Default -> Automatic,
				Description -> "The buffer composition over time in the fluid flow for CationStandard samples. Specific parameters of an object can be overridden by specific options for CationStandardGradientA, CationStandardGradientB, CationStandardGradientC, and CationStandardGradientD.",
				ResolutionDescription -> "Automatically set to match all specified options related to CationStandardGradient (e.g. CationStandardGradientA, CationStandardGradientB, CationStandardGradientC, CationStandardGradientD, CationStandardFlowRate, and CationStandardGradientDuration). If none of the options is specified, the first value of CationGradient will be used.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Object,
						Pattern :> ObjectP[Object[Method, IonChromatographyGradient]]
					],
					Adder[
						{
							"Time" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Minute, 4320 Minute],
								Units -> {Minute, {Second, Minute}}
							],
							"Buffer A Composition" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Percent, 100 Percent],
								Units -> Percent
							],
							"Buffer B Composition" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Percent, 100 Percent],
								Units -> Percent
							],
							"Buffer C Composition" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Percent, 100 Percent],
								Units -> Percent
							],
							"Buffer D Composition" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Percent, 100 Percent],
								Units -> Percent
							],
							"Flow Rate" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Milliliter / Minute, 10 Milliliter / Minute],
								Units -> CompoundUnit[
									{1, {Milliliter, {Milliliter, Liter}}},
									{-1, {Minute, {Minute, Second}}}
								]
							]
						},
						Orientation -> Vertical
					]
				],
				Category -> "Standard"
			},
			{
				OptionName -> CationStandardSuppressorMode,
				Default -> Automatic,
				Description -> "The operation method of the CationSuppressor for standard samples. Under DynamicMode, constant voltage is supplied to the suppressor with variable current while under LegacyMode, constant current is supplied.",
				ResolutionDescription -> "This option will be set to DynamicMode if SuppressorVoltage is specified or LegacyMode if SuppressorCurrent is specified. If none of the suppressor related options are set, this option will automatically be set to LegacyMode.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Enumeration,
					Pattern :> SuppressorModeP
				],
				Category -> "Hidden"
			},
			{
				OptionName -> CationStandardSuppressorVoltage,
				Default -> Null,
				Description -> "The electrical potential difference applied to the CationSuppressor for standard samples. This option is set to the factory recommended voltage of the suppressor unless otherwise specified.",
				ResolutionDescription -> "This option will be set to Null if CationStandardSuppressorMode is LegacyMode or Null. Otherwise, this option will be set to the factory recommended voltage of the suppressor.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 * Volt, 10 * Volt],
					Units -> Volt
				],
				Category -> "Hidden"
			},
			{
				OptionName -> CationStandardSuppressorCurrent,
				Default -> Automatic,
				Description -> "The electrical current supplied to the CationSuppressor module for CationStandard samples before conductivity measurement.",
				ResolutionDescription -> "This option will be calculated by multiplying flow rate, maximum buffer concentration and suppressor specific factor (2.94 for cation suppressor).",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Milliampere, 150 Milliampere],
					Units -> Milliampere
				],
				Category -> "Standard"
			},
			{
				OptionName -> CationStandardDetectionTemperature,
				Default -> Automatic,
				Description -> "The temperature of the oven where conductivity of the CationStandard sample is measured.",
				ResolutionDescription -> "Automatically set to the first value of the CationDetectionTemperature.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Quantity,
						Pattern :> RangeP[15 Celsius, 35 Celsius],
						Units -> Celsius
					],
					Widget[
						Type -> Enumeration,
						Pattern :> Alternatives[Ambient]
					]
				],
				Category -> "Standard"
			}
		],


		(* ================================================ *)
		(* === Single channel ICS 6000 Specific Options === *)
		(* ================================================ *)

		{
			OptionName -> StandardFrequency,
			Default -> Automatic,
			Description -> "Specify the frequency at which Standard measurements will be inserted among samples.",
			ResolutionDescription -> "Automatically set to FirstAndLast when any Standard option is specified.",
			AllowNull -> True,
			Widget -> Alternatives[
				Widget[
					Type -> Enumeration,
					Pattern :> None | First | Last | FirstAndLast | GradientChange
				],
				Widget[
					Type -> Number,
					Pattern :> GreaterP[0, 1]
				]
			],
			Category -> "Standard"
		},

		IndexMatching[
			IndexMatchingParent -> Standard,

			(* - Injection and Gradient options - *)
			{
				OptionName -> StandardInjectionVolume,
				Default -> Automatic,
				Description -> "The physical quantity of each Standard to inject into the system. We recommend that injection volumes either be equal to the sample loop volume (25 uL) or less than or equal to one half of the sample loop volume (12.5 uL). Injection volumes between 12.5 and 25 uL may have lower accuracy and precision.",
				ResolutionDescription -> "Automatically set to the first value of InjectionVolume.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Microliter, 25 Microliter],
					Units -> Microliter
				],
				Category -> "Standard"
			},
			{
				OptionName -> StandardColumnTemperature,
				Default -> Automatic,
				Description -> "The temperature the Column is held to throughout the Standard run and measurement.",
				ResolutionDescription -> "Automatically set from ColumnTemperature or taken from the StandardGradient option.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Quantity,
						Pattern :> RangeP[10 Celsius, 70 Celsius],
						Units -> Celsius
					],
					Widget[
						Type -> Enumeration,
						Pattern :> Alternatives[Ambient]
					]
				],
				Category -> "Standard"
			},
			{
				OptionName -> StandardGradientA,
				Default -> Automatic,
				Description -> "The composition of Buffer A within the flow for Standard samples, defined for specific time points. The composition is linearly interpolated for the intervening periods between the defined time points. For example for StandardGradientA->{{0 Minute, 0 Percent},{30 Minute, 100 Percent}}, the percentage of BufferA in the flow will rise such that at 15 minutes, the composition should be 50*Percent.",
				ResolutionDescription -> "Automatically set from StandardGradient option or implicitly determined from StandardGradientB, StandardGradientC, and StandardGradientD options such that composition of BufferA, B, C, and D sums up to 100 Percent throughout the gradient.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Quantity,
						Pattern :> RangeP[0 Percent, 100 Percent],
						Units -> Percent
					],
					Adder[
						{
							"Time" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Minute, 4320 Minute],
								Units -> {Minute, {Second, Minute}}
							],
							"Buffer A Composition" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Percent, 100 Percent],
								Units -> Percent
							]
						},
						Orientation -> Vertical
					]
				],
				Category -> "Standard"
			},
			{
				OptionName -> StandardGradientB,
				Default -> Automatic,
				Description -> "The composition of Buffer B within the flow for Standard samples, defined for specific time points. The composition is linearly interpolated for the intervening periods between the defined time points. For example for StandardGradientB->{{0 Minute, 0 Percent},{30 Minute, 100 Percent}}, the percentage of BufferB in the flow will rise such that at 15 minutes, the composition should be 50*Percent.",
				ResolutionDescription -> "Automatically set from CationStandardGradient option or implicitly determined from StandardGradientA, StandardGradientC, and StandardGradientD options such that composition of BufferA, B, C, and D sums up to 100 Percent throughout the gradient.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Quantity,
						Pattern :> RangeP[0 Percent, 100 Percent],
						Units -> Percent
					],
					Adder[
						{
							"Time" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Minute, 4320 Minute],
								Units -> {Minute, {Second, Minute}}
							],
							"Buffer B Composition" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Percent, 100 Percent],
								Units -> Percent
							]
						},
						Orientation -> Vertical
					]
				],
				Category -> "Standard"
			},
			{
				OptionName -> StandardGradientC,
				Default -> Automatic,
				Description -> "The composition of Buffer C within the flow for Standard samples, defined for specific time points. The composition is linearly interpolated for the intervening periods between the defined time points. For example for StandardGradientC->{{0 Minute, 0 Percent},{30 Minute, 100 Percent}}, the percentage of BufferC in the flow will rise such that at 15 minutes, the composition should be 50*Percent.",
				ResolutionDescription -> "Automatically set from CationStandardGradient option or implicitly determined from StandardGradientA, StandardGradientB, and StandardGradientD options such that composition of BufferA, B, C, and D sums up to 100 Percent throughout the gradient.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Quantity,
						Pattern :> RangeP[0 Percent, 100 Percent],
						Units -> Percent
					],
					Adder[
						{
							"Time" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Minute, 4320 Minute],
								Units -> {Minute, {Second, Minute}}
							],
							"Buffer C Composition" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Percent, 100 Percent],
								Units -> Percent
							]
						},
						Orientation -> Vertical
					]
				],
				Category -> "Standard"
			},
			{
				OptionName -> StandardGradientD,
				Default -> Automatic,
				Description -> "The composition of Buffer D within the flow for Standard samples, defined for specific time points. The composition is linearly interpolated for the intervening periods between the defined time points. For example for StandardGradientD->{{0 Minute, 0 Percent},{30 Minute, 100 Percent}}, the percentage of BufferD in the flow will rise such that at 15 minutes, the composition should be 50*Percent.",
				ResolutionDescription -> "Automatically set from StandardGradient option or implicitly determined from StandardGradientA, StandardGradientB, and StandardGradientC options such that composition of BufferA, B, C, and D sums up to 100 Percent throughout the gradient.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Quantity,
						Pattern :> RangeP[0 Percent, 100 Percent],
						Units -> Percent
					],
					Adder[
						{
							"Time" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Minute, 4320 Minute],
								Units -> {Minute, {Second, Minute}}
							],
							"Buffer D Composition" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Percent, 100 Percent],
								Units -> Percent
							]
						},
						Orientation -> Vertical
					]
				],
				Category -> "Standard"
			},
			{
				OptionName -> StandardFlowRate,
				Default -> Automatic,
				Description -> "The speed of the fluid through the system for Standard samples.",
				ResolutionDescription -> "Automatically set from Column, and FlowRate specified in the InjectionTable or taken from the method given in the StandardGradient option. If neither option is specified, the first value of FlowRate will be used.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Quantity,
						Pattern :> RangeP[0 Milliliter / Minute, 10 Milliliter / Minute],
						Units -> CompoundUnit[
							{1, {Milliliter, {Milliliter, Liter}}},
							{-1, {Minute, {Minute, Second}}}
						]
					],
					Adder[
						{
							"Time" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Minute, 4320 Minute],
								Units -> {Minute, {Second, Minute}}
							],
							"Flow Rate" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Milliliter / Minute, 10 Milliliter / Minute],
								Units -> CompoundUnit[
									{1, {Milliliter, {Milliliter, Liter}}},
									{-1, {Minute, {Minute, Second}}}
								]
							]
						},
						Orientation -> Vertical
					]
				],
				Category -> "Standard"
			},
			{
				OptionName -> StandardGradientStart,
				Default -> Null,
				Description -> "A shorthand option to specify the starting BufferB concentration in the fluid flow of the instrument for Standard samples.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Percent, 100 Percent],
					Units -> Percent
				],
				Category -> "Standard"
			},
			{
				OptionName -> StandardGradientEnd,
				Default -> Null,
				Description -> "A shorthand option to specify the final BufferB concentration in the fluid flow of the instrument for Standard samples.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Percent, 100 Percent],
					Units -> Percent
				],
				Category -> "Standard"
			},
			{
				OptionName -> StandardGradientDuration,
				Default -> Null,
				Description -> "A shorthand option to specify the total time it takes to run the Standard gradient.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Minute, 4320 Minute],
					Units -> {Minute, {Minute, Second}}
				],
				Category -> "Standard"
			},
			{
				OptionName -> StandardGradient,
				Default -> Automatic,
				Description -> "The buffer composition over time in the fluid flow for Standard samples. Specific parameters of an object can be overridden by specific options for StandardGradientA, StandardGradientB, StandardGradientC, and StandardGradientD.",
				ResolutionDescription -> "Automatically set to match all specified options related to StandardGradient (e.g. StandardGradientA, StandardGradientB, StandardGradientC, StandardGradientD, StandardFlowRate, and StandardGradientDuration). If none of the options is specified, the first Gradient will be used.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Object,
						Pattern :> ObjectP[Object[Method, Gradient]]
					],
					Adder[
						{
							"Time" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Minute, 4320 Minute],
								Units -> {Minute, {Second, Minute}}
							],
							"Buffer A Composition" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Percent, 100 Percent],
								Units -> Percent
							],
							"Buffer B Composition" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Percent, 100 Percent],
								Units -> Percent
							],
							"Buffer C Composition" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Percent, 100 Percent],
								Units -> Percent
							],
							"Buffer D Composition" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Percent, 100 Percent],
								Units -> Percent
							],
							"Flow Rate" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Milliliter / Minute, 10 Milliliter / Minute],
								Units -> CompoundUnit[
									{1, {Milliliter, {Milliliter, Liter}}},
									{-1, {Minute, {Minute, Second}}}
								]
							]
						},
						Orientation -> Vertical
					]
				],
				Category -> "Standard"
			},

			(* - UV detection options - *)
			{
				OptionName -> StandardAbsorbanceWavelength,
				Default -> Automatic,
				Description -> "The physical properties of light passed through the flow for the UVVis Detector during Standard sample runs. Up to 4 separate wavelengths may be specified.",
				ResolutionDescription -> "Automatically set to 280 Nanometer if the UVVis detector is used in the protocol.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Quantity,
						Pattern :> RangeP[190 Nanometer, 900 Nanometer],
						Units -> Nanometer
					],
					Adder[
						Widget[
							Type -> Quantity,
							Pattern :> RangeP[190 Nanometer, 900 Nanometer],
							Units -> Nanometer
						]
					]
				],
				Category -> "Standard"
			},
			{
				OptionName -> StandardAbsorbanceSamplingRate,
				Default -> Automatic,
				Description -> "Indicates the frequency of absorbance measurement for Standard samples. Lower values will be less susceptible to noise but will record less frequently across time.",
				ResolutionDescription -> "Automatically set based on the number of wavelengths specified. Default StandardAbsorbanceSamplingRate is 10/Second for measurement at a single wavelength and 1/Second for measurements at multiple wavelengths.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Quantity,
					Pattern :> RangeP[0.2 / Second, 100 / Second],
					Units -> 1 / Second
				],
				Category -> "Standard"
			},

			(* - Electrochemical detection options - *)
			{
				OptionName -> StandardElectrochemicalDetectionMode,
				Default -> Automatic,
				Description -> "Specifies the mode of operation for the electrochemical detector during Standard sample runs, including DC Amperometric Detection, Pulsed Amperometric Detection, and Integrated Pulsed Amperometric Detection. In DC Amperometric Detection, a constant voltage is applied. In contrast, Pulsed Amperometric Detections first apply a working potential followed by higher or lower potentials that are used for cleaning the electrode. Further, Integrated Amperometric Detection integrates current over a single potential whereas Integrated Pulsed Amperometric Detection integrates current over two or more potentials.",
				ResolutionDescription -> "Automatically set based on the StandardVoltageProfile or the StandardWaveformProfile specified. If neither option is specified, this option defaults to Pulsed Amperometry.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Enumeration,
					Pattern :> ElectrochemicalDetectionModeP
				],
				Category -> "Standard"
			},
			{
				OptionName -> StandardReferenceElectrodeMode,
				Default -> Automatic,
				Description -> "A combination pH-Ag/AgCl reference electrode that can be used to either monitor the buffer pH (\"pH\" reference) or to serve as a cell reference electrode with a constant potential (\"AgCl\" reference).",
				ResolutionDescription -> "Automatically set from Waveform method object. If Waveform is not specified, this option defaults to AgCl.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Enumeration,
					Pattern :> ReferenceElectrodeModeP
				],
				Category -> "Standard"
			},
			{
				OptionName -> StandardVoltageProfile,
				Default -> Automatic,
				Description -> "The time-dependent voltage setting throughout the measurement for Standard samples.",
				ResolutionDescription -> "Automatically set to 0.1 Volt for DCAmperometricDetection. If any other StandardElectrochemicalDetectionMode is used, this option will set to Null.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Quantity,
						Pattern :> RangeP[-2.048 Volt, 2.047 Volt],
						Units -> Volt
					],
					Adder[
						{
							"Time" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Minute, 4320 Minute],
								Units -> {Minute, {Second, Minute}}
							],
							"Voltage" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[-2.048 Volt, 2.047 Volt],
								Units -> {Volt, {Milli * Volt, Volt}}
							]
						},
						Orientation -> Vertical
					]
				],
				Category -> "Standard"
			},
			{
				OptionName -> StandardWaveformProfile,
				Default -> Automatic,
				Description -> "A series of time-dependent voltage setting (waveform) that will be repeated over the duration of the Standard sample analysis.",
				ResolutionDescription -> "Automatically set to repeat a single waveform defined for either Pulsed Amperometric Detection or Integrated Pulsed Amperometric Detection over the entire run.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Object,
						Pattern :> ObjectP[Object[Method, Waveform]]
					],
					Adder[
						{
							"Waveform Time" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Second, 2 Second],
								Units -> Second
							],
							"Voltage" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[-2.048 Volt, 2.047 Volt],
								Units -> Volt
							],
							"Interpolation" -> Widget[
								Type -> Enumeration,
								Pattern :> BooleanP
							],
							"Integration" -> Widget[
								Type -> Enumeration,
								Pattern :> BooleanP
							]
						},
						Orientation -> Vertical
					],
					Adder[
						{
							"Time" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Minute, 4320 Minute],
								Units -> {Minute, {Second, Minute}}
							],
							"Waveform" -> Widget[
								Type -> Object,
								Pattern :> ObjectP[Object[Method, Waveform]]
							]
						},
						Orientation -> Vertical
					],
					Adder[
						{
							"Time" -> Widget[
								Type -> Quantity,
								Pattern :> GreaterEqualP[0 Minute],
								Units -> {Minute, {Second, Minute}}
							],
							"Waveform" -> Adder[
								{
									"Waveform Time" -> Widget[
										Type -> Quantity,
										Pattern :> RangeP[0 Second, 2 Second],
										Units -> Second
									],
									"Voltage" -> Widget[
										Type -> Quantity,
										Pattern :> RangeP[-2.048 Volt, 2.047 Volt],
										Units -> Volt
									],
									"Interpolation" -> Widget[
										Type -> Enumeration,
										Pattern :> BooleanP
									],
									"Integration" -> Widget[
										Type -> Enumeration,
										Pattern :> BooleanP
									]
								},
								Orientation -> Vertical
							]
						},
						Orientation -> Vertical
					]
				],
				Category -> "Standard"
			},
			{
				OptionName -> StandardElectrochemicalSamplingRate,
				Default -> Automatic,
				Description -> "Indicates the frequency of amperometric measurement. Lower values will be less susceptible to noise but will record less frequently across time.",
				ResolutionDescription -> "Automatically set to 1/waveform duration if a single waveform is specified. If multiple waveforms are specified, this option is set to 1 over the longest waveform duration. If no waveform is specified, this option is set to 2/Second.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Quantity,
					Pattern :> RangeP[0.2 / Second, 100 / Second],
					Units -> 1 / Second
				],
				Category -> "Standard"
			},
			{
				OptionName -> StandardDetectionTemperature,
				Default -> Automatic,
				Description -> "The temperature of the detection oven where the eletrochemical detection takes place.",
				ResolutionDescription -> "This option will automatically be set to Ambient if electrochemical detector is used.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Quantity,
						Pattern :> RangeP[15 Celsius, 35 Celsius],
						Units -> Celsius
					],
					Widget[
						Type -> Enumeration,
						Pattern :> Alternatives[Ambient]
					]
				],
				Category -> "Standard"
			}
		],


		(* --- Blank Category --- *)

		(* ====================== *)
		(* === Common options === *)
		(* ====================== *)

		IndexMatching[
			IndexMatchingParent -> Blank,
			{
				OptionName -> Blank,
				Default -> Automatic,
				Description -> "The compound(s) to inject typically as negative controls (e.g. to test effects stemming from injection, sample solvent, or buffer).",
				ResolutionDescription -> "Automatically set to deionized water when any other Blank option is specified.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Object,
					Pattern :> ObjectP[{Model[Sample], Object[Sample]}]
				],
				Category -> "Blanks"
			},
			{
				OptionName -> BlankStorageCondition,
				Default -> Automatic,
				Description -> "The conditions under which any Blank sample used by this experiment should be stored after the protocol is completed. If this option is set to Null when Blank samples are specified, the Blank samples will be stored according to their Models' DefaultStorageCondition.",
				ResolutionDescription -> "Automatically set to Disposal if there's any blank sample.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Enumeration,
						Pattern :> SampleStorageTypeP | Disposal
					]
				],
				Category -> "Blanks"
			}
		],


		(* ================================================ *)
		(* === Double channel ICS 6000 Specific Options === *)
		(* ================================================ *)

		IndexMatching[
			IndexMatchingParent -> Blank,
			{
				OptionName -> BlankAnalysisChannel,
				Default -> Automatic,
				Description -> "The flow path into which the Blank is injected. CationChannel and AnionChannel employ suppressed conductivity detection for common cations and anions respectively whereas ElectrochemicalChannel employs electrochemical and/or UV detection for polysaccharides and beyond.",
				ResolutionDescription -> "Automatically set from the Composition and/or Analytes of the Blank. If the sample contains any oligomer, this option will automatically set to ElectrochemicalChannel. If the sample consists of two or more analytes in the common cation list (Lithium, Sodium, Ammonium, Potassium, Magnesium, and Calcium), this option will automatically set to CationChannel. If the sample consists of two or more analytes in the common anion list (Fluoride, Chloride, Bromide, Nitrate, Sulfate, and Phosphate), this option will automatically set to AnionChannel. If a sample meets both cation and anion criteria or if neither Composition nor Analytes is specified for the sample, this option defaults to AnionChannel.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Enumeration,
					Pattern :> AnalysisChannelP
				],
				Category -> "Blanks"
			}
		],
		IndexMatching[
			IndexMatchingParent -> AnionBlank,
			{
				OptionName -> AnionBlank,
				Default -> Automatic,
				Description -> "A list of negative control compounds to be injected into the anion channel of the instrument.",
				ResolutionDescription -> "Automatically compiled from Blank with BlankAnalysisChannel set to AnionChannel.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Object,
					Pattern :> ObjectP[{Model[Sample], Object[Sample]}]
				],
				Category -> "Blanks"
			}
		],
		{
			OptionName -> AnionBlankFrequency,
			Default -> Automatic,
			Description -> "Specify the frequency at which AnionBlank measurements will be inserted among samples.",
			ResolutionDescription -> "Automatically set to FirstAndLast when any AnionBlank option is specified.",
			AllowNull -> True,
			Widget -> Alternatives[
				Widget[
					Type -> Enumeration,
					Pattern :> None | First | Last | FirstAndLast | GradientChange
				],
				Widget[
					Type -> Number,
					Pattern :> GreaterP[0, 1]
				]
			],
			Category -> "Blanks"
		},
		IndexMatching[
			IndexMatchingParent -> CationBlank,
			{
				OptionName -> CationBlank,
				Default -> Automatic,
				Description -> "A list of negative control compounds to be injected into the cation channel of the instrument.",
				ResolutionDescription -> "Automatically compiled from Blank with BlankAnalysisChannel set to CationChannel.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Object,
					Pattern :> ObjectP[{Model[Sample], Object[Sample]}]
				],
				Category -> "Blanks"
			}
		],
		{
			OptionName -> CationBlankFrequency,
			Default -> Automatic,
			Description -> "Specify the frequency at which CationBlank measurements will be inserted among samples.",
			ResolutionDescription -> "Automatically set to FirstAndLast when any CationBlank option is specified.",
			AllowNull -> True,
			Widget -> Alternatives[
				Widget[
					Type -> Enumeration,
					Pattern :> None | First | Last | FirstAndLast | GradientChange
				],
				Widget[
					Type -> Number,
					Pattern :> GreaterP[0, 1]
				]
			],
			Category -> "Blanks"
		},
		IndexMatching[
			IndexMatchingParent -> AnionBlank,
			{
				OptionName -> AnionBlankInjectionVolume,
				Default -> Automatic,
				Description -> "The physical quantity of each AnionBlank sample to inject. We recommend that injection volumes either be equal to the sample loop volume (10 uL) or less than or equal to one half of the sample loop volume (5 uL). Injection volumes between 5 and 10 uL may have lower accuracy and precision.",
				ResolutionDescription -> "Automatically set to the first value of the AnionInjectionVolume.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Microliter, 10 Microliter],
					Units -> Microliter
				],
				Category -> "Blanks"
			},
			{
				OptionName -> AnionBlankColumnTemperature,
				Default -> Automatic,
				Description -> "The temperature the AnionColumn is held to throughout the AnionBlank run and measurement.",
				ResolutionDescription -> "Automatically set from AnionColumnTemperature or taken from the AnionBlankGradient option.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Quantity,
						Pattern :> RangeP[10 Celsius, 70 Celsius],
						Units -> Celsius
					],
					Widget[
						Type -> Enumeration,
						Pattern :> Alternatives[Ambient]
					]
				],
				Category -> "Blanks"
			}
		],
		IndexMatching[
			IndexMatchingParent -> CationBlank,
			{
				OptionName -> CationBlankInjectionVolume,
				Default -> Automatic,
				Description -> "The physical quantity of each CationBlank sample to inject. We recommend that injection volumes either be equal to the sample loop volume (10 uL) or less than or equal to one half of the sample loop volume (5 uL). Injection volumes between 5 and 10 uL may have lower accuracy and precision.",
				ResolutionDescription -> "Automatically set to the first value of CationInjectionVolume.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Microliter, 10 Microliter],
					Units -> Microliter
				],
				Category -> "Blanks"
			},
			{
				OptionName -> CationBlankColumnTemperature,
				Default -> Automatic,
				Description -> "The temperature the CationColumn is held to throughout the AnionBlank run and measurement.",
				ResolutionDescription -> "Automatically set from CationColumnTemperature or taken from the CationBlankGradient option.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Quantity,
						Pattern :> RangeP[10 Celsius, 70 Celsius],
						Units -> Celsius
					],
					Widget[
						Type -> Enumeration,
						Pattern :> Alternatives[Ambient]
					]
				],
				Category -> "Blanks"
			}
		],
		IndexMatching[
			IndexMatchingParent -> AnionBlank,
			{
				OptionName -> BlankEluentGradient,
				Default -> Automatic,
				Description -> "The concentration of the eluent that is automatically generated within the flow path for AnionBlank samples, defined for specific time points. The composition is linearly interpolated for the intervening periods between the defined time points. For example for BlankEluentGradient->{{0 Minute, 0 Millimolar},{30 Minute, 100 Millimolar}}, the eluent concentration in the flow will rise such that at 15 minutes, the concentration should be 50 Millimolar. Since eluent generator is only integrated in anion channel, this option is not applicable to cation blanks. Gradient for cation blanks can be set in CationBlankGradientA, CationBlankGradientB, CationBlankGradientC, CationBlankGradientD, and CationBlankGradient options.",
				ResolutionDescription -> "Automatically set from AnionBlankGradient option.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Quantity,
						Pattern :> RangeP[0 Millimolar, 100 Millimolar],
						Units -> Millimolar
					],
					Adder[
						{
							"Time" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Minute, 4320 Minute],
								Units -> {Minute, {Second, Minute}}
							],
							"Eluent Concentration" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Millimolar, 100 Millimolar],
								Units -> Millimolar
							]
						},
						Orientation -> Vertical
					]
				],
				Category -> "Blanks"
			},
			{
				OptionName -> AnionBlankFlowRate,
				Default -> Automatic,
				Description -> "The speed at which the fluid is pumped through the system for AnionBlank sample measurement.",
				ResolutionDescription -> "Automatically set from AnionColumn and FlowRate specified in the AnionInjectionTable or taken from the method given in the AnionBlankGradient option.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Quantity,
						Pattern :> RangeP[0 Milliliter / Minute, 10 Milliliter / Minute],
						Units -> CompoundUnit[
							{1, {Milliliter, {Milliliter, Liter}}},
							{-1, {Minute, {Minute, Second}}}
						]
					],
					Adder[
						{
							"Time" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Minute, 4320 Minute],
								Units -> {Minute, {Second, Minute}}
							],
							"Flow Rate" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Milliliter / Minute, 10 Milliliter / Minute],
								Units -> CompoundUnit[
									{1, {Milliliter, {Milliliter, Liter}}},
									{-1, {Minute, {Minute, Second}}}
								]
							]
						},
						Orientation -> Vertical
					]
				],
				Category -> "Blanks"
			},
			{
				OptionName -> AnionBlankGradientStart,
				Default -> Null,
				Description -> "A shorthand option to specify the starting eluent concentration in the fluid flow of the instrument for AnionBlank samples.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Millimolar, 100 Millimolar],
					Units -> Millimolar
				],
				Category -> "Blanks"
			},
			{
				OptionName -> AnionBlankGradientEnd,
				Default -> Null,
				Description -> "A shorthand option to specify the final eluent concentration in the fluid flow of the instrument for AnionBlank samples.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Millimolar, 100 Millimolar],
					Units -> Millimolar
				],
				Category -> "Blanks"
			},
			{
				OptionName -> AnionBlankGradientDuration,
				Default -> Null,
				Description -> "A shorthand option to specify the total time it takes to run the gradient for AnionBlank samples.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Minute, 4320 Minute],
					Units -> {Minute, {Minute, Second}}
				],
				Category -> "Blanks"
			},
			{
				OptionName -> AnionBlankGradient,
				Default -> Automatic,
				Description -> "The concentration of the eluent, potassium hydroxide, over time in the fluid flow for AnionBlank samples. Specific parameters of an object can be overridden by specific options for BlankEluentGradient. Since eluent generator is only integrated in anion channel, this option is not applicable to cation blanks. Gradient for cation blanks can be set in CationBlankGradientA, CationBlankGradientB, CationBlankGradientC, CationBlankGradientD, and CationBlankGradient options.",
				ResolutionDescription -> "Automatically set to match all specified options related to AnionBlankGradient (e.g. BlankEluentGradient, AnionBlankFlowRate, AnionBlankGradientDuration). If none of the options is specified, the first AnionGradient will be used.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Object,
						Pattern :> ObjectP[Object[Method, IonChromatographyGradient]]
					],
					Adder[
						{
							"Time" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Minute, 4320 Minute],
								Units -> {Minute, {Second, Minute}}
							],
							"Eluent Concentration" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Millimolar, 100 Millimolar],
								Units -> Millimolar
							],
							"Flow Rate" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Milliliter / Minute, 10 Milliliter / Minute],
								Units -> CompoundUnit[
									{1, {Milliliter, {Milliliter, Liter}}},
									{-1, {Minute, {Minute, Second}}}
								]
							]
						},
						Orientation -> Vertical
					]
				],
				Category -> "Blanks"
			},
			{
				OptionName -> AnionBlankSuppressorMode,
				Default -> Automatic,
				Description -> "The operation method of the AnionSuppressor for blank samples. Under DynamicMode, constant voltage is supplied to the suppressor with variable current while under LegacyMode, constant current is supplied.",
				ResolutionDescription -> "This option will be set to DynamicMode if SuppressorVoltage is specified or Legacy if SuppressorCurrent is specified. If none of the suppressor related options are set, this option will automatically be set to LegacyMode.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Enumeration,
					Pattern :> SuppressorModeP
				],
				Category -> "Hidden"
			},
			{
				OptionName -> AnionBlankSuppressorVoltage,
				Default -> Null,
				Description -> "The electrical potential difference applied to the AnionSuppressor for blank samples. This option is set to the factory recommended voltage of the suppressor unless otherwise specified.",
				ResolutionDescription -> "This option will be set to Null if AnionBlankSuppressorMode is LegacyMode or Null. Otherwise, this option will be set to the factory recommended voltage of the suppressor.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 * Volt, 10 * Volt],
					Units -> Volt
				],
				Category -> "Hidden"
			},
			{
				OptionName -> AnionBlankSuppressorCurrent,
				Default -> Automatic,
				Description -> "The electrical current supplied to the AnionSuppressor module for AnionBlank samples before conductivity measurement.",
				ResolutionDescription -> "This option will be calculated by multiplying flow rate, maximum eluent concentration and suppressor specific factor (2.47 for anion suppressor).",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Milliampere, 150 Milliampere],
					Units -> Milliampere
				],
				Category -> "Blanks"
			},
			{
				OptionName -> AnionBlankDetectionTemperature,
				Default -> Automatic,
				Description -> "The temperature of the oven where conductivity of AnionBlank sample is measured.",
				ResolutionDescription -> "Automatically set to the first value of the AnionDetectionTemperature.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Quantity,
						Pattern :> RangeP[15 Celsius, 35 Celsius],
						Units -> Celsius
					],
					Widget[
						Type -> Enumeration,
						Pattern :> Alternatives[Ambient]
					]
				],
				Category -> "Blanks"
			}
		],
		IndexMatching[
			IndexMatchingParent -> CationBlank,
			{
				OptionName -> CationBlankGradientA,
				Default -> Automatic,
				Description -> "The composition of Buffer A within the flow for CationBlank samples, defined for specific time points. The composition is linearly interpolated for the intervening periods between the defined time points. For example for CationBlankGradientA->{{0 Minute, 0 Percent},{30 Minute, 100 Percent}}, the percentage of BufferA in the flow will rise such that at 15 minutes, the composition should be 50*Percent. Since BufferA is only pumped into cation channel, this option is not applicable to anion blanks. Gradient for anion blanks can be set in BlankEluentGradient and AnionBlankGradient options.",
				ResolutionDescription -> "Automatically set from CationBlankGradient option or implicitly determined from CationBlankGradientA, CationBlankGradientB, and CationBlankGradientD options such that composition of BufferA, B, C, and D sums up to 100 Percent throughout the gradient.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Quantity,
						Pattern :> RangeP[0 Percent, 100 Percent],
						Units -> Percent
					],
					Adder[
						{
							"Time" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Minute, 4320 Minute],
								Units -> {Minute, {Second, Minute}}
							],
							"Buffer A Composition" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Percent, 100 Percent],
								Units -> Percent
							]
						},
						Orientation -> Vertical
					]
				],
				Category -> "Blanks"
			},
			{
				OptionName -> CationBlankGradientB,
				Default -> Automatic,
				Description -> "The composition of Buffer B within the flow for CationBlank samples, defined for specific time points. The composition is linearly interpolated for the intervening periods between the defined time points. For example for CationBlankGradientB->{{0 Minute, 0 Percent},{30 Minute, 100 Percent}}, the percentage of BufferB in the flow will rise such that at 15 minutes, the composition should be 50*Percent. Since BufferB is only pumped into cation channel, this option is not applicable to anion blanks. Gradient for anion blanks can be set in BlankEluentGradient and AnionBlankGradient options.",
				ResolutionDescription -> "Automatically set from CationBlankGradient option or implicitly determined from CationBlankGradientA, CationBlankGradientC, and CationBlankGradientD options such that composition of BufferA, B, C, and D sums up to 100 Percent throughout the gradient.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Quantity,
						Pattern :> RangeP[0 Percent, 100 Percent],
						Units -> Percent
					],
					Adder[
						{
							"Time" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Minute, 4320 Minute],
								Units -> {Minute, {Second, Minute}}
							],
							"Buffer B Composition" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Percent, 100 Percent],
								Units -> Percent
							]
						},
						Orientation -> Vertical
					]
				],
				Category -> "Blanks"
			},
			{
				OptionName -> CationBlankGradientC,
				Default -> Automatic,
				Description -> "The composition of Buffer C within the flow for CationBlank samples, defined for specific time points. The composition is linearly interpolated for the intervening periods between the defined time points. For example for CationBlankGradientC->{{0 Minute, 0 Percent},{30 Minute, 100 Percent}}, the percentage of BufferC in the flow will rise such that at 15 minutes, the composition should be 50*Percent. Since BufferC is only pumped into cation channel, this option is not applicable to anion blanks. Gradient for anion blanks can be set in BlankEluentGradient and AnionBlankGradient options.",
				ResolutionDescription -> "Automatically set from CationBlankGradient option or implicitly determined from CationBlankGradientA,CationBlankGradientB, and CationBlankGradientD options such that composition of BufferA, B, C, and D sums up to 100 Percent throughout the gradient.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Quantity,
						Pattern :> RangeP[0 Percent, 100 Percent],
						Units -> Percent
					],
					Adder[
						{
							"Time" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Minute, 4320 Minute],
								Units -> {Minute, {Second, Minute}}
							],
							"Buffer C Composition" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Percent, 100 Percent],
								Units -> Percent
							]
						},
						Orientation -> Vertical
					]
				],
				Category -> "Blanks"
			},
			{
				OptionName -> CationBlankGradientD,
				Default -> Automatic,
				Description -> "The composition of Buffer D within the flow for CationBlank samples, defined for specific time points. The composition is linearly interpolated for the intervening periods between the defined time points. For example for BlankGradientD->{{0 Minute, 0 Percent},{30 Minute, 100 Percent}}, the percentage of BufferD in the flow will rise such that at 15 minutes, the composition should be 50*Percent. Since BufferD is only pumped into cation channel, this option is not applicable to anion blanks. Gradient for anion blanks can be set in BlankEluentGradient and AnionBlankGradient options.",
				ResolutionDescription -> "Automatically set from CationBlankGradient option or implicitly determined from CationBlankGradientA, CationBlankGradientB, and CationBlankGradientC options such that composition of BufferA, B, C, and D sums up to 100 Percent throughout the gradient.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Quantity,
						Pattern :> RangeP[0 Percent, 100 Percent],
						Units -> Percent
					],
					Adder[
						{
							"Time" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Minute, 4320 Minute],
								Units -> {Minute, {Second, Minute}}
							],
							"Buffer D Composition" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Percent, 100 Percent],
								Units -> Percent
							]
						},
						Orientation -> Vertical
					]
				],
				Category -> "Blanks"
			},
			{
				OptionName -> CationBlankFlowRate,
				Default -> Automatic,
				Description -> "The speed at which the fluid is pumped through the system for CationBlank sample measurement.",
				ResolutionDescription -> "Automatically set from CationColum and FlowRate specified in the CationInjectionTable or taken from the method given in the CationBlankGradient option.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Quantity,
						Pattern :> RangeP[0 Milliliter / Minute, 10 Milliliter / Minute],
						Units -> CompoundUnit[
							{1, {Milliliter, {Milliliter, Liter}}},
							{-1, {Minute, {Minute, Second}}}
						]
					],
					Adder[
						{
							"Time" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Minute, 4320 Minute],
								Units -> {Minute, {Second, Minute}}
							],
							"Flow Rate" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Milliliter / Minute, 10 Milliliter / Minute],
								Units -> CompoundUnit[
									{1, {Milliliter, {Milliliter, Liter}}},
									{-1, {Minute, {Minute, Second}}}
								]
							]
						},
						Orientation -> Vertical
					]
				],
				Category -> "Blanks"
			},
			{
				OptionName -> CationBlankGradientStart,
				Default -> Null,
				Description -> "A shorthand option to specify the starting BufferB concentration in the fluid flow of the instrument for CationBlank samples.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Percent, 100 Percent],
					Units -> Percent
				],
				Category -> "Blanks"
			},
			{
				OptionName -> CationBlankGradientEnd,
				Default -> Null,
				Description -> "A shorthand option to specify the final BufferB concentration in the fluid flow of the instrument for CationBlank samples.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Percent, 100 Percent],
					Units -> Percent
				],
				Category -> "Blanks"
			},
			{
				OptionName -> CationBlankGradientDuration,
				Default -> Null,
				Description -> "A shorthand option to specify the total time it takes to run the gradient for CationBlank samples.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Minute, 4320 Minute],
					Units -> {Minute, {Minute, Second}}
				],
				Category -> "Blanks"
			},
			{
				OptionName -> CationBlankGradient,
				Default -> Automatic,
				Description -> "The buffer composition over time in the fluid flow for CationBlank samples. Specific parameters of an object can be overridden by specific options for CationBlankGradientA, CationBlankGradientB, CationBlankGradientC, and CationBlankGradientD.",
				ResolutionDescription -> "Automatically set to match all specified options related to CationBlankGradient (e.g. CationBlankGradientA, CationBlankGradientB, CationBlankGradientC, CationBlankGradientD, CationBlankFlowRate, and CationBlankGradientDuration). If none of the options is specified, the first CationGradient will be used.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Object,
						Pattern :> ObjectP[Object[Method, IonChromatographyGradient]]
					],
					Adder[
						{
							"Time" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Minute, 4320 Minute],
								Units -> {Minute, {Second, Minute}}
							],
							"Buffer A Composition" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Percent, 100 Percent],
								Units -> Percent
							],
							"Buffer B Composition" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Percent, 100 Percent],
								Units -> Percent
							],
							"Buffer C Composition" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Percent, 100 Percent],
								Units -> Percent
							],
							"Buffer D Composition" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Percent, 100 Percent],
								Units -> Percent
							],
							"Flow Rate" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Milliliter / Minute, 10 Milliliter / Minute],
								Units -> CompoundUnit[
									{1, {Milliliter, {Milliliter, Liter}}},
									{-1, {Minute, {Minute, Second}}}
								]
							]
						},
						Orientation -> Vertical
					]
				],
				Category -> "Blanks"
			},
			{
				OptionName -> CationBlankSuppressorMode,
				Default -> Automatic,
				Description -> "The operation method of the CationSuppressor for blank samples. Under DynamicMode, constant voltage is supplied to the suppressor with variable current while under LegacyMode, constant current is supplied.",
				ResolutionDescription -> "This option will be set to DynamicMode if SuppressorVoltage is specified or LegacyMode if SuppressorCurrent is specified. If none of the suppressor related options are set, this option will automatically be set to LegacyMode.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Enumeration,
					Pattern :> SuppressorModeP
				],
				Category -> "Hidden"
			},
			{
				OptionName -> CationBlankSuppressorVoltage,
				Default -> Null,
				Description -> "The electrical potential difference applied to the CationSuppressor for blank samples. This option is set to the factory recommended voltage of the suppressor unless otherwise specified.",
				ResolutionDescription -> "This option will be set to Null if CationBlankSuppressorMode is LegacyMode or Null. Otherwise, this option will be set to the factory recommended voltage of the suppressor.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 * Volt, 10 * Volt],
					Units -> Volt
				],
				Category -> "Hidden"
			},
			{
				OptionName -> CationBlankSuppressorCurrent,
				Default -> Automatic,
				Description -> "The electrical current supplied to the CationSuppressor module for CationBlank samples before conductivity measurement.",
				ResolutionDescription -> "This option will be calculated by multiplying flow rate, maximum buffer concentration and suppressor specific factor (2.94 for cation suppressor).",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Milliampere, 150 Milliampere],
					Units -> Milliampere
				],
				Category -> "Blanks"
			},
			{
				OptionName -> CationBlankDetectionTemperature,
				Default -> Automatic,
				Description -> "The temperature of the oven where conductivity of CationBlank sample is measured.",
				ResolutionDescription -> "Automatically set to the first value of the CationDetectionTemperature.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Quantity,
						Pattern :> RangeP[15 Celsius, 35 Celsius],
						Units -> Celsius
					],
					Widget[
						Type -> Enumeration,
						Pattern :> Alternatives[Ambient]
					]
				],
				Category -> "Blanks"
			}
		],


		(* ================================================ *)
		(* === Single channel ICS 6000 Specific Options === *)
		(* ================================================ *)

		{
			OptionName -> BlankFrequency,
			Default -> Automatic,
			Description -> "Specify the frequency at which Blank measurements will be inserted among samples.",
			ResolutionDescription -> "Automatically set to FirstAndLast when any Blank option is specified.",
			AllowNull -> True,
			Widget -> Alternatives[
				Widget[
					Type -> Enumeration,
					Pattern :> None | First | Last | FirstAndLast | GradientChange
				],
				Widget[
					Type -> Number,
					Pattern :> GreaterP[0, 1]
				]
			],
			Category -> "Blanks"
		},
		IndexMatching[
			IndexMatchingParent -> Blank,

			(* - Injection and Gradient options - *)
			{
				OptionName -> BlankInjectionVolume,
				Default -> Automatic,
				Description -> "The physical quantity of each Blank to inject into the system. We recommend that injection volumes either be equal to the sample loop volume (25 uL) or less than or equal to one half of the sample loop volume (12.5 uL). Injection volumes between 12.5 and 25 uL may have lower accuracy and precision.",
				ResolutionDescription -> "Automatically set to the first value of InjectionVolume.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Microliter, 25 Microliter],
					Units -> Microliter
				],
				Category -> "Blanks"
			},
			{
				OptionName -> BlankColumnTemperature,
				Default -> Automatic,
				Description -> "The temperature the Column is held to throughout the Blank run and measurement.",
				ResolutionDescription -> "Automatically set from ColumnTemperature or taken from the BlankGradient option.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Quantity,
						Pattern :> RangeP[10 Celsius, 70 Celsius],
						Units -> Celsius
					],
					Widget[
						Type -> Enumeration,
						Pattern :> Alternatives[Ambient]
					]
				],
				Category -> "Blanks"
			},
			{
				OptionName -> BlankGradientA,
				Default -> Automatic,
				Description -> "The composition of Buffer A within the flow for Blank samples, defined for specific time points. The composition is linearly interpolated for the intervening periods between the defined time points. For example for BlankGradientA->{{0 Minute, 0 Percent},{30 Minute, 100 Percent}}, the percentage of BufferA in the flow will rise such that at 15 minutes, the composition should be 50*Percent.",
				ResolutionDescription -> "Automatically set from BlankGradient option or implicitly determined from BlankGradientB, BlankGradientC, and BlankGradientD options such that composition of BufferA, B, C, and D sums up to 100 Percent throughout the gradient.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Quantity,
						Pattern :> RangeP[0 Percent, 100 Percent],
						Units -> Percent
					],
					Adder[
						{
							"Time" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Minute, 4320 Minute],
								Units -> {Minute, {Second, Minute}}
							],
							"Buffer A Composition" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Percent, 100 Percent],
								Units -> Percent
							]
						},
						Orientation -> Vertical
					]
				],
				Category -> "Blanks"
			},
			{
				OptionName -> BlankGradientB,
				Default -> Automatic,
				Description -> "The composition of Buffer B within the flow for Blank samples, defined for specific time points. The composition is linearly interpolated for the intervening periods between the defined time points. For example for BlankGradientB->{{0 Minute, 0 Percent},{30 Minute, 100 Percent}}, the percentage of BufferB in the flow will rise such that at 15 minutes, the composition should be 50*Percent.",
				ResolutionDescription -> "Automatically set from BlankGradient option or implicitly determined from BlankGradientA, BlankGradientC, and BlankGradientD options such that composition of BufferA, B, C, and D sums up to 100 Percent throughout the gradient.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Quantity,
						Pattern :> RangeP[0 Percent, 100 Percent],
						Units -> Percent
					],
					Adder[
						{
							"Time" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Minute, 4320 Minute],
								Units -> {Minute, {Second, Minute}}
							],
							"Buffer B Composition" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Percent, 100 Percent],
								Units -> Percent
							]
						},
						Orientation -> Vertical
					]
				],
				Category -> "Blanks"
			},
			{
				OptionName -> BlankGradientC,
				Default -> Automatic,
				Description -> "The composition of Buffer C within the flow for Blank samples, defined for specific time points. The composition is linearly interpolated for the intervening periods between the defined time points. For example for BlankGradientC->{{0 Minute, 0 Percent},{30 Minute, 100 Percent}}, the percentage of BufferC in the flow will rise such that at 15 minutes, the composition should be 50*Percent.",
				ResolutionDescription -> "Automatically set from BlankGradient option or implicitly determined from BlankGradientA, BlankGradientB, and BlankGradientD options such that composition of BufferA, B, C, and D sums up to 100 Percent throughout the gradient.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Quantity,
						Pattern :> RangeP[0 Percent, 100 Percent],
						Units -> Percent
					],
					Adder[
						{
							"Time" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Minute, 4320 Minute],
								Units -> {Minute, {Second, Minute}}
							],
							"Buffer C Composition" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Percent, 100 Percent],
								Units -> Percent
							]
						},
						Orientation -> Vertical
					]
				],
				Category -> "Blanks"
			},
			{
				OptionName -> BlankGradientD,
				Default -> Automatic,
				Description -> "The composition of Buffer D within the flow for Blank samples, defined for specific time points. The composition is linearly interpolated for the intervening periods between the defined time points. For example for BlankGradientD->{{0 Minute, 0 Percent},{30 Minute, 100 Percent}}, the percentage of BufferD in the flow will rise such that at 15 minutes, the composition should be 50*Percent.",
				ResolutionDescription -> "Automatically set from BlankGradient option or implicitly determined from BlankGradientA, BlankGradientB, and BlankGradientC options such that composition of BufferA, B, C, and D sums up to 100 Percent throughout the gradient.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Quantity,
						Pattern :> RangeP[0 Percent, 100 Percent],
						Units -> Percent
					],
					Adder[
						{
							"Time" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Minute, 4320 Minute],
								Units -> {Minute, {Second, Minute}}
							],
							"Buffer D Composition" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Percent, 100 Percent],
								Units -> Percent
							]
						},
						Orientation -> Vertical
					]
				],
				Category -> "Blanks"
			},
			{
				OptionName -> BlankFlowRate,
				Default -> Automatic,
				Description -> "The speed of the fluid through the system for Blank samples.",
				ResolutionDescription -> "Automatically set from Column, and FlowRate specified in the InjectionTable or taken from the method given in the BlankGradient option. If neither option is specified, the first value of FlowRate will be used",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Quantity,
						Pattern :> RangeP[0 Milliliter / Minute, 10 Milliliter / Minute],
						Units -> CompoundUnit[
							{1, {Milliliter, {Milliliter, Liter}}},
							{-1, {Minute, {Minute, Second}}}
						]
					],
					Adder[
						{
							"Time" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Minute, 4320 Minute],
								Units -> {Minute, {Second, Minute}}
							],
							"Flow Rate" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Milliliter / Minute, 15 Milliliter / Minute],
								Units -> CompoundUnit[
									{1, {Milliliter, {Milliliter, Liter}}},
									{-1, {Minute, {Minute, Second}}}
								]
							]
						},
						Orientation -> Vertical
					]
				],
				Category -> "Blanks"
			},
			{
				OptionName -> BlankGradientStart,
				Default -> Null,
				Description -> "A shorthand option to specify the starting BufferB concentration in the fluid flow of the instrument for Blank samples.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Percent, 100 Percent],
					Units -> Percent
				],
				Category -> "Blanks"
			},
			{
				OptionName -> BlankGradientEnd,
				Default -> Null,
				Description -> "A shorthand option to specify the final BufferB concentration in the fluid flow of the instrument for Blank samples.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Percent, 100 Percent],
					Units -> Percent
				],
				Category -> "Blanks"
			},
			{
				OptionName -> BlankGradientDuration,
				Default -> Null,
				Description -> "A shorthand option to specify the total time it takes to run the Blank gradient.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Minute, 4320 Minute],
					Units -> {Minute, {Minute, Second}}
				],
				Category -> "Blanks"
			},
			{
				OptionName -> BlankGradient,
				Default -> Automatic,
				Description -> "The buffer composition over time in the fluid flow for Blank samples. Specific parameters of an object can be overridden by specific options for BlankGradientA, BlankGradientB, BlankGradientC, and BlankGradientD.",
				ResolutionDescription -> "Automatically set to match all specified options related to BlankGradient (e.g. BlankGradientA, BlankGradientB, BlankGradientC, BlankGradientD, BlankFlowRate, and BlankGradientDuration).",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Object,
						Pattern :> ObjectP[Object[Method, Gradient]]
					],
					Adder[
						{
							"Time" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Minute, 4320 Minute],
								Units -> {Minute, {Second, Minute}}
							],
							"Buffer A Composition" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Percent, 100 Percent],
								Units -> Percent
							],
							"Buffer B Composition" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Percent, 100 Percent],
								Units -> Percent
							],
							"Buffer C Composition" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Percent, 100 Percent],
								Units -> Percent
							],
							"Buffer D Composition" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Percent, 100 Percent],
								Units -> Percent
							],
							"Flow Rate" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Milliliter / Minute, 10 Milliliter / Minute],
								Units -> CompoundUnit[
									{1, {Milliliter, {Milliliter, Liter}}},
									{-1, {Minute, {Minute, Second}}}
								]
							]
						},
						Orientation -> Vertical
					]
				],
				Category -> "Blanks"
			},

			(* - UV detection options - *)
			{
				OptionName -> BlankAbsorbanceWavelength,
				Default -> Automatic,
				Description -> "The physical properties of light passed through the flow for the UVVis Detector during Blank sample runs. Up to 4 separate wavelengths may be specified.",
				ResolutionDescription -> "Automatically set to 280 Nanometer if the UVVis detector is used in the protocol.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Quantity,
						Pattern :> RangeP[190 Nanometer, 900 Nanometer],
						Units -> Nanometer
					],
					Adder[
						Widget[
							Type -> Quantity,
							Pattern :> RangeP[190 Nanometer, 900 Nanometer],
							Units -> Nanometer
						]
					]
				],
				Category -> "Blanks"
			},
			{
				OptionName -> BlankAbsorbanceSamplingRate,
				Default -> Automatic,
				Description -> "Indicates the frequency of absorbance measurement for Blank samples. Lower values will be less susceptible to noise but will record less frequently across time.",
				ResolutionDescription -> "Automatically set based on the number of wavelengths specified. Default BlankAbsorbanceSamplingRate is 10/Second for measurement at a single wavelength and 1/Second for measurements at multiple wavelengths.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Quantity,
					Pattern :> RangeP[0.2 / Second, 100 / Second],
					Units -> 1 / Second
				],
				Category -> "Blanks"
			},

			(* - Electrochemical detection options - *)
			{
				OptionName -> BlankElectrochemicalDetectionMode,
				Default -> Automatic,
				Description -> "Specifies the mode of operation for the electrochemical detector during Blank sample runs, including DC Amperometric Detection, Pulsed Amperometric Detection, and Integrated Pulsed Amperometric Detection. In DC Amperometric Detection, a constant voltage is applied. In contrast, Pulsed Amperometric Detections first apply a working potential followed by higher or lower potentials that are used for cleaning the electrode. Further, Integrated Amperometric Detection integrates current over a single potential whereas Integrated Pulsed Amperometric Detection integrates current over two or more potentials.",
				ResolutionDescription -> "Automatically set based on the BlankVoltageProfile or the BlankWaveformProfile specified. If neither option is specified, this option defaults to Pulsed Amperometric Detection.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Enumeration,
					Pattern :> ElectrochemicalDetectionModeP
				],
				Category -> "Blanks"
			},
			{
				OptionName -> BlankReferenceElectrodeMode,
				Default -> Automatic,
				Description -> "A combination pH-Ag/AgCl reference electrode that can be used to either monitor the buffer pH (\"pH\" reference) or to serve as a cell reference electrode with a constant potential (\"AgCl\" reference).",
				ResolutionDescription -> "Automatically set from Waveform method object. If Waveform is not specified, this option defaults to AgCl.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Enumeration,
					Pattern :> ReferenceElectrodeModeP
				],
				Category -> "Blanks"
			},
			{
				OptionName -> BlankVoltageProfile,
				Default -> Automatic,
				Description -> "The time-dependent voltage setting throughout the measurement for Blank samples.",
				ResolutionDescription -> "Automatically set to 0.1 Volt for DCAmperometricDetection. If any other BlankElectrochemicalDetectionMode is used, this option will set to Null.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Quantity,
						Pattern :> RangeP[-2.048 Volt, 2.047 Volt],
						Units -> Volt
					],
					Adder[
						{
							"Time" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Minute, 4320 Minute],
								Units -> {Minute, {Second, Minute}}
							],
							"Voltage" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[-2.048 Volt, 2.047 Volt],
								Units -> {Volt, {Volt, Milli * Volt}}
							]
						},
						Orientation -> Vertical
					]
				],
				Category -> "Blanks"
			},
			{
				OptionName -> BlankWaveformProfile,
				Default -> Automatic,
				Description -> "A series of time-dependent voltage setting (waveform) that will be repeated over the duration of the Blank sample analysis.",
				ResolutionDescription -> "Automatically set to repeat a single waveform defined for either Pulsed Amperometric Detection or Integrated Pulsed Amperometric Detection over the entire run.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Object,
						Pattern :> ObjectP[Object[Method, Waveform]]
					],
					Adder[
						{
							"Waveform Time" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Second, 2 Second],
								Units -> Second
							],
							"Voltage" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[-2.048 Volt, 2.047 Volt],
								Units -> Volt
							],
							"Interpolation" -> Widget[
								Type -> Enumeration,
								Pattern :> BooleanP
							],
							"Integration" -> Widget[
								Type -> Enumeration,
								Pattern :> BooleanP
							]
						},
						Orientation -> Vertical
					],
					Adder[
						{
							"Time" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Minute, 4320 Minute],
								Units -> {Minute, {Second, Minute}}
							],
							"Waveform" -> Widget[
								Type -> Object,
								Pattern :> ObjectP[Object[Method, Waveform]]
							]
						},
						Orientation -> Vertical
					],
					Adder[
						{
							"Time" -> Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Minute, 4320 Minute],
								Units -> {Minute, {Second, Minute}}
							],
							"Waveform" -> Adder[
								{
									"Waveform Time" -> Widget[
										Type -> Quantity,
										Pattern :> RangeP[0 Second, 2 Second],
										Units -> Second
									],
									"Voltage" -> Widget[
										Type -> Quantity,
										Pattern :> RangeP[-2.048 Volt, 2.047 Volt],
										Units -> Volt
									],
									"Interpolation" -> Widget[
										Type -> Enumeration,
										Pattern :> BooleanP
									],
									"Integration" -> Widget[
										Type -> Enumeration,
										Pattern :> BooleanP
									]
								},
								Orientation -> Vertical
							]
						},
						Orientation -> Vertical
					]
				],
				Category -> "Blanks"
			},
			{
				OptionName -> BlankElectrochemicalSamplingRate,
				Default -> Automatic,
				Description -> "Indicates the frequency of amperometric measurement. Lower values will be less susceptible to noise but will record less frequently across time.",
				ResolutionDescription -> "Automatically set to 1/waveform duration if a single waveform is specified. If multiple waveforms are specified, this option is set to 1 over the longest waveform duration. If no waveform is specified, this option is set to 2/Second.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Quantity,
					Pattern :> RangeP[0.2 / Second, 100 / Second],
					Units -> 1 / Second
				],
				Category -> "Blanks"
			},
			{
				OptionName -> BlankDetectionTemperature,
				Default -> Automatic,
				Description -> "The temperature of the detection oven where the eletrochemical detection takes place.",
				ResolutionDescription -> "This option will automatically be set to Ambient if electrochemical detector is used and Null if not.",
				AllowNull -> True,
				Widget -> Alternatives[
					Widget[
						Type -> Quantity,
						Pattern :> RangeP[15 Celsius, 35 Celsius],
						Units -> Celsius
					],
					Widget[
						Type -> Enumeration,
						Pattern :> Alternatives[Ambient]
					]
				],
				Category -> "Blanks"
			}
		],

		(* --- Column Prime Category --- *)

		(* ================================================ *)
		(* === Double channel ICS 6000 Specific Options === *)
		(* ================================================ *)

		{
			OptionName -> AnionColumnRefreshFrequency,
			Default -> Automatic,
			Description -> "Specify the frequency at which procedures to clear out and re-prime the AnionColumn will be inserted into the order of sample injections. If specified to a number, indicates how often the anion column prime runs will run among the samples; for example, if 5 input samples are measured and AnionColumnRefreshFrequency is 2, then a column prime will occur after the first two samples and again after the third and fourth.",
			ResolutionDescription -> "Set to Null when AnionInjectionTable option is specified (meaning that this option is inconsequential); otherwise, set to FirstAndLast (meaning initial anion column prime before the measurements and final anion column flush after measurements).",
			AllowNull -> True,
			Widget -> Alternatives[
				Widget[
					Type -> Enumeration,
					Pattern :> None | FirstAndLast | GradientChange
				],
				Widget[
					Type -> Number,
					Pattern :> GreaterEqualP[0, 1]
				]
			],
			Category -> "ColumnPrime"
		},
		{
			OptionName -> AnionColumnPrimeTemperature,
			Default -> Automatic,
			Description -> "The temperature the AnionColumn is held to throughout the anion column prime gradient.",
			ResolutionDescription -> "Automatically set from AnionColumnTemperature or taken from the AnionColumnPrimeGradient option.",
			AllowNull -> True,
			Widget -> Alternatives[
				Widget[
					Type -> Quantity,
					Pattern :> RangeP[10 Celsius, 70 Celsius],
					Units -> Celsius
				],
				Widget[
					Type -> Enumeration,
					Pattern :> Alternatives[Ambient]
				]
			],
			Category -> "ColumnPrime"
		},
		{
			OptionName -> ColumnPrimeEluentGradient,
			Default -> Automatic,
			Description -> "The concentration of eluent, potassium hydroxide, that is automatically generated within the flow during AnionColumn Prime, defined for specific time points. Eluent is automatically generated in the flow path via electrolysis of deionized water. The composition is linearly interpolated for the intervening periods between the defined time points. For example for ColumnPrimeEluentGradient->{{0 Minute, 0 Millimolar},{30 Minute, 100 Millimolar}}, the eluent concentration in the flow will rise such that at 15 minutes, the concentration should be 50 Millimolar. Since eluent generator is only integrated in anion channel, this option is not applicable to cation column prime. Gradient for cation column prime can be set in CationColumnPrimeGradientA, CationColumnPrimeGradientB, CationColumnPrimeGradientC, CationColumnPrimeGradientD, and CationColumnPrimeGradient options.",
			ResolutionDescription -> "Automatically set from AnionColumnPrimeGradient option.",
			AllowNull -> True,
			Widget -> Alternatives[
				Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Millimolar, 100 Millimolar],
					Units -> Millimolar
				],
				Adder[
					{
						"Time" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Minute, 4320 Minute],
							Units -> {Minute, {Second, Minute}}
						],
						"Eluent Concentration" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Millimolar, 100 Millimolar],
							Units -> Millimolar
						]
					},
					Orientation -> Vertical
				]
			],
			Category -> "ColumnPrime"
		},
		{
			OptionName -> AnionColumnPrimeFlowRate,
			Default -> Automatic,
			Description -> "The speed of the fluid through the system during anion column prime.",
			ResolutionDescription -> "Automatically set from AnionColumn and FlowRate specified in the AnionInjectionTable or taken from the method given in the AnionColumnPrimeGradient option.",
			AllowNull -> True,
			Widget -> Alternatives[
				Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Milliliter / Minute, 10 Milliliter / Minute],
					Units -> CompoundUnit[
						{1, {Milliliter, {Milliliter, Liter}}},
						{-1, {Minute, {Minute, Second}}}
					]
				],
				Adder[
					{
						"Time" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Minute, 4320 Minute],
							Units -> {Minute, {Second, Minute}}
						],
						"Flow Rate" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Milliliter / Minute, 10 Milliliter / Minute],
							Units -> CompoundUnit[
								{1, {Milliliter, {Milliliter, Liter}}},
								{-1, {Minute, {Minute, Second}}}
							]
						]
					},
					Orientation -> Vertical
				]
			],
			Category -> "ColumnPrime"
		},
		{
			OptionName -> AnionColumnPrimeStart,
			Default -> Null,
			Description -> "A shorthand option to specify the starting eluent concentration in the fluid flow of the instrument for anion column prime.",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Quantity,
				Pattern :> RangeP[0 Millimolar, 100 Millimolar],
				Units -> Millimolar
			],
			Category -> "ColumnPrime"
		},
		{
			OptionName -> AnionColumnPrimeEnd,
			Default -> Null,
			Description -> "A shorthand option to specify the final eluent concentration in the fluid flow of the instrument for anion column prime.",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Quantity,
				Pattern :> RangeP[0 Millimolar, 100 Millimolar],
				Units -> Millimolar
			],
			Category -> "ColumnPrime"
		},
		{
			OptionName -> AnionColumnPrimeDuration,
			Default -> Null,
			Description -> "A shorthand option to specify the total time it takes to run the anion column prime gradient.",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Quantity,
				Pattern :> RangeP[0 Minute, 4320 Minute],
				Units -> {Minute, {Minute, Second}}
			],
			Category -> "ColumnPrime"
		},
		{
			OptionName -> AnionColumnPrimeGradient,
			Default -> Automatic,
			Description -> "The concentration of the eluent, potassium hydroxide, over time in the fluid flow for anion channel during anion column prime. Specific parameters of an object can be overridden by specific options for ColumnPrimeEluentGradient.",
			ResolutionDescription -> "Automatically set to match all specified options related to AnionColumnPrimeGradient (e.g. ColumnPrimeEluentGradient, AnionColumnPrimeGradientDuration, AnionColumnPrimeFlowRate). If none of the options is specified, the following default column prime gradient will be use: {{0 Minute, 100 Millimolar, 0.5 Milliliter/Minute}, {5 Minute, 100 Millimolar, 0.5 Milliliter/Minute}}.",
			AllowNull -> True,
			Widget -> Alternatives[
				Widget[
					Type -> Object,
					Pattern :> ObjectP[Object[Method, IonChromatographyGradient]]
				],
				Adder[
					{
						"Time" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Minute, 4320 Minute],
							Units -> {Minute, {Second, Minute}}
						],
						"Eluent Concentration" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Millimolar, 100 Millimolar],
							Units -> Millimolar
						],
						"Flow Rate" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Milliliter / Minute, 10 Milliliter / Minute],
							Units -> CompoundUnit[
								{1, {Milliliter, {Milliliter, Liter}}},
								{-1, {Minute, {Minute, Second}}}
							]
						]
					},
					Orientation -> Vertical
				]
			],
			Category -> "ColumnPrime"
		},
		{
			OptionName -> AnionColumnPrimeSuppressorMode,
			Default -> Automatic,
			Description -> "The operation method of the AnionSuppressor during column prime. Under DynamicMode, constant voltage is supplied to the suppressor with variable current while under LegacyMode, constant current is supplied.",
			ResolutionDescription -> "This option will be set to DynamicMode if SuppressorVoltage is specified or LegacyMode if SuppressorCurrent is specified. If none of the suppressor related options are set, this option will automatically be set to LegacyMode.",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Enumeration,
				Pattern :> SuppressorModeP
			],
			Category -> "Hidden"
		},
		{
			OptionName -> AnionColumnPrimeSuppressorVoltage,
			Default -> Null,
			Description -> "The electrical potential difference applied to the AnionSuppressor during column prime. This option is set to the factory recommended voltage of the suppressor unless otherwise specified.",
			ResolutionDescription -> "This option will be set to Null if AnionColumnPrimeSuppressorMode is LegacyMode or Null. Otherwise, this option will be set to the factory recommended voltage of the suppressor.",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Quantity,
				Pattern :> RangeP[0 * Volt, 10 * Volt],
				Units -> Volt
			],
			Category -> "Hidden"
		},
		{
			OptionName -> AnionColumnPrimeSuppressorCurrent,
			Default -> Automatic,
			Description -> "The electrical current supplied to the AnionSuppressor module during anion column prime.",
			ResolutionDescription -> "This option will be calculated by multiplying flow rate, maximum eluent concentration and suppressor specific factor (2.47 for anion suppressor).",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Quantity,
				Pattern :> RangeP[0 Milliampere, 150 Milliampere],
				Units -> Milliampere
			],
			Category -> "ColumnPrime"
		},
		{
			OptionName -> AnionColumnPrimeDetectionTemperature,
			Default -> Automatic,
			Description -> "The temperature of the oven where conductivity is measured during anion column prime.",
			ResolutionDescription -> "Automatically set to the first value of the AnionDetectionTemperature.",
			AllowNull -> True,
			Widget -> Alternatives[
				Widget[
					Type -> Quantity,
					Pattern :> RangeP[15 Celsius, 35 Celsius],
					Units -> Celsius
				],
				Widget[
					Type -> Enumeration,
					Pattern :> Alternatives[Ambient]
				]
			],
			Category -> "ColumnPrime"
		},
		{
			OptionName -> CationColumnRefreshFrequency,
			Default -> Automatic,
			Description -> "Specify the frequency at which procedures to clear out and re-prime the CationColumn will be inserted into the order of sample injections. If specified to a number, indicates how often the cation column prime runs will run among the samples; for example, if 5 input samples are measured and CationColumnRefreshFrequency is 2, then a column prime will occur after the first two samples and again after the third and fourth.",
			ResolutionDescription -> "Set to Null when CationInjectionTable option is specified (meaning that this option is inconsequential); otherwise, set to FirstAndLast (meaning initial cation column prime before the measurements and final column flush after measurements).",
			AllowNull -> True,
			Widget -> Alternatives[
				Widget[
					Type -> Enumeration,
					Pattern :> None | FirstAndLast | GradientChange
				],
				Widget[
					Type -> Number,
					Pattern :> GreaterP[0, 1]
				]
			],
			Category -> "ColumnPrime"
		},
		{
			OptionName -> CationColumnPrimeTemperature,
			Default -> Automatic,
			Description -> "The temperature the CationColumn is held to throughout the cation column prime gradient.",
			ResolutionDescription -> "Automatically set from CationColumnTemperature or taken from the CationColumnPrimeGradient option.",
			AllowNull -> True,
			Widget -> Alternatives[
				Widget[
					Type -> Quantity,
					Pattern :> RangeP[10 Celsius, 70 Celsius],
					Units -> Celsius
				],
				Widget[
					Type -> Enumeration,
					Pattern :> Alternatives[Ambient]
				]
			],
			Category -> "ColumnPrime"
		},
		{
			OptionName -> CationColumnPrimeGradientA,
			Default -> Automatic,
			Description -> "The composition of Buffer A within the flow during Column Prime, defined for specific time points. The composition is linearly interpolated for the intervening periods between the defined time points. For example for CationColumnPrimeGradientA->{{0 Minute, 0 Percent},{30 Minute, 100 Percent}}, the percentage of Buffer A in the flow will rise such that at 15 minutes, the composition should be 50*Percent. Since BufferA is only pumped into cation channel, this option is not applicable to anion column prime. Gradient for anion column prime can be set in ColumnPrimeEluentGradient and AnionColumnPrimeGradient options.",
			ResolutionDescription -> "Automatically set from CationColumnPrimeGradient option or implicitly determined from CationColumnPrimeGradientB, CationColumnPrimeGradientC, and CationColumnPrimeGradientD options such that composition of BufferA, B, C, and D sums up to 100 Percent throughout the gradient.",
			AllowNull -> True,
			Widget -> Alternatives[
				Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Percent, 100 Percent],
					Units -> Percent
				],
				Adder[
					{
						"Time" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Minute, 4320 Minute],
							Units -> {Minute, {Second, Minute}}
						],
						"Buffer A Composition" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Percent, 100 Percent],
							Units -> Percent
						]
					},
					Orientation -> Vertical
				]
			],
			Category -> "ColumnPrime"
		},
		{
			OptionName -> CationColumnPrimeGradientB,
			Default -> Automatic,
			Description -> "The composition of Buffer B within the flow during Column Prime, defined for specific time points. The composition is linearly interpolated for the intervening periods between the defined time points. For example for CationColumnPrimeGradientB->{{0 Minute, 0 Percent},{30 Minute, 100 Percent}}, the percentage of Buffer B in the flow will rise such that at 15 minutes, the composition should be 50*Percent. Since BufferB is only pumped into cation channel, this option is not applicable to anion column prime. Gradient for anion column prime can be set in ColumnPrimeEluentGradient and AnionColumnPrimeGradient options.",
			ResolutionDescription -> "Automatically set from CationColumnPrimeGradient option or implicitly determined from CationColumnPrimeGradientA, CationColumnPrimeGradientC, and CationColumnPrimeGradientD options such that composition of BufferA, B, C, and D sums up to 100 Percent throughout the gradient.",
			AllowNull -> True,
			Widget -> Alternatives[
				Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Percent, 100 Percent],
					Units -> Percent
				],
				Adder[
					{
						"Time" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Minute, 4320 Minute],
							Units -> {Minute, {Second, Minute}}
						],
						"Buffer B Composition" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Percent, 100Percent],
							Units -> Percent
						]
					},
					Orientation -> Vertical
				]
			],
			Category -> "ColumnPrime"
		},
		{
			OptionName -> CationColumnPrimeGradientC,
			Default -> Automatic,
			Description -> "The composition of Buffer C within the flow during Column Prime, defined for specific time points. The composition is linearly interpolated for the intervening periods between the defined time points. For example for CationColumnPrimeGradientC->{{0 Minute, 0 Percent},{30 Minute, 100 Percent}}, the percentage of Buffer C in the flow will rise such that at 15 minutes, the composition should be 50*Percent. Since BufferC is only pumped into cation channel, this option is not applicable to anion column prime. Gradient for anion column prime can be set in ColumnPrimeEluentGradient and AnionColumnPrimeGradient options.",
			ResolutionDescription -> "Automatically set from CationColumnPrimeGradient option or implicitly determined from CationColumnPrimeGradientA, CationColumnPrimeGradientB, and CationColumnPrimeGradientD options such that composition of BufferA, B, C, and D sums up to 100 Percent throughout the gradient.",
			AllowNull -> True,
			Widget -> Alternatives[
				Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Percent, 100 Percent],
					Units -> Percent
				],
				Adder[
					{
						"Time" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Minute, 4320 Minute],
							Units -> {Minute, {Second, Minute}}
						],
						"Buffer C Composition" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Percent, 100Percent],
							Units -> Percent
						]
					},
					Orientation -> Vertical
				]
			],
			Category -> "ColumnPrime"
		},
		{
			OptionName -> CationColumnPrimeGradientD,
			Default -> Automatic,
			Description -> "The composition of Buffer D within the flow during Column Prime, defined for specific time points. The composition is linearly interpolated for the intervening periods between the defined time points. For example for CationColumnPrimeGradientD->{{0 Minute, 0 Percent},{30 Minute, 100 Percent}}, the percentage of Buffer D in the flow will rise such that at 15 minutes, the composition should be 50*Percent. Since BufferD is only pumped into cation channel, this option is not applicable to anion column prime. Gradient for anion column prime can be set in ColumnPrimeEluentGradient and AnionColumnPrimeGradient options.",
			ResolutionDescription -> "Automatically set from CationColumnPrimeGradient option or implicitly determined from CationColumnPrimeGradientA, CationColumnPrimeGradientB, and CationColumnPrimeGradientC options such that composition of BufferA, B, C, and D sums up to 100 Percent throughout the gradient.",
			AllowNull -> True,
			Widget -> Alternatives[
				Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Percent, 100 Percent],
					Units -> Percent
				],
				Adder[
					{
						"Time" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Minute, 4320 Minute],
							Units -> {Minute, {Second, Minute}}
						],
						"Buffer D Composition" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Percent, 100Percent],
							Units -> Percent
						]
					},
					Orientation -> Vertical
				]
			],
			Category -> "ColumnPrime"
		},
		{
			OptionName -> CationColumnPrimeFlowRate,
			Default -> Automatic,
			Description -> "The speed of the fluid through the system during cation column prime.",
			ResolutionDescription -> "Automatically set from CationColumn and FlowRate specified in the CationInjectionTable or taken from the method given in the CationColumnPrimeGradient option.",
			AllowNull -> True,
			Widget -> Alternatives[
				Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Milliliter / Minute, 10 Milliliter / Minute],
					Units -> CompoundUnit[
						{1, {Milliliter, {Milliliter, Liter}}},
						{-1, {Minute, {Minute, Second}}}
					]
				],
				Adder[
					{
						"Time" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Minute, 4320 Minute],
							Units -> {Minute, {Second, Minute}}
						],
						"Flow Rate" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Milliliter / Minute, 10 Milliliter / Minute],
							Units -> CompoundUnit[
								{1, {Milliliter, {Milliliter, Liter}}},
								{-1, {Minute, {Minute, Second}}}
							]
						]
					},
					Orientation -> Vertical
				]
			],
			Category -> "ColumnPrime"
		},
		{
			OptionName -> CationColumnPrimeStart,
			Default -> Null,
			Description -> "A shorthand option to specify the starting buffer B concentration in the fluid flow of the instrument for cation column prime.",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Quantity,
				Pattern :> RangeP[0 Percent, 100 Percent],
				Units -> Percent
			],
			Category -> "ColumnPrime"
		},
		{
			OptionName -> CationColumnPrimeEnd,
			Default -> Null,
			Description -> "A shorthand option to specify the final buffer B concentration in the fluid flow of the instrument for cation column prime.",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Quantity,
				Pattern :> RangeP[0 Percent, 100 Percent],
				Units -> Percent
			],
			Category -> "ColumnPrime"
		},
		{
			OptionName -> CationColumnPrimeDuration,
			Default -> Null,
			Description -> "A shorthand option to specify the total time it takes to run the cation column prime gradient.",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Quantity,
				Pattern :> RangeP[0 Minute, 4320 Minute],
				Units -> {Minute, {Minute, Second}}
			],
			Category -> "ColumnPrime"
		},
		{
			OptionName -> CationColumnPrimeGradient,
			Default -> Automatic,
			Description -> "The buffer composition over time in the fluid flow during cation column prime. Specific parameters of an object can be overridden by specific options for CationColumnPrimeGradientA, CationColumnPrimeGradientB, CationColumnPrimeGradientC, and CationColumnPrimeGradientD.",
			ResolutionDescription -> "Automatically set to match all specified options related to CationColumnPrimeGradient (e.g. CationColumnPrimeGradientA, CationColumnPrimeGradientB, CationColumnPrimeGradientC, CationColumnPrimeGradientD, CationColumnPrimeGradientDuration, CationColumnPrimeFlowRate). If none of the options is specified, the following default column prime gradient will be used: {{0 Minute, 0 Percent, 0 Percent, 0 Percent, 100 Percent, 0.5 Milliliter/Minute}, {5 Minute, 0 Percent, 0 Percent, 0 Percent, 100 Percent, 0.5 Milliliter/Minute}, {5.1 Minute, 0 Percent, 0 Percent, 100 Percent, 0 Percent, 0.5 Milliliter/Minute}, {10 Minute, 0 Percent, 0 Percent, 100 Percent, 0 Percent, 0.5 Milliliter/Minute}, {10.1 Minute, 0 Percent, 100 Percent, 0 Percent, 0 Percent, 0.5 Milliliter/Minute}, {15 Minute, 0 Percent, 100 Percent, 0 Percent, 0 Percent, 0.5 Milliliter/Minute}, {15.1 Minute, 100 Percent, 0 Percent, 0 Percent, 0 Percent, 0.5 Milliliter/Minute}, {20 Minute, 100 Percent, 0 Percent, 0 Percent, 0 Percent, 0.5 Milliliter/Minute}}.",
			AllowNull -> True,
			Widget -> Alternatives[
				Widget[
					Type -> Object,
					Pattern :> ObjectP[Object[Method, IonChromatographyGradient]]
				],
				Adder[
					{
						"Time" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Minute, 4320 Minute],
							Units -> {Minute, {Second, Minute}}
						],
						"Buffer A Composition" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Percent, 100 Percent],
							Units -> Percent
						],
						"Buffer B Composition" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Percent, 100 Percent],
							Units -> Percent
						],
						"Buffer C Composition" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Percent, 100 Percent],
							Units -> Percent
						],
						"Buffer D Composition" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Percent, 100 Percent],
							Units -> Percent
						],
						"Flow Rate" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Milliliter / Minute, 10 Milliliter / Minute],
							Units -> CompoundUnit[
								{1, {Milliliter, {Milliliter, Liter}}},
								{-1, {Minute, {Minute, Second}}}
							]
						]
					},
					Orientation -> Vertical
				]
			],
			Category -> "ColumnPrime"
		},
		{
			OptionName -> CationColumnPrimeSuppressorMode,
			Default -> Automatic,
			Description -> "The operation method of the CationSuppressor during column prime. Under DynamicMode, constant voltage is supplied to the suppressor with variable current while under LegacyMode, constant current is supplied.",
			ResolutionDescription -> "This option will be set to DynamicMode if SuppressorVoltage is specified or LegacyMode if SuppressorCurrent is specified. If none of the suppressor related options are set, this option will automatically be set to LegacyMode.",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Enumeration,
				Pattern :> SuppressorModeP
			],
			Category -> "Hidden"
		},
		{
			OptionName -> CationColumnPrimeSuppressorVoltage,
			Default -> Null,
			Description -> "The electrical potential difference applied to the CationSuppressor during column prime. This option is set to the factory recommended voltage of the suppressor unless otherwise specified.",
			ResolutionDescription -> "This option will be set to Null if CationSuppressorMode is LegacyMode or Null. Otherwise, this option will be set to the factory recommended voltage of the suppressor.",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Quantity,
				Pattern :> RangeP[0 * Volt, 10 * Volt],
				Units -> Volt
			],
			Category -> "Hidden"
		},
		{
			OptionName -> CationColumnPrimeSuppressorCurrent,
			Default -> Automatic,
			Description -> "The electrical current supplied to the suppressor module in cation channel during cation column prime.",
			ResolutionDescription -> "This option will be calculated by multiplying flow rate, maximum buffer concentration and suppressor specific factor (2.94 for cation suppressor).",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Quantity,
				Pattern :> RangeP[0 Milliampere, 150 Milliampere],
				Units -> Milliampere
			],
			Category -> "ColumnPrime"
		},
		{
			OptionName -> CationColumnPrimeDetectionTemperature,
			Default -> Automatic,
			Description -> "The temperature of the oven where conductivity is measured during cation column prime.",
			ResolutionDescription -> "Automatically set to the first value of the CationDetectionTemperature.",
			AllowNull -> True,
			Widget -> Alternatives[
				Widget[
					Type -> Quantity,
					Pattern :> RangeP[15 Celsius, 35 Celsius],
					Units -> Celsius
				],
				Widget[
					Type -> Enumeration,
					Pattern :> Alternatives[Ambient]
				]
			],
			Category -> "ColumnPrime"
		},


		(* ================================================ *)
		(* === Single channel ICS 6000 Specific Options === *)
		(* ================================================ *)

		{
			OptionName -> ColumnRefreshFrequency,
			Default -> Automatic,
			Description -> "Specify the frequency at which procedures to clear out and re-prime the Column will be inserted into the order of sample injections. If specified to a number, indicates how often the anion column prime runs will run among the samples; for example, if 5 input samples are measured and ColumnRefreshFrequency is 2, then a column prime will occur after the first two samples and again after the third and fourth.",
			ResolutionDescription -> "Automatically set to FirstAndLast when any Blank option is specified.",
			AllowNull -> True,
			Widget -> Alternatives[
				Widget[
					Type -> Enumeration,
					Pattern :> None | First | Last | FirstAndLast | GradientChange
				],
				Widget[
					Type -> Number,
					Pattern :> GreaterP[0, 1]
				]
			],
			Category -> "ColumnPrime"
		},
		{
			OptionName -> ColumnPrimeTemperature,
			Default -> Automatic,
			Description -> "The temperature the Column is held to throughout the column prime run.",
			ResolutionDescription -> "Automatically set from ColumnTemperature or taken from the ColumnPrimeGradient option.",
			AllowNull -> True,
			Widget -> Alternatives[
				Widget[
					Type -> Quantity,
					Pattern :> RangeP[10 Celsius, 70 Celsius],
					Units -> Celsius
				],
				Widget[
					Type -> Enumeration,
					Pattern :> Alternatives[Ambient]
				]
			],
			Category -> "ColumnPrime"
		},
		{
			OptionName -> ColumnPrimeGradientA,
			Default -> Automatic,
			Description -> "The composition of Buffer A within the flow during column prime, defined for specific time points. The composition is linearly interpolated for the intervening periods between the defined time points. For example for ColumnPrimeGradientA->{{0 Minute, 0 Percent},{30 Minute, 100 Percent}}, the percentage of BufferA in the flow will rise such that at 15 minutes, the composition should be 50*Percent.",
			ResolutionDescription -> "Automatically set from ColumnPrimeGradient option or implicitly determined from ColumnPrimeGradientB, ColumnPrimeGradientC, and ColumnPrimeGradientD options such that composition of BufferA, B, C, and D sums up to 100 Percent throughout the gradient.",
			AllowNull -> True,
			Widget -> Alternatives[
				Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Percent, 100 Percent],
					Units -> Percent
				],
				Adder[
					{
						"Time" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Minute, 4320 Minute],
							Units -> {Minute, {Second, Minute}}
						],
						"Buffer A Composition" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Percent, 100 Percent],
							Units -> Percent
						]
					},
					Orientation -> Vertical
				]
			],
			Category -> "ColumnPrime"
		},
		{
			OptionName -> ColumnPrimeGradientB,
			Default -> Automatic,
			Description -> "The composition of Buffer B within the flow during column prime, defined for specific time points. The composition is linearly interpolated for the intervening periods between the defined time points. For example for ColumnPrimeGradientB->{{0 Minute, 0 Percent},{30 Minute, 100 Percent}}, the percentage of BufferB in the flow will rise such that at 15 minutes, the composition should be 50*Percent.",
			ResolutionDescription -> "Automatically set from ColumnPrimeGradient option or implicitly determined from ColumnPrimeGradientA, ColumnPrimeGradientC, and ColumnPrimeGradientD options such that composition of BufferA, B, C, and D sums up to 100 Percent throughout the gradient.",
			AllowNull -> True,
			Widget -> Alternatives[
				Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Percent, 100 Percent],
					Units -> Percent
				],
				Adder[
					{
						"Time" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Minute, 4320 Minute],
							Units -> {Minute, {Second, Minute}}
						],
						"Buffer B Composition" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Percent, 100 Percent],
							Units -> Percent
						]
					},
					Orientation -> Vertical
				]
			],
			Category -> "ColumnPrime"
		},
		{
			OptionName -> ColumnPrimeGradientC,
			Default -> Automatic,
			Description -> "The composition of Buffer C within the flow during column prime, defined for specific time points. The composition is linearly interpolated for the intervening periods between the defined time points. For example for ColumnPrimeGradientC->{{0 Minute, 0 Percent},{30 Minute, 100 Percent}}, the percentage of BufferC in the flow will rise such that at 15 minutes, the composition should be 50*Percent.",
			ResolutionDescription -> "Automatically set from ColumnPrimeGradient option or implicitly determined from ColumnPrimeGradientA, ColumnPrimeGradientB, and ColumnPrimeGradientD options such that composition of BufferA, B, C, and D sums up to 100 Percent throughout the gradient.",
			AllowNull -> True,
			Widget -> Alternatives[
				Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Percent, 100 Percent],
					Units -> Percent
				],
				Adder[
					{
						"Time" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Minute, 4320 Minute],
							Units -> {Minute, {Second, Minute}}
						],
						"Buffer C Composition" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Percent, 100 Percent],
							Units -> Percent
						]
					},
					Orientation -> Vertical
				]
			],
			Category -> "ColumnPrime"
		},
		{
			OptionName -> ColumnPrimeGradientD,
			Default -> Automatic,
			Description -> "The composition of Buffer D within the flow during column prime, defined for specific time points. The composition is linearly interpolated for the intervening periods between the defined time points. For example for ColumnPrimeGradientD->{{0 Minute, 0 Percent},{30 Minute, 100 Percent}}, the percentage of BufferD in the flow will rise such that at 15 minutes, the composition should be 50*Percent.",
			ResolutionDescription -> "Automatically set from ColumnPrimeGradient option or implicitly determined from ColumnPrimeGradientA, ColumnPrimeGradientB, and ColumnPrimeGradientC options such that composition of BufferA, B, C, and D sums up to 100 Percent throughout the gradient.",
			AllowNull -> True,
			Widget -> Alternatives[
				Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Percent, 100 Percent],
					Units -> Percent
				],
				Adder[
					{
						"Time" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Minute, 4320 Minute],
							Units -> {Minute, {Second, Minute}}
						],
						"Buffer D Composition" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Percent, 100 Percent],
							Units -> Percent
						]
					},
					Orientation -> Vertical
				]
			],
			Category -> "ColumnPrime"
		},
		{
			OptionName -> ColumnPrimeFlowRate,
			Default -> Automatic,
			Description -> "The speed of the fluid through the system during column prime.",
			ResolutionDescription -> "Automatically set from Column, and FlowRate specified in the InjectionTable or taken from the method given in the ColumnPrimeGradient option.",
			AllowNull -> True,
			Widget -> Alternatives[
				Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Milliliter / Minute, 10 Milliliter / Minute],
					Units -> CompoundUnit[
						{1, {Milliliter, {Milliliter, Liter}}},
						{-1, {Minute, {Minute, Second}}}
					]
				],
				Adder[
					{
						"Time" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Minute, 4320 Minute],
							Units -> {Minute, {Second, Minute}}
						],
						"Flow Rate" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Milliliter / Minute, 10 Milliliter / Minute],
							Units -> CompoundUnit[
								{1, {Milliliter, {Milliliter, Liter}}},
								{-1, {Minute, {Minute, Second}}}
							]
						]
					},
					Orientation -> Vertical
				]
			],
			Category -> "ColumnPrime"
		},
		{
			OptionName -> ColumnPrimeStart,
			Default -> Null,
			Description -> "A shorthand option to specify the starting eluent concentration in the fluid flow of the instrument for column prime.",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Quantity,
				Pattern :> RangeP[0 Percent, 100 Percent],
				Units -> Percent
			],
			Category -> "ColumnPrime"
		},
		{
			OptionName -> ColumnPrimeEnd,
			Default -> Null,
			Description -> "A shorthand option to specify the final eluent concentration in the fluid flow of the instrument for column prime.",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Quantity,
				Pattern :> RangeP[0 Percent, 100 Percent],
				Units -> Percent
			],
			Category -> "ColumnPrime"
		},
		{
			OptionName -> ColumnPrimeDuration,
			Default -> Null,
			Description -> "A shorthand option to specify the total time it takes to run the column prime gradient.",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Quantity,
				Pattern :> RangeP[0 Minute, 4320 Minute],
				Units -> {Minute, {Minute, Second}}
			],
			Category -> "ColumnPrime"
		},
		{
			OptionName -> ColumnPrimeGradient,
			Default -> Automatic,
			Description -> "The buffer composition over time in the fluid flow during column prime. Specific parameters of an object can be overridden by specific options for ColumnPrimeGradientA, ColumnPrimeGradientB, ColumnPrimeGradientC, and ColumnPrimeGradientD.",
			ResolutionDescription -> "Automatically set to match all specified options related to ColumnPrimeGradient (e.g. ColumnPrimeGradientA, ColumnPrimeGradientB, ColumnPrimeGradientC, ColumnPrimeGradientD, ColumnPrimeFlowRate, and ColumnPrimeGradientDuration).",
			AllowNull -> True,
			Widget -> Alternatives[
				Widget[
					Type -> Object,
					Pattern :> ObjectP[Object[Method, Gradient]]
				],
				Adder[
					{
						"Time" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Minute, 4320 Minute],
							Units -> {Minute, {Second, Minute}}
						],
						"Buffer A Composition" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Percent, 100 Percent],
							Units -> Percent
						],
						"Buffer B Composition" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Percent, 100 Percent],
							Units -> Percent
						],
						"Buffer C Composition" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Percent, 100 Percent],
							Units -> Percent
						],
						"Buffer D Composition" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Percent, 100 Percent],
							Units -> Percent
						],
						"Flow Rate" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Milliliter / Minute, 10 Milliliter / Minute],
							Units -> CompoundUnit[
								{1, {Milliliter, {Milliliter, Liter}}},
								{-1, {Minute, {Minute, Second}}}
							]
						]
					},
					Orientation -> Vertical
				]
			],
			Category -> "ColumnPrime"
		},

		(* - UV detection options - *)
		{
			OptionName -> ColumnPrimeAbsorbanceWavelength,
			Default -> Automatic,
			Description -> "The physical properties of light passed through the flow for the UVVis Detector during ColumnPrime. Up to 4 separate wavelengths may be specified.",
			ResolutionDescription -> "Automatically set to 280*Nanometer if the UVVis detector is used in the protocol and ColumnRefreshFrequency is not set to Null or None.",
			AllowNull -> True,
			Widget -> Alternatives[
				Widget[
					Type -> Quantity,
					Pattern :> RangeP[190 Nanometer, 900 Nanometer],
					Units -> Nanometer
				],
				Adder[
					Widget[
						Type -> Quantity,
						Pattern :> RangeP[190 Nanometer, 900 Nanometer],
						Units -> Nanometer
					]
				]
			],
			Category -> "ColumnPrime"
		},
		{
			OptionName -> ColumnPrimeAbsorbanceSamplingRate,
			Default -> Automatic,
			Description -> "Indicates the frequency of absorbance measurement during ColumnPrime. Lower values will be less susceptible to noise but will record less frequently across time.",
			ResolutionDescription -> "Automatically set based on the number of wavelengths specified. Default ColumnPrimeAbsorbanceSamplingRate is 10/Second for measurement at a single wavelength and 1/Second for measurements at multiple wavelengths.",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Quantity,
				Pattern :> RangeP[0.2 / Second, 100 / Second],
				Units -> 1 / Second
			],
			Category -> "ColumnPrime"
		},

		(* - Electrochemical detection options - *)
		{
			OptionName -> ColumnPrimeElectrochemicalDetectionMode,
			Default -> Automatic,
			Description -> "Specifies the mode of operation for the electrochemical detector during ColumnPrime, including DC Amperometric Detection, Pulsed Amperometric Detection, and Integrated Pulsed Amperometric Detection. In DC Amperometric Detection, a constant voltage is applied. In contrast, Pulsed Amperometric Detections first apply a working potential followed by higher or lower potentials that are used for cleaning the electrode. Further, Integrated Amperometric Detection integrates current over a single potential whereas Integrated Pulsed Amperometric Detection integrates current over two or more potentials.",
			ResolutionDescription -> "Automatically set based on the ColumnPrimeVoltageProfile or the ColumnPrimeWaveformProfile specified. If neither option is specified, this option defaults to Pulsed Amperometric Detection.",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Enumeration,
				Pattern :> ElectrochemicalDetectionModeP
			],
			Category -> "ColumnPrime"
		},
		{
			OptionName -> ColumnPrimeReferenceElectrodeMode,
			Default -> Automatic,
			Description -> "A combination pH-Ag/AgCl reference electrode that can be used to either monitor the buffer pH (\"pH\" reference) or to serve as a cell reference electrode with a constant potential (\"AgCl\" reference).",
			ResolutionDescription -> "Automatically set from Waveform method object. If Waveform is not specified, this option defaults to AgCl.",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Enumeration,
				Pattern :> ReferenceElectrodeModeP
			],
			Category -> "ColumnPrime"
		},
		{
			OptionName -> ColumnPrimeVoltageProfile,
			Default -> Automatic,
			Description -> "The time-dependent voltage setting throughout the measurement during ColumnPrime.",
			ResolutionDescription -> "Automatically set to 0.1 Volt for DCAmperometricDetection. If any other ColumnPrimeElectrochemicalDetectionMode is used, this option will set to Null.",
			AllowNull -> True,
			Widget -> Alternatives[
				Widget[
					Type -> Quantity,
					Pattern :> RangeP[-2.048 Volt, 2.047 Volt],
					Units -> Volt
				],
				Adder[
					{
						"Time" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Minute, 4320 Minute],
							Units -> {Minute, {Second, Minute}}
						],
						"Voltage" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[-2.048 Volt, 2.047 Volt],
							Units -> {Volt, {Volt, Milli * Volt}}
						]
					},
					Orientation -> Vertical
				]
			],
			Category -> "ColumnPrime"
		},
		{
			OptionName -> ColumnPrimeWaveformProfile,
			Default -> Automatic,
			Description -> "A series of time-dependent voltage setting (waveform) that will be repeated over the duration of ColumnPrime.",
			ResolutionDescription -> "Automatically set to repeat a single waveform defined for either Pulsed Amperometric Detection or Integrated Pulsed Amperometric Detection over the entire run.",
			AllowNull -> True,
			Widget -> Alternatives[
				Widget[
					Type -> Object,
					Pattern :> ObjectP[Object[Method, Waveform]]
				],
				Adder[
					{
						"Waveform Time" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Second, 2 Second],
							Units -> Second
						],
						"Voltage" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[-2.048 Volt, 2.047 Volt],
							Units -> Volt
						],
						"Interpolation" -> Widget[
							Type -> Enumeration,
							Pattern :> BooleanP
						],
						"Integration" -> Widget[
							Type -> Enumeration,
							Pattern :> BooleanP
						]
					},
					Orientation -> Vertical
				],
				Adder[
					{
						"Time" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Minute, 4320 Minute],
							Units -> {Minute, {Second, Minute}}
						],
						"Waveform" -> Widget[
							Type -> Object,
							Pattern :> ObjectP[Object[Method, Waveform]]
						]
					},
					Orientation -> Vertical
				],
				Adder[
					{
						"Time" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Minute, 4320 Minute],
							Units -> {Minute, {Second, Minute}}
						],
						"Waveform" -> Adder[
							{
								"Waveform Time" -> Widget[
									Type -> Quantity,
									Pattern :> RangeP[0 Second, 2 Second],
									Units -> Second
								],
								"Voltage" -> Widget[
									Type -> Quantity,
									Pattern :> RangeP[-2.048 Volt, 2.047 Volt],
									Units -> Volt
								],
								"Interpolation" -> Widget[
									Type -> Enumeration,
									Pattern :> BooleanP
								],
								"Integration" -> Widget[
									Type -> Enumeration,
									Pattern :> BooleanP
								]
							},
							Orientation -> Vertical
						]
					},
					Orientation -> Vertical
				]
			],
			Category -> "ColumnPrime"
		},
		{
			OptionName -> ColumnPrimeElectrochemicalSamplingRate,
			Default -> Automatic,
			Description -> "Indicates the frequency of amperometric measurement. Lower values will be less susceptible to noise but will record less frequently across time.",
			ResolutionDescription -> "Automatically set to 1/waveform duration if a single waveform is specified. If multiple waveforms are specified, this option is set to 1 over the longest waveform duration. If no waveform is specified, this option is set to 2/Second.",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Quantity,
				Pattern :> RangeP[0.2 / Second, 100 / Second],
				Units -> 1 / Second
			],
			Category -> "ColumnPrime"
		},
		{
			OptionName -> ColumnPrimeDetectionTemperature,
			Default -> Automatic,
			Description -> "The temperature of the detection oven where the eletrochemical detection takes place.",
			ResolutionDescription -> "This option will automatically be set to Ambient if electrochemical detector is used.",
			AllowNull -> True,
			Widget -> Alternatives[
				Widget[
					Type -> Quantity,
					Pattern :> RangeP[15 Celsius, 35 Celsius],
					Units -> Celsius
				],
				Widget[
					Type -> Enumeration,
					Pattern :> Alternatives[Ambient]
				]
			],
			Category -> "ColumnPrime"
		},


		(* --- Column Flush Gradient Parameters --- *)
		{
			OptionName -> AnionColumnFlushTemperature,
			Default -> Automatic,
			Description -> "The temperature the AnionColumn is held to throughout the anion column flush gradient.",
			ResolutionDescription -> "Automatically set from AnionColumnTemperature or taken from the AnionColumnFlushGradient option.",
			AllowNull -> True,
			Widget -> Alternatives[
				Widget[
					Type -> Quantity,
					Pattern :> RangeP[10 Celsius, 70 Celsius],
					Units -> Celsius
				],
				Widget[
					Type -> Enumeration,
					Pattern :> Alternatives[Ambient]
				]
			],
			Category -> "ColumnFlush"
		},
		{
			OptionName -> ColumnFlushEluentGradient,
			Default -> Automatic,
			Description -> "The concentration of eluent, potassium hydroxide, that is automatically generated within the flow during Column Flush, defined for specific time points. Eluent is automatically generated in the flow path via electrolysis of deionized water. The composition is linearly interpolated for the intervening periods between the defined time points. For example for ColumnFlushEluentGradient->{{0 Minute, 0 Millimolar},{30 Minute, 100 Millimolar}}, the eluent concentration in the flow will rise such that at 15 minutes, the concentration should be 50 Millimolar. Since eluent generator is only integrated in anion channel, this option is not applicable to cation column flush. Gradient for cation column flush can be set in CationColumnFlushGradientA, CationColumnFlushGradientB, CationColumnFlushGradientC, CationColumnFlushGradientD, and CationColumnFlushGradient options.",
			ResolutionDescription -> "Automatically set to match all specified options related to AnionColumnFlushGradient (e.g. ColumnFlushEluentGradient, AnionColumnFlushGradientDuration, AnionColumnFlushFlowRate).",
			AllowNull -> True,
			Widget -> Alternatives[
				Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Millimolar, 100 Millimolar],
					Units -> Millimolar
				],
				Adder[
					{
						"Time" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Minute, 4320 Minute],
							Units -> {Minute, {Second, Minute}}
						],
						"Eluent Concentration" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Millimolar, 100 Millimolar],
							Units -> Millimolar
						]
					},
					Orientation -> Vertical
				]
			],
			Category -> "ColumnFlush"
		},
		{
			OptionName -> AnionColumnFlushFlowRate,
			Default -> Automatic,
			Description -> "The speed of the fluid through the system during anion column flush.",
			ResolutionDescription -> "Automatically set from AnionColumn and FlowRate specified in the AnionInjectionTable or taken from the method given in the AnionColumnFlushGradient option. If neither option is specified, the smaller flow rate between the minumum flow rate of the resolved AnionColumn and that of the resolved Instrument will be used.",
			AllowNull -> True,
			Widget -> Alternatives[
				Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Milliliter / Minute, 10 Milliliter / Minute],
					Units -> CompoundUnit[
						{1, {Milliliter, {Milliliter, Liter}}},
						{-1, {Minute, {Minute, Second}}}
					]
				],
				Adder[
					{
						"Time" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Minute, 4320 Minute],
							Units -> {Minute, {Second, Minute}}
						],
						"Flow Rate" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Milliliter / Minute, 10 Milliliter / Minute],
							Units -> CompoundUnit[
								{1, {Milliliter, {Milliliter, Liter}}},
								{-1, {Minute, {Minute, Second}}}
							]
						]
					},
					Orientation -> Vertical
				]
			],
			Category -> "ColumnFlush"
		},
		{
			OptionName -> AnionColumnFlushStart,
			Default -> Null,
			Description -> "A shorthand option to specify the starting eluent concentration in the fluid flow of the instrument for anion column flush.",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Quantity,
				Pattern :> RangeP[0 Millimolar, 100 Millimolar],
				Units -> Millimolar
			],
			Category -> "ColumnFlush"
		},
		{
			OptionName -> AnionColumnFlushEnd,
			Default -> Null,
			Description -> "A shorthand option to specify the final eluent concentration in the fluid flow of the instrument for anion column flush.",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Quantity,
				Pattern :> RangeP[0 Millimolar, 100 Millimolar],
				Units -> Millimolar
			],
			Category -> "ColumnFlush"
		},
		{
			OptionName -> AnionColumnFlushDuration,
			Default -> Null,
			Description -> "A shorthand option to specify the total time it takes to run the anion column flush gradient.",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Quantity,
				Pattern :> RangeP[0 Minute, 4320 Minute],
				Units -> {Minute, {Minute, Second}}
			],
			Category -> "ColumnFlush"
		},
		{
			OptionName -> AnionColumnFlushGradient,
			Default -> Automatic,
			Description -> "The concentration of the eluent, potassium hydroxide, over time in the fluid flow for anion channel during anion column flush. Specific parameters of an object can be overridden by specific options for ColumnFlushEluentGradient.",
			ResolutionDescription -> "Automatically set to match all specified options related to AnionColumnFlushGradient (e.g. ColumnFlushEluentGradient, AnionColumnFlushGradientDuration, AnionColumnFlushFlowRate). If none of the options is specified, the following column flush gradient will be used: {{0 Minute, 100 Millimolar, 0.5 Milliliter/Minute}, {5 Minute, 100 Millimolar, 0.5 Milliliter/Minute}}.",
			AllowNull -> True,
			Widget -> Alternatives[
				Widget[
					Type -> Object,
					Pattern :> ObjectP[Object[Method, IonChromatographyGradient]]
				],
				Adder[
					{
						"Time" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Minute, 4320 Minute],
							Units -> {Minute, {Second, Minute}}
						],
						"Eluent Concentration" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Millimolar, 100 Millimolar],
							Units -> Millimolar
						],
						"Flow Rate" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Milliliter / Minute, 10 Milliliter / Minute],
							Units -> CompoundUnit[
								{1, {Milliliter, {Milliliter, Liter}}},
								{-1, {Minute, {Minute, Second}}}
							]
						]
					},
					Orientation -> Vertical
				]
			],
			Category -> "ColumnFlush"
		},
		{
			OptionName -> AnionColumnFlushSuppressorMode,
			Default -> Automatic,
			Description -> "The operation method of the AnionSuppressor during column flush. Under DynamicMode, constant voltage is supplied to the suppressor with variable current while under LegacyMode, constant current is supplied.",
			ResolutionDescription -> "This option will be set to DynamicMode if SuppressorVoltage is specified or LegacyMode if SuppressorCurrent is specified. If none of the suppressor related options are set, this option will automatically be set to LegacyMode.",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Enumeration,
				Pattern :> SuppressorModeP
			],
			Category -> "Hidden"
		},
		{
			OptionName -> AnionColumnFlushSuppressorVoltage,
			Default -> Null,
			Description -> "The electrical potential difference applied to the AnionSuppressor during column flush. This option is set to the factory recommended voltage of the suppressor unless otherwise specified.",
			ResolutionDescription -> "This option will be set to Null if AnionSuppressorMode is LegacyMode or Null. Otherwise, this option will be set to the factory recommended voltage of the suppressor.",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Quantity,
				Pattern :> RangeP[0 * Volt, 10 * Volt],
				Units -> Volt
			],
			Category -> "Hidden"
		},
		{
			OptionName -> AnionColumnFlushSuppressorCurrent,
			Default -> Automatic,
			Description -> "The electrical current supplied to the AnionSuppressor module during anion column flush.",
			ResolutionDescription -> "This option will be calculated by multiplying flow rate, maximum eluent concentration and suppressor specific factor (2.47 for anion suppressor).",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Quantity,
				Pattern :> RangeP[0 Milliampere, 150 Milliampere],
				Units -> Milliampere
			],
			Category -> "ColumnFlush"
		},
		{
			OptionName -> AnionColumnFlushDetectionTemperature,
			Default -> Automatic,
			Description -> "The temperature of the oven where conductivity is measured during anion channel column flush.",
			ResolutionDescription -> "Automatically set to the first value of the AnionDetectionTemperature.",
			AllowNull -> True,
			Widget -> Alternatives[
				Widget[
					Type -> Quantity,
					Pattern :> RangeP[15 Celsius, 35 Celsius],
					Units -> Celsius
				],
				Widget[
					Type -> Enumeration,
					Pattern :> Alternatives[Ambient]
				]
			],
			Category -> "ColumnFlush"
		},
		{
			OptionName -> CationColumnFlushTemperature,
			Default -> Automatic,
			Description -> "The temperature the CationColumn is held to throughout the cation column flush gradient.",
			ResolutionDescription -> "Automatically set from CationColumnTemperature or taken from the CationColumnFlushGradient option.",
			AllowNull -> True,
			Widget -> Alternatives[
				Widget[
					Type -> Quantity,
					Pattern :> RangeP[10 Celsius, 70 Celsius],
					Units -> Celsius
				],
				Widget[
					Type -> Enumeration,
					Pattern :> Alternatives[Ambient]
				]
			],
			Category -> "ColumnFlush"
		},
		{
			OptionName -> CationColumnFlushGradientA,
			Default -> Automatic,
			Description -> "The composition of Buffer A within the flow during ColumnFlush, defined for specific time points. The composition is linearly interpolated for the intervening periods between the defined time points. For example for CationColumnFlushGradientA->{{0 Minute, 0 Percent},{30 Minute, 100 Percent}}, the percentage of Buffer A in the flow will rise such that at 15 minutes, the composition should be 50*Percent. Since BufferA is only pumped into cation channel, this option is not applicable to anion column flush. Gradient for anion column flush can be set in ColumnFlushEluentGradient and AnionColumnFlushGradient options.",
			ResolutionDescription -> "Automatically set from CationColumnFlushGradient option or implicitly determined from CationColumnFlushGradientB, CationColumnFlushGradientC, and CationColumnFlushGradientD options such that composition of BufferA, B, C, and D sums up to 100 Percent throughout the gradient.",
			AllowNull -> True,
			Widget -> Alternatives[
				Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Percent, 100 Percent],
					Units -> Percent
				],
				Adder[
					{
						"Time" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Minute, 4320 Minute],
							Units -> {Minute, {Second, Minute}}
						],
						"Buffer A Composition" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Percent, 100 Percent],
							Units -> Percent
						]
					},
					Orientation -> Vertical
				]
			],
			Category -> "ColumnFlush"
		},
		{
			OptionName -> CationColumnFlushGradientB,
			Default -> Automatic,
			Description -> "The composition of Buffer B within the flow during ColumnFlush, defined for specific time points. The composition is linearly interpolated for the intervening periods between the defined time points. For example for CationColumnFlushGradientB->{{0 Minute, 0 Percent},{30 Minute, 100 Percent}}, the percentage of Buffer B in the flow will rise such that at 15 minutes, the composition should be 50*Percent. Since BufferB is only pumped into cation channel, this option is not applicable to anion column flush. Gradient for anion column flush can be set in ColumnFlushEluentGradient and AnionColumnFlushGradient options.",
			ResolutionDescription -> "Automatically set from CationColumnFlushGradient option or implicitly determined from CationColumnFlushGradientA, CationColumnFlushGradientC, and CationColumnFlushGradientD options such that composition of BufferA, B, C, and D sums up to 100 Percent throughout the gradient.",
			AllowNull -> True,
			Widget -> Alternatives[
				Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Percent, 100 Percent],
					Units -> Percent
				],
				Adder[
					{
						"Time" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Minute, 4320 Minute],
							Units -> {Minute, {Second, Minute}}
						],
						"Buffer B Composition" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Percent, 100 Percent],
							Units -> Percent
						]
					},
					Orientation -> Vertical
				]
			],
			Category -> "ColumnFlush"
		},
		{
			OptionName -> CationColumnFlushGradientC,
			Default -> Automatic,
			Description -> "The composition of Buffer C within the flow during ColumnFlush, defined for specific time points. The composition is linearly interpolated for the intervening periods between the defined time points. For example for CationColumnFlushGradientC->{{0 Minute, 0 Percent},{30 Minute, 100 Percent}}, the percentage of Buffer C in the flow will rise such that at 15 minutes, the composition should be 50*Percent. Since BufferC is only pumped into cation channel, this option is not applicable to anion column flush. Gradient for anion column flush can be set in ColumnFlushEluentGradient and AnionColumnFlushGradient options.",
			ResolutionDescription -> "Automatically set from CationColumnFlushGradient option or implicitly determined from CationColumnFlushGradientA, CationColumnFlushGradientB, and CationColumnFlushGradientD options such that composition of BufferA, B, C, and D sums up to 100 Percent throughout the gradient.",
			AllowNull -> True,
			Widget -> Alternatives[
				Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Percent, 100 Percent],
					Units -> Percent
				],
				Adder[
					{
						"Time" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Minute, 4320 Minute],
							Units -> {Minute, {Second, Minute}}
						],
						"Buffer C Composition" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Percent, 100 Percent],
							Units -> Percent
						]
					},
					Orientation -> Vertical
				]
			],
			Category -> "ColumnFlush"
		},
		{
			OptionName -> CationColumnFlushGradientD,
			Default -> Automatic,
			Description -> "The composition of Buffer D within the flow during ColumnFlush, defined for specific time points. The composition is linearly interpolated for the intervening periods between the defined time points. For example for CationColumnFlushGradientD->{{0 Minute, 0 Percent},{30 Minute, 100 Percent}}, the percentage of Buffer D in the flow will rise such that at 15 minutes, the composition should be 50*Percent. Since BufferD is only pumped into cation channel, this option is not applicable to anion column flush. Gradient for anion column flush can be set in ColumnFlushEluentGradient and AnionColumnFlushGradient options.",
			ResolutionDescription -> "Automatically set from CationColumnFlushGradient option or implicitly determined from CationColumnFlushGradientA, CationColumnFlushGradientB, and CationColumnFlushGradientC options such that composition of BufferA, B, C, and D sums up to 100 Percent throughout the gradient.",
			AllowNull -> True,
			Widget -> Alternatives[
				Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Percent, 100 Percent],
					Units -> Percent
				],
				Adder[
					{
						"Time" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Minute, 4320 Minute],
							Units -> {Minute, {Second, Minute}}
						],
						"Buffer D Composition" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Percent, 100 Percent],
							Units -> Percent
						]
					},
					Orientation -> Vertical
				]
			],
			Category -> "ColumnFlush"
		},
		{
			OptionName -> CationColumnFlushFlowRate,
			Default -> Automatic,
			Description -> "The speed of the fluid through the system during cation column flush.",
			ResolutionDescription -> "Automatically set from CationColumn and FlowRate specified in the CationInjectionTable or taken from the method given in the CationColumnFlushGradient option.",
			AllowNull -> True,
			Widget -> Alternatives[
				Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Milliliter / Minute, 10 Milliliter / Minute],
					Units -> CompoundUnit[
						{1, {Milliliter, {Milliliter, Liter}}},
						{-1, {Minute, {Minute, Second}}}
					]
				],
				Adder[
					{
						"Time" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Minute, 4320 Minute],
							Units -> {Minute, {Second, Minute}}
						],
						"Flow Rate" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Milliliter / Minute, 10 Milliliter / Minute],
							Units -> CompoundUnit[
								{1, {Milliliter, {Milliliter, Liter}}},
								{-1, {Minute, {Minute, Second}}}
							]
						]
					},
					Orientation -> Vertical
				]
			],
			Category -> "ColumnFlush"
		},
		{
			OptionName -> CationColumnFlushStart,
			Default -> Null,
			Description -> "A shorthand option to specify the starting buffer B concentration in the fluid flow of the instrument for cation column flush.",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Quantity,
				Pattern :> RangeP[0 Percent, 100 Percent],
				Units -> Percent
			],
			Category -> "ColumnFlush"
		},
		{
			OptionName -> CationColumnFlushEnd,
			Default -> Null,
			Description -> "A shorthand option to specify the final buffer B concentration in the fluid flow of the instrument for cation column flush.",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Quantity,
				Pattern :> RangeP[0 Percent, 100 Percent],
				Units -> Percent
			],
			Category -> "ColumnFlush"
		},
		{
			OptionName -> CationColumnFlushDuration,
			Default -> Null,
			Description -> "A shorthand option to specify the total time it takes to run the cation column flush gradient.",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Quantity,
				Pattern :> RangeP[0 Minute, 4320 Minute],
				Units -> {Minute, {Minute, Second}}
			],
			Category -> "ColumnFlush"
		},
		{
			OptionName -> CationColumnFlushGradient,
			Default -> Automatic,
			Description -> "The buffer composition over time in the fluid flow during cation column flush. Specific parameters of an object can be overridden by specific options for CationColumnFlushGradientA, CationColumnFlushGradientB, CationColumnFlushGradientC, and CationColumnFlushGradientD.",
			ResolutionDescription -> "Automatically set to match all specified options related to CationColumnFlushGradient (e.g. CationColumnFlushGradient, CationColumnFlushGradientB, CationColumnFlushGradientC, CationColumnFlushGradientD, CationColumnFlushGradientDuration, CationColumnFlushFlowRate). If none of the options is specified, the following column flush gradient will be used: {{0 Minute, 0 Percent, 0 Percent, 0 Percent, 100 Percent, 0.5 Milliliter/Minute}, {5 Minute, 0 Percent, 0 Percent, 0 Percent, 100 Percent, 0.5 Milliliter/Minute}, {5.1 Minute, 0 Percent, 0 Percent, 100 Percent, 0 Percent, 0.5 Milliliter/Minute}, {10 Minute, 0 Percent, 0 Percent, 100 Percent, 0 Percent, 0.5 Milliliter/Minute}, {10.1 Minute, 0 Percent, 100 Percent, 0 Percent, 0 Percent, 0.5 Milliliter/Minute}, {15 Minute, 0 Percent, 100 Percent, 0 Percent, 0 Percent, 0.5 Milliliter/Minute}, {15.1 Minute, 100 Percent, 0 Percent, 0 Percent, 0 Percent, 0.5 Milliliter/Minute}, {20 Minute, 100 Percent, 0 Percent, 0 Percent, 0 Percent, 0.5 Milliliter/Minute}}.",
			AllowNull -> True,
			Widget -> Alternatives[
				Widget[
					Type -> Object,
					Pattern :> ObjectP[Object[Method, IonChromatographyGradient]]
				],
				Adder[
					{
						"Time" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Minute, 4320 Minute],
							Units -> {Minute, {Second, Minute}}
						],
						"Buffer A Composition" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Percent, 100 Percent],
							Units -> Percent
						],
						"Buffer B Composition" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Percent, 100 Percent],
							Units -> Percent
						],
						"Buffer C Composition" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Percent, 100 Percent],
							Units -> Percent
						],
						"Buffer D Composition" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Percent, 100 Percent],
							Units -> Percent
						],
						"Flow Rate" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Milliliter / Minute, 10 Milliliter / Minute],
							Units -> CompoundUnit[
								{1, {Milliliter, {Milliliter, Liter}}},
								{-1, {Minute, {Minute, Second}}}
							]
						]
					},
					Orientation -> Vertical
				]
			],
			Category -> "ColumnFlush"
		},
		{
			OptionName -> CationColumnFlushSuppressorMode,
			Default -> Automatic,
			Description -> "The operation method of the CationSuppressor during column flush. Under DynamicMode, constant voltage is supplied to the suppressor with variable current while under LegacyMode, constant current is supplied.",
			ResolutionDescription -> "This option will be set to DynamicMode if SuppressorVoltage is specified or LegacyMode if SuppressorCurrent is specified. If none of the suppressor related options are set, this option will automatically be set to LegacyMode.",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Enumeration,
				Pattern :> SuppressorModeP
			],
			Category -> "Hidden"
		},
		{
			OptionName -> CationColumnFlushSuppressorVoltage,
			Default -> Null,
			Description -> "The electrical potential difference applied to the CationSuppressor during column flush. This option is set to the factory recommended voltage of the suppressor unless otherwise specified.",
			ResolutionDescription -> "This option will be set to Null if CationColumnFlushSuppressorMode is LegacyMode or Null. Otherwise, this option will be set to the factory recommended voltage of the suppressor.",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Quantity,
				Pattern :> RangeP[0 * Volt, 10 * Volt],
				Units -> Volt
			],
			Category -> "Hidden"
		},
		{
			OptionName -> CationColumnFlushSuppressorCurrent,
			Default -> Automatic,
			Description -> "The electrical current supplied to the CationSuppressor module during cation column flush.",
			ResolutionDescription -> "This option will be calculated by multiplying flow rate, maximum buffer concentration and suppressor specific factor (2.94 for cation suppressor).",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Quantity,
				Pattern :> RangeP[0 Milliampere, 150 Milliampere],
				Units -> Milliampere
			],
			Category -> "ColumnFlush"
		},
		{
			OptionName -> CationColumnFlushDetectionTemperature,
			Default -> Automatic,
			Description -> "The temperature of the oven where conductivity is measured during cation channel column flush.",
			ResolutionDescription -> "Automatically set to the first value of the CationDetectionTemperature.",
			AllowNull -> True,
			Widget -> Alternatives[
				Widget[
					Type -> Quantity,
					Pattern :> RangeP[15 Celsius, 35 Celsius],
					Units -> Celsius
				],
				Widget[
					Type -> Enumeration,
					Pattern :> Alternatives[Ambient]
				]
			],
			Category -> "ColumnFlush"
		},


		(* ================================================ *)
		(* === Single channel ICS 6000 Specific Options === *)
		(* ================================================ *)

		{
			OptionName -> ColumnFlushTemperature,
			Default -> Automatic,
			Description -> "The temperature the Column is held to throughout the column flush run.",
			ResolutionDescription -> "Automatically set from ColumnTemperature or taken from the ColumnFlushGradient option.",
			AllowNull -> True,
			Widget -> Alternatives[
				Widget[
					Type -> Quantity,
					Pattern :> RangeP[10 Celsius, 70 Celsius],
					Units -> Celsius
				],
				Widget[
					Type -> Enumeration,
					Pattern :> Alternatives[Ambient]
				]
			],
			Category -> "ColumnFlush"
		},
		{
			OptionName -> ColumnFlushGradientA,
			Default -> Automatic,
			Description -> "The composition of Buffer A within the flow during column prime, defined for specific time points. The composition is linearly interpolated for the intervening periods between the defined time points. For example for ColumnFlushGradientA->{{0 Minute, 0 Percent},{30 Minute, 100 Percent}}, the percentage of BufferA in the flow will rise such that at 15 minutes, the composition should be 50*Percent.",
			ResolutionDescription -> "Automatically set from ColumnFlushGradient option or implicitly determined from ColumnFlushGradientB, ColumnFlushGradientC, and ColumnFlushGradientD options such that composition of BufferA, B, C, and D sums up to 100 Percent throughout the gradient.",
			AllowNull -> True,
			Widget -> Alternatives[
				Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Percent, 100 Percent],
					Units -> Percent
				],
				Adder[
					{
						"Time" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Minute, 4320 Minute],
							Units -> {Minute, {Second, Minute}}
						],
						"Buffer A Composition" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Percent, 100 Percent],
							Units -> Percent
						]
					},
					Orientation -> Vertical
				]
			],
			Category -> "ColumnFlush"
		},
		{
			OptionName -> ColumnFlushGradientB,
			Default -> Automatic,
			Description -> "The composition of Buffer B within the flow during column flush, defined for specific time points. The composition is linearly interpolated for the intervening periods between the defined time points. For example for ColumnFlushGradientB->{{0 Minute, 0 Percent},{30 Minute, 100 Percent}}, the percentage of BufferB in the flow will rise such that at 15 minutes, the composition should be 50*Percent.",
			ResolutionDescription -> "Automatically set from ColumnFlushGradient option or implicitly determined from ColumnFlushGradientA, ColumnFlushGradientC, and ColumnFlushGradientD options such that composition of BufferA, B, C, and D sums up to 100 Percent throughout the gradient.",
			AllowNull -> True,
			Widget -> Alternatives[
				Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Percent, 100 Percent],
					Units -> Percent
				],
				Adder[
					{
						"Time" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Minute, 4320 Minute],
							Units -> {Minute, {Second, Minute}}
						],
						"Buffer B Composition" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Percent, 100 Percent],
							Units -> Percent
						]
					},
					Orientation -> Vertical
				]
			],
			Category -> "ColumnFlush"
		},
		{
			OptionName -> ColumnFlushGradientC,
			Default -> Automatic,
			Description -> "The composition of Buffer C within the flow during column flush, defined for specific time points. The composition is linearly interpolated for the intervening periods between the defined time points. For example for ColumnFlushGradientC->{{0 Minute, 0 Percent},{30 Minute, 100 Percent}}, the percentage of BufferC in the flow will rise such that at 15 minutes, the composition should be 50*Percent.",
			ResolutionDescription -> "Automatically set from ColumnFlushGradient option or implicitly determined from ColumnFlushGradientA, ColumnFlushGradientB, and ColumnFlushGradientD options such that composition of BufferA, B, C, and D sums up to 100 Percent throughout the gradient.",
			AllowNull -> True,
			Widget -> Alternatives[
				Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Percent, 100 Percent],
					Units -> Percent
				],
				Adder[
					{
						"Time" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Minute, 4320 Minute],
							Units -> {Minute, {Second, Minute}}
						],
						"Buffer C Composition" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Percent, 100 Percent],
							Units -> Percent
						]
					},
					Orientation -> Vertical
				]
			],
			Category -> "ColumnFlush"
		},
		{
			OptionName -> ColumnFlushGradientD,
			Default -> Automatic,
			Description -> "The composition of Buffer D within the flow during column flush, defined for specific time points. The composition is linearly interpolated for the intervening periods between the defined time points. For example for ColumnFlushGradientD->{{0 Minute, 0 Percent},{30 Minute, 100 Percent}}, the percentage of BufferD in the flow will rise such that at 15 minutes, the composition should be 50*Percent.",
			ResolutionDescription -> "Automatically set from ColumnFlushGradient option or implicitly determined from ColumnFlushGradientA, ColumnFlushGradientB, and ColumnFlushGradientC options such that composition of BufferA, B, C, and D sums up to 100 Percent throughout the gradient.",
			AllowNull -> True,
			Widget -> Alternatives[
				Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Percent, 100 Percent],
					Units -> Percent
				],
				Adder[
					{
						"Time" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Minute, 4320 Minute],
							Units -> {Minute, {Second, Minute}}
						],
						"Buffer D Composition" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Percent, 100 Percent],
							Units -> Percent
						]
					},
					Orientation -> Vertical
				]
			],
			Category -> "ColumnFlush"
		},
		{
			OptionName -> ColumnFlushFlowRate,
			Default -> Automatic,
			Description -> "The speed of the fluid through the system during column flush.",
			ResolutionDescription -> "Automatically set from Column, and FlowRate specified in the InjectionTable or taken from the method given in the ColumnFlushGradient option. If neither option is specified, the first value of FlowRate will be used",
			AllowNull -> True,
			Widget -> Alternatives[
				Widget[
					Type -> Quantity,
					Pattern :> RangeP[0 Milliliter / Minute, 10 Milliliter / Minute],
					Units -> CompoundUnit[
						{1, {Milliliter, {Milliliter, Liter}}},
						{-1, {Minute, {Minute, Second}}}
					]
				],
				Adder[
					{
						"Time" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Minute, 4320 Minute],
							Units -> {Minute, {Second, Minute}}
						],
						"Flow Rate" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Milliliter / Minute, 10 Milliliter / Minute],
							Units -> CompoundUnit[
								{1, {Milliliter, {Milliliter, Liter}}},
								{-1, {Minute, {Minute, Second}}}
							]
						]
					},
					Orientation -> Vertical
				]
			],
			Category -> "ColumnFlush"
		},
		{
			OptionName -> ColumnFlushStart,
			Default -> Null,
			Description -> "A shorthand option to specify the starting eluent concentration in the fluid flow of the instrument for column flush.",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Quantity,
				Pattern :> RangeP[0 Percent, 100 Percent],
				Units -> Percent
			],
			Category -> "ColumnFlush"
		},
		{
			OptionName -> ColumnFlushEnd,
			Default -> Null,
			Description -> "A shorthand option to specify the final eluent concentration in the fluid flow of the instrument for column flush.",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Quantity,
				Pattern :> RangeP[0 Percent, 100 Percent],
				Units -> Percent
			],
			Category -> "ColumnFlush"
		},
		{
			OptionName -> ColumnFlushDuration,
			Default -> Null,
			Description -> "A shorthand option to specify the total time it takes to run the column flush gradient.",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Quantity,
				Pattern :> RangeP[0 Minute, 4320 Minute],
				Units -> {Minute, {Minute, Second}}
			],
			Category -> "ColumnFlush"
		},
		{
			OptionName -> ColumnFlushGradient,
			Default -> Automatic,
			Description -> "The buffer composition over time in the fluid flow during column flush. Specific parameters of an object can be overridden by specific options for ColumnFlushGradientA, ColumnFlushGradientB, ColumnFlushGradientC, and ColumnFlushGradientD.",
			ResolutionDescription -> "Automatically set to match all specified options related to ColumnFlushGradient (e.g. ColumnFlushGradientA, ColumnFlushGradientB, ColumnFlushGradientC, ColumnFlushGradientD, ColumnFlushFlowRate, and ColumnFlushGradientDuration).",
			AllowNull -> True,
			Widget -> Alternatives[
				Widget[
					Type -> Object,
					Pattern :> ObjectP[Object[Method, Gradient]]
				],
				Adder[
					{
						"Time" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Minute, 4320 Minute],
							Units -> {Minute, {Second, Minute}}
						],
						"Buffer A Composition" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Percent, 100 Percent],
							Units -> Percent
						],
						"Buffer B Composition" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Percent, 100 Percent],
							Units -> Percent
						],
						"Buffer C Composition" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Percent, 100 Percent],
							Units -> Percent
						],
						"Buffer D Composition" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Percent, 100 Percent],
							Units -> Percent
						],
						"Flow Rate" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Milliliter / Minute, 10 Milliliter / Minute],
							Units -> CompoundUnit[
								{1, {Milliliter, {Milliliter, Liter}}},
								{-1, {Minute, {Minute, Second}}}
							]
						]
					},
					Orientation -> Vertical
				]
			],
			Category -> "ColumnFlush"
		},

		(* - UV detection options - *)
		{
			OptionName -> ColumnFlushAbsorbanceWavelength,
			Default -> Automatic,
			Description -> "The physical properties of light passed through the flow for the UVVis Detector during ColumnFlush. Up to 4 separate wavelengths may be specified.",
			ResolutionDescription -> "Automatically set to 280*Nanometer if the UVVis detector is used in the protocol and ColumnRefreshFrequency is not set to Null or None.",
			AllowNull -> True,
			Widget -> Alternatives[
				Widget[
					Type -> Quantity,
					Pattern :> RangeP[190 Nanometer, 900 Nanometer],
					Units -> Nanometer
				],
				Adder[
					Widget[
						Type -> Quantity,
						Pattern :> RangeP[190 Nanometer, 900 Nanometer],
						Units -> Nanometer
					]
				]
			],
			Category -> "ColumnFlush"
		},
		{
			OptionName -> ColumnFlushAbsorbanceSamplingRate,
			Default -> Automatic,
			Description -> "Indicates the frequency of absorbance measurement during ColumnFlush. Lower values will be less susceptible to noise but will record less frequently across time.",
			ResolutionDescription -> "Automatically set based on the number of wavelengths specified. Default ColumnFlushAbsorbanceSamplingRate is 10/Second for measurement at a single wavelength and 1/Second for measurements at multiple wavelengths.",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Quantity,
				Pattern :> RangeP[0.2 / Second, 100 / Second],
				Units -> 1 / Second
			],
			Category -> "ColumnFlush"
		},

		(* - Electrochemical detection options - *)
		{
			OptionName -> ColumnFlushElectrochemicalDetectionMode,
			Default -> Automatic,
			Description -> "Specifies the mode of operation for the electrochemical detector during ColumnFlush, including DC Amperometric Detection, Pulsed Amperometric Detection, and Integrated Pulsed Amperometric Detection. In DC Amperometric Detection, a constant voltage is applied. In contrast, Pulsed Amperometric Detections first apply a working potential followed by higher or lower potentials that are used for cleaning the electrode. Further, Integrated Amperometric Detection integrates current over a single potential whereas Integrated Pulsed Amperometric Detection integrates current over two or more potentials.",
			ResolutionDescription -> "Automatically set based on the ColumnFlushVoltageProfile or the ColumnFlushWaveformProfile specified. If neither option is specified, this option defaults to Pulsed Amperometric Detection.",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Enumeration,
				Pattern :> ElectrochemicalDetectionModeP
			],
			Category -> "ColumnFlush"
		},
		{
			OptionName -> ColumnFlushReferenceElectrodeMode,
			Default -> Automatic,
			Description -> "A combination pH-Ag/AgCl reference electrode that can be used to either monitor the buffer pH (\"pH\" reference) or to serve as a cell reference electrode with a constant potential (\"AgCl\" reference).",
			ResolutionDescription -> "Automatically set from Waveform method object. If Waveform is not specified, this option defaults to AgCl.",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Enumeration,
				Pattern :> ReferenceElectrodeModeP
			],
			Category -> "ColumnFlush"
		},
		{
			OptionName -> ColumnFlushVoltageProfile,
			Default -> Automatic,
			Description -> "The time-dependent voltage setting throughout the measurement during ColumnFlush.",
			ResolutionDescription -> "Automatically set to 0.1 Volt for DCAmperometricDetection. If any other ColumnFlushElectrochemicalDetectionMode is used, this option will set to Null.",
			AllowNull -> True,
			Widget -> Alternatives[
				Widget[
					Type -> Quantity,
					Pattern :> RangeP[-2.048 Volt, 2.047 Volt],
					Units -> Volt
				],
				Adder[
					{
						"Time" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Minute, 4320 Minute],
							Units -> {Minute, {Second, Minute}}
						],
						"Voltage" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[-2.048 Volt, 2.047 Volt],
							Units -> {Volt, {Volt, Milli * Volt}}
						]
					},
					Orientation -> Vertical
				]
			],
			Category -> "ColumnFlush"
		},
		{
			OptionName -> ColumnFlushWaveformProfile,
			Default -> Automatic,
			Description -> "A series of time-dependent voltage setting (waveform) that will be repeated over the duration of ColumnFlush.",
			ResolutionDescription -> "Automatically set to repeat a single waveform defined for either Pulsed Amperometric Detection or Integrated Pulsed Amperometric Detection over the entire run.",
			AllowNull -> True,
			Widget -> Alternatives[
				Widget[
					Type -> Object,
					Pattern :> ObjectP[Object[Method, Waveform]]
				],
				Adder[
					{
						"Waveform Time" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Second, 2 Second],
							Units -> Second
						],
						"Voltage" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[-2.048 Volt, 2.047 Volt],
							Units -> Volt
						],
						"Interpolation" -> Widget[
							Type -> Enumeration,
							Pattern :> BooleanP
						],
						"Integration" -> Widget[
							Type -> Enumeration,
							Pattern :> BooleanP
						]
					},
					Orientation -> Vertical
				],
				Adder[
					{
						"Time" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Minute, 4320 Minute],
							Units -> {Minute, {Second, Minute}}
						],
						"Waveform" -> Widget[
							Type -> Object,
							Pattern :> ObjectP[Object[Method, Waveform]]
						]
					},
					Orientation -> Vertical
				],
				Adder[
					{
						"Time" -> Widget[
							Type -> Quantity,
							Pattern :> RangeP[0 Minute, 4320 Minute],
							Units -> {Minute, {Second, Minute}}
						],
						"Waveform" -> Adder[
							{
								"Waveform Time" -> Widget[
									Type -> Quantity,
									Pattern :> RangeP[0 Second, 2 Second],
									Units -> Second
								],
								"Voltage" -> Widget[
									Type -> Quantity,
									Pattern :> RangeP[-2.048 Volt, 2.047 Volt],
									Units -> Volt
								],
								"Interpolation" -> Widget[
									Type -> Enumeration,
									Pattern :> BooleanP
								],
								"Integration" -> Widget[
									Type -> Enumeration,
									Pattern :> BooleanP
								]
							},
							Orientation -> Vertical
						]
					},
					Orientation -> Vertical
				]
			],
			Category -> "ColumnFlush"
		},
		{
			OptionName -> ColumnFlushElectrochemicalSamplingRate,
			Default -> Automatic,
			Description -> "Indicates the frequency of amperometric measurement. Lower values will be less susceptible to noise but will record less frequently across time.",
			ResolutionDescription -> "Automatically set to 1/waveform duration if a single waveform is specified. If multiple waveforms are specified, this option is set to 1 over the longest waveform duration. If no waveform is specified, this option is set to 2/Second.",
			AllowNull -> True,
			Widget -> Widget[
				Type -> Quantity,
				Pattern :> RangeP[0.2 / Second, 100 / Second],
				Units -> 1 / Second
			],
			Category -> "ColumnFlush"
		},
		{
			OptionName -> ColumnFlushDetectionTemperature,
			Default -> Automatic,
			Description -> "The temperature of the detection oven where the eletrochemical detection takes place.",
			ResolutionDescription -> "This option will automatically be set to Ambient if electrochemical detector is used and Null if not.",
			AllowNull -> True,
			Widget -> Alternatives[
				Widget[
					Type -> Quantity,
					Pattern :> RangeP[15 Celsius, 35 Celsius],
					Units -> Celsius
				],
				Widget[
					Type -> Enumeration,
					Pattern :> Alternatives[Ambient]
				]
			],
			Category -> "ColumnFlush"
		},


		(* --- Sample Parameters Category --- *)

		(* ================================================ *)
		(* === Double channel ICS 6000 Specific Options === *)
		(* ================================================ *)

		{
			OptionName -> AnionInjectionTable,
			Default -> Automatic,
			Description -> "The order of AnionSamples, AnionStandard, and AnionBlank sample loading into the anion flow path of the Instrument during measurement. Also includes the flushing and priming of the AnionColumn.",
			ResolutionDescription -> "Determined to the order of AnionSamples articulated. AnionStandard and AnionBlank samples are inserted based on the determination of AnionStandardFrequency and AnionBlankFrequency. For example, AnionStandardFrequency->FirstAndLast and AnionBlankFrequency->Null result in AnionStandard samples being injected first, then the AnionSamples, and then the AnionStandard again at the end.",
			AllowNull -> True,
			Widget -> Adder[
				Alternatives[
					{
						"Type" -> Widget[
							Type -> Enumeration,
							Pattern :> InjectionTableSampleTypeP
						],
						"Anion Samples" -> Alternatives[
							Widget[
								Type -> Object,
								Pattern :> ObjectP[{Model[Sample], Object[Sample]}]
							]
						],
						"Analysis Channel" -> Alternatives[
							Widget[
								Type -> Enumeration,
								Pattern :> Alternatives[AnionChannel]
							],
							Widget[
								Type -> Enumeration,
								Pattern :> Alternatives[Automatic]
							]
						],
						"Injection Volume" -> Alternatives[
							Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Microliter, 10 Microliter],
								Units -> Microliter
							],
							Widget[
								Type -> Enumeration,
								Pattern :> Alternatives[Automatic]
							]
						],
						"Gradient" -> Alternatives[
							Widget[
								Type -> Object,
								Pattern :> ObjectP[Object[Method, IonChromatographyGradient]]
							],
							Widget[
								Type -> Enumeration,
								Pattern :> Alternatives[Automatic]
							]
						]
					},
					{
						"Type" -> Widget[
							Type -> Enumeration,
							Pattern :> InjectionTableCleaningTypeP
						],
						"Analysis Channel" -> Alternatives[
							Widget[
								Type -> Enumeration,
								Pattern :> Alternatives[AnionChannel]
							],
							Widget[
								Type -> Enumeration,
								Pattern :> Alternatives[Automatic]
							]
						],
						"Gradient" -> Alternatives[
							Widget[
								Type -> Object,
								Pattern :> ObjectP[Object[Method, IonChromatographyGradient]]
							],
							Widget[
								Type -> Enumeration,
								Pattern :> Alternatives[Automatic]
							]
						]
					}
				],
				Orientation -> Vertical
			],
			Category -> "Sample Parameters"
		},
		{
			OptionName -> CationInjectionTable,
			Default -> Automatic,
			Description -> "The order of CationSamples, CationStandard, and CationBlank sample loading into the cation flow path of the Instrument during measurement. Also includes the flushing and priming of the CaitonColumn.",
			ResolutionDescription -> "Determined to the order of CationSamples articulated. CationStandard and CationBlank samples are inserted based on the determination of CationStandardFrequency and CationBlankFrequency. For example, CationStandardFrequency->FirstAndLast and CationBlankFrequency->Null result in CationStandard samples being injected first, then the CationSamples, and then the CationStandard again at the end.",
			AllowNull -> True,
			Widget -> Adder[
				Alternatives[
					{
						"Type" -> Widget[
							Type -> Enumeration,
							Pattern :> InjectionTableSampleTypeP
						],
						"Cation Samples" -> Alternatives[
							Widget[
								Type -> Object,
								Pattern :> ObjectP[{Model[Sample], Object[Sample]}]
							]
						],
						"Analysis Channel" -> Alternatives[
							Widget[
								Type -> Enumeration,
								Pattern :> Alternatives[CationChannel]
							],
							Widget[
								Type -> Enumeration,
								Pattern :> Alternatives[Automatic]
							]
						],
						"Injection Volume" -> Alternatives[
							Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Microliter, 10 Microliter],
								Units -> Microliter
							],
							Widget[
								Type -> Enumeration,
								Pattern :> Alternatives[Automatic]
							]
						],
						"Gradient" -> Alternatives[
							Widget[
								Type -> Object,
								Pattern :> ObjectP[Object[Method, IonChromatographyGradient]]
							],
							Widget[
								Type -> Enumeration,
								Pattern :> Alternatives[Automatic]
							]
						]
					},
					{
						"Type" -> Widget[
							Type -> Enumeration,
							Pattern :> InjectionTableCleaningTypeP
						],
						"Analysis Channel" -> Alternatives[
							Widget[
								Type -> Enumeration,
								Pattern :> Alternatives[CationChannel]
							],
							Widget[
								Type -> Enumeration,
								Pattern :> Alternatives[Automatic]
							]
						],
						"Gradient" -> Alternatives[
							Widget[
								Type -> Object,
								Pattern :> ObjectP[Object[Method, IonChromatographyGradient]]
							],
							Widget[
								Type -> Enumeration,
								Pattern :> Alternatives[Automatic]
							]
						]
					}
				],
				Orientation -> Vertical
			],
			Category -> "Sample Parameters"
		},


		(* ================================================ *)
		(* === Single channel ICS 6000 Specific Options === *)
		(* ================================================ *)

		{
			OptionName -> ElectrochemicalInjectionTable,
			Default -> Automatic,
			Description -> "The order of Samples, Standard, and Blank sample loading into the flow path of the Instrument during measurement. Also includes the flushing and priming of the Column.",
			ResolutionDescription -> "Determined to the order of input samples articulated. Standard and Blank samples are inserted based on the determination of StandardFrequency and BlankFrequency. For example, StandardFrequency->FirstAndLast and BlankFrequency->Null result in Standard samples injected first, then the samples, and then the Standard sample again at the end.",
			AllowNull -> True,
			Widget -> Adder[
				Alternatives[
					{
						"Type" -> Widget[
							Type -> Enumeration,
							Pattern :> InjectionTableSampleTypeP
						],
						"Samples" -> Alternatives[
							Widget[
								Type -> Object,
								Pattern :> ObjectP[{Model[Sample], Object[Sample]}]
							],
							Widget[
								Type -> Enumeration,
								Pattern :> Alternatives[Automatic]
							]
						],
						"Injection Volume" -> Alternatives[
							Widget[
								Type -> Quantity,
								Pattern :> RangeP[0 Microliter, 25 Microliter],
								Units -> Microliter
							],
							Widget[
								Type -> Enumeration,
								Pattern :> Alternatives[Automatic]
							]
						],
						"Gradient" -> Alternatives[
							Widget[
								Type -> Object,
								Pattern :> ObjectP[Object[Method, Gradient]]
							],
							Widget[
								Type -> Enumeration,
								Pattern :> Alternatives[Automatic]
							]
						],
						"Waveform Profile" -> Alternatives[
							Widget[
								Type -> Object,
								Pattern :> ObjectP[Object[Method, Waveform]] (* TODO: Throw in the catalog folder where the default waveform is located *)
							],
							Adder[
								{
									"Time" -> Widget[
										Type -> Quantity,
										Pattern :> RangeP[0 Minute, 4320 Minute],
										Units -> {Minute, {Second, Minute}}
									],
									"Waveform" -> Widget[
										Type -> Object,
										Pattern :> ObjectP[Object[Method, Waveform]]
									]
								}
							],
							Adder[
								{
									"Time" -> Widget[
										Type -> Quantity,
										Pattern :> RangeP[0 Minute, 4320 Minute],
										Units -> {Minute, {Second, Minute}}
									],
									"Waveform" -> Adder[
										{
											"Waveform Time" -> Widget[
												Type -> Quantity,
												Pattern :> RangeP[0 Second, 2 Second],
												Units -> Second
											],
											"Voltage" -> Widget[
												Type -> Quantity,
												Pattern :> RangeP[-2.048 Volt, 2.047 Volt],
												Units -> Volt
											],
											"Interpolation" -> Widget[
												Type -> Enumeration,
												Pattern :> BooleanP
											],
											"Integration" -> Widget[
												Type -> Enumeration,
												Pattern :> BooleanP
											]
										},
										Orientation -> Vertical
									]
								},
								Orientation -> Vertical
							],
							Widget[
								Type -> Enumeration,
								Pattern :> Alternatives[Automatic | Null]
							]
						],
						"Voltage Profile" -> Alternatives[
							Adder[
								{
									"Time" -> Widget[
										Type -> Quantity,
										Pattern :> RangeP[0 Minute, 4320 Minute],
										Units -> {Minute, {Second, Minute}}
									],
									"Voltage" -> Widget[
										Type -> Quantity,
										Pattern :> RangeP[-2.048 Volt, 2.047 Volt],
										Units -> Volt
									]
								}
							],
							Widget[
								Type -> Quantity,
								Pattern :> RangeP[-2.048 Volt, 2.047 Volt],
								Units -> Volt
							],
							Widget[
								Type -> Enumeration,
								Pattern :> Alternatives[Automatic | Null]
							]
						]
					},
					{
						"Type" -> Widget[
							Type -> Enumeration,
							Pattern :> InjectionTableCleaningTypeP
						],
						"Gradient" -> Alternatives[
							Widget[
								Type -> Object,
								Pattern :> ObjectP[Object[Method, Gradient]]
							],
							Widget[
								Type -> Enumeration,
								Pattern :> Alternatives[Automatic]
							]
						],
						"Waveform Profile" -> Alternatives[
							Widget[
								Type -> Object,
								Pattern :> ObjectP[Object[Method, Waveform]]
							],
							Adder[
								{
									"Time" -> Widget[
										Type -> Quantity,
										Pattern :> RangeP[0 Minute, 4320 Minute],
										Units -> {Minute, {Second, Minute}}
									],
									"Waveform" -> Widget[
										Type -> Object,
										Pattern :> ObjectP[Object[Method, Waveform]]
									]
								}
							],
							Adder[
								{
									"Time" -> Widget[
										Type -> Quantity,
										Pattern :> RangeP[0 Minute, 4320 Minute],
										Units -> {Minute, {Second, Minute}}
									],
									"Waveform" -> Adder[
										{
											"Waveform Time" -> Widget[
												Type -> Quantity,
												Pattern :> RangeP[0 Second, 2 Second],
												Units -> Second
											],
											"Voltage" -> Widget[
												Type -> Quantity,
												Pattern :> RangeP[-2.048 Volt, 2.047 Volt],
												Units -> Volt
											],
											"Interpolation" -> Widget[
												Type -> Enumeration,
												Pattern :> BooleanP
											],
											"Integration" -> Widget[
												Type -> Enumeration,
												Pattern :> BooleanP
											]
										},
										Orientation -> Vertical
									]
								},
								Orientation -> Vertical
							],
							Widget[
								Type -> Enumeration,
								Pattern :> Alternatives[Automatic | Null]
							]
						],
						"Voltage Profile" -> Alternatives[
							Adder[
								{
									"Time" -> Widget[
										Type -> Quantity,
										Pattern :> RangeP[0 Minute, 4320 Minute],
										Units -> {Minute, {Second, Minute}}
									],
									"Voltage" -> Widget[
										Type -> Quantity,
										Pattern :> RangeP[-2.048 Volt, 2.047 Volt],
										Units -> Volt
									]
								}
							],
							Widget[
								Type -> Quantity,
								Pattern :> RangeP[-2.048 Volt, 2.047 Volt],
								Units -> Volt
							],
							Widget[
								Type -> Enumeration,
								Pattern :> Alternatives[Automatic | Null]
							]
						]
					}
				],
				Orientation -> Vertical
			],
			Category -> "Sample Parameters"
		},


		(* ====================== *)
		(* === Common options === *)
		(* ====================== *)

		{
			OptionName -> SampleTemperature,
			Default -> Ambient,
			Description -> "The temperature at which the Samples, Standard, and Blank are kept in the autosampler.",
			AllowNull -> False,
			Widget -> Alternatives[
				Widget[
					Type -> Quantity,
					Pattern :> RangeP[4 Celsius, 60 Celsius],
					Units -> Celsius
				],
				Widget[
					Type -> Enumeration,
					Pattern :> Alternatives[Ambient]
				]
			],
			Category -> "Sample Parameters"
		},
		{
			OptionName -> NeedleWashSolution,
			Default -> Model[Sample, "Milli-Q water"],
			Description -> "The solvent used to wash the injection needle before each sample measurement.",
			AllowNull -> False,
			Widget -> Widget[
				Type -> Object,
				Pattern :> ObjectP[{Object[Sample], Model[Sample]}],
				PreparedSample->False,
				PreparedContainer->False
			],
			Category -> "Sample Parameters"
		},

		NonBiologyFuntopiaSharedOptions,
		SubprotocolDescriptionOption,
		SamplesInStorageOption,
		ModifyOptions[
			ModelInputOptions,
			OptionName -> PreparedModelAmount
		],
		ModifyOptions[
			ModelInputOptions,
			PreparedModelContainer,
			{
				ResolutionDescription -> "If PreparedModelAmount is set to All and the input model has a product associated with both Amount and DefaultContainerModel populated, automatically set to the DefaultContainerModel value in the product. Otherwise, automatically set to Model[Container, Plate, \"96-well 2mL Deep Well Plate\"]."
			}
		],
		SimulationOption
	}
];


(* ::Subsection:: *)
(*ExperimentIonChromatography Error Messages*)

(* === Warnings === *)
Warning::IncompatibleColumnAnalysisChannel = "The specified `1` `2` has a preferred analysis channel of `3`, which is different from the specified `4` AnalysisChannel. Please consider specifying a different `1`.";
Warning::OverwritingSamplelessChannelOptions = "One or more `1` related options are specified while there's no `1`. These options are overwritten and set to Null.";
Warning::NoAnalyteInAnalysisChannel = "There is no analyte currently in the `1` while Standard or Blank samples are specified.";
Warning::MultipleElectrochemicalDetectionModes = "The specified waveforms in either `1` option or the injection table have different `2`. Please consider specifying waveforms with the same detection mode.";
Warning::pHCalibrationTarget = "The specified SecondarypHCalibrationBufferTarget does not match the pH from the SecondarypHCalibrationBuffer packet. Please consider letting the SecondarypHCalibrationBufferTarget set automatically.";
Warning::HPICGradientShortcutAmbiguity = "Gradient shortcut options are specified in both `1` and `2` options but they conflict with each other. The experiment will commence as directed with the latter value(s). Please verify the resolved gradients in the submitted protocol are desired.";
Warning::IncompatibleICDetector = "The specified detectors `1` are not a subset of compatible detectors `2` for the specified analysis channel `3`. Data will only be collected on the compatible detectors.";
Warning::NonRecommendedICInjectionVolume = "The resolved `1` values are `2`. Due to limitations of the injection mechanism, we recommend that injection volumes either be equal to the sample loop volume (`3`) or less than or equal to one half of the sample loop volume (`4`). Injection volumes between `4` and `3` can be specified, but they may be less accurate and precise.";


(* === Sample error messages === *)
Error::IncompatibleICInstrument = "The specified Instrument `1` only supports `2` analysis channel and is incompatible with the desired analysis channel `3`. Consider letting these options resolve automatically.";
Error::InvalidAnalysisChannelSpecification = "Our Instrument does not support ElectrochemicalChannel and AnionChannel or CationChannel in the same protocol for Samples, Standards and Blanks. Consider running two separate protocols.";
Error::InvalidGuardColumn = "The specified `1` `2` is not a valid guard column. A valid guard column's ColumnType is Guard.";
Error::SampleOptionConflict = "The following options can not be set to Null when samples are injected into `1`, either in the option or the injection table: `2`. Consider letting these options set automatically.";
Error::InconsistentAnalysisChannelSpecification = "The specified `1` `2` has specified AnalysisChannel of `3`, which is different from `4` expected for `1`.";
Error::ImbalancedAnionCationGrouping = "The total number of `1` and `2` does not sum up to the total number of `3`. Please consider re-grouping `1` and `2`.";
Error::HPICGradientStartEndConflict = "`1` options must be specified simultaneously or not at all for `2`.";
Error::InconsistentGradientSpecification = "The `1` `2` has inconsistent gradient specification in the option and the injection table. Consider letting them one of them set automatically.";
Error::InvalidAnionGradientComposition = "The specified Gradient for `1` `2` has a maximum concentration over `3` supported by our system.";
Error::InvalidGradientComposition = "The specified Gradient for `1` does not have a total buffer composition of 100% over the specified time points.";
Error::ConflictingSuppressorMode = "The following `1` have conflicting specification of `2`. If `2` is set to DynamicMode, `3` cannot be set to Null. If `2` is set to LegacyMode, `4` cannot be set to Null. Consider letting these options set automatically.";
Error::InvalidAbsorbanceOption = "The specified Detector UVVis is conflicting with one or more of the following options being set to Null: `1`. Consider letting these options set automatically.";
Error::InvalidElectrochemicalOption = "The specified Detector ElectrochemicalDetector is conflicting with one or more of the following options being set to Null: `1`. Consider letting these options set automatically.";
Error::InvalidElectrochemicalDetectionModeOption = "The `1` option has inconsistent specification with either `2` or `3`. If `1` is set to DCAmperometricDetection, `2` cannot be Null. Similarly, if `1` is set to either PulsedAmperometricDetection or IntegratedPulsedAmperometricDetection, `3` cannot be Null. Consider letting these options set automatically.";
Error::ConflictingElectrochemicalDetectionModes = "The specified waveforms in either `1` option or the injection table is conflicting with `2` option. Consider letting these options set automatically.";
Error::MultipleWaveformDuration = "The specified waveforms for the following samples `1` have difference durations. Waveforms with difference durations are not supported by our instrument `2`.";
Error::InvalidTimeSpecification = "The time specified in `1` option is not monotonically increasing. For Waveform options, both waveform time and the time for the onset of each waveform need to be monotonically increasing.";
Error::pHCalibrationOptionConflict = "One or more options in the following sets of options: `1` are not specified. These options should be specified or set to Null simultaneously. Consider letting these options set automatically.";
Error::HPICGradientShortcutConflict = "When `1` option is specified, its corresponding `2` options cannot be used in combination with `3` options.";
Error::HPICConflictingDetectionOptions = "The specified detector `1` are not compatible with the specified detector options: `2`. These options are only compatible with `3` detector. Please consider specify `3` as the Detector or removing the conflicting option specifications.";
Error::ColumnRefreshOptionConflict = "The following options can not be set to Null when `1` is being run in `2`, either in the option or the InjectionTable: `3`. Consider letting these options set automatically.";
Error::HPICNullBlankOption = "The Blank option has been set to Null while other blank-related options: `1`  have values other than Null. Consider letting these options set automatically.";
Error::HPICNullStandardOption = "The Standard option has been set to Null while other standard-related options: `1`  have values other than Null. Consider letting these options set automatically.";

(* === ColumnRefresh error messages === *)
Error::InconsistentRefreshGradientSpecification = "The `1` has inconsistent gradient specification in the option and the InjectionTable. ";
Error::InvalidAnionRefreshGradientComposition = "The specified Gradient for `1` has a maximum concentration over `2` supported by our system.";
Error::InvalidRefreshGradientComposition = "The specified Gradient for `1` does not have a total buffer composition of 100% over the specified time points.";
Error::ConflictingColumnRefreshSuppressorMode = "The specified `1` have conflicting specification of `2`. If `2` is set to DynamicMode, `3` cannot be set to Null. If `2` is set to LegacyMode, `4` cannot be set to Null. Consider letting these options set automatically.";
Error::ColumnRefreshMultipleWaveformDuration = "The specified waveforms for `1` have difference durations. Waveforms with difference durations are not supported by our instrument `2`.";


(* ::Subsection:: *)
(*ExperimentIonChromatography Main Function*)


(* ::Subsubsection::Closed:: *)
(*ExperimentIonChromatography Main Function - Sample Overload*)


ExperimentIonChromatography[mySamples : ListableP[ObjectP[Object[Sample]]], myOptions : OptionsPattern[]] := Module[
	{
		outputSpecification, output, gatherTests, validSamplePreparationResult, mySamplesWithPreparedSamples, myOptionsWithPreparedSamples,
		safeOptionsNamed, mySamplesWithPreparedSamplesNamed, myOptionsWithPreparedSamplesNamed, lcVialModels,
		safeOps, safeOpsTests, validLengths, validLengthTests, availableInstruments, allObjects, objectSampleFields, analyteFields,
		objectContainerFields, modelContainerFieldsPacket, modelInstrumentFields, columnFields, modelColumnFields, modelSampleFields, modelSampleObjects,
		gradientFields, sampleFields, modelContainerFields, optionsWithObjects, userSpecifiedObjects, simulatedSampleQ, objectsExistQs, modelSamplePackets,
		objectsExistTests, sampleObjects, modelContainerObjects, instrumentObjects, modelInstrumentObjects, columnObjects, modelColumnObjects, gradientObjects,
		templatedOptions, templateTests, inheritedOptions, expandedSafeOps, cacheBall, resolvedOptionsResult, instrumentFields, anionInjectionTableLookup,
		cationInjectionTableLookup, anionInjectionTableObjects, cationInjectionTableObjects, resolvedOptions, resolvedOptionsTests, collapsedResolvedOptions,
		protocolObject, resourcePackets, resourcePacketTests, completeCollapsedResolvedOptions, standardAndBufferModels, listedSamples, noTemperoralLinkOptions,
		electrochemicalInjectionTableLookup, electrochemicalInjectionTableObjects, electrodeFields, modelElectrodeFields, waveformFields, electrodeObjects,
		modelElectrodeObjects, waveformObjects, updatedSimulation, cache
	},

	(* Determine the requested return value from the function *)
	outputSpecification = Quiet[OptionValue[Output], OptionValue::nodef];
	output = ToList[outputSpecification];

	(* Determine if we should keep a running list of tests *)
	gatherTests = MemberQ[output, Tests];

	(* pull out the Cache from the specified options *)
	cache=Lookup[ToList@myOptions,Cache,{}];

  (* Get the samples and options in list format without links. *)
	{listedSamples, noTemperoralLinkOptions} = removeLinks[ToList[mySamples], ToList[myOptions]];

	(* Simulate our sample preparation. *)
	validSamplePreparationResult = Check[
		(* Simulate sample preparation. *)
		{mySamplesWithPreparedSamplesNamed, myOptionsWithPreparedSamplesNamed, updatedSimulation} = simulateSamplePreparationPacketsNew[
			ExperimentIonChromatography,
			ToList[listedSamples],
			ToList[noTemperoralLinkOptions]
		],
		$Failed,
		{Download::ObjectDoesNotExist, Error::MissingDefineNames, Error::InvalidInput, Error::InvalidOption}
	];

	(* If we are given an invalid define name, return early. *)
	If[MatchQ[validSamplePreparationResult, $Failed],
		(* Return early. *)
		(* Note: We've already thrown a message above in simulateSamplePreparationPackets. *)
		Return[$Failed]
	];

	(* Call SafeOptions to make sure all options match pattern *)
	{safeOptionsNamed, safeOpsTests} = If[gatherTests,
		SafeOptions[ExperimentIonChromatography, myOptionsWithPreparedSamplesNamed, AutoCorrect -> False, Output -> {Result, Tests}],
		{SafeOptions[ExperimentIonChromatography, myOptionsWithPreparedSamplesNamed, AutoCorrect -> False], {}}
	];

	(* replace all objects referenced by Name to ID *)
	{mySamplesWithPreparedSamples, safeOps, myOptionsWithPreparedSamples} = sanitizeInputs[mySamplesWithPreparedSamplesNamed, safeOptionsNamed, myOptionsWithPreparedSamplesNamed, Simulation -> updatedSimulation];

	(* If the specified options don't match their patterns or if option lengths are invalid return $Failed *)
	If[MatchQ[safeOps, $Failed],
		Return[outputSpecification /. {
			Result -> $Failed,
			Tests -> safeOpsTests,
			Options -> $Failed,
			Preview -> Null
		}]
	];

	(* Call ValidInputLengthsQ to make sure all options are the right length *)
	{validLengths, validLengthTests} = If[gatherTests,
		ValidInputLengthsQ[ExperimentIonChromatography, {mySamplesWithPreparedSamples}, myOptionsWithPreparedSamples, Output -> {Result, Tests}],
		{ValidInputLengthsQ[ExperimentIonChromatography, {mySamplesWithPreparedSamples}, myOptionsWithPreparedSamples], Null}
	];

	(* If option lengths are invalid return $Failed (or the tests up to this point) *)
	If[!validLengths,
		Return[outputSpecification /. {
			Result -> $Failed,
			Tests -> Join[safeOpsTests, validLengthTests],
			Options -> $Failed,
			Preview -> Null
		}]
	];

	(* Use any template options to get values for options not specified in myOptions *)
	{templatedOptions, templateTests} = If[gatherTests,
		ApplyTemplateOptions[ExperimentIonChromatography, {ToList[mySamplesWithPreparedSamples]}, myOptionsWithPreparedSamples, Output -> {Result, Tests}],
		{ApplyTemplateOptions[ExperimentIonChromatography, {ToList[mySamplesWithPreparedSamples]}, myOptionsWithPreparedSamples], Null}
	];

	(* Return early if the template cannot be used - will only occur if the template object does not exist. *)
	If[MatchQ[templatedOptions, $Failed],
		Return[outputSpecification /. {
			Result -> $Failed,
			Tests -> Join[safeOpsTests, validLengthTests, templateTests],
			Options -> $Failed,
			Preview -> Null
		}]
	];

	(* Replace our safe options with our inherited options from our template. *)
	inheritedOptions = ReplaceRule[safeOps, templatedOptions];

	(* Expand index-matching options *)
	expandedSafeOps = Last[ExpandIndexMatchedInputs[ExperimentIonChromatography, {ToList[mySamplesWithPreparedSamples]}, inheritedOptions]];

	(*-- DOWNLOAD THE INFORMATION THAT WE NEED FOR OUR OPTION RESOLVER AND RESOURCE PACKET FUNCTION --*)

	(* Fields to download from any instrument objects *)
	instrumentFields = {
		Packet[Model, Status],
		Packet[Model[{
			AnalysisChannels,
			AnionSuppressor,
			CationSuppressor,
			TubingMaxPressure,
			AnionPumpMinPressure,
			AnionPumpMaxPressure,
			CationPumpMinPressure,
			CationPumpMaxPressure,
			MinFlowRate,
			MaxFlowRate,
			MinSampleVolume,
			MaxSampleVolume,
			MinSampleTemperature,
			MaxSampleTemperature,
			AnionMinColumnTemperature,
			CationMinColumnTemperature,
			AnionMaxColumnTemperature,
			CationMaxColumnTemperature,
			AnionMinDetectionTemperature,
			CationMinDetectionTemperature,
			AnionMaxDetectionTemperature,
			CationMaxDetectionTemperature,
			NeedleWashSolution,
			SampleLoop,
			AnionDetector,
			CationDetector,
			AnionSuppressor,
			CationSuppressor,
			IntegratedEluentGenerator,
			Manufacturer,
			Deprecated
		}]]
	};

	(* Fields to download from any model instrument objects *)
	modelInstrumentFields = {
		Packet[
			AnalysisChannels,
			TubingMaxPressure,
			AnionPumpMinPressure,
			AnionPumpMaxPressure,
			CationPumpMinPressure,
			CationPumpMaxPressure,
			MinFlowRate,
			MaxFlowRate,
			MinSampleVolume,
			MaxSampleVolume,
			MinSampleTemperature,
			MaxSampleTemperature,
			AnionMinColumnTemperature,
			CationMinColumnTemperature,
			MinColumnTemperature,
			AnionMaxColumnTemperature,
			CationMaxColumnTemperature,
			MaxColumnTemperature,
			AnionMinDetectionTemperature,
			CationMinDetectionTemperature,
			MinDetectionTemperature,
			AnionMaxDetectionTemperature,
			CationMaxDetectionTemperature,
			MaxDetectionTemperature,
			NeedleWashSolution,
			SampleLoop,
			AnionDetector,
			CationDetector,
			Detectors,
			ReferenceElectrode,
			Manufacturer,
			Deprecated
		],
		Packet[AnionSuppressor[{
			FactoryRecommendedVoltage,
			MaxVoltage,
			MaxCurrent,
			MinFlowRate,
			MaxFlowRate,
			SuppressorSpecificFactor
		}]],
		Packet[CationSuppressor[{
			FactoryRecommendedVoltage,
			MaxVoltage,
			MaxCurrent,
			MinFlowRate,
			MaxFlowRate,
			SuppressorSpecificFactor
		}]],
		Packet[IntegratedEluentGenerator[{
			Eluent,
			MaxConcentration,
			MinFlowRate,
			MaxFlowRate
		}]]
	};

	(* Fields to download from any column objects *)
	columnFields = {
		Packet[Model],
		Packet[Model[{ChromatographyType, ColumnType, AnalysisChannel, ColumnLength, Diameter, MinFlowRate, MaxFlowRate, MaxPressure, PreferredGuardColumn, MinTemperature, MaxTemperature}]]
	};

	(* Fields to download from any column model objects *)
	modelColumnFields = {
		Packet[ChromatographyType, ColumnType, AnalysisChannel, MinFlowRate, MaxFlowRate, MaxPressure, PreferredGuardColumn, MinTemperature, MaxTemperature]
	};

	(* Set fields to download from gradient objects *)
	gradientFields = {
		Packet[
			EluentGradient,
			AnionGradient,
			EluentGeneratorInletSolution,
			BufferA,
			BufferB,
			BufferC,
			BufferD,
			GradientA,
			GradientB,
			GradientC,
			GradientD,
			CationGradient,
			AnionColumnTemperature,
			CationColumnTemperature,
			AnionFlowRate,
			CationFlowRate,
			AnionEquilibrationTime,
			AnionFlushTime,
			CationEquilibrationTime,
			CationFlushTime,
			Gradient,
			FlowRate,
			ColumnTemperature,
			Temperature,
			InitialFlowRate,
			EquilibrationTime,
			FlushTime
		]
	};

	(* Set fields to download from electrode objects *)
	electrodeFields = {
		Packet[Model],
		Packet[Model[{Coated, CoatMaterial, MinPotential, MaxPotential, DefaultStorageCondition}]]
	};

	(* Fields to download from any electrode model objects *)
	modelElectrodeFields = {
		Packet[Coated, CoatMaterial, MinPotential, MaxPotential, DefaultStorageCondition]
	};

	(* Set fields to download from waveformFields objects *)
	waveformFields = {
		Packet[
			ElectrochemicalDetectionMode,
			ReferenceElectrodeMode,
			WaveformDuration,
			Waveform
		]
	};


	(*define all the fields that we want*)
	objectSampleFields = SamplePreparationCacheFields[Object[Sample]];
	modelSampleFields = SamplePreparationCacheFields[Model[Sample]];
	analyteFields = {Object, Composition, Analytes};
	objectContainerFields = Union[SamplePreparationCacheFields[Object[Container]]];
	modelContainerFields = Union[SamplePreparationCacheFields[Model[Container]]];

	(* Set fields to download from mySamples *)
	sampleFields = {
		Packet[Sequence @@ objectSampleFields],
		Packet[Analytes[analyteFields]],
		Packet[Field[Composition[[All, 2]]][{Object, Name, MolecularWeight}]],
		Packet[Container[objectContainerFields]],
		Packet[Container[Model][modelContainerFields]],
		Packet[Model[pH]]
	};

	modelSamplePackets = {Packet[Sequence @@ modelSampleFields]};

	(* Container Model fields to download *)
	modelContainerFieldsPacket = {Packet[Sequence @@ modelContainerFields]};

	(* Any options whose values _could_ be an object *)
	optionsWithObjects = {
		Instrument,
		AnionSamples,
		CationSamples,
		AnionColumn,
		CationColumn,
		Column,
		AnionGuardColumn,
		CationGuardColumn,
		GuardColumn,
		BufferA,
		BufferB,
		BufferC,
		BufferD,
		WorkingElectrode,
		NeutralpHCalibrationBuffer,
		SecondarypHCalibrationBuffer,
		WaveformProfile,
		AnionGradient,
		CationGradient,
		Gradient,
		Standard,
		CationStandard,
		AnionStandard,
		AnionStandardGradient,
		CationStandardGradient,
		StandardGradient,
		StandardWaveformProfile,
		Blank,
		AnionBlank,
		CationBlank,
		AnionBlankGradient,
		CationBlankGradient,
		BlankGradient,
		BlankWaveformProfile,
		AnionColumnPrimeGradient,
		CationColumnPrimeGradient,
		ColumnPrimeGradient,
		ColumnPrimeWaveformProfile,
		AnionColumnFlushGradient,
		CationColumnFlushGradient,
		ColumnFlushGradient,
		ColumnFlushWaveformProfile
	};

	(*we also need to the check the objects within the injection table*)
	anionInjectionTableLookup = Lookup[ToList[myOptionsWithPreparedSamples], AnionInjectionTable, Null];
	cationInjectionTableLookup = Lookup[ToList[myOptionsWithPreparedSamples], CationInjectionTable, Null];
	electrochemicalInjectionTableLookup = Lookup[ToList[myOptionsWithPreparedSamples], ElectrochemicalInjectionTable, Null];

	(*if injection table is specified, need to check all of the column and gradient objects within*)
	anionInjectionTableObjects = If[MatchQ[anionInjectionTableLookup, Except[Automatic | Null]],

		Flatten@(Which[
			(* if sample, standard or blank is specified, get the sample objects, and gradient objects *)
			MatchQ[#[[1]], InjectionTableSampleTypeP],
			Flatten[Cases[#[[{2, 5}]], ObjectP[]]],

			(* if ColumnPrime or ColumnFlush is specified, get the gradient objects *)
			MatchQ[#[[1]], InjectionTableCleaningTypeP],
			Flatten[Cases[ToList@#[[3]], ObjectP[]]],

			True,
			Null
		]& /@ anionInjectionTableLookup),

		(*otherwise, we can just say Null*)
		Null
	];

	(*if injection table is specified, need to check all of the column and gradient objects within*)
	cationInjectionTableObjects = If[MatchQ[cationInjectionTableLookup, Except[Automatic | Null]],

		Flatten@(Which[
			(* if sample, standard or blank is specified, get the sample objects, and gradient objects *)
			MatchQ[#[[1]], InjectionTableSampleTypeP],
			Flatten[Cases[#[[{2, 5}]], ObjectP[]]],

			(* if ColumnPrime or ColumnFlush is specified, get the gradient objects *)
			MatchQ[#[[1]], InjectionTableCleaningTypeP],
			Flatten[Cases[ToList@#[[3]], ObjectP[]]],

			True,
			Null
		]& /@ cationInjectionTableLookup),

		(*otherwise, we can just say Null*)
		Null
	];

	(*if injection table is specified, need to check all of the column and gradient objects within*)
	electrochemicalInjectionTableObjects = If[MatchQ[electrochemicalInjectionTableLookup, Except[Automatic | Null]],

		Flatten@(Which[
			(* if sample, standard or blank is specified, get the sample objects, gradient objects and the waveform objects *)
			MatchQ[#[[1]], InjectionTableSampleTypeP],
			Flatten[Cases[#[[{2, 4, 5}]], ObjectP[]]],

			(* if ColumnPrime or ColumnFlush is specified, get the gradient objects *)
			MatchQ[#[[1]], InjectionTableCleaningTypeP],
			Flatten[Cases[#[[{3, 4}]], ObjectP[]]],

			True,
			Null
		]& /@ electrochemicalInjectionTableLookup),

		(*otherwise, we can just say Null*)
		Null
	];

	(* Extract any objects that the user has explicitly specified *)
	userSpecifiedObjects = DeleteDuplicates@Cases[
		Flatten@Join[ToList[mySamplesWithPreparedSamples], Lookup[ToList[myOptionsWithPreparedSamples], optionsWithObjects, Null], ToList@anionInjectionTableObjects, ToList@cationInjectionTableObjects, ToList@electrochemicalInjectionTableObjects],
		ObjectP[]
	];

	(* Check that the specified objects exist or are visible to the current user *)
	simulatedSampleQ = If[MatchQ[updatedSimulation, {}|Null],
		Table[False, Length[userSpecifiedObjects]],
		MemberQ[Download[Lookup[updatedSimulation[[1]], Packets],Object], #] &/@userSpecifiedObjects
	];
	objectsExistQs = DatabaseMemberQ[PickList[userSpecifiedObjects, simulatedSampleQ, False]];

	(* Build tests for object existence *)
	objectsExistTests = If[gatherTests,
		MapThread[
			Test[StringTemplate["Specified object `1` exists in the database:"][#1], #2, True]&,
			{PickList[userSpecifiedObjects, simulatedSampleQ, False], objectsExistQs}
		],
		{}
	];

	(* If objects do not exist, return failure *)
	If[!(And @@ objectsExistQs),
		If[!gatherTests,
			Message[Error::ObjectDoesNotExist, PickList[PickList[userSpecifiedObjects, simulatedSampleQ, False], objectsExistQs, False]];
			Message[Error::InvalidInput, PickList[PickList[userSpecifiedObjects, simulatedSampleQ, False], objectsExistQs, False]]
		];
		Return[outputSpecification /. {
			Result -> $Failed,
			Tests -> Join[safeOpsTests, validLengthTests, templateTests, objectsExistTests],
			Options -> $Failed,
			Preview -> Null
		}]
	];

	(*all the instruments to use*)
	availableInstruments = {
		Model[Instrument, IonChromatography, "id:M8n3rx0K7LJG"],
		Model[Instrument, IonChromatography, "id:9RdZXv1R0Pkl"],
		Object[Instrument, IonChromatography, "id:WNa4ZjK6d8Jq"],
		Object[Instrument, IonChromatography, "id:GmzlKjPmo4W4"]
	};

	lcVialModels = allLCCompatibleVialSearch["Memoization"];

	(* Flatten and merge all possible objects needed into a list *)
	allObjects = DeleteDuplicates@Download[
		Cases[
			Flatten@Join[
				mySamplesWithPreparedSamples,
				(* Default objects *)
				{
					(* == Default IC columns == *)
					(* Dionex IonPac AG18-Fast-4 Micron IC Guard Column (2x30mm) *)
					Model[Item, Column, "id:xRO9n3BDm765"],
					(* Dionex IonPac AS18-Fast IC Analytical Column *)
					Model[Item, Column, "id:6V0npvm3W4za"],
					(* Dionex IonPac CG16 4Micron IC Guard Column *)
					Model[Item, Column, "id:1ZA60vL3WjA5"],
					(* Dionex IonPac CS16 4Micron IC Analytical Column *)
					Model[Item, Column, "id:Z1lqpMz94jlL"],
					(* Dionex CarboPac PA10 Analytical Column *)
					Model[Item, Column, "id:wqW9BP78Xnl4"],
					(* Dionex CarboPac PA10 Guard Column *)
					Model[Item, Column, "id:Vrbp1jKPW6JW"],

					(* == Default containers == *)
					(* 96-well 2mL Deep Well Plate *)
					Model[Container, Plate, "id:L8kPEjkmLbvW"],
					lcVialModels,

					(* == Instruments == *)
					availableInstruments,

					(* == Default Buffers == *)
					(* Milli-Q water *)
					Model[Sample, "id:8qZ1VWNmdLBD"],
					(* 50 mM MSA (Methanesulfonic Acid) *)
					Model[Sample, StockSolution, "id:01G6nvwndaR7"],
					(* 100 mM NaOH, LCMS Grade *)
					Model[Sample, StockSolution, "id:vXl9j57xDEed"],

					(* == Default pH Calibration Buffers == *)
					(* Reference buffer, pH 7 *)
					Model[Sample, "id:E8zoYveRllov"],
					(* Reference buffer, pH 10 *)
					Model[Sample, "id:1ZA60vwjbbV8"],

					(* == Default Electrodes == *)
					(* Dionex Disposable Gold on PTFE Electrode *)
					Model[Item, Electrode, "Dionex Disposable Gold on PTFE Electrode"],

					(* == Default Waveforms == *)
					(* Gold Electrode Quad Potential for Carbohydrate Analysis *)
					Object[Method, Waveform, "Gold Electrode Quad Potential for Carbohydrate Analysis"],
					(* Silver Electrode for Sulfide, Cyanide, Iodide, Thiosulface Analysis *)
					Object[Method, Waveform, "Silver Electrode for Sulfide, Cyanide, Iodide, Thiosulface Analysis"],
					(* Platinum Electrode for Alcohols, Glycols, Carboxylates, Cyanide, Sulfide Analysis *)
					Object[Method, Waveform, "Platinum Electrode for Alcohols, Glycols, Carboxylates, Cyanide, Sulfide Analysis"],

					(* == Default Standards == *)
					(* Multielement Ion Chromatography Anion Standard Solution *)
					Model[Sample, "id:dORYzZJkKY6D"],
					(* Multi Cation Standard 1 for I *)
					Model[Sample, "id:M8n3rx0mDjZR"],
					(* Glucose solution (5 g/L) *)
					Model[Sample, StockSolution, "id:Z1lqpMzx0wV5"],

					(* == Default system prime and flush gradients == *)
					(* ICS 6000 System Prime Method - Anion Channel *)
					Object[Method, IonChromatographyGradient, "id:pZx9jo8DrEv0"],
					(* ICS 6000 System Prime Method - Cation Channel *)
					Object[Method, IonChromatographyGradient, "id:4pO6dM5r7JBo"],
					(* ICS 6000 System Flush Method - Anion Channel *)
					Object[Method, IonChromatographyGradient, "id:Vrbp1jKPZJNx"],
					(* ICS 6000 System Flush Method - Cation Channel *)
					Object[Method, IonChromatographyGradient, "id:XnlV5jKWerJ8"],
					(* ICS 6000 2 System Prime Method *)
					Object[Method, Gradient, "ICS 6000 with ED-UVVis Detectors System Prime Method"],
					(* ICS 6000 2 System Flush Method *)
					Object[Method, Gradient, "ICS 6000 with ED-UVVis Detectors System Flush Method"]

				},
				(* All options that _could_ have an object *)
				Lookup[expandedSafeOps, optionsWithObjects],

				(*also include anything within the injection table*)
				If[!NullQ[anionInjectionTableObjects], anionInjectionTableObjects, {}],
				If[!NullQ[cationInjectionTableObjects], cationInjectionTableObjects, {}],
				If[!NullQ[electrochemicalInjectionTableObjects], electrochemicalInjectionTableObjects, {}],
				userSpecifiedObjects
			],
			ObjectP[]
		],
		Object,
		Date -> Now
	];

	(* Isolate objects of particular types so we can build a indexed-download call *)
	sampleObjects = Cases[allObjects, NonSelfContainedSampleP];
	modelSampleObjects = Cases[allObjects, ObjectP[Model[Sample]]];
	modelContainerObjects = Cases[allObjects, ObjectP[Model[Container]]];
	instrumentObjects = Cases[allObjects, ObjectP[Object[Instrument, IonChromatography]]];
	modelInstrumentObjects = Cases[allObjects, ObjectP[Model[Instrument, IonChromatography]]];
	columnObjects = Cases[allObjects, ObjectP[Object[Item, Column]]];
	modelColumnObjects = Cases[allObjects, ObjectP[Model[Item, Column]]];
	gradientObjects = Cases[allObjects, ObjectP[{Object[Method, IonChromatographyGradient], Object[Method, Gradient]}]];
	standardAndBufferModels = Cases[allObjects, ObjectP[Model[Sample]]];
	electrodeObjects = Cases[allObjects, ObjectP[Object[Item, Electrode]]];
	modelElectrodeObjects = Cases[allObjects, ObjectP[Model[Item, Electrode]]];
	waveformObjects = Cases[allObjects, ObjectP[Object[Method, Waveform]]];

	(* Combine our downloaded and simulated cache. *)
	(* It is important that the sample preparation cache is added first to the cache ball, before the main download. *)
	cacheBall = DeleteCases[
		Quiet[
			FlattenCachePackets[
				{
					Download[
						{
							sampleObjects,
							modelSampleObjects,
							modelContainerObjects,
							instrumentObjects,
							modelInstrumentObjects,
							columnObjects,
							modelColumnObjects,
							gradientObjects,
							standardAndBufferModels,
							electrodeObjects,
							modelElectrodeObjects,
							waveformObjects
						},
						{
							sampleFields,
							modelSamplePackets,
							modelContainerFieldsPacket,
							instrumentFields,
							modelInstrumentFields,
							columnFields,
							modelColumnFields,
							gradientFields,
							{Packet[Object, Name]},
							electrodeFields,
							modelElectrodeFields,
							waveformFields
						},
						Cache -> cache,
						Simulation -> updatedSimulation,
						Date -> Now
					]
				}
			],
			{Download::FieldDoesntExist, Download::NotLinkField}
		],
		Null
	];

	(* Build the resolved options *)
	resolvedOptionsResult = If[gatherTests,

		{resolvedOptions, resolvedOptionsTests} = resolveExperimentIonChromatographyOptions[ToList[mySamplesWithPreparedSamples], expandedSafeOps, Cache -> cacheBall, Simulation -> updatedSimulation, Output -> {Result, Tests}];

		(* Therefore, we have to run the tests to see if we encountered a failure. *)
		If[RunUnitTest[<|"Tests" -> resolvedOptionsTests|>, OutputFormat -> SingleBoolean, Verbose -> False],
			{resolvedOptions, resolvedOptionsTests},
			$Failed
		],

		(* We are not gathering tests. Simply check for Error::InvalidInput and Error::InvalidOption. *)
		Check[
			{resolvedOptions, resolvedOptionsTests} = {resolveExperimentIonChromatographyOptions[ToList[mySamplesWithPreparedSamples], expandedSafeOps, Cache -> cacheBall, Simulation -> updatedSimulation], {}},
			$Failed,
			{Error::InvalidInput, Error::InvalidOption}
		]
	];

	(* Collapse the resolved options *)
	(* One edge case here: if the user put two water objects as blanks, Blank Option will also be collapsed here *)
	(* So we need to first take out the Blank and Stsandard options before collapsing *)
	collapsedResolvedOptions = If[MatchQ[resolvedOptions, $Failed],
		{},
		Quiet[
			CollapseIndexMatchedOptions[
				ExperimentIonChromatography,
				Normal@KeyDrop[resolvedOptions, {AnionSamples, CationSamples, ElectrochemicalSamples, Standard, AnionStandard, CationStandard, Blank, AnionBlank, CationBlank}],
				Ignore -> ToList[myOptionsWithPreparedSamples],
				Messages -> True
			],
			Warning::CannotCollapse
		]
	];

	(* Then add the blank and standard option back into the list *)
	completeCollapsedResolvedOptions = If[MatchQ[resolvedOptions, $Failed],
		{},
		Join[collapsedResolvedOptions, Normal@KeyTake[Association @@ resolvedOptions, {AnionSamples, CationSamples, ElectrochemicalSamples, Standard, AnionStandard, CationStandard, Blank, AnionBlank, CationBlank}]]
	];

	(* If option resolution failed, return early. *)
	If[MatchQ[resolvedOptionsResult, $Failed],
		Return[outputSpecification /. {
			Result -> $Failed,
			Tests -> Join[safeOpsTests, validLengthTests, templateTests, resolvedOptionsTests],
			Options -> RemoveHiddenOptions[ExperimentIonChromatography, completeCollapsedResolvedOptions],
			Preview -> Null
		}]
	];


	(* Build packets with resources *)
	{resourcePackets, resourcePacketTests} = If[gatherTests,
		experimentIonChromatographyResourcePackets[ToList[mySamplesWithPreparedSamples], expandedSafeOps, resolvedOptions, Cache -> cacheBall, Simulation -> updatedSimulation, Output -> {Result, Tests}],
		{experimentIonChromatographyResourcePackets[ToList[mySamplesWithPreparedSamples], expandedSafeOps, resolvedOptions, Cache -> cacheBall, Simulation -> updatedSimulation], {}}
	];

	(* If we don't have to return the Result, don't bother calling UploadProtocol[...]. *)
	If[!MemberQ[output, Result],
		Return[outputSpecification /. {
			Result -> Null,
			Tests -> Flatten[{safeOpsTests, validLengthTests, templateTests, resolvedOptionsTests, resourcePacketTests}],
			Options -> RemoveHiddenOptions[ExperimentIonChromatography, completeCollapsedResolvedOptions],
			Preview -> Null
		}]
	];

	(* We have to return the result. Call UploadProtocol[...] to prepare our protocol packet (and upload it if asked). *)
	protocolObject = If[!MatchQ[resourcePackets, $Failed] && !MatchQ[resolvedOptionsResult, $Failed],

		If[Length[resourcePackets] > 1,
			UploadProtocol[
				First[resourcePackets],
				DeleteDuplicates@Rest[resourcePackets],
				Upload -> Lookup[safeOps, Upload],
				Confirm -> Lookup[safeOps, Confirm],
        		CanaryBranch -> Lookup[safeOps, CanaryBranch],
				ParentProtocol -> Lookup[safeOps, ParentProtocol],
				Priority -> Lookup[safeOps, Priority],
				StartDate -> Lookup[safeOps, StartDate],
				HoldOrder -> Lookup[safeOps, HoldOrder],
				QueuePosition -> Lookup[safeOps, QueuePosition],
				ConstellationMessage -> Object[Protocol, IonChromatography],
				Cache -> cacheBall,
				Simulation -> updatedSimulation
			],
			(*otherwise just protocol packet*)
			UploadProtocol[
				First[resourcePackets],
				Upload -> Lookup[safeOps, Upload],
				Confirm -> Lookup[safeOps, Confirm],
        		CanaryBranch -> Lookup[safeOps, CanaryBranch],
				ParentProtocol -> Lookup[safeOps, ParentProtocol],
				Priority -> Lookup[safeOps, Priority],
				StartDate -> Lookup[safeOps, StartDate],
				HoldOrder -> Lookup[safeOps, HoldOrder],
				QueuePosition -> Lookup[safeOps, QueuePosition],
				ConstellationMessage -> Object[Protocol, IonChromatography],
				Cache -> cacheBall,
				Simulation -> updatedSimulation
			]
		],
		$Failed
	];

	(* Return requested output *)
	outputSpecification /. {
		Result -> protocolObject,
		Tests -> Flatten[{safeOpsTests, validLengthTests, templateTests, resolvedOptionsTests, resourcePacketTests}],
		Options -> RemoveHiddenOptions[ExperimentIonChromatography, completeCollapsedResolvedOptions],
		Preview -> Null
	}
];


(* ::Subsubsection::Closed:: *)
(*ExperimentIonChromatography Main Function - Container Overload*)


(*container overload*)
ExperimentIonChromatography[myContainers : ListableP[ObjectP[{Object[Container], Object[Sample], Model[Sample]}] | _String | {LocationPositionP, _String | ObjectP[Object[Container]]}], myOptions : OptionsPattern[]] := Module[
	{listedOptions, outputSpecification, output, gatherTests, validSamplePreparationResult, mySamplesWithPreparedSamples, myOptionsWithPreparedSamples, updatedSimulation, cache,
		containerToSampleResult, containerToSampleOutput, samples, sampleOptions, containerToSampleTests, listedContainers, containerToSampleSimulation},

	(* Determine the requested return value from the function *)
	outputSpecification = Quiet[OptionValue[Output]];
	output = ToList[outputSpecification];

	(* Determine if we should keep a running list of tests *)
	gatherTests = MemberQ[output, Tests];

		(* pull out the Cache from the specified options *)
	cache=Lookup[ToList@myOptions,Cache,{}];

  (* Make sure we're working with a list of containers and options *)
	{listedContainers, listedOptions} = {ToList[myContainers], ToList[myOptions]};

	(* First, simulate our sample preparation. *)
	validSamplePreparationResult = Check[
		(* Simulate sample preparation. *)
		{mySamplesWithPreparedSamples, myOptionsWithPreparedSamples, updatedSimulation} = simulateSamplePreparationPacketsNew[
			ExperimentIonChromatography,
			ToList[listedContainers],
			ToList[listedOptions],
      DefaultPreparedModelContainer -> Model[Container, Plate, "96-well 2mL Deep Well Plate"]
		],
		$Failed,
		{Download::ObjectDoesNotExist, Error::MissingDefineNames, Error::InvalidInput, Error::InvalidOption}
	];

	(* If we are given an invalid define name, return early. *)
	If[MatchQ[validSamplePreparationResult, $Failed],
		(* Return early. *)
		(* Note: We've already thrown a message above in simulateSamplePreparationPackets. *)
		Return[$Failed]
	];

	(* Convert our given containers into samples and sample index-matched options. *)
	containerToSampleResult = If[gatherTests,
		(* We are gathering tests. This silences any messages being thrown. *)
		{containerToSampleOutput, containerToSampleTests, containerToSampleSimulation} = containerToSampleOptions[
			ExperimentIonChromatography,
			mySamplesWithPreparedSamples,
			myOptionsWithPreparedSamples,
			Output -> {Result, Tests, Simulation},
			Cache -> cache,
			Simulation -> updatedSimulation
		];

		(* Therefore, we have to run the tests to see if we encountered a failure. *)
		If[RunUnitTest[<|"Tests" -> containerToSampleTests|>, OutputFormat -> SingleBoolean, Verbose -> False],
			Null,
			$Failed
		],

		(* We are not gathering tests. Simply check for Error::InvalidInput and Error::InvalidOption. *)
		Check[
			{containerToSampleOutput, containerToSampleSimulation} = containerToSampleOptions[
				ExperimentIonChromatography,
				mySamplesWithPreparedSamples,
				myOptionsWithPreparedSamples,
				Output -> {Result, Simulation},
				Cache -> cache,
				Simulation -> updatedSimulation
			],
			$Failed,
			{Error::EmptyContainers, Error::ContainerEmptyWells, Error::WellDoesNotExist}
		]
	];

	(* If we were given an empty container, return early. *)
	If[MatchQ[containerToSampleResult, $Failed],
		(* containerToSampleOptions failed - return $Failed *)
		outputSpecification /. {
			Result -> $Failed,
			Tests -> containerToSampleTests,
			Options -> $Failed,
			Preview -> Null
		},
		(* Split up our containerToSample result into the samples and sampleOptions. *)
		{samples, sampleOptions} = containerToSampleOutput;

		(* Call our main function with our samples and converted options. *)
		ExperimentIonChromatography[samples, ReplaceRule[sampleOptions, Simulation -> updatedSimulation]]
	]
];


(* ::Subsection::Closed:: *)
(*resolveExperimentIonChromatographyOptions *)


DefineOptions[
	resolveExperimentIonChromatographyOptions,
	Options :> {HelperOutputOption, CacheOption, SimulationOption}
];


resolveExperimentIonChromatographyOptions[mySamples : {ObjectP[Object[Sample]]...}, myOptions : {_Rule...}, myResolutionOptions : OptionsPattern[resolveExperimentIonChromatographyOptions]] :=
	Module[{
		(* All other variables *)
		safeOps, outputSpecification, output, gatherTests, messagesQ, notInEngine, cache, samplePrepOptions, ionChromatographyOptions, simulatedSamples, resolvedSamplePrepOptions,
		fullCache, samplePrepTests, ionChromatographyOptionsAssociation, samplePackets, simulatedSamplePackets,

		(* INVALID INPUT CHECK *)
		discardedSamplePackets, discardedQ, discardedInvalidInputs, discardedSampleTest, sampleContainers, simulatedSampleContainers, simulatedSampleContainerModels, containerlessSamples,
		containerlessQ, containersExistTest, containerlessInvalidInputs,

		(* OPTION PRECISION CHECK *)
		anionInjectionTableLookup, cationInjectionTableLookup, anionInjectionTableSpecifiedQ, cationInjectionTableSpecifiedQ, anionInjectionTableSamples, cationInjectionTableSamples,
		inputSampleObjs, injectionTableSamples, injectionTableSampleConflictQ, roundedGradientTests, roundedOptionsAssociation, allRoundingTests, roundedCationGradientOptions,
		roundedAnionGradientOptions, roundedVoltageOptions, roundedWaveformOptions, anionGradientOptions, cationGradientOptions, volumeRoundedAssociation, volumeRoundedTests,
		tempRoundedAssociation, tempRoundedTests, voltageRoundedAssociation, voltageRoundedTests, currentRoundedAssociation, currentRoundedTests, samplingRateOptions, currentOptions,
		voltageOptions, tempOptions, volumeOptions, timeRoundedAssociation, timeRoundedTests, timeOptions, samplingRateRoundedAssociation, samplingRateRoundedTests, waveformOptions,
		voltageProfileOptions,

		(* CONFLICTING OPTION CHECK *)
		specifiedInstrument, specifiedAnionSamples, specifiedCationSamples, specifiedAnionColumn, specifiedCationColumn, specifiedAnionGuardColumn,
		specifiedCationGuardColumn, specifiedNumberOfReplicates, specifiedSampleTemperature,
		specifiedBufferA, specifiedBufferB, specifiedBufferC, specifiedBufferD, specifiedNeedleWashSolution, specifiedStandard, specifiedAnionStandard, specifiedCationStandard, specifiedAnionStandardFrequency,
		specifiedCationStandardFrequency, specifiedBlank, specifiedAnionBlank, specifiedCationBlank, specifiedAnionBlankFrequency,
		specifiedCationBlankFrequency, specifiedAnionColumnRefreshFrequency, specifiedCationColumnRefreshFrequency, specifiedAnionColumnPrimeTemperature,
		specifiedCationColumnPrimeTemperature, specifiedColumnPrimeEluentGradient, specifiedAnionColumnPrimeDuration, specifiedAnionColumnPrimeGradient, specifiedColumnPrimeGradientA, specifiedColumnPrimeGradientB,
		specifiedColumnPrimeGradientC, specifiedColumnPrimeGradientD, specifiedCationColumnPrimeDuration, specifiedCationColumnPrimeGradient, specifiedAnionColumnPrimeFlowRate, specifiedCationColumnPrimeFlowRate,
		specifiedAnionColumnPrimeSuppressorCurrent, specifiedCationColumnPrimeSuppressorCurrent, specifiedAnionColumnPrimeDetectionTemperature, specifiedCationColumnPrimeDetectionTemperature,
		specifiedAnionColumnFlushTemperature, specifiedCationColumnFlushTemperature, specifiedColumnFlushEluentGradient, specifiedAnionColumnFlushDuration, specifiedAnionColumnFlushGradient,
		specifiedColumnFlushGradientA, specifiedColumnFlushGradientB, specifiedColumnFlushGradientC, specifiedColumnFlushGradientD, specifiedCationColumnFlushDuration, specifiedCationColumnFlushGradient,
		specifiedAnionColumnFlushFlowRate, specifiedCationColumnFlushFlowRate, specifiedAnionColumnFlushSuppressorCurrent, specifiedCationColumnFlushSuppressorCurrent, specifiedAnionColumnFlushDetectionTemperature,
		specifiedCationColumnFlushDetectionTemperature, name, validNameQ, nameInvalidOptions, validNameTest, specifiedBufferAStorageCondition, specifiedBufferBStorageCondition, specifiedBufferCStorageCondition,
		specifiedBufferDStorageCondition, specifiedAnionColumnPrimeSuppressorMode, specifiedAnionColumnPrimeSuppressorVoltage, specifiedCationColumnPrimeSuppressorMode,
		specifiedCationColumnPrimeSuppressorVoltage, specifiedAnionColumnFlushSuppressorMode, specifiedAnionColumnFlushSuppressorVoltage, specifiedCationColumnFlushSuppressorMode,
		specifiedCationColumnFlushSuppressorVoltage, specifiedColumn, specifiedGuardColumn, specifiedStandardFrequency, specifiedBlankFrequency, specifiedColumnRefreshFrequency, specifiedCationColumnPrimeStart,
		specifiedCationColumnPrimeEnd, specifiedCationColumnFlushStart, specifiedCationColumnFlushEnd, specifiedAnionColumnPrimeStart, specifiedAnionColumnPrimeEnd, specifiedAnionColumnFlushStart,
		specifiedAnionColumnFlushEnd, specifiedCationColumnPrimeGradientA, specifiedCationColumnPrimeGradientB, specifiedCationColumnPrimeGradientC, specifiedCationColumnPrimeGradientD,
		specifiedCationColumnFlushGradientA, specifiedCationColumnFlushGradientB, specifiedCationColumnFlushGradientC, specifiedCationColumnFlushGradientD, specifiedColumnPrimeTemperature,
		specifiedColumnPrimeStart, specifiedColumnPrimeEnd, specifiedColumnPrimeDuration, specifiedColumnPrimeGradient, specifiedColumnPrimeFlowRate, specifiedColumnPrimeAbsorbanceWavelength,
		specifiedColumnPrimeAbsorbanceSamplingRate, specifiedColumnPrimeElectrochemicalDetectionMode, specifiedColumnPrimeReferenceElectrodeMode,
		specifiedColumnPrimeVoltageProfile, specifiedColumnPrimeWaveformProfile, specifiedColumnPrimeElectrochemicalSamplingRate, specifiedColumnPrimeDetectionTemperature,
		specifiedColumnFlushTemperature, specifiedColumnFlushStart, specifiedColumnFlushEnd, specifiedColumnFlushDuration, specifiedColumnFlushGradient, specifiedColumnFlushFlowRate,
		specifiedColumnFlushAbsorbanceWavelength, specifiedColumnFlushAbsorbanceSamplingRate, specifiedColumnFlushElectrochemicalDetectionMode,
		specifiedColumnFlushReferenceElectrodeMode, specifiedColumnFlushVoltageProfile, specifiedColumnFlushWaveformProfile, specifiedColumnFlushElectrochemicalSamplingRate, specifiedColumnFlushDetectionTemperature,


		(* RESOLVE EXPERIMENT OPTIONS *)
		resolvedInstrument, mapThreadFriendlyOptions, anionInjectionTableLookupRounded, cationInjectionTableLookupRounded, resolvedAnalysisChannel, imbalancedAnionCationGroupingErrors,
		imbalancedAnionCationGroupingOption, repeatedGroupingTests, resolvedAnionSamples, resolvedCationSamples, resolvedElectrochemicalSamples, resolvedChannelSelection, resolvedAnionColumn, resolvedCationColumn, resolvedAnionColumnModelPacket,
		preferredAnionGuardColumn, resolvedAnionGuardColumn, resolvedAnionGuardColumnModelPacket, resolvedCationColumnModelPacket, preferredCationGuardColumn, resolvedCationGuardColumn,
		resolvedCationGuardColumnModelPacket, anionSampleOption, cationSampleOption, extractedAnionSamplesOptions, extractedCationSamplesOptions, mapThreadFriendlyAnionSampleOptions,
		mapThreadFriendlyCationSampleOptions, resolvedAnionColumnTemperature, resolvedCationColumnTemperature, resolvedNumberOfReplicates, resolvedSampleTemperature, maxInjectionVolume, autosamplerDeadVolume,
		minColumnFlowRate, maxColumnFlowRate, resolvedAnionInjectionVolume, resolvedCationInjectionVolume, invalidAnionFlowRateTests, notSpecifiedCationGradientDuration, notSpecifiedCationGradientDurationOptions,
		anionSampleMustOptions, anionSampleOptionSpecifiedBool, anionAliquotVolumeMapThreadFriendly, cationAliquotVolumeMapThreadFriendly, anionSampleInInjectionTable, anionSampleExistsQ,
		anionSampleConflictQ, invalidAnionSampleConflictOptions, anionSampleConflictTest, resolvedAnionStandardInjectionVolume, anionFlowRateErrors, incompatibleAnionFlowRateOptions, incompatibleCationFlowRateOptions,
		resolvedCationStandardInjectionVolume, minAnionFlowRate, maxAnionFlowRate, anionDurationOptionSpecifiedErrors, anionDurationConsistentErrors, notSpecifiedCationGradientDurationTests,
		optimalAnionColumnFlowRate, resolvedAnionGradientStart, resolvedAnionGradientEnd, resolvedAnionGradientDuration, resolvedAnionEquilibrationTime, resolvedAnionFlushTime, resolvedAnionFlowRate,
		resolvedEluentGradient, resolvedAnionGradient, anionGradientStartEndSpecifiedErrors, anionGradientConsistentErrors, invalidAnionGradientCompositionErrors, cationFlowRateErrors,
		anionRemovedExtraErrors, cationSampleMustOptions, cationSampleOptionSpecifiedBool, cationSampleInInjectionTable, cationSampleExistsQ, cationSampleConflictQ, invalidCationSampleConflictOptions,
		cationSampleConflictTest, cationGradientObjectPositions, cationGradientObjects, cationGradientPackets, bufferAInFirstGradient, bufferBInFirstGradient, bufferCInFirstGradient,
		bufferDInFirstGradient, calculateICBufferConcentration, resolvedBufferA, resolvedBufferB, resolvedBufferC, resolvedBufferD, bufferAConcentration, bufferBConcentration, bufferCConcentration, bufferDConcentration, minFlowRate,
		maxFlowRate, optimalColumnFlowRate, resolvedCationGradientStart, resolvedCationGradientEnd, resolvedCationGradientDuration, resolvedCationEquilibrationTime, resolvedCationFlushTime,
		resolvedCationFlowRate, resolvedCationGradientA, resolvedCationGradientB, resolvedCationGradientC, resolvedCationGradientD, resolvedCationGradient, inconsistentCationGradientDuration,
		cationGradientStartEndSpecifiedErrors, cationGradientConsistentErrors, invalidCationGradientCompositionErrors, cationRemovedExtraErrors, resolvedAnionSuppressorCurrent,
		resolvedAnionDetectionTemperature, conflictingAnionSuppressorModeErrors, conflictingAnionSuppressorModeSamples, conflictingAnionSuppressorModeOptions, anionSuppressorModeTests,
		cationSuppressorRecommendedVoltage, maxCationSuppressorVoltage, invalidCationFlowRateTests, cationSuppressorSpecificFactor, resolvedCationSuppressorMode, resolvedCationSuppressorVoltage,
		resolvedCationSuppressorCurrent, resolvedCationDetectionTemperature, anionStandardGradientStartEndSpecifiedErrors, notSpecifiedAnionStandardGradientStartEnd,
		conflictingCationSuppressorModeErrors, conflictingCationSuppressorModeSamples, conflictingCationSuppressorModeOptions, cationSuppressorModeTests, notSpecifiedAnionStandardGradientStartEndTests,
		resolvedNeedleWashSolution, anionSuppressorRecommendedVoltage, maxAnionSuppressorVoltage, maxAnionSuppressorCurrent, anionSuppressorSpecificFactor, minAnionDetectionTemperature,
		resolvedAnionSuppressorMode, resolvedAnionSuppressorVoltage, maxAnionDetectionTemperature, maxCationSuppressorCurrent, minCationDetectionTemperature, maxCationDetectionTemperature, anionStandardOptionNames,
		cationStandardOptionNames, anionInjectionTableTypes, cationInjectionTableTypes, dualChannelStandardOptionSpecifiedBool, notSpecifiedAnionStandardGradientStartEndOptions,
		standardExistsQ, standardConflictOptions, standardConflictQ, invalidStandardConflictOptions, standardConflictTest, resolvedStandardInjectionVolume, inconsistentCationGradientDurationOptions,
		anionStandardOptionSpecifiedBool, anionStandardInInjectionTable, anionStandardExistsQ, anionStandardConflictQ, invalidAnionStandardConflictOptions, anionStandardConflictTest, cationStandardOptionSpecifiedBool,
		cationStandardInInjectionTable, cationStandardExistsQ, cationStandardConflictQ, invalidCationStandardConflictOptions, cationStandardConflictTest, resolvedStandard, standardMapThreadOption, anionStandardMapThreadOption,
		cationStandardMapThreadOption, extractedStandardOptions, extractedAnionStandardOptions, extractedCationStandardOptions, mapThreadFriendlyStandardOptions, initiallyResolvedStandardAnalysisChannel, resolvedStandardModelPackets,
		defaultAnionStandardPosition, defaultCationStandardPosition, resolvedStandardAnalysisChannel, imbalancedStandardAnionCationGroupingErrors, imbalancedStandardAnionCationGroupingOption, repeatedStandardGroupingTests,
		allStandardWithSpecifiedChannel, anionStandardWithSpecifiedChannel, consistentAnionStandardChannelQ, invalidAnionStandardChannelSpecification, inconsistentAnionStandardChannelOption,
		anionStandardChannelSpecificationTests, resolvedAnionStandard, cationStandardWithSpecifiedChannel, consistentCationStandardChannelQ, invalidCationStandardChannelSpecification, inconsistentCationStandardChannelOption,
		cationStandardChannelSpecificationTests, totalStandard, totalResolvedStandard, totalStandardConsistentQ, invalidStandardGroupingOption, standardGroupingTests, resolvedCationStandard, anionStandardExistQ,
		cationStandardExistQ, allBlankWithSpecifiedChannel, anionBlankWithSpecifiedChannel, consistentAnionBlankChannelQ, invalidAnionBlankChannelSpecification, inconsistentAnionBlankChannelOption,
		anionBlankChannelSpecificationTests, cationBlankWithSpecifiedChannel, consistentCationBlankChannelQ, invalidCationBlankChannelSpecification, inconsistentCationBlankChannelOption, cationBlankChannelSpecificationTests,
		totalBlank, totalResolvedBlank, totalBlankConsistentQ, invalidBlankGroupingOption, blankGroupingTests, mapThreadFriendlyAnionStandardOptions, minCationSuppressorFlowRate, maxCationSuppressorFlowRate,
		notSpecifiedAnionGradientStartEnd, notSpecifiedAnionGradientStartEndOptions, notSpecifiedAnionGradientStartEndTests, inconsistentGradientAnionSamples, inconsistentAnionGradientOptions,
		inconsistentAnionGradientTests, invalidGradientCompositionAnionSamples, maxEluentConcentration, invalidAnionGradientCompositionOptions, invalidAnionGradientTests, incompatibleAnionStandardFlowRateOptions,
		notSpecifiedCationGradientStartEnd, notSpecifiedCationGradientStartEndOptions, notSpecifiedCationGradientStartEndTests, inconsistentGradientCationSamples, incompatibleCationStandardFlowRateOptions,
		inconsistentCationGradientOptions, inconsistentCationGradientTests, invalidGradientCompositionCationSamples, invalidCationGradientCompositionOptions, invalidCationGradientTests,
		mapThreadFriendlyCationStandardOptions, resolvedAnionStandardFrequency, invalidAnionStandardFlowRateTests, resolvedCationStandardFrequency, resolvedAnionStandardGradientDuration, invalidCationStandardFlowRateTests,
		resolvedAnionStandardFlowRate, resolvedStandardEluentGradient, resolvedAnionStandardGradient, anionStandardGradientConsistentErrors, invalidAnionStandardGradientCompositionErrors,
		anionStandardRemovedExtraErrors, inconsistentGradientAnionStandard, inconsistentAnionStandardGradientOptions, anionStandardFlowRateErrors, cationStandardFlowRateErrors, consistentCationGradientDurationTests,
		inconsistentAnionStandardGradientTests, invalidGradientCompositionAnionStandard, invalidAnionStandardGradientCompositionOptions, invalidAnionStandardGradientTests, resolvedAnionStandardColumnTemperature,
		resolvedAnionStandardSuppressorCurrent, resolvedAnionStandardDetectionTemperature, resolvedCationStandardGradientDuration, resolvedCationStandardFlowRate, resolvedStandardGradientA, resolvedStandardGradientB,
		resolvedStandardGradientC, resolvedStandardGradientD, resolvedAnionStandardSuppressorMode, resolvedAnionStandardSuppressorVoltage, conflictingAnionStandardSuppressorModeErrors, notSpecifiedGradientDuration,
		conflictingAnionSuppressorModeStandards, conflictingAnionStandardSuppressorModeOptions, anionStandardSuppressorModeTests, resolvedCationStandardGradient, cationStandardGradientConsistentErrors,
		invalidAnionBlankFlowRateTests, invalidCationStandardGradientCompositionErrors, cationStandardRemovedExtraErrors, anionBlankFlowRateErrors, cationBlankFlowRateErrors, incompatibleAnionBlankFlowRateOptions,
		incompatibleCationBlankFlowRateOptions, inconsistentGradientCationStandards, inconsistentCationStandardGradientOptions, inconsistentCationStandardGradientTests, invalidGradientCompositionCationStandard,
		invalidCationStandardGradientCompositionOptions, invalidCationStandardGradientTests, resolvedCationStandardColumnTemperature, resolvedCationStandardSuppressorMode, resolvedCationStandardSuppressorVoltage,
		conflictingCationStandardSuppressorModeErrors, incompatibleCationStandardSuppressorVoltageErrors, conflictingCationSuppressorModeStandards, conflictingCationStandardSuppressorModeOptions,
		cationStandardSuppressorModeTests, resolvedCationStandardSuppressorCurrent, resolvedCationStandardDetectionTemperature, incompatibleCationStandardColumnTemperatureErrors, incompatibleCationStandardSuppressorCurrentErrors,
		incompatibleCationStandardDetectionTemperatureErrors, anionBlankOptionNames, cationBlankOptionNames, blankOptionSpecifiedBool, blankExistsQ, blankConflictOptions, blankConflictQ, invalidBlankConflictOptions,
		blankConflictTest, anionBlankOptionSpecifiedBool, anionBlankInInjectionTable, anionBlankExistsQ, anionBlankConflictQ, invalidAnionBlankConflictOptions, anionBlankConflictTest, cationBlankOptionSpecifiedBool,
		cationBlankInInjectionTable, cationBlankExistsQ, cationBlankConflictQ, invalidCationBlankConflictOptions, cationBlankConflictTest, resolvedBlank, blankMapThreadOption, anionBlankMapThreadOption,
		cationBlankMapThreadOption, electrochemicalBlankMapThreadOption, extractedBlankOptions, extractedElectrochemicalBlankOptions, resolvedInjectionVolume, resolvedAnionStandardGradientStart,
		nonRecommendedInjectionVolumeQs, recommendedInjectionVolumeTests,
		extractedAnionBlankOptions, extractedCationBlankOptions, mapThreadFriendlyBlankOptions, initiallyResolvedBlankAnalysisChannel, imbalancedBlankAnionCationGroupingErrors, imbalancedBlankAnionCationGroupingOption,
		repeatedBlankGroupingTests, resolvedAnionBlank, resolvedCationBlank, anionBlankExistQ, cationBlankExistQ, mapThreadFriendlyAnionBlankOptions, mapThreadFriendlyCationBlankOptions, resolvedAnionBlankFrequency,
		resolvedCationBlankFrequency, invalidCationBlankFlowRateTests, cationColumnPrimeFlowRateErrors, resolvedAnionStandardGradientEnd, notSpecifiedAnionGradientDuration, notSpecifiedGradientDurationOptions,
		notSpecifiedAnionGradientDurationOptions, notSpecifiedAnionGradientDurationTests, resolvedAnionBlankGradientDuration, resolvedAnionBlankFlowRate, resolvedBlankEluentGradient, resolvedAnionBlankGradient,
		anionBlankGradientConsistentErrors, invalidAnionBlankGradientCompositionErrors, anionBlankRemovedExtraErrors, anionColumnPrimeFlowRateErrors, anionColumnFlushFlowRateErrors,
		inconsistentGradientAnionBlank, inconsistentAnionBlankGradientOptions, inconsistentAnionBlankGradientTests, invalidGradientCompositionAnionBlank, invalidAnionBlankGradientCompositionOptions,
		invalidAnionBlankGradientTests, resolvedAnionBlankSuppressorMode, resolvedAnionBlankSuppressorVoltage, conflictingAnionBlankSuppressorModeErrors, notSpecifiedGradientDurationTests,
		resolvedAnionBlankColumnTemperature, resolvedAnionBlankSuppressorCurrent, resolvedAnionBlankDetectionTemperature, conflictingAnionSuppressorModeBlanks, conflictingAnionBlankSuppressorModeOptions,
		anionBlankSuppressorModeTests, resolvedBlankAnalysisChannel, resolvedCationBlankGradientDuration, resolvedCationBlankFlowRate, resolvedBlankGradientA, resolvedBlankGradientB,
		resolvedBlankGradientC, resolvedBlankGradientD, resolvedCationBlankGradient, cationBlankGradientConsistentErrors, invalidCationBlankGradientCompositionErrors, cationColumnFlushFlowRateErrors,
		cationBlankRemovedExtraErrors, inconsistentGradientCationBlanks, inconsistentCationBlankGradientOptions, inconsistentGradientDuration,
		inconsistentCationBlankGradientTests, invalidGradientCompositionCationBlank, invalidCationBlankGradientCompositionOptions, invalidCationBlankGradientTests, resolvedCationBlankColumnTemperature,
		resolvedCationBlankSuppressorCurrent, resolvedCationBlankSuppressorMode, resolvedCationBlankSuppressorVoltage, conflictingCationBlankSuppressorModeErrors, consistentAnionGradientDurationTests,
		conflictingCationSuppressorModeBlanks, conflictingCationBlankSuppressorModeOptions, cationBlankSuppressorModeTests, resolvedCationBlankDetectionTemperature, duplicateFreeBlankQ,
		anionColumnPrimeNullOutQ, cationColumnPrimeNullOutQ, anionColumnFlushNullOutQ, cationColumnFlushNullOutQ, inconsistentAnionGradientDuration, inconsistentAnionGradientDurationOptions,
		resolvedAnionColumnRefreshFrequency, resolvedCationColumnRefreshFrequency, resolvedAnionColumnPrimeTemperature, resolvedColumnPrimeEluentGradient, resolvedAnionColumnPrimeFlowRate,
		resolvedAnionColumnPrimeDuration, resolvedAnionColumnPrimeGradient, resolvedAnionColumnPrimeSuppressorCurrent, resolvedAnionColumnPrimeDetectionTemperature, anionColumnPrimeGradientConsistentErrors,
		invalidAnionColumnPrimeGradientCompositionErrors, anionColumnPrimeRemovedExtraErrors, cationDurationOptionSpecifiedErrors, cationDurationConsistentErrors, durationOptionSpecifiedErrors,
		resolvedAnionColumnFlushTemperature, resolvedColumnFlushEluentGradient, resolvedAnionColumnFlushFlowRate, resolvedAnionColumnFlushDuration, durationConsistentErrors,
		resolvedAnionColumnFlushGradient, resolvedAnionColumnFlushSuppressorCurrent, resolvedAnionColumnFlushDetectionTemperature, anionColumnFlushGradientConsistentErrors, wrongChannelOptionSpecification,
		resolvedAnionColumnFlushSuppressorMode, resolvedAnionColumnFlushSuppressorVoltage, conflictingAnionColumnFlushSuppressorModeErrors, inconsistentGradientDurationOptions, consistentGradientDurationTests,
		resolvedAnionColumnPrimeSuppressorMode, resolvedAnionColumnPrimeSuppressorVoltage, conflictingAnionColumnPrimeSuppressorModeErrors, anionStandardDurationOptionSpecifiedErrors,
		invalidAnionColumnFlushGradientCompositionErrors, anionColumnFlushRemovedExtraErrors, anionStandardDurationConsistentErrors, notSpecifiedAnionStandardGradientDuration,
		inconsistentAnionColumnPrimeGradientOptions, inconsistentAnionColumnPrimeGradientTests, notSpecifiedAnionStandardGradientDurationOptions,
		inconsistentAnionColumnFlushGradientOptions, inconsistentAnionColumnFlushGradientTests, invalidAnionColumnPrimeGradientCompositionOptions, invalidAnionColumnPrimeGradientCompositionTests,
		invalidAnionColumnFlushGradientCompositionOptions, invalidAnionColumnFlushGradientCompositionTests, notSpecifiedAnionStandardGradientDurationTests, inconsistentAnionStandardGradientDuration,
		conflictingAnionColumnPrimeSuppressorModeOptions, anionColumnPrimeSuppressorModeTests, conflictingAnionColumnFlushSuppressorModeOptions, anionColumnFlushSuppressorModeTests,
		resolvedCationColumnPrimeTemperature, resolvedColumnPrimeGradientA, resolvedColumnPrimeGradientB, inconsistentAnionStandardGradientDurationOptions, consistentAnionStandardGradientDurationTests,
		resolvedColumnPrimeGradientC, resolvedColumnPrimeGradientD, resolvedColumnFlushGradientC, resolvedColumnFlushGradientD, resolvedCationColumnPrimeSuppressorMode, maxGradientTimeLimit,
		resolvedCationColumnPrimeSuppressorVoltage, conflictingCationColumnPrimeSuppressorModeErrors, resolvedCationColumnFlushSuppressorMode, notSpecifiedAnionBlankGradientDuration,
		resolvedCationColumnFlushSuppressorVoltage, conflictingCationColumnFlushSuppressorModeErrors, conflictingCationColumnPrimeSuppressorModeOptions, notSpecifiedAnionBlankGradientDurationOptions,
		cationColumnPrimeSuppressorModeTests, conflictingCationColumnFlushSuppressorModeOptions, cationColumnFlushSuppressorModeTests, notSpecifiedAnionBlankGradientDurationTests,
		resolvedCationColumnPrimeFlowRate, resolvedCationColumnPrimeDuration, inconsistentAnionBlankGradientDuration, inconsistentAnionBlankGradientDurationOptions,
		resolvedCationColumnPrimeGradient, resolvedCationColumnPrimeSuppressorCurrent, resolvedCationColumnPrimeDetectionTemperature, cationColumnPrimeGradientConsistentErrors, initiallyResolvedStandard,
		invalidCationColumnPrimeGradientCompositionErrors, cationColumnPrimeRemovedExtraErrors, anionBlankDurationOptionSpecifiedErrors, anionBlankDurationConsistentErrors,
		resolvedCationColumnFlushTemperature, resolvedColumnFlushGradientA, resolvedColumnFlushGradientB, resolvedCationColumnFlushFlowRate, anionColumnPrimeDurationOptionSpecifiedErrors,
		resolvedCationColumnFlushDuration, resolvedCationColumnFlushGradient, resolvedCationColumnFlushSuppressorCurrent, resolvedCationColumnFlushDetectionTemperature, initiallyResolvedBlank,
		cationColumnFlushGradientConsistentErrors, invalidCationColumnFlushGradientCompositionErrors, cationColumnFlushRemovedExtraErrors, anionColumnPrimeDurationConsistentErrors,
		inconsistentCationColumnPrimeGradientOptions, anionColumnFlushDurationOptionSpecifiedErrors, anionColumnFlushDurationConsistentErrors,
		inconsistentCationColumnPrimeGradientTests, inconsistentCationColumnFlushGradientOptions, inconsistentCationColumnFlushGradientTests, invalidCationColumnPrimeGradientCompositionOptions,
		invalidCationColumnPrimeGradientCompositionTests, invalidCationColumnFlushGradientCompositionOptions, invalidCationColumnFlushGradientCompositionTests,
		resolvedAnionBlankInjectionVolume, resolvedCationBlankInjectionVolume, consistentAnionBlankGradientDurationTests,
		overwriteAnionGradientBool, overwriteCationGradientBool, overwriteAnionStandardGradientBool, overwriteCationStandardGradientBool, overwriteAnionBlankGradientBool, overwriteCationBlankGradientBool,
		overwriteAnionColumnPrimeGradientBool, overwriteAnionColumnFlushGradientBool, overwriteCationColumnPrimeGradientBool, overwriteCationColumnFlushGradientBool,
		overwriteOptionBool, injectionTableAnionBlanks, injectionTableCationBlanks, notSpecifiedAnionColumnPrimeGradientDurationOptions, notSpecifiedAnionColumnPrimeGradientDurationTests,
		injectionTableAnionStandards, injectionTableCationStandards, injectionTableAnionStandardInjectionVolumes, injectionTableCationStandardInjectionVolumes, injectionTableAnionBlankInjectionVolumes,
		injectionTableCationBlankInjectionVolumes, injectionTableAnionStandardGradients, injectionTableCationStandardGradients, injectionTableAnionBlankGradients,
		injectionTableCationBlankGradients, adjustedOverwriteAnionStandardBool, adjustedOverwriteCationStandardBool, adjustedOverwriteAnionBlankBool, adjustedOverwriteCationBlankBool,
		resolvedOptionsForInjectionTable, resolvedInjectionTable, resolvedAnionInjectionTable, resolvedCationInjectionTable, invalidInjectionTableOptions, invalidInjectionTableTests, resolvedInjectionTableAnionBlanks,
		resolvedInjectionTableAnionBlankInjectionVolumes, resolvedInjectionTableAnionBlankGradients, foreignAnionBlanksQ, foreignAnionBlankOptions, foreignAnionBlankTest,
		resolvedInjectionTableCationBlanks, resolvedInjectionTableCationBlankInjectionVolumes, resolvedInjectionTableCationBlankGradients, foreignCationBlanksQ, inconsistentAnionColumnPrimeGradientDurationOptions,
		foreignCationBlankOptions, foreignCationBlankTest, resolvedInjectionTableAnionStandards, resolvedInjectionTableAnionStandardInjectionVolumes, resolvedInjectionTableAnionStandardGradients,
		foreignAnionStandardsQ, foreignAnionStandardOptions, foreignAnionStandardTest, resolvedInjectionTableCationStandards, resolvedInjectionTableCationStandardInjectionVolumes,
		resolvedInjectionTableCationStandardGradients, foreignCationStandardsQ, foreignCationStandardOptions, foreignCationStandardTest, cationSampleGradientObjects, consistentAnionColumnPrimeGradientDurationTests,
		cationBlankGradientObjects, cationStandardGradientObjects, cationColumnPrimeGradientObject, cationColumnFlushGradientObject, cationSampleGradientsTuples, cationBlankGradientsTuples, cationStandardGradientsTuples,
		cationColumnPrimeGradientTuples, cationColumnFlushGradientTuples, cationStandardPositions, cationBlankPositions, cationColumnRefreshPositions, allCationGradientTuples, bufferAVolumePerGradient,
		bufferBVolumePerGradient, bufferCVolumePerGradient, bufferDVolumePerGradient, bufferAVolume, bufferBVolume, bufferCVolume, bufferDVolume, neededBufferAVolume, neededBufferBVolume, neededBufferCVolume,
		neededBufferDVolume, resolvedBufferAStorageCondition, resolvedBufferBStorageCondition, resolvedBufferCStorageCondition, resolvedBufferDStorageCondition, resolvedInstrumentPacket, resolvedInstrumentModelPacket,
		notRetiredInstrumentQ, notDeprecatedInstrumentQ, instrumentInvalidOption, notRetiredInstrumentTests, notDeprecatedInstruemntTests, allSamplesWithSpecifiedChannel, maxTimeAnionSampleQ,
		maxTimeCationSampleQ, maxTimeAnionStandardQ, maxTimeCationStandardQ, maxTimeAnionBlankQ, maxTimeCationBlankQ, maxTimeAnionColumnPrimeQ, maxTimeCationColumnPrimeQ, maxTimeAnionColumnFlushQ, maxTimeCationColumnFlushQ,
		anionSamplesWithSpecifiedChannel, consistentAnionChannelQ, invalidAnionChannelSpecification, minAnionSuppressorFlowRate, maxAnionSuppressorFlowRate, minEluentGeneratorFlowRate, maxEluentGeneratorFlowRate,
		inconsistentAnionChannelOption, anionChannelSpecificationTests, cationSamplesWithSpecifiedChannel, consistentCationChannelQ, invalidCationChannelSpecification, inconsistentCationChannelOption,
		cationChannelSpecificationTests, totalSample, totalResolvedSamples, totalSampleInconsistentQ, invalidSampleGroupingOption, sampleGroupingTests, specifiedAnionColumnTechniques, validAnionColumnTechniqueQ,
		anionColumnInvalidOptions, anionColumnTechniqueTests, specifiedCationColumnTechniques, validCationColumnTechniqueQ, cationColumnInvalidOptions, cationColumnTechniqueTests, specifiedAnionColumnAnalysisChannel,
		matchingAnionColumnAnalysisChannelQ, anionColumnAnalysisChannelTests, specifiedCationColumnAnalysisChannel, matchingCationColumnAnalysisChannelQ, cationColumnAnalysisChannelTests,
		specifiedAnionGuardColumnTypes, validAnionGuardColumnTypeQ, specifiedAnionGuardColumnTechniques, validAnionGuardColumnTechniqueQ, anionGuardColumnInvalidOption, anionGuardColumnTypeTests,
		anionGuardColumnTechniqueTests, specifiedCationGuardColumnTypes, validCationGuardColumnTypeQ, specifiedCationGuardColumnTechniques, validCationGuardColumnTechniqueQ, cationGuardColumnInvalidOption,
		cationGuardColumnTypeTests, cationGuardColumnTechniqueTests, electrochemicalGradientPackets, notSpecifiedAnionColumnFlushGradientDurationOptions,
		resolvedColumnTemperature, mapThreadFriendlyElectrochemicalStandardOptions, notSpecifiedAnionColumnFlushGradientDurationTests,
		validBufferAStorageConditionQ, invalidBufferAStorageConditionOptions, invalidBufferAStorageConditionTests, validBufferBStorageConditionQ, invalidBufferBStorageConditionOptions,
		invalidBufferBStorageConditionTests, validBufferCStorageConditionQ, invalidBufferCStorageConditionOptions, invalidBufferCStorageConditionTests, validBufferDStorageConditionQ, duplicateFreeStandardQ,
		invalidBufferDStorageConditionOptions, invalidBufferDStorageConditionTests, invalidInputs, invalidOptions, targetContainers, resolvedAliquotOptions, aliquotTests, resolvedExperimentOptions,
		resolvedPostProcessingOptions, resolvedOptions, resolvedStandardStorageCondition, resolvedBlankStorageCondition, aliquotOptions, allTests, duplicateStandardAnalysisChannelExpansion,
		duplicateStandardAnalysisChannel, duplicateStandardAnalysisChannelQ, duplicateBlankAnalysisChannel, duplicateBlankAnalysisChannelQ, allStandardAutomaticPositions, anionStandardObjects,
		cationStandardObjects, replacementStandardObjects, replacementStandardRule, doubleResolvedStandardAnalysisChannel, doubleResolvedBlankAnalysisChannel, duplicateBlankAnalysisChannelExpansion,
		preResolvedStandardAnalysisChannel, preResolvedBlankAnalysisChannel, resolvedInjectionTableAnionSamples, resolvedInjectionTableAnionSampleInjectionVolumes, inconsistentAnionColumnFlushGradientDurationOptions,
		resolvedInjectionTableAnionSampleGradients, foreignAnionSamplesQ, foreignAnionSampleOptions, foreignAnionSampleTest, resolvedInjectionTableCationSamples, consistentAnionColumnFlushGradientDurationTests,
		resolvedInjectionTableCationSampleInjectionVolumes, resolvedInjectionTableCationSampleGradients, foreignCationSamplesQ, foreignCationSampleOptions, standardDurationOptionSpecifiedErrors,
		foreignCationSampleTest, resolvedEmail, cationUnresolvedGradientObjectPosition, cationStandardUnresolvedGradientObjectPosition, cationBlankUnresolvedGradientObjectPosition,
		minAnionColumnFlowRate, maxAnionColumnFlowRate, cationStandardDurationOptionSpecifiedErrors, cationStandardDurationConsistentErrors, standardDurationConsistentErrors,
		maxTimesAnionSamples, maxTimesCationSamples, maxTimesAnionStandards, maxTimesCationStandards, maxTimesAnionBlanks, maxTimesCationBlanks, maxTimeAnionColumnPrime,
		maxTimeCationColumnPrime, maxTimeAnionColumnFlush, maxTimeCationColumnFlush, doubleResolvedAnionBlank, notSpecifiedCationStandardGradientDuration, notSpecifiedCationStandardGradientDurationOptions,
		doubleResolvedCationBlank, sampleContainerPackets, sampleContainerModel, resolvedInjectionVolumes, defaultAliquotContainer, resolvedAliquotQ, collapseGradient, notSpecifiedCationStandardGradientDurationTests,
		minInstrumentFlowRate, maxInstrumentFlowRate, allAnionSampleOptionCheck, inconsistentCationStandardGradientDuration, inconsistentCationStandardGradientDurationOptions,
		allCationSampleOptionCheck, noSampleWarning, consistentCationStandardGradientDurationTests, notSpecifiedStandardGradientDuration, notSpecifiedStandardGradientDurationOptions,
		cationStandardGradientOptions, cationBlankGradientOptions, notSpecifiedStandardGradientDurationTests, inconsistentStandardGradientDuration, inconsistentStandardGradientDurationOptions,
		electrochemicalOptions, electrochemicalInjectionTableLookupRounded, invalidAnalysisChannelOption, analysisChannelTests, electrochemicalInjectionTableLookup, consistentStandardGradientDurationTests,
		electrochemicalInjectionTableSpecifiedQ, electrochemicalInjectionTableSamples, electrochemicalStandardOptionsNames, sharedStandardOptionNames, dualChannelStandardOptions,
		electrochemicalStandardOptions, electrochemicalStandardOptionSpecifiedBool, electrochemicalInjectionTableTypes, electrochemicalStandardMapThreadOption, extractedElectrochemicalStandardOptions,
		sharedBlankOptionNames, electrochemicalBlankOptionNames, dualChannalBlankOptions, electrochemicalBlankOptions, electrochemicalBlankOptionSpecifiedBool, resolvedColumn, resolvedColumnModelPacket,
		preferredGuardColumn, resolvedGuardColumn, resolvedGuardColumnModelPacket, specifiedColumnTechniques, validColumnTechniqueQ, columnInvalidOptions, columnTechniqueTests, specifiedColumnAnalysisChannel,
		matchingColumnAnalysisChannelQ, columnAnalysisChannelTests, specifiedGuardColumnTypes, validGuardColumnTypeQ, specifiedGuardColumnTechniques, validGuardColumnTechniqueQ, guardColumnInvalidOption,
		guardColumnTypeTests, guardColumnTechniqueTests, electrochemicalSampleOption, extractedElectrochemicalSamplesOptions, mapThreadFriendlyElectrochemicalSampleOptions, electrochemicalSampleMustOptions,
		electrochemicalSampleOptionSpecifiedBool, electrochemicalSampleInInjectionTable, electrochemicalSampleExistsQ, electrochemicalSampleConflictQ, invalidElectrochemicalSampleConflictOptions,
		electrochemicalSampleConflictTest, electrochemicalGradientObjectPositions, electrochemicalGradientObjects, specifiedInstrumentPacket, specifiedInstrumentModelPacket,
		electrochemicalDetectionOptions, resolvedDetector, cationSampleGradientOptions, electrochemicalSampleGradientOptions, resolvedGradient, resolvedGradientStart, resolvedGradientEnd,
		resolvedGradientDuration, resolvedEquilibrationTime, resolvedFlushTime, resolvedFlowRate, resolvedGradientA, resolvedGradientB, resolvedGradientC, resolvedGradientD,
		gradientStartEndSpecifiedErrors, gradientConsistentErrors, invalidGradientCompositionErrors, removedExtraErrors, flowRateErrors, overwriteGradientBool,
		notSpecifiedGradientStartEnd, notSpecifiedGradientStartEndOptions, notSpecifiedGradientStartEndTests, inconsistentGradientSamples, inconsistentGradientOptions, inconsistentGradientTests,
		invalidGradientCompositionSamples, invalidGradientCompositionOptions, invalidGradientTests, incompatibleFlowRateOptions, invalidFlowRateTests, resolvedAbsorbanceWavelength,
		resolvedAbsorbanceSamplingRate, resolvedElectrochemicalDetectionMode, resolvedReferenceElectrodeMode, resolvedVoltageProfile, resolvedWaveformProfile,
		resolvedElectrochemicalSamplingRate, resolvedDetectionTemperature, resolvedWorkingElectrode, resolvedWorkingElectrodeStorageCondition, invalidAbsorbanceOptions, absorbanceOptionConflictErrors,
		absorbanceOptionTest, electrochemicalModeOptionConflictErrors, invalidElectrochemicalDetectionModeOptions, electrochemicalModeOptionTest, multipleDetectionModeErrors,
		waveformDetectionModeErrors, multipleWaveformDurationErrors, multipleDetectionModeOptions, multipleDetectionModeOptionTest, invalidWaveformDetectionModeOptions, invalidWaveformDetectionModeTest,
		duplicateVoltageProfileTimeErrors, duplicateWaveformProfileTimeErrors, multipleWaveformDurationSamples, multipleWaveformDurationOptions, multipleWaveformDurationTest,
		voltageProfileTimeOptions, voltageProfileTimeTest, waveformProfileTimeOptions, waveformProfileTimeTest, electrochemicalStandardExistQ, resolvedStandardFrequency, compiledStandardInjectionVolumes,
		electrochemicalStandardGradientOptions, resolvedCationStandardGradientA, resolvedCationStandardGradientB, resolvedCationStandardGradientC, resolvedCationStandardGradientD,
		resolvedCationStandardGradientStart, resolvedCationStandardGradientEnd, cationStandardGradientStartEndSpecifiedErrors, resolvedStandardGradient, resolvedStandardGradientStart,
		resolvedStandardGradientEnd, resolvedStandardGradientDuration, resolvedStandardFlowRate, standardGradientStartEndSpecifiedErrors, standardGradientConsistentErrors,
		invalidStandardGradientCompositionErrors, standardRemovedExtraErrors, standardFlowRateErrors, overwriteStandardGradientBool, notSpecifiedCationStandardGradientStartEnd,
		notSpecifiedCationStandardGradientStartEndOptions, notSpecifiedCationStandardGradientStartEndTests, inconsistentGradientStandards, inconsistentStandardGradientOptions,
		inconsistentStandardGradientTests, invalidGradientCompositionStandard, invalidStandardGradientCompositionOptions, invalidStandardGradientTests, invalidStandardFlowRateTests,
		notSpecifiedStandardGradientStartEnd, notSpecifiedStandardGradientStartEndOptions, notSpecifiedStandardGradientStartEndTests, incompatibleStandardFlowRateOptions,
		resolvedStandardColumnTemperature, resolvedStandardAbsorbanceWavelength, resolvedStandardAbsorbanceSamplingRate, resolvedStandardElectrochemicalDetectionMode,
		resolvedStandardReferenceElectrodeMode, resolvedStandardVoltageProfile, resolvedStandardWaveformProfile, resolvedStandardElectrochemicalSamplingRate,
		resolvedStandardDetectionTemperature, standardAbsorbanceOptionConflictErrors, standardElectrochemicalModeOptionConflictErrors, multipleStandardDetectionModeErrors,
		standardWaveformDetectionModeErrors, multipleStandardWaveformDurationErrors, duplicateStandardVoltageProfileTimeErrors, duplicateStandardWaveformProfileTimeErrors,
		invalidStandardAbsorbanceOptions, standardAbsorbanceOptionTest, invalidStandardElectrochemicalDetectionModeOptions, standardElectrochemicalModeOptionTest,
		multipleStandardDetectionModeOptions, multipleStandardDetectionModeOptionTest, invalidStandardWaveformDetectionModeOptions, invalidStandardWaveformDetectionModeTest,
		multipleStandardWaveformDurationSamples, multipleStandardWaveformDurationOptions, multipleStandardWaveformDurationTest, standardVoltageProfileTimeOptions, standardVoltageProfileTimeTest,
		standardWaveformProfileTimeOptions, standardWaveformProfileTimeTest, mapThreadFriendlyElectrochemicalBlankOptions, electrochemicalBlankExistQ, resolvedBlankFrequency,
		resolvedBlankInjectionVolume, resolvedAnionBlankGradientStart, resolvedAnionBlankGradientEnd, anionBlankGradientStartEndSpecifiedErrors, notSpecifiedCationBlankGradientDuration,
		notSpecifiedAnionBlankGradientStartEnd, notSpecifiedAnionBlankGradientStartEndOptions, notSpecifiedAnionBlankGradientStartEndTests, resolvedCationBlankGradientStart,
		resolvedCationBlankGradientEnd, resolvedCationBlankGradientA, resolvedCationBlankGradientB, resolvedCationBlankGradientC, resolvedCationBlankGradientD,
		cationBlankGradientStartEndSpecifiedErrors, resolvedBlankGradient, resolvedBlankGradientStart, resolvedBlankGradientEnd, resolvedBlankGradientDuration,
		resolvedBlankFlowRate, blankGradientStartEndSpecifiedErrors, blankGradientConsistentErrors, invalidBlankGradientCompositionErrors, blankRemovedExtraErrors,
		blankFlowRateErrors, overwriteBlankGradientBool, electrochemicalBlankGradientOptions, notSpecifiedCationBlankGradientStartEnd, notSpecifiedCationBlankGradientStartEndOptions,
		notSpecifiedCationBlankGradientStartEndTests, inconsistentGradientBlanks, inconsistentBlankGradientOptions, inconsistentBlankGradientTests, invalidGradientCompositionBlank,
		invalidBlankGradientCompositionOptions, invalidBlankGradientTests, incompatibleBlankFlowRateOptions, invalidBlankFlowRateTests, notSpecifiedBlankGradientStartEnd,
		notSpecifiedBlankGradientStartEndOptions, notSpecifiedBlankGradientStartEndTests, resolvedBlankColumnTemperature, resolvedBlankAbsorbanceWavelength, resolvedBlankAbsorbanceSamplingRate,
		resolvedBlankElectrochemicalDetectionMode, resolvedBlankReferenceElectrodeMode, resolvedBlankVoltageProfile, resolvedBlankWaveformProfile, notSpecifiedCationBlankGradientDurationOptions,
		resolvedBlankElectrochemicalSamplingRate, resolvedBlankDetectionTemperature, blankAbsorbanceOptionConflictErrors, blankElectrochemicalModeOptionConflictErrors, multipleBlankDetectionModeErrors,
		blankWaveformDetectionModeErrors, multipleBlankWaveformDurationErrors, duplicateBlankVoltageProfileTimeErrors, duplicateBlankWaveformProfileTimeErrors, invalidBlankAbsorbanceOptions,
		blankAbsorbanceOptionTest, invalidBlankElectrochemicalDetectionModeOptions, blankElectrochemicalModeOptionTest, multipleBlankDetectionModeOptions, multipleBlankDetectionModeOptionTest,
		invalidBlankWaveformDetectionModeOptions, invalidBlankWaveformDetectionModeTest, multipleBlankWaveformDurationSamples, multipleBlankWaveformDurationOptions, multipleBlankWaveformDurationTest,
		blankVoltageProfileTimeOptions, blankVoltageProfileTimeTest, blankWaveformProfileTimeOptions, blankWaveformProfileTimeTest, columnPrimeNullOutQ, columnFlushNullOutQ,
		resolvedColumnRefreshFrequency, resolvedAnionColumnPrimeStart, resolvedAnionColumnPrimeEnd, anionColumnPrimeStartEndSpecifiedErrors, resolvedAnionColumnFlushStart,
		resolvedAnionColumnFlushEnd, anionColumnFlushStartEndSpecifiedErrors, resolvedCationColumnPrimeGradientA, resolvedCationColumnPrimeGradientB, resolvedCationColumnPrimeGradientC,
		resolvedCationColumnPrimeGradientD, resolvedCationColumnPrimeStart, resolvedCationColumnPrimeEnd, cationColumnPrimeStartEndSpecifiedErrors, resolvedCationColumnFlushGradientA,
		resolvedCationColumnFlushGradientB, resolvedCationColumnFlushGradientC, resolvedCationColumnFlushGradientD, resolvedCationColumnFlushStart, resolvedCationColumnFlushEnd,
		cationColumnFlushStartEndSpecifiedErrors, notSpecifiedCationColumnPrimeGradientStartEndOptions, notSpecifiedCationColumnPrimeGradientStartEndTests,
		notSpecifiedCationColumnFlushGradientStartEndOptions, notSpecifiedCationColumnFlushGradientStartEndTests, notSpecifiedAnionColumnPrimeGradientStartEndOptions,
		notSpecifiedAnionColumnPrimeGradientStartEndTests, notSpecifiedAnionColumnFlushGradientStartEndOptions, notSpecifiedAnionColumnFlushGradientStartEndTests,
		resolvedColumnPrimeTemperature, resolvedColumnPrimeGradient, resolvedColumnPrimeFlowRate, resolvedColumnPrimeStart, resolvedColumnPrimeEnd, resolvedColumnPrimeDuration,
		resolvedColumnPrimeAbsorbanceWavelength, resolvedColumnPrimeAbsorbanceSamplingRate, resolvedColumnPrimeElectrochemicalDetectionMode, notSpecifiedCationBlankGradientDurationTests,
		resolvedColumnPrimeReferenceElectrodeMode, resolvedColumnPrimeVoltageProfile, resolvedColumnPrimeWaveformProfile, resolvedColumnPrimeElectrochemicalSamplingRate,
		resolvedColumnPrimeDetectionTemperature, columnPrimeGradientConsistentErrors, columnPrimeStartEndSpecifiedErrors, invalidColumnPrimeGradientCompositionErrors,
		columnPrimeRemovedExtraErrors, columnPrimeFlowRateErrors, overwriteColumnPrimeGradientBool, columnPrimeAbsorbanceOptionConflictErrors, columnPrimeElectrochemicalModeOptionConflictErrors,
		multipleColumnPrimeDetectionModeErrors, columnPrimeWaveformDetectionModeErrors, multipleColumnPrimeWaveformDurationErrors, duplicateColumnPrimeVoltageProfileTimeErrors,
		duplicateColumnPrimeWaveformProfileTimeErrors, resolvedColumnFlushTemperature, resolvedColumnFlushGradient, resolvedColumnFlushFlowRate, resolvedColumnFlushStart, resolvedColumnFlushEnd,
		resolvedColumnFlushDuration, resolvedColumnFlushAbsorbanceWavelength, resolvedColumnFlushAbsorbanceSamplingRate, resolvedColumnFlushElectrochemicalDetectionMode,
		resolvedColumnFlushReferenceElectrodeMode, resolvedColumnFlushVoltageProfile, resolvedColumnFlushWaveformProfile, inconsistentCationBlankGradientDuration,
		resolvedColumnFlushElectrochemicalSamplingRate, resolvedColumnFlushDetectionTemperature, columnFlushGradientConsistentErrors, columnFlushStartEndSpecifiedErrors,
		invalidColumnFlushGradientCompositionErrors, columnFlushRemovedExtraErrors, columnFlushFlowRateErrors, overwriteColumnFlushGradientBool, columnFlushAbsorbanceOptionConflictErrors,
		columnFlushElectrochemicalModeOptionConflictErrors, multipleColumnFlushDetectionModeErrors, columnFlushWaveformDetectionModeErrors, multipleColumnFlushWaveformDurationErrors,
		duplicateColumnFlushVoltageProfileTimeErrors, duplicateColumnFlushWaveformProfileTimeErrors, inconsistentColumnPrimeGradientOptions, inconsistentColumnPrimeGradientTests,
		inconsistentColumnFlushGradientOptions, inconsistentColumnFlushGradientTests, invalidColumnPrimeGradientCompositionOptions, invalidColumnPrimeGradientCompositionTests,
		invalidColumnFlushGradientCompositionOptions, invalidColumnFlushGradientCompositionTests, notSpecifiedColumnPrimeGradientStartEndOptions, notSpecifiedColumnPrimeGradientStartEndTests,
		notSpecifiedColumnFlushGradientStartEndOptions, notSpecifiedColumnFlushGradientStartEndTests, invalidColumnPrimeAbsorbanceOptions, columnPrimeAbsorbanceOptionTest,
		invalidColumnFlushAbsorbanceOptions, columnFlushAbsorbanceOptionTest, invalidColumnPrimeElectrochemicalDetectionModeOptions, columnPrimeElectrochemicalModeOptionTest,
		invalidColumnFlushElectrochemicalDetectionModeOptions, columnFlushElectrochemicalModeOptionTest, multipleColumnPrimeDetectionModeOptions, multipleColumnPrimeDetectionModeOptionTest,
		multipleColumnFlushDetectionModeOptions, multipleColumnFlushDetectionModeOptionTest, invalidColumnPrimeWaveformDetectionModeOptions, invalidColumnPrimeWaveformDetectionModeTest,
		invalidColumnFlushWaveformDetectionModeOptions, invalidColumnFlushWaveformDetectionModeTest, multipleColumnPrimeWaveformDurationOptions, multipleColumnPrimeWaveformDurationTest,
		multipleColumnFlushWaveformDurationOptions, multipleColumnFlushWaveformDurationTest, columnPrimeVoltageProfileTimeOptions, columnPrimeVoltageProfileTimeTest,
		columnFlushVoltageProfileTimeOptions, columnFlushVoltageProfileTimeTest, columnPrimeWaveformProfileTimeOptions, columnPrimeWaveformProfileTimeTest,
		columnFlushWaveformProfileTimeOptions, columnFlushWaveformProfileTimeTest, resolvedpHCalibration, pHCalibrationOptionConflictQ, invalidpHCalibrationOptions,
		pHCalibrationOptionTests, resolvedNeutralpHCalibrationBuffer, resolvedSecondarypHCalibrationBuffer, resolvedSecondarypHCalibrationBufferTarget, pHTargetConflictQ,
		invalidpHCalibrationTargetOptions, pHCalibrationTargetOptionTests, injectionTableStandards, injectionTableBlanks, injectionTableStandardInjectionVolumes,
		injectionTableBlankInjectionVolumes, injectionTableStandardGradients, injectionTableBlankGradients, resolvedElectrochemicalInjectionTable,
		resolvedInjectionTableSamples, resolvedInjectionTableSampleInjectionVolumes, resolvedInjectionTableSampleGradients, foreignSamplesQ, foreignSampleOptions, foreignSampleTest,
		resolvedInjectionTableBlanks, resolvedInjectionTableBlankInjectionVolumes, resolvedInjectionTableBlankGradients, foreignBlanksQ, foreignBlankOptions, foreignBlankTest,
		resolvedInjectionTableStandards, resolvedInjectionTableStandardInjectionVolumes, resolvedInjectionTableStandardGradients, foreignStandardsQ, foreignStandardOptions,
		foreignStandardTest, unresolvedGradientObjectPosition, standardUnresolvedGradientObjectPosition, blankUnresolvedGradientObjectPosition, sampleGradientObjects,
		blankGradientObjects, standardGradientObjects, columnPrimeGradientObject, columnFlushGradientObject, sampleGradientsTuples, blankGradientsTuples,
		standardGradientsTuples, columnPrimeGradientTuples, columnFlushGradientTuples, standardPositions, blankPositions, columnRefreshPositions, allGradientTuples,
		inconsistentCationBlankGradientDurationOptions, consistentCationBlankGradientDurationTests, notSpecifiedBlankGradientDuration, notSpecifiedBlankGradientDurationOptions,
		notSpecifiedBlankGradientDurationTests, inconsistentBlankGradientDuration, inconsistentBlankGradientDurationOptions, consistentBlankGradientDurationTests,
		cationBlankDurationOptionSpecifiedErrors, cationBlankDurationConsistentErrors, blankDurationOptionSpecifiedErrors, blankDurationConsistentErrors,
		notSpecifiedCationColumnPrimeGradientDurationOptions, notSpecifiedCationColumnPrimeGradientDurationTests, notSpecifiedCationColumnFlushGradientDurationOptions,
		notSpecifiedCationColumnFlushGradientDurationTests, inconsistentCationColumnPrimeGradientDurationOptions, consistentCationColumnPrimeGradientDurationTests,
		inconsistentCationColumnFlushGradientDurationOptions, consistentCationColumnFlushGradientDurationTests, cationColumnPrimeDurationOptionSpecifiedErrors,
		cationColumnPrimeDurationConsistentErrors, cationColumnFlushDurationOptionSpecifiedErrors, cationColumnFlushDurationConsistentErrors,
		columnPrimeDurationOptionSpecifiedErrors, columnPrimeDurationConsistentErrors, columnFlushDurationOptionSpecifiedErrors, columnFlushDurationConsistentErrors,
		notSpecifiedColumnPrimeGradientDurationOptions, notSpecifiedColumnPrimeGradientDurationTests, notSpecifiedColumnFlushGradientDurationOptions,
		notSpecifiedColumnFlushGradientDurationTests, inconsistentColumnPrimeGradientDurationOptions, consistentColumnPrimeGradientDurationTests,
		inconsistentColumnFlushGradientDurationOptions, consistentColumnFlushGradientDurationTests, validChannelQ, instrumentAnalysisChannel, instrumentCompatibleQ,
		instrumentIncompatibleOption, compatibleInstrumentTests, compatibleDetectors, compatibleDetectorQ, detectorWarning, detectorTest, absorbanceOptions, edOptions,
		conflictingDetectionOptionQ, missingDetector, detectionOptionConflictOptions, detectorConflictTest, electrochemicalOptionConflictErrors, invalidElectrochemicalOptions,
		electrochemicalOptionTest, standardElectrochemicalOptionConflictErrors, invalidStandardElectrochemicalOptions, standardElectrochemicalOptionTest,
		blankElectrochemicalOptionConflictErrors, invalidBlankElectrochemicalOptions, blankElectrochemicalOptionTest, columnPrimeElectrochemicalOptionConflictErrors,
		invalidColumnPrimeElectrochemicalOptions, columnPrimeElectrochemicalOptionTest, columnFlushElectrochemicalOptionConflictErrors, invalidColumnFlushElectrochemicalOptions,
		columnFlushElectrochemicalOptionTest, workingElectrodeModelPacket, electrochemicalStandardInInjectionTable, electrochemicalStandardExistsQ, electrochemicalStandardConflictQ,
		invalidElectrochemicalStandardConflictOptions, electrochemicalStandardConflictTest, electrochemicalBlankInInjectionTable, electrochemicalBlankExistsQ,
		electrochemicalBlankConflictQ, invalidElectrochemicalBlankConflictOptions, electrochemicalBlankConflictTest, anionColumnPrimeOptionNames, anionColumnFlushOptionNames,
		cationColumnPrimeOptionNames, cationColumnFlushOptionNames, electrochemicalColumnPrimeOptionNames, electrochemicalColumnFlushOptionNames, anionColumnPrimeOptions,
		cationColumnPrimeOptions, electrochemicalColumnPrimeOptions, anionColumnFlushOptions, cationColumnFlushOptions, electrochemicalColumnFlushOptions,
		anionColumnPrimeOptionSpecifiedBool, anionColumnPrimeExistsQ, cationColumnPrimeOptionSpecifiedBool, cationColumnPrimeExistsQ, electrochemicalColumnPrimeOptionSpecifiedBool,
		electrochemicalColumnPrimeExistsQ, anionColumnPrimeConflictQ, invalidAnionColumnPrimeConflictOptions, anionColumnPrimeConflictTest, catonColumnPrimeConflictQ,
		invalidCationColumnPrimeConflictOptions, cationColumnPrimeConflictTest, electrochemicalColumnPrimeConflictQ, invalidElectrochemicalColumnPrimeConflictOptions,
		electrochemicalColumnPrimeConflictTest, anionColumnFlushOptionSpecifiedBool, anionColumnFlushExistsQ, cationColumnFlushOptionSpecifiedBool, cationColumnFlushExistsQ,
		electrochemicalColumnFlushOptionSpecifiedBool, electrochemicalColumnFlushExistsQ, anionColumnFlushConflictQ, invalidAnionColumnFlushConflictOptions,
		anionColumnFlushConflictTest, catonColumnFlushConflictQ, invalidCationColumnFlushConflictOptions, cationColumnFlushConflictTest, electrochemicalColumnFlushConflictQ,
		invalidElectrochemicalColumnFlushConflictOptions, electrochemicalColumnFlushConflictTest, blankOptionConflictQ, nullBlankOption, nullBlankTests, standardOptionConflictQ,
		nullStandardOption, nullStandardTests, conflictingDetectionOptions, getModelPacket, simulation, updatedSimulation, testOrNull,warningOrNull,testOrNullIndexMatched,warningOrNullIndexMatched,
		anySpecifiedQ
	},

		(*-- SETUP OUR USER SPECIFIED OPTIONS AND CACHE --*)

		(* get the safe options *)
		safeOps = SafeOptions[ExperimentIonChromatography, ToList[myOptions]];

		(* Determine the requested output format of this function. *)
		outputSpecification = OptionValue[Output];
		output = ToList[outputSpecification];

		(* Determine if we should keep a running list of tests to return to the user. *)
		gatherTests = MemberQ[output, Tests];

		(* If we are not gathering test, then we should throw messages *)
		messagesQ = !gatherTests;

		(* Determine if we are not in Engine, in Engine we silence warnings *)
		notInEngine = Not[MatchQ[$ECLApplication, Engine]];

		(* Fetch our cache from the parent function. *)
		cache = Lookup[ToList[myResolutionOptions], Cache, {}];
		simulation = Lookup[ToList[myResolutionOptions], Simulation, {}];

		(* Separate out our IonChromatography options from our Sample Prep options. *)
		{samplePrepOptions, ionChromatographyOptions} = splitPrepOptions[myOptions];

		(* Resolve our sample prep options *)
		{{simulatedSamples, resolvedSamplePrepOptions, updatedSimulation}, samplePrepTests} = If[gatherTests,
			resolveSamplePrepOptionsNew[ExperimentIonChromatography, mySamples, samplePrepOptions, Cache -> cache, Simulation -> simulation, Output -> {Result, Tests}],
			{resolveSamplePrepOptionsNew[ExperimentIonChromatography, mySamples, samplePrepOptions, Cache -> cache, Simulation -> simulation, Output -> Result], {}}
		];

		(* Convert list of rules to Association so we can Lookup, Append, Join as usual. *)
		ionChromatographyOptionsAssociation = Association[ionChromatographyOptions];

		(* define the function to generate the test for a specific option *)
		(* note that this function only takes in one boolean and the function below, testOrNullIndexMatched takes an index matched list of boolean *)
		testOrNull[testDescription_String, boolean : BooleanP] := If[gatherTests,
			Test[testDescription, True, Evaluate[boolean]],
			Null
		];

		(* define the function to generate the test for a specific option where a warning is thrown instead of an error message *)
		warningOrNull[testDescription_String, boolean : BooleanP] := If[gatherTests,
			Warning[testDescription, True, Evaluate[boolean]],
			Null
		];

		(* define the functions to generate all the tests *)
		(* note that this requires the sample list to be index matched with the boolean list (and True means Failing) *)
		testOrNullIndexMatched[testDescription_String, allSamples : {ObjectP[]...} | {}, booleanList : {BooleanP...} | {}] := If[gatherTests,
			Module[{failingTest, passingTest, failingSamples, passingSamples, failingString, passingString},

				(* in this case, True means Yes, we are failing *)
				failingSamples = PickList[allSamples, booleanList, True];
				passingSamples = PickList[allSamples, booleanList, False];

				(* get the failing and passing string *)
				failingString = If[MatchQ[failingSamples, {}],
					Null,
					StringReplace[testDescription, "`1`" :> ObjectToString[failingSamples, Cache -> cache, Simulation -> updatedSimulation]]
				];
				passingString = If[MatchQ[passingSamples, {}],
					Null,
					StringReplace[testDescription, "`1`" :> ObjectToString[passingSamples, Cache -> cache, Simulation -> updatedSimulation]]
				];

				(* create a test for non-passing and passing inputs *)
				failingTest = If[NullQ[failingString],
					Null,
					Test[failingString,
						True,
						False
					]
				];
				passingTest = If[NullQ[passingString],
					Null,
					Test[passingString,
						True,
						True
					]
				];

				{failingTest, passingTest}
			],
			Null
		];

		(* define the functions to generate all the warning *)
		(* note that this requires the sample list to be index matched with the boolean list (and True means Failing) *)
		warningOrNullIndexMatched[testDescription_String, allSamples : {ObjectP[]...}, booleanList : {BooleanP...}] := If[gatherTests,
			Module[{failingWarning, passingWarning, failingSamples, passingSamples, failingString, passingString},

				(* in this case, True means Yes, we are failing *)
				failingSamples = PickList[allSamples, booleanList, True];
				passingSamples = PickList[allSamples, booleanList, False];

				(* get the failing and passing string *)
				failingString = If[MatchQ[failingSamples, {}],
					Null,
					StringReplace[testDescription, "`1`" :> ObjectToString[failingSamples, Cache -> cache, Simulation -> updatedSimulation]]
				];
				passingString = If[MatchQ[passingSamples, {}],
					Null,
					StringReplace[testDescription, "`1`" :> ObjectToString[passingSamples, Cache -> cache, Simulation -> updatedSimulation]]
				];

				(* create a warning for non-passing and passing inputs *)
				failingWarning = If[NullQ[failingString],
					Null,
					Warning[failingString,
						True,
						False
					]
				];
				passingWarning = If[NullQ[passingString],
					Null,
					Warning[passingString,
						True,
						True
					]
				];

				{failingWarning, passingWarning}
			],
			Null
		];

		(* Checks to see if any of the provided options are specified (not automatic, not null) *)
		anySpecifiedQ[optionNamesToCheck : {_Symbol..}, ops_Association] := anySpecifiedQ[
			KeyTake[ops, optionNamesToCheck]
		];

		(* Checks to see if any of the provided options are specified (not automatic, not null) *)
		anySpecifiedQ[optionsToCheck : (_Association | {_Rule...})] := MemberQ[
			Flatten[Values[optionsToCheck]],
			Except[Automatic | Null | None | {Null}]
		];

		(* Extract the packets that we need from our downloaded cache. *)
		(* Remember to download from simulatedSamples, using our simulatedCache *)
		(* Quiet[Download[...],Download::FieldDoesntExist] *)

		(* If you have Warning:: messages, do NOT throw them when MatchQ[$ECLApplication,Engine]. Warnings should NOT be surfaced in engine. *)



		(*----- INPUT VALIDATION CHECKS -----*)

		(* Extract downloaded mySamples packets *)
		fullCache = FlattenCachePackets[{cache, Lookup[FirstOrDefault[updatedSimulation, <|Packets->{}|>], Packets]}];
		samplePackets = fetchPacketFromCache[#, fullCache]& /@ mySamples;

		(* Fetch simulated samples' cached packets *)
		simulatedSamplePackets = fetchPacketFromCache[#, fullCache]& /@ simulatedSamples;

		(* === 1 Discarded sample check === *)
		(* Find any samples that are discarded; also get DiscardedQ for use with the test-making function *)
		discardedSamplePackets = Cases[Flatten[samplePackets], KeyValuePattern[Status -> Discarded]];
		discardedQ = MemberQ[discardedSamplePackets, #]& /@ samplePackets;

		(* Set discardedInvalidInputs to the input objects whose statuses are Discarded *)
		discardedInvalidInputs = If[MatchQ[discardedSamplePackets, {}] && messagesQ,
			{},
			Lookup[discardedSamplePackets, Object]
		];

		(* If there are invalid inputs and we are throwing messages, throw an error message and keep track of the invalid inputs.*)
		If[Length[discardedInvalidInputs] > 0 && messagesQ,
			Message[Error::DiscardedSamples, ObjectToString[discardedInvalidInputs, Cache -> fullCache, Simulation -> updatedSimulation]]
		];

		(* If we are gathering tests, create a passing and/or failing test with the appropriate result. *)
		discardedSampleTest = testOrNullIndexMatched["Provided input samples `1` are not discarded:", samplePackets, discardedQ];

		(* === 2 Containerless sample check === *)
		(* Extract containers *)
		sampleContainers = Download[Lookup[samplePackets, Container], Object];

		(* Extract simulated sample containers *)
		simulatedSampleContainers = Download[Lookup[simulatedSamplePackets, Container], Object];

		(* Find simulated container models *)
		simulatedSampleContainerModels = Map[
			If[NullQ[#],
				Null,
				Download[Lookup[fetchPacketFromCache[#, fullCache], Model], Object]
			]&,
			simulatedSampleContainers
		];

		(* get whether a given sample is containerless *)
		containerlessSamples = PickList[mySamples, sampleContainers, Null];
		containerlessQ = NullQ[#]& /@ sampleContainers;

		(* If a sample is not in a container, throw error *)
		If[Length[containerlessSamples] > 0 && messagesQ,
			Message[Error::ContainerlessSamples, ObjectToString[containerlessSamples, Cache -> fullCache, Simulation -> updatedSimulation]]
		];

		(* Keep track of samples that do not have containers *)
		containerlessInvalidInputs = If[MatchQ[containerlessSamples, {}],
			{},
			containerlessSamples
		];

		(* Test that all samples are in a container *)
		containersExistTest = testOrNullIndexMatched["Provided input samples `1` are in containers:", samplePackets, containerlessQ];


		(*----- OPTION PRECISION CHECKS -----*)

		(*we have to break apart our options so that it's easier to tackle this part*)

		(*get the injection table option and see if need consider the suboptions within it*)
		anionInjectionTableLookup = Lookup[ionChromatographyOptionsAssociation, AnionInjectionTable, Null];
		cationInjectionTableLookup = Lookup[ionChromatographyOptionsAssociation, CationInjectionTable, Null];
		electrochemicalInjectionTableLookup = Lookup[ionChromatographyOptionsAssociation, ElectrochemicalInjectionTable, Null];

		(*is the injection specified (meaning that it has tuples within it)?*)
		anionInjectionTableSpecifiedQ = MatchQ[anionInjectionTableLookup, Except[Automatic | Null]];
		cationInjectionTableSpecifiedQ = MatchQ[cationInjectionTableLookup, Except[Automatic | Null]];
		electrochemicalInjectionTableSpecifiedQ = MatchQ[electrochemicalInjectionTableLookup, Except[Automatic | Null]];

		(* get the samples that are in the injection table, and the input sample objects *)
		anionInjectionTableSamples = If[anionInjectionTableSpecifiedQ,
			Lookup[fetchPacketFromCache[#, fullCache], Object]& /@ Cases[anionInjectionTableLookup, {Sample, sampleObj : ObjectP[], ___} :> sampleObj],
			Null
		];
		cationInjectionTableSamples = If[cationInjectionTableSpecifiedQ,
			Lookup[fetchPacketFromCache[#, fullCache], Object]& /@ Cases[cationInjectionTableLookup, {Sample, sampleObj : ObjectP[], ___} :> sampleObj],
			Null
		];
		electrochemicalInjectionTableSamples = If[electrochemicalInjectionTableSpecifiedQ,
			Lookup[fetchPacketFromCache[#, fullCache], Object]& /@ Cases[electrochemicalInjectionTableLookup, {Sample, sampleObj : ObjectP[], ___} :> sampleObj],
			Null
		];
		inputSampleObjs = Lookup[fetchPacketFromCache[#, fullCache], Object]& /@ mySamples;

		(* compile a list of sample objects from the two injection tables *)
		injectionTableSamples = Join[ToList@anionInjectionTableSamples, ToList@cationInjectionTableSamples] /. {ListableP[Null] -> {}};

		(*we need to make sure that if the injection table is specified that the samples and the input are compatible*)
		injectionTableSampleConflictQ = If[anionInjectionTableSpecifiedQ && cationInjectionTableSpecifiedQ,
			(*check first if they're the same length. that's already bad*)
			If[Length[ToList[mySamples]] == (Count[anionInjectionTableLookup, {Sample, ___}] + Count[cationInjectionTableLookup, {Sample, ___}]),
				Not[
					(* make sure each sample object input into InjectionTable matches exactly the input samples *)
					SameQ[Sort[injectionTableSamples], Sort[inputSampleObjs]]
				],
				True
			],
			If[electrochemicalInjectionTableSpecifiedQ,
				If[Length[ToList[mySamples]] == Count[electrochemicalInjectionTableLookup, {Sample, ___}],
					Not[
						(* make sure each sample object input into InjectionTable matches exactly the input samples *)
						SameQ[Sort[electrochemicalInjectionTableSamples], Sort[inputSampleObjs]]
					],
					True
				],
				False
			]
		];

		(* Compile a list of all anion gradient related options for rounding *)
		anionGradientOptions = {
			AnionGradient,
			EluentGradient,
			AnionFlowRate,
			AnionGradientStart,
			AnionGradientEnd,
			AnionGradientDuration,
			AnionEquilibrationTime,
			AnionFlushTime,
			AnionStandardGradient,
			StandardEluentGradient,
			AnionStandardGradientDuration,
			AnionStandardFlowRate,
			AnionBlankGradient,
			BlankEluentGradient,
			AnionBlankGradientDuration,
			AnionBlankFlowRate,
			AnionColumnPrimeGradient,
			ColumnPrimeEluentGradient,
			AnionColumnPrimeDuration,
			AnionColumnPrimeFlowRate,
			AnionColumnFlushGradient,
			ColumnFlushEluentGradient,
			AnionColumnFlushDuration,
			AnionColumnFlushFlowRate
		};

		(* Compile a list of all cation gradient related options for rounding *)
		cationGradientOptions = {
			CationGradient,
			CationGradientA,
			CationGradientB,
			CationGradientC,
			CationGradientD,
			CationFlowRate,
			CationGradientStart,
			CationGradientEnd,
			CationGradientDuration,
			CationEquilibrationTime,
			CationFlushTime,
			CationStandardGradient,
			CationStandardGradientA,
			CationStandardGradientB,
			CationStandardGradientC,
			CationStandardGradientD,
			CationStandardGradientStart,
			CationStandardGradientEnd,
			CationStandardGradientDuration,
			CationStandardFlowRate,
			CationBlankGradient,
			CationBlankGradientA,
			CationBlankGradientB,
			CationBlankGradientC,
			CationBlankGradientD,
			CationBlankGradientStart,
			CationBlankGradientEnd,
			CationBlankGradientDuration,
			CationBlankFlowRate,
			CationColumnPrimeGradient,
			CationColumnPrimeGradientA,
			CationColumnPrimeGradientB,
			CationColumnPrimeGradientC,
			CationColumnPrimeGradientD,
			CationColumnPrimeStart,
			CationColumnPrimeEnd,
			CationColumnPrimeDuration,
			CationColumnPrimeFlowRate,
			CationColumnFlushGradient,
			CationColumnFlushGradientA,
			CationColumnFlushGradientB,
			CationColumnFlushGradientC,
			CationColumnFlushGradientD,
			CationColumnFlushStart,
			CationColumnFlushEnd,
			CationColumnFlushDuration,
			CationColumnFlushFlowRate,
			Gradient,
			GradientA,
			GradientB,
			GradientC,
			GradientD,
			FlowRate,
			GradientStart,
			GradientEnd,
			GradientDuration,
			EquilibrationTime,
			FlushTime,
			StandardGradient,
			StandardGradientA,
			StandardGradientB,
			StandardGradientC,
			StandardGradientD,
			StandardGradientStart,
			StandardGradientEnd,
			StandardGradientDuration,
			StandardFlowRate,
			BlankGradient,
			BlankGradientA,
			BlankGradientB,
			BlankGradientC,
			BlankGradientD,
			BlankGradientStart,
			BlankGradientEnd,
			BlankGradientDuration,
			BlankFlowRate,
			ColumnPrimeGradient,
			ColumnPrimeGradientA,
			ColumnPrimeGradientB,
			ColumnPrimeGradientC,
			ColumnPrimeGradientD,
			ColumnPrimeStart,
			ColumnPrimeEnd,
			ColumnPrimeDuration,
			ColumnPrimeFlowRate,
			ColumnFlushGradient,
			ColumnFlushGradientA,
			ColumnFlushGradientB,
			ColumnFlushGradientC,
			ColumnFlushGradientD,
			ColumnFlushStart,
			ColumnFlushEnd,
			ColumnFlushDuration,
			ColumnFlushFlowRate
		};

		(* Compile a list of all voltage related options for rounding *)
		voltageProfileOptions = {
			VoltageProfile,
			StandardVoltageProfile,
			BlankVoltageProfile,
			ColumnPrimeVoltageProfile,
			ColumnFlushVoltageProfile
		};

		(* Compile a list of all waveform related options for rounding *)
		waveformOptions = {
			WaveformProfile,
			StandardWaveformProfile,
			BlankWaveformProfile,
			ColumnPrimeWaveformProfile,
			ColumnFlushWaveformProfile
		};

		(*use the helper function to round all of the gradient options collectively; helper function in SharedChromaotgraphy in HPLC folder*)
		{roundedCationGradientOptions, roundedAnionGradientOptions, roundedVoltageOptions, roundedWaveformOptions, roundedGradientTests} =
			roundICGradientDetectionOptions[anionGradientOptions, cationGradientOptions, voltageProfileOptions, waveformOptions, ionChromatographyOptionsAssociation, gatherTests];

		volumeOptions = {
			(* Volume options *)
			AnionInjectionVolume,
			CationInjectionVolume,
			AnionStandardInjectionVolume,
			CationStandardInjectionVolume,
			AnionBlankInjectionVolume,
			CationBlankInjectionVolume,
			InjectionVolume,
			StandardInjectionVolume,
			BlankInjectionVolume
		};

		tempOptions = {
			SampleTemperature,
			AnionColumnTemperature,
			CationColumnTemperature,
			ColumnTemperature,
			AnionStandardColumnTemperature,
			CationStandardColumnTemperature,
			StandardColumnTemperature,
			AnionBlankColumnTemperature,
			CationBlankColumnTemperature,
			BlankColumnTemperature,
			AnionColumnPrimeTemperature,
			CationColumnPrimeTemperature,
			ColumnPrimeTemperature,
			AnionColumnFlushTemperature,
			CationColumnFlushTemperature,
			ColumnFlushTemperature,
			AnionDetectionTemperature,
			CationDetectionTemperature,
			DetectionTemperature,
			AnionStandardDetectionTemperature,
			CationStandardDetectionTemperature,
			StandardDetectionTemperature,
			AnionBlankDetectionTemperature,
			CationBlankDetectionTemperature,
			BlankDetectionTemperature,
			AnionColumnPrimeDetectionTemperature,
			CationColumnPrimeDetectionTemperature,
			ColumnPrimeDetectionTemperature,
			AnionColumnFlushDetectionTemperature,
			CationColumnFlushDetectionTemperature,
			ColumnFlushDetectionTemperature
		};

		voltageOptions = {
			(* Voltage options *)
			AnionSuppressorVoltage,
			CationSuppressorVoltage,
			AnionStandardSuppressorVoltage,
			CationStandardSuppressorVoltage,
			AnionBlankSuppressorVoltage,
			CationBlankSuppressorVoltage,
			AnionColumnPrimeSuppressorVoltage,
			CationColumnPrimeSuppressorVoltage,
			AnionColumnFlushSuppressorVoltage,
			CationColumnFlushSuppressorVoltage
		};

		currentOptions = {
			(* Current options *)
			AnionSuppressorCurrent,
			CationSuppressorCurrent,
			AnionStandardSuppressorCurrent,
			CationStandardSuppressorCurrent,
			AnionBlankSuppressorCurrent,
			CationBlankSuppressorCurrent,
			AnionColumnPrimeSuppressorCurrent,
			CationColumnPrimeSuppressorCurrent,
			AnionColumnFlushSuppressorCurrent,
			CationColumnFlushSuppressorCurrent
		};

		samplingRateOptions = {
			(* SamplingRate options *)
			AbsorbanceSamplingRate,
			ElectrochemicalSamplingRate,
			StandardAbsorbanceSamplingRate,
			StandardElectrochemicalSamplingRate,
			BlankAbsorbanceSamplingRate,
			BlankElectrochemicalSamplingRate,
			ColumnPrimeAbsorbanceSamplingRate,
			ColumnPrimeElectrochemicalSamplingRate,
			ColumnFlushAbsorbanceSamplingRate,
			ColumnFlushElectrochemicalSamplingRate
		};

		timeOptions = {
			AnionGradientDuration,
			AnionEquilibrationTime,
			AnionFlushTime,
			AnionStandardGradientDuration,
			AnionBlankGradientDuration,
			AnionColumnPrimeDuration,
			AnionColumnFlushDuration,
			CationGradientDuration,
			CationEquilibrationTime,
			CationFlushTime,
			CationStandardGradientDuration,
			CationBlankGradientDuration,
			CationColumnPrimeDuration,
			CationColumnFlushDuration,
			GradientDuration,
			EquilibrationTime,
			FlushTime,
			StandardGradientDuration,
			BlankGradientDuration,
			ColumnPrimeDuration,
			ColumnFlushDuration
		};


		(* Fetch association with times rounded *)
		{volumeRoundedAssociation, volumeRoundedTests} = If[gatherTests,
			RoundOptionPrecision[ionChromatographyOptionsAssociation, volumeOptions, Table[10^-1 Microliter, Length[volumeOptions]], Output -> {Result, Tests}],
			{RoundOptionPrecision[ionChromatographyOptionsAssociation, volumeOptions, Table[10^-1 Microliter, Length[volumeOptions]]], {}}
		];

		{tempRoundedAssociation, tempRoundedTests} = If[gatherTests,
			RoundOptionPrecision[ionChromatographyOptionsAssociation, tempOptions, Table[10^-2 Celsius, Length[tempOptions]], Output -> {Result, Tests}],
			{RoundOptionPrecision[ionChromatographyOptionsAssociation, tempOptions, Table[10^-2 Celsius, Length[tempOptions]]], {}}
		];

		{voltageRoundedAssociation, voltageRoundedTests} = If[gatherTests,
			RoundOptionPrecision[ionChromatographyOptionsAssociation, voltageOptions, Table[10^-1 Volt, Length[voltageOptions]], Output -> {Result, Tests}],
			{RoundOptionPrecision[ionChromatographyOptionsAssociation, voltageOptions, Table[10^-1 Volt, Length[voltageOptions]]], {}}
		];

		{currentRoundedAssociation, currentRoundedTests} = If[gatherTests,
			RoundOptionPrecision[ionChromatographyOptionsAssociation, currentOptions, Table[10^0 Milli * Ampere, Length[currentOptions]], Output -> {Result, Tests}],
			{RoundOptionPrecision[ionChromatographyOptionsAssociation, currentOptions, Table[10^0 Milli * Ampere, Length[currentOptions]]], {}}
		];

		{samplingRateRoundedAssociation, samplingRateRoundedTests} = If[gatherTests,
			RoundOptionPrecision[ionChromatographyOptionsAssociation, samplingRateOptions, Table[10^-1 / Second, Length[samplingRateOptions]], Output -> {Result, Tests}],
			{RoundOptionPrecision[ionChromatographyOptionsAssociation, samplingRateOptions, Table[10^-1 / Second, Length[samplingRateOptions]]], {}}
		];

		{timeRoundedAssociation, timeRoundedTests} = If[gatherTests,
			RoundOptionPrecision[ionChromatographyOptionsAssociation, timeOptions, Table[10^-3 Minute, Length[timeOptions]], Output -> {Result, Tests}],
			{RoundOptionPrecision[ionChromatographyOptionsAssociation, timeOptions, Table[10^-3 Minute, Length[timeOptions]]], {}}
		];

		(* Join all rounded associations together, with rounded values overwriting existing values *)
		roundedOptionsAssociation = Join[
			ionChromatographyOptionsAssociation,
			KeyTake[volumeRoundedAssociation, volumeOptions],
			KeyTake[tempRoundedAssociation, tempOptions],
			KeyTake[voltageRoundedAssociation, voltageOptions],
			KeyTake[currentRoundedAssociation, currentOptions],
			KeyTake[samplingRateRoundedAssociation, samplingRateOptions],
			KeyTake[timeRoundedAssociation, timeOptions],
			roundedCationGradientOptions,
			roundedAnionGradientOptions,
			roundedVoltageOptions,
			roundedWaveformOptions
		];

		(* Join all tests together *)
		allRoundingTests = Flatten[{volumeRoundedTests, tempRoundedTests, voltageRoundedTests, currentRoundedTests, samplingRateRoundedTests, timeRoundedTests, roundedGradientTests}];

		(*----- CONFLICTING OPTIONS CHECKS -----*)

		{
			(* == General options == *)
			specifiedInstrument, specifiedNumberOfReplicates, specifiedSampleTemperature, specifiedNeedleWashSolution, specifiedStandard, specifiedBlank,

			(* == Anion related options == *)
			(* - 1. sample options - *)
			specifiedAnionSamples, specifiedAnionColumn, specifiedAnionGuardColumn,
			(* - 2. standard options - *)
			specifiedAnionStandard, specifiedAnionStandardFrequency,
			(* - 3. blank options - *)
			specifiedAnionBlank, specifiedAnionBlankFrequency,
			(* - 4. column prime options - *)
			specifiedAnionColumnRefreshFrequency, specifiedAnionColumnPrimeTemperature,
			specifiedColumnPrimeEluentGradient, specifiedAnionColumnPrimeStart, specifiedAnionColumnPrimeEnd, specifiedAnionColumnPrimeDuration,
			specifiedAnionColumnPrimeGradient, specifiedAnionColumnPrimeFlowRate, specifiedAnionColumnPrimeSuppressorMode,
			specifiedAnionColumnPrimeSuppressorVoltage, specifiedAnionColumnPrimeSuppressorCurrent, specifiedAnionColumnPrimeDetectionTemperature,
			(* - 5. column flush options - *)
			specifiedAnionColumnFlushTemperature, specifiedAnionColumnFlushStart, specifiedAnionColumnFlushEnd, specifiedAnionColumnFlushDuration,
			specifiedColumnFlushEluentGradient, specifiedAnionColumnFlushGradient, specifiedAnionColumnFlushFlowRate, specifiedAnionColumnFlushSuppressorMode,
			specifiedAnionColumnFlushSuppressorVoltage, specifiedAnionColumnFlushSuppressorCurrent, specifiedAnionColumnFlushDetectionTemperature,

			(* == Cation related options == *)
			(* - 1. sample options - *)
			specifiedCationSamples, specifiedCationColumn, specifiedCationGuardColumn, specifiedBufferA, specifiedBufferB, specifiedBufferC, specifiedBufferD,
			specifiedBufferAStorageCondition, specifiedBufferBStorageCondition, specifiedBufferCStorageCondition, specifiedBufferDStorageCondition,
			(* - 2. standard options - *)
			specifiedCationStandard, specifiedCationStandardFrequency,
			(* - 3. blank options - *)
			specifiedCationBlank, specifiedCationBlankFrequency,
			(* - 4. column prime options - *)
			specifiedCationColumnRefreshFrequency, specifiedCationColumnPrimeTemperature, specifiedCationColumnPrimeGradientA, specifiedCationColumnPrimeGradientB,
			specifiedCationColumnPrimeGradientC, specifiedCationColumnPrimeGradientD, specifiedCationColumnPrimeStart, specifiedCationColumnPrimeEnd,
			specifiedCationColumnPrimeDuration, specifiedCationColumnPrimeGradient, specifiedCationColumnPrimeFlowRate, specifiedCationColumnPrimeSuppressorMode,
			specifiedCationColumnPrimeSuppressorVoltage, specifiedCationColumnPrimeSuppressorCurrent, specifiedCationColumnPrimeDetectionTemperature,
			(* - 5. column flush options - *)
			specifiedCationColumnFlushTemperature, specifiedCationColumnFlushGradientA, specifiedCationColumnFlushGradientB, specifiedCationColumnFlushGradientC,
			specifiedCationColumnFlushGradientD, specifiedCationColumnFlushStart, specifiedCationColumnFlushEnd, specifiedCationColumnFlushDuration,
			specifiedCationColumnFlushGradient, specifiedCationColumnFlushFlowRate, specifiedCationColumnFlushSuppressorMode, specifiedCationColumnFlushSuppressorVoltage,
			specifiedCationColumnFlushSuppressorCurrent, specifiedCationColumnFlushDetectionTemperature,

			(* == Electrochemical related options == *)
			(* - 1. sample options - *)
			specifiedColumn, specifiedGuardColumn,
			(* - 2. standard options - *)
			specifiedStandardFrequency,
			(* - 3. blank options - *)
			specifiedBlankFrequency,
			(* - 4. column prime options - *)
			specifiedColumnRefreshFrequency, specifiedColumnPrimeTemperature, specifiedColumnPrimeGradientA, specifiedColumnPrimeGradientB,
			specifiedColumnPrimeGradientC, specifiedColumnPrimeGradientD, specifiedColumnPrimeStart, specifiedColumnPrimeEnd, specifiedColumnPrimeDuration,
			specifiedColumnPrimeGradient, specifiedColumnPrimeFlowRate, specifiedColumnPrimeAbsorbanceWavelength, specifiedColumnPrimeAbsorbanceSamplingRate,
			specifiedColumnPrimeElectrochemicalDetectionMode, specifiedColumnPrimeReferenceElectrodeMode,
			specifiedColumnPrimeVoltageProfile, specifiedColumnPrimeWaveformProfile, specifiedColumnPrimeElectrochemicalSamplingRate, specifiedColumnPrimeDetectionTemperature,
			(* - 5. column flush options - *)
			specifiedColumnFlushTemperature, specifiedColumnFlushGradientA, specifiedColumnFlushGradientB,
			specifiedColumnFlushGradientC, specifiedColumnFlushGradientD, specifiedColumnFlushStart, specifiedColumnFlushEnd, specifiedColumnFlushDuration,
			specifiedColumnFlushGradient, specifiedColumnFlushFlowRate, specifiedColumnFlushAbsorbanceWavelength, specifiedColumnFlushAbsorbanceSamplingRate,
			specifiedColumnFlushElectrochemicalDetectionMode, specifiedColumnFlushReferenceElectrodeMode,
			specifiedColumnFlushVoltageProfile, specifiedColumnFlushWaveformProfile, specifiedColumnFlushElectrochemicalSamplingRate, specifiedColumnFlushDetectionTemperature
		} = Lookup[roundedOptionsAssociation,
			{
				(* == General options == *)
				Instrument, NumberOfReplicates, SampleTemperature, NeedleWashSolution, Standard, Blank,

				(* == Anion related options == *)
				(* - 1. sample options - *)
				AnionSamples, AnionColumn, AnionGuardColumn,
				(* - 2. standard options - *)
				AnionStandard, AnionStandardFrequency,
				(* - 3. blank options - *)
				AnionBlank, AnionBlankFrequency,
				(* - 4. column prime options - *)
				AnionColumnRefreshFrequency, AnionColumnPrimeTemperature,
				ColumnPrimeEluentGradient, AnionColumnPrimeStart, AnionColumnPrimeEnd, AnionColumnPrimeDuration,
				AnionColumnPrimeGradient, AnionColumnPrimeFlowRate, AnionColumnPrimeSuppressorMode,
				AnionColumnPrimeSuppressorVoltage, AnionColumnPrimeSuppressorCurrent, AnionColumnPrimeDetectionTemperature,
				(* - 5. column flush options - *)
				AnionColumnFlushTemperature, AnionColumnFlushStart, AnionColumnFlushEnd, AnionColumnFlushDuration,
				ColumnFlushEluentGradient, AnionColumnFlushGradient, AnionColumnFlushFlowRate, AnionColumnFlushSuppressorMode,
				AnionColumnFlushSuppressorVoltage, AnionColumnFlushSuppressorCurrent, AnionColumnFlushDetectionTemperature,

				(* == Cation related options == *)
				(* - 1. sample options - *)
				CationSamples, CationColumn, CationGuardColumn, BufferA, BufferB, BufferC, BufferD,
				BufferAStorageCondition, BufferBStorageCondition, BufferCStorageCondition, BufferDStorageCondition,
				(* - 2. standard options - *)
				CationStandard, CationStandardFrequency,
				(* - 3. blank options - *)
				CationBlank, CationBlankFrequency,
				(* - 4. column prime options - *)
				CationColumnRefreshFrequency, CationColumnPrimeTemperature, CationColumnPrimeGradientA, CationColumnPrimeGradientB,
				CationColumnPrimeGradientC, CationColumnPrimeGradientD, CationColumnPrimeStart, CationColumnPrimeEnd,
				CationColumnPrimeDuration, CationColumnPrimeGradient, CationColumnPrimeFlowRate, CationColumnPrimeSuppressorMode,
				CationColumnPrimeSuppressorVoltage, CationColumnPrimeSuppressorCurrent, CationColumnPrimeDetectionTemperature,
				(* - 5. column flush options - *)
				CationColumnFlushTemperature, CationColumnFlushGradientA, CationColumnFlushGradientB, CationColumnFlushGradientC,
				CationColumnFlushGradientD, CationColumnFlushStart, CationColumnFlushEnd, CationColumnFlushDuration,
				CationColumnFlushGradient, CationColumnFlushFlowRate, CationColumnFlushSuppressorMode, CationColumnFlushSuppressorVoltage,
				CationColumnFlushSuppressorCurrent, CationColumnFlushDetectionTemperature,

				(* == Electrochemical related options == *)
				(* - 1. sample options - *)
				Column, GuardColumn,
				(* - 2. standard options - *)
				StandardFrequency,
				(* - 3. blank options - *)
				BlankFrequency,
				(* - 4. column prime options - *)
				ColumnRefreshFrequency, ColumnPrimeTemperature, ColumnPrimeGradientA, ColumnPrimeGradientB,
				ColumnPrimeGradientC, ColumnPrimeGradientD, ColumnPrimeStart, ColumnPrimeEnd, ColumnPrimeDuration,
				ColumnPrimeGradient, ColumnPrimeFlowRate, ColumnPrimeAbsorbanceWavelength, ColumnPrimeAbsorbanceSamplingRate,
				ColumnPrimeElectrochemicalDetectionMode, ColumnPrimeReferenceElectrodeMode,
				ColumnPrimeVoltageProfile, ColumnPrimeWaveformProfile, ColumnPrimeElectrochemicalSamplingRate, ColumnPrimeDetectionTemperature,
				(* - 5. column flush options - *)
				ColumnFlushTemperature, ColumnFlushGradientA, ColumnFlushGradientB,
				ColumnFlushGradientC, ColumnFlushGradientD, ColumnFlushStart, ColumnFlushEnd, ColumnFlushDuration,
				ColumnFlushGradient, ColumnFlushFlowRate, ColumnFlushAbsorbanceWavelength, ColumnFlushAbsorbanceSamplingRate,
				ColumnFlushElectrochemicalDetectionMode, ColumnFlushReferenceElectrodeMode,
				ColumnFlushVoltageProfile, ColumnFlushWaveformProfile, ColumnFlushElectrochemicalSamplingRate, ColumnFlushDetectionTemperature
			}
		];


		(* === 1 Protocol name check === *)
		(* pull out the specified name to start *)
		name = Lookup[roundedOptionsAssociation, Name];

		(* If the specified Name is not in the database, it is valid *)
		validNameQ = If[MatchQ[name, _String],
			Not[DatabaseMemberQ[Object[Protocol, IonChromatography, name]]],
			True
		];

		(* if validNameQ is False AND we are throwing messages (or, equivalently, not gathering tests), then throw the message and make nameInvalidOptions = {Name}; otherwise, {} is fine *)
		nameInvalidOptions = If[Not[validNameQ] && messagesQ,
			(
				Message[Error::DuplicateName, "IonChromatography protocol"];
				{Name}
			),
			{}
		];

		(* Generate Test for Name check *)
		validNameTest = testOrNull["Specified name is not already an IonChromatography protocol object name:", validNameQ];

		(* All other conflicting option checks are incorporated in resolve experiment options *)

		(*----- RESOLVE EXPERIMENT OPTIONS -----*)

		(* Set up MapThread options *)
		mapThreadFriendlyOptions = OptionsHandling`Private`mapThreadOptions[ExperimentIonChromatography, roundedOptionsAssociation];

		(* Name a variable to look up specified InjectionTable *)
		anionInjectionTableLookupRounded = Lookup[roundedOptionsAssociation, AnionInjectionTable, Null];
		cationInjectionTableLookupRounded = Lookup[roundedOptionsAssociation, CationInjectionTable, Null];
		electrochemicalInjectionTableLookupRounded = Lookup[roundedOptionsAssociation, ElectrochemicalInjectionTable, Null];

		(* Convert our options into a MapThread friendly version. *)
		(* Setup our error tracking variables *)
		(* Resolve master switches *)
		(* Independent options resolution *)
		(* Gather MapThread results *)



		(* 1. AnalysisChannel resolution *)

		(* It's a complicated option: cases outlined below will result in different resolultion of this option *)
		(* 1.1 User directly specified Analysis Channel *)
		(* 1.2 User indirectly specified Analysis Channel in any of the InjectionTable *)

		(* The following few cases, 2.3-2.5, deal with the scenario where user specified either AnionSamples or CationSamples, or both *)
		(* 1.3 Object belongs to both AnionSamples and CationSamples *)
		(* 1.4 Object belongs to only AnionSamples *)
		(* 1.5 Object belongs to only CationSamples *)
		(* 1.6 Object does not belong to user specified AnionSamples and CationSamples are not specified *)
		(* 1.7 Object does not belong to user specified CationSamples and AnionSamples are not specified *)

		(* 1.8 If user didn't specify any options related to AnalysisChannel *)


		(* Helper function created to resolve analysis channel into either AnionChannel or CationChannel *)
		(* To determine whether samples are going to be injected into the ICS 6000 with Anion/CationChannel or with ElectrochemicalDetector, we first compile a list of Electrochemical Detection related options *)
		electrochemicalOptions = {
			Detector,
			Column,
			GuardColumn,
			InjectionVolume,
			ColumnTemperature,
			GradientA,
			GradientB,
			GradientC,
			GradientD,
			Gradient,
			FlowRate,
			GradientStart,
			GradientEnd,
			GradientDuration,
			AbsorbanceWavelength,
			AbsorbanceSamplingRate,
			ElectrochemicalDetectionMode,
			pHCalibration,
			NeutralpHCalibrationBuffer,
			SecondarypHCalibrationBuffer,
			SecondarypHCalibrationBufferTarget,
			WorkingElectrode,
			WorkingElectrodeStorageCondition,
			ReferenceElectrodeMode,
			VoltageProfile,
			WaveformProfile,
			ElectrochemicalSamplingRate,
			DetectionTemperature,
			ElectrochemicalInjectionTable,
			StandardFrequency,
			BlankFrequency
		};

		(* Get information for the instrument option conflict checks *)
		(* If Instrument is specified by the user, download from fullCache *)
		specifiedInstrumentPacket = If[MatchQ[specifiedInstrument, ObjectP[]],
			fetchPacketFromCache[Download[specifiedInstrument, Object], fullCache],
			Null
		];

		(* Fetch instrument model packet *)
		specifiedInstrumentModelPacket = Which[
			(* If the specified instrument is an Object, grab the packet of the Instrument model *)
			MatchQ[specifiedInstrument, ObjectP[Object[Instrument, IonChromatography]]],
			fetchPacketFromCache[Lookup[specifiedInstrumentPacket, Model], fullCache],

			(* If the specified instrument is already an model object, download the packet *)
			MatchQ[specifiedInstrument, ObjectP[Model[Instrument, IonChromatography]]],
			specifiedInstrumentPacket,

			True,
			{}
		];


		{resolvedAnalysisChannel, imbalancedAnionCationGroupingErrors} = If[!MemberQ[Lookup[roundedOptionsAssociation, AnalysisChannel], Automatic],
			(* If user specified analysis channel, go with that *)
			{Lookup[roundedOptionsAssociation, AnalysisChannel], False},

			(* any of the electrochemical options are specified, set analysis channel to all electrochemical *)
			If[
				Or[
					anySpecifiedQ[electrochemicalOptions, roundedOptionsAssociation],
					MemberQ[Lookup[specifiedInstrumentModelPacket, Detectors], ElectrochemicalDetector],
					MemberQ[ToList@Lookup[roundedOptionsAssociation, StandardAnalysisChannel], ElectrochemicalChannel],
					MemberQ[ToList@Lookup[roundedOptionsAssociation, BlankAnalysisChannel], ElectrochemicalChannel]
				],

				(* If any electrochemical detector options are specified, then set AnalysisChannel to ElectrochemicalChannel *)
				{Table[ElectrochemicalChannel, Length[mySamples]], False},

				resolveICAnalysisChannel[mySamples, roundedOptionsAssociation, mapThreadFriendlyOptions, Sample, AnalysisChannel, AnionSamples, CationSamples, fullCache]
			]
		];

		(* == Error checking == *)
		(* 1.1 If Anion/CationChannel are used, we need to check if the total samples injected into each channel adds up to the total input sample *)
		(* If there is imbalanced grouping of samples and we are throwing messages, then throw error message and collect invalid options *)
		imbalancedAnionCationGroupingOption = If[imbalancedAnionCationGroupingErrors && messagesQ,
			(
				Message[Error::ImbalancedAnionCationGrouping, AnionSamples, CationSamples, Samples];
				{AnalysisChannel}
			),
			{}
		];

		(* Generate test to check anion and cation sample grouping *)
		repeatedGroupingTests = testOrNull["If AnionSamples and CationSamples are specified and AnalysiChannel is not, the total number of samples from these two groups equals that of the input sample:", Not[imbalancedAnionCationGroupingErrors]];

		(* 1. Instrument resolution *)
		resolvedInstrument = If[MatchQ[specifiedInstrument, Except[Automatic]],
			specifiedInstrument,
			If[MemberQ[resolvedAnalysisChannel, ElectrochemicalChannel],
				Model[Instrument, IonChromatography, "Dionex ICS 6000 with Electrochemical and UVVis Detector"],
				Model[Instrument, IonChromatography, "Dionex ICS 6000"]
			]
		];

		(* == Error checking == *)
		(* 1.1 Instrument status check  *)
		(* Check for the instrument's status and model instrument's deprecation *)

		(* Get information for the instrument option conflict checks *)
		(* If Instrument is specified by the user, download from fullCache *)
		resolvedInstrumentPacket = If[MatchQ[resolvedInstrument, ObjectP[]],
			fetchPacketFromCache[Download[resolvedInstrument, Object], fullCache],
			Null
		];

		(* Fetch instrument model packet *)
		resolvedInstrumentModelPacket = Which[
			(* If the specified instrument is an Object, grab the packet of the Instrument model *)
			MatchQ[resolvedInstrument, ObjectP[Object[Instrument, IonChromatography]]],
			fetchPacketFromCache[Lookup[resolvedInstrumentPacket, Model], fullCache],

			(* If the specified instrument is already an model object, download the packet *)
			MatchQ[resolvedInstrument, ObjectP[Model[Instrument, IonChromatography]]],
			resolvedInstrumentPacket,

			True,
			Null
		];

		(* Bool tracking if specified instrument is retired *)
		notRetiredInstrumentQ = Or[
			NullQ[resolvedInstrumentPacket],
			!MatchQ[Lookup[resolvedInstrumentPacket, Status], Retired]
		];

		(* Bool tracking if specified instrument model is deprecated *)
		notDeprecatedInstrumentQ = Or[
			NullQ[resolvedInstrumentModelPacket],
			!TrueQ[Lookup[resolvedInstrumentModelPacket, Deprecated]]
		];

		(* Throw errors if the Instrument is either retired or deprecated AND we are throwing messages, keep track of invalid option *)
		instrumentInvalidOption = Which[
			!notRetiredInstrumentQ && messagesQ,
			(
				Message[Error::RetiredChromatographyInstrument, ObjectToString[specifiedInstrument, Cache -> fullCache, Simulation -> updatedSimulation], ObjectToString[Lookup[resolvedInstrumentModelPacket, Object], Cache -> fullCache, Simulation -> updatedSimulation]];
				{Instrument}
			),
			!notDeprecatedInstrumentQ && messagesQ,
			(
				Message[Error::DeprecatedInstrumentModel, ObjectToString[specifiedInstrument,Cache -> fullCache, Simulation -> updatedSimulation]];
				{Instrument}
			),
			True, {}
		];

		(* Generate tests for retired and deprecated Instrument *)
		notRetiredInstrumentTests = testOrNull["If specified, Instrument is not retired:", notRetiredInstrumentQ];
		notDeprecatedInstruemntTests = testOrNull["If specified, Instrument model is not deprecated", notDeprecatedInstrumentQ];

		(* 1.2 Instrument analysis channel compatibility check  *)
		(* First get the instrument analysis Channel *)
		instrumentAnalysisChannel = Lookup[resolvedInstrumentModelPacket, AnalysisChannels];

		(* Then check if the resolved analysis channel is compatible with the resolved instrument *)
		instrumentCompatibleQ = If[MatchQ[instrumentAnalysisChannel, {}],
			True,
			MemberQ[instrumentAnalysisChannel, Alternatives @@ DeleteDuplicates[resolvedAnalysisChannel]]
		];

		(* Throw error if the instrument is not compatible with the analysis channel *)
		instrumentIncompatibleOption = If[
			!instrumentCompatibleQ && messagesQ,
			(
				Message[Error::IncompatibleICInstrument, ObjectToString[specifiedInstrument, Cache -> fullCache, Simulation -> updatedSimulation], instrumentAnalysisChannel, resolvedAnalysisChannel];
				{Instrument, AnalysisChannel}
			),
			{}
		];

		(* Generate tests for retired and deprecated Instrument *)
		compatibleInstrumentTests = testOrNull["If specified, Instrument supports the AnalysisChannel specified:", instrumentCompatibleQ];

		(* 3. AnionSamples resolution *)

		(* AnionSamples can either be directly specified or be set when AnalysisChannel has been resolved *)
		resolvedAnionSamples = Which[

			(* If AnionChannel or CationChannel will not be used, then AnionSamples is {} *)
			MemberQ[resolvedAnalysisChannel, ElectrochemicalChannel],
			{},

			(* If there's an imbalanced assignment of cation and anion, go ahead and set anion samples to {} *)
			TrueQ[imbalancedAnionCationGroupingErrors], {},

			(* If user specified AnionSamples, go with the specified option *)
			MatchQ[specifiedAnionSamples, Except[ListableP[Automatic]]],
			specifiedAnionSamples,

			(* If Samples and AnalysisChannel are specified in the InjectionTable, compile AnionSamples from the InjectionTable *)
			MemberQ[anionInjectionTableLookupRounded, {Sample, __}],
			Lookup[fetchPacketFromCache[#, fullCache], Object]& /@ (Cases[anionInjectionTableLookupRounded, {Sample, __}][[All, 2]]),

			(* Once AnalysisChannel is resolved, compile all the samples with AnalysisChannel set to AnionChannel *)
			!MatchQ[ToList@resolvedAnalysisChannel, ListableP[Automatic]],
			PickList[simulatedSamples, resolvedAnalysisChannel, AnionChannel],

			True, {}
		];

		(* 4. CationSamples resolution *)

		(* CationSamples can either be directly specified or be set when AnalysisChannel has been resolved *)
		resolvedCationSamples = Which[

			(* If AnionChannel or CationChannel will not be used, then AnionSamples is {} *)
			MemberQ[resolvedAnalysisChannel, ElectrochemicalChannel],
			{},

			(* If there's an imbalanced assignment of cation and anion, go ahead and set anion samples to {} *)
			imbalancedAnionCationGroupingErrors, {},

			(* If user specified CationSamples, go with the specified option *)
			MatchQ[specifiedCationSamples, Except[ListableP[Automatic]]],
			specifiedCationSamples,

			(* If Samples and AnalysisChannel are specified in the InjectionTable, compile CationSamples from the InjectionTable *)
			MemberQ[cationInjectionTableLookupRounded, {Sample, __}],
			Lookup[fetchPacketFromCache[#, fullCache], Object]& /@ (Cases[cationInjectionTableLookupRounded, {Sample, __}][[All, 2]]),

			(* Once AnalysisChannel is resolved, compile all the samples with AnalysisChannel set to CationChannel *)
			!MatchQ[resolvedAnalysisChannel, ListableP[Automatic]],
			PickList[simulatedSamples, resolvedAnalysisChannel, CationChannel],

			True, {}
		];

		(*Determine ElectrochemicalSamples to pass the info*)
		resolvedElectrochemicalSamples = Complement[simulatedSamples, Join[Flatten[{resolvedCationSamples, resolvedAnionSamples}] /. Null -> Nothing]];

		(* == Error checking == *)

		(* Construct a list with all the simulatedSamples in the first place and its corresponding specifiedAnalysisChannel in the second place *)
		allSamplesWithSpecifiedChannel = Transpose[{simulatedSamples, resolvedAnalysisChannel}];

		(* 3.1 AnionSamples check *)
		(* 3.1.1 When AnalysisChannel and AnionSamples options are conflicting, throw error *)

		(* Extract the AnionSamples along with their specifiedAnalysisChannel from the all samples list *)
		anionSamplesWithSpecifiedChannel = If[!NullQ[allSamplesWithSpecifiedChannel] && MatchQ[resolvedAnionSamples, Except[Null | Automatic]],
			Flatten[
				DeleteDuplicates@Cases[allSamplesWithSpecifiedChannel, {#, _}]& /@ ToList[resolvedAnionSamples],
				1
			],
			Null
		];

		consistentAnionChannelQ = If[MatchQ[anionSamplesWithSpecifiedChannel, Null | {}],

			(* If either AnalysisChannel or AnionSamples option is not specified, then set this variable to False *)
			False,

			If[
				(* If user has specified AnionSamples *)
				MatchQ[resolvedAnionSamples, Except[Automatic | Null]],

				(* Then check if all the specified AnalysisChannel is AnionChannel *)
				(* Here FALSE = channel specification is consistent *)
				Not[MatchQ[#, {_, AnionChannel}]],

				(* If either option is not specified, then set this variable to False *)
				False
			]& /@ anionSamplesWithSpecifiedChannel
		];

		(* Compile a list of anion samples that have their AnalysisChannel set to CationChannel *)
		invalidAnionChannelSpecification = If[MatchQ[resolvedAnionSamples, Except[Null | Automatic]] && MatchQ[anionSamplesWithSpecifiedChannel, Except[Null | {}]],
			PickList[ToList@resolvedAnionSamples, consistentAnionChannelQ, True],
			Null
		];

		(* If there are invalid specifcation AND we are throwing messages, then throw an error, and collect AnalysisChannel option *)
		inconsistentAnionChannelOption = If[Length[invalidAnionChannelSpecification] > 0 && messagesQ,
			If[TrueQ[imbalancedAnionCationGroupingErrors],
				{},
				(
					Message[Error::InconsistentAnalysisChannelSpecification, AnionSamples, ObjectToString[invalidAnionChannelSpecification, Cache -> fullCache, Simulation -> updatedSimulation], CationChannel, AnionChannel];
					{AnalysisChannel}
				)
			],
			{}
		];

		(* Generate tests for inconsistent analysis channel specification *)
		anionChannelSpecificationTests = testOrNullIndexMatched["If both AnionSamples and AnalysisChannel are specified, AnalysisChannels of all AnionSamples should be AnionChannel:", resolvedAnionSamples, consistentAnionChannelQ];


		(* 3.2 CationSamples check *)
		(* 3.2.1 When AnalysisChannel and CationSamples options are conflicting, CationSamples take priority *)

		(* Extract the AnionSamples along with their specifiedAnalysisChannel from the all samples list *)
		cationSamplesWithSpecifiedChannel = If[!NullQ[allSamplesWithSpecifiedChannel] && MatchQ[resolvedCationSamples, Except[Null | Automatic]],
			FirstCase[allSamplesWithSpecifiedChannel, {#, CationChannel}]& /@ ToList[resolvedCationSamples],
			Null
		];

		consistentCationChannelQ = If[MatchQ[cationSamplesWithSpecifiedChannel, {} | Null],

			(* If either AnalysisChannel or CationSample option is not specified, then set this variable to True *)
			False,

			If[
				(* If user has specified AnionSamples *)
				MatchQ[resolvedCationSamples, Except[Automatic | Null]],

				(* Then check if all the specified AnalysisChannel is AnionChannel *)
				(* Here FALSE = channel specification is consistent *)
				Not[MatchQ[#, {_, CationChannel}]],

				(* If either option is not specified, then set this variable to False *)
				False
			]& /@ cationSamplesWithSpecifiedChannel
		];

		(* Compile a list of anion samples that have their AnalysisChannel set to CationChannel *)
		invalidCationChannelSpecification = If[MatchQ[resolvedCationSamples, Except[Null | Automatic]] && MatchQ[cationSamplesWithSpecifiedChannel, Except[Null | {}]],
			PickList[ToList@resolvedCationSamples, consistentCationChannelQ, True],
			Null
		];

		(* If there are invalid specifcation AND we are throwing messages, then throw an error, and collect AnalysisChannel option *)
		inconsistentCationChannelOption = If[Length[invalidCationChannelSpecification] > 0 && messagesQ,
			If[TrueQ[imbalancedAnionCationGroupingErrors],
				{},
				(
					Message[Error::InconsistentAnalysisChannelSpecification, CationSamples, ObjectToString[invalidCationChannelSpecification, Cache -> fullCache, Simulation -> updatedSimulation], AnionChannel, CationChannel];
					{AnalysisChannel}
				)
			],
			{}
		];

		(* Generate tests for inconsistent analysis channel specification *)
		cationChannelSpecificationTests = testOrNullIndexMatched["If both CationSamples and AnalysisChannel are specified, AnalysisChannels of all CationSamples should be CationChannel:", specifiedCationSamples, consistentCationChannelQ];


		(* 3.3 AnionSamples and CationSamples check together *)

		(* Get the number of samples as well as the number of resolvedAnionSamples and resolvedCationSamples *)
		(* Only count samples if we are not using ElectrochemicalChannel AnalysisChannel *)
		totalSample = If[MemberQ[resolvedAnalysisChannel, ElectrochemicalChannel],
			0,
			Length[ToList@simulatedSamples]
		];
		totalResolvedSamples = Length[ToList@resolvedAnionSamples] + Length[ToList@resolvedCationSamples];

		(* Check to see if the number of resolved samples add up to the number of input samples *)
		(* False here means the sample number matches *)
		totalSampleInconsistentQ = Not[MatchQ[totalSample, totalResolvedSamples]];

		(* If the number of samples don't match up and we are throwing message, throw error message and collect invalid options *)
		invalidSampleGroupingOption = If[totalSampleInconsistentQ && messagesQ,
			If[imbalancedAnionCationGroupingErrors,
				If[MatchQ[imbalancedAnionCationGroupingOption, {}],
					(
						Message[Error::ImbalancedAnionCationGrouping, AnionSamples, CationSamples, Samples];
						{AnionSamples, CationSamples, AnalysisChannel}
					),
					{}
				],
				{}
			],
			{}
		];

		(* Generate test to check imbalanced grouping of cation and anion samples *)
		sampleGroupingTests = testOrNull["If AnalysisChannel and either AnionSamples or CationSamples are specified, the total number of samples from specified or resolved AnionSamples and CationSamples sums up to the total number of input samples:", Not[totalSampleInconsistentQ]];

		(* I want to resolve Standard and Blank samples, along with CationStandard/Blank and AnionStandard/Blank before resolving column options *)
		(* Because there is always the edge case where the user runs anion samples but only wants to run a cation standard *)
		(* If column is resolved before it even gets to cation standard, can we will not have a resolvedCationColumn *)

		(* 5. Standard resolution *)

		(* First compile all the Standard related options, including AnionStandard, and CationStandard related options *)
		(* This method is a little weird but it ensures that if we add new options we don't need to remember to add them to a hard coded list here *)
		sharedStandardOptionNames = {
			StandardStorageCondition,
			StandardAnalysisChannel
		};
		anionStandardOptionNames = {
			AnionStandardFrequency,
			AnionStandardInjectionVolume,
			AnionStandardColumnTemperature,
			StandardEluentGradient,
			AnionStandardFlowRate,
			AnionStandardGradient,
			AnionStandardSuppressorMode,
			AnionStandardDetectionTemperature
		};
		cationStandardOptionNames = {
			CationStandardFrequency,
			CationStandardInjectionVolume,
			CationStandardColumnTemperature,
			CationStandardGradientA,
			CationStandardGradientB,
			CationStandardGradientC,
			CationStandardGradientD,
			CationStandardFlowRate,
			CationStandardGradient,
			CationStandardSuppressorMode,
			CationStandardDetectionTemperature
		};
		electrochemicalStandardOptionsNames = {
			StandardFrequency,
			StandardInjectionVolume,
			StandardColumnTemperature,
			StandardGradientA,
			StandardGradientB,
			StandardGradientC,
			StandardGradientD,
			StandardFlowRate,
			StandardGradient
		};

		(* Compile a list of anion/cation standard options as well as electrochemical standard options *)
		dualChannelStandardOptions = Join[
			sharedStandardOptionNames,
			anionStandardOptionNames,
			cationStandardOptionNames,
			{CationStandardGradientStart, CationStandardGradientEnd, CationStandardGradientDuration, CationStandardSuppressorVoltage, CationStandardSuppressorCurrent},
			{AnionStandardGradientStart, AnionStandardGradientEnd, AnionStandardGradientDuration, AnionStandardSuppressorVoltage, AnionStandardSuppressorCurrent}
		];
		electrochemicalStandardOptions = Join[sharedStandardOptionNames, electrochemicalStandardOptionsNames,
			{StandardGradientStart, StandardGradientEnd, StandardGradientDuration, StandardVoltageProfile, StandardWaveformProfile, StandardAbsorbanceWavelength,
				StandardAbsorbanceSamplingRate, StandardElectrochemicalDetectionMode, StandardReferenceElectrodeMode, StandardElectrochemicalSamplingRate,
				StandardDetectionTemperature}
		];

		(* == Error checking == *)

		(* 5.1 If Standard is specified for dual channel instrument, StandardAnalysisChannel, and StandardStorageCondition cannot be Null *)
		(*first we ask if any of the standard options are defined*)
		dualChannelStandardOptionSpecifiedBool = Map[
			MatchQ[Lookup[roundedOptionsAssociation, #], Except[ListableP[(Null | None | Automatic)]]]&,
			dualChannelStandardOptions
		];
		electrochemicalStandardOptionSpecifiedBool = Map[
			MatchQ[Lookup[roundedOptionsAssociation, #], Except[ListableP[(Null | None | Automatic)]]]&,
			electrochemicalStandardOptions
		];

		(*if the injection table is specified, get the types of all of the samples*)
		anionInjectionTableTypes = If[anionInjectionTableSpecifiedQ,
			anionInjectionTableLookupRounded[[All, 1]],
			{}
		];
		cationInjectionTableTypes = If[cationInjectionTableSpecifiedQ,
			cationInjectionTableLookupRounded[[All, 1]],
			{}
		];
		electrochemicalInjectionTableTypes = If[electrochemicalInjectionTableSpecifiedQ,
			electrochemicalInjectionTableLookupRounded[[All, 1]],
			{}
		];

		(* Check to see if standard exists in the first place *)
		standardExistsQ = MatchQ[Lookup[roundedOptionsAssociation, Standard], Except[Null]] || MemberQ[dualChannelStandardOptionSpecifiedBool, True] || MemberQ[electrochemicalStandardOptionSpecifiedBool, True] || MemberQ[anionInjectionTableTypes, Standard] || MemberQ[cationInjectionTableTypes, Standard] || MemberQ[electrochemicalInjectionTableTypes, Standard];

		(*simultaneously, we should check to see if certain options were set to Null when they shouldn't have been*)
		standardConflictOptions = {StandardFrequency, StandardAnalysisChannel, StandardStorageCondition};
		standardConflictQ = And[standardExistsQ, MemberQ[Lookup[roundedOptionsAssociation, standardConflictOptions], Null]];

		(*do all of our error accounting *)
		invalidStandardConflictOptions = If[standardConflictQ && messagesQ,
			(
				Message[Error::StandardOptionConflict, PickList[standardConflictOptions, Lookup[roundedOptionsAssociation, standardConflictOptions], ListableP[Null]]];
				PickList[standardConflictOptions, Lookup[roundedOptionsAssociation, standardConflictOptions], ListableP[Null]]
			),
			{}
		];

		(* generate the test for mismatches between the injection table and the samples *)
		standardConflictTest = testOrNull["If standards are specified, the other pertinent options should not be set to Null:", Not[standardConflictQ]];

		(* 5.2 If AnionStandard is specified, all anion standard related options, i.e. the gradient and detection options cannot be Null *)
		(*first we ask if any of the anion standard options are defined*)
		anionStandardOptionSpecifiedBool = Map[
			MatchQ[Lookup[roundedOptionsAssociation, #], Except[ListableP[(Null | None | Automatic | Ambient)]]]&,
			anionStandardOptionNames
		];

		(* Then we check whether anion standard are specified in the InjectionTable *)
		anionStandardInInjectionTable = If[anionInjectionTableSpecifiedQ,
			Cases[anionInjectionTableLookupRounded, {Standard, __}],
			{}
		];

		(* Check to see if standard exists in the first place *)
		anionStandardExistsQ = MemberQ[anionStandardOptionSpecifiedBool, True] || Length[anionStandardInInjectionTable] > 0;

		(*simultaneously, we should check to see if certain options were set to Null when they shouldn't have been*)
		anionStandardConflictQ = And[anionStandardExistsQ, MemberQ[Lookup[roundedOptionsAssociation, anionStandardOptionNames], ListableP[Null]]];

		(*do all of our error accounting *)
		invalidAnionStandardConflictOptions = If[anionStandardConflictQ && messagesQ,
			(
				Message[Error::StandardOptionConflict, PickList[anionStandardOptionNames, Lookup[roundedOptionsAssociation, anionStandardOptionNames], ListableP[Null]]];
				PickList[anionStandardOptionNames, Lookup[roundedOptionsAssociation, anionStandardOptionNames], ListableP[Null]]
			),
			{}
		];

		(* generate the test for mismatches between the injection table and the samples *)
		anionStandardConflictTest = testOrNull["If AnionStandards are specified, the other pertinent options should not be set to Null:", Not[anionStandardConflictQ]];

		(* 5.3 If CationStandard is specified, all cation standard related options, i.e. the gradient and detection options cannot be Null *)
		(*first we ask if any of the cation standard options are defined*)
		cationStandardOptionSpecifiedBool = Map[
			MatchQ[Lookup[roundedOptionsAssociation, #], Except[ListableP[(Null | None | Automatic | Ambient)]]]&,
			cationStandardOptionNames
		];

		(* Then we check whether cation standard are specified in the InjectionTable *)
		cationStandardInInjectionTable = If[cationInjectionTableSpecifiedQ,
			Cases[cationInjectionTableLookupRounded, {Standard, __}],
			{}
		];

		(* Check to see if standard exists in the first place *)
		cationStandardExistsQ = MemberQ[cationStandardOptionSpecifiedBool, True] || Length[cationStandardInInjectionTable] > 0;

		(*simultaneously, we should check to see if certain options were set to Null when they shouldn't have been*)
		cationStandardConflictQ = And[cationStandardExistsQ, MemberQ[Lookup[roundedOptionsAssociation, cationStandardOptionNames], ListableP[Null]]];

		(*do all of our error accounting *)
		invalidCationStandardConflictOptions = If[cationStandardConflictQ && messagesQ,
			(
				Message[Error::StandardOptionConflict, PickList[cationStandardOptionNames, Lookup[roundedOptionsAssociation, cationStandardOptionNames], ListableP[Null]]];
				PickList[cationStandardOptionNames, Lookup[roundedOptionsAssociation, cationStandardOptionNames], ListableP[Null]]
			),
			{}
		];

		(* generate the test for mismatches between the injection table and the samples *)
		cationStandardConflictTest = testOrNull["If CationStandards are specified, the other pertinent options should not be set to Null:", Not[cationStandardConflictQ]];


		(* 5.4 If Standard is specified for electrochemical channel, all electrochemical standard related options, i.e. the gradient and detection options cannot be Null *)
		(* Then we check whether cation standard are specified in the InjectionTable *)
		electrochemicalStandardInInjectionTable = If[electrochemicalInjectionTableSpecifiedQ,
			Cases[electrochemicalInjectionTableLookupRounded, {Standard, __}],
			{}
		];

		(* Check to see if standard exists in the first place *)
		electrochemicalStandardExistsQ = MemberQ[electrochemicalStandardOptionSpecifiedBool, True] || Length[electrochemicalStandardInInjectionTable] > 0;

		(*simultaneously, we should check to see if certain options were set to Null when they shouldn't have been*)
		electrochemicalStandardConflictQ = And[electrochemicalStandardExistsQ, MemberQ[Lookup[roundedOptionsAssociation, electrochemicalStandardOptionsNames], ListableP[Null]]];

		(*do all of our error accounting *)
		invalidElectrochemicalStandardConflictOptions = If[electrochemicalStandardConflictQ && messagesQ,
			(
				Message[Error::StandardOptionConflict, PickList[electrochemicalStandardOptionsNames, Lookup[roundedOptionsAssociation, electrochemicalStandardOptionsNames], ListableP[Null]]];
				PickList[electrochemicalStandardOptionsNames, Lookup[roundedOptionsAssociation, electrochemicalStandardOptionsNames], ListableP[Null]]
			),
			{}
		];

		(* generate the test for mismatches between the injection table and the samples *)
		electrochemicalStandardConflictTest = testOrNull["If Standards are specified for ElectrochemicalChannel, the other pertinent options should not be set to Null:", Not[electrochemicalStandardConflictQ]];

		(* 5.5 If Blank is Nulled out but any blank option is specified, we need to throw an error *)
		standardOptionConflictQ = If[
			And[
				Or[
					(* First check if blank is nulled out in the injection table or in the option *)
					MatchQ[Lookup[roundedOptionsAssociation, Standard], Null | {} | {Null}],
					Length[anionStandardInInjectionTable] > 0,
					Length[cationStandardInInjectionTable] > 0,
					Length[electrochemicalStandardInInjectionTable] > 0
				],
				(* Then we check if any blank related options are specified *)
				Or[Or @@ dualChannelStandardOptionSpecifiedBool, Or @@ electrochemicalStandardOptionSpecifiedBool]
			],
			True,
			False
		];

		(* If we are there are option conflict, throw an error message and collect invalid options *)
		nullStandardOption = If[standardOptionConflictQ && messagesQ,
			(
				Message[Error::HPICNullStandardOption, PickList[Union[dualChannelStandardOptions, electrochemicalStandardOptions], Lookup[roundedOptionsAssociation, Union[dualChannelStandardOptions, electrochemicalStandardOptions]], Except[ListableP[Null | None | Automatic]]]];
				{Standard}
			),
			{}
		];

		(* generate test for nulling Blank option *)
		nullStandardTests = testOrNull["If Standard is nulled out, standard related options should not be specified:", Not[standardptionConflictQ]];


		(* Resolve Standard from option value, or if any other standard options are specified, default to standard, otherwise, use no standard. *)
		initiallyResolvedStandard = Which[

			anionStandardConflictQ || cationStandardConflictQ || standardConflictQ, {},

			(* First check if the option was specified; if user specifies Standard, go with that *)
			!MatchQ[specifiedStandard, ListableP[Automatic]],
			preResolvedStandardAnalysisChannel = {};
			specifiedStandard,

			(* Then check if AnionStandard and CationStandard are specified, if so, construct Standard from these options *)
			Or[
				!MatchQ[specifiedAnionStandard, ListableP[Automatic | Null]],
				!MatchQ[specifiedCationStandard, ListableP[Automatic | Null]]
			],
			preResolvedStandardAnalysisChannel = {};
			Flatten[{specifiedAnionStandard, specifiedCationStandard}] /. {Automatic -> Nothing, Null -> Nothing},

			(* Check whether there were specified standards in the injection table option *)
			Length[Join[
				Cases[anionInjectionTableLookupRounded, {Standard, ObjectP[], ___}],
				Cases[cationInjectionTableLookupRounded, {Standard, ObjectP[], ___}]]] > 0,
			preResolvedStandardAnalysisChannel = {};
			(Join[
				DeleteDuplicates@Cases[anionInjectionTableLookupRounded, {Standard, ObjectP[], ___}],
				DeleteDuplicates@Cases[cationInjectionTableLookupRounded, {Standard, ObjectP[], ___}]])[[All, 2]],

			(* Check whether there were specified standards in the electrochemical injection table *)
			Length[Cases[electrochemicalInjectionTableLookupRounded, {Standard, ObjectP[], ___}]] > 0,
			preResolvedStandardAnalysisChannel = {};
			(DeleteDuplicates@Cases[electrochemicalInjectionTableLookupRounded, {Standard, ObjectP[], ___}])[[All, 2]],

			(* If both AnionStandardFrequency and CationStandardFrequency is None or Null, set Standards to {} *)
			MatchQ[Lookup[roundedOptionsAssociation, AnionStandardFrequency], None | Null] && MatchQ[Lookup[roundedOptionsAssociation, CationStandardFrequency], None | Null] && MatchQ[Lookup[roundedOptionsAssociation, StandardFrequency], None | Null],
			preResolvedStandardAnalysisChannel = {};
			{},

			(* Otherwise, we check whether there are signs that the user wanted standards *)
			And[
				(* If any AnionStandard and CationStandard related options are specified, use default sample models for both channels *)
				Or[
					anySpecifiedQ[Join[anionStandardOptionNames, {AnionStandardSuppressorCurrent, AnionStandardGradientDuration}], roundedOptionsAssociation],
					MatchQ[Lookup[roundedOptionsAssociation, AnionStandardFrequency], Except[None | Null | Automatic]]
				],
				Or[
					anySpecifiedQ[Join[cationStandardOptionNames, {CationStandardGradientB, CationStandardGradientC, CationStandardGradientD, CationStandardSuppressorCurrent, CationStandardSuppressorVoltage, CationStandardGradientDuration}], roundedOptionsAssociation],
					MatchQ[Lookup[roundedOptionsAssociation, CationStandardFrequency], Except[None | Null | Automatic]]
				]
			],
			preResolvedStandardAnalysisChannel = {AnionChanel, CationChannel};
			{Model[Sample, "Multielement Ion Chromatography Anion Standard Solution"], Model[Sample, "Multi Cation Standard 1 for IC"]},

			(* If only AnionStandard related options are specified, use default sample models for anion channel *)
			Or[
				anySpecifiedQ[Join[anionStandardOptionNames, {AnionStandardSuppressorCurrent, AnionStandardSuppressorVoltage, AnionStandardGradientDuration}], roundedOptionsAssociation],
				MatchQ[Lookup[roundedOptionsAssociation, AnionStandardFrequency], Except[None | Null | Automatic]]
			],
			preResolvedStandardAnalysisChannel = {AnionChannel};
			{Model[Sample, "Multielement Ion Chromatography Anion Standard Solution"]},

			(* If only CationStandard related options are specified, use default sample models for cation channel *)
			Or[
				anySpecifiedQ[Join[cationStandardOptionNames, {CationStandardGradientB, CationStandardGradientC, CationStandardGradientD, CationStandardSuppressorCurrent, CationStandardGradientDuration}], roundedOptionsAssociation],
				MatchQ[Lookup[roundedOptionsAssociation, CationStandardFrequency], Except[None | Null | Automatic]]
			],
			preResolvedStandardAnalysisChannel = {CationChannel};
			{Model[Sample, "Multi Cation Standard 1 for IC"]},

			(* If Standard related options are specified for electrochemical detection, use default glucose stock solution as standard *)
			Or[
				anySpecifiedQ[electrochemicalStandardOptions, roundedOptionsAssociation],
				MatchQ[Lookup[roundedOptionsAssociation, StandardFrequency], Except[None | Null | Automatic]]
			],
			preResolvedStandardAnalysisChannel = {ElectrochemicalChannel};
			{Model[Sample, StockSolution, "Glucose solution (5 g/L)"]}, (* TODO: update this once proper standards are purchased *)

			(* All other situations, resolve Standard to Null *)
			True,
			preResolvedStandardAnalysisChannel = {};
			{}
		];

		(* First find all the position of all standard that is specified as Automatic *)
		allStandardAutomaticPositions = Sequence @@@ Position[initiallyResolvedStandard, Automatic];

		(* Then compile a list of alternating cation standard and anion standard *)
		(* Form a replacement rule that is each Automatic -> either cation or anion standard object *)
		anionStandardObjects = If[!MatchQ[allStandardAutomaticPositions, {}],
			ConstantArray[Model[Sample, "Multielement Ion Chromatography Anion Standard Solution"], SafeRound[(Length[allStandardAutomaticPositions] + 1) / 2, 1, Round -> Down]]
		];
		cationStandardObjects = If[!MatchQ[allStandardAutomaticPositions, {}],
			ConstantArray[Model[Sample, "Multi Cation Standard 1 for IC"], Length[allStandardAutomaticPositions] - Length[anionStandardObjects]]
		];
		replacementStandardObjects = If[!NullQ[anionStandardObjects] && !NullQ[cationStandardObjects],
			Riffle[anionStandardObjects, cationStandardObjects]
		];
		replacementStandardRule = If[!NullQ[replacementStandardObjects],
			MapThread[#1 -> #2&, {allStandardAutomaticPositions, replacementStandardObjects}]
		];

		(* Finally replace the automatic to either cation or anion standard *)
		resolvedStandard = If[!NullQ[replacementStandardRule],
			ReplacePart[initiallyResolvedStandard, replacementStandardRule],
			initiallyResolvedStandard
		];

		(* SET UP FOR RESOLVING STANDARDS *)

		(* We first need to set up map friendly options for options that are index matched to Standard/AnionStandard/CationStandard *)
		standardMapThreadOption = {
			StandardAnalysisChannel,
			StandardStorageCondition
		};

		anionStandardMapThreadOption = {
			AnionStandardColumnTemperature,
			AnionStandardInjectionVolume,
			StandardEluentGradient,
			AnionStandardFlowRate,
			AnionStandardGradientStart,
			AnionStandardGradientEnd,
			AnionStandardGradientDuration,
			AnionStandardGradient,
			AnionStandardSuppressorMode,
			AnionStandardSuppressorVoltage,
			AnionStandardSuppressorCurrent,
			AnionStandardDetectionTemperature
		};

		cationStandardMapThreadOption = {
			CationStandardColumnTemperature,
			CationStandardInjectionVolume,
			CationStandardGradientA,
			CationStandardGradientB,
			CationStandardGradientC,
			CationStandardGradientD,
			CationStandardFlowRate,
			CationStandardGradientStart,
			CationStandardGradientEnd,
			CationStandardGradientDuration,
			CationStandardGradient,
			CationStandardSuppressorMode,
			CationStandardSuppressorVoltage,
			CationStandardSuppressorCurrent,
			CationStandardDetectionTemperature
		};

		electrochemicalStandardMapThreadOption = {
			StandardInjectionVolume,
			StandardColumnTemperature,
			StandardGradientA,
			StandardGradientB,
			StandardGradientC,
			StandardGradientD,
			StandardFlowRate,
			StandardGradientStart,
			StandardGradientEnd,
			StandardGradientDuration,
			StandardGradient,
			StandardAbsorbanceWavelength,
			StandardAbsorbanceSamplingRate,
			StandardElectrochemicalDetectionMode,
			StandardReferenceElectrodeMode,
			StandardVoltageProfile,
			StandardWaveformProfile,
			StandardElectrochemicalSamplingRate,
			StandardDetectionTemperature
		};

		(* From the comprehesive list of options, extract options index matched to AnionStandards/CationStandards *)
		extractedStandardOptions = Normal[KeyTake[roundedOptionsAssociation, standardMapThreadOption]];
		extractedAnionStandardOptions = Normal[KeyTake[roundedOptionsAssociation, anionStandardMapThreadOption]];
		extractedCationStandardOptions = Normal[KeyTake[roundedOptionsAssociation, cationStandardMapThreadOption]];
		extractedElectrochemicalStandardOptions = Normal[KeyTake[roundedOptionsAssociation, electrochemicalStandardMapThreadOption]];

		(* Generate MapThread friendly option for Standard, similar to OptionsHandling`Private`mapThreadOptions. *)
		mapThreadFriendlyStandardOptions = If[!MatchQ[resolvedStandard, {} | Null | {Null}],
			Transpose[Map[
				Function[{options},
					Module[{optionSymbol, optionValues, optionSymbolList, optionValuesList},
						(* Separate out the option symfbol from the option values. *)
						optionSymbol = options[[1]];
						optionValues = options[[2]];

						(* Get a list of optionSymbol that is the same length as optionValue. *)
						If[MatchQ[Length[ToList@optionValues], Length[ToList@resolvedStandard]],
							optionSymbolList = ConstantArray[optionSymbol, Length[ToList@optionValues]];optionValuesList = ToList@optionValues,
							optionSymbolList = ConstantArray[optionSymbol, Length[ToList@resolvedStandard]];optionValuesList = ConstantArray[optionValues, Length[ToList@resolvedStandard]]
						];

						MapThread[
							(#1 -> #2&),
							{optionSymbolList, optionValuesList}
						]
					]
				],
				extractedStandardOptions]
			],
			Null
		];


		(* 6. Standard Analysis Channel resolution *)

		(* Helper function to resolve Standard Analysis Channel *)
		{initiallyResolvedStandardAnalysisChannel, imbalancedStandardAnionCationGroupingErrors} = Which[
			(* If there is no standard, there's no analysis channel *)
			MatchQ[resolvedStandard, {} | {Null} | Null],
			{{}, False},

			(* If StandardAnalysisChannel is specified, go with that and set error tracking variable to be false *)
			!MemberQ[ToList[Lookup[roundedOptionsAssociation, StandardAnalysisChannel]], Automatic],
			{Lookup[roundedOptionsAssociation, StandardAnalysisChannel], False},

			Length[preResolvedStandardAnalysisChannel] > 0,
			{preResolvedStandardAnalysisChannel, False},

			(* If resolvedAnalysisChannel is already ElectrochemicalChannel, then go ahead and set StandardAnalysisChannel to ElectrochemicalChannel as well *)
			MemberQ[ToList@resolvedAnalysisChannel, ElectrochemicalChannel],
			{Table[ElectrochemicalChannel, Length[ToList[resolvedStandard]]], False},

			(* Otherwise, go through helper function to figure out whether the resolved Standard goes into Anion or Cation Channel *)
			True,
			resolveICAnalysisChannel[resolvedStandard, roundedOptionsAssociation, mapThreadFriendlyStandardOptions, Standard, StandardAnalysisChannel, AnionStandard, CationStandard, fullCache]
		];

		(* Get the model packets of the resolved standard *)
		resolvedStandardModelPackets = If[MatchQ[resolvedStandard, {} | Null | {Null}],
			{},

			Map[
				Which[
					(* If the resolved Standard is specified as a sample object, download it's model object *)
					MatchQ[#, ObjectP[Object[Sample]]],
					Lookup[fetchPacketFromCache[#, fullCache], Model],

					(* If the resolved Standard is specified as a model object, then download directly *)
					MatchQ[#, ObjectP[Model[Sample]]],
					Lookup[fetchPacketFromCache[#, fullCache], Object],

					True,
					#
				]&,
				Download[resolvedStandard, Object]
			]
		];

		(* Within the downloaded resolved standard model packets, look to see if there are matches for model object for default anion or cation standard *)
		(* If so find the position for the default anion and cation standard *)
		defaultAnionStandardPosition = Flatten[Position[resolvedStandardModelPackets, Model[Sample, "id:dORYzZJkKY6D"]]];
		defaultCationStandardPosition = Flatten[Position[resolvedStandardModelPackets, Model[Sample, "id:M8n3rx0mDjZR"]]];

		(* First check to see if there is duplicated standard *)
		duplicateFreeStandardQ = If[Length[ToList@resolvedStandard] > 0,
			If[MemberQ[ToList@initiallyResolvedStandardAnalysisChannel, ElectrochemicalChannel],
				True,
				DuplicateFreeQ[ToList@resolvedStandard]
			],
			True
		];
		(* An extreme rare edge case here is that when the same sample is specified in the InjectionTable for AnionChannel and CationChannel *)
		(* For example, an user specified Milli-Q water as anion blank and as cation blank in the InjectionTable *)
		(* Then when resolved analysis channel, these duplicate samples will have a duplicate assignment of analysis channels *)
		(* e.g. each water blank's analysis channel will be {AnionChannel, CationChannel} *)
		(* So here we are getting the list of duplicated analysis channel assignment first *)
		duplicateStandardAnalysisChannel = Select[Length /@ ToList@initiallyResolvedStandardAnalysisChannel, Length[#] > 1&];
		duplicateStandardAnalysisChannelQ = If[Length[duplicateStandardAnalysisChannel] > 0,
			True,
			False
		];

		(* If there is no duplicate standard, use the initially resolved standard analysis channel for final resolution *)
		duplicateStandardAnalysisChannelExpansion = If[duplicateFreeStandardQ || !duplicateStandardAnalysisChannelQ,
			initiallyResolvedStandardAnalysisChannel,

			Module[{standardTally, duplicateStandard, standardAnalysisChannel, analysisChannelReplaceRule},
				(* Count the time each standard appears and compile a list positions for only duplicated standard*)
				standardTally = Position[resolvedStandard, #]& /@ Keys@Counts[resolvedStandard];
				duplicateStandard = DeleteCases[standardTally, {_}];

				(* Find the standard analysis channel values for the duplicate standard samples *)
				standardAnalysisChannel = Extract[initiallyResolvedStandardAnalysisChannel, First[#]]& /@ duplicateStandard;
				(* Compile a list of replacement rules *)
				(* For duplicated samples, its corresponding analysis channel will be something like {CationChannel,AnionChannel} instead of a single value *)
				(* This map thread command will compile the replcament rule with position -> analysis channel resolved value *)
				analysisChannelReplaceRule = MapThread[#1 -> #2&, {Flatten@duplicateStandard, Flatten@standardAnalysisChannel}];
				(* Replace the initially resolved standard analysis channel with correct value *)
				ReplacePart[initiallyResolvedStandardAnalysisChannel, analysisChannelReplaceRule]
			]
		];

		resolvedStandardAnalysisChannel = If[MatchQ[initiallyResolvedStandardAnalysisChannel, {} | Null | {Null}],
			{},
			Which[
				MatchQ[defaultAnionStandardPosition, Except[{}]] && MatchQ[defaultCationStandardPosition, Except[{}]],
				ReplacePart[duplicateStandardAnalysisChannelExpansion, {defaultAnionStandardPosition -> AnionChannel, defaultCationStandardPosition -> CationChannel}],

				MatchQ[defaultAnionStandardPosition, Except[{}]],
				ReplacePart[duplicateStandardAnalysisChannelExpansion, defaultAnionStandardPosition -> AnionChannel],

				MatchQ[defaultCationStandardPosition, Except[{}]],
				ReplacePart[duplicateStandardAnalysisChannelExpansion, defaultCationStandardPosition -> CationChannel],

				True,
				duplicateStandardAnalysisChannelExpansion
			]
		];

		(* == Error checking == *)
		(* 6.1 If Anion/CationChannel are used, we need to check if the total anion and cation standards injected into each channel adds up to the total standard sample *)
		(* If there is imbalanced grouping of samples and we are throwing messages, then throw error message and collect invalid options *)
		imbalancedStandardAnionCationGroupingOption = If[MatchQ[imbalancedStandardAnionCationGroupingErrors, True] && messagesQ,
			(
				Message[Error::ImbalancedAnionCationGrouping, AnionStandard, CationStandard, Standard];
				{AnionStandard, CationStandard}
			),
			{}
		];

		(* Generate test to check anion and cation sample grouping *)
		repeatedStandardGroupingTests = testOrNull["If AnionStandard and CationStandard are specified and StandardAnalysiChannel is not, the total number of standards from these two groups equals that of the specified standard:", Not[imbalancedStandardAnionCationGroupingErrors]];

		(* 7. AnionStandard resolution *)

		(* AnionStandard can either be directly specified or be set when AnalysisChannel has been resolved *)
		resolvedAnionStandard = If[MatchQ[resolvedStandard, Null | {Null} | {}] && !MemberQ[resolvedStandardAnalysisChannel, ElectrochemicalChannel],

			(* If there is no resolvedStandard, there is also no resolvedAnionStandard *)
			{},

			Which[

				(* If user specified AnionStandard, go with the specified option *)
				MatchQ[specifiedAnionStandard, Except[Null | Automatic | {Automatic}]],
				specifiedAnionStandard,

				(* If Samples and AnalysisChannel are specified in the InjectionTable, compile AnionStandard from the InjectionTable *)
				MemberQ[anionInjectionTableLookupRounded, {Standard, __}],
				Lookup[fetchPacketFromCache[#, fullCache], Object]& /@ (Cases[anionInjectionTableLookupRounded, {Standard, __}][[All, 2]]),

				(* If only AnionStandard related options are specified, use default sample models for anion channel *)
				Or[
					anySpecifiedQ[Join[anionStandardOptionNames, {AnionStandardSuppressorCurrent, AnionStandardGradientDuration}], roundedOptionsAssociation],
					MatchQ[Lookup[roundedOptionsAssociation, AnionStandardFrequency], Except[None | Null | Automatic]]
				],
				{Model[Sample, "Multielement Ion Chromatography Anion Standard Solution"]},

				(* Once AnalysisChannel is resolved, compile all the samples with AnalysisChannel set to AnionChannel *)
				!MatchQ[resolvedStandardAnalysisChannel, ListableP[Automatic] | {}],
				PickList[ToList@resolvedStandard, ToList@resolvedStandardAnalysisChannel, AnionChannel],

				True,
				{}
			]];

		(* 8. CationStandard resolution *)

		(* CationSamples can either be directly specified or be set when AnalysisChannel has been resolved *)
		resolvedCationStandard = If[MatchQ[resolvedStandard, Null | {} | {Null}],

			(* If there is no resolvedStandard, there is also no resolvedCationStandard *)
			{},

			Which[

				(* If user specified CationSamples, go with the specified option *)
				MatchQ[specifiedCationStandard, Except[Null | Automatic | {Automatic}]],
				specifiedCationStandard,

				(* If Standards and AnalysisChannel are specified in the InjectionTable, compile CationSamples from the InjectionTable *)
				MemberQ[cationInjectionTableLookupRounded, {Standard, __}],
				Lookup[fetchPacketFromCache[#, fullCache], Object]& /@ (Cases[cationInjectionTableLookupRounded, {Standard, __}][[All, 2]]),

				(* If only CationStandard related options are specified, use default sample models for cation channel *)
				Or[
					anySpecifiedQ[Join[cationStandardOptionNames, {CationStandardGradientB, CationStandardGradientC, CationStandardGradientD, CationStandardSuppressorCurrent, CationStandardGradientDuration}], roundedOptionsAssociation],
					MatchQ[Lookup[roundedOptionsAssociation, CationStandardFrequency], Except[None | Null | Automatic]]
				],
				{Model[Sample, "Multi Cation Standard 1 for IC"]},

				(* Once AnalysisChannel is resolved, compile all the samples with AnalysisChannel set to CationChannel *)
				!MatchQ[resolvedStandardAnalysisChannel, ListableP[Automatic] | {}],
				PickList[ToList@resolvedStandard, ToList@resolvedStandardAnalysisChannel, CationChannel],

				True,
				{}
			]];

		(* Once cation and anion standards are resolved, double resolve AnalysisChannel again to correct the edge case assignment *)
		(* Such that if two waters appear as blanks, the analysis channel will assign to anion channel and cation channel *)
		doubleResolvedStandardAnalysisChannel = Module[{
			anionStandardPosition, cationStandardPosition, anionChannelArray, cationChannelArray, anionChannelRule, cationChannelRule},

			If[MemberQ[ToList@resolvedStandardAnalysisChannel, ElectrochemicalChannel],
				resolvedStandardAnalysisChannel,

				(* First, find the position of anion blanks from the list of blanks *)
				(* Repeat for cation; the only difference here is that the cation positions are found using Complement *)
				(* For example, if anion positions are 1,4 in a list of 5 blanks, then cation positions automatically takes on 2,3,and 5 *)
				anionStandardPosition = Flatten[FirstPosition[ToList@Download[resolvedStandard, Object], #]]& /@ ToList[Download[resolvedAnionStandard, Object]];
				cationStandardPosition = DeleteCases[Range[1, Length[resolvedStandardAnalysisChannel]], Alternatives @@ anionStandardPosition];

				(* Make constant array of either AnionChannel or CationChannel for the length of anion blanks and cation blanks respectively *)
				anionChannelArray = ConstantArray[AnionChannel, Length[anionStandardPosition]];
				cationChannelArray = ConstantArray[CationChannel, Length[cationStandardPosition]];

				(* Construct rule that points position to their corresponding channel assignment *)
				anionChannelRule = MapThread[#1 -> #2&, {anionStandardPosition, anionChannelArray}];
				cationChannelRule = MapThread[#1 -> #2&, {cationStandardPosition, cationChannelArray}];

				(* Finally use the rules above to replace the resolvedStandardAnalysisChanenl *)
				ReplacePart[resolvedStandardAnalysisChannel, Join[anionChannelRule, cationChannelRule]]
			]
		];

		(* == Error checking == *)

		(* Construct a list with all the simulatedSamples in the first place and its corresponding specifiedAnalysisChannel in the second place *)
		allStandardWithSpecifiedChannel = If[MatchQ[resolvedStandard, Null | {} | {Null}] || MatchQ[specifiedStandard, ListableP[Automatic]] || MatchQ[doubleResolvedStandardAnalysisChannel, {}],
			Null,
			Transpose[{ToList@resolvedStandard, ToList@doubleResolvedStandardAnalysisChannel}]
		];

		(* 8.1 When StandardAnalysisChannel and StandardAnionSamples options are conflicting, throw error *)

		(* Extract the AnionSamples along with their specifiedAnalysisChannel from the all samples list *)
		anionStandardWithSpecifiedChannel = If[!NullQ[allStandardWithSpecifiedChannel] && MatchQ[resolvedAnionStandard, Except[Null | Automatic]],
			Flatten[Cases[allStandardWithSpecifiedChannel, {#, _}]& /@ ToList[resolvedAnionStandard], 1],
			Null
		];

		consistentAnionStandardChannelQ = If[MatchQ[anionStandardWithSpecifiedChannel, Null | {}],

			(* If either AnalysisChannel or AnionSamples option is not specified, then set this variable to False *)
			False,

			If[
				(* If user has specified AnionSamples *)
				!MatchQ[resolvedAnionStandard, Except[Automatic | Null]],

				(* Then check if all the specified AnalysisChannel is AnionChannel *)
				(* Here FALSE = channel specification is consistent *)
				Not[MatchQ[#, {_, AnionChannel}]],

				(* If either option is not specified, then set this variable to False *)
				False
			]& /@ anionStandardWithSpecifiedChannel
		];

		(* Compile a list of anion samples that have their AnalysisChannel set to CationChannel *)
		invalidAnionStandardChannelSpecification = If[MatchQ[resolvedAnionStandard, Except[Null | {} | {Null} | Automatic]] && MatchQ[anionStandardWithSpecifiedChannel, Except[{} | Null]],
			PickList[ToList@resolvedAnionStandard, consistentAnionStandardChannelQ, True],
			Null
		];

		(* If there are invalid specifcation AND we are throwing messages, then throw an error, and collect AnalysisChannel option *)
		inconsistentAnionStandardChannelOption = If[Length[invalidAnionStandardChannelSpecification] > 0 && messagesQ,
			If[TrueQ[imbalancedStandardAnionCationGroupingErrors],
				{},
				(
					Message[Error::InconsistentAnalysisChannelSpecification, AnionStandard, ObjectToString[invalidAnionStandardChannelSpecification,Cache -> fullCache, Simulation -> updatedSimulation], CationChannel, AnionChannel];
					{StandardAnalysisChannel}
				)
			],
			{}
		];

		(* Generate tests for inconsistent analysis channel specification *)
		anionStandardChannelSpecificationTests = testOrNullIndexMatched["If both AnionStandard and StandardAnalysisChannel are specified, StandardAnalysisChannels of all AnionStandard should be AnionChannel:", resolvedAnionStandard, consistentAnionStandardChannelQ];

		(* 8.2 When StandardAnalysisChannel and CationStandard options are conflicting, CationStandard take priority *)

		(* Extract the AnionSamples along with their specifiedAnalysisChannel from the all samples list *)
		cationStandardWithSpecifiedChannel = If[!NullQ[allStandardWithSpecifiedChannel] && MatchQ[resolvedCationStandard, Except[Null | Automatic]],
			Flatten[Cases[allStandardWithSpecifiedChannel, {#, _}]& /@ ToList[resolvedCationStandard], 1],
			Null
		];

		consistentCationStandardChannelQ = If[MatchQ[cationStandardWithSpecifiedChannel, Null | {}],

			(* If either AnalysisChannel or CationSample option is not specified, then set this variable to True *)
			False,

			If[
				(* If user has specified AnionSamples *)
				MatchQ[resolvedCationStandard, Except[Automatic | Null]],

				(* Then check if all the specified AnalysisChannel is AnionChannel *)
				(* Here FALSE = channel specification is consistent *)
				Not[MatchQ[#, {_, CationChannel}]],

				(* If either option is not specified, then set this variable to False *)
				False
			]& /@ cationStandardWithSpecifiedChannel
		];

		(* Compile a list of anion samples that have their AnalysisChannel set to CationChannel *)
		invalidCationStandardChannelSpecification = If[MatchQ[resolvedCationStandard, Except[Null | {} | {Null} | Automatic]] && MatchQ[cationStandardWithSpecifiedChannel, Except[{} | Null]],
			PickList[ToList@resolvedCationStandard, consistentCationStandardChannelQ, True],
			Null
		];

		(* If there are invalid specifcation AND we are throwing messages, then throw an error, and collect AnalysisChannel option *)
		inconsistentCationStandardChannelOption = If[Length[invalidCationStandardChannelSpecification] > 0 && messagesQ,
			If[TrueQ[imbalancedStandardAnionCationGroupingErrors],
				(
					Message[Error::InconsistentAnalysisChannelSpecification, CationStandard, ObjectToString[invalidCationStandardChannelSpecification, Cache -> fullCache, Simulation -> updatedSimulation], AnionChannel, CationChannel];
					{StandardAnalysisChannel}
				),
				{}
			],
			{}
		];

		(* Generate tests for inconsistent analysis channel specification *)
		cationStandardChannelSpecificationTests = testOrNullIndexMatched["If both CationStandard and StandardAnalysisChannel are specified, StandardAnalysisChannels of all CationStandard should be CationChannel:", resolvedCationStandard, consistentCationStandardChannelQ];

		(* 8.3 AnionStandard and CationStandard check together *)
		(* Get the number of standard as well as the number of resolvedAnionStandard and resolvedCationStandard *)
		totalStandard = If[MatchQ[doubleResolvedStandardAnalysisChannel, {}],
			ToList@resolvedStandard,
			Length[PickList[Cases[ToList@resolvedStandard, Except[Null]], ToList@doubleResolvedStandardAnalysisChannel, AnionChannel | CationChannel]]
		];
		totalResolvedStandard = Length[ToList@resolvedAnionStandard] + Length[ToList@resolvedCationStandard];

		(* Check to see if the number of resolved samples add up to the number of input samples *)
		(* False here means the sample number matches *)
		totalStandardConsistentQ = If[!MatchQ[doubleResolvedStandardAnalysisChannel, {}],
			Not[MatchQ[totalStandard, totalResolvedStandard]],
			False
		];

		(* If the number of samples don't match up and we are throwing message, throw error message and collect invalid options *)
		invalidStandardGroupingOption = If[totalStandardConsistentQ && messagesQ,
			If[TrueQ[imbalancedStandardAnionCationGroupingErrors],
				(
					Message[Error::ImbalancedAnionCationGrouping, AnionStandard, CationStandard, Standard];
					{AnionStandard, CationStandard, StandardAnalysisChannel}
				),
				{}
			],
			{}
		];

		(* Generate test to check imbalanced grouping of cation and anion samples *)
		standardGroupingTests = testOrNull["If StandardAnalysisChannel and either AnionStandard or CationStandard are specified, the total number of standards from specified or resolved AnionStandard and CationStandard sums up to the total number of standard:", Not[totalStandardConsistentQ]];

		(* 9. Blank resolution *)

		(* First compile all the Blank related options, including AnionBlank, and CationBlank related options *)
		(* This method is a little weird but it ensures that if we add new options we don't need to remember to add them to a hard coded list here *)
		sharedBlankOptionNames = {
			BlankStorageCondition,
			BlankAnalysisChannel
		};
		anionBlankOptionNames = {
			AnionBlankFrequency,
			AnionBlankColumnTemperature,
			AnionBlankInjectionVolume,
			BlankEluentGradient,
			AnionBlankFlowRate,
			AnionBlankGradient,
			AnionBlankSuppressorMode,
			AnionBlankDetectionTemperature
		};
		cationBlankOptionNames = {
			CationBlankFrequency,
			CationBlankColumnTemperature,
			CationBlankInjectionVolume,
			CationBlankGradientA,
			CationBlankGradientB,
			CationBlankGradientC,
			CationBlankGradientD,
			CationBlankFlowRate,
			CationBlankGradient,
			CationBlankSuppressorMode,
			CationBlankDetectionTemperature
		};
		electrochemicalBlankOptionNames = {
			BlankFrequency,
			BlankInjectionVolume,
			BlankColumnTemperature,
			BlankGradientA,
			BlankGradientB,
			BlankGradientC,
			BlankGradientD,
			BlankFlowRate,
			BlankGradient
		};
		dualChannalBlankOptions = Join[
			sharedBlankOptionNames,
			anionBlankOptionNames,
			cationBlankOptionNames,
			{CationBlankGradientDuration, CationBlankSuppressorVoltage, CationBlankSuppressorCurrent},
			{AnionBlankGradientDuration, AnionBlankSuppressorVoltage, AnionBlankSuppressorCurrent}
		];
		electrochemicalBlankOptions = Join[sharedBlankOptionNames, electrochemicalBlankOptionNames,
			{BlankGradientDuration, BlankVoltageProfile, BlankWaveformProfile, BlankAbsorbanceWavelength,
				BlankAbsorbanceSamplingRate, BlankElectrochemicalDetectionMode, BlankReferenceElectrodeMode, BlankElectrochemicalSamplingRate,
				BlankDetectionTemperature}
		];

		(* == Error checking == *)

		(* 9.1 If Blank is specified, BlankAnalysisChannel, BlankInjectionVolume, and BlankStorageCondition cannot be Null *)

		(*first we ask if any of the Blank options are defined*)
		blankOptionSpecifiedBool = Map[
			MatchQ[Lookup[roundedOptionsAssociation, #], Except[ListableP[(Null | None | Automatic | Disposal)]]]&,
			dualChannalBlankOptions
		];
		electrochemicalBlankOptionSpecifiedBool = Map[
			MatchQ[Lookup[roundedOptionsAssociation, #], Except[ListableP[(Null | None | Automatic)]]]&,
			electrochemicalBlankOptions
		];

		(* Check to see if Blank exists in the first place *)
		blankExistsQ = MatchQ[Lookup[roundedOptionsAssociation, Blank], Except[Null]] || MemberQ[blankOptionSpecifiedBool, True] || MemberQ[electrochemicalStandardOptionSpecifiedBool, True] || MemberQ[anionInjectionTableTypes, Blank] || MemberQ[cationInjectionTableTypes, Blank] || MemberQ[electrochemicalInjectionTableTypes, Blank];

		(*simultaneously, we should check to see if certain options were set to Null when they shouldn't have been*)
		blankConflictOptions = {BlankAnalysisChannel, BlankStorageCondition};
		blankConflictQ = And[blankExistsQ, MemberQ[Lookup[roundedOptionsAssociation, blankConflictOptions], ListableP[Null]]];

		(*do all of our error accounting *)
		invalidBlankConflictOptions = If[blankConflictQ && messagesQ,
			(
				Message[Error::BlankOptionConflict, PickList[blankConflictOptions, Lookup[roundedOptionsAssociation, blankConflictOptions], ListableP[Null]]];
				PickList[blankConflictOptions, Lookup[roundedOptionsAssociation, blankConflictOptions], ListableP[Null]]
			),
			{}
		];

		(* generate the test for mismatches between the injection table and the samples *)
		blankConflictTest = testOrNull["If blanks are specified, the other pertinent options should not be set to Null:", Not[blankConflictQ]];

		(* 9.2 If AnionBlank is specified, all anion Blank related options, i.e. the gradient and detection options cannot be Null *)
		(*first we ask if any of the anion Blank options are defined*)
		anionBlankOptionSpecifiedBool = Map[
			MatchQ[Lookup[roundedOptionsAssociation, #], Except[ListableP[(Null | None | Automatic | Ambient)]]]&,
			anionBlankOptionNames
		];

		(* Then we check whether anion Blank are specified in the InjectionTable *)
		anionBlankInInjectionTable = If[anionInjectionTableSpecifiedQ,
			Cases[anionInjectionTableLookupRounded, {Blank, __}],
			{}
		];

		(* Check to see if Blank exists in the first place *)
		anionBlankExistsQ = MatchQ[Lookup[roundedOptionsAssociation, AnionBlank], Except[Null]] || MemberQ[anionBlankOptionSpecifiedBool, True] || Length[anionBlankInInjectionTable] > 0;

		(*simultaneously, we should check to see if certain options were set to Null when they shouldn't have been*)
		anionBlankConflictQ = And[anionBlankExistsQ, MemberQ[Lookup[roundedOptionsAssociation, anionBlankOptionNames], ListableP[Null]]];

		(*do all of our error accounting *)
		invalidAnionBlankConflictOptions = If[anionBlankConflictQ && messagesQ,
			(
				Message[Error::BlankOptionConflict, PickList[anionBlankOptionNames, Lookup[roundedOptionsAssociation, anionBlankOptionNames], ListableP[Null]]];
				PickList[anionBlankOptionNames, Lookup[roundedOptionsAssociation, anionBlankOptionNames], ListableP[Null]]
			),
			{}
		];

		(* generate the test for mismatches between the injection table and the samples *)
		anionBlankConflictTest = testOrNull["If AnionBlanks are specified, the other pertinent options should not be set to Null:", Not[anionBlankConflictQ]];

		(* 9.3 If CationBlank is specified, all cation Blank related options, i.e. the gradient and detection options cannot be Null *)
		(*first we ask if any of the cation Blank options are defined*)
		cationBlankOptionSpecifiedBool = Map[
			MatchQ[Lookup[roundedOptionsAssociation, #], Except[ListableP[(Null | None | Automatic | Ambient)]]]&,
			cationBlankOptionNames
		];

		(* Then we check whether cation Blank are specified in the InjectionTable *)
		cationBlankInInjectionTable = If[cationInjectionTableSpecifiedQ,
			Cases[cationInjectionTableLookupRounded, {Blank, __}],
			{}
		];

		(* Check to see if Blank exists in the first place *)
		cationBlankExistsQ = MatchQ[Lookup[roundedOptionsAssociation, CationBlank], Except[Null]] || MemberQ[cationBlankOptionSpecifiedBool, True] || Length[cationBlankInInjectionTable] > 0;

		(*simultaneously, we should check to see if certain options were set to Null when they shouldn't have been*)
		cationBlankConflictQ = And[cationBlankExistsQ, MemberQ[Lookup[roundedOptionsAssociation, cationBlankOptionNames], ListableP[Null]]];

		(*do all of our error accounting *)
		invalidCationBlankConflictOptions = If[cationBlankConflictQ && messagesQ,
			(
				Message[Error::BlankOptionConflict, PickList[cationBlankOptionNames, Lookup[roundedOptionsAssociation, cationBlankOptionNames], ListableP[Null]]];
				PickList[cationBlankOptionNames, Lookup[roundedOptionsAssociation, cationBlankOptionNames], ListableP[Null]]
			),
			{}
		];

		(* generate the test for mismatches between the injection table and the samples *)
		cationBlankConflictTest = testOrNull["If CationBlanks are specified, the other pertinent options should not be set to Null:", Not[cationBlankConflictQ]];

		(* 9.4 If Blank is specified for electrochemical channel, all Blank related options, i.e. the gradient and detection options cannot be Null *)
		(* Then we check whether cation Blank are specified in the InjectionTable *)
		electrochemicalBlankInInjectionTable = If[electrochemicalInjectionTableSpecifiedQ,
			Cases[electrochemicalInjectionTableLookupRounded, {Blank, __}],
			{}
		];

		(* Check to see if Blank exists in the first place *)
		electrochemicalBlankExistsQ = MemberQ[electrochemicalBlankOptionSpecifiedBool, True] || Length[electrochemicalBlankInInjectionTable] > 0;

		(*simultaneously, we should check to see if certain options were set to Null when they shouldn't have been*)
		electrochemicalBlankConflictQ = And[electrochemicalBlankExistsQ, MemberQ[Lookup[roundedOptionsAssociation, electrochemicalBlankOptionNames], ListableP[Null]]];

		(*do all of our error accounting *)
		invalidElectrochemicalBlankConflictOptions = If[electrochemicalBlankConflictQ && messagesQ,
			(
				Message[Error::BlankOptionConflict, PickList[electrochemicalBlankOptionNames, Lookup[roundedOptionsAssociation, electrochemicalBlankOptionNames], ListableP[Null]]];
				PickList[electrochemicalBlankOptionNames, Lookup[roundedOptionsAssociation, electrochemicalBlankOptionNames], ListableP[Null]]
			),
			{}
		];

		(* generate the test for mismatches between the injection table and the samples *)
		electrochemicalBlankConflictTest = testOrNull["If Blanks are specified for electrochemical channel, the other pertinent options should not be set to Null:", Not[electrochemicalBlankConflictQ]];

		(* 9.6 If Blank is Nulled out but any blank option is specified, we need to throw an error *)
		blankOptionConflictQ = If[
			And[
				Or[
					(* First check if blank is nulled out in the injection table or in the option *)
					MatchQ[Lookup[roundedOptionsAssociation, Blank], Null | {} | {Null}],
					Length[anionBlankInInjectionTable] > 0,
					Length[cationBlankInInjectionTable] > 0,
					Length[electrochemicalBlankInInjectionTable] > 0
				],
				(* Then we check if any blank related options are specified *)
				Or[Or @@ blankOptionSpecifiedBool, Or @@ electrochemicalBlankOptionSpecifiedBool]
			],
			True,
			False
		];

		(* If we are there are option conflict, throw an error message and collect invalid options *)
		nullBlankOption = If[blankOptionConflictQ && messagesQ,
			(
				Message[Error::HPICNullBlankOption, PickList[Union[dualChannalBlankOptions, electrochemicalBlankOptions], Lookup[roundedOptionsAssociation, Union[dualChannalBlankOptions, electrochemicalBlankOptions]], Except[ListableP[Null | None | Automatic]]]];
				{Blank}
			),
			{}
		];

		(* generate test for nulling Blank option *)
		nullBlankTests = testOrNull["If Blank is nulled out, blank related options should not be specified:", Not[blankOptionConflictQ]];

		(* Resolve Blank from option value, or if any other Blank options are specified, default to Blank, otherwise, use no Blank. *)
		initiallyResolvedBlank = Which[

			anionBlankConflictQ || cationBlankConflictQ || blankConflictQ, {},

			(* First check if the option was specified; if user specifies Blank, go with that *)
			!MatchQ[specifiedBlank, ListableP[Automatic]],
			preResolvedBlankAnalysisChannel = {};
			specifiedBlank,

			(* Then check if AnionBlank and CationBlank are specified, if so, construct Blank from these options *)
			Or[
				!MatchQ[specifiedAnionBlank, ListableP[Automatic | Null]],
				!MatchQ[specifiedCationBlank, ListableP[Automatic | Null]]
			],
			preResolvedBlankAnalysisChannel = {};
			Flatten[{specifiedAnionBlank, specifiedCationBlank}] /. {Automatic -> Nothing, Null -> Nothing},

			(* Check whether there were specified blanks in the injection table option *)
			Length[Join[
				Cases[anionInjectionTableLookupRounded, {Blank, ObjectP[], ___}],
				Cases[cationInjectionTableLookupRounded, {Blank, ObjectP[], ___}]]] > 0,
			preResolvedBlankAnalysisChannel = {};
			(Join[
				DeleteDuplicates@Cases[anionInjectionTableLookupRounded, {Blank, ObjectP[], ___}],
				DeleteDuplicates@Cases[cationInjectionTableLookupRounded, {Blank, ObjectP[], ___}]])[[All, 2]],

			(* Check whether there were specified standards in the electrochemical injection table *)
			Length[Cases[electrochemicalInjectionTableLookupRounded, {Blank, ObjectP[], ___}]] > 0,
			preResolvedBlankAnalysisChannel = {};
			(DeleteDuplicates@Cases[electrochemicalInjectionTableLookupRounded, {Blank, ObjectP[], ___}])[[All, 2]],

			(* If both AnionBlankFrequency and CationBlankFrequency is None or Null, set Blank to {} *)
			MatchQ[Lookup[roundedOptionsAssociation, AnionBlankFrequency], None | Null] && MatchQ[Lookup[roundedOptionsAssociation, CationBlankFrequency], None | Null],
			preResolvedBlankAnalysisChannel = {};
			{},

			(* Otherwise, we check whether there are signs that the user wanted Blanks *)
			And[
				(* If any AnionBlank and CationBlank related options are specified, use default sample models for both channels *)
				Or[
					anySpecifiedQ[Join[anionBlankOptionNames, {AnionBlankGradientDuration, AnionBlankSuppressorCurrent}], roundedOptionsAssociation],
					MatchQ[Lookup[roundedOptionsAssociation, AnionBlankFrequency], Except[None | Null | Automatic]]
				],
				Or[
					anySpecifiedQ[Join[cationBlankOptionNames, {CationBlankGradientB, CationBlankGradientC, CationBlankGradientD, CationBlankGradientDuration, CationBlankSuppressorCurrent}], roundedOptionsAssociation],
					MatchQ[Lookup[roundedOptionsAssociation, CationBlankFrequency], Except[None | Null | Automatic]]
				]
			],
			preResolvedBlankAnalysisChannel = {AnionChannel, CationChannel};
			{Model[Sample, "Milli-Q water"], Model[Sample, "Milli-Q water"]},

			(* If only AnionBlank related options are specified, use default sample models for anion channel *)
			Or[
				anySpecifiedQ[Join[anionBlankOptionNames, {AnionBlankGradientDuration, AnionBlankSuppressorCurrent}], roundedOptionsAssociation],
				MatchQ[Lookup[roundedOptionsAssociation, AnionBlankFrequency], Except[None | Null | Automatic]]
			],
			preResolvedBlankAnalysisChannel = {AnionChannel};
			{Model[Sample, "Milli-Q water"]},

			(* If only CationBlank related options are specified, use default sample models for cation channel *)
			Or[
				anySpecifiedQ[Join[cationBlankOptionNames, {BlankGradientB, BlankGradientC, BlankGradientD, CationBlankGradientDuration, CationBlankSuppressorCurrent}], roundedOptionsAssociation],
				MatchQ[Lookup[roundedOptionsAssociation, CationBlankFrequency], Except[None | Null | Automatic]]
			],
			preResolvedBlankAnalysisChannel = {CationChannel};
			{Model[Sample, "Milli-Q water"]},

			(* If Blank related options are specified for electrochemical detection, use Milli-Q water as default blank *)
			Or[
				anySpecifiedQ[electrochemicalBlankOptions, roundedOptionsAssociation],
				MatchQ[Lookup[roundedOptionsAssociation, BlankFrequency], Except[None | Null | Automatic]]
			],
			preResolvedBlankAnalysisChannel = {ElectrochemicalChannel};
			{Model[Sample, "Milli-Q water"]},

			(* All other situations, resolve Blank to Null *)
			True,
			preResolvedBlankAnalysisChannel = {};
			{}
		];

		(* Replace any automatic in the list of initially resolved blanks into Milli-Q water *)
		resolvedBlank = initiallyResolvedBlank /. {Automatic -> Model[Sample, "Milli-Q water"]};

		(* SET UP FOR RESOLVING BLANKS *)

		(* We first need to set up map friendly options for options that are index matched to Blank/AnionBlank/CationBlank *)
		blankMapThreadOption = {
			BlankAnalysisChannel,
			BlankStorageCondition
		};

		anionBlankMapThreadOption = {
			AnionBlankColumnTemperature,
			AnionBlankInjectionVolume,
			BlankEluentGradient,
			AnionBlankFlowRate,
			AnionBlankGradientStart,
			AnionBlankGradientEnd,
			AnionBlankGradientDuration,
			AnionBlankGradient,
			AnionBlankSuppressorMode,
			AnionBlankSuppressorVoltage,
			AnionBlankSuppressorCurrent,
			AnionBlankDetectionTemperature
		};

		cationBlankMapThreadOption = {
			CationBlankColumnTemperature,
			CationBlankInjectionVolume,
			CationBlankGradientA,
			CationBlankGradientB,
			CationBlankGradientC,
			CationBlankGradientD,
			CationBlankFlowRate,
			CationBlankGradientStart,
			CationBlankGradientEnd,
			CationBlankGradientDuration,
			CationBlankGradient,
			CationBlankSuppressorMode,
			CationBlankSuppressorVoltage,
			CationBlankSuppressorCurrent,
			CationBlankDetectionTemperature
		};

		electrochemicalBlankMapThreadOption = {
			BlankInjectionVolume,
			BlankColumnTemperature,
			BlankGradientA,
			BlankGradientB,
			BlankGradientC,
			BlankGradientD,
			BlankGradientStart,
			BlankGradientEnd,
			BlankGradientDuration,
			BlankFlowRate,
			BlankGradient,
			BlankAbsorbanceWavelength,
			BlankAbsorbanceSamplingRate,
			BlankElectrochemicalDetectionMode,
			BlankReferenceElectrodeMode,
			BlankVoltageProfile,
			BlankWaveformProfile,
			BlankElectrochemicalSamplingRate,
			BlankDetectionTemperature
		};

		(* From the comprehesive list of options, extract options index matched to AnionBlanks/CationBlanks *)
		extractedBlankOptions = Normal[KeyTake[roundedOptionsAssociation, blankMapThreadOption]];
		extractedAnionBlankOptions = Normal[KeyTake[roundedOptionsAssociation, anionBlankMapThreadOption]];
		extractedCationBlankOptions = Normal[KeyTake[roundedOptionsAssociation, cationBlankMapThreadOption]];
		extractedElectrochemicalBlankOptions = Normal[KeyTake[roundedOptionsAssociation, electrochemicalBlankMapThreadOption]];

		(* Generate MapThread friendly option for Blank, similar to OptionsHandling`Private`mapThreadOptions. *)
		mapThreadFriendlyBlankOptions = If[Length[resolvedBlank] > 0,
			Transpose[Map[
				Function[{options},
					Module[{optionSymbol, optionValues, optionSymbolList, optionValuesList},
						(* Separate out the option symfbol from the option values. *)
						optionSymbol = options[[1]];
						optionValues = options[[2]];

						(* Get a list of optionSymbol that is the same length as optionValue. *)
						If[MatchQ[Length[ToList@optionValues], Length[ToList@resolvedBlank]],
							optionSymbolList = ConstantArray[optionSymbol, Length[ToList@optionValues]];optionValuesList = ToList@optionValues,
							optionSymbolList = ConstantArray[optionSymbol, Length[ToList@resolvedBlank]];optionValuesList = ConstantArray[optionValues, Length[ToList@resolvedBlank]]
						];

						MapThread[
							(#1 -> #2&),
							{optionSymbolList, optionValuesList}
						]
					]
				],
				extractedBlankOptions
			]],
			Null
		];

		(* 10. Blank Analysis Channel resolution *)

		(* Helper function to resolve Blank Analysis Channel *)
		{initiallyResolvedBlankAnalysisChannel, imbalancedBlankAnionCationGroupingErrors} = Which[
			(* If there is no blank, there's no analysis channel *)
			MatchQ[resolvedBlank, Null | {} | {Null}],
			{{}, False},

			(* If BlankAnalysisChannel is specified, go with that and set error tracking variable to be false *)
			!MemberQ[ToList[Lookup[roundedOptionsAssociation, BlankAnalysisChannel]], Automatic],
			{Lookup[roundedOptionsAssociation, BlankAnalysisChannel], False},

			Length[preResolvedBlankAnalysisChannel] > 0,
			{preResolvedBlankAnalysisChannel, False},

			(* If resolvedAnalysisChannel is already ElectrochemicalChannel, then go ahead and set StandardAnalysisChannel to ElectrochemicalChannel as well *)
			MemberQ[resolvedAnalysisChannel, ElectrochemicalChannel],
			{Table[ElectrochemicalChannel, Length[ToList@resolvedBlank]], False},

			(* Otherwise, go through helper function to figure out whether the resolved Standard goes into Anion or Cation Channel *)
			True,
			resolveICAnalysisChannel[resolvedBlank, roundedOptionsAssociation, mapThreadFriendlyBlankOptions, Blank, BlankAnalysisChannel, AnionBlank, CationBlank, fullCache]
		];

		(* First check to see if there is duplicated standard *)
		duplicateFreeBlankQ = If[Length[ToList@resolvedBlank] > 0,
			If[MemberQ[ToList@initiallyResolvedBlankAnalysisChannel, ElectrochemicalChannel],
				True,
				DuplicateFreeQ[ToList@resolvedBlank]
			],
			True
		];
		(* An extreme rare edge case here is that when the same sample is specified in the InjectionTable for AnionChannel and CationChannel *)
		(* For example, an user specified Milli-Q water as anion blank and as cation blank in the InjectionTable *)
		(* Then when resolved analysis channel, these duplicate samples will have a duplicate assignment of analysis channels *)
		(* e.g. each water blank's analysis channel will be {AnionChannel, CationChannel} *)
		(* So here we are getting the list of duplicated analysis channel assignment first *)
		duplicateBlankAnalysisChannel = Select[Length /@ ToList@initiallyResolvedBlankAnalysisChannel, # > 1&];
		duplicateBlankAnalysisChannelQ = If[Length[duplicateBlankAnalysisChannel] > 0,
			True,
			False
		];

		(* If there is no duplicate blank, use the initially resolved blank analysis channel for final resolution *)
		duplicateBlankAnalysisChannelExpansion = If[duplicateFreeBlankQ || !duplicateBlankAnalysisChannelQ,
			initiallyResolvedBlankAnalysisChannel,

			Module[{blankTally, duplicateBlank, blankAnalysisChannel, analysisChannelReplaceRule},
				(* Count the time each standard appears and compile a list positions for only duplicated standard*)
				blankTally = Position[resolvedBlank, #]& /@ Keys@Counts[ToList@resolvedBlank];
				duplicateBlank = DeleteCases[blankTally, {_}];

				(* Find the standard analysis channel values for the duplicate standard samples *)
				blankAnalysisChannel = Extract[initiallyResolvedBlankAnalysisChannel, First@#]& /@ duplicateBlank;
				(* Compile a list of replacement rules *)
				(* For duplicated samples, its corresponding analysis channel will be something like {CationChannel,AnionChannel} instead of a single value *)
				(* This this map thread command will compile the replcament rule with position -> analysis channel resolved value *)
				analysisChannelReplaceRule = MapThread[#1 -> #2&, {Flatten@duplicateBlank, Flatten@blankAnalysisChannel}];
				(* Replace the initially resolved standard analysis channel with correct value *)
				ReplacePart[initiallyResolvedBlankAnalysisChannel, analysisChannelReplaceRule]
			]
		];

		resolvedBlankAnalysisChannel = If[MatchQ[initiallyResolvedBlankAnalysisChannel, {} | Null | {Null}],
			{},
			duplicateBlankAnalysisChannelExpansion
		];

		(* == Error checking == *)
		(* If there is imbalanced grouping of samples and we are throwing messages, then throw error message and collect invalid options *)
		imbalancedBlankAnionCationGroupingOption = If[MatchQ[imbalancedBlankAnionCationGroupingErrors, True] && messagesQ,
			(
				Message[Error::ImbalancedAnionCationGrouping, AnionBlank, CationBlank, Blank];
				{AnionBlank, CationBlank}
			),
			{}
		];

		(* Generate test to check anion and cation sample grouping *)
		repeatedBlankGroupingTests = testOrNull["If AnionBlank and CationBlank are specified and BlankAnalysisChannel is not, the total number of balnks from these two groups equals that of the specified blank:", Not[imbalancedBlankAnionCationGroupingErrors]];


		(* 11. AnionBlank resolution *)

		(* AnionBlank can either be directly specified or be set when AnalysisChannel has been resolved *)
		resolvedAnionBlank = If[MatchQ[resolvedBlank, {}],

			(* If there is no resolvedBlank, there is also no resolvedAnionBlank *)
			{},

			Which[

				(* If user specified AnionBlank, go with the specified option *)
				MatchQ[specifiedAnionBlank, Except[Null | Automatic]],
				specifiedAnionBlank,

				(* If Samples and AnalysisChannel are specified in the InjectionTable, compile AnionBlank from the InjectionTable *)
				MemberQ[anionInjectionTableLookupRounded, {Blank, __}],
				Lookup[fetchPacketFromCache[#, fullCache], Object]& /@ (Cases[anionInjectionTableLookupRounded, {Blank, _, AnionChannel, __}][[All, 2]]),

				(* Once AnalysisChannel is resolved, compile all the samples with AnalysisChannel set to AnionChannel *)
				!MatchQ[resolvedBlankAnalysisChannel, ListableP[Automatic] | {}],
				PickList[ToList@resolvedBlank, ToList@resolvedBlankAnalysisChannel, AnionChannel],

				(* If only AnionBlank related options are specified, use default sample models for anion channel *)
				Or[
					anySpecifiedQ[Join[anionBlankOptionNames, {AnionBlankGradientDuration, AnionBlankSuppressorCurrent}], roundedOptionsAssociation],
					MatchQ[Lookup[roundedOptionsAssociation, AnionBlankFrequency], Except[None | Null | Automatic]]
				],
				{Model[Sample, "Milli-Q water"]},

				True,
				{}
			]];

		(* 12. CationBlank resolution *)

		(* CationSamples can either be directly specified or be set when AnalysisChannel has been resolved *)
		resolvedCationBlank = If[MatchQ[resolvedBlank, {}],

			(* If there is no resolvedBlank, there is also no resolvedCationBlank *)
			{},

			Which[

				(* If user specified CationSamples, go with the specified option *)
				MatchQ[specifiedCationBlank, Except[Null | Automatic]],
				specifiedCationBlank,

				(* If Blanks and AnalysisChannel are specified in the InjectionTable, compile CationSamples from the InjectionTable *)
				MemberQ[cationInjectionTableLookupRounded, {Blank, __}],
				Lookup[fetchPacketFromCache[#, fullCache], Object]& /@ (Cases[cationInjectionTableLookupRounded, {Blank, __}][[All, 2]]),

				(* Once AnalysisChannel is resolved, compile all the samples with AnalysisChannel set to CationChannel *)
				!MatchQ[resolvedBlankAnalysisChannel, ListableP[Automatic] | {}],
				PickList[ToList@resolvedBlank, ToList@resolvedBlankAnalysisChannel, CationChannel],

				(* If only CationBlank related options are specified, use default sample models for cation channel *)
				Or[
					anySpecifiedQ[Join[cationBlankOptionNames, {CationBlankGradientB, CationBlankGradientC, CationBlankGradientD, CationBlankGradientDuration, CationBlankSuppressorCurrent}], roundedOptionsAssociation],
					MatchQ[Lookup[roundedOptionsAssociation, CationBlankFrequency], Except[None | Null | Automatic]]
				],
				{Model[Sample, "Milli-Q water"]},

				True,
				{}
			]];

		(* Once cation and anion blanks are resolved, double resolve AnalysisChannel again to correct the edge case assignment *)
		(* Such that if two waters appear as blanks, the analysis channel will assign to anion channel and cation channel *)
		doubleResolvedBlankAnalysisChannel = Module[{
			anionBlankPosition, cationBlankPosition, anionChannelArray, cationChannelArray, anionChannelRule, cationChannelRule},

			If[MemberQ[ToList@resolvedBlankAnalysisChannel, ElectrochemicalChannel] || Length[ToList@resolvedBlank] == Length[ToList@specifiedAnionBlank] || Length[ToList@resolvedBlank] == Length[ToList@specifiedCationBlank],
				resolvedBlankAnalysisChannel,

				(* First, find the position of anion blanks from the list of blanks *)
				(* Repeat for cation; the only difference here is that the cation positions are found using Complement *)
				(* For example, if anion positions are 1,4 in a list of 5 blanks, then cation positions automatically takes on 2,3,and 5 *)
				anionBlankPosition = Flatten[FirstPosition[ToList@Download[resolvedBlank, Object], #]& /@ ToList[Download[resolvedAnionBlank, Object]]];
				cationBlankPosition = DeleteCases[Range[1, Length[resolvedBlankAnalysisChannel]], Alternatives @@ anionBlankPosition];

				(* Make constant array of either AnionChannel or CationChannel for the length of anion blanks and cation blanks respectively *)
				anionChannelArray = ConstantArray[AnionChannel, Length[anionBlankPosition]];
				cationChannelArray = ConstantArray[CationChannel, Length[cationBlankPosition]];

				(* Construct rule that points position to their corresponding channel assignment *)
				anionChannelRule = MapThread[#1 -> #2&, {anionBlankPosition, anionChannelArray}];
				cationChannelRule = MapThread[#1 -> #2&, {cationBlankPosition, cationChannelArray}];

				(* Finally use the rules above to replace the resolvedBlankAnalysisChanenl *)
				ReplacePart[resolvedBlankAnalysisChannel, Join[anionChannelRule, cationChannelRule]]
			]
		];

		doubleResolvedAnionBlank = PickList[Cases[ToList@resolvedBlank, Except[Null]], ToList@doubleResolvedBlankAnalysisChannel, AnionChannel];
		doubleResolvedCationBlank = PickList[Cases[ToList@resolvedBlank, Except[Null]], ToList@doubleResolvedBlankAnalysisChannel, CationChannel];

		(* == Error checking == *)

		(* Construct a list with all the simulatedSamples in the first place and its corresponding specifiedAnalysisChannel in the second place *)
		allBlankWithSpecifiedChannel = If[MatchQ[resolvedBlank, Null | {} | {Null}] || MatchQ[specifiedStandard, ListableP[Automatic]] || MatchQ[doubleResolvedBlankAnalysisChannel, {}],
			Null,
			Transpose[{ToList@resolvedBlank, ToList@doubleResolvedBlankAnalysisChannel}]
		];

		(* 12.1 When BlankAnalysisChannel and BlankAnionSamples options are conflicting, throw error *)

		(* Extract the AnionSamples along with their specifiedAnalysisChannel from the all samples list *)
		anionBlankWithSpecifiedChannel = If[!NullQ[allBlankWithSpecifiedChannel] && MatchQ[doubleResolvedAnionBlank, Except[Null | Automatic]],
			Flatten[Cases[allBlankWithSpecifiedChannel, {#, _}]& /@ doubleResolvedAnionBlank, 1],
			Null
		];

		consistentAnionBlankChannelQ = If[MatchQ[anionBlankWithSpecifiedChannel, Null | {}],

			(* If either AnalysisChannel or AnionSamples option is not specified, then set this variable to False *)
			False,

			If[
				(* If user has specified AnionSamples *)
				!MatchQ[doubleResolvedAnionBlank, Except[Automatic | Null]],

				(* Then check if all the specified AnalysisChannel is AnionChannel *)
				(* Here FALSE = channel specification is consistent *)
				Not[MatchQ[#, {_, AnionChannel}]],

				(* If either option is not specified, then set this variable to False *)
				False
			]& /@ anionBlankWithSpecifiedChannel
		];

		(* Compile a list of anion samples that have their AnalysisChannel set to CationChannel *)
		invalidAnionBlankChannelSpecification = If[MatchQ[doubleResolvedAnionBlank, Except[Null | {} | {Null} | Automatic]] && MatchQ[anionBlankWithSpecifiedChannel, Except[Null | {}]],
			PickList[doubleResolvedAnionBlank, consistentAnionBlankChannelQ, True],
			Null
		];

		(* If there are invalid specifcation AND we are throwing messages, then throw an error, and collect AnalysisChannel option *)
		inconsistentAnionBlankChannelOption = If[Length[invalidAnionBlankChannelSpecification] > 0 && messagesQ,
			If[TrueQ[imbalancedBlankAnionCationGroupingErrors],
				(
					Message[Error::InconsistentAnalysisChannelSpecification, AnionBlank, ObjectToString[invalidAnionBlankChannelSpecification,Cache -> fullCache, Simulation -> updatedSimulation], CationChannel, AnionChannel];
					{BlankAnalysisChannel}
				),
				{}
			],
			{}
		];

		(* Generate tests for inconsistent analysis channel specification *)
		anionBlankChannelSpecificationTests = testOrNullIndexMatched["If both AnionBlank and BlankAnalysisChannel are specified, BlankAnalysisChannels of all AnionBlank should be AnionChannel:", doubleResolvedAnionBlank, consistentAnionBlankChannelQ];

		(* 12.2 When BlankAnalysisChannel and CationBlank options are conflicting, CationBlank take priority *)

		(* Extract the AnionSamples along with their specifiedAnalysisChannel from the all samples list *)
		cationBlankWithSpecifiedChannel = If[!NullQ[allBlankWithSpecifiedChannel] && MatchQ[doubleResolvedCationBlank, Except[Null | Automatic]],
			Flatten[Cases[allBlankWithSpecifiedChannel, {#, _}]& /@ doubleResolvedCationBlank, 1],
			Null
		];

		consistentCationBlankChannelQ = If[MatchQ[cationBlankWithSpecifiedChannel, Null | {}],

			(* If either AnalysisChannel or CationSample option is not specified, then set this variable to True *)
			False,

			If[
				(* If user has specified AnionSamples *)
				MatchQ[doubleResolvedCationBlank, Except[Automatic | Null]],

				(* Then check if all the specified AnalysisChannel is AnionChannel *)
				(* Here FALSE = channel specification is consistent *)
				Not[MatchQ[#, {_, CationChannel}]],

				(* If either option is not specified, then set this variable to False *)
				False
			]& /@ cationBlankWithSpecifiedChannel
		];

		(* Compile a list of anion samples that have their AnalysisChannel set to CationChannel *)
		invalidCationBlankChannelSpecification = If[MatchQ[doubleResolvedCationBlank, Except[Null | {} | {Null} | Automatic]] && MatchQ[cationBlankWithSpecifiedChannel, Except[Null | {}]],
			PickList[doubleResolvedCationBlank, consistentCationBlankChannelQ, True],
			Null
		];

		(* If there are invalid specifcation AND we are throwing messages, then throw an error, and collect AnalysisChannel option *)
		inconsistentCationBlankChannelOption = If[Length[invalidCationBlankChannelSpecification] > 0 && messagesQ,
			If[TrueQ[imbalancedBlankAnionCationGroupingErrors],
				{},
				(
					Message[Error::InconsistentAnalysisChannelSpecification, CationBlank, ObjectToString[invalidCationBlankChannelSpecification,Cache -> fullCache, Simulation -> updatedSimulation], AnionChannel, CationChannel];
					{BlankAnalysisChannel}
				)
			],
			{}
		];

		(* Generate tests for inconsistent analysis channel specification *)
		cationBlankChannelSpecificationTests = testOrNullIndexMatched["If both CationBlank and BlankAnalysisChannel are specified, BlankAnalysisChannels of all CationBlank should be CationChannel:", doubleResolvedCationBlank, consistentCationBlankChannelQ];

		(* 12.4 AnionBlank and CationBlank check together *)

		(* Get the number of standard as well as the number of resolvedAnionStandard and resolvedCationStandard *)
		totalBlank = Length[PickList[Cases[ToList@resolvedBlank, Except[Null]], ToList@doubleResolvedBlankAnalysisChannel, AnionChannel | CationChannel]];
		totalResolvedBlank = Length[ToList@doubleResolvedAnionBlank] + Length[ToList@doubleResolvedCationBlank];

		(* Check to see if the number of resolved samples add up to the number of input samples *)
		(* False here means the sample number matches *)
		totalBlankConsistentQ = If[!MatchQ[doubleResolvedBlankAnalysisChannel, {}],
			Not[MatchQ[totalBlank, totalResolvedBlank]],
			False
		];

		(* If the number of samples don't match up and we are throwing message, throw error message and collect invalid options *)
		invalidBlankGroupingOption = If[totalBlankConsistentQ && messagesQ,
			If[imbalancedBlankAnionCationGroupingErrors,
				{},
				(
					Message[Error::ImbalancedAnionCationGrouping, AnionBlank, CationBlank, Blank];
					{AnionBlank, CationBlank, BlankAnalysisChannel}
				)
			],
			{}
		];

		(* Generate test to check imbalanced grouping of cation and anion samples *)
		blankGroupingTests = testOrNull["If BlankAnalysisChannel and either AnionBlank or CationBlank are specified, the total number of blanks from specified or resolved AnionBlank and CationBlank sums up to the total number of blank:", Not[totalBlankConsistentQ]];


		(* No longer an option - Channel Selection resolution *)

		resolvedChannelSelection = If[MemberQ[Join[ToList@resolvedAnalysisChannel, ToList@doubleResolvedStandardAnalysisChannel, ToList@doubleResolvedBlankAnalysisChannel], ElectrochemicalChannel],
			Null,
			DeleteDuplicates[Join[ToList@resolvedAnalysisChannel, ToList@doubleResolvedStandardAnalysisChannel, ToList@doubleResolvedBlankAnalysisChannel]] /. Null -> Nothing
		];

		(* 13.1 If ElectrochemicalChannel is used, we need to check only ElectrochemicalChannel is specified in the analysis channel *)
		(* If both ElectrochemicalChannel and Anion/CationChannel are selected, and we are throwing messages, then throw error message and collect invalid options *)
		validChannelQ = And[
			MemberQ[Join[ToList@resolvedAnalysisChannel, ToList@doubleResolvedStandardAnalysisChannel, ToList@doubleResolvedBlankAnalysisChannel], ElectrochemicalChannel],
			MemberQ[Join[ToList@resolvedAnalysisChannel, ToList@doubleResolvedStandardAnalysisChannel, ToList@doubleResolvedBlankAnalysisChannel], AnionChannel | CationChannel]
		];

		invalidAnalysisChannelOption = If[validChannelQ && messagesQ,
			(
				Message[Error::InvalidAnalysisChannelSpecification];
				{AnalysisChannel, StandardAnalysisChannel, BlankAnalysisChannel}
			),
			{}
		];

		(* Generate test to check anion and cation sample grouping *)
		analysisChannelTests = testOrNull["If AnalysisChannel/StandardAnalysisChannel/BlankAnalysisChannel is specified, it cannot contain both ElectrochemicalChannel and Anion/CationChannel:",
			Not[
				(
					MemberQ[Join[resolvedAnalysisChannel, doubleResolvedStandardAnalysisChannel, doubleResolvedBlankAnalysisChannel], ElectrochemicalChannel] &&
						MemberQ[Join[resolvedAnalysisChannel, doubleResolvedStandardAnalysisChannel, doubleResolvedBlankAnalysisChannel], AnionChannel | CationChannel]
				)
			]
		];

		(* 14. Detector resolution *)
		(* Compile a list of absorbance and electrochemical detection options *)
		absorbanceOptions = {
			AbsorbanceWavelength,
			AbsorbanceSamplingRate,
			StandardAbsorbanceWavelength,
			StandardAbsorbanceSamplingRate,
			BlankAbsorbanceWavelength,
			BlankAbsorbanceSamplingRate,
			ColumnPrimeAbsorbanceWavelength,
			ColumnPrimeAbsorbanceSamplingRate,
			ColumnFlushAbsorbanceWavelength,
			ColumnFlushAbsorbanceSamplingRate
		};

		(* First pull a list of electrochemical detection options *)
		electrochemicalDetectionOptions = {
			ElectrochemicalDetectionMode,
			ReferenceElectrodeMode,
			ElectrochemicalSamplingRate,
			DetectionTemperature,
			StandardElectrochemicalDetectionMode,
			StandardReferenceElectrodeMode,
			StandardElectrochemicalSamplingRate,
			StandardDetectionTemperature,
			BlankElectrochemicalDetectionMode,
			BlankReferenceElectrodeMode,
			BlankElectrochemicalSamplingRate,
			BlankDetectionTemperature,
			ColumnPrimeElectrochemicalDetectionMode,
			ColumnPrimeReferenceElectrodeMode,
			ColumnPrimeElectrochemicalSamplingRate,
			ColumnPrimeDetectionTemperature,
			ColumnFlushElectrochemicalDetectionMode,
			ColumnFlushReferenceElectrodeMode,
			ColumnFlushElectrochemicalSamplingRate,
			ColumnFlushDetectionTemperature
		};

		resolvedDetector = If[MemberQ[resolvedAnalysisChannel, ElectrochemicalChannel],
			Which[
				(* If user specified detector, then go with that *)
				MatchQ[Lookup[roundedOptionsAssociation, Detector], Except[Automatic | Null]],
				Lookup[roundedOptionsAssociation, Detector],

				(* If any of the UV detection options are Nulled out, then set detector to ElectrochemicalDetector only *)
				MemberQ[NullQ[#]& /@ Lookup[roundedOptionsAssociation, absorbanceOptions], True],
				ElectrochemicalDetector,

				(* Similarly, if any of the electrochemical detection options are Nulled out, then set detector to UVVis only *)
				MemberQ[NullQ[#]& /@ Lookup[roundedOptionsAssociation, electrochemicalDetectionOptions], True],
				UVVis,

				(* Otherwise, select all detectors available from the instrument *)
				True,
				Lookup[resolvedInstrumentModelPacket, Detectors]
			],
			Null
		];

		(* == Error check == *)
		(* 1. We need to make sure the specified detector is a subset of compatible detectors of the specified analysis channel *)

		(* First based on analysis channel, figure out the compatible detectors *)
		compatibleDetectors = Switch[resolvedAnalysisChannel,
			ListableP[AnionChannel | CationChannel],
			{SuppressedConductivity},

			ListableP[ElectrochemicalChannel],
			{UVVis, ElectrochemicalDetector}
		];

		(* Then look at whether the resolved detectors are a subset of the compatible detectors *)
		compatibleDetectorQ = If[!NullQ[compatibleDetectors] && !NullQ[resolvedDetector],
			SubsetQ[compatibleDetectors, ToList@resolvedDetector],
			True
		];

		(* Throw a warning if the resolvedDetector is not a subset of the compatible detectors *)
		detectorWarning = If[!compatibleDetectorQ && messagesQ && notInEngine,
			Message[Warning::IncompatibleICDetector, resolvedDetector, compatibleDetectors, resolvedAnalysisChannel],
			Nothing
		];

		(* Test for compatible detectors *)
		detectorTest = WarningOrNull["If specified, detectors is a subset of the compatible detectors determined by the analysis channel:", !compatibleDetectorQ];

		(* 2. We need to check whether there's conflict between specified detection options (absorbance, etc) and detector *)

		edOptions = {
			ElectrochemicalDetectionMode,
			pHCalibration,
			NeutralpHCalibrationBuffer,
			SecondarypHCalibrationBuffer,
			SecondarypHCalibrationBufferTarget,
			WorkingElectrode,
			WorkingElectrodeStorageCondition,
			ReferenceElectrodeMode,
			VoltageProfile,
			WaveformProfile,
			ElectrochemicalSamplingRate,
			DetectionTemperature,
			StandardElectrochemicalDetectionMode,
			StandardReferenceElectrodeMode,
			StandardVoltageProfile,
			StandardWaveformProfile,
			StandardElectrochemicalSamplingRate,
			StandardDetectionTemperature,
			BlankElectrochemicalDetectionMode,
			BlankReferenceElectrodeMode,
			BlankVoltageProfile,
			BlankWaveformProfile,
			BlankElectrochemicalSamplingRate,
			BlankDetectionTemperature,
			ColumnPrimeElectrochemicalDetectionMode,
			ColumnPrimeReferenceElectrodeMode,
			ColumnPrimeVoltageProfile,
			ColumnPrimeWaveformProfile,
			ColumnPrimeElectrochemicalSamplingRate,
			ColumnPrimeDetectionTemperature,
			ColumnFlushElectrochemicalDetectionMode,
			ColumnFlushReferenceElectrodeMode,
			ColumnFlushVoltageProfile,
			ColumnFlushWaveformProfile,
			ColumnFlushElectrochemicalSamplingRate,
			ColumnFlushDetectionTemperature
		};

		(* Check if the resolved detector and the absorbance/electrochemical detection options are consistently specified *)
		{conflictingDetectionOptionQ, missingDetector, conflictingDetectionOptions} = Which[
			NullQ[resolvedDetector],
			{False, Null, {}},

			!MemberQ[ToList@resolvedDetector, UVVis],
			{
				anySpecifiedQ[absorbanceOptions, roundedOptionsAssociation],
				UVVis,
				PickList[absorbanceOptions, Lookup[roundedOptionsAssociation, absorbanceOptions], Except[ListableP[(Automatic | Null | None)]]]
			},

			!MemberQ[ToList@resolvedDetector, ElectrochemicalDetector],
			{
				anySpecifiedQ[edOptions, roundedOptionsAssociation],
				ElectrochemicalDetector,
				PickList[edOptions, Lookup[roundedOptionsAssociation, edOptions], Except[ListableP[(Automatic | Null | None)]]]
			},

			True,
			{False, Null, {}}
		];

		(* Throw a warning if the resolvedDetector is not a subset of the compatible detectors *)
		detectionOptionConflictOptions = If[conflictingDetectionOptionQ && messagesQ,
			(
				Message[
					Error::HPICConflictingDetectionOptions,
					resolvedDetector,
					conflictingDetectionOptions,
					missingDetector
				];
				{Detector}
			),
			{}
		];

		(* Test for compatible detectors *)
		detectorConflictTest = testOrNull["The specified detection options are compatible with the specified detector:", Not[conflictingDetectionOptionQ]];


		(* Helper to get the model packet when object is specified *)
		getModelPacket[inputValue_] := Module[{objectPacket},
			(* step 1. get the object packet *)
			objectPacket = fetchPacketFromCache[
				Download[inputValue, Object],
				fullCache
			];
			(* step 2. grab the model from the object packet and get the model packet *)
			fetchPacketFromCache[
				Download[Lookup[objectPacket, Model], Object],
				fullCache
			]
		];

		(* 14. AnionColumn resolution *)

		(* Resolve AnionColumn if there are AnionSamples specified *)
		resolvedAnionColumn = If[Length[Join[ToList@resolvedAnionSamples, ToList@resolvedAnionStandard, doubleResolvedAnionBlank] /. Null -> Nothing] > 0,

			(* If user has already specified AnionColumn, then go with that *)
			If[MatchQ[specifiedAnionColumn, Except[Automatic | Null]],
				specifiedAnionColumn,

				(* Otherwise, use this default IC column *)
				Model[Item, Column, "Dionex IonPac AS18-Fast IC Analytical Column"]
			],

			(* If there is no AnionSamples, AnionColumn resolves to Null *)
			Null
		];

		(* 15. AnionGuardColumn resolution *)

		(* If column is specified by user, download Column model packets from fullCache *)
		resolvedAnionColumnModelPacket = Which[
			(* If the specified column is an Object, grab the packet of the Column model *)
			MatchQ[resolvedAnionColumn, ObjectP[Object[Item, Column]]],
			getModelPacket[resolvedAnionColumn],

			(* If the specified column is already a model, download the model packet *)
			MatchQ[resolvedAnionColumn, ObjectP[Model[Item, Column]]],
			fetchPacketFromCache[Download[resolvedAnionColumn, Object], fullCache],

			True,
			Null
		];
		(*Set the preferredAnionGuardColumn for the resolvedAnionColumn if the PreferredGuardColumn is not Null*)
		preferredAnionGuardColumn = If[!NullQ[resolvedAnionColumn] && !NullQ[Lookup[resolvedAnionColumnModelPacket, PreferredGuardColumn]],

			(* Extract the preferred guard column of the resolved analytical column *)
			Lookup[resolvedAnionColumnModelPacket, PreferredGuardColumn][Object],


			(* If there is no resolvedAnionColumn, set preferredAnionGuardColumn to Null *)
			Null
		];

		(* Resolve AnionGuardColumn only if there is an AnionColumn specified for this protocol *)
		resolvedAnionGuardColumn = If[!NullQ[resolvedAnionColumn],

			(* If user has already specified AnionGuardColumn, then go with that *)
			If[MatchQ[specifiedAnionGuardColumn, Except[Automatic]],
				specifiedAnionGuardColumn,

				(* If the user did not specify, use the PreferredGuardColumn of the resolved analytical column *)
				preferredAnionGuardColumn
			],

			(* If resolvedAnionColumn is Null, then anion guard column also resolves to Null *)
			Null
		];

		(* If guard column is specified by user, download guard column model packets from fullCache *)
		resolvedAnionGuardColumnModelPacket = Which[
			(* If the specified column is an Object, grab the packet of the Column model *)
			MatchQ[resolvedAnionGuardColumn, ObjectP[Object[Item, Column]]],
			getModelPacket[resolvedAnionGuardColumn],

			(* If the specified column is already a model, download the model packet *)
			MatchQ[resolvedAnionGuardColumn, ObjectP[Model[Item, Column]]],
			fetchPacketFromCache[Download[resolvedAnionGuardColumn, Object], fullCache],

			True,
			Null
		];

		(* 16. CationColumn resolution *)

		(* Resolve CationColumn if there are CationSamples specified *)
		resolvedCationColumn = If[Length[Join[ToList@resolvedCationSamples, ToList@resolvedCationStandard, doubleResolvedCationBlank] /. Null -> Nothing] > 0,

			(* If user has already specified AnionColumn, then go with that *)
			If[MatchQ[specifiedCationColumn, Except[Automatic | Null]],
				specifiedCationColumn,

				(* Otherwise, use this default IC column *)
				Model[Item, Column, "Dionex IonPac CS16 4Micron IC Analytical Column"]
			],

			(* If there is no CationSamples, CationColumn resolves to Null *)
			Null
		];

		(* 17. CationGuardColumn resolution *)

		(* If column is specified by user, download Column model packets from fullCache *)
		resolvedCationColumnModelPacket = Which[
			(* If the specified column is an Object, grab the packet of the Column model *)
			MatchQ[resolvedCationColumn, ObjectP[Object[Item, Column]]],
			getModelPacket[resolvedCationColumn],

			(* If the specified column is already a model, download the model packet *)
			MatchQ[resolvedCationColumn, ObjectP[Model[Item, Column]]],
			fetchPacketFromCache[Download[resolvedCationColumn, Object], fullCache],

			True,
			Null
		];
		(*Set the preferredCationGuardColumn for the resolvedCationColumn if the PreferredGuardColumn is not Null*)
		preferredCationGuardColumn = If[!NullQ[resolvedCationColumn] && !NullQ[Lookup[resolvedCationColumnModelPacket, PreferredGuardColumn]],

			(* Extract the preferred guard column of the resolved analytical column *)
			Lookup[resolvedCationColumnModelPacket, PreferredGuardColumn][Object],

			(* If there is no resolvedAnionColumn, set preferredCationGuardColumn to Null *)
			Null
		];

		(* Resolve CationGuardColumn only if there is an CationColumn specified for this protocol *)
		resolvedCationGuardColumn = If[!NullQ[resolvedCationColumn],

			(* If user has already specified CationGuardColumn, then go with that *)
			If[MatchQ[specifiedCationGuardColumn, Except[Automatic]],
				specifiedCationGuardColumn,

				(* If the user did not specify, use the PreferredGuardColumn of the resolved analytical column *)
				preferredCationGuardColumn

			],

			(* If resolvedCationColumn is Null, then cation guard column also resolves to Null *)
			Null
		];

		(* If guard column is specified by user, download guard column model packets from fullCache *)
		resolvedCationGuardColumnModelPacket = Which[
			(* If the specified column is an Object, grab the packet of the Column model *)
			MatchQ[resolvedCationGuardColumn, ObjectP[Object[Item, Column]]],
			getModelPacket[resolvedCationGuardColumn],

			(* If the specified column is already a model, download the model packet *)
			MatchQ[resolvedCationGuardColumn, ObjectP[Model[Item, Column]]],
			fetchPacketFromCache[Download[resolvedCationGuardColumn, Object], fullCache],

			True,
			Null
		];

		(* 18. Column resolution *)

		(* Resolve Column if AnalysisChannel is resolved to ElectrochemicalChannel *)
		resolvedColumn = If[MemberQ[Join[ToList@resolvedAnalysisChannel, ToList@doubleResolvedStandardAnalysisChannel, ToList@doubleResolvedBlankAnalysisChannel], ElectrochemicalChannel],

			(* If user has already specified a Column, then go with that *)
			If[MatchQ[specifiedColumn, Except[Automatic | Null]],
				specifiedColumn,

				(* Otherwise, use this default CarboPac column *)
				Model[Item, Column, "Dionex CarboPack PA10 BioLC Analytical 4 x 250 mm"]
			],

			(* If there is no sample for ElectrochemicalChannel, then resolve to Null *)
			Null
		];

		(* 19. GuardColumn resolution *)

		(* If column is specified by user, download Column model packets from fullCache *)
		resolvedColumnModelPacket = Which[
			(* If the specified column is an Object, grab the packet of the Column model *)
			MatchQ[resolvedColumn, ObjectP[Object[Item, Column]]],
			getModelPacket[resolvedColumn],

			(* If the specified column is already a model, download the model packet *)
			MatchQ[resolvedColumn, ObjectP[Model[Item, Column]]],
			fetchPacketFromCache[Download[resolvedColumn, Object], fullCache],

			True,
			Null
		];

		(*Set the preferredGuardColumn for the resolvedColumn if the PreferredGuardColumn is not Null*)
		preferredGuardColumn = If[!NullQ[resolvedColumn] && !NullQ[Lookup[resolvedColumnModelPacket, PreferredGuardColumn]],

			(* Extract the preferred guard column of the resolved analytical column *)
			If[NullQ[Lookup[resolvedColumnModelPacket, PreferredGuardColumn]],

				Null,
				Lookup[resolvedColumnModelPacket, PreferredGuardColumn][Object]
			],

			(* If there is no resolvedAnionColumn, set preferredAnionGuardColumn to Null *)
			Null
		];

		(* Resolve AnionGuardColumn only if there is an AnionColumn specified for this protocol *)
		resolvedGuardColumn = If[!NullQ[resolvedColumn],

			(* If user has already specified GuardColumn, then go with that *)
			If[MatchQ[specifiedGuardColumn, Except[Automatic | Null]],
				specifiedGuardColumn,

				(* If the user did not specify, use the PreferredGuardColumn of the resolved analytical column *)
				preferredGuardColumn
			],

			(* If resolvedColumn is Null, then anion guard column also resolves to Null *)
			Null
		];

		(* If guard column is specified by user, download guard column model packets from fullCache *)
		resolvedGuardColumnModelPacket = Which[
			(* If the specified column is an Object, grab the packet of the Column model *)
			MatchQ[resolvedGuardColumn, ObjectP[Object[Item, Column]]],
			getModelPacket[resolvedGuardColumn],

			(* If the specified column is already a model, download the model packet *)
			MatchQ[resolvedGuardColumn, ObjectP[Model[Item, Column]]],
			fetchPacketFromCache[Download[resolvedGuardColumn, Object], fullCache],

			True,
			Null
		];

		(* == Error Checking == *)

		(* all resolved Columns' ChromatographyType should be IonChromatography and the Column's analysis channel should match the resolved AnalysisChannel *)

		(* = 18.1 ChromatographyType check = *)

		(* 18.1.1 Anion column check *)
		(* Extract the ChromatographyType field for the anion column specified *)
		specifiedAnionColumnTechniques = If[!NullQ[resolvedAnionColumnModelPacket],
			Lookup[resolvedAnionColumnModelPacket, ChromatographyType],
			Null
		];

		(* Bool tracking if the ChromatographyType of the specified AnionColumn is IonChromatography *)
		validAnionColumnTechniqueQ = If[!NullQ[specifiedAnionColumnTechniques],
			MatchQ[specifiedAnionColumnTechniques, IonChromatography],
			True
		];

		(* Throw errors if the Column's ChromatographyType is not IonChromatography AND we are throwing messages, keep track of invalid option *)
		anionColumnInvalidOptions = If[!validAnionColumnTechniqueQ && messagesQ,
			(
				Message[Error::IncompatibleColumnTechnique, AnionColumn, ObjectToString[resolvedAnionColumn,Cache -> fullCache, Simulation -> updatedSimulation], specifiedAnionColumnTechniques, IonChromatography];
				{AnionColumn}
			),
			{}
		];

		(* Generate test for incompatible columns based on ChromatographyType *)
		anionColumnTechniqueTests = testOrNull["If AnionColumn is specified, ChromatographyType of the specified column is IonChromatography:", validAnionColumnTechniqueQ];

		(* 18.1.2 Cation column check *)
		(* Extract the ChromatographyType field for the cation column specified *)
		specifiedCationColumnTechniques = If[!NullQ[resolvedCationColumnModelPacket],
			Lookup[resolvedCationColumnModelPacket, ChromatographyType],
			Null
		];

		(* Bool tracking if the ChromatographyType of the specified CationColumn is IonChromatography *)
		validCationColumnTechniqueQ = If[!NullQ[specifiedCationColumnTechniques],
			MatchQ[specifiedCationColumnTechniques, IonChromatography],
			True
		];

		(* Throw errors if the Column's ChromatographyType is not IonChromatography AND we are throwing messages, keep track of invalid option *)
		cationColumnInvalidOptions = If[!validCationColumnTechniqueQ && messagesQ,
			(
				Message[Error::IncompatibleColumnTechnique, CationColumn, ObjectToString[resolvedCationColumn,Cache -> fullCache, Simulation -> updatedSimulation], specifiedCationColumnTechniques, IonChromatography];
				{CationColumn}
			),
			{}
		];

		(* Generate test for incompatible columns based on ChromatographyType *)
		cationColumnTechniqueTests = testOrNull["If CationColumn is specified, ChromatographyType of the specified column is IonChromatography:", validCationColumnTechniqueQ];


		(* 18.1.3 column check *)
		(* Extract the ChromatographyType field for the anion column specified *)
		specifiedColumnTechniques = If[!NullQ[resolvedColumnModelPacket],
			Lookup[resolvedColumnModelPacket, ChromatographyType],
			Null
		];

		(* Bool tracking if the ChromatographyType of the specified AnionColumn is IonChromatography *)
		validColumnTechniqueQ = If[!NullQ[specifiedColumnTechniques],
			MatchQ[specifiedColumnTechniques, IonChromatography],
			True
		];

		(* Throw errors if the Column's ChromatographyType is not IonChromatography AND we are throwing messages, keep track of invalid option *)
		columnInvalidOptions = If[!validColumnTechniqueQ && messagesQ,
			(
				Message[Error::IncompatibleColumnTechnique, Column, ObjectToString[resolvedColumn,Cache -> fullCache, Simulation -> updatedSimulation], specifiedColumnTechniques, IonChromatography];
				{Column}
			),
			{}
		];

		(* Generate test for incompatible columns based on ChromatographyType *)
		columnTechniqueTests = testOrNull["If Column is specified, ChromatographyType of the specified column is IonChromatography:", validColumnTechniqueQ];


		(* = 18.2 AnalysisChannel check = *)

		(* 18.2.1 Anion column check *)
		(* Extract the AnalysisChannel field for the anion column specified *)
		specifiedAnionColumnAnalysisChannel = If[!NullQ[resolvedAnionColumnModelPacket],
			Lookup[resolvedAnionColumnModelPacket, AnalysisChannel],
			Null
		];

		(* Bool tracking if the AnalysisChannel of the specified column matches AnionChannel *)
		matchingAnionColumnAnalysisChannelQ = If[!NullQ[specifiedAnionColumnAnalysisChannel],
			MatchQ[specifiedAnionColumnAnalysisChannel, AnionChannel],
			Null
		];

		(* If the specified column has mismatched AnalysisChannel AND we are throwing errors, then throw incompatibleColumnAnalysisChannel warning *)
		(* No need to keep the invalid option for warning *)
		If[!matchingAnionColumnAnalysisChannelQ && messagesQ && notInEngine,
			Message[Warning::IncompatibleColumnAnalysisChannel, AnionColumn, ObjectToString[resolvedAnionColumn,Cache -> fullCache, Simulation -> updatedSimulation], specifiedAnionColumnAnalysisChannel, AnionChannel];
			{}
		];

		(* Generate test for anion column that has mismatching AnalysisChannel from the column model and the user specified channel in this a protocol *)
		anionColumnAnalysisChannelTests = warningOrNull["If AnionColumn is specified, AnalysisChannel in the column model is AnionChannel:", matchingAnionColumnAnalysisChannelQ];

		(* 18.2.2 Cation column check *)
		(* Extract the AnalysisChannel field for the cation column specified *)
		specifiedCationColumnAnalysisChannel = If[!NullQ[resolvedCationColumnModelPacket],
			Lookup[resolvedCationColumnModelPacket, AnalysisChannel],
			Null
		];

		(* Bool tracking if the AnalysisChannel of the specified column matches AnionChannel *)
		matchingCationColumnAnalysisChannelQ = If[!NullQ[specifiedCationColumnAnalysisChannel],
			MatchQ[specifiedCationColumnAnalysisChannel, CationChannel],
			Null
		];

		(* If the specified column has mismatched AnalysisChannel AND we are throwing errors, then throw incompatibleColumnAnalysisChannel warning *)
		(* No need to keep the invalid option for warning *)
		If[!matchingCationColumnAnalysisChannelQ && messagesQ && notInEngine,
			Message[Warning::IncompatibleColumnAnalysisChannel, CationColumn, ObjectToString[resolvedCationColumn,Cache -> fullCache, Simulation -> updatedSimulation], specifiedCationColumnAnalysisChannel, CationChannel];
			{}
		];

		(* Generate test for anion column that has mismatching AnalysisChannel from the column model and the user specified channel in this a protocol *)
		cationColumnAnalysisChannelTests = warningOrNull["If CationColumn is specified, AnalysisChannel in the column model is CationChannel:", matchingCationColumnAnalysisChannelQ];

		(* 18.2.3 Column check *)
		(* Extract the AnalysisChannel field for the column specified *)
		specifiedColumnAnalysisChannel = If[!NullQ[resolvedColumnModelPacket],
			Lookup[resolvedColumnModelPacket, AnalysisChannel],
			Null
		];

		(* Bool tracking if the AnalysisChannel of the specified column matches AnionChannel *)
		matchingColumnAnalysisChannelQ = If[!NullQ[specifiedColumnAnalysisChannel],
			MatchQ[specifiedColumnAnalysisChannel, ElectrochemicalChannel],
			Null
		];

		(* If the specified column has mismatched AnalysisChannel AND we are throwing errors, then throw incompatibleColumnAnalysisChannel warning *)
		(* No need to keep the invalid option for warning *)
		If[!matchingColumnAnalysisChannelQ && messagesQ && notInEngine,
			Message[Warning::IncompatibleColumnAnalysisChannel, Column, ObjectToString[resolvedColumn,Cache -> fullCache, Simulation -> updatedSimulation], specifiedColumnAnalysisChannel, ElectrochemicalChannel];
			{}
		];

		(* Generate test for anion column that has mismatching AnalysisChannel from the column model and the user specified channel in this a protocol *)
		columnAnalysisChannelTests = warningOrNull["If Column is specified, AnalysisChannel in the column model is ElectrochemicalChannel:", matchingColumnAnalysisChannelQ];


		(* == Error Checking == *)
		(* all specified GuardColumns' ColumnType should be Guard and ChromatographyType should be IonChromatography *)

		(* 18.3.1 Anion guard column check *)
		(* Extract the ColumnType for anion GuardColumn specified *)
		specifiedAnionGuardColumnTypes = If[!NullQ[resolvedAnionGuardColumnModelPacket],
			Lookup[resolvedAnionGuardColumnModelPacket, ColumnType],
			Null
		];

		(* Bool tracking if the ColumnType of all specified GuardColumn is Guard *)
		validAnionGuardColumnTypeQ = If[!NullQ[specifiedAnionGuardColumnTypes],
			MatchQ[specifiedAnionGuardColumnTypes, Guard],
			True
		];

		(* Extract the ChromatographyType for all GuardColumns specified *)
		specifiedAnionGuardColumnTechniques = If[!NullQ[resolvedAnionGuardColumnModelPacket],
			Lookup[resolvedAnionGuardColumnModelPacket, ChromatographyType],
			Null
		];

		(* Bool tracking if the ChromatographyType of all specified GuardColumn is IonChromatography *)
		validAnionGuardColumnTechniqueQ = If[!NullQ[specifiedAnionGuardColumnTechniques],
			MatchQ[specifiedAnionGuardColumnTechniques, IonChromatography],
			True
		];

		anionGuardColumnInvalidOption = Which[
			(* Throw errors if the AnionGuardColumn's ColumnType is not Guard AND we are throwing messages, keep track of invalid option *)
			!validAnionGuardColumnTypeQ && messagesQ,
			(
				Message[Error::InvalidGuardColumn, AnionGuardColumn, ObjectToString[resolvedAnionGuardColumn,Cache -> fullCache, Simulation -> updatedSimulation]];
				{AnionGuardColumn}
			),

			(* Throw errors if the GuardColumn's ChromatographyType is not IonChromatography AND we are throwing messages, keep track of invalid option *)
			!validAnionGuardColumnTechniqueQ && messagesQ,
			(
				Message[Error::IncompatibleColumnTechnique, AnionGuardColumn, ObjectToString[resolvedAnionGuardColumn,Cache -> fullCache, Simulation -> updatedSimulation], specifiedAnionGuardColumnTechniques, IonChromatography];
				{AnionGuardColumn}
			),

			(* Otherwise, there is no invalid option *)
			True,
			{}
		];

		(* Generate tests for invalid guard columns as well as guard columns not intended for IonChromatography applications *)
		anionGuardColumnTypeTests = testOrNull["If AnionGuardColumn is specified, ColumnType of the specified guard column is Guard:", validAnionGuardColumnTypeQ];
		anionGuardColumnTechniqueTests = testOrNull["If AnionGuardColumn is specified, ChromatographyType of the specified guard columns is IonChromatography:", validAnionGuardColumnTechniqueQ];

		(* 18.3.2 Cation guard column check *)
		(* Extract the ColumnType for anion GuardColumn specified *)
		specifiedCationGuardColumnTypes = If[!NullQ[resolvedCationGuardColumnModelPacket],
			Lookup[resolvedCationGuardColumnModelPacket, ColumnType],
			Null
		];

		(* Bool tracking if the ColumnType of all specified GuardColumn is Guard *)
		validCationGuardColumnTypeQ = If[!NullQ[specifiedCationGuardColumnTypes],
			MatchQ[specifiedCationGuardColumnTypes, Guard],
			True
		];

		(* Extract the ChromatographyType for all GuardColumns specified *)
		specifiedCationGuardColumnTechniques = If[!NullQ[resolvedCationGuardColumnModelPacket],
			Lookup[resolvedCationGuardColumnModelPacket, ChromatographyType],
			Null
		];

		(* Bool tracking if the ChromatographyType of all specified GuardColumn is IonChromatography *)
		validCationGuardColumnTechniqueQ = If[!NullQ[specifiedCationGuardColumnTechniques],
			MatchQ[specifiedCationGuardColumnTechniques, IonChromatography],
			True
		];

		cationGuardColumnInvalidOption = Which[
			(* Throw errors if the AnionGuardColumn's ColumnType is not Guard AND we are throwing messages, keep track of invalid option *)
			!validCationGuardColumnTypeQ && messagesQ,
			(
				Message[Error::InvalidGuardColumn, CationGuardColumn, ObjectToString[resolvedAnionGuardColumn,Cache -> fullCache, Simulation -> updatedSimulation]];
				{CationGuardColumn}
			),

			(* Throw errors if the GuardColumn's ChromatographyType is not IonChromatography AND we are throwing messages, keep track of invalid option *)
			!validCationGuardColumnTechniqueQ && messagesQ,
			(
				Message[Error::IncompatibleColumnTechnique, CationGuardColumn, ObjectToString[resolvedCationGuardColumn,Cache -> fullCache, Simulation -> updatedSimulation], specifiedCationGuardColumnTechniques, IonChromatography];
				{CationGuardColumn}
			),

			(* Otherwise, there is no invalid option *)
			True,
			{}
		];

		(* Generate tests for invalid guard columns as well as guard columns not intended for IonChromatography applications *)
		cationGuardColumnTypeTests = testOrNull["If CationGuardColumn is specified, ColumnType of the specified guard column is Guard:", validCationGuardColumnTypeQ];
		cationGuardColumnTechniqueTests = testOrNull["If CationGuardColumn is specified, ChromatographyType of the specified guard columns is IonChromatography:", validCationGuardColumnTechniqueQ];

		(* 18.3.3 Guard column check *)
		(* Extract the ColumnType for GuardColumn specified *)
		specifiedGuardColumnTypes = If[!NullQ[resolvedGuardColumnModelPacket],
			Lookup[resolvedGuardColumnModelPacket, ColumnType],
			Null
		];

		(* Bool tracking if the ColumnType of all specified GuardColumn is Guard *)
		validGuardColumnTypeQ = If[!NullQ[specifiedGuardColumnTypes],
			MatchQ[specifiedGuardColumnTypes, Guard],
			True
		];

		(* Extract the ChromatographyType for all GuardColumns specified *)
		specifiedGuardColumnTechniques = If[!NullQ[resolvedGuardColumnModelPacket],
			Lookup[resolvedGuardColumnModelPacket, ChromatographyType],
			Null
		];

		(* Bool tracking if the ChromatographyType of all specified GuardColumn is IonChromatography *)
		validGuardColumnTechniqueQ = If[!NullQ[specifiedGuardColumnTechniques],
			MatchQ[specifiedGuardColumnTechniques, IonChromatography],
			True
		];

		guardColumnInvalidOption = Which[
			(* Throw errors if the GuardColumn's ColumnType is not Guard AND we are throwing messages, keep track of invalid option *)
			!validGuardColumnTypeQ && messagesQ,
			(
				Message[Error::InvalidGuardColumn, GuardColumn, ObjectToString[resolvedGuardColumn,Cache -> fullCache, Simulation -> updatedSimulation]];
				{GuardColumn}
			),

			(* Throw errors if the GuardColumn's ChromatographyType is not IonChromatography AND we are throwing messages, keep track of invalid option *)
			!validGuardColumnTechniqueQ && messagesQ,
			(
				Message[Error::IncompatibleColumnTechnique, GuardColumn, ObjectToString[resolvedGuardColumn,Cache -> fullCache, Simulation -> updatedSimulation], specifiedGuardColumnTechniques, IonChromatography];
				{GuardColumn}
			),

			(* Otherwise, there is no invalid option *)
			True,
			{}
		];

		(* Generate tests for invalid guard columns as well as guard columns not intended for IonChromatography applications *)
		guardColumnTypeTests = testOrNull["If GuardColumn is specified, ColumnType of the specified guard column is Guard:", validGuardColumnTypeQ];
		guardColumnTechniqueTests = testOrNull["If GuardColumn is specified, ChromatographyType of the specified guard columns is IonChromatography:", validGuardColumnTechniqueQ];


		(* Before going into Gradient and ColumnTemperature resolution, we first need to set up map friendly options for options that are index matched to AnionSamples/CationSamples *)
		anionSampleOption = {
			AnionColumnTemperature,
			AnionInjectionVolume,
			EluentGradient,
			AnionFlowRate,
			AnionGradientStart,
			AnionGradientEnd,
			AnionGradientDuration,
			AnionEquilibrationTime,
			AnionFlushTime,
			AnionGradient,
			AnionSuppressorMode,
			AnionSuppressorVoltage,
			AnionSuppressorCurrent,
			AnionDetectionTemperature
		};

		cationSampleOption = {
			CationColumnTemperature,
			CationInjectionVolume,
			CationGradientA,
			CationGradientB,
			CationGradientC,
			CationGradientD,
			CationFlowRate,
			CationGradientStart,
			CationGradientEnd,
			CationGradientDuration,
			CationEquilibrationTime,
			CationFlushTime,
			CationGradient,
			CationSuppressorMode,
			CationSuppressorVoltage,
			CationSuppressorCurrent,
			CationDetectionTemperature
		};

		electrochemicalSampleOption = {
			ColumnTemperature,
			InjectionVolume,
			GradientA,
			GradientB,
			GradientC,
			GradientD,
			FlowRate,
			GradientStart,
			GradientEnd,
			GradientDuration,
			EquilibrationTime,
			FlushTime,
			Gradient,
			AbsorbanceWavelength,
			AbsorbanceSamplingRate,
			ElectrochemicalDetectionMode,
			ReferenceElectrodeMode,
			VoltageProfile,
			WaveformProfile,
			ElectrochemicalSamplingRate,
			DetectionTemperature
		};

		(* From the comprehesive list of options, extract options index matched to AnionSamples/CationSamples *)
		extractedAnionSamplesOptions = Normal[KeyTake[roundedOptionsAssociation, anionSampleOption]];
		extractedCationSamplesOptions = Normal[KeyTake[roundedOptionsAssociation, cationSampleOption]];
		extractedElectrochemicalSamplesOptions = Normal[KeyTake[roundedOptionsAssociation, electrochemicalSampleOption]];

		resolvedAnionSamples = If[imbalancedAnionCationGroupingErrors || And @@ consistentAnionChannelQ || And @@ consistentCationChannelQ, {}, resolvedAnionSamples];
		resolvedCationSamples = If[imbalancedAnionCationGroupingErrors || And @@ consistentCationChannelQ || And @@ consistentAnionChannelQ, {}, resolvedCationSamples];

		(* Generate MapThread friendly option for AnionSamples and CationSamples, similar to OptionsHandling`Private`mapThreadOptions. *)
		mapThreadFriendlyAnionSampleOptions = If[Length[ToList@resolvedAnionSamples] > 0,
			Transpose[Map[
				Function[{options},
					Module[{optionSymbol, optionValues, optionSymbolList, optionValuesList},
						(* Separate out the option symbol from the option values. *)
						optionSymbol = options[[1]];
						optionValues = options[[2]];

						(* Get a list of optionSymbol that is the same length as optionValue. *)
						If[MatchQ[Length[ToList@optionValues], Length[ToList@resolvedAnionSamples]],
							optionSymbolList = ConstantArray[optionSymbol, Length[ToList@optionValues]];optionValuesList = ToList@optionValues,
							optionSymbolList = ConstantArray[optionSymbol, Length[ToList@resolvedAnionSamples]];optionValuesList = ConstantArray[optionValues, Length[ToList@resolvedAnionSamples]]
						];

						MapThread[
							(#1 -> #2&),
							{optionSymbolList, optionValuesList}
						]
					]
				],
				extractedAnionSamplesOptions
			]],
			{}
		];

		mapThreadFriendlyCationSampleOptions = If[Length[ToList@resolvedCationSamples] > 0,
			Transpose[Map[
				Function[{options},
					Module[{optionSymbol, optionValues, optionSymbolList, optionValuesList},
						(* Separate out the option symbol from the option values. *)
						optionSymbol = options[[1]];
						optionValues = options[[2]];

						(* Get a list of optionSymbol that is the same length as optionValue. *)
						If[MatchQ[Length[ToList@optionValues], Length[ToList@resolvedCationSamples]],
							optionSymbolList = ConstantArray[optionSymbol, Length[ToList@optionValues]];optionValuesList = ToList@optionValues,
							optionSymbolList = ConstantArray[optionSymbol, Length[ToList@resolvedCationSamples]];optionValuesList = ConstantArray[optionValues, Length[ToList@resolvedCationSamples]]
						];

						MapThread[
							(#1 -> #2&),
							{optionSymbolList, optionValuesList}
						]
					]
				],
				extractedCationSamplesOptions
			]],
			{}
		];

		mapThreadFriendlyElectrochemicalSampleOptions = If[MemberQ[ToList@resolvedAnalysisChannel, ElectrochemicalChannel],
			Transpose[Map[
				Function[{options},
					Module[{optionSymbol, optionValues, optionSymbolList, optionValuesList},
						(* Separate out the option symbol from the option values. *)
						optionSymbol = options[[1]];
						optionValues = options[[2]];

						(* Get a list of optionSymbol that is the same length as optionValue. *)
						If[MatchQ[Length[ToList@optionValues], Length[ToList@mySamples]],
							optionSymbolList = ConstantArray[optionSymbol, Length[ToList@optionValues]];optionValuesList = ToList@optionValues,
							optionSymbolList = ConstantArray[optionSymbol, Length[ToList@mySamples]];optionValuesList = ConstantArray[optionValues, Length[ToList@mySamples]]
						];

						MapThread[
							(#1 -> #2&),
							{optionSymbolList, optionValuesList}
						]
					]
				],
				extractedElectrochemicalSamplesOptions
			]],
			{}
		];


		(* 18. NumberOfReplicates resolution *)

		resolvedNumberOfReplicates = specifiedNumberOfReplicates;

		(* 19. SampleTemperature resolution *)

		resolvedSampleTemperature = specifiedSampleTemperature;

		(* == Error Checking == *)
		(* Extract the min and max sample temperature of the autosampler *)
		(* Don't need this error check anymore since the upper limit is already included in the widget
        minSampleTemperature=Lookup[resolvedInstrumentModelPacket,MinSampleTemperature]/.Null->-Infinity Celsius;
        maxSampleTemperature=Lookup[resolvedInstrumentModelPacket,MaxSampleTemperature]/.Null->Infinity Celsius;

        (* Check whether the specified sample temperature is within the range of allowed temperature of the instrument's autosampler *)
        validSampleTemperatureQ=If[MatchQ[resolvedSampleTemperature,Ambient],
            False,
            Not[Between[resolvedSampleTemperature,{minSampleTemperature,maxSampleTemperature}]]
        ];

        (* If the sample temperature is not compatible, and we are throwing messages, throw error message and collect invalid sample temperature option *)
        invalidSampleTemperatureOption=If[validSampleTemperatureQ&&messagesQ,
            (
                Message[Error::IncompatibleSampleTemperature,resolvedSampleTemperature,minSampleTemperature,maxSampleTemperature,resolvedInstrument];
                {SampleTemperature}
            ),
            {}
        ];

        (* Generate tests for valid sample temperature *)
        validSampleTemperatureTests=testOrNull["If sample temperature is specified, it is within the allowed temperature range of the autosampler:",Not[validSampleTemperatureQ]]; *)

		(* 20. InjectionVolume resolution *)

		(* declare some global variables depending on what our instrument is *)
		maxInjectionVolume = Lookup[resolvedInstrumentModelPacket, MaxSampleVolume] /. Null -> Infinity Microliter;

		(* get the dead volume; for whatever reason this isn't stored in the object space so need to hard code it here *)
		autosamplerDeadVolume = 30 Microliter;

		(* get the aliquot option for anion samples *)
		anionAliquotVolumeMapThreadFriendly = PickList[Lookup[samplePrepOptions, AliquotAmount], ToList@resolvedAnalysisChannel, AnionChannel] /. {} -> Null;
		cationAliquotVolumeMapThreadFriendly = PickList[Lookup[samplePrepOptions, AliquotAmount], ToList@resolvedAnalysisChannel, CationChannel] /. {} -> Null;

		(* resolve the InjectionVolume option *)
		resolvedAnionInjectionVolume = If[MatchQ[resolvedAnionSamples, {} | {Null} | Null] || And @@ consistentAnionChannelQ,
			
			{},
			
			MapThread[
				Function[{mySample, aliquotVolume, myMapThreadOptions},
					Module[{injectionTableSampleInjectionVolume, anionInjectionTableSamples, anionInjectionTableSampleList, anionInjectionTableLookupWithID},
						
						anionInjectionTableSampleList = Cases[anionInjectionTableLookupRounded, {Sample, sample_, ___} :> Download[sample, Object]];
						anionInjectionTableLookupWithID = MapThread[ReplacePart[#1, 2 -> #2]&, {Cases[anionInjectionTableLookupRounded, {Sample, ___}], anionInjectionTableSampleList}];
						
						(*we need to extract out the injection volume from the injection table*)
						injectionTableSampleInjectionVolume = If[anionInjectionTableSpecifiedQ && Not[injectionTableSampleConflictQ],
							Cases[anionInjectionTableLookupWithID, {Sample, Download[mySample, Object] | mySample, _, injectionVolume_, _} :> injectionVolume],
							
							(*otherwise pad automatic*)
							Automatic
						];
						
						Which[
							(*user specified*)
							MatchQ[Lookup[myMapThreadOptions, AnionInjectionVolume], VolumeP], Lookup[myMapThreadOptions, AnionInjectionVolume],
							(*injectionTable specified*)
							MatchQ[injectionTableSampleInjectionVolume, ListableP[VolumeP]], Sequence @@ injectionTableSampleInjectionVolume,
							(* we are aliquoting and know what the aliquot volume will be and it is less than the maximum autosampler injection volume, then go with that minus the dead volume *)
							MatchQ[aliquotVolume, GreaterP[0 * Microliter]], Min[aliquotVolume - autosamplerDeadVolume, maxInjectionVolume],
							MatchQ[Lookup[fetchPacketFromCache[mySample, Cache -> fullCache], Volume], VolumeP], Min[Lookup[fetchPacketFromCache[mySample, Cache -> fullCache], Volume], 10 Microliter],
							True, 10 Microliter
						]
					]],
				{
					ToList@resolvedAnionSamples,
					anionAliquotVolumeMapThreadFriendly,
					mapThreadFriendlyAnionSampleOptions
				}
			]
		];

		(* resolve the InjectionVolume option *)
		resolvedCationInjectionVolume = If[MatchQ[resolvedCationSamples, {} | {Null} | Null] || And @@ consistentCationChannelQ,
			
			{},
			
			MapThread[
				Function[{mySample, aliquotVolume, myMapThreadOptions},
					Module[{injectionTableSampleInjectionVolume, cationInjectionTableSampleList, cationInjectionTableLookupWithID},
						
						cationInjectionTableSampleList = Cases[cationInjectionTableLookupRounded, {Sample, sample_, ___} :> Download[sample, Object]];
						cationInjectionTableLookupWithID = MapThread[ReplacePart[#1, 2 -> #2]&, {Cases[cationInjectionTableLookupRounded, {Sample, ___}], cationInjectionTableSampleList}];
						
						(*we need to extract out the injection volume from the injection table*)
						injectionTableSampleInjectionVolume = If[cationInjectionTableSpecifiedQ && Not[injectionTableSampleConflictQ],
							Cases[cationInjectionTableLookupWithID, {Sample, Download[mySample, Object] | mySample, _, injectionVolume_, _} :> injectionVolume],
							
							(*otherwise pad automatic*)
							Automatic
						];
						
						Which[
							(*user specified*)
							MatchQ[Lookup[myMapThreadOptions, CationInjectionVolume], VolumeP], Lookup[myMapThreadOptions, CationInjectionVolume],
							(*injectionTable specified*)
							MatchQ[injectionTableSampleInjectionVolume, ListableP[VolumeP]], Sequence @@ injectionTableSampleInjectionVolume,
							(* we are aliquoting and know what the aliquot volume will be and it is less than the maximum autosampler injection volume, then go with that minus the dead volume *)
							MatchQ[aliquotVolume, GreaterP[0 * Microliter]], Min[aliquotVolume - autosamplerDeadVolume, maxInjectionVolume],
							MatchQ[Lookup[fetchPacketFromCache[mySample, Cache -> fullCache], Volume], VolumeP], Min[Lookup[fetchPacketFromCache[mySample, Cache -> fullCache], Volume], 10 Microliter],
							True, 10 Microliter
						]
					]],
				{
					ToList@resolvedCationSamples,
					cationAliquotVolumeMapThreadFriendly,
					mapThreadFriendlyCationSampleOptions
				}
			]
		];


		(* resolve the InjectionVolume option *)
		resolvedInjectionVolume = If[MemberQ[ToList@resolvedAnalysisChannel, ElectrochemicalChannel],

			MapThread[
				Function[{mySample, aliquotVolume, myMapThreadOptions},
					Module[{injectionTableSampleInjectionVolume, injectionTableSampleList, injectionTableLookupWithID},

						injectionTableSampleList = Cases[electrochemicalInjectionTableLookupRounded, {Sample, sample_, ___} :> Download[sample, Object]];
						injectionTableLookupWithID = MapThread[ReplacePart[#1, 2 -> #2]&, {Cases[electrochemicalInjectionTableLookupRounded, {Sample, ___}], injectionTableSampleList}];

						(*we need to extract out the injection volume from the injection table*)
						injectionTableSampleInjectionVolume = If[electrochemicalInjectionTableSpecifiedQ && Not[injectionTableSampleConflictQ],
							Cases[injectionTableLookupWithID, {Sample, Download[mySample, Object] | mySample, injectionVolume_, _, _, _} :> injectionVolume],

							(*otherwise pad automatic*)
							Automatic
						];

						Which[
							(*user specified*)
							MatchQ[Lookup[myMapThreadOptions, InjectionVolume], VolumeP], Lookup[myMapThreadOptions, InjectionVolume],
							(*injectionTable specified*)
							MatchQ[injectionTableSampleInjectionVolume, ListableP[VolumeP]], Sequence @@ injectionTableSampleInjectionVolume,
							(* we are aliquoting and know what the aliquot volume will be and it is less than the maximum autosampler injection volume, then go with that minus the dead volume *)
							MatchQ[aliquotVolume, GreaterP[0 * Microliter]], Min[aliquotVolume - autosamplerDeadVolume, maxInjectionVolume],
							MatchQ[Lookup[fetchPacketFromCache[mySample, fullCache], Volume], VolumeP], Min[Lookup[fetchPacketFromCache[mySample, fullCache], Volume], 25 Microliter],
							True, 25 Microliter
						]
					]],
				{
					ToList@mySamples,
					Lookup[samplePrepOptions, AliquotAmount],
					mapThreadFriendlyElectrochemicalSampleOptions
				}
			]
		];

		(* == Error Checking == *)
		(* The autosampler throws a warning if an injection volume between the sample loop volume and one half of the
		sample loop volume is specified. Here we pass that warning on to the user. *)

		(* Set a boolean indicating if any of the injection volume options has a non-recommended injection volume *)
		nonRecommendedInjectionVolumeQs = Map[
			MemberQ[#, RangeP[maxInjectionVolume / 2, maxInjectionVolume, Inclusive -> None]]&,
			{resolvedInjectionVolume, resolvedCationInjectionVolume, resolvedAnionInjectionVolume}
		];

		(* Throw warnings and create tests for any non-recommended injection volumes *)
		recommendedInjectionVolumeTests = MapThread[
			Function[{optionName, resolvedOption, nonRecommendedInjectionVolumeQ},
				If[nonRecommendedInjectionVolumeQ && messagesQ && notInEngine,
					Message[
						Warning::NonRecommendedICInjectionVolume,
						optionName,
						resolvedOption,
						maxInjectionVolume,
						maxInjectionVolume / 2
					]
				];
				Warning[
					"If " <> ToString[optionName] <> " is specified, it is either equal to the sample loop volume or less than one half of the sample loop volume:",
					nonRecommendedInjectionVolumeQ,
					False
				]
			],
			{
				{InjectionVolume, CationInjectionVolume, AnionInjectionVolume},
				{resolvedInjectionVolume, resolvedCationInjectionVolume, resolvedAnionInjectionVolume},
				nonRecommendedInjectionVolumeQs
			}
		];

		(* 21. EluentGradient, AnionGradient, AnionGradientStart, AnionGradientEnd, AnionGradientDuration, AnionEquilibrationTime, AnionFlushTime and AnionFlowRate resolution! *)

		(* == Error Checking == *)
		(* If there are anion samples in a run, all anion related gradient options should all be specified *)

		(* 21.1 If AnionSamples is specified, all anion related options, i.e. the gradient and detection options cannot be Null *)

		(* Pull all the options related to anion samples that cannot be set to Null if AnionSamples are specified *)
		anionSampleMustOptions = {
			AnionColumn,
			AnionColumnTemperature,
			EluentGradient,
			AnionFlowRate,
			AnionGradient,
			AnionSuppressorMode,
			AnionDetectionTemperature,
			AnionInjectionTable
		};

		(*first we ask if any of the anion options are defined*)
		anionSampleOptionSpecifiedBool = Map[
			MatchQ[Lookup[roundedOptionsAssociation, #], Except[ListableP[(Null | None | Automatic | Ambient)]]]&,
			anionSampleMustOptions
		];

		(* Then we check whether anion samples are specified in the InjectionTable *)
		anionSampleInInjectionTable = If[anionInjectionTableSpecifiedQ,
			Cases[anionInjectionTableLookupRounded, {Sample, __}],
			{}
		];

		(* Check to see if anion sample exists in the first place *)
		anionSampleExistsQ = MemberQ[anionSampleOptionSpecifiedBool, True] || Length[anionSampleInInjectionTable] > 0 || Length[ToList@resolvedAnionSamples] > 0;

		(*simultaneously, we should check to see if certain options were set to Null when they shouldn't have been*)
		anionSampleConflictQ = And[anionSampleExistsQ, MemberQ[Lookup[roundedOptionsAssociation, anionSampleMustOptions], Null]];

		(*do all of our error accounting *)
		invalidAnionSampleConflictOptions = If[anionSampleConflictQ && messagesQ,
			(
				Message[Error::SampleOptionConflict, AnionChannel, PickList[anionSampleMustOptions, Lookup[roundedOptionsAssociation, anionSampleMustOptions], Null]];
				PickList[anionSampleMustOptions, Lookup[roundedOptionsAssociation, anionSampleMustOptions], Null]
			),
			{}
		];

		(* generate the test for mismatches between the injection table and the samples *)
		anionSampleConflictTest = testOrNull["If AnionSamples are specified, the other pertinent options should not be set to Null:", Not[anionSampleConflictQ]];


		(* Helper function here to collapse gradient into single percentage/concentration/flowrate value if the option is Automatic and all values are the same at each timepoint *)
		collapseGradient[gradientTimepoints : {{TimeP, PercentP | ConcentrationP | FlowRateP}...}] := If[SameQ @@ (gradientTimepoints[[All, 2]]),
			gradientTimepoints[[1, 2]],
			gradientTimepoints
		];

		(* Pull out the MinFlowRate and MaxFlowRate values of the resolved anion column *)
		{minAnionColumnFlowRate, maxAnionColumnFlowRate} = If[!NullQ[resolvedAnionColumn],
			Lookup[resolvedAnionColumnModelPacket, {MinFlowRate, MaxFlowRate}],
			{Null, Null}
		];

		(* Pull out the MinFlowRate and MaxFlowRate values of the resolved instrument *)
		minInstrumentFlowRate = Lookup[resolvedInstrumentModelPacket, MinFlowRate];
		maxInstrumentFlowRate = Lookup[resolvedInstrumentModelPacket, MaxFlowRate];

		(* Pull out the MinFlowRate and MaxFlowRate values from the suppressor and the eluent generator *)
		{minAnionSuppressorFlowRate, maxAnionSuppressorFlowRate} = If[NullQ[Lookup[resolvedInstrumentModelPacket, AnionSuppressor, Null]],
			{Null, Null},
			Lookup[
				fetchPacketFromCache[Lookup[resolvedInstrumentModelPacket, AnionSuppressor, {}], fullCache],
				{MinFlowRate, MaxFlowRate}
			]
		];

		{minEluentGeneratorFlowRate, maxEluentGeneratorFlowRate} = If[MatchQ[Lookup[resolvedInstrumentModelPacket, IntegratedEluentGenerator, Null], {} | Null],
			{Null, Null},
			Lookup[
				fetchPacketFromCache[First@Lookup[resolvedInstrumentModelPacket, IntegratedEluentGenerator], fullCache],
				{MinFlowRate, MaxFlowRate}
			]
		];

		(* Use the minimum MinFlowRate and MaxFlowRate from instrument, column, eluent generator, and suppressor *)
		minAnionFlowRate = If[NullQ[{minAnionColumnFlowRate, minInstrumentFlowRate, minAnionSuppressorFlowRate, minEluentGeneratorFlowRate}],
			Null,
			Min[{minAnionColumnFlowRate, minInstrumentFlowRate, minAnionSuppressorFlowRate, minEluentGeneratorFlowRate} /. Null -> Nothing]
		];
		maxAnionFlowRate = If[NullQ[{maxAnionColumnFlowRate, maxInstrumentFlowRate, maxAnionSuppressorFlowRate, maxEluentGeneratorFlowRate}],
			Null,
			Min[{maxAnionColumnFlowRate, maxInstrumentFlowRate, maxAnionSuppressorFlowRate, maxEluentGeneratorFlowRate} /. Null -> Nothing]
		];

		(* Pick the optimal flow rate for this column *)
		(* Resolution logic: If the minimum flowrate is greater than 0.25 mL/Minute, then go with the minimum flowrate. Otherwise, go with the smaller value between 0.25 mL/Minute and maximum flow rate *)
		optimalAnionColumnFlowRate = If[!NullQ[{minAnionFlowRate, maxAnionFlowRate}],
			If[minAnionFlowRate > 0.25 Milliliter / Minute,
				minAnionFlowRate,
				Min[0.25 Milliliter / Minute, maxAnionFlowRate]
			],
			Null
		];

		(* Error checking to see if all three GradientStart GradientEnd and GradientDuration options are specified or Nulled out *)

		(* Resolution of gradient related options *)
		{
			resolvedAnionGradient,
			resolvedAnionGradientStart,
			resolvedAnionGradientEnd,
			resolvedAnionGradientDuration,
			resolvedAnionEquilibrationTime,
			resolvedAnionFlushTime,
			resolvedAnionFlowRate,
			resolvedEluentGradient,
			anionGradientStartEndSpecifiedErrors,
			anionDurationOptionSpecifiedErrors,
			anionGradientConsistentErrors,
			invalidAnionGradientCompositionErrors,
			anionRemovedExtraErrors,
			anionFlowRateErrors,
			anionDurationConsistentErrors,
			overwriteAnionGradientBool
		} = Module[{
			eluentGradientLookup, anionGradientStartLookup, anionGradientEndLookup, anionGradientDurationLookup, anionGradientLookup, anionEquilibrationTimeLookup,
			anionFlushTimeLookup, anionFlowRateLookup, anionInjectionTableSampleRoundedGradient, anionGradientStartEndSpecifiedQ, anionDurationOptionsSpecifiedQ,
			anionGradientConsistentQ, anionGradientStart, anionGradientEnd, anionRemovedExtrasQ, anionEquilibrationTime, anionFlushTime, protoAnionGradientOptionTuple,
			anionGradientOptionTuple, defaultedAnionFlowRate, anionGradientReturned, initiallyResolvedAnionGradient, invalidAnionGradientCompositionQ, eluentGradient,
			anionFlowRate, anionGradient, overwriteAnionGradientQ, anionInjectionTableWithID, incompatibleAnionFlowRateQ, fullAnionGradient, individualGradientSpecifiedQ,
			anionDurationConsistentQ, individualGradientNullQ
		},

			If[MatchQ[resolvedAnionSamples, {} | Null | {Null}] || MatchQ[mapThreadFriendlyAnionSampleOptions, Null],
				(* If there is no resolvedAnionSamples, then set all anion gradient related options to Null, and all error tracking variable to False *)
				Join[ConstantArray[Null, 8], ConstantArray[False, 8]],

				(* Otherwise, run this giant map thread to resolve all anion gradient related options *)
				Transpose[MapThread[Function[{mySample, myMapFriendlyOptions},

					(* Look up the values of each options in the list *)
					{
						eluentGradientLookup,
						anionGradientStartLookup,
						anionGradientEndLookup,
						anionGradientDurationLookup,
						anionGradientLookup,
						anionEquilibrationTimeLookup,
						anionFlushTimeLookup,
						anionFlowRateLookup
					} = Lookup[myMapFriendlyOptions, {
						EluentGradient,
						AnionGradientStart,
						AnionGradientEnd,
						AnionGradientDuration,
						AnionGradient,
						AnionEquilibrationTime,
						AnionFlushTime,
						AnionFlowRate
					}];

					(* Setup: We first get the injection table gradients *)
					anionInjectionTableSampleRoundedGradient = If[MatchQ[anionInjectionTableLookupRounded, Except[Automatic]] && !injectionTableSampleConflictQ,

						anionInjectionTableWithID = Map[
							If[MatchQ[#[[2]], ObjectP[]],
								Join[ToList@#[[1]], ToList@Download[#[[2]], Object], #[[3 ;; 5]]],
								#
							]&,
							anionInjectionTableLookupRounded
						];

						(* Extract the gradient specified in InjectionTable *)
						Cases[anionInjectionTableWithID, {Sample, mySample | Download[mySample, Object], _, _, gradient_} :> gradient],

						(* If InjectionTable is not specified or has conflict with input samples, pad it with Automatics*)
						Automatic
					];

					(* First we need to make sure that the start and end options are either all specified or not *)
					anionGradientStartEndSpecifiedQ = !MatchQ[{anionGradientStartLookup, anionGradientEndLookup}, {ConcentrationP, ConcentrationP} | {Automatic | Null, Automatic | Null}];

					(* Then we need to make sure that the duration is specified either with start & end, or with eluent gradient *)
					anionDurationOptionsSpecifiedQ = If[MatchQ[anionGradientDurationLookup, TimeP],
						Not[MatchQ[{anionGradientStartLookup, anionGradientEndLookup}, {ConcentrationP, ConcentrationP}] || MatchQ[eluentGradientLookup, ConcentrationP]],
						False
					];

					(* Need to check if any of the individual gradient is specified in {Time,Percent} format *)
					individualGradientSpecifiedQ = MatchQ[eluentGradientLookup, Except[Automatic | ConcentrationP]];

					(* We also need to check if Duration specification is consistent with individual gradient *)
					anionDurationConsistentQ = If[individualGradientSpecifiedQ,

						If[MatchQ[anionGradientDurationLookup, TimeP],
							True,
							False
						],
						(* If none of the individual gradient is specified, then leave this error tracking variable to False *)
						False
					];

					(* If gradient is specied as a method object, check whether AnionGradient and the injection table specify the same object*)
					anionGradientConsistentQ = If[MatchQ[anionGradientLookup, ObjectP[Object[Method, IonChromatographyGradient]]] && MatchQ[anionInjectionTableSampleRoundedGradient, {ObjectP[Object[Method, IonChromatographyGradient]]}],
						Not[MatchQ[ToList@Download[anionGradientLookup, Object], Download[anionInjectionTableSampleRoundedGradient, Object]]],
						False
					];

					(* Extract or default GradientStart and GradientEnd values *)
					{anionGradientStart, anionGradientEnd} = Switch[{anionGradientStartLookup, anionGradientEndLookup, anionGradientDurationLookup},

						(* If valid anionGradientStart and anionGradientEnd are given, go with that *)
						{ConcentrationP, ConcentrationP, _} | {Null, Null, Null | TimeP}, {anionGradientStartLookup, anionGradientEndLookup},

						(* Default to anionGradientStart if something is wrong with gradientEnd *)
						{ConcentrationP, _, _}, {anionGradientStartLookup, anionGradientStartLookup},

						(* Default to 0 Millimolar if something is wrong with anionGradeintStart *)
						{_, ConcentrationP, _}, {0 Millimolar, anionGradientEndLookup},

						(* Otherwise, both Null*)
						_, {Null, Null}
					];

					(* Resolve equilibration times from option value or gradient or injection table object *)
					anionEquilibrationTime = Which[

						(* If user specified equilibration time, go with it *)
						MatchQ[anionEquilibrationTimeLookup, Except[Automatic]], anionEquilibrationTimeLookup,

						(* If AnionGradient is specified as an object, extract EquilibrationTime information from the packet *)
						MatchQ[anionGradientLookup, ObjectP[Object[Method, IonChromatographyGradient]]], Lookup[fetchPacketFromCache[Download[anionGradientLookup, Object], fullCache], AnionEquilibrationTime],

						(* If InjectionTable specifies a gradient for an anion channel sample, extract EquilibrationTime information from the packet *)
						MatchQ[anionInjectionTableSampleRoundedGradient, ObjectP[Object[Method, IonChromatographyGradient]]], Lookup[fetchPacketFromCache[Download[anionInjectionTableSampleRoundedGradient, Object], fullCache], AnionEquilibrationTime],

						(* Otherwise, set it to Null *)
						True, Null
					];

					(* Similarly, resolve flush times from option value or gradient object *)
					anionFlushTime = Which[

						(* If user specified flush time, go with it *)
						MatchQ[anionFlushTimeLookup, Except[Automatic]], anionFlushTimeLookup,

						(* If AnionGradient is specified as an object, extract FlushTime information from the packet *)
						MatchQ[anionGradientLookup, ObjectP[Object[Method, IonChromatographyGradient]]], Lookup[fetchPacketFromCache[Download[anionGradientLookup, Object], fullCache], AnionFlushTime],

						(* If InjectionTable specifies a gradient for a anion channel sample, extract Flush information from the packet *)
						MatchQ[anionInjectionTableSampleRoundedGradient, ObjectP[Object[Method, IonChromatographyGradient]]], Lookup[fetchPacketFromCache[Download[anionInjectionTableSampleRoundedGradient, Object], fullCache], AnionFlushTime],

						(* Otherwise, set it to Null *)
						True, Null
					];

					(* If Gradient option is an object, pull Gradient value from packet *)
					protoAnionGradientOptionTuple = Which[

						(* If AnionGradient specifies a method object, extract Gradient information from the packet *)
						MatchQ[anionGradientLookup, ObjectP[Object[Method, IonChromatographyGradient]]],
						Lookup[fetchPacketFromCache[Download[anionGradientLookup, Object], fullCache], AnionGradient],

						(* If InjectionTable specifies a method object, extract Gradient information from the packet *)
						MatchQ[anionGradientLookup, Automatic] && MatchQ[anionInjectionTableSampleRoundedGradient, ObjectP[Object[Method, IonChromatographyGradient]]],
						Lookup[fetchPacketFromCache[Download[anionInjectionTableSampleRoundedGradient, Object], fullCache], AnionGradient],

						(* Otherwise, namely if anionGradient is not a method object, then use what's specified in AnionGradient *)
						True, anionGradientLookup
					];

					(* Update AnionFlowRate in the gradient method object if the option is specified *)
					anionGradientOptionTuple = If[MatchQ[anionFlowRateLookup, Except[Automatic]],

						(* If AnionFlowRate is specified, use the specified flow rate and replace the default flowrate of the method object *)
						(* In IonChromatography Gradient method, AnionGradient goes "Time", "Eluent Concentration", "FlowRate". FlowRate is in the third column *)
						ReplacePart[protoAnionGradientOptionTuple, Table[{x, 3} -> anionFlowRateLookup, {x, 1, Length[protoAnionGradientOptionTuple]}]],

						(* Otherwise, use the default flow rate in the gradient object *)
						protoAnionGradientOptionTuple
					];

					(* Default FlowRate to option value, gradient tuple values, or the pre-calculated optimal flow rate for the column *)
					(* note that it's ok to have this flow rate either match FlowRateP, or be a list of pairs of time and flow rate since resolveGradient can handle either *)
					defaultedAnionFlowRate = Which[

						(* If the AnionFlowRate is specified, go with the user specified value *)
						MatchQ[anionFlowRateLookup, Except[Automatic]], anionFlowRateLookup,

						(* If the AnionFlowRate is specified as part of the gradient method object, extract the flow rate from the object *)
						MatchQ[anionGradientOptionTuple, {TimeP, ConcentrationP, FlowRateP}], anionGradientOptionTuple[[All, {1, 3}]],

						(* If no flow rate is specified, use the optional flow rate determined for the column *)
						True, optimalAnionColumnFlowRate
					];

					(* Track whether AnionFlowRate is compatible with the instrument, and the column *)
					incompatibleAnionFlowRateQ = Not[Between[defaultedAnionFlowRate, {minAnionFlowRate, maxAnionFlowRate}]];

					(* finally run our helper resolution function *)
					anionGradientReturned = If[MatchQ[{anionGradientOptionTuple, eluentGradientLookup, anionGradientStart, anionGradientEnd, anionGradientDurationLookup, anionFlowRateLookup}, {(Null | Automatic)..}] || anionGradientStartEndSpecifiedQ || anionDurationOptionsSpecifiedQ,
						resolveICAnionGradient[defaultAnionGradientIC[defaultedAnionFlowRate], eluentGradientLookup, defaultedAnionFlowRate, anionGradientStartLookup, anionGradientEndLookup, anionGradientDurationLookup],
						resolveICAnionGradient[anionGradientOptionTuple, eluentGradientLookup, defaultedAnionFlowRate, anionGradientStartLookup, anionGradientEndLookup, anionGradientDurationLookup]
					];

					(*remove duplicate entries if need be*)
					initiallyResolvedAnionGradient = DeleteDuplicatesBy[anionGradientReturned, First[# * 1.] &];

					(*if it's not the same note that*)
					anionRemovedExtrasQ = !MatchQ[anionGradientReturned, initiallyResolvedAnionGradient];


					(* Add equilibration time and flush time *)
					fullAnionGradient = Module[{gradientStartPoint, gradientEndPoint},
						(* Add equilibration time in minute onto the resolved gradient *)
						(* If equilibration time is Null, then do nothing  here *)
						If[NullQ[anionEquilibrationTime],
							gradientStartPoint = Nothing,
							gradientStartPoint = First[initiallyResolvedAnionGradient];
							initiallyResolvedAnionGradient[[All, 1]] = initiallyResolvedAnionGradient[[All, 1]] + anionEquilibrationTime
						];

						(* Add flush time in minute onto the resolved gradient *)
						(* If flush time is Null, then do nothing  here *)
						If[NullQ[anionFlushTime],
							gradientEndPoint = Nothing,
							gradientEndPoint = Last[initiallyResolvedAnionGradient];
							gradientEndPoint[[1]] = gradientEndPoint[[1]] + anionFlushTime
						];
						Join[{gradientStartPoint}, initiallyResolvedAnionGradient, {gradientEndPoint}]
					];

					(*check whether the gradient composition adds up to 100 okay*)
					invalidAnionGradientCompositionQ = Not[AllTrue[fullAnionGradient, #[[2]] <= 100 Millimolar&]];

					(*now resolve all of the individual gradients and flow rate*)
					eluentGradient = If[MatchQ[eluentGradientLookup, Automatic],
						collapseGradient[fullAnionGradient[[All, {1, 2}]]],
						eluentGradientLookup
					];
					anionFlowRate = If[MatchQ[anionFlowRateLookup, Automatic],
						collapseGradient[fullAnionGradient[[All, {1, -1}]]],
						anionFlowRateLookup
					];

					overwriteAnionGradientQ = If[MatchQ[anionGradientLookup, ObjectP[Object[Method, IonChromatographyGradient]]],
						!MatchQ[Lookup[fetchPacketFromCache[Download[anionGradientLookup, Object], fullCache], AnionGradient], fullAnionGradient],
						False
					];

					(*finally resolve the gradient*)
					anionGradient = Which[
						MatchQ[anionGradientLookup, ObjectP[Object[Method, IonChromatographyGradient]]] && !overwriteAnionGradientQ, anionGradientLookup,
						(*otherwise if the gradient is automatic and the injection table is set, should use that*)
						MatchQ[anionGradientLookup, Automatic] && MatchQ[anionInjectionTableSampleRoundedGradient, ObjectP[Object[Method, IonChromatographyGradient]]], Download[anionInjectionTableSampleRoundedGradient, Object],
						(*otherwise, it should be a tuple*)
						True, fullAnionGradient
					];

					(*return everything*)
					{
						anionGradient,
						anionGradientStart,
						anionGradientEnd,
						anionGradientDurationLookup,
						anionEquilibrationTime,
						anionFlushTime,
						anionFlowRate,
						eluentGradient,
						anionGradientStartEndSpecifiedQ,
						anionDurationOptionsSpecifiedQ,
						anionGradientConsistentQ,
						invalidAnionGradientCompositionQ,
						anionRemovedExtrasQ,
						incompatibleAnionFlowRateQ,
						anionDurationConsistentQ,
						overwriteAnionGradientQ
					}

				],
					{ToList@resolvedAnionSamples, mapThreadFriendlyAnionSampleOptions}
				]]]
		];

		(* == Error Checking == *)
		(* This error should already be thrown from SampleOptionConflict error
        (* 21.1 If AnionSamples are specified or resolved, some gradient options must be specified *)
        missingGradientAnionSamples=If[MatchQ[resolvedAnionSamples,{}|Null|{Null}],
            {},
            PickList[ToList@resolvedAnionSamples,anionGradientMissingErrors,True]
        ];

        (* If there are any missing anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
        missingAnionGradientOptions=If[Length[missingGradientAnionSamples]>0&&messagesQ,
            (
                Message[Error::MissingAnionGradientOptions,AnionSamples,ObjectToString[missingGradientAnionSamples,Cache -> fullCache, Simulation -> updatedSimulation]];
                {EluentGradient,AnionFlowRate,AnionGradient}
            ),
            {}
        ];

        (* Generate test for missing anion gradient options *)
        missingAnionGradientTests=testOrNullIndexMatched["If AnionSamples are specified or resolved, anion gradient options are either specified in the option or the InjectionTable:",resolvedAnionSamples,anionGradientMissingErrors]; *)

		(* 21.2 If either gradient start or gradient end options is specified, both options need to be specified *)
		notSpecifiedAnionGradientStartEnd = If[MatchQ[resolvedAnionSamples, {} | Null | {Null}],
			{},
			PickList[ToList@resolvedAnionSamples, anionGradientStartEndSpecifiedErrors, True]
		];

		(* If there are any missing anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
		notSpecifiedAnionGradientStartEndOptions = If[Length[notSpecifiedAnionGradientStartEnd] > 0 && messagesQ,
			(
				Message[Error::HPICGradientStartEndConflict, {AnionGradientStart, AnionGradientEnd}, ObjectToString[notSpecifiedAnionGradientStartEnd,Cache -> fullCache, Simulation -> updatedSimulation]];
				{AnionGradientStart, AnionGradientEnd, AnionGradientDuration}
			),
			{}
		];

		(* Generate test for missing specification among anion gradient start, end and duration *)
		notSpecifiedAnionGradientStartEndTests = testOrNullIndexMatched["AnionGradientStart, and AnionGradientEnd should be specified or set to Null simultaneously:", resolvedAnionSamples, anionGradientStartEndSpecifiedErrors];

		(* 21.3 If AnionGradient is specified simultaenously in the option and the InjectionTable as method object, they should be consistent with each other *)
		inconsistentGradientAnionSamples = If[MatchQ[resolvedAnionSamples, Null | {} | {Null}],
			{},
			PickList[ToList@resolvedAnionSamples, anionGradientConsistentErrors, True]
		];

		(* If there are any missing anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
		inconsistentAnionGradientOptions = If[Length[inconsistentGradientAnionSamples] > 0 && messagesQ,
			(
				Message[Error::InconsistentGradientSpecification, AnionSamples, ObjectToString[inconsistentGradientAnionSamples,Cache -> fullCache, Simulation -> updatedSimulation]];
				{AnionGradient, AnionInjectionTable}
			),
			{}
		];

		(* Generate test for missing specification among anion gradient start, end and duration *)
		inconsistentAnionGradientTests = testOrNullIndexMatched["If specified, gradient methods in the AnionGradient option and the AnionInjectionTable must be consistent:", resolvedAnionSamples, anionGradientConsistentErrors];

		(* 21.4 If either EluentGradient or AnionGradient is specified, the maximum concentration is within the range defined by the integrated eluent generator *)
		invalidGradientCompositionAnionSamples = If[MatchQ[resolvedAnionSamples, Null | {} | {Null}],
			{},
			PickList[ToList@resolvedAnionSamples, invalidAnionGradientCompositionErrors, True]
		];
		maxEluentConcentration = If[MatchQ[Lookup[resolvedInstrumentModelPacket, IntegratedEluentGenerator, {}], {}],
			Infinity Millimolar,
			Lookup[fetchPacketFromCache[First@Lookup[resolvedInstrumentModelPacket, IntegratedEluentGenerator], fullCache], MaxConcentration, Null] /. Null -> Infinity Millimolar
		];

		(* If there are any invalid anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
		invalidAnionGradientCompositionOptions = If[Length[invalidGradientCompositionAnionSamples] > 0 && messagesQ,
			(
				Message[Error::InvalidAnionGradientComposition, AnionSamples, ObjectToString[invalidGradientCompositionAnionSamples,Cache -> fullCache, Simulation -> updatedSimulation], maxEluentConcentration];
				{EluentGradient, AnionGradient}
			),
			{}
		];

		(* Generate test for invalid anion gradient composition *)
		invalidAnionGradientTests = testOrNullIndexMatched["The specified AnionGradient has maximum eluent concentrations less than the max concentration allowed by the eluent generator:", resolvedAnionSamples, invalidAnionGradientCompositionErrors];

		(* 21.5 AnionFlowRate has to be within the range supported by the instrument, and the column *)
		(* If there are any invalid anion flow rates and we are throwing messages, then throw an error message and collect invalid options *)
		incompatibleAnionFlowRateOptions = If[MemberQ[anionFlowRateErrors, True] && messagesQ,
			(
				Message[Error::FlowRateAboveMax, AnionFlowRate, PickList[resolvedAnionFlowRate, anionFlowRateErrors, True], resolvedInstrument, resolvedAnionColumn, maxAnionFlowRate];
				{AnionFlowRate}
			),
			{}
		];

		(* Generate test for invalid anion gradient composition *)
		invalidAnionFlowRateTests = testOrNullIndexMatched["The specified AnionFlowRate has maximum flow rate less than that supported by the instrument and the column:", resolvedAnionSamples, anionFlowRateErrors];

		(* 21.6 If gradient duration is specified, either gradient start & end or eluent gradient is specified *)
		notSpecifiedAnionGradientDuration = If[MatchQ[resolvedAnionSamples, {} | Null | {Null}],
			{},
			PickList[ToList@resolvedAnionSamples, anionDurationOptionSpecifiedErrors, True]
		];

		(* If there are any missing anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
		notSpecifiedAnionGradientDurationOptions = If[Length[notSpecifiedAnionGradientDuration] > 0 && messagesQ,
			(
				Message[Error::HPICGradientShortcutConflict, AnionGradientDuration, {AnionGradientStart, AnionGradientEnd}, "EluentGradient"];
				{AnionGradientStart, AnionGradientEnd, AnionGradientDuration, EluentGradient}
			),
			{}
		];

		(* Generate test for missing specification among anion gradient start, end and duration *)
		notSpecifiedAnionGradientDurationTests = testOrNullIndexMatched["AnionGradientDuration should be specified either with AnionGradientStart/AnionGradientEnd or with EluentGradient:", resolvedAnionSamples, anionDurationOptionSpecifiedErrors];

		(* 21.7 If gradient duration and eluent gradient are both specified, their specified values are consistent *)
		inconsistentAnionGradientDuration = If[MatchQ[resolvedAnionSamples, {} | Null | {Null}],
			{},
			PickList[ToList@resolvedAnionSamples, anionDurationConsistentErrors, True]
		];

		(* If there are any missing anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
		inconsistentAnionGradientDurationOptions = If[Length[inconsistentAnionGradientDuration] > 0 && messagesQ && notInEngine,
			(
				Message[Warning::HPICGradientShortcutAmbiguity, AnionGradientDuration, EluentGradient];
				{}
			),
			{}
		];

		(* Generate test for missing specification among anion gradient start, end and duration *)
		consistentAnionGradientDurationTests = warningOrNullIndexMatched["Specified values for AnionGradientDuration and EluentGradient are consistent:", resolvedAnionSamples, anionDurationConsistentErrors];

		(* 22. AnionColumnTemperature resolution *)

		resolvedAnionColumnTemperature = Module[{injectionTableWithID, gradientInInjectionTable},

			If[MatchQ[resolvedAnionColumn, {} | Null | {Null}] || MatchQ[mapThreadFriendlyAnionSampleOptions, Null | {}],
				Null,

				MapThread[Function[{mySample, anionGradient, myMapThreadOptions},

					injectionTableWithID = Map[
						If[MatchQ[#[[2]], ObjectP[]],
							Join[ToList@#[[1]], ToList@Download[#[[2]], Object], #[[3 ;; Length[#]]]],
							#
						]&,
						anionInjectionTableLookupRounded
					];

					(* If InjectionTable is not the default value of automatic, then look up the gradient object specified for mySample *)
					gradientInInjectionTable = If[!MatchQ[injectionTableWithID, ListableP[Automatic]],
						Cases[injectionTableWithID, {Sample, Download[mySample, Object], _, _, gradientObj : ObjectP[Object[Method, IonChromatographyGradient]]} :> gradientObj],
						Null
					];

					(* Download the gradient object from fullCache and extract column temperature information *)
					Which[

						(* If user has already specified anion column temperature, go with that *)
						!MatchQ[Lookup[myMapThreadOptions, AnionColumnTemperature], Automatic | Null],
						Lookup[myMapThreadOptions, AnionColumnTemperature],

						(* If the specified AnionGradient is a method object, extract column temperature from there *)
						MatchQ[anionGradient, ObjectP[Object[Method, IonChromatographyGradient]]],
						If[NullQ[Lookup[fetchPacketFromCache[anionGradient, fullCache], AnionColumnTemperature]],
							Ambient,
							Lookup[fetchPacketFromCache[Download[anionGradient, Object], fullCache], AnionColumnTemperature]
						],

						(* If the specified gradient in the InjectionTable is an Object, extract column temperature from there *)
						MatchQ[gradientInInjectionTable, ObjectP[Object[Method, IonChromatographyGradient]]],
						Lookup[fetchPacketFromCache[Download[gradientInInjectionTable, Object], fullCache], AnionColumnTemperature],

						True,
						Ambient
					]
				],
					{ToList@resolvedAnionSamples, resolvedAnionGradient /. Null -> {}, mapThreadFriendlyAnionSampleOptions}
				]]];


		(* == Error Checking == *)
		(* No need for error checking here because the column temperature limits are already incorporated into the widget
        (* Identify resolved anion samples that have incompatible column temperature and also compiled a list of incompatible temperatures *)
        incompatibleColumnTemperatureAnionSamples=If[MatchQ[resolvedAnionSamples,Null|{}|{Null}],
            {},
            PickList[ToList@resolvedAnionSamples,incompatibleAnionColumnTemperatureErrors,True]
        ];
        incompatibleAnionColumnTemperature=If[MatchQ[resolvedAnionSamples,{}|Null|{Null}],
            {},
            PickList[resolvedAnionColumnTemperature,incompatibleAnionColumnTemperatureErrors,True]
        ];

        (* If there are any incompatible column temperatures and we are throwing messages, throw an error and collect in valid option *)
        incompatibleAnionColumnTemperatureOptions=If[Length[incompatibleAnionColumnTemperature]>0&&messagesQ,
            (
                Message[Error::IncompatibleColumnTemperature,AnionColumn,incompatibleAnionColumnTemperature,AnionSamples,ObjectToString[incompatibleColumnTemperatureAnionSamples,Cache -> fullCache, Simulation -> updatedSimulation],allowedAnionColumnTemperatureRange[[1]],allowedAnionColumnTemperatureRange[[2]]];
                {AnionColumnTemperature}
            ),
            {}
        ];

        (* Generate tests for incompatible anion column temperature *)
        incompatibleAnionColumnTemperatureTests=testOrNullIndexMatched["Specified AnionColumnTemperature is within the range of supported temperature of the AnionColumn:",resolvedAnionSamples,incompatibleAnionColumnTemperatureErrors]; *)

		(* 24. BufferA resolution *)

		(* == Error Checking == *)
		(* 24.1 If CationSamples is specified, all cation related options, i.e. the gradient and detection options cannot be Null *)

		(* Pull all the options related to anion samples that cannot be set to Null if AnionSamples are specified *)
		(* Note: BufferB, C, D and therefore GradientB, C, D can be null *)
		cationSampleMustOptions = {
			CationColumn,
			CationColumnTemperature,
			BufferA,
			BufferB,
			BufferC,
			BufferD,
			CationGradientA,
			CationGradientB,
			CationGradientC,
			CationGradientD,
			CationFlowRate,
			CationGradient,
			CationSuppressorMode,
			CationDetectionTemperature,
			CationInjectionTable
		};

		(*first we ask if any of the cation sample options are defined*)
		cationSampleOptionSpecifiedBool = Map[
			MatchQ[Lookup[roundedOptionsAssociation, #], Except[ListableP[(Null | None | Automatic | Ambient)]]]&,
			cationSampleMustOptions
		];

		(* Then we check whether cation samples are specified in the InjectionTable *)
		cationSampleInInjectionTable = If[cationInjectionTableSpecifiedQ,
			Cases[cationInjectionTableLookupRounded, {Sample, __}],
			{}
		];

		(* Check to see if standard exists in the first place *)
		cationSampleExistsQ = MemberQ[cationSampleOptionSpecifiedBool, True] || Length[cationSampleInInjectionTable] > 0 || Length[ToList@resolvedCationSamples] > 0;

		(*simultaneously, we should check to see if certain options were set to Null when they shouldn't have been*)
		cationSampleConflictQ = And[cationSampleExistsQ, MemberQ[Lookup[roundedOptionsAssociation, cationSampleMustOptions], Null]];

		(*do all of our error accounting *)
		invalidCationSampleConflictOptions = If[cationSampleConflictQ && messagesQ,
			(
				Message[Error::SampleOptionConflict, CationChannel, PickList[cationSampleMustOptions, Lookup[roundedOptionsAssociation, cationSampleMustOptions], Null]];
				PickList[cationSampleMustOptions, Lookup[roundedOptionsAssociation, cationSampleMustOptions], Null]
			),
			{}
		];

		(* generate the test for mismatches between the injection table and the samples *)
		cationSampleConflictTest = testOrNull["If CationSamples are specified, the other pertinent options should not be set to Null:", Not[cationSampleConflictQ]];

		(* 24.2 If ElectrochemicalChannel is used, all electrochemical related options, i.e. the gradient and detection options cannot be Null *)

		(* Pull all the options related to electrochemical samples that cannot be set to Null *)
		(* Note: BufferB, C, D and therefore GradientB, C, D can be null *)
		electrochemicalSampleMustOptions = {
			Column,
			ColumnTemperature,
			BufferA,
			BufferB,
			BufferC,
			BufferD,
			GradientA,
			GradientB,
			GradientC,
			GradientD,
			FlowRate,
			Gradient,
			Detector,
			ElectrochemicalInjectionTable
		};

		(*first we ask if any of the electrochemical sample options are defined*)
		electrochemicalSampleOptionSpecifiedBool = Map[
			MatchQ[Lookup[roundedOptionsAssociation, #], Except[ListableP[(Null | None | Automatic | Ambient)]]]&,
			electrochemicalSampleMustOptions
		];

		(* Then we check whether electrochemical samples are specified in the InjectionTable *)
		electrochemicalSampleInInjectionTable = If[electrochemicalInjectionTableSpecifiedQ,
			Cases[electrochemicalInjectionTableLookupRounded, {Sample, __}],
			{}
		];

		(* Check to see if standard exists in the first place *)
		electrochemicalSampleExistsQ = MemberQ[ToList@resolvedAnalysisChannel, ElectrochemicalChannel] || MemberQ[electrochemicalSampleOptionSpecifiedBool, True] || Length[electrochemicalSampleInInjectionTable] > 0;

		(*simultaneously, we should check to see if certain options were set to Null when they shouldn't have been*)
		electrochemicalSampleConflictQ = And[electrochemicalSampleExistsQ, MemberQ[Lookup[roundedOptionsAssociation, electrochemicalSampleMustOptions], Null | {Null}]];

		(*do all of our error accounting *)
		invalidElectrochemicalSampleConflictOptions = If[electrochemicalSampleConflictQ && messagesQ,
			(
				Message[Error::SampleOptionConflict, ElectrochemicalChannel, PickList[electrochemicalSampleMustOptions, Lookup[roundedOptionsAssociation, electrochemicalSampleMustOptions], Null | {Null}]];
				PickList[electrochemicalSampleMustOptions, Lookup[roundedOptionsAssociation, electrochemicalSampleMustOptions], Null]
			),
			{}
		];

		(* generate the test for mismatches between the injection table and the samples *)
		electrochemicalSampleConflictTest = testOrNull["If ElectrochemicalChannel is used, the pertinent options should not be set to Null:", Not[electrochemicalSampleConflictQ]];


		(* A bit of a set up here *)
		(* Find the position for any objects specified in the CationGradient option *)
		cationGradientObjectPositions = Which[
			!MatchQ[Lookup[roundedOptionsAssociation, CationGradient], Null | {} | {Null}],
			{1, Flatten@Position[ToList@Lookup[roundedOptionsAssociation, CationGradient], ObjectP[Object[Method, IonChromatographyGradient]], {1}]},

			!MatchQ[Lookup[roundedOptionsAssociation, CationStandardGradient], Null | {} | {Null}],
			{2, Flatten@Position[ToList@Lookup[roundedOptionsAssociation, CationStandardGradient], ObjectP[Object[Method, IonChromatographyGradient]], {1}]},

			!MatchQ[Lookup[roundedOptionsAssociation, CationBlankGradient], Null | {} | {Null}],
			{3, Flatten@Position[ToList@Lookup[roundedOptionsAssociation, CationBlankGradient], ObjectP[Object[Method, IonChromatographyGradient]], {1}]}
		];

		(* Lookup any specified CationGradient using the positions identified above *)
		cationGradientObjects = If[!MatchQ[cationGradientObjectPositions, {}],
			Switch[
				First[cationGradientObjectPositions],
				1,
				(ToList@Lookup[roundedOptionsAssociation, CationGradient])[[Last@cationGradientObjectPositions]],

				2,
				(ToList@Lookup[roundedOptionsAssociation, CationStandardGradient])[[Last@cationGradientObjectPositions]],

				3,
				(ToList@Lookup[roundedOptionsAssociation, CationBlankGradient])[[Last@cationGradientObjectPositions]]
			],
			Null
		];

		(* Download the specified CationGradient objects from fullCache and lookup BufferA and BufferB in the first specified gradient object *)
		cationGradientPackets = If[!NullQ[cationGradientObjects],
			fetchPacketFromCache[#, fullCache]& /@ Download[cationGradientObjects, Object],
			Null
		];

		(* Find the position for any objects specified in the CationGradient option *)
		electrochemicalGradientObjectPositions = Which[
			!MatchQ[Lookup[roundedOptionsAssociation, Gradient], Null | {} | {Null}],
			{1, Flatten@Position[ToList@Lookup[roundedOptionsAssociation, Gradient], ObjectP[Object[Method, Gradient]], {1}]},

			!MatchQ[Lookup[roundedOptionsAssociation, StandardGradient], Null | {} | {Null}],
			{2, Flatten@Position[ToList@Lookup[roundedOptionsAssociation, StandardGradient], ObjectP[Object[Method, Gradient]], {1}]},

			!MatchQ[Lookup[roundedOptionsAssociation, BlankGradient], Null | {} | {Null}],
			{3, Flatten@Position[ToList@Lookup[roundedOptionsAssociation, BlankGradient], ObjectP[Object[Method, Gradient]], {1}]}
		];

		(* Lookup any specified CationGradient using the positions identified above *)
		electrochemicalGradientObjects = If[!MatchQ[electrochemicalGradientObjectPositions, {}],
			Switch[
				First[electrochemicalGradientObjectPositions],
				1,
				(ToList@Lookup[roundedOptionsAssociation, Gradient])[[Last@electrochemicalGradientObjectPositions]],

				2,
				(ToList@Lookup[roundedOptionsAssociation, StandardGradient])[[Last@electrochemicalGradientObjectPositions]],

				3,
				(ToList@Lookup[roundedOptionsAssociation, BlankGradient])[[Last@electrochemicalGradientObjectPositions]]
			],
			Null
		];

		(* Download the specified CationGradient objects from fullCache and lookup BufferA and BufferB in the first specified gradient object *)
		electrochemicalGradientPackets = If[!NullQ[electrochemicalGradientObjects],
			fetchPacketFromCache[#, fullCache]& /@ Download[electrochemicalGradientObjects, Object],
			Null
		];

		{bufferAInFirstGradient, bufferBInFirstGradient, bufferCInFirstGradient, bufferDInFirstGradient} = Which[
			(* Fetch the buffers stated in the cation gradient *)
			!MatchQ[cationGradientPackets, {}],
			Lookup[First[cationGradientPackets], {BufferA, BufferB, BufferC, BufferD}],

			(* Fetch the buffers stated in the electrochemical gradient *)
			!MatchQ[electrochemicalGradientPackets, {}],
			Lookup[First[electrochemicalGradientPackets], {BufferA, BufferB, BufferC, BufferD}],

			True,
			{Null, Null, Null, Null}
		];
		(*Define a helper function to calculate the buffer concentration based on the composition if the resolved buffer is a Model[Sample]*)
		calculateICBufferConcentration[resolvedBuffer : ObjectP[Model[Sample]]] := Module[
			{components, amount, compositionNoWater, density, molecularWeight, molarity, amountMolaritySum,
				amountUnits, molarityVolumePercentPicked, amountVolumePercentPicked, amountMolarityPicked,
				molecularWeightMassPercentPicked, amountMassPercentPicked, amountMassPercentSum,
				amountVolumePercentSum, compositionWaterPosition, amountNoWater, compositionPackets},

			(* If the resolvedBufferA is a model sample object, then get the composition of the buffer *)
			{amount, components} = If[MatchQ[resolvedBuffer, ObjectP[Model[Sample]]],

				Switch[Download[resolvedBuffer, Composition, Date -> Now],

					{} | Null | {Null}, {Null, 0 Millimolar},
					Except[{} | Null | {Null}], Transpose[Download[resolvedBuffer, Composition, Date -> Now]]
				]
			];

			(* Take out water object from the composition list *)
			compositionWaterPosition = Flatten@Position[Download[components, Object], Model[Molecule, "id:vXl9j57PmP5D"]];
			compositionNoWater = Delete[components, compositionWaterPosition];
			amountNoWater = Delete[amount, compositionWaterPosition];

			(* Get the density and molecular weight of all the composition *)
			(*I don't love Downloading this directly here; still better to have one instead of two which it used to be *)
			compositionPackets = Download[compositionNoWater, Packet[Density, MolecularWeight], Date -> Now];
			density = Convert[Lookup[compositionPackets, Density, {}], Gram / Liter] /. {Null -> 1 Gram / Liter};
			molecularWeight = Convert[Lookup[compositionPackets, MolecularWeight, {}], Gram / Millimole];

			(* Calculate molarity for all components *)
			molarity = MapThread[Divide, {ToList@density, ToList@molecularWeight}];

			(* From the amount list, fish out all amounts given in molarity units and sum it up *)
			amountMolarityPicked = Convert[Cases[amountNoWater, ConcentrationP], Millimolar];
			amountMolaritySum = Total[amountMolarityPicked];

			(* Get the units for all the amounts given *)
			amountUnits = Units[amountNoWater];

			(* Pick out amount given in MassPercent and then pick out their respective molarity calculated *)
			molecularWeightMassPercentPicked = PickList[ToList@molecularWeight, ToList@amountUnits, UnitsP[MassPercent]];
			amountMassPercentPicked = Unitless[Cases[ToList@amountNoWater, UnitsP[MassPercent]]] / 100;
			(*The buffer concentration calculation is used to calculate the current only. It is assumed that the buffer is water based, and the solute is dilute.*)
			amountMassPercentSum = Total[0.997 Gram / Milliliter * MapThread[Divide, {amountMassPercentPicked, molecularWeightMassPercentPicked}]];

			(* Pick out amount given in VolumePercent and then pick out their respective molarity calculated *)
			molarityVolumePercentPicked = PickList[ToList@molarity, ToList@amountUnits, UnitsP[VolumePercent]];
			amountVolumePercentPicked = Unitless[Cases[ToList@amountNoWater, UnitsP[VolumePercent]]] / 100;

			(* Sum up the concentration of all components given in VolumePercent *)
			amountVolumePercentSum = Total[molarityVolumePercentPicked * amountVolumePercentPicked];

			(* Total concentration *)
			Total[Cases[Flatten[{amountVolumePercentSum, amountMolaritySum, amountMassPercentSum, 0 Millimolar}], ConcentrationP]]
		];

		(* Actual resolution of BufferA here *)
		(* If user specified BufferA, that is specifiedBufferA is not Automatic or Null, go with user specification *)
		resolvedBufferA = If[!MatchQ[specifiedBufferA, (Automatic)],
			specifiedBufferA,

			(* If any Gradient object is specified and the specified Gradient method has BufferA already, then use that as the bufferA for this protocol *)
			If[MatchQ[bufferAInFirstGradient, ObjectP[Model[Sample]]],
				bufferAInFirstGradient,

				If[MemberQ[resolvedChannelSelection, CationChannel],

					(* Use MSA solution as BufferA for cation channel *)
					Model[Sample, StockSolution, "50 mM MSA (Methanesulfonic Acid)"],

					If[MemberQ[Join[ToList@resolvedAnalysisChannel, ToList@resolvedStandardAnalysisChannel, ToList@resolvedBlankAnalysisChannel], ElectrochemicalChannel],
						(* Use Milli-Q water as buffer for electrochemical channel *)
						Model[Sample, "Milli-Q water"],
						Null
					]
				]
			]
		];

		(* We need to get the concentratino of bufferA *)
		bufferAConcentration = If[NullQ[resolvedBufferA] || Not[DatabaseMemberQ[resolvedBufferA]],

			0 Millimolar,

			If[MatchQ[resolvedBufferA, ObjectP[Object[Sample]]],

				Convert[Download[resolvedBufferA, Concentration, Date -> Now], Millimolar],

				calculateICBufferConcentration[resolvedBufferA]
			]
		];

		(* 25. BufferB resolution *)

		(* Actual resolution of BufferB here *)
		(* If user specified BufferB, that is specifiedBufferB is not Automatic or Null, go with user specification *)
		resolvedBufferB = If[!MatchQ[specifiedBufferB, (Automatic)],
			specifiedBufferB,

			(* If any Gradient object is specified and the specified Gradient method has BufferA already, then use that as the bufferA for this protocol *)
			If[MatchQ[bufferBInFirstGradient, ObjectP[Model[Sample]]],
				bufferBInFirstGradient,

				If[MemberQ[resolvedChannelSelection, CationChannel],

					(* Use MSA solution as BufferA for cation channel *)
					Model[Sample, "Milli-Q water"],

					If[MemberQ[Join[ToList@resolvedAnalysisChannel, ToList@resolvedStandardAnalysisChannel, ToList@resolvedBlankAnalysisChannel], ElectrochemicalChannel],
						(* Use 100 mM NaOH as buffer for electrochemical channel *)
						Model[Sample, StockSolution, "Sodium Hydroxide Solution, 0.1M in Water, LCMS Grade"],
						Null
					]
				]
			]
		];

		(* We need to get the concentratino of bufferB *)
		bufferBConcentration = If[NullQ[resolvedBufferB] || Not[DatabaseMemberQ[resolvedBufferB]],

			0 Millimolar,

			If[MatchQ[resolvedBufferB, ObjectP[Object[Sample]]],

				Convert[Download[resolvedBufferB, Concentration, Date -> Now], Millimolar],

				calculateICBufferConcentration[resolvedBufferB]
			]
		];

		(* 26. BufferC resolution *)

		(* Actual resolution of BufferB here *)
		(* If user specified BufferB, that is specifiedBufferB is not Automatic or Null, go with user specification *)
		resolvedBufferC = If[!MatchQ[specifiedBufferC, Automatic],
			specifiedBufferC,

			(* If any Gradient object is specified and the specified Gradient method has BufferC already, then use that as the bufferA for this protocol *)
			If[MatchQ[bufferCInFirstGradient, ObjectP[Model[Sample]]],
				bufferCInFirstGradient,

				If[MemberQ[resolvedChannelSelection, CationChannel] || MemberQ[Join[ToList@resolvedAnalysisChannel, ToList@resolvedStandardAnalysisChannel, ToList@resolvedBlankAnalysisChannel], ElectrochemicalChannel],

					(* Use water as buffer C for cation and electrochemical applications  *)
					Model[Sample, "Milli-Q water"],
					(* Otherwise resolve to nothing *)
					Null
				]
			],

			(* If none of the above conditions are met, then resolve to Null *)
			Null
		];

		(* We need to get the concentratino of bufferC *)
		bufferCConcentration = If[NullQ[resolvedBufferC] || Not[DatabaseMemberQ[resolvedBufferC]],

			0 Millimolar,

			If[MatchQ[resolvedBufferC, ObjectP[Object[Sample]]],

				Convert[Download[resolvedBufferC, Concentration, Date -> Now], Millimolar],

				calculateICBufferConcentration[resolvedBufferC]
			]
		];

		(* 27. BufferD resolution *)

		(* Actual resolution of BufferB here *)
		(* If user specified BufferB, that is specifiedBufferB is not Automatic or Null, go with user specification *)
		resolvedBufferD = If[!MatchQ[specifiedBufferD, (Automatic)],
			specifiedBufferD,

			(* If any Gradient object is specified and the specified Gradient method has BufferC already, then use that as the bufferA for this protocol *)
			If[MatchQ[bufferDInFirstGradient, ObjectP[Model[Sample]]],
				bufferDInFirstGradient,

				If[MemberQ[resolvedChannelSelection, CationChannel] || MemberQ[Join[ToList@resolvedAnalysisChannel, ToList@resolvedStandardAnalysisChannel, ToList@resolvedBlankAnalysisChannel], ElectrochemicalChannel],

					(* Use water as buffer D for cation and electrochemical applications  *)
					Model[Sample, "Milli-Q water"],
					(* Otherwise resolve to nothing *)
					Null
				]
			],

			(* If none of the above conditions are met, then resolve to Null *)
			Null
		];

		(* We need to get the concentratino of bufferD *)
		bufferDConcentration = If[NullQ[resolvedBufferD] || Not[DatabaseMemberQ[resolvedBufferD]],

			0 Millimolar,

			If[MatchQ[resolvedBufferD, ObjectP[Object[Sample]]],

				Convert[Download[resolvedBufferD, Concentration, Date -> Now], Millimolar],

				calculateICBufferConcentration[resolvedBufferD]
			]
		];


		(* 26. GradientA, GradientB, CationGradient, CationGradientStart, CationGradientEnd, CationGradientDuration, CationEquilibrationTime, CationFlushTime and CationFlowRate resolution! *)

		(* Pull out the MinFlowRate and MaxFlowRate values of the resolved cation column *)
		{minColumnFlowRate, maxColumnFlowRate} = Which[
			!NullQ[resolvedCationColumn],
			Lookup[resolvedCationColumnModelPacket, {MinFlowRate, MaxFlowRate}],

			!NullQ[resolvedColumn],
			Lookup[resolvedColumnModelPacket, {MinFlowRate, MaxFlowRate}],

			True,
			{Null, Null}
		];

		(* Pull out the MinFlowRate and MaxFlowRate values from the suppressor and the eluent generator *)
		{minCationSuppressorFlowRate, maxCationSuppressorFlowRate} = If[NullQ[Lookup[resolvedInstrumentModelPacket, CationSuppressor, Null]],
			{Null, Null},
			Lookup[
				fetchPacketFromCache[Lookup[resolvedInstrumentModelPacket, CationSuppressor], fullCache],
				{MinFlowRate, MaxFlowRate}
			]
		];

		(* Use the minimum MinFlowRate and MaxFlowRate from instrument, column, and suppressor *)
		minFlowRate = If[NullQ[{minColumnFlowRate, minInstrumentFlowRate, minCationSuppressorFlowRate}],
			Null,
			Min[{minColumnFlowRate, minInstrumentFlowRate, minCationSuppressorFlowRate} /. Null -> Nothing]
		];
		maxFlowRate = If[NullQ[{maxColumnFlowRate, maxInstrumentFlowRate, maxCationSuppressorFlowRate}],
			Null,
			Min[{maxColumnFlowRate, maxInstrumentFlowRate, maxCationSuppressorFlowRate} /. Null -> Nothing]
		];

		(* Pick the optimal flow rate for this column *)
		(* Resolution logic: If the minimum flowrate is greater than 0.16 mL/Minute, then go with the minimum flowrate. Otherwise, go with the smaller value between 0.16 mL/Minute and maximum flow rate *)
		optimalColumnFlowRate = If[!NullQ[{minFlowRate, maxFlowRate}],
			If[MemberQ[resolvedChannelSelection, CationChannel],
				If[minFlowRate > 0.16 Milliliter / Minute,
					minFlowRate,
					Min[0.16 Milliliter / Minute, maxFlowRate]
				],
				If[minFlowRate > 1 Milliliter / Minute,
					minFlowRate,
					Min[1 Milliliter / Minute, maxFlowRate]
				]
			],
			Null
		];

		(* Compile a list of cation gradient related options to pass into the MapThread below for resolving gradient *)
		cationSampleGradientOptions = {
			CationGradientA,
			CationGradientB,
			CationGradientC,
			CationGradientD,
			CationGradientStart,
			CationGradientEnd,
			CationGradientDuration,
			CationGradient,
			CationEquilibrationTime,
			CationFlushTime,
			CationFlowRate
		};

		(* Compile a list of electrochemical gradient related options to pass into the MapThread below for resolving gradient *)
		electrochemicalSampleGradientOptions = {
			GradientA,
			GradientB,
			GradientC,
			GradientD,
			GradientStart,
			GradientEnd,
			GradientDuration,
			Gradient,
			EquilibrationTime,
			FlushTime,
			FlowRate
		};
		(* Resolution of gradient related options *)
		{
			{
				resolvedCationGradient,
				resolvedCationGradientStart,
				resolvedCationGradientEnd,
				resolvedCationGradientDuration,
				resolvedCationEquilibrationTime,
				resolvedCationFlushTime,
				resolvedCationFlowRate,
				resolvedCationGradientA,
				resolvedCationGradientB,
				resolvedCationGradientC,
				resolvedCationGradientD,
				cationGradientStartEndSpecifiedErrors,
				cationDurationOptionSpecifiedErrors,
				cationGradientConsistentErrors,
				invalidCationGradientCompositionErrors,
				cationRemovedExtraErrors,
				cationFlowRateErrors,
				cationDurationConsistentErrors,
				overwriteCationGradientBool
			},
			{
				resolvedGradient,
				resolvedGradientStart,
				resolvedGradientEnd,
				resolvedGradientDuration,
				resolvedEquilibrationTime,
				resolvedFlushTime,
				resolvedFlowRate,
				resolvedGradientA,
				resolvedGradientB,
				resolvedGradientC,
				resolvedGradientD,
				gradientStartEndSpecifiedErrors,
				durationOptionSpecifiedErrors,
				gradientConsistentErrors,
				invalidGradientCompositionErrors,
				removedExtraErrors,
				flowRateErrors,
				durationConsistentErrors,
				overwriteGradientBool
			}
		} = Module[{
			gradientALookup, gradientBLookup, gradientCLookup, gradientDLookup, gradientStartLookup, gradientEndLookup, gradientDurationLookup,
			sampleGradientLookup, equilibrationTimeLookup, flushTimeLookup, flowRateLookup, injectionTableSampleRoundedGradient,
			gradientStartEndSpecifiedQ, gradientConsistentQ, gradientStart, gradientEnd, removedExtrasQ, equilibrationTime,
			flushTime, protoGradientOptionTuple, gradientOptionTuple, defaultedFlowRate, gradientReturned, initiallyResolvedGradient,
			invalidGradientCompositionQ, gradientA, gradientB, gradientC, gradientD, flowRate, gradient, overwriteGradientQ, injectionTableWithID,
			incompatibleFlowRateQ, fullGradient, samples, mapThreadOptions, injectionTableLookup, gradientOptions, criteria,
			gradientColumnInInjectionTable, durationOptionsSpecifiedQ, gradientDuration, durationConsistentQ, individualGradientSpecifiedQ},

			Map[Function[{entryVariable},

				{samples, mapThreadOptions, gradientOptions, injectionTableLookup, criteria, gradientColumnInInjectionTable} = entryVariable;

				If[criteria || MatchQ[mapThreadOptions, Null],
					(* If there is no resolvedCationSamples or samples for ElectrochemicalChannel, then set all cation gradient related options to Null, and all error tracking variable to False *)
					Join[ConstantArray[Null, 11], ConstantArray[False, 8]],

					(* Otherwise, run this giant map thread to resolve all anion gradient related options *)
					Transpose[MapThread[Function[{mySample, myMapFriendlyOptions},

						(* Look up the values of each options in the list *)
						{
							gradientALookup,
							gradientBLookup,
							gradientCLookup,
							gradientDLookup,
							gradientStartLookup,
							gradientEndLookup,
							gradientDurationLookup,
							sampleGradientLookup,
							equilibrationTimeLookup,
							flushTimeLookup,
							flowRateLookup
						} = Lookup[myMapFriendlyOptions, gradientOptions];

						(* Setup: We first get the injection table gradients *)
						injectionTableSampleRoundedGradient = If[MatchQ[injectionTableLookup, Except[Automatic]] && !injectionTableSampleConflictQ,

							injectionTableWithID = Map[
								If[MatchQ[#[[2]], ObjectP[]],
									Join[ToList@#[[1]], ToList@Download[#[[2]], Object], #[[3 ;; Length[#]]]],
									#
								]&,
								injectionTableLookup
							];

							(* Extract the gradient specified in InjectionTable *)
							Which[
								gradientColumnInInjectionTable == 5,
								Cases[injectionTableWithID, {Sample, mySample | Download[mySample, Object], _, _, gradient_} :> gradient],

								gradientColumnInInjectionTable == 4,
								Cases[injectionTableWithID, {Sample, mySample | Download[mySample, Object], _, gradient_, ___} :> gradient],

								True,
								Automatic
							],

							(* If InjectionTable is not specified or has conflict with input samples, pad it with Automatics*)
							Automatic
						];

						(* First we need to make sure that the start end and duration options are either all specified or not *)
						gradientStartEndSpecifiedQ = !MatchQ[{gradientStartLookup, gradientEndLookup}, {PercentP, PercentP} | {Automatic | Null, Automatic | Null}];

						(* Then we need to make sure that the duration is specified either with start & end, or with eluent gradient *)
						durationOptionsSpecifiedQ = If[MatchQ[gradientDurationLookup, TimeP],
							Not[MatchQ[{gradientStartLookup, gradientEndLookup}, {PercentP, PercentP}] || MatchQ[gradientALookup, PercentP] || MatchQ[gradientBLookup, PercentP] || MatchQ[gradientCLookup, PercentP] || MatchQ[gradientDLookup, PercentP]],
							False
						];

						(* Need to check if any of the individual gradient is specified in {Time,Percent} format *)
						individualGradientSpecifiedQ = Or[
							MatchQ[gradientALookup, Except[Automatic | PercentP]],
							MatchQ[gradientBLookup, Except[Automatic | PercentP]],
							MatchQ[gradientCLookup, Except[Automatic | PercentP]],
							MatchQ[gradientDLookup, Except[Automatic | PercentP]]
						];

						(* We also need to check if Duration specification is consistent with individual gradient *)
						durationConsistentQ = If[individualGradientSpecifiedQ,

							If[MatchQ[gradientDurationLookup, TimeP],
								True,
								False
							],
							(* If none of the individual gradient is specified, then leave this error tracking variable to False *)
							False
						];

						(* If gradient is specied as a method object, check whether CationGradient and the injection table specify the same object*)
						gradientConsistentQ = If[MatchQ[sampleGradientLookup, ObjectP[{Object[Method, IonChromatographyGradient], Object[Method, Gradient]}]] && MatchQ[injectionTableSampleRoundedGradient, ObjectP[{Object[Method, IonChromatographyGradient], Object[Method, Gradient]}]],
							Not[MatchQ[Lookup[fetchPacketFromCache[sampleGradientLookup, fullCache], Object], Lookup[fetchPacketFromCache[injectionTableSampleRoundedGradient, fullCache], Object]]],
							False
						];

						(* Extract or default GradientStart and GradientEnd values *)
						{gradientStart, gradientEnd} = Switch[{gradientStartLookup, gradientEndLookup, gradientDurationLookup},

							(* If valid cationGradientStart and cationGradientEnd are given, go with that *)
							{PercentP, PercentP, _} | {Null, Null, Null | TimeP}, {gradientStartLookup, gradientEndLookup},

							(* Default to cationGradientStart if something is wrong with gradientEnd *)
							{PercentP, _, _}, {gradientStartLookup, gradientStartLookup},

							(* Default to 0 Percent if something is wrong with cationGradeintStart *)
							{_, PercentP, _}, {0 Percent, gradientEndLookup},

							(* Otherwise, both Null*)
							_, {Null, Null}
						];

						(* Resolve equilibration times from option value or gradient or injection table object *)
						equilibrationTime = Which[

							(* If user specified equilibration time, go with it *)
							MatchQ[equilibrationTimeLookup, Except[Automatic]], equilibrationTimeLookup,

							(* If CationGradient is specified as an object, extract EquilibrationTime information from the packet *)
							MatchQ[sampleGradientLookup, ObjectP[Object[Method, IonChromatographyGradient]]], Lookup[fetchPacketFromCache[sampleGradientLookup, fullCache], CationEquilibrationTime],

							(* If Gradient is specified as an object, extract EquilibrationTime information from the packet *)
							MatchQ[sampleGradientLookup, ObjectP[Object[Method, Gradient]]], Lookup[fetchPacketFromCache[sampleGradientLookup, fullCache], EquilibrationTime],

							(* If InjectionTable specifies a gradient for an anion channel sample, extract EquilibrationTime information from the packet *)
							MatchQ[injectionTableSampleRoundedGradient, ObjectP[Object[Method, IonChromatographyGradient]]], Lookup[fetchPacketFromCache[injectionTableSampleRoundedGradient, simluatedCache], CationEquilibrationTime],

							(* If InjectionTable specifies a gradient, extract EquilibrationTime information from the packet *)
							MatchQ[injectionTableSampleRoundedGradient, ObjectP[Object[Method, Gradient]]], Lookup[fetchPacketFromCache[injectionTableSampleRoundedGradient, simluatedCache], EquilibrationTime],

							(* Otherwise, set it to Null *)
							True, Null
						];

						(* Similarly, resolve flush times from option value or gradient object *)
						flushTime = Which[

							(* If user specified flush time, go with it *)
							MatchQ[flushTimeLookup, Except[Automatic]], flushTimeLookup,

							(* If CationGradient is specified as an object, extract FlushTime information from the packet *)
							MatchQ[sampleGradientLookup, ObjectP[Object[Method, IonChromatographyGradient]]], Lookup[fetchPacketFromCache[sampleGradientLookup, fullCache], CationFlushTime],

							(* If CationGradient is specified as an object, extract FlushTime information from the packet *)
							MatchQ[sampleGradientLookup, ObjectP[Object[Method, Gradient]]], Lookup[fetchPacketFromCache[sampleGradientLookup, fullCache], FlushTime],

							(* If InjectionTable specifies a gradient for a anion channel sample, extract Flush information from the packet *)
							MatchQ[injectionTableSampleRoundedGradient, ObjectP[Object[Method, IonChromatographyGradient]]], Lookup[fetchPacketFromCache[injectionTableSampleRoundedGradient, fullCache], CationFlushTime],

							(* If InjectionTable specifies a gradient for a anion channel sample, extract Flush information from the packet *)
							MatchQ[injectionTableSampleRoundedGradient, ObjectP[Object[Method, Gradient]]], Lookup[fetchPacketFromCache[injectionTableSampleRoundedGradient, fullCache], FlushTime],

							(* Otherwise, set it to Null *)
							True, Null
						];

						(* If Gradient option is an object, pull Gradient value from packet *)
						protoGradientOptionTuple = Which[

							(* If CationGradient specifies a method object, extract Gradient information from the packet *)
							MatchQ[sampleGradientLookup, ObjectP[Object[Method, IonChromatographyGradient]]],
							Lookup[fetchPacketFromCache[Download[sampleGradientLookup, Object], fullCache], CationGradient],

							(* If CationGradient specifies a method object, extract Gradient information from the packet *)
							MatchQ[sampleGradientLookup, ObjectP[Object[Method, Gradient]]],
							Lookup[fetchPacketFromCache[Download[sampleGradientLookup, Object], fullCache], Gradient],

							(* If InjectionTable specifies a method object, extract Gradient information from the packet *)
							MatchQ[sampleGradientLookup, Automatic] && MatchQ[injectionTableSampleRoundedGradient, ObjectP[Object[Method, IonChromatographyGradient]]],
							Lookup[fetchPacketFromCache[Download[injectionTableSampleRoundedGradient, Object], fullCache], CationGradient],

							(* If InjectionTable specifies a method object, extract Gradient information from the packet *)
							MatchQ[sampleGradientLookup, Automatic] && MatchQ[injectionTableSampleRoundedGradient, ObjectP[Object[Method, Gradient]]],
							Lookup[fetchPacketFromCache[Download[injectionTableSampleRoundedGradient, Object], fullCache], Gradient],

							(* Otherwise, namely if anionGradient is not a method object, then use what's specified in AnionGradient *)
							True, sampleGradientLookup
						];

						(* Update CationFlowRate in the gradient method object if the option is specified *)
						gradientOptionTuple = If[MatchQ[flowRateLookup, Except[Automatic]],

							(* If CationFlowRate is specified, use the specified flow rate and replace the default flowrate of the method object *)
							(* In IonChromatography Gradient method, CationGradient goes "Time", "BufferA Composition", "BufferB Composition", "BufferC Composition", "BufferD Composition", "FlowRate". FlowRate is in the third column *)
							ReplacePart[protoGradientOptionTuple, Table[{x, 6} -> flowRateLookup, {x, 1, Length[protoGradientOptionTuple]}]],

							(* Otherwise, use the default flow rate in the gradient object *)
							protoGradientOptionTuple
						];

						(* Default FlowRate to option value, gradient tuple values, or the pre-calculated optimal flow rate for the column *)
						(* note that it's ok to have this flow rate either match FlowRateP, or be a list of pairs of time and flow rate since resolveGradient can handle either *)
						defaultedFlowRate = Which[

							(* If the AnionFlowRate is specified, go with the user specified value *)
							MatchQ[flowRateLookup, Except[Automatic]], flowRateLookup,

							(* If the AnionFlowRate is specified as part of the gradient method object, extract the flow rate from the object *)
							MatchQ[gradientOptionTuple, {TimeP, PercentP, PercentP, PercentP, PercentP, FlowRateP}], gradientOptionTuple[[All, {1, 6}]],

							(* If no flow rate is specified, use the optional flow rate determined for the column *)
							True, optimalColumnFlowRate
						];

						(* Track whether CationFlowRate is compatible with the instrument, and the column *)
						incompatibleFlowRateQ = Not[Between[defaultedFlowRate, {minFlowRate, maxFlowRate}]];

						(* finally run our helper resolution function *)
						gradientReturned = If[MatchQ[{gradientOptionTuple, gradientALookup, gradientBLookup, gradientCLookup, gradientDLookup, gradientStart, gradientEnd, gradientDurationLookup, flowRateLookup}, {(Null | Automatic)..}] || gradientStartEndSpecifiedQ || durationOptionsSpecifiedQ,
							resolveICCationGradient[defaultGradientIC[resolvedChannelSelection, defaultedFlowRate], gradientALookup, gradientBLookup, gradientCLookup, gradientDLookup, defaultedFlowRate, gradientStartLookup, gradientEndLookup, gradientDurationLookup],
							resolveICCationGradient[gradientOptionTuple, gradientALookup, gradientBLookup, gradientCLookup, gradientDLookup, defaultedFlowRate, gradientStartLookup, gradientEndLookup, gradientDurationLookup]
						];

						(*remove duplicate entries if need be*)
						initiallyResolvedGradient = DeleteDuplicatesBy[gradientReturned, First[# * 1.] &];

						(*if it's not the same note that*)
						removedExtrasQ = !MatchQ[gradientReturned, initiallyResolvedGradient];

						(* Add equilibration time and flush time *)
						fullGradient = Module[{gradientStartPoint, gradientEndPoint},
							(* Add equilibration time in minute onto the resolved gradient *)
							(* If equilibration time is Null, then do nothing  here *)
							If[NullQ[equilibrationTime],
								gradientStartPoint = Nothing,
								gradientStartPoint = First[initiallyResolvedGradient];
								initiallyResolvedGradient[[All, 1]] = initiallyResolvedGradient[[All, 1]] + equilibrationTime
							];

							(* Add flush time in minute onto the resolved gradient *)
							(* If flush time is Null, then do nothing  here *)
							If[NullQ[flushTime],
								gradientEndPoint = Nothing,
								gradientEndPoint = Last[initiallyResolvedGradient];
								gradientEndPoint[[1]] = gradientEndPoint[[1]] + flushTime
							];
							Join[{gradientStartPoint}, initiallyResolvedGradient, {gradientEndPoint}]
						];

						(*check whether the gradient composition adds up to 100 okay*)
						invalidGradientCompositionQ = Not[AllTrue[fullGradient, (#[[2]] + #[[3]] + #[[4]] + #[[5]] == 100 Percent)&]];

						(*now resolve all of the individual gradients and flow rate*)
						gradientA = If[MatchQ[gradientALookup, Automatic],
							collapseGradient[fullGradient[[All, {1, 2}]]],
							gradientALookup
						];

						gradientB = If[MatchQ[gradientBLookup, Automatic],
							collapseGradient[fullGradient[[All, {1, 3}]]],
							gradientBLookup
						];

						gradientC = If[MatchQ[gradientCLookup, Automatic],
							collapseGradient[fullGradient[[All, {1, 4}]]],
							gradientCLookup
						];

						gradientD = If[MatchQ[gradientDLookup, Automatic],
							collapseGradient[fullGradient[[All, {1, 5}]]],
							gradientDLookup
						];

						flowRate = If[MatchQ[flowRateLookup, Automatic],
							collapseGradient[fullGradient[[All, {1, -1}]]],
							flowRateLookup
						];

						overwriteGradientQ = Which[
							MatchQ[sampleGradientLookup, ObjectP[Object[Method, IonChromatographyGradient]]],
							!MatchQ[Lookup[fetchPacketFromCache[Download[sampleGradientLookup, Object], fullCache], CationGradient], fullGradient],

							MatchQ[sampleGradientLookup, ObjectP[Object[Method, Gradient]]],
							!MatchQ[Lookup[fetchPacketFromCache[Download[sampleGradientLookup, Object], fullCache], Gradient], fullGradient],

							True,
							False
						];

						(*finally resolve the gradient*)
						gradient = Which[

							MatchQ[sampleGradientLookup, ObjectP[Object[Method, IonChromatographyGradient]]] && !overwriteGradientQ, sampleGradientLookup,
							MatchQ[sampleGradientLookup, ObjectP[Object[Method, Gradient]]] && !overwriteGradientQ, sampleGradientLookup,

							(*otherwise if the gradient is automatic and the injection table is set, should use that*)
							MatchQ[sampleGradientLookup, Automatic] && MatchQ[injectionTableSampleRoundedGradient, ObjectP[Object[Method, IonChromatographyGradient]]],
							Lookup[fetchPacketFromCache[injectionTableSampleRoundedGradient, fullCache], Object],

							MatchQ[sampleGradientLookup, Automatic] && MatchQ[injectionTableSampleRoundedGradient, ObjectP[Object[Method, Gradient]]],
							Lookup[fetchPacketFromCache[injectionTableSampleRoundedGradient, fullCache], Object],

							(*otherwise, it should be a tuple*)
							True, fullGradient
						];

						(*return everything*)
						{
							gradient,
							gradientStart,
							gradientEnd,
							gradientDurationLookup,
							equilibrationTime,
							flushTime,
							flowRate,
							gradientA,
							gradientB,
							gradientC,
							gradientD,
							gradientStartEndSpecifiedQ,
							durationOptionsSpecifiedQ,
							gradientConsistentQ,
							invalidGradientCompositionQ,
							removedExtrasQ,
							incompatibleFlowRateQ,
							durationConsistentQ,
							overwriteGradientQ
						}],
						{samples, mapThreadOptions}
					]]
				]],
				{
					{ToList@resolvedCationSamples, mapThreadFriendlyCationSampleOptions, cationSampleGradientOptions, cationInjectionTableLookupRounded, MatchQ[resolvedCationSamples, {} | {Null} | Null], 5},
					{ToList@mySamples, mapThreadFriendlyElectrochemicalSampleOptions, electrochemicalSampleGradientOptions, electrochemicalInjectionTableLookupRounded, !MemberQ[resolvedAnalysisChannel, ElectrochemicalChannel], 4}
				}
			]
		];

		(* == Error Checking == *)
		(*
        (* 26.1 If CationSamples are specified or resolved, some gradient options must be specified *)
        missingGradientCationSamples=If[MatchQ[resolvedCationSamples,{}|Null|{Null}],
            {},
            PickList[ToList@resolvedCationSamples,cationGradientMissingErrors,True]
        ];

        (* If there are any missing anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
        missingCationGradientOptions=If[Length[missingGradientCationSamples]>0&&messagesQ,
            (
                Message[Error::MissingCationGradientOptions,CationSamples,ObjectToString[missingGradientCationSamples,Cache -> fullCache, Simulation -> updatedSimulation]];
                {GradientA,CationFlowRate,CationGradient}
            ),
            {}
        ];

        (* Generate test for missing anion gradient options *)
        missingCationGradientTests=testOrNullIndexMatched["If CationSamples are specified or resolved, cation gradient options are either specified in the option or the InjectionTable:",resolvedCationSamples,cationGradientMissingErrors]; *)

		(* 21.2 If any of the following gradient start, end and duration options are specified, all three options need to be specified *)
		notSpecifiedCationGradientStartEnd = If[MatchQ[resolvedCationSamples, {} | Null | {Null}],
			{},
			PickList[ToList@resolvedCationSamples, cationGradientStartEndSpecifiedErrors, True]
		];

		(* If there are any missing anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
		notSpecifiedCationGradientStartEndOptions = If[Length[notSpecifiedCationGradientStartEnd] > 0 && messagesQ,
			(
				Message[Error::HPICGradientStartEndConflict, {CationGradientStart, CationGradientEnd}, ObjectToString[notSpecifiedCationGradientStartEnd,Cache -> fullCache, Simulation -> updatedSimulation]];
				{CationGradientStart, CationGradientEnd, CationGradientDuration}
			),
			{}
		];

		(* Generate test for missing specification among anion gradient start, end and duration *)
		notSpecifiedCationGradientStartEndTests = testOrNullIndexMatched["CationGradientStart, CationGradientEnd, and CationGradientDuration should be specified or set to Null simultaneously:", resolvedCationSamples, cationGradientStartEndSpecifiedErrors];

		(* 21.3 If AnionGradient is specified simultaenously in the option and the InjectionTable as method object, they should be consistent with each other *)
		inconsistentGradientCationSamples = If[MatchQ[resolvedCationSamples, Null | {} | {Null}],
			{},
			PickList[ToList@resolvedCationSamples, cationGradientConsistentErrors, True]
		];

		(* If there are any missing anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
		inconsistentCationGradientOptions = If[Length[inconsistentGradientCationSamples] > 0 && messagesQ,
			(
				Message[Error::InconsistentGradientSpecification, CationGraient, ObjectToString[inconsistentGradientCationSamples,Cache -> fullCache, Simulation -> updatedSimulation]];
				{CationGradient, CationInjectionTable}
			),
			{}
		];

		(* Generate test for missing specification among anion gradient start, end and duration *)
		inconsistentCationGradientTests = testOrNullIndexMatched["If specified, gradient methods in the CationGradient option and the CationInjectionTable must be consistent:", resolvedCationSamples, cationGradientConsistentErrors];

		(* 21.4 If either EluentGradient or AnionGradient is specified, the maximum concentration is within the range defined by the integrated eluent generator *)
		invalidGradientCompositionCationSamples = If[MatchQ[resolvedCationSamples, {} | Null | {Null}],
			{},
			PickList[ToList@resolvedCationSamples, invalidCationGradientCompositionErrors, True]
		];

		(* If there are any invalid anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
		invalidCationGradientCompositionOptions = If[Length[invalidGradientCompositionCationSamples] > 0 && messagesQ,
			(
				Message[Error::InvalidGradientComposition, ObjectToString[invalidGradientCompositionCationSamples,Cache -> fullCache, Simulation -> updatedSimulation]];
				{CationGradientA, CationGradientB, CationGradientC, CationGradientD, CationGradient}
			),
			{}
		];

		(* Generate test for invalid anion gradient composition *)
		invalidCationGradientTests = testOrNullIndexMatched["The specified CationGradient has a total buffer composition of 100% at all times:", resolvedCationSamples, invalidCationGradientCompositionErrors];

		(* 21.5 CationFlowRate has to be within the range supported by the instrument, and the column *)

		(* If there are any invalid anion flow rates and we are throwing messages, then throw an error message and collect invalid options *)
		incompatibleCationFlowRateOptions = If[MemberQ[cationFlowRateErrors, True] && messagesQ,
			(
				Message[Error::FlowRateAboveMax, CationFlowRate, PickList[resolvedCationFlowRate, cationFlowRateErrors, True], resolvedInstrument, resolvedCationColumn, maxFlowRate];
				{CationFlowRate}
			),
			{}
		];

		(* Generate test for invalid anion gradient composition *)
		invalidCationFlowRateTests = testOrNullIndexMatched["The specified CationFlowRate has maximum flow rate less than that supported by the instrument and the column:", resolvedCationSamples, cationFlowRateErrors];

		(* 21.6 If gradient duration is specified, either gradient start & end or eluent gradient is specified *)
		notSpecifiedCationGradientDuration = If[MatchQ[resolvedCationSamples, {} | Null | {Null}],
			{},
			PickList[ToList@resolvedCationSamples, cationDurationOptionSpecifiedErrors, True]
		];

		(* If there are any missing anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
		notSpecifiedCationGradientDurationOptions = If[Length[notSpecifiedCationGradientDuration] > 0 && messagesQ,
			(
				Message[Error::HPICGradientShortcutConflict, CationGradientDuration, {CationGradientStart, CationGradientEnd}, "CationGradientA/B/C/D"];
				{CationGradientStart, CationGradientEnd, CationGradientDuration, CationGradientA, CationGradientB, CationGradientC, CationGradientD}
			),
			{}
		];

		(* Generate test for missing specification among anion gradient start, end and duration *)
		notSpecifiedCationGradientDurationTests = testOrNullIndexMatched["CationGradientDuration should be specified either with CationGradientStart/CationGradientEnd or any of the CationGradientA/B/C/D:", resolvedCationSamples, cationDurationOptionSpecifiedErrors];

		(* 21.7 If gradient duration and eluent gradient are both specified, their specified values are consistent *)
		inconsistentCationGradientDuration = If[MatchQ[resolvedCationSamples, {} | Null | {Null}],
			{},
			PickList[ToList@resolvedCationSamples, cationDurationConsistentErrors, True]
		];

		(* If there are any missing anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
		inconsistentCationGradientDurationOptions = If[Length[inconsistentCationGradientDuration] > 0 && messagesQ && notInEngine,
			(
				Message[Warning::HPICGradientShortcutAmbiguity, CationGradientDuration, "CationGradientA/B/C/D"];
				{}
			),
			{}
		];

		(* Generate test for missing specification among anion gradient start, end and duration *)
		consistentCationGradientDurationTests = warningOrNullIndexMatched["Specified values for CationGradientDuration and CationGradientA/B/C/D are consistent:", resolvedCationSamples, cationDurationConsistentErrors];

		(* 21.8 If any of the following gradient start, end and duration options are specified, all three options need to be specified *)
		notSpecifiedGradientStartEnd = If[!MemberQ[resolvedAnalysisChannel, ElectrochemicalChannel],
			{},
			PickList[ToList@mySamples, gradientStartEndSpecifiedErrors, True]
		];

		(* If there are any missing anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
		notSpecifiedGradientStartEndOptions = If[Length[notSpecifiedGradientStartEnd] > 0 && messagesQ,
			(
				Message[Error::HPICGradientStartEndConflict, {GradientStart, GradientEnd}, ObjectToString[notSpecifiedGradientStartEnd,Cache -> fullCache, Simulation -> updatedSimulation]];
				{GradientStart, GradientEnd, GradientDuration}
			),
			{}
		];

		(* Generate test for missing specification among anion gradient start, end and duration *)
		notSpecifiedGradientStartEndTests = testOrNullIndexMatched["GradientStart, GradientEnd, and GradientDuration should be specified or set to Null simultaneously:", mySamples, gradientStartEndSpecifiedErrors];

		(* 21.9 If Gradient is specified simultaenously in the option and the InjectionTable as method object, they should be consistent with each other *)
		inconsistentGradientSamples = If[!MemberQ[resolvedAnalysisChannel, ElectrochemicalChannel],
			{},
			PickList[ToList@mySamples, gradientConsistentErrors, True]
		];

		(* If there are any missing anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
		inconsistentGradientOptions = If[Length[inconsistentGradientSamples] > 0 && messagesQ,
			(
				Message[Error::InconsistentGradientSpecification, Graient, ObjectToString[inconsistentGradientSamples,Cache -> fullCache, Simulation -> updatedSimulation]];
				{Gradient, ElectrochemicalInjectionTable}
			),
			{}
		];

		(* Generate test for missing specification among anion gradient start, end and duration *)
		inconsistentGradientTests = testOrNullIndexMatched["If specified, gradient methods in the Gradient option and the ElectrochemicalInjectionTable must be consistent:", mySamples, gradientConsistentErrors];

		(* 21.10 If either GradientA or Gradient is specified, the maximum concentration is within the range defined by the integrated eluent generator *)
		invalidGradientCompositionSamples = If[!MemberQ[ToList@resolvedAnalysisChannel, ElectrochemicalChannel],
			{},
			PickList[ToList@mySamples, invalidGradientCompositionErrors, True]
		];

		(* If there are any invalid anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
		invalidGradientCompositionOptions = If[Length[invalidGradientCompositionSamples] > 0 && messagesQ,
			(
				Message[Error::InvalidGradientComposition, ObjectToString[invalidGradientCompositionSamples,Cache -> fullCache, Simulation -> updatedSimulation]];
				{GradientA, GradientB, GradientC, GradientD, Gradient}
			),
			{}
		];

		(* Generate test for invalid anion gradient composition *)
		invalidGradientTests = If[Length[invalidGradientCompositionSamples] > 0,
			testOrNullIndexMatched["The specified Gradient has a total buffer composition of 100% at all times:", mySamples, invalidGradientCompositionSamples],
			{}
		];

		(* 21.11 FlowRate has to be within the range supported by the instrument, and the column *)

		(* If there are any invalid anion flow rates and we are throwing messages, then throw an error message and collect invalid options *)
		incompatibleFlowRateOptions = If[MemberQ[flowRateErrors, True] && messagesQ,
			(
				Message[Error::FlowRateAboveMax, FlowRate, PickList[resolvedFlowRate, flowRateErrors, True], resolvedInstrument, resolvedColumn, maxFlowRate];
				{FlowRate}
			),
			{}
		];

		(* Generate test for invalid anion gradient composition *)
		invalidFlowRateTests = testOrNullIndexMatched["The specified FlowRate has maximum flow rate less than that supported by the instrument and the column:", mySamples, flowRateErrors];

		(* 21.12 If gradient duration is specified, either gradient start & end or eluent gradient is specified *)
		notSpecifiedGradientDuration = If[!MemberQ[ToList@resolvedAnalysisChannel, ElectrochemicalChannel],
			{},
			PickList[ToList@mySamples, durationOptionSpecifiedErrors, True]
		];

		(* If there are any missing anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
		notSpecifiedGradientDurationOptions = If[Length[notSpecifiedGradientDuration] > 0 && messagesQ,
			(
				Message[Error::HPICGradientShortcutConflict, GradientDuration, {GradientStart, GradientEnd}, "GradientA/B/C/D"];
				{GradientStart, GradientEnd, GradientDuration, GradientA, GradientB, GradientC, GradientD}
			),
			{}
		];

		(* Generate test for missing specification among anion gradient start, end and duration *)
		notSpecifiedGradientDurationTests = testOrNullIndexMatched["GradientDuration should be specified either with GradientStart/GradientEnd or any of the GradientA/B/C/D:", mySamples, durationOptionSpecifiedErrors];

		(* 21.13 If gradient duration and eluent gradient are both specified, their specified values are consistent *)
		inconsistentGradientDuration = If[!MemberQ[ToList@resolvedAnalysisChannel, ElectrochemicalChannel],
			{},
			PickList[ToList@mySamples, durationConsistentErrors, True]
		];

		(* If there are any missing anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
		inconsistentGradientDurationOptions = If[Length[inconsistentGradientDuration] > 0 && messagesQ && notInEngine,
			(
				Message[Warning::HPICGradientShortcutAmbiguity, GradientDuration, "GradientA/B/C/D"];
				{}
			),
			{}
		];

		(* Generate test for missing specification among anion gradient start, end and duration *)
		consistentGradientDurationTests = warningOrNullIndexMatched["Specified values for GradientDuration and GradientA/B/C/D are consistent:", mySamples, durationConsistentErrors];

		(* 27. CationColumnTemperature resolution *)
		resolvedCationColumnTemperature = Module[{injectionTableWithID, gradientInInjectionTable},

			(* First check whether there are any resolved cation sample; if there is none, set resolvedCationColumnTemperature to Null and all error tracking variable to False *)
			If[MatchQ[resolvedCationColumn, {} | Null | {Null}] || MatchQ[mapThreadFriendlyCationSampleOptions, Null | {}],
				Null,

				MapThread[Function[{mySample, cationGradient, myMapThreadOptions},

					injectionTableWithID = Map[
						If[MatchQ[#[[2]], ObjectP[]],
							Join[ToList@#[[1]], ToList@Download[#[[2]], Object], #[[3 ;; Length[#]]]],
							#
						]&,
						cationInjectionTableLookupRounded
					];

					(* If InjectionTable is not the default value of automatic, then look up the gradient object specified for mySample *)
					gradientInInjectionTable = If[!MatchQ[injectionTableWithID, ListableP[Automatic]],
						Cases[injectionTableWithID, {Sample, Download[mySample, Object], _, _, gradientObj : ObjectP[Object[Method, IonChromatographyGradient]]} :> gradientObj],
						Null
					];

					(* Download the gradient object from fullCache and extract column temperature information *)
					Which[

						(* If user has already specified cation column temperature, go with that *)
						!MatchQ[Lookup[myMapThreadOptions, CationColumnTemperature], Automatic | Null],
						Lookup[myMapThreadOptions, CationColumnTemperature],

						(* If the specified AnionGradient is a method object, extract column temperature from there *)
						MatchQ[cationGradient, ObjectP[Object[Method, IonChromatographyGradient]]],
						If[NullQ[Lookup[fetchPacketFromCache[cationGradient, fullCache], CationColumnTemperature]],
							Ambient,
							Lookup[fetchPacketFromCache[cationGradient, fullCache], CationColumnTemperature]
						],

						(* If the specified gradient in the InjectionTable is an Object, extract column temperature from there *)
						MatchQ[gradientInInjectionTable, ObjectP[Object[Method, IonChromatographyGradient]]],
						Lookup[fetchPacketFromCache[gradientInInjectionTable, fullCache], CationColumnTemperature],

						(* Otherwise, use Ambient temperature *)
						True,
						Ambient
					]
				],
					{ToList@resolvedCationSamples, resolvedCationGradient /. Null -> {}, mapThreadFriendlyCationSampleOptions}
				]]];

		(* == Error Checking == *)
		(* Identify resolved cation samples that have incompatible column temperature and also compiled a list of incompatible temperatures *)
		(*incompatibleColumnTemperatureCationSamples=If[MatchQ[resolvedCationSamples,Null|{}|{Null}],
            {},
            PickList[ToList@resolvedCationSamples,incompatibleCationColumnTemperatureErrors,True]
        ];
        incompatibleCationColumnTemperature=If[MatchQ[resolvedCationSamples,Null|{}|{Null}],
            {},
            PickList[resolvedCationColumnTemperature,incompatibleCationColumnTemperatureErrors,True]
        ];

        (* If there are any incompatible column temperatures and we are throwing messages, throw an error and collect in valid option *)
        incompatibleCationColumnTemperatureOptions=If[Length[incompatibleCationColumnTemperature]>0&&messagesQ,
            (
                Message[Error::IncompatibleColumnTemperature,CationColumn,incompatibleCationColumnTemperature,CationSamples,ObjectToString[incompatibleColumnTemperatureCationSamples,Cache -> fullCache, Simulation -> updatedSimulation],allowedCationColumnTemperatureRange[[1]],allowedCationColumnTemperatureRange[[2]]];
                {CationColumnTemperature}
            ),
            {}
        ];

        (* Generate tests for incompatible anion column temperature *)
        incompatibleCationColumnTemperatureTests=testOrNullIndexMatched["Specified CationColumnTemperature is within the range of supported temperature of the CationColumn:",resolvedCationSamples,incompatibleCationColumnTemperatureErrors]; *)

		(* 28. ColumnTemperature resolution *)
		resolvedColumnTemperature = Module[{gradientInInjectionTable},

			(* First check whether there are any resolved cation sample; if there is none, set resolvedColumnTemperature to Null and all error tracking variable to False *)
			If[MatchQ[resolvedColumn, {} | Null | {Null}] || MatchQ[mapThreadFriendlyElectrochemicalSampleOptions, Null | {}],
				Null,

				MapThread[Function[{mySample, gradient, myMapThreadOptions},

					(* If InjectionTable is not the default value of automatic, then look up the gradient object specified for mySample *)
					gradientInInjectionTable = If[!MatchQ[electrochemicalInjectionTableLookup, ListableP[Automatic]],
						Cases[electrochemicalInjectionTableLookup, {Sample, Download[mySample, Object], _, _, gradientObj : ObjectP[Object[Method, Gradient]]} :> gradientObj],
						Null
					];

					(* Download the gradient object from fullCache and extract column temperature information *)
					Which[

						(* If user has already specified cation column temperature, go with that *)
						!MatchQ[Lookup[myMapThreadOptions, ColumnTemperature], Automatic | Null],
						Lookup[myMapThreadOptions, ColumnTemperature],

						(* If the specified AnionGradient is a method object, extract column temperature from there *)
						MatchQ[gradient, ObjectP[Object[Method, Gradient]]],
						If[NullQ[Lookup[fetchPacketFromCache[gradient, fullCache], Temperature]],
							Ambient,
							Lookup[fetchPacketFromCache[gradient, fullCache], Temperature]
						],

						(* If the specified gradient in the InjectionTable is an Object, extract column temperature from there *)
						MatchQ[gradientInInjectionTable, ObjectP[Object[Method, Gradient]]],
						Lookup[fetchPacketFromCache[gradientInInjectionTable, fullCache], Temperature] /. {Null :> Ambient},

						(* Otherwise, use Ambient temperature *)
						True,
						Ambient
					]
				],
					{ToList@mySamples, resolvedGradient /. Null -> {}, mapThreadFriendlyElectrochemicalSampleOptions}
				]]];

		(* 29. NeedleWashSolution resolution *)
		resolvedNeedleWashSolution = specifiedNeedleWashSolution;

		(* 30. AnionSuppressorCurrent and AnionDetectionTemperature resolution *)

		(* Find the maximum allowed anion current from the instrument model packet *)
		{anionSuppressorRecommendedVoltage, maxAnionSuppressorVoltage, maxAnionSuppressorCurrent, anionSuppressorSpecificFactor} = If[
			MatchQ[Lookup[resolvedInstrumentModelPacket, AnionSuppressor, {}], {} | Null | {Null}],
			{0 Volt, Infinity Volt, -Infinity Milliampere, 0},
			Lookup[fetchPacketFromCache[Lookup[resolvedInstrumentModelPacket, AnionSuppressor, {}], fullCache], {FactoryRecommendedVoltage, MaxVoltage, MaxCurrent, SuppressorSpecificFactor}]
		];

		(* Find the allowed range of detection temperature from the instrument model packet *)
		minAnionDetectionTemperature = Lookup[resolvedInstrumentModelPacket, AnionMinDetectionTemperature] /. Null -> -Infinity Celsius;
		maxAnionDetectionTemperature = Lookup[resolvedInstrumentModelPacket, AnionMaxDetectionTemperature] /. Null -> Infinity Celsius;

		{
			resolvedAnionSuppressorMode,
			resolvedAnionSuppressorVoltage,
			resolvedAnionSuppressorCurrent,
			resolvedAnionDetectionTemperature,
			conflictingAnionSuppressorModeErrors
		} = Module[{anionSuppressorModeLookup, anionSuppressorVoltageLookup, anionSuppressorCurrentLookup, anionDetectionTemperatureLookup, anionSuppressorMode,
			anionSuppressorVoltage, anionSuppressorCurrent, anionSuppressorModeConflictQ, anionDetectionTemperature,
			myGradient, maxFlowRate, maxEluentConc, defaultMinAnionSuppressorCurrent},

			If[MatchQ[resolvedAnionSamples, {} | Null | {Null}] || MatchQ[mapThreadFriendlyAnionSampleOptions, Null],
				(* If there is no samples for anion channel, resolve both options to Null and error tracking variables to False *)
				{Null, Null, Null, Null, {}},

				(* Otherwise, use map thread friendly options to resolve these options as below *)
				Transpose[MapThread[Function[{mySample, myResolvedGradient, myMapThreadOptions},

					(* Look up the specified options from the map thread friendly version of the anion options *)
					{
						anionSuppressorModeLookup,
						anionSuppressorVoltageLookup,
						anionSuppressorCurrentLookup,
						anionDetectionTemperatureLookup
					} = Lookup[myMapThreadOptions,
						{
							AnionSuppressorMode,
							AnionSuppressorVoltage,
							AnionSuppressorCurrent,
							AnionDetectionTemperature
						}
					];

					(* If user specified AnionSuppressorMode, go with that *)
					anionSuppressorMode = Which[

						(* If user specified suppressor mode, then go with that *)
						MatchQ[anionSuppressorModeLookup, Except[Null | Automatic]],
						anionSuppressorModeLookup,

						(* If user does not specify suppressor mode but instead specify suppressor voltage, set suppressorMode to DynamicMode *)
						MatchQ[anionSuppressorVoltageLookup, Except[Null | Automatic]],
						DynamicMode,

						(* Similarly, if user does not specify suppressor mode but instead specify suppressor current, set suppressorMode to LegacyMode *)
						MatchQ[anionSuppressorCurrentLookup, Except[Null | Automatic]],
						LegacyMode,

						(* If nothing is specified, resolve to DynamicMode *)
						True,
						LegacyMode
					];

					(*Get the actual gradient list*)
					myGradient = If[MatchQ[myResolvedGradient, ObjectP[Object[Method]]],
						(*If our resolved gradient is an object, we need to extract the actual gradient from the correct field*)
						Lookup[fetchPacketFromCache[Download[myResolvedGradient, Object], fullCache], AnionGradient],
						(*Otherwise it is already a list of sample and flow rate*)
						myResolvedGradient
					];

					(* Preparation to resolve anionSuppressorCurrent *)
					(* anionSuppressorCurrent (mA) = FlowRate (min/mL) x [Eluent] x suppressor specific Factor *)
					maxFlowRate = Convert[Max[myGradient[[All, -1]]], Milliliter / Minute];
					maxEluentConc = Convert[Max[myGradient[[All, 2]]], Millimolar];
					defaultMinAnionSuppressorCurrent = SafeRound[Unitless[maxFlowRate * maxEluentConc * anionSuppressorSpecificFactor], 1, Round -> Up] * Milli * Ampere;

					{anionSuppressorVoltage, anionSuppressorCurrent, anionSuppressorModeConflictQ} = Which[

						(* If AnionSuppressorMode option is set to DynamicMode, then we need to resolve AnionSuppressorVoltage and set AnionSuppressorCurrent to Null *)
						MatchQ[anionSuppressorMode, DynamicMode],
						If[
							(* First we need to make sure when AnionSuppressorMode is set to DynamicMode, AnionSuppressorCurrent is not specified *)
							(* If it is specified, set error tracking variable to True so that we can throw error later *)
							MatchQ[anionSuppressorVoltageLookup, Null],
							{Null, Null, True},

							Which[
								(* If AnionSuppressorVoltage is specified, go with that *)
								MatchQ[anionSuppressorVoltageLookup, Except[Automatic]],
								{anionSuppressorVoltageLookup, Null, False},

								(* If not, use the factory recommended value of the suppressor *)
								MatchQ[anionSuppressorVoltageLookup, Automatic],
								{anionSuppressorRecommendedVoltage, Null, False},

								True,
								{anionSuppressorRecommendedVoltage, Null, False}
							]
						],

						(* If AnionSuppressorMode option is set to LegacyMode, then we need to resolve AnionSuppressorCurrent and set AnionSuppressotVoltage to Null *)
						MatchQ[anionSuppressorMode, LegacyMode],
						If[
							(* First we need to make sure when AnionSuppressorMode is set to LegacyModel, AnionSuppressorVoltage is not specified *)
							(* If it is specified, set error tracking variable to True so that we can throw error later *)
							MatchQ[anionSuppressorCurrentLookup, Null],
							{Null, Null, True},

							Which[
								(* If AnionSuppressorCurrent is specified, go with that *)
								MatchQ[anionSuppressorCurrentLookup, Except[Automatic]],
								{Null, anionSuppressorCurrentLookup, False},

								(* If not, use the factory recommended value of the suppressor *)
								MatchQ[anionSuppressorCurrentLookup, Automatic],
								{Null, defaultMinAnionSuppressorCurrent, False},

								True,
								{Null, defaultMinAnionSuppressorCurrent, False}
							]
						],

						True,
						{Null, Null, False}

					];

					(* If user specified AnionDetectionTemperature, go with that *)
					anionDetectionTemperature = If[MatchQ[anionDetectionTemperatureLookup, Except[Automatic | Null]],
						anionDetectionTemperatureLookup,
						(* Otherwise, use Ambient detection *)
						Ambient
					];

					(* Return everything *)
					{
						anionSuppressorMode,
						anionSuppressorVoltage,
						anionSuppressorCurrent,
						anionDetectionTemperature,
						anionSuppressorModeConflictQ
					}
				],
					{ToList@resolvedAnionSamples, resolvedAnionGradient, mapThreadFriendlyAnionSampleOptions}
				]]]];

		(* == Error Checking == *)

		(* 30.1 Suppressor mode error check *)
		(* Pull out the anion samples that have conflicting suppressor mode and compile a list of conflicting suppressor mode*)
		conflictingAnionSuppressorModeSamples = If[MatchQ[resolvedAnionSamples, Null | {} | {Null}],
			{},
			PickList[ToList@resolvedAnionSamples, conflictingAnionSuppressorModeErrors, True]
		];

		(* Throw error message and collect invalid option *)
		conflictingAnionSuppressorModeOptions = If[Length[conflictingAnionSuppressorModeSamples] > 0 && messagesQ,
			(
				Message[Error::ConflictingSuppressorMode, ObjectToString[conflictingAnionSuppressorModeSamples,Cache -> fullCache, Simulation -> updatedSimulation], AnionSuppressorMode, AnionSuppressorVoltage, AnionSuppressorCurrent];
				{AnionSuppressorMode, AnionSuppressorVoltage, AnionSuppressorCurrent}
			),
			{}
		];

		(* Generate test for conflicting suppressor mode *)
		anionSuppressorModeTests = testOrNullIndexMatched["AnionSuppressorVoltage and AnionSuppressorCurrent are set if AnionSuppressorMode is set to DynamicMode and LegacyMode respectively:", resolvedAnionSamples, conflictingAnionSuppressorModeErrors];

		(* 30.2 Suppressor voltage error check *)
		(* Pull out the anion samples that have incompatible suppressor current and compile a list of incompatible suppressor current *)
		(*incompatibleSuppressorVoltageAnionSamples=If[MatchQ[resolvedAnionSamples,Null|{}|{Null}],
            {},
            PickList[ToList@resolvedAnionSamples,incompatibleAnionSuppressorVoltageErrors,True]
        ];
        incompatibleAnionSuppressorVoltage=If[MatchQ[resolvedAnionSamples,Null|{}|{Null}],
            {},
            PickList[resolvedAnionSuppressorVoltage,incompatibleAnionSuppressorVoltageErrors,True]
        ];

        (* Throw error message and collect invalid option *)
        invalidAnionSuppressorVoltageOptions=If[Length[incompatibleSuppressorVoltageAnionSamples]>0&&messagesQ,
            (
                Message[Error::IncompatibleSuppressorVoltage,incompatibleAnionSuppressorVoltage,AnionSamples,ObjectToString[incompatibleSuppressorVoltageAnionSamples,Cache -> fullCache, Simulation -> updatedSimulation],maxAnionSuppressorVoltage/.Null->Infinity Volt];
                {AnionSuppressorVoltage}
            ),
            {}
        ];

        (* Generate test for invalid max acceleration *)
        anionSuppressorVoltageTests=testOrNullIndexMatched["AnionSuppressorVoltage is less than the maximum suppressor voltage supported by the instrument:",resolvedAnionSamples,incompatibleAnionSuppressorVoltageErrors];

        (* 30.3 Suppressor current error check *)
        (* Pull out the anion samples that have incompatible suppressor current and compile a list of incompatible suppressor current *)
        incompatibleSuppressorCurrentAnionSamples=If[MatchQ[resolvedAnionSamples,Null|{}|{Null}],
            {},
            PickList[ToList@resolvedAnionSamples,incompatibleAnionSuppressorCurrentErrors,True]
        ];
        incompatibleAnionSuppressorCurrent=If[MatchQ[resolvedAnionSamples,Null|{}|{Null}],
            {},
            PickList[resolvedAnionSuppressorCurrent,incompatibleAnionSuppressorCurrentErrors,True]
        ];

        (* Throw error message and collect invalid option *)
        invalidAnionSuppressorCurrentOptions=If[Length[incompatibleSuppressorCurrentAnionSamples]>0&&messagesQ,
            (
                Message[Error::IncompatibleSuppressorCurrent,incompatibleAnionSuppressorCurrent,AnionSamples,ObjectToString[incompatibleSuppressorCurrentAnionSamples,Cache -> fullCache, Simulation -> updatedSimulation],0 Milliampere,maxAnionSuppressorCurrent];
                {AnionSuppressorCurrent}
            ),
            {}
        ];

        (* Generate test for invalid max acceleration *)
        anionSuppressorCurrentTests=testOrNullIndexMatched["AnionSuppressorCurrent is less than the maximum suppressor current supported by the instrument:",resolvedAnionSamples,incompatibleAnionSuppressorCurrentErrors];

        (* 30.4 Detection Temperature error check *)
        (* Pull out the anion samples that have incompatible suppressor current and compile a list of incompatible suppressor current *)
        incompatibleDetectionTemperatureAnionSamples=If[MatchQ[resolvedAnionSamples,Null|{}|{Null}],
            {},
            PickList[ToList@resolvedAnionSamples,incompatibleAnionDetectionTemperatureErrors,True]
        ];
        incompatibleAnionDetectionTemperature=If[MatchQ[resolvedAnionSamples,Null|{}|{Null}],
            {},
            PickList[resolvedAnionDetectionTemperature,incompatibleAnionDetectionTemperatureErrors,True]
        ];

        (* Throw error message and collect invalid option *)
        invalidAnionDetectionTemperatureOptions=If[Length[incompatibleDetectionTemperatureAnionSamples]>0&&messagesQ,
            (
                Message[Error::IncompatibleDetectionTemperature,incompatibleAnionDetectionTemperature,AnionSamples,ObjectToString[incompatibleDetectionTemperatureAnionSamples,Cache -> fullCache, Simulation -> updatedSimulation],minAnionDetectionTemperature,maxAnionDetectionTemperature];
                {AnionDetectionTemperature}
            ),
            {}
        ];

        (* Generate test for invalid max acceleration *)
        anionDetectionTemperatureTests=testOrNullIndexMatched["AnionDetectionTemperature is within the range of detection temperatures set by the instrument:",resolvedAnionSamples,incompatibleAnionDetectionTemperatureErrors]; *)

		(* 31. CationSuppressorCurrent and CationDetectionTemperature resolution *)

		(* Find the maximum allowed anion current from the instrument model packet *)
		{cationSuppressorRecommendedVoltage, maxCationSuppressorVoltage, maxCationSuppressorCurrent, cationSuppressorSpecificFactor} = If[
			MatchQ[Lookup[resolvedInstrumentModelPacket, CationSuppressor, {}], {} | Null | {Null}],
			{0 Volt, Infinity Volt, -Infinity Milliampere, 0},
			Lookup[fetchPacketFromCache[Lookup[resolvedInstrumentModelPacket, CationSuppressor, {}], fullCache], {FactoryRecommendedVoltage, MaxVoltage, MaxCurrent, SuppressorSpecificFactor}]
		];

		(* Find the allowed range of detection temperature from the instrument model packet *)
		{minCationDetectionTemperature, maxCationDetectionTemperature} = Lookup[resolvedInstrumentModelPacket, {CationMinDetectionTemperature, CationMaxDetectionTemperature}];

		{
			resolvedCationSuppressorMode,
			resolvedCationSuppressorVoltage,
			resolvedCationSuppressorCurrent,
			resolvedCationDetectionTemperature,
			conflictingCationSuppressorModeErrors
		} = Module[{cationSuppressorModeLookup, cationSuppressorVoltageLookup, cationSuppressorCurrentLookup, cationDetectionTemperatureLookup, cationSuppressorMode,
			myGradient, maxFlowRate, maxBufferConc, defaultMinCationSuppressorCurrent, cationSuppressorVoltage, cationSuppressorCurrent,
			cationSuppressorModeConflictQ, cationDetectionTemperature, allBufferPercent, totalBufferConcentration},

			If[MatchQ[resolvedCationSamples, {} | Null | {Null}] || MatchQ[mapThreadFriendlyCationSampleOptions, Null],
				(* If there is no samples for cation channel, resolve both options to Null and error tracking variables to False *)
				{Null, Null, Null, Null, {}},

				(* Otherwise, use map thread friendly options to resolve these options as below *)
				Transpose[MapThread[Function[{mySample, myResolvedGradient, myMapThreadOptions},

					(* Look up the specified options from the map thread friendly version of the cation options *)
					{
						cationSuppressorModeLookup,
						cationSuppressorVoltageLookup,
						cationSuppressorCurrentLookup,
						cationDetectionTemperatureLookup
					} = Lookup[myMapThreadOptions,
						{
							CationSuppressorMode,
							CationSuppressorVoltage,
							CationSuppressorCurrent,
							CationDetectionTemperature
						}
					];

					(* If user specified AnionSuppressorMode, go with that *)
					cationSuppressorMode = Which[

						(* If user specified suppressor mode, then go with that *)
						MatchQ[cationSuppressorModeLookup, Except[Null | Automatic]],
						cationSuppressorModeLookup,

						(* If user does not specify suppressor mode but instead specify suppressor voltage, set suppressorMode to DynamicMode *)
						MatchQ[cationSuppressorVoltageLookup, Except[Null | Automatic]],
						DynamicMode,

						(* Similarly, if user does not specify suppressor mode but instead specify suppressor current, set suppressorMode to LegacyMode *)
						MatchQ[cationSuppressorCurrentLookup, Except[Null | Automatic]],
						LegacyMode,

						(* If nothing is specified, resolve to DynamicMode *)
						True,
						LegacyMode
					];
					(*Get the actual gradient list*)
					myGradient = If[MatchQ[myResolvedGradient, ObjectP[Object[Method]]],
						(*If our resolved gradient is an object, we need to extract the actual gradient from the correct field*)
						Lookup[fetchPacketFromCache[Download[myResolvedGradient, Object], fullCache], CationGradient],
						(*Otherwise it is already a list of sample and flow rate*)
						myResolvedGradient
					];

					(* Pull out the percent of all 4 buffers from the resolvedGradient *)
					allBufferPercent = If[MatchQ[myResolvedGradient, ObjectP[Object[Method, IonChromatographyGradient]]],
						(Lookup[fetchPacketFromCache[Download[myResolvedGradient, Object], fullCache], CationGradient][[All, 2 ;; 5]]) / (100 Percent),
						myResolvedGradient[[All, 2 ;; 5]] / (100 Percent)
					];
					(* Calculate the total concentration of all 4 buffers *)
					totalBufferConcentration = Map[Times[#, {bufferAConcentration, bufferBConcentration, bufferCConcentration, bufferDConcentration}]&, allBufferPercent];

					(* Preparation to resolve cationSuppressorCurrent *)
					(* cationSuppressorCurrent (mA) = FlowRate (min/mL) x [Eluent] x suppressor specific Factor *)
					maxFlowRate = Convert[Max[myGradient[[All, -1]]], Milliliter / Minute];
					maxBufferConc = Max[totalBufferConcentration];
					defaultMinCationSuppressorCurrent = SafeRound[Unitless[maxFlowRate * maxBufferConc * cationSuppressorSpecificFactor], 1, Round -> Up] * Milli * Ampere;

					{cationSuppressorVoltage, cationSuppressorCurrent, cationSuppressorModeConflictQ} = Which[

						(* If CationSuppressorMode option is set to DynamicMode, then we need to resolve CationSuppressorVoltage and set CationSuppressorCurrent to Null *)
						MatchQ[cationSuppressorMode, DynamicMode],
						If[
							(* First we need to make sure when CationSuppressorMode is set to DynamicMode, CationSuppressorCurrent is not specified *)
							(* If it is specified, set error tracking variable to True so that we can throw error later *)
							MatchQ[cationSuppressorVoltageLookup, Null],
							{Null, Null, True},

							Which[
								(* If CationSuppressorVoltage is specified, go with that *)
								MatchQ[cationSuppressorVoltageLookup, Except[Automatic]],
								{cationSuppressorVoltageLookup, Null, False},

								(* If not, use the factory recommended value of the suppressor *)
								MatchQ[cationSuppressorVoltageLookup, Automatic],
								{cationSuppressorRecommendedVoltage, Null, False},

								True,
								{cationSuppressorRecommendedVoltage, Null, False}
							]
						],

						(* If CationSuppressorMode option is set to LegacyMode, then we need to resolve CationSuppressorCurrent and set CationSuppressotVoltage to Null *)
						MatchQ[cationSuppressorMode, LegacyMode],
						If[
							(* First we need to make sure when CationSuppressorMode is set to LegacyModel, CationSuppressorVoltage is not specified *)
							(* If it is specified, set error tracking variable to True so that we can throw error later *)
							MatchQ[cationSuppressorCurrentLookup, Null],
							{Null, Null, True},

							Which[
								(* If CationSuppressorCurrent is specified, go with that *)
								MatchQ[cationSuppressorCurrentLookup, Except[Automatic]],
								{Null, cationSuppressorCurrentLookup, False},

								(* If not, use the factory recommended value of the suppressor *)
								MatchQ[cationSuppressorCurrentLookup, Automatic],
								{Null, defaultMinCationSuppressorCurrent, False},

								MatchQ[defaultMinCationSuppressorCurrent, 0 Milliampere],
								{Null, 15 Milliampere, False},

								True,
								{Null, defaultMinCationSuppressorCurrent, False}
							]
						],

						True,
						{Null, Null, False}

					];

					(* If user specified CationDetectionTemperature, go with that *)
					cationDetectionTemperature = If[MatchQ[cationDetectionTemperatureLookup, Except[Automatic | Null]],
						cationDetectionTemperatureLookup,
						(* Otherwise, use Ambient detection *)
						Ambient
					];

					(* Return everything *)
					{
						cationSuppressorMode,
						cationSuppressorVoltage,
						cationSuppressorCurrent,
						cationDetectionTemperature,
						cationSuppressorModeConflictQ
					}
				],
					{ToList@resolvedCationSamples, resolvedCationGradient, mapThreadFriendlyCationSampleOptions}
				]]]];


		(* == Error Checking == *)

		(* 32.1 Suppressor mode error check *)
		(* Pull out the cation samples that have conflicting suppressor mode and compile a list of conflicting suppressor mode*)
		conflictingCationSuppressorModeSamples = If[MatchQ[resolvedCationSamples, Null | {} | {Null}],
			{},
			PickList[ToList@resolvedCationSamples, conflictingCationSuppressorModeErrors, True]
		];

		(* Throw error message and collect invalid option *)
		conflictingCationSuppressorModeOptions = If[Length[conflictingCationSuppressorModeSamples] > 0 && messagesQ,
			(
				Message[Error::ConflictingSuppressorMode, ObjectToString[conflictingCationSuppressorModeSamples,Cache -> fullCache, Simulation -> updatedSimulation], CationSuppressorMode, CationSuppressorVoltage, CationSuppressorCurrent];
				{CationSuppressorMode, CationSuppressorVoltage, CationSuppressorCurrent}
			),
			{}
		];

		(* Generate test for conflicting suppressor mode *)
		cationSuppressorModeTests = testOrNullIndexMatched["CationSuppressorVoltage and CationSuppressorCurrent are set if CationSuppressorMode is set to DynamicMode and LegacyMode respectively:", resolvedCationSamples, conflictingCationSuppressorModeErrors];

		(* 32.2 Suppressor voltage error check *)
		(* Pull out the cation samples that have incompatible suppressor current and compile a list of incompatible suppressor current *)
		(*incompatibleSuppressorVoltageCationSamples=If[MatchQ[resolvedCationSamples,Null|{}|{Null}],
            {},
            PickList[ToList@resolvedCationSamples,incompatibleCationSuppressorVoltageErrors,True]
        ];
        incompatibleCationSuppressorVoltage=If[MatchQ[resolvedCationSamples,Null|{}|{Null}],
            {},
            PickList[resolvedCationSuppressorVoltage,incompatibleCationSuppressorVoltageErrors,True]
        ];

        (* Throw error message and collect invalid option *)
        invalidCationSuppressorVoltageOptions=If[Length[incompatibleSuppressorVoltageCationSamples]>0&&messagesQ,
            (
                Message[Error::IncompatibleSuppressorVoltage,incompatibleCationSuppressorVoltage,CationSamples,ObjectToString[incompatibleSuppressorVoltageCationSamples,Cache -> fullCache, Simulation -> updatedSimulation],maxCationSuppressorVoltage/.Null->Infinity Volt];
                {CationSuppressorVoltage}
            ),
            {}
        ];

        (* Generate test for invalid max acceleration *)
        cationSuppressorVoltageTests=testOrNullIndexMatched["CationSuppressorVoltage is less than the maximum suppressor voltage supported by the instrument:",resolvedCationSamples,incompatibleCationSuppressorVoltageErrors];

        (* 32.3 Suppressor current error check *)
        (* Pull out the cation samples that have incompatible suppressor current and compile a list of incompatible suppressor current *)
        incompatibleSuppressorCurrentCationSamples=If[MatchQ[resolvedCationSamples,Null|{}|{Null}],
            {},
            PickList[ToList@resolvedCationSamples,incompatibleCationSuppressorCurrentErrors,True]
        ];
        incompatibleCationSuppressorCurrent=If[MatchQ[resolvedCationSamples,Null|{}|{Null}],
            {},
            PickList[resolvedCationSuppressorCurrent,incompatibleCationSuppressorCurrentErrors,True]
        ];

        (* Throw error message and collect invalid option *)
        invalidCationSuppressorCurrentOptions=If[Length[incompatibleSuppressorCurrentCationSamples]>0&&messagesQ,
            (
                Message[Error::IncompatibleSuppressorCurrent,incompatibleCationSuppressorCurrent,CationSamples,ObjectToString[incompatibleSuppressorCurrentCationSamples,Cache -> fullCache, Simulation -> updatedSimulation],0 Milliampere,maxCationSuppressorCurrent];
                {CationSuppressorCurrent}
            ),
            {}
        ];

        (* Generate test for invalid max acceleration *)
        cationSuppressorCurrentTests=testOrNullIndexMatched["CationSuppressorCurrent is less than the maximum suppressor current supported by the instrument:",resolvedCationSamples,incompatibleCationSuppressorCurrentErrors];

        (* 32.4 Detection Temperature error check *)
        (* Pull out the cation samples that have incompatible suppressor current and compile a list of incompatible suppressor current *)
        incompatibleDetectionTemperatureCationSamples=If[MatchQ[resolvedCationSamples,Null|{}|{Null}],
            {},
            PickList[ToList@resolvedCationSamples,incompatibleCationDetectionTemperatureErrors,True]
        ];
        incompatibleCationDetectionTemperature=If[MatchQ[resolvedCationSamples,Null|{}|{Null}],
            {},
            PickList[resolvedCationSuppressorCurrent,incompatibleCationDetectionTemperatureErrors,True]
        ];

        (* Throw error message and collect invalid option *)
        invalidCationDetectionTemperatureOptions=If[Length[incompatibleDetectionTemperatureCationSamples]>0&&messagesQ,
            (
                Message[Error::IncompatibleDetectionTemperature,incompatibleCationDetectionTemperature,CationSamples,ObjectToString[incompatibleDetectionTemperatureCationSamples,Cache -> fullCache, Simulation -> updatedSimulation],minCationDetectionTemperature/.Null->-Infinity Celsius,maxCationDetectionTemperature/.Null->Infinity Celsius];
                {CationDetectionTemperature}
            ),
            {}
        ];

        (* Generate test for invalid max acceleration *)
        cationDetectionTemperatureTests=testOrNullIndexMatched["CationDetectionTemperature is within the range of detection temperatures set by the instrument:",resolvedCationSamples,incompatibleCationDetectionTemperatureErrors]; *)


		(* 32. UVVis and Electrochemical Detection parameter resolution *)

		resolvedWorkingElectrode = Which[

			(* If the protocol is not using Electrochemical Detector, resolve to Null *)
			!MemberQ[ToList@resolvedDetector, ElectrochemicalDetector],
			Null,

			(* If user specified working electrode, go with that *)
			MatchQ[Lookup[roundedOptionsAssociation, WorkingElectrode], Except[Automatic | Null]],
			Lookup[roundedOptionsAssociation, WorkingElectrode],

			(* Otherwise resolve to Disposable Gold on PTFE Electrode *)
			True,
			Model[Item, Electrode, "Dionex Disposable Gold on PTFE Electrode"]
		];

		workingElectrodeModelPacket = Which[
			(* If the working electrode is given as an object *)
			(* Get the model packet from fullCache *)
			MatchQ[resolvedWorkingElectrode, ObjectP[Object[Item, Electrode]]],
			fetchPacketFromCache[
				Lookup[
					fetchPacketFromCache[Download[resolvedWorkingElectrode, Object], fullCache],
					Model
				],
				fullCache
			],

			(* If the working electrode is given as a model object already *)
			(* Then directly get packet from fullCache *)
			MatchQ[resolvedWorkingElectrode, ObjectP[Model[Item, Electrode]]],
			fetchPacketFromCache[Download[resolvedWorkingElectrode, Object], fullCache]
		];

		resolvedWorkingElectrodeStorageCondition = Module[{dateUnsealed, disposeQ},

			(* Lookup the DateUnsealed information of the electrode or  *)
			dateUnsealed = Which[
				NullQ[resolvedWorkingElectrode],
				Null,

				MatchQ[ObjectP[Object[Item, Electrode]]],
				Lookup[fetchPacketFromCache[Download[resolvedWorkingElectrode, Object], fullCache], DateUnsealed],

				True,
				Null
			];

			(* Create a variable to determine whether we will be disposing working electrode *)
			disposeQ = Which[
				(* If DateUnsealed is not populated, set disposeQ to True *)
				NullQ[dateUnsealed],
				True,

				(* If DateUnsealed is a date object, then we look how long it has been opened *)
				DateObjectQ[dateUnsealed],
				If[
					(* If DateUnsealed is populated and it has been over 14 days, then set variable to True *)
					Now - dateUnsealed > 14 Day,
					True,

					(* If DateUnsealed is populated and it has been less than 14 days, then set variable to False *)
					False
				]
			];


			Which[
				(* If there is no working electrode for the protocol, resolve to Null *)
				NullQ[resolvedWorkingElectrode],
				Null,

				MatchQ[Lookup[roundedOptionsAssociation, WorkingElectrodeStorageCondition], Except[Automatic]],
				Lookup[roundedOptionsAssociation, WorkingElectrodeStorageCondition],

				(* If working electrode is an Object[Item,Electrode], then we look at disposeQ to decide whether we are throwing the electrode away *)
				MatchQ[resolvedWorkingElectrode, ObjectP[Object[Item, Electrode]]],
				(* If diposeQ is True, we set storage condition to Disposal, otherwise we set storage condition according to its Model's DefaultStorageCondition *)
				If[disposeQ,
					Disposal,
					Lookup[fetchPacketFromCache[Download[resolvedWorkingElectrode, Object], fullCache], DefaultStorageCondition][StorageCondition]
				],

				(* If working electrode is an Model[Item,Electrode] *)
				MatchQ[resolvedWorkingElectrode, ObjectP[Model[Item, Electrode]]],
				(* We set storage condition according to its Model's DefaultStorageCondition *)
				Lookup[fetchPacketFromCache[Download[resolvedWorkingElectrode, Object], fullCache], DefaultStorageCondition][StorageCondition]
			]
		];

		pHCalibrationOptionConflictQ = Module[{calibrationOptionsSpecifiedQ},

			(* First check if any of the pH calibration options are specified *)
			calibrationOptionsSpecifiedQ = anySpecifiedQ[{NeutralpHCalibrationBuffer, SecondarypHCalibrationBuffer, SecondarypHCalibrationBufferTarget}, roundedOptionsAssociation];

			Which[
				(* If pHCalibration option is turned on, its child options cannot be Nulled out *)
				MatchQ[Lookup[roundedOptionsAssociation, pHCalibration], True],
				!MatchQ[Lookup[roundedOptionsAssociation, {NeutralpHCalibrationBuffer, SecondarypHCalibrationBuffer, SecondarypHCalibrationBufferTarget}], {Except[Null], Except[Null], Except[Null]}],

				(* If pHCalibration option is not turn on, its child options should not be specified *)
				MatchQ[Lookup[roundedOptionsAssociation, pHCalibration], False],
				calibrationOptionsSpecifiedQ,

				True,
				False
			]
		];

		(* pH Calibration options error check *)
		(* If pHCalibration is turned on, associated options cannot be Nulled out; otherwise, associated options should not be specified *)
		invalidpHCalibrationOptions = If[pHCalibrationOptionConflictQ && messagesQ,
			(
				Message[Error::pHCalibrationOptionConflict, {pHCalibration, NeutralpHCalibrationBuffer, SecondarypHCalibrationBuffer, SecondarypHCalibrationBufferTarget}];
				{pHCalibration, NeutralpHCalibrationBuffer, SecondarypHCalibrationBuffer, SecondarypHCalibrationBufferTarget}
			),
			{}
		];

		(* Generate test for pH calibration option error check *)
		pHCalibrationOptionTests = testOrNull["If pHCalibration is turned on, associated options cannot be Nulled out; otherwise, associated options should not be specified:", Not[pHCalibrationOptionConflictQ]];


		resolvedpHCalibration = If[pHCalibrationOptionConflictQ,
			False,

			Which[
				(* If user has specified the pH Calibration option, go with it *)
				MatchQ[Lookup[roundedOptionsAssociation, pHCalibration], Except[Automatic | Null]],
				Lookup[roundedOptionsAssociation, pHCalibration],

				(* Automatically turn on this option if any of its child option is specified *)
				MatchQ[Lookup[roundedOptionsAssociation, pHCalibration], Except[Null]] && anySpecifiedQ[{NeutralpHCalibrationBuffer, SecondarypHCalibrationBuffer, SecondarypHCalibrationBufferTarget}, roundedOptionsAssociation],
				True,

				(* If the protocol is using electrochemical detector, resolve this option to False *)
				MemberQ[resolvedDetector, ElectrochemicalDetector],
				False,

				(* Otherwise resolve to Null *)
				True,
				Null
			]
		];

		resolvedNeutralpHCalibrationBuffer = If[TrueQ[resolvedpHCalibration],

			If[
				(* If user has specified the pH Calibration option, go with it *)
				MatchQ[Lookup[roundedOptionsAssociation, NeutralpHCalibrationBuffer], Except[Automatic | Null]],
				Lookup[roundedOptionsAssociation, NeutralpHCalibrationBuffer],

				(* Otherwise resolve to reference solution at pH 7 *)
				Model[Sample, "id:E8zoYveRllov"]
			],

			Null
		];

		resolvedSecondarypHCalibrationBuffer = If[TrueQ[resolvedpHCalibration],

			If[
				(* If user has specified the pH Calibration option, go with it *)
				MatchQ[Lookup[roundedOptionsAssociation, SecondarypHCalibrationBuffer], Except[Automatic | Null]],
				Lookup[roundedOptionsAssociation, SecondarypHCalibrationBuffer],

				(* Otherwise resolve to reference solution at pH 10 *)
				Model[Sample, "id:1ZA60vwjbbV8"]
			],

			Null
		];

		resolvedSecondarypHCalibrationBufferTarget = If[TrueQ[resolvedpHCalibration],

			If[
				(* If user has specified the pH Calibration option, go with it *)
				MatchQ[Lookup[roundedOptionsAssociation, SecondarypHCalibrationBufferTarget], Except[Automatic | Null]],
				Lookup[roundedOptionsAssociation, SecondarypHCalibrationBufferTarget],

				(* Otherwise pull out the pH value from the solution packet *)
				(* If the pH field is not populated, then just resolve to 10 *)
				If[MatchQ[Lookup[fetchPacketFromCache[Download[resolvedSecondarypHCalibrationBuffer, Object], fullCache], pH], {}],
					10,
					Lookup[fetchPacketFromCache[Download[resolvedSecondarypHCalibrationBuffer, Object], fullCache], pH]
				]
			],

			Null
		];

		(* Secondary pH buffer and target conflict check *)
		(* If SecondaryCalibrationBuffer and SecondarypHCalibrationBufferTarget are both specified, make sure the specified pH value matches that from the buffer packet *)
		pHTargetConflictQ = If[resolvedpHCalibration,
			If[MatchQ[Lookup[fetchPacketFromCache[Download[resolvedSecondarypHCalibrationBuffer, Object], fullCache], pH], {}],
				(* If pH is not present in the buffer packet, set this to false *)
				False,
				!EqualQ[Lookup[fetchPacketFromCache[Download[resolvedSecondarypHCalibrationBuffer, Object], fullCache], pH], resolvedSecondarypHCalibrationBufferTarget]
			],
			False
		];

		invalidpHCalibrationTargetOptions = If[pHTargetConflictQ && messagesQ && notInEngine,
			(
				Message[Warning::pHCalibrationTarget];
			),
			{}
		];

		(* Generate test for pH calibration option error check *)
		pHCalibrationTargetOptionTests = warningOrNull["If both SecondarypHCalibrationBuffer and SecondarypHCalibrationBufferTarget are specified, the specified pH target matches that from the buffer packet:", Not[pHTargetConflictQ]];


		{
			resolvedAbsorbanceWavelength,
			resolvedAbsorbanceSamplingRate,
			resolvedElectrochemicalDetectionMode,
			resolvedReferenceElectrodeMode,
			resolvedVoltageProfile,
			resolvedWaveformProfile,
			resolvedElectrochemicalSamplingRate,
			resolvedDetectionTemperature,
			absorbanceOptionConflictErrors,
			electrochemicalOptionConflictErrors,
			electrochemicalModeOptionConflictErrors,
			multipleDetectionModeErrors,
			waveformDetectionModeErrors,
			multipleWaveformDurationErrors,
			duplicateVoltageProfileTimeErrors,
			duplicateWaveformProfileTimeErrors
		} = Module[{absorbanceOptionConflictQ, absorbanceWavelength, absorbanceSamplingRate, injectionTableWithID, injectionTableWaveformEntry, electrochemicalModeOptionConflictQ,
			waveformDetectionMode, multipleDetectionModeQ, electrochemicalDetectionMode, waveformDetectionModeConflictQ,
			referenceElectrodeMode, voltageProfile, voltageProfileDuplicateTimeQ, waveformProfile, waveformProfileDuplicateTimeQ, waveformDuration, multipleWaveformDurationQ,
			electrochemicalSamplingRate, detectionTemperature, injectionTableVoltageEntry, electrochemicalOptionConflictQ},

			If[
				MatchQ[mapThreadFriendlyElectrochemicalSampleOptions, {}],
				Join[ConstantArray[Null, 8], ConstantArray[False, 8]],

				(* Set up map thread for resolving detection options *)
				Transpose[MapThread[Function[{mySample, myMapThreadOptions},

					(* Before resolving the absorbance options, first do some option conflict checks *)
					absorbanceOptionConflictQ = If[MemberQ[ToList@resolvedDetector, UVVis],
						Switch[
							(* We will look up the specified value of Absorbance related options *)
							Lookup[myMapThreadOptions, {AbsorbanceWavelength, AbsorbanceSamplingRate}],

							(* Both options cannot be null *)
							{Except[Null], Except[Null]},
							False,

							(* Otherwise set the error tracking variable to True *)
							{_, _},
							True
						],
						False
					];

					absorbanceWavelength = If[MatchQ[Lookup[myMapThreadOptions, AbsorbanceWavelength], Except[Automatic | Null]],
						(* If user specified absorbance wavelength, go with that *)
						Lookup[myMapThreadOptions, AbsorbanceWavelength],
						(* Otherwise, set to 280 nm *)
						280 Nanometer
					];

					absorbanceSamplingRate = Which[

						(* If user specified absorbance wavelength sampling rate, go with that *)
						MatchQ[Lookup[myMapThreadOptions, AbsorbanceSamplingRate], Except[Automatic | Null]],
						Lookup[myMapThreadOptions, AbsorbanceSamplingRate],

						(* If we are only reading at one wavelength, then set sampling rate to 10/Second *)
						Length[ToList@absorbanceWavelength] == 1,
						10 / Second,
						(* If we are reading at multiple wavelengths, then set sampling rate to 1/Second *)
						Length[ToList@absorbanceWavelength] > 1,
						1 / Second,

						(* Otherwise, set to Null *)
						True,
						Null
					];

					(* First download all the sample objects specified in the InjectionTable *)
					injectionTableWithID = Map[
						If[MatchQ[#[[2]], ObjectP[]],
							Join[ToList@#[[1]], ToList@Download[#[[2]], Object], #[[3 ;; Length[#]]]],
							#
						]&,
						electrochemicalInjectionTableLookupRounded
					];

					(* Then find the entry of the particular sample in the injection table *)
					{injectionTableWaveformEntry, injectionTableVoltageEntry} = If[electrochemicalInjectionTableSpecifiedQ,
						If[MatchQ[Cases[injectionTableWithID, {Sample, Download[mySample, Object], ___}], {}],
							{Null, Null},
							First[Cases[injectionTableWithID, {Sample, Download[mySample, Object], ___}]][[5 ;; 6]]
						],
						{Automatic, Automatic}
					];

					(* Before resolving the electrochemical options, first do some option conflict checks *)
					electrochemicalOptionConflictQ = If[MemberQ[ToList@resolvedDetector, ElectrochemicalDetector],
						Switch[
							(* We will look up the specified value of Absorbance related options *)
							Lookup[myMapThreadOptions, {ElectrochemicalDetectionMode, ReferenceElectrodeMode, ElectrochemicalSamplingRate, DetectionTemperature}],

							(* Both options cannot be null *)
							{Except[Null], Except[Null], Except[Null], Except[Null]},
							False,

							(* Otherwise set the error tracking variable to True *)
							{_, _, _, _},
							True
						],
						False
					];

					(* Before resolving all the electrochemical detection mode option, first do some option conflict checks *)
					electrochemicalModeOptionConflictQ = Switch[

						(* We will look up the specified value of Absorbance related options *)
						Lookup[myMapThreadOptions, {ElectrochemicalDetectionMode, VoltageProfile, WaveformProfile}],

						(* If they are both Null, there's no conflict *)
						{DCAmperometricDetection | {DCAmperometricDetection}, Null | {Null}, _},
						True,

						(* If they are both specified, there's also no conflict *)
						{PulsedAmperometricDetection | {PulsedAmperometricDetection}, _, Null | {Null}},
						True,

						(* If only one of the option value is Null, then set the conflict variable to True *)
						{IntegratedPulsedAmperometricDetection | {IntegratedPulsedAmperometricDetection}, _, Null | {Null}},
						True,

						{_, _, _},
						False
					];

					(* Before resolving electrochemical detection mode, let's first pull out the electrochemical mode from any waveforms specified *)
					waveformDetectionMode = Which[

						(* If WaveformProfile is specified, detection mode can either be Pulsed Amperometry or Integrated Pulsed Amperometry *)
						MatchQ[Lookup[myMapThreadOptions, WaveformProfile], Except[Automatic | Null]],
						Which[

							(* If WaveformProfile is specified as a method object, then directly pull ElectrochemicalDetectionMode field from it *)
							MatchQ[Lookup[myMapThreadOptions, WaveformProfile], ObjectP[Object[Method, Waveform]]],
							Lookup[fetchPacketFromCache[Download[Lookup[myMapThreadOptions, WaveformProfile], Object], fullCache], ElectrochemicalDetectionMode],

							(* If WaveformProfile is specified as multiple method objects, then track ElectrochemicalDetectionMode of all methods and use ElectrochemicalDetectionMode from the first method *)
							MatchQ[Lookup[myMapThreadOptions, WaveformProfile], {{TimeP, ObjectP[Object[Method, Waveform]]}...}],
							Lookup[fetchPacketFromCache[#, fullCache], ElectrochemicalDetectionMode]& /@ Download[Lookup[myMapThreadOptions, WaveformProfile][[All, 2]], Object],

							(* If WaveformProfile is specified as tuples of {Time,Voltage,Boolean,Boolean}, then it gets a little more complicated *)
							(* We will have to look at the second Boolean and the Voltage value to determine ElectrochemicalDetectionMode *)
							(* If voltages specified are one constant value when the second Boolean is True then it is PulsedAmperometricDetection *)
							(* If voltages specified are more than one value when the second Boolean is True then it is IntegratedPulsedAmperometricDetection *)
							MatchQ[Lookup[myMapThreadOptions, WaveformProfile], {{TimeP, VoltageP, BooleanP, BooleanP}...}],
							Module[{integratedEntries, integratedVoltages},

								(* First pick out the entries where the secnd Boolean is True, aka when integration happens *)
								integratedEntries = Select[Lookup[myMapThreadOptions, WaveformProfile], #[[4]] == True&];

								(* Then pull out the voltages of the entire integration period *)
								integratedVoltages = integratedEntries[[All, 2]];
								If[Length[DeleteDuplicates[integratedVoltages]] == 1,
									PulsedAmperometricDetection,
									IntegratedPulsedAmperometricDetection
								]
							],

							(* Final case, if WaveformProfile is specified as tuples of {Time, {Time,Voltage,Boolean,Boolean}}, then we apply the logic above *)
							MatchQ[Lookup[myMapThreadOptions, WaveformProfile], {{TimeP, {{TimeP, VoltageP, BooleanP, BooleanP}...}...}...}],
							Module[{waveforms, integratedEntries, integratedVoltages},

								(* First pick out the entries where the secnd Boolean is True, aka when integration happens *)
								waveforms = Lookup[myMapThreadOptions, WaveformProfile][[All, 2]];
								integratedEntries = Map[
									Function[{waveform},
										Select[waveform, #[[4]] == True&]
									],
									waveforms
								];

								(* Then pull out the voltages of the entire integration period *)
								integratedVoltages = integratedEntries[[All, All, 2]];
								If[Length[DeleteDuplicates[#]] == 1,
									PulsedAmperometricDetection,
									IntegratedPulsedAmperometricDetection
								]& /@ integratedVoltages
							]
						],

						(* If WaveformProfile is specified in the injection table, detection mode can either be Pulsed Amperometry or Integrated Pulsed Amperometry *)
						MatchQ[injectionTableWaveformEntry, Except[Automatic | Null]],
						Which[
							(* If WaveformProfile is specified in the injection table, download the method and pull ElectrochemicalDetectionMode *)
							MatchQ[injectionTableWaveformEntry, ObjectP[Object[Method, Waveform]]],
							Lookup[fetchPacketFromCache[Download[injectionTableWaveformEntry, Object], fullCache], ElectrochemicalDetectionMode],

							(* If WaveformProfile is specified as multiple method objects in the injection table, then track ElectrochemicalDetectionMode of all methods *)
							MatchQ[injectionTableWaveformEntry, {{TimeP, ObjectP[Object[Method, Waveform]]}...}],
							Lookup[fetchPacketFromCache[#, fullCache], ElectrochemicalDetectionMode]& /@ Download[injectionTableWaveformEntry[[All, 2]], Object],

							(* Similar logic applies for Waveform specified in the injection table *)
							MatchQ[injectionTableWaveformEntry, {{TimeP, VoltageP, BooleanP, BooleanP}...}],
							Module[{integratedEntries, integratedVoltages},

								(* First pick out the entries where the secnd Boolean is True, aka when integration happens *)
								integratedEntries = Select[injectionTableWaveformEntry, #[[4]] == True&];

								(* Then pull out the voltages of the entire integration period *)
								integratedVoltages = integratedEntries[[All, 2]];
								If[Length[DeleteDuplicates[integratedVoltages]] == 1,
									PulsedAmperometricDetection,
									IntegratedPulsedAmperometricDetection
								]
							],

							(* The injection table specified with same logic as above *)
							MatchQ[injectionTableWaveformEntry, {{TimeP, {{TimeP, VoltageP, BooleanP, BooleanP}...}...}...}],
							Module[{waveforms, integratedEntries, integratedVoltages},

								(* First pick out the entries where the secnd Boolean is True, aka when integration happens *)
								waveforms = injectionTableWaveformEntry[[All, 2]];
								integratedEntries = Map[
									Function[{waveform},
										Select[waveform, #[[4]] == True&]
									],
									waveforms
								];

								(* Then pull out the voltages of the entire integration period *)
								integratedVoltages = integratedEntries[[All, 2]];
								If[Length[DeleteDuplicates[#]] == 1,
									PulsedAmperometricDetection,
									IntegratedPulsedAmperometricDetection
								]& /@ integratedVoltages
							]
						],

						(* If waveform is not specified, leave it as Automatic *)
						True,
						Automatic
					];

					multipleDetectionModeQ = Module[{uniqueDetectionMode},
						(* Get the unique detection modes from all waveforms specified *)
						uniqueDetectionMode = DeleteDuplicates[ToList[waveformDetectionMode]];
						(* If there are more than 1 detection mode, set error tracking variable to True, otherwise set it to False *)
						If[Length[uniqueDetectionMode] == 1,
							False,
							True
						]
					];

					electrochemicalDetectionMode = Which[

						(* If user specified electrochemical detection mode, go with that *)
						MatchQ[Lookup[myMapThreadOptions, ElectrochemicalDetectionMode], Except[Automatic | Null]],
						Lookup[myMapThreadOptions, ElectrochemicalDetectionMode],

						(* If VoltageProfile is specified, set detection mode to DC Amperometry *)
						MatchQ[Lookup[myMapThreadOptions, VoltageProfile], Except[Automatic | Null]] || MatchQ[injectionTableVoltageEntry, Except[Automatic | Null]],
						DCAmperometricDetection,

						MatchQ[First@ToList[waveformDetectionMode], Except[Automatic]],
						First@ToList[waveformDetectionMode],

						(* Use the ElectrochemicalDetectionMode of the first waveform as the resolved electrochemicalDetection Mode *)
						True,
						PulsedAmperometricDetection
					];

					(* Here we check if the electrochemical detection mode and the specified waveform is in conflict *)
					(* If there is already multiple detection mode error, then we can pass on this error *)
					waveformDetectionModeConflictQ = If[multipleDetectionModeQ,
						False,
						If[MatchQ[electrochemicalDetectionMode, Except[DCAmperometricDetection]],
							If[!MatchQ[waveformDetectionMode, Automatic],
								!MatchQ[First@ToList[waveformDetectionMode], electrochemicalDetectionMode],
								False
							],
							False
						]
					];

					referenceElectrodeMode = Which[

						(* If user specified reference electrode mode, go with that *)
						MatchQ[Lookup[myMapThreadOptions, ReferenceElectrodeMode], Except[Automatic | Null]],
						Lookup[myMapThreadOptions, ReferenceElectrodeMode],

						(* If ElectrochemicalDetectionMode is set to DCAmperometry, set reference electrode mode to Null *)
						MatchQ[Lookup[myMapThreadOptions, ElectrochemicalDetectionMode], DCAmperometricDetection],
						Null,

						(* If VoltageProfile is specified, set reference electrode mode to DC Amperometry *)
						MatchQ[Lookup[myMapThreadOptions, VoltageProfile], Except[Automatic | Null]] || MatchQ[injectionTableVoltageEntry, Except[Automatic | Null]],
						Null,

						(* If WaveformProfile is specified, detection mode can either be Pulsed Amperometry or Integrated Pulsed Amperometry *)
						MatchQ[Lookup[myMapThreadOptions, WaveformProfile], Except[Automatic | Null]],
						Which[

							(* If WaveformProfile is specified as a method object, then directly pull ReferenceElectrodeMode field from it *)
							MatchQ[Lookup[myMapThreadOptions, WaveformProfile], ObjectP[Object[Method, Waveform]]],
							Lookup[fetchPacketFromCache[Download[Lookup[myMapThreadOptions, WaveformProfile], Object], fullCache], ReferenceElectrodeMode],

							(* If WaveformProfile is specified as multiple method objects, then track ReferenceElectrodeMode of all methods and use ReferenceElectrodeMode from the first method *)
							MatchQ[Lookup[myMapThreadOptions, WaveformProfile], {{TimeP, ObjectP[Object[Method, Waveform]]}...}],
							Lookup[fetchPacketFromCache[Download[Lookup[myMapThreadOptions, WaveformProfile][[1, 2]], Object], fullCache], ReferenceElectrodeMode],

							True,
							AgCl
						],

						(* If WaveformProfile is specified, detection mode can either be Pulsed Amperometry or Integrated Pulsed Amperometry *)
						MatchQ[injectionTableWaveformEntry, Except[Automatic | Null]],
						Which[
							(* If WaveformProfile is specified in the injection table, download the method and pull ReferenceElectrodeMode *)
							MatchQ[injectionTableWaveformEntry, ObjectP[Object[Method, Waveform]]],
							Lookup[fetchPacketFromCache[Download[injectionTableWaveformEntry, Object], fullCache], ReferenceElectrodeMode],

							(* If WaveformProfile is specified as multiple method objects in the injection table, then track ReferenceElectrodeMode of all methods and use ReferenceElectrodeMode from the first method *)
							MatchQ[injectionTableWaveformEntry, {{TimeP, ObjectP[Object[Method, Waveform]]}...}],
							Lookup[fetchPacketFromCache[Download[injectionTableWaveformEntry, Object], fullCache], ReferenceElectrodeMode],

							True,
							AgCl
						],

						(* If WaveformProfile is specified as tuples of {Time,Voltage,Boolean,Boolean} or {Time, {Time,Voltage,Boolean,Boolean}}, either in the option or in the injection table *)
						(* And this option is not specified, then go ahead and set reference electrode mode to AgCl *)
						True,
						AgCl
					];

					voltageProfile = Which[

						(* If the user is not using DC Amperometry, set it to Null *)
						!MatchQ[electrochemicalDetectionMode, DCAmperometricDetection],
						Null,

						(* If the user has specified voltage profile, go with it *)
						MatchQ[Lookup[myMapThreadOptions, VoltageProfile], Except[Automatic | Null]],
						Lookup[myMapThreadOptions, VoltageProfile],

						(* If the user has specified voltage profile in the injection table, go with it *)
						MatchQ[injectionTableVoltageEntry, Except[Automatic | Null]],
						injectionTableVoltageEntry,

						(* If the user has specified voltage profile in the injection table, go with it *)
						MatchQ[injectionTableWaveformEntry, Except[Automatic | Null]],
						injectionTableWaveformEntry,

						(* Otherwise, set it to 0.1 Volt throughout the whole gradient *)
						True,
						0.1 Volt
					];

					(* We need to check that the time specified in VoltageProfile is monotonically increasing *)
					voltageProfileDuplicateTimeQ = Module[{timeDifferences},
						(* This check only makes sense when VoltageProfile is specified as tuples in the form of {Time,Voltage} *)
						If[MatchQ[voltageProfile, {{TimeP, VoltageP}...}],
							timeDifferences = Differences[voltageProfile[[All, 1]]];
							If[MatchQ[timeDifferences, {GreaterP[0 * Second]...}],
								False,
								True
							],
							False
						]
					];

					waveformProfile = Which[

						(* If the user is using DC Amperometry, set it to Null *)
						MatchQ[electrochemicalDetectionMode, DCAmperometricDetection],
						Null,

						(* If the user has specified waveform profile, go with it *)
						MatchQ[Lookup[myMapThreadOptions, WaveformProfile], Except[Automatic]],
						Lookup[myMapThreadOptions, WaveformProfile],

						(* If the user has specified waveform profile in the injection table, go with it *)
						MatchQ[injectionTableWaveformEntry, Except[Automatic | Null]],
						injectionTableWaveformEntry,

						(* If nothing is specified, then first we look at the ElectrochemicalDetectionMode *)
						True,
						Which[

							(* If the detection mode is PulsedAmperometricDetection *)
							MatchQ[electrochemicalDetectionMode, PulsedAmperometricDetection],

							If[MatchQ[fetchPacketFromCache[Download[resolvedWorkingElectrode, Object], fullCache], <||> | Null],
								Null,
								(* Then we look at the coat material of the working electrode and give default waveform *)
								Switch[
									Lookup[workingElectrodeModelPacket, CoatMaterial],

									Gold,
									Values[Lookup[fetchPacketFromCache[Download[Object[Method, Waveform, "Gold Electrode Quad Potential for Carbohydrate Analysis"], Object], fullCache], Waveform]],

									Silver,
									Values[Lookup[fetchPacketFromCache[Download[Object[Method, Waveform, "Silver Electrode for Sulfide, Cyanide, Iodide, Thiosulface Analysis"], Object], fullCache], Waveform]],

									Platinum,
									Values[Lookup[fetchPacketFromCache[Download[Object[Method, Waveform, "Platinum Electrode for Alcohols, Glycols, Carboxylates, Cyanide, Sulfide Analysis"], Object], fullCache], Waveform]],

									_,
									Null
								]
							],

							(* If the detection mode is IntegratedPulsedAmperometricDetection *)
							MatchQ[electrochemicalDetectionMode, IntegratedPulsedAmperometricDetection],

							(* Then we look at the coat material of the working electrode and give default waveform *)
							If[MatchQ[fetchPacketFromCache[Download[resolvedWorkingElectrode, Object], fullCache], <||> | Null],
								Null,
								Switch[
									Lookup[workingElectrodeModelPacket, CoatMaterial],

									Gold,
									Object[Method, Waveform, "Gold AAA Electrode for Amino Acids, Carbohydrates, Water Soluble Vitamins Analysis"],

									_,
									Null
								]
							],

							True,
							Null
						]
					];

					(* We need to check that the time specified in WaveformProfile is monotonically increasing *)
					waveformProfileDuplicateTimeQ = Module[{waveformTimeDifferences, retentionTimeDifferences},
						Which[
							(* We first check the waveform times specified as tuples in the form of {Time,Voltage,Interpolation,Integration} *)
							MatchQ[waveformProfile, {{TimeP, VoltageP, BooleanP, BooleanP}...}],
							waveformTimeDifferences = Differences[waveformProfile[[All, 1]]];
							If[MatchQ[waveformTimeDifferences, {GreaterP[0 * Second]...}],
								False,
								True
							],

							(* Then we check the waveform times as well as retention times specified as tuples in the form of {Time,{Time,Voltage,Interpolation,Integration}} *)
							MatchQ[waveformProfile, {{TimeP, {{TimeP, VoltageP, BooleanP, BooleanP}...}...}...}],
							waveformTimeDifferences = Differences /@ ((Last /@ waveformProfile)[[All, All, 1]]);
							retentionTimeDifferences = Differences[First /@ waveformProfile];
							If[MatchQ[waveformTimeDifferences, {{GreaterP[0 * Second]...}...}] && MatchQ[retentionTimeDifferences, {GreaterP[0 * Second]...}],
								False,
								True
							],

							(* Finally we check waveform times specified in the form of {Time, Object[Method,Waveform]} *)
							MatchQ[waveformProfile, {{TimeP, ObjectP[Object[Method, Waveform]]}...}],
							retentionTimeDifferences = Differences[First /@ waveformProfile];
							If[MatchQ[retentionTimeDifferences, {GreaterP[0 * Second]...}],
								False,
								True
							],

							True,
							False
						]
					];

					(* Before resolving sampling rate, let's first get the waveform duration *)
					waveformDuration = Which[

						(* If the resolved waveform profile consists of a single waveform, grab WaveformDuration from the method object *)
						MatchQ[waveformProfile, ObjectP[Object[Method, Waveform]]],
						Lookup[fetchPacketFromCache[Download[waveformProfile, Object], fullCache], WaveformDuration],

						(* If the resolved waveform profile consists of multiple waveforms, grab WaveformDuration from the first method object *)
						MatchQ[waveformProfile, {{TimeP, ObjectP[Object[Method, Waveform]]}...}],
						Lookup[fetchPacketFromCache[#, fullCache], WaveformDuration]& /@ Download[waveformProfile[[All, 2]], Object],

						(* If the resolved waveform profile consists of a tuple in the form of {Time,Voltage,Boolean,Boolean}, get the last time point to be the waveform duration *)
						MatchQ[waveformProfile, {{TimeP, VoltageP, BooleanP, BooleanP}...}],
						Last[waveformProfile][[1]],

						(* If the resolved waveform profile consists of multiple tuples in the form of {Time,{Time,Voltage,Boolean,Boolean}}, get the last time point of all waveforms *)
						MatchQ[waveformProfile, {{TimeP, {{TimeP, VoltageP, BooleanP, BooleanP}...}...}...}],
						(Last /@ Last /@ waveformProfile)[[All, 1]],

						True,
						Null
					];

					(* We need to check if the specified waveforms have multiple duration *)
					multipleWaveformDurationQ = Module[{uniqueDuration},
						uniqueDuration = DeleteDuplicates[ToList[waveformDuration]];
						(* If so, set the error tracking variable to True, otherwise set it to False *)
						If[Length[uniqueDuration] == 1,
							False,
							True
						]
					];

					electrochemicalSamplingRate = Which[

						(* If the user specified sampling rate for electrochemical detection, go with it *)
						MatchQ[Lookup[myMapThreadOptions, ElectrochemicalSamplingRate], Except[Automatic | Null]],
						Lookup[myMapThreadOptions, ElectrochemicalSamplingRate],

						MatchQ[electrochemicalDetectionMode, Null | {Null}],
						Null,

						(* If the user is using DC Amperometry, set it to 1.67 Hz *)
						MatchQ[electrochemicalDetectionMode, DCAmperometricDetection],
						1.67 / Second,

						(* If the user is using Integrated Amperometry, then we set sampling rate based on the resolved waveform duration *)
						MatchQ[waveformProfile, Except[Null]],
						1 / (Convert[ToList[waveformDuration][[1]], Second]),

						True,
						Null
					];

					detectionTemperature = Which[
						(* If the user specified sampling rate for electrochemical detection, go with it *)
						MatchQ[Lookup[myMapThreadOptions, DetectionTemperature], Except[Automatic | Null]],
						Lookup[myMapThreadOptions, DetectionTemperature],

						MatchQ[electrochemicalDetectionMode, Null | {Null}],
						Null,

						(* Otherwise default to ambient temperature *)
						True,
						Ambient
					];

					Which[

						(* If both UV and Electrochemical Detection are employed, then resolve all options *)
						MemberQ[ToList@resolvedDetector, UVVis] && MemberQ[ToList@resolvedDetector, ElectrochemicalDetector],
						{
							absorbanceWavelength,
							absorbanceSamplingRate,
							electrochemicalDetectionMode,
							referenceElectrodeMode,
							voltageProfile,
							waveformProfile,
							electrochemicalSamplingRate,
							detectionTemperature,
							absorbanceOptionConflictQ,
							electrochemicalOptionConflictQ,
							electrochemicalModeOptionConflictQ,
							multipleDetectionModeQ,
							waveformDetectionModeConflictQ,
							multipleWaveformDurationQ,
							voltageProfileDuplicateTimeQ,
							waveformProfileDuplicateTimeQ
						},

						!MemberQ[ToList@resolvedDetector, UVVis] && MemberQ[ToList@resolvedDetector, ElectrochemicalDetector],
						{
							Null,
							Null,
							electrochemicalDetectionMode,
							referenceElectrodeMode,
							voltageProfile,
							waveformProfile,
							electrochemicalSamplingRate,
							detectionTemperature,
							absorbanceOptionConflictQ,
							electrochemicalOptionConflictQ,
							electrochemicalModeOptionConflictQ,
							multipleDetectionModeQ,
							waveformDetectionModeConflictQ,
							multipleWaveformDurationQ,
							voltageProfileDuplicateTimeQ,
							waveformProfileDuplicateTimeQ
						},

						MemberQ[ToList@resolvedDetector, UVVis] && !MemberQ[ToList@resolvedDetector, ElectrochemicalDetector],
						{
							absorbanceWavelength,
							absorbanceSamplingRate,
							Null,
							Null,
							Null,
							Null,
							Null,
							Null,
							absorbanceOptionConflictQ,
							electrochemicalOptionConflictQ,
							electrochemicalModeOptionConflictQ,
							multipleDetectionModeQ,
							waveformDetectionModeConflictQ,
							multipleWaveformDurationQ,
							voltageProfileDuplicateTimeQ,
							waveformProfileDuplicateTimeQ
						},

						!MemberQ[ToList@resolvedDetector, UVVis] && !MemberQ[ToList@resolvedDetector, ElectrochemicalDetector],
						Join[ConstantArray[Null, 8], ConstantArray[False, 8]]
					]],
					{ToList@mySamples, mapThreadFriendlyElectrochemicalSampleOptions}
				]
				]
			]
		];

		(* === Massive error checks for all UVVis and Electrochemical Detection parameters === *)

		(* 1. Check if absorbance parameter specification is in conflict *)
		(* If the absorbance options are in conflict and we are throwing message, throw an error and collect invalid options *)
		invalidAbsorbanceOptions = If[MemberQ[absorbanceOptionConflictErrors, True] && messagesQ,
			(
				Message[Error::InvalidAbsorbanceOption, {AbsorbanceWavelength, AbsorbanceSamplingRate}];
				{AbsorbanceWavelength, AbsorbanceSamplingRate}
			),
			{}
		];

		(* Test for absorbance options *)
		absorbanceOptionTest = testOrNullIndexMatched["The absorbance options are both not Null if Detector is set to UVVis:", ToList@mySamples, absorbanceOptionConflictErrors];

		(* 1.1 Check if absorbance parameter specification is in conflict *)
		(* If the absorbance options are in conflict and we are throwing message, throw an error and collect invalid options *)
		invalidElectrochemicalOptions = If[MemberQ[ToList@electrochemicalOptionConflictErrors, True] && messagesQ,
			(
				Message[Error::InvalidElectrochemicalOption, {ElectrochemicalDetectionMode, ReferenceElectrodeMode, ElectrochemicalSamplingRate, DetectionTemperature}];
				{ElectrochemicalDetectionMode, ReferenceElectrodeMode, ElectrochemicalSamplingRate, DetectionTemperature}
			),
			{}
		];

		(* Test for absorbance options *)
		electrochemicalOptionTest = testOrNullIndexMatched["The electrochemical options are not set to Null if Detector is set to ElectrochemicalDetector:", ToList@mySamples, electrochemicalOptionConflictErrors];


		(* 2. Check if electrochemical detection mode related paramter specification is in conflict *)
		(* Specifically if ElectrochemicalDetectionMode is DCAmperometricDetection, then VoltageProfile cannot be Null; if it's any other mode, then WaveformProfile cannot be Null *)
		(* If the electrochemical detection options are in conflict and we are throwing message, throw an error and collect invalid options *)
		invalidElectrochemicalDetectionModeOptions = If[MemberQ[ToList@electrochemicalModeOptionConflictErrors, True] && messagesQ,
			(
				Message[Error::InvalidElectrochemicalDetectionModeOption, ElectrochemicalDetectionMode, VoltageProfile, WaveformProfile];
				{ElectrochemicalDetectionMode, VoltageProfile, WaveformProfile}
			),
			{}
		];

		(* Test for absorbance options *)
		electrochemicalModeOptionTest = testOrNullIndexMatched["The electrochemical detection mode options are set correctly. If detection mode is DCAmperometricDetection, VoltageProfile cannot be Null; If detection mode is any other amperometric detection, WaveformProfile cannot be Null:", ToList@mySamples, electrochemicalModeOptionConflictErrors];

		(* 3. Check if the specified waveforms render several detection modes *)
		(* If the waveform specified give more than 1 electrochemical detection mode and we are throwing message, throw a warning *)
		multipleDetectionModeOptions = If[MemberQ[multipleDetectionModeErrors, True] && messagesQ && notInEngine,
			(
				Message[Warning::MultipleElectrochemicalDetectionModes, WaveformProfile, ElectrochemicalDetectionMode];
				{}
			),
			{}
		];

		(* Test for absorbance options *)
		multipleDetectionModeOptionTest = warningOrNullIndexMatched["The specified waveforms in WaveformProfile option or in the injection table have a unique ElectrochemicalDetectionMode value:", ToList@mySamples, multipleDetectionModeErrors];

		(* 4. Check if the specified waveforms and the specified detection modes are consistent *)
		(* If the two options have conflicting values, throw an error and collect invalid options *)
		invalidWaveformDetectionModeOptions = If[MemberQ[waveformDetectionModeErrors, True] && messagesQ,
			(
				Message[Error::ConflictingElectrochemicalDetectionModes, WaveformProfile, ElectrochemicalDetectionMode];
				{WaveformProfile, ElectrochemicalDetectionMode}
			),
			{}
		];

		(* Test for absorbance options *)
		invalidWaveformDetectionModeTest = testOrNullIndexMatched["The specified waveforms in WaveformProfile option or in the injection table have consistent ElectrochemicalDetectionMode:", ToList@mySamples, multipleDetectionModeErrors];

		(* 5. Check if the specified waveforms have the same duration *)
		multipleWaveformDurationSamples = PickList[ToList@mySamples, multipleWaveformDurationErrors, True];

		(* If the specified waveforms have different duration and we are throwing messages, throw an error and collect invalid options *)
		multipleWaveformDurationOptions = If[MemberQ[multipleWaveformDurationErrors, True] && messagesQ,
			(
				Message[Error::MultipleWaveformDuration, ObjectToString[multipleWaveformDurationSamples, Cache -> fullCache, Simulation -> updatedSimulation], ObjectToString[resolvedInstrument,Cache -> fullCache, Simulation -> updatedSimulation]];
				{WaveformProfile, ElectrochemicalSamplingRate}
			),
			{}
		];

		(* Test for absorbance options *)
		multipleWaveformDurationTest = testOrNullIndexMatched["The specified waveforms all have the same waveform duration:", ToList@mySamples, Not[multipleWaveformDurationErrors]];

		(* 6. Check if the times specified in voltage profile is monotonically increasing *)
		(* If the specified voltage profile has duplicate or decreasing time and we are throwing messages, throw an error and collect invalid options *)
		voltageProfileTimeOptions = If[MemberQ[duplicateVoltageProfileTimeErrors, True] && messagesQ,
			(
				Message[Error::InvalidTimeSpecification, VoltageProfile];
				{VoltageProfile}
			),
			{}
		];

		(* Test for absorbance options *)
		voltageProfileTimeTest = testOrNullIndexMatched["The specified VoltageProfile in the form of {Time,Voltage} have monotonically increasing time:", ToList@mySamples, Not[duplicateVoltageProfileTimeErrors]];

		(* 6. Check if the times specified in voltage profile is monotonically increasing *)
		(* If the specified voltage profile has duplicate or decreasing time and we are throwing messages, throw an error and collect invalid options *)
		waveformProfileTimeOptions = If[MemberQ[duplicateWaveformProfileTimeErrors, True] && messagesQ,
			(
				Message[Error::InvalidTimeSpecification, WaveformProfile];
				{WaveformProfile}
			),
			{}
		];

		(* Test for absorbance options *)
		waveformProfileTimeTest = testOrNullIndexMatched["The specified WaveformProfile in the form of {Time,Voltage,Interpolation,Integration} or {Time,{Time,Voltage,Interpolation,Integration}} have monotonically increasing time:", ToList@mySamples, Not[duplicateWaveformProfileTimeErrors]];



		(* Set these variables for later use in referrring to whether AnionStandard and CationStandard exist *)
		anionStandardExistQ = !MatchQ[resolvedAnionStandard, {} | Null | {Null}];
		cationStandardExistQ = !MatchQ[resolvedCationStandard, {} | Null | {Null}];

		(* Setting up the map friendly options for Anion and Cation Standard here *)
		(* Generate MapThread friendly option for AnionStandard, similar to OptionsHandling`Private`mapThreadOptions. *)
		mapThreadFriendlyAnionStandardOptions = If[Length[ToList@resolvedAnionStandard] > 0,
			If[MatchQ[imbalancedStandardAnionCationGroupingErrors, True],
				{},

				Transpose[Map[
					Function[{options},
						Module[{optionSymbol, optionValues, optionSymbolList, optionValuesList},
							(* Separate out the option symfbol from the option values. *)
							optionSymbol = options[[1]];
							optionValues = options[[2]];

							(* Get a list of optionSymbol that is the same length as optionValue. *)
							If[MatchQ[Length[ToList@optionValues], Length[ToList@resolvedAnionStandard]],
								optionSymbolList = ConstantArray[optionSymbol, Length[ToList@optionValues]];optionValuesList = ToList@optionValues,
								optionSymbolList = ConstantArray[optionSymbol, Length[ToList@resolvedAnionStandard]];optionValuesList = ConstantArray[optionValues, Length[ToList@resolvedAnionStandard]]
							];

							MapThread[
								(#1 -> #2&),
								{optionSymbolList, optionValuesList}
							]
						]
					],
					extractedAnionStandardOptions
				]]
			],
			{}
		];

		(* Generate MapThread friendly option for CationStandard, similar to OptionsHandling`Private`mapThreadOptions. *)
		mapThreadFriendlyCationStandardOptions = If[Length[ToList@resolvedCationStandard] > 0,
			If[MatchQ[imbalancedStandardAnionCationGroupingErrors, True],
				{},

				Transpose[Map[
					Function[{options},
						Module[{optionSymbol, optionValues, optionSymbolList, optionValuesList},
							(* Separate out the option symfbol from the option values. *)
							optionSymbol = options[[1]];
							optionValues = options[[2]];

							(* Get a list of optionSymbol that is the same length as optionValue. *)
							If[MatchQ[Length[ToList@optionValues], Length[ToList@resolvedCationStandard]],
								optionSymbolList = ConstantArray[optionSymbol, Length[ToList@optionValues]];optionValuesList = ToList@optionValues,
								optionSymbolList = ConstantArray[optionSymbol, Length[ToList@resolvedCationStandard]];optionValuesList = ConstantArray[optionValues, Length[ToList@resolvedCationStandard]]
							];

							MapThread[
								(#1 -> #2&),
								{optionSymbolList, optionValuesList}
							]
						]
					],
					extractedCationStandardOptions
				]]
			],
			{}
		];

		(* Generate MapThread friendly option for Standard for electrochemical detection, similar to OptionsHandling`Private`mapThreadOptions. *)
		mapThreadFriendlyElectrochemicalStandardOptions = If[MemberQ[ToList@doubleResolvedStandardAnalysisChannel, ElectrochemicalChannel],
			Transpose[Map[
				Function[{options},
					Module[{optionSymbol, optionValues, optionSymbolList, optionValuesList},
						(* Separate out the option symfbol from the option values. *)
						optionSymbol = options[[1]];
						optionValues = options[[2]];

						(* Get a list of optionSymbol that is the same length as optionValue. *)
						If[MatchQ[Length[ToList@optionValues], Length[ToList@resolvedStandard]],
							optionSymbolList = ConstantArray[optionSymbol, Length[ToList@optionValues]];optionValuesList = ToList@optionValues,
							optionSymbolList = ConstantArray[optionSymbol, Length[ToList@resolvedStandard]];optionValuesList = ConstantArray[optionValues, Length[ToList@resolvedStandard]]
						];

						MapThread[
							(#1 -> #2&),
							{optionSymbolList, optionValuesList}
						]
					]
				],
				extractedElectrochemicalStandardOptions
			]],
			{}
		];

		(* 33. AnionStandardFrequency and CationStandardFrequency Resolution *)

		(* If injecting a standard, resolve StandardFrequency based on option value or default to FirstAndLast *)
		resolvedAnionStandardFrequency = If[MatchQ[resolvedAnionStandard, {} | Null | {Null}],

			Null,

			If[MatchQ[specifiedAnionStandardFrequency, Except[Automatic]],
				specifiedAnionStandardFrequency,
				Which[
					(*if there is an injection table, then set to null*)
					MatchQ[anionInjectionTableLookupRounded, Except[Automatic]], Null,
					(*if we have standards otherwise, then we can do FirstAndLast*)
					anionStandardExistQ, FirstAndLast,
					(*otherwise, nothing*)
					True, None
				]
			]
		];

		(* == Error Checking == *)
		(* Don't need this error - it is already covered by StandardOptionConflict
        (* Check to see if AnionStandardFrequency is set if there are resolved AnionStandard *)

        (* If AnionStandardFrequency is set to Null or None AND if we are throwing messages, throw an error and collect invalid options *)
        noAnionStandardFrequencyButStandardsOptions=If[noAnionStandardFrequencyButStandardsQ&&messagesQ,
            (
                Message[Error::StandardsButNoFrequency];
                {AnionStandardFrequency,AnionStandard}
            ),
            {}
        ];

        (* Generate test for checking AnionStandardFrequency *)
        noAnionStandardFrequencyButStandardsTests=testOrNull["If AnionStandardFrequency is set, the AnionStandard option is not Null:",Not[noAnionStandardFrequencyButStandardsQ]]; *)


		(* If injecting a standard, resolve StandardFrequency based on option value or default to FirstAndLast *)
		resolvedCationStandardFrequency = If[MatchQ[resolvedCationStandard, {} | Null | {Null}],

			(* If there is no resolvedCationStandard, set the option to Null and error tracking variables to False *)
			Null,

			If[MatchQ[specifiedCationStandardFrequency, Except[Automatic]],
				specifiedCationStandardFrequency,
				Which[
					(*if there is an injection table, then set to null*)
					MatchQ[cationInjectionTableLookupRounded, Except[Automatic]], Null,
					(*if we have standards otherwise, then we can do FirstAndLast*)
					cationStandardExistQ, FirstAndLast,
					(*otherwise, nothing*)
					True, None
				]
			]
		];

		(* == Error Checking == *)
		(* Same here - covered by StandardOptionConflict
        (* Check to see if CationStandardFrequency is set if there are resolved CationStandard *)

        (* If CationStandardFrequency is set to Null or None AND if we are throwing messages, throw an error and collect invalid options *)
        noCationStandardFrequencyButStandardsOptions=If[noCationStandardFrequencyButStandardsQ&&messagesQ,
            (
                Message[Error::StandardsButNoFrequency];
                {CationStandardFrequency,CationStandard}
            ),
            {}
        ];

        (* Generate test for checking CationStandardFrequency *)
        noCationStandardFrequencyButStandardsTests=testOrNull["If CationStandardFrequency is set, the CationStandard option is not Null:",Not[noCationStandardFrequencyButStandardsQ]]; *)

		(* Set these variables for later use in referrring to whether the protocol has Standards for Electrochemical Detection *)
		electrochemicalStandardExistQ = !MatchQ[resolvedStandard, {} | Null | {Null}] && MemberQ[ToList@resolvedStandardAnalysisChannel, ElectrochemicalChannel];

		(* If injecting a standard, resolve StandardFrequency based on option value or default to FirstAndLast *)
		resolvedStandardFrequency = If[!MemberQ[ToList@resolvedStandardAnalysisChannel, ElectrochemicalChannel],

			(* If there is no resolvedCationStandard, set the option to Null and error tracking variables to False *)
			Null,

			If[MatchQ[specifiedStandardFrequency, Except[Automatic]],
				specifiedStandardFrequency,
				Which[
					(*if there is an injection table, then set to null*)
					MatchQ[electrochemicalInjectionTableLookupRounded, Except[Automatic]], Null,
					(*if we have standards otherwise, then we can do FirstAndLast*)
					electrochemicalStandardExistQ, FirstAndLast,
					(*otherwise, nothing*)
					True, None
				]
			]
		];

		(* 34. StandardInjectionVolume resolution *)

		(* resolve the InjectionVolume option *)
		resolvedAnionStandardInjectionVolume = Module[{injectionTableStandardInjectionVolume, anionInjectionTableStandardList, anionInjectionTableLookupWithID},

			If[MatchQ[resolvedAnionStandard, Null | {} | {Null}],

				{},

				MapThread[
					Function[{mySample, myMapThreadOptions},

						anionInjectionTableStandardList = Cases[anionInjectionTableLookupRounded, {Standard, sample_, ___} :> Download[sample, Object]];
						anionInjectionTableLookupWithID = MapThread[ReplacePart[#1, 2 -> #2]&, {Cases[anionInjectionTableLookupRounded, {Standard, ___}], anionInjectionTableStandardList}];

						(*we need to extract out the injection volume from the injection table*)
						injectionTableStandardInjectionVolume = If[anionInjectionTableSpecifiedQ,
							Cases[anionInjectionTableLookupWithID, {Standard, Download[mySample, Object] | mySample, _, injectionVolume_, _} :> injectionVolume],

							(*otherwise pad automatic*)
							Automatic
						];

						Which[
							(*user specified*)
							MatchQ[Lookup[myMapThreadOptions, AnionStandardInjectionVolume], ListableP[VolumeP]], Lookup[myMapThreadOptions, AnionStandardInjectionVolume],
							(*injectionTable specified*)
							MatchQ[injectionTableStandardInjectionVolume, ListableP[VolumeP]], Sequence @@ injectionTableStandardInjectionVolume,
							MatchQ[resolvedAnionInjectionVolume, Null | {} | {Null}], 10 Microliter,
							(*otherwise, use the first value of the resolved injection volume for the sample *)
							True, resolvedAnionInjectionVolume[[1]]
						]
					],
					{
						ToList@resolvedAnionStandard, mapThreadFriendlyAnionStandardOptions
					}
				]
			]
		];

		(* resolve the InjectionVolume option *)
		resolvedCationStandardInjectionVolume = Module[{injectionTableStandardInjectionVolume, cationInjectionTableStandardList, cationInjectionTableLookupWithID},

			If[MatchQ[resolvedCationStandard, Null | {} | {Null}],

				{},

				MapThread[
					Function[{mySample, myMapThreadOptions},

						cationInjectionTableStandardList = Cases[cationInjectionTableLookupRounded, {Standard, sample_, ___} :> Download[sample, Object]];
						cationInjectionTableLookupWithID = MapThread[ReplacePart[#1, 2 -> #2]&, {Cases[cationInjectionTableLookupRounded, {Standard, ___}], cationInjectionTableStandardList}];

						(*we need to extract out the injection volume from the injection table*)
						injectionTableStandardInjectionVolume = If[cationInjectionTableSpecifiedQ,
							Cases[cationInjectionTableLookupWithID, {Standard, Lookup[fetchPacketFromCache[mySample, fullCache], Object] | mySample, _, injectionVolume_, _} :> injectionVolume],

							(*otherwise pad automatic*)
							Automatic
						];

						Which[
							(*user specified*)
							MatchQ[Lookup[myMapThreadOptions, CationStandardInjectionVolume], ListableP[VolumeP]], Lookup[myMapThreadOptions, CationStandardInjectionVolume],
							(*injectionTable specified*)
							MatchQ[injectionTableStandardInjectionVolume, ListableP[VolumeP]], Sequence @@ injectionTableStandardInjectionVolume,
							(*otherwise, use the first value of the resolved injection volume for the sample *)
							MatchQ[resolvedCationInjectionVolume, Null | {} | {Null}], 10 Microliter,
							True, resolvedCationInjectionVolume[[1]]
						]
					],
					{
						ToList@resolvedCationStandard, mapThreadFriendlyCationStandardOptions
					}
				]
			]
		];

		(* resolve the InjectionVolume option *)
		resolvedStandardInjectionVolume = Module[{injectionTableStandardInjectionVolume, electrochemicalInjectionTableStandardList, electrochemicalInjectionTableLookupWithID},

			If[!electrochemicalStandardExistQ,

				{},

				MapThread[
					Function[{mySample, myMapThreadOptions},

						electrochemicalInjectionTableStandardList = Cases[electrochemicalInjectionTableLookupRounded, {Standard, sample_, ___} :> Download[sample, Object]];
						electrochemicalInjectionTableLookupWithID = MapThread[ReplacePart[#1, 2 -> #2]&, {Cases[electrochemicalInjectionTableLookupRounded, {Standard, ___}], electrochemicalInjectionTableStandardList}];

						(*we need to extract out the injection volume from the injection table*)
						injectionTableStandardInjectionVolume = If[electrochemicalInjectionTableSpecifiedQ,
							Cases[electrochemicalInjectionTableLookupWithID, {Standard, Lookup[fetchPacketFromCache[mySample, fullCache], Object] | mySample, _, injectionVolume_, _, _, _} :> injectionVolume],

							(*otherwise pad automatic*)
							Automatic
						];

						Which[
							(*user specified*)
							MatchQ[Lookup[myMapThreadOptions, StandardInjectionVolume], ListableP[VolumeP]], Lookup[myMapThreadOptions, StandardInjectionVolume],
							(*injectionTable specified*)
							MatchQ[injectionTableStandardInjectionVolume, ListableP[VolumeP]], Sequence @@ injectionTableStandardInjectionVolume,
							(*otherwise, use the first value of the resolved injection volume for the sample *)
							MatchQ[resolvedInjectionVolume, Null | {} | {Null}], 25 Microliter,
							True, resolvedInjectionVolume[[1]]
						]
					],
					{
						ToList@resolvedStandard, mapThreadFriendlyElectrochemicalStandardOptions
					}
				]
			]
		];

		(* == Error Checking == *)
		(* No need to do erro checks here because the upper bound is already set in the widget
        (* Check whether the specified sample temperature is within the range of allowed temperature of the instrument's autosampler *)
        validAnionStandardVolumeQ=If[!MatchQ[resolvedAnionStandardInjectionVolume,{}|Null],
            Not[Between[#,{minSampleVolume,maxSampleVolume}]]&/@resolvedAnionStandardInjectionVolume,
            False
        ];
        validCationStandardVolumeQ=If[!MatchQ[resolvedCationStandardInjectionVolume,{}|Null],
            Not[Between[#,{minSampleVolume,maxSampleVolume}]]&/@resolvedCationStandardInjectionVolume,
            False
        ];

        (* Pick out sample objects that have incompatible injection volume *)
        invalidAnionStandardInjectionVolumeObjects=If[!MatchQ[resolvedAnionStandard,{}|Null],
            PickList[ToList@resolvedAnionStandard,validAnionStandardVolumeQ,True],
            {}
        ];
        invalidCationStandardInjectionVolumeObjects=If[!MatchQ[resolvedCationStandard,Null|{}],
            PickList[ToList@resolvedCationStandard,validCationStandardVolumeQ,True],
            {}
        ];

        (* If the sample temperature is not compatible, and we are throwing messages, throw error message and collect invalid sample temperature option *)
        invalidAnionStandardSampleVolumeOption=If[(Or@@validAnionStandardVolumeQ)&&messagesQ,
            (
                Message[Error::IncompatibleInjectionVolume,invalidAnionStandardInjectionVolumeObjects,ObjectToString[resolvedInstrument,Cache -> fullCache, Simulation -> updatedSimulation],maxSampleVolume];
                {AnionStandardInjectionVolume}
            ),
            {}
        ];
        invalidCationStandardSampleVolumeOption=If[(Or@@validCationStandardVolumeQ)&&messagesQ,
            (
                Message[Error::IncompatibleInjectionVolume,invalidCationStandardInjectionVolumeObjects,ObjectToString[resolvedInstrument,Cache -> fullCache, Simulation -> updatedSimulation],maxSampleVolume];
                {CationStandardInjectionVolume}
            ),
            {}
        ];

        (* Generate tests for compatible injection volume *)
        validAnionStandardInjectionVolumeTests=If[!NullQ[resolvedAnionStandard],
            testOrNullIndexMatched["Specified anion standard injectionVolume is within the range of the allowed injection volume of the instrument:",ToList@resolvedAnionStandard,validAnionStandardVolumeQ],
            Nothing
        ];
        validCationStandardInjectionVolumeTests=If[!NullQ[resolvedCationStandard],
            testOrNullIndexMatched["Specified cation standard injectionVolume is within the range of the allowed injection volume of the instrument:",ToList@resolvedCationStandard,validCationStandardVolumeQ],
            Nothing
        ]; *)

		(* 35. AnionStandard related option resolution: AnionStandardGradientDuration, AnionStandardFlowRate,StandardEluentGradient,AnionStandardGradient *)

		(* Resolution of gradient related options *)
		{
			resolvedAnionStandardGradient,
			resolvedAnionStandardGradientStart,
			resolvedAnionStandardGradientEnd,
			resolvedAnionStandardGradientDuration,
			resolvedAnionStandardFlowRate,
			resolvedStandardEluentGradient,
			anionStandardGradientConsistentErrors,
			anionStandardGradientStartEndSpecifiedErrors,
			anionStandardDurationOptionSpecifiedErrors,
			invalidAnionStandardGradientCompositionErrors,
			anionStandardRemovedExtraErrors,
			overwriteAnionStandardGradientBool,
			anionStandardDurationConsistentErrors,
			anionStandardFlowRateErrors
		} = Module[{
			standardEluentGradientLookup, anionStandardGradientDurationLookup, anionStandardGradientLookup, anionStandardFlowRateLookup, anionInjectionTableStandardRoundedGradient,
			anionStandardGradientConsistentQ, anionStandardRemovedExtrasQ, protoAnionStandardGradientOptionTuple, anionStandardGradientOptionTuple, anionStandardGradientStartLookup,
			anionStandardGradientEndLookup, defaultedAnionFlowRate, anionStandardGradientReturned, initiallyResolvedAnionStandardGradient, invalidAnionStandardGradientCompositionQ,
			standardEluentGradient, anionStandardFlowRate, anionStandardGradient, overwriteAnionStandardGradientQ, anionInjectionTableWithID, incompatibleAnionStandardFlowRateQ,
			anionStandardGradientStartEndSpecifiedQ, anionStandardGradientStart, anionStandardGradientEnd, anionStandardDurationOptionsSpecifiedQ, anionStandardDurationConsistentQ,
			individualGradientSpecifiedQ, individualStandardGradientNullQ
		},

			If[!anionStandardExistQ || MatchQ[mapThreadFriendlyAnionStandardOptions, Null],
				(* If there is no resolvedAnionStandard, then set all anion gradient related options to Null, and all error tracking variable to False *)
				Join[ConstantArray[Null, 6], ConstantArray[False, 8]],

				(* Otherwise, run this giant map thread to resolve all anion gradient related options *)
				Transpose[MapThread[Function[{mySample, myMapFriendlyOptions},

					(* Look up the values of each options in the list *)
					{
						standardEluentGradientLookup,
						anionStandardGradientStartLookup,
						anionStandardGradientEndLookup,
						anionStandardGradientDurationLookup,
						anionStandardGradientLookup,
						anionStandardFlowRateLookup
					} = Lookup[myMapFriendlyOptions, {
						StandardEluentGradient,
						AnionStandardGradientStart,
						AnionStandardGradientEnd,
						AnionStandardGradientDuration,
						AnionStandardGradient,
						AnionStandardFlowRate
					}];

					(* Setup: We first get the injection table gradients *)
					anionInjectionTableStandardRoundedGradient = If[MatchQ[anionInjectionTableLookupRounded, Except[Automatic]],

						anionInjectionTableWithID = Map[
							If[MatchQ[#[[2]], ObjectP[]],
								Join[ToList@#[[1]], ToList@Download[#[[2]], Object], #[[3 ;; 5]]],
								#
							]&,
							anionInjectionTableLookupRounded
						];

						(* Extract the gradient specified in InjectionTable *)
						Cases[anionInjectionTableWithID, {Standard, Download[mySample, Object] | mySample, _, _, gradient_} :> gradient],

						(* If InjectionTable is not specified or has conflict with input samples, pad it with Automatics*)
						Automatic
					];

					(* First we need to make sure that the start and end options are either all specified or not *)
					anionStandardGradientStartEndSpecifiedQ = !MatchQ[{anionStandardGradientStartLookup, anionStandardGradientEndLookup}, {ConcentrationP, ConcentrationP} | {Automatic | Null, Automatic | Null}];

					(* Then we need to make sure that the duration is specified either with start & end, or with eluent gradient *)
					anionStandardDurationOptionsSpecifiedQ = If[MatchQ[anionStandardGradientDurationLookup, TimeP],
						Not[MatchQ[{anionStandardGradientStartLookup, anionStandardGradientEndLookup}, {ConcentrationP, ConcentrationP}] || MatchQ[standardEluentGradientLookup, ConcentrationP]],
						False
					];

					(* Need to check if any of the individual gradient is specified in {Time,Percent} format *)
					individualGradientSpecifiedQ = MatchQ[standardEluentGradientLookup, Except[Automatic | ConcentrationP]];

					(* We also need to check if Duration specification is consistent with individual gradient *)
					anionStandardDurationConsistentQ = If[individualGradientSpecifiedQ,

						If[MatchQ[anionStandardGradientDurationLookup, TimeP],
							True,
							False
						],
						(* If none of the individual gradient is specified, then leave this error tracking variable to False *)
						False
					];

					(* If gradient is specied as a method object, check whether AnionStandardGradient and the injection table specify the same object*)
					anionStandardGradientConsistentQ = If[MatchQ[anionStandardGradientLookup, ObjectP[Object[Method, IonChromatographyGradient]]] && MatchQ[anionInjectionTableStandardRoundedGradient, {ObjectP[Object[Method, IonChromatographyGradient]]}],
						Not[MatchQ[ToList@Download[anionStandardGradientLookup, Object], Download[anionInjectionTableStandardRoundedGradient, Object]]],
						False
					];

					(* Extract or default GradientStart and GradientEnd values *)
					{anionStandardGradientStart, anionStandardGradientEnd} = Switch[{anionStandardGradientStartLookup, anionStandardGradientEndLookup, anionStandardGradientDurationLookup},

						(* If valid anionGradientStart and anionGradientEnd are given, go with that *)
						{ConcentrationP, ConcentrationP, _} | {Null, Null, Null | TimeP}, {anionStandardGradientStartLookup, anionStandardGradientEndLookup},

						(* Default to anionGradientStart if something is wrong with gradientEnd *)
						{ConcentrationP, _, _}, {anionStandardGradientStartLookup, anionStandardGradientStartLookup},

						(* Default to 0 Millimolar if something is wrong with anionGradeintStart *)
						{_, ConcentrationP, _}, {0 Millimolar, anionStandardGradientEndLookup},

						(* Otherwise, both Null*)
						_, {Null, Null}
					];

					(* If Gradient option is an object, pull Gradient value from packet *)
					protoAnionStandardGradientOptionTuple = Which[

						(* If AnionStandardGradient specifies a method object, extract Gradient information from the packet *)
						MatchQ[anionStandardGradientLookup, ObjectP[Object[Method, IonChromatographyGradient]]],
						Lookup[fetchPacketFromCache[Download[anionStandardGradientLookup, Object], fullCache], AnionGradient],

						(* If InjectionTable specifies a method object, extract Gradient information from the packet *)
						MatchQ[anionStandardGradientLookup, Automatic] && MatchQ[anionInjectionTableStandardRoundedGradient, ObjectP[Object[Method, IonChromatographyGradient]]],
						Lookup[fetchPacketFromCache[Download[anionInjectionTableStandardRoundedGradient, Object], fullCache], AnionGradient],

						(* Otherwise, namely if anionGradient is not a method object, then use what's specified in AnionGradient *)
						True, anionStandardGradientLookup
					];

					(* Update AnionStandardlowRate in the gradient method object if the option is specified *)
					anionStandardGradientOptionTuple = If[MatchQ[anionStandardFlowRateLookup, Except[Automatic]],

						(* If AnionStandardFlowRate is specified, use the specified flow rate and replace the default flowrate of the method object *)
						(* In IonChromatography Gradient method, AnionStandardGradient goes "Time", "Eluent Concentration", "FlowRate". FlowRate is in the third column *)
						ReplacePart[protoAnionStandardGradientOptionTuple, Table[{x, 3} -> anionStandardFlowRateLookup, {x, 1, Length[protoAnionStandardGradientOptionTuple]}]],

						(* Otherwise, use the default flow rate in the gradient object *)
						protoAnionStandardGradientOptionTuple
					];

					(* Default FlowRate to option value, gradient tuple values, or the pre-calculated optimal flow rate for the column *)
					(* note that it's ok to have this flow rate either match FlowRateP, or be a list of pairs of time and flow rate since resolveGradient can handle either *)
					defaultedAnionFlowRate = Which[

						(* If the AnionStandardFlowRate is specified, go with the user specified value *)
						MatchQ[anionStandardFlowRateLookup, Except[Automatic]], anionStandardFlowRateLookup,

						(* If the AnionStandardFlowRate is specified as part of the gradient method object, extract the flow rate from the object *)
						MatchQ[anionStandardGradientOptionTuple, {TimeP, ConcentrationP, FlowRateP}], anionStandardGradientOptionTuple[[All, {1, 3}]],

						(* If no flow rate is specified, use the optional flow rate determined for the column *)
						True, optimalAnionColumnFlowRate
					];

					(* Set up error tracking variable for error messages outside the map thread *)
					incompatibleAnionStandardFlowRateQ = Not[Between[defaultedAnionFlowRate, {minAnionFlowRate, maxAnionFlowRate}]];

					(* finally run our helper resolution function *)
					anionStandardGradientReturned = If[MatchQ[{anionStandardGradientOptionTuple, standardEluentGradientLookup, anionStandardGradientStartLookup, anionStandardGradientEndLookup, anionStandardGradientDurationLookup, anionStandardFlowRateLookup}, {(Null | Automatic)..}] || anionStandardGradientStartEndSpecifiedQ || anionStandardDurationOptionsSpecifiedQ,
						resolveICAnionGradient[defaultAnionGradientIC[defaultedAnionFlowRate], standardEluentGradientLookup, defaultedAnionFlowRate, anionStandardGradientStart, anionStandardGradientEnd, anionStandardGradientDurationLookup],
						resolveICAnionGradient[anionStandardGradientOptionTuple, standardEluentGradientLookup, defaultedAnionFlowRate, anionStandardGradientStart, anionStandardGradientEnd, anionStandardGradientDurationLookup]
					];

					(*remove duplicate entries if need be*)
					initiallyResolvedAnionStandardGradient = DeleteDuplicatesBy[anionStandardGradientReturned, First[# * 1.] &];

					(*if it's not the same note that*)
					anionStandardRemovedExtrasQ = !MatchQ[anionStandardGradientReturned, initiallyResolvedAnionStandardGradient];

					(*check whether the gradient composition adds up to 100 okay*)
					invalidAnionStandardGradientCompositionQ = Not[AllTrue[initiallyResolvedAnionStandardGradient, #[[2]] <= 100 Millimolar&]];

					(*now resolve all of the individual gradients and flow rate*)
					standardEluentGradient = If[MatchQ[initiallyResolvedAnionStandardGradient, {}],

						{},

						If[MatchQ[standardEluentGradientLookup, Automatic],
							collapseGradient[initiallyResolvedAnionStandardGradient[[All, {1, 2}]]],
							standardEluentGradientLookup
						]
					];
					anionStandardFlowRate = If[MatchQ[initiallyResolvedAnionStandardGradient, {}],

						{},
						If[MatchQ[anionStandardFlowRateLookup, Automatic],
							collapseGradient[initiallyResolvedAnionStandardGradient[[All, {1, -1}]]],
							anionStandardFlowRateLookup
						]
					];

					overwriteAnionStandardGradientQ = If[MatchQ[anionStandardGradientLookup, ObjectP[Object[Method, IonChromatographyGradient]]],
						!MatchQ[Lookup[fetchPacketFromCache[Download[anionStandardGradientLookup, Object], fullCache], AnionGradient], initiallyResolvedAnionStandardGradient],
						False
					];

					(*finally resolve the gradient*)
					anionStandardGradient = Which[
						MatchQ[anionStandardGradientLookup, ObjectP[Object[Method, IonChromatographyGradient]]] && !overwriteAnionStandardGradientQ, anionStandardGradientLookup,
						(*otherwise if the gradient is automatic and the injection table is set, should use that*)
						MatchQ[anionStandardGradientLookup, Automatic] && MatchQ[anionInjectionTableStandardRoundedGradient, ObjectP[Object[Method, IonChromatographyGradient]]], Download[anionInjectionTableStandardRoundedGradient, Object],
						(*otherwise, it should be a tuple*)
						True, initiallyResolvedAnionStandardGradient
					];

					(*return everything*)
					{
						anionStandardGradient,
						anionStandardGradientStart,
						anionStandardGradientEnd,
						anionStandardGradientDurationLookup,
						anionStandardFlowRate,
						standardEluentGradient,
						anionStandardGradientConsistentQ,
						anionStandardGradientStartEndSpecifiedQ,
						anionStandardDurationOptionsSpecifiedQ,
						invalidAnionStandardGradientCompositionQ,
						anionStandardRemovedExtrasQ,
						overwriteAnionStandardGradientQ,
						anionStandardDurationConsistentQ,
						incompatibleAnionStandardFlowRateQ
					}

				],
					{ToList@resolvedAnionStandard, mapThreadFriendlyAnionStandardOptions}
				]]]];

		(* == Error Checking == *)
		(* Don't need this test anymore, covered in StandardOptionConflict
        (* 35.1 If AnionStandard are specified or resolved, some gradient options must be specified *)
        missingGradientAnionStandards=If[Length[ToList@resolvedAnionStandard]==0,
            {},
            PickList[ToList@resolvedAnionStandard,anionStandardGradientMissingErrors,True]
        ];

        (* If there are any missing anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
        missingAnionStandardGradientOptions=If[Length[missingGradientAnionStandards]>0&&messagesQ,
            (
                Message[Error::MissingAnionGradientOptions,AnionStandard,ObjectToString[missingGradientAnionStandards,Cache -> fullCache, Simulation -> updatedSimulation]];
                {StandardEluentGradient,AnionStandardFlowRate,AnionStandardGradient}
            ),
            {}
        ];

        (* Generate test for missing anion gradient options *)
        missingAnionStandardGradientTests=testOrNullIndexMatched["If AnionStandard are specified or resolved, anion standard gradient options are either specified in the option or the InjectionTable:",resolvedAnionStandard,anionStandardGradientMissingErrors]; *)

		(* 35.2 If AnionStandardGradient is specified simultaenously in the option and the InjectionTable as method object, they should be consistent with each other *)
		inconsistentGradientAnionStandard = If[Length[ToList@resolvedAnionStandard] == 0,
			{},
			PickList[ToList@resolvedAnionStandard, ToList@anionStandardGradientConsistentErrors, True]
		];

		(* If there are any missing anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
		inconsistentAnionStandardGradientOptions = If[Length[inconsistentGradientAnionStandard] > 0 && messagesQ,
			(
				Message[Error::InconsistentGradientSpecification, AnionStandard, ObjectToString[inconsistentGradientAnionStandard,Cache -> fullCache, Simulation -> updatedSimulation]];
				{AnionStandardGradient, AnionInjectionTable}
			),
			{}
		];

		(* Generate test for missing specification among anion gradient start, end and duration *)
		inconsistentAnionStandardGradientTests = testOrNullIndexMatched["If specified, gradient methods in the AnionStandardGradient option and the AnionInjectionTable must be consistent:", resolvedAnionStandard, anionStandardGradientConsistentErrors];

		(* 35.3 If either StandardEluentGradient or AnionStandardGradient is specified, the maximum concentration is within the range defined by the integrated eluent generator *)
		invalidGradientCompositionAnionStandard = If[Length[ToList@resolvedAnionStandard] == 0,
			{},
			PickList[ToList@resolvedAnionStandard, invalidAnionStandardGradientCompositionErrors, True]
		];

		(* If there are any invalid anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
		invalidAnionStandardGradientCompositionOptions = If[Length[inconsistentGradientAnionStandard] > 0 && messagesQ,
			(
				Message[Error::InvalidAnionGradientComposition, AnionStandard, ObjectToString[invalidGradientCompositionAnionStandard,Cache -> fullCache, Simulation -> updatedSimulation], maxEluentConcentration];
				{StandardEluentGradient, AnionStandardGradient}
			),
			{}
		];

		(* Generate test for invalid anion gradient composition *)
		invalidAnionStandardGradientTests = testOrNullIndexMatched["The specified AnionStandardGradient has maximum eluent concentrations less than the max concentration allowed by the eluent generator:", resolvedAnionStandard, invalidAnionStandardGradientCompositionErrors];

		(* 35.4 AnionStandardFlowRate has to be within the range supported by the instrument, and the column *)
		(* If there are any invalid anion flow rates and we are throwing messages, then throw an error message and collect invalid options *)
		incompatibleAnionStandardFlowRateOptions = If[MemberQ[anionStandardFlowRateErrors, True] && messagesQ,
			(
				Message[Error::FlowRateAboveMax, AnionStandardFlowRate, PickList[resolvedAnionStandardFlowRate, anionStandardFlowRateErrors, True], resolvedInstrument, resolvedAnionColumn, maxAnionFlowRate];
				{AnionStandardFlowRate}
			),
			{}
		];

		(* Generate test for invalid anion gradient composition *)
		invalidAnionStandardFlowRateTests = testOrNullIndexMatched["The specified AnionStandardFlowRate has maximum flow rate less than that supported by the instrument and the column:", resolvedAnionStandard, anionStandardFlowRateErrors];

		(* 35.5 If any of the following gradient start, end and duration options are specified, all three options need to be specified *)
		notSpecifiedAnionStandardGradientStartEnd = If[MatchQ[resolvedAnionStandard, {} | Null | {Null}],
			{},
			PickList[ToList@resolvedAnionStandard, anionStandardGradientStartEndSpecifiedErrors, True]
		];

		(* If there are any missing anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
		notSpecifiedAnionStandardGradientStartEndOptions = If[Length[notSpecifiedAnionStandardGradientStartEnd] > 0 && messagesQ,
			(
				Message[Error::HPICGradientStartEndConflict, {AnionStandardGradientStart}, ObjectToString[notSpecifiedAnionStandardGradientStartEnd, Cache -> fullCache, Simulation -> updatedSimulation]];
				{AnionStandardGradientStart, AnionStandardGradientEnd}
			),
			{}
		];

		(* Generate test for missing specification among anion gradient start, end and duration *)
		notSpecifiedAnionStandardGradientStartEndTests = testOrNullIndexMatched["AnionStandardGradientStart and AnionStandardGradientEnd should be specified or set to Null simultaneously:", resolvedAnionStandard, anionStandardGradientStartEndSpecifiedErrors];

		(* 35.6 If gradient duration is specified, either gradient start & end or eluent gradient is specified *)
		notSpecifiedAnionStandardGradientDuration = If[MatchQ[resolvedAnionStandard, {} | Null | {Null}],
			{},
			PickList[ToList@resolvedAnionStandard, anionStandardDurationOptionSpecifiedErrors, True]
		];

		(* If there are any missing anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
		notSpecifiedAnionStandardGradientDurationOptions = If[Length[notSpecifiedAnionStandardGradientDuration] > 0 && messagesQ,
			(
				Message[Error::HPICGradientShortcutConflict, AnionStandardGradientDuration, {AnionStandardGradientStart, AnionStandardGradientEnd}, "StandardEluentGradient"];
				{AnionStandardGradientStart, AnionStandardGradientEnd, AnionStandardGradientDuration, StandardEluentGradient}
			),
			{}
		];

		(* Generate test for missing specification among anion gradient start, end and duration *)
		notSpecifiedAnionStandardGradientDurationTests = testOrNullIndexMatched["AnionStandardGradientDuration should be specified either with AnionStandardGradientStart/AnionStandardGradientEnd or with StandardEluentGradient:", resolvedAnionStandard, anionStandardDurationOptionSpecifiedErrors];

		(* 35.7 If gradient duration and eluent gradient are both specified, their specified values are consistent *)
		inconsistentAnionStandardGradientDuration = If[MatchQ[resolvedAnionStandard, {} | Null | {Null}],
			{},
			PickList[ToList@resolvedAnionStandard, anionStandardDurationConsistentErrors, True]
		];

		(* If there are any missing anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
		inconsistentAnionStandardGradientDurationOptions = If[Length[inconsistentAnionStandardGradientDuration] > 0 && messagesQ && notInEngine,
			(
				Message[Warning::HPICGradientShortcutAmbiguity, AnionStandardGradientDuration, StandardEluentGradient];
				{}
			),
			{}
		];

		(* Generate test for missing specification among anion gradient start, end and duration *)
		consistentAnionStandardGradientDurationTests = warningOrNullIndexMatched["Specified values for AnionStandardGradientDuration and StandardEluentGradient are consistent:", resolvedAnionStandard, anionStandardDurationConsistentErrors];

		(* 36. AnionStandardColumnTemperature, AnionStandardSuppressorCurrent, and AnionStandardDetectionTemperature resolution *)

		{
			resolvedAnionStandardColumnTemperature,
			resolvedAnionStandardSuppressorMode,
			resolvedAnionStandardSuppressorVoltage,
			resolvedAnionStandardSuppressorCurrent,
			resolvedAnionStandardDetectionTemperature,
			conflictingAnionStandardSuppressorModeErrors
		} = Module[{injectionTableWithID, gradientInInjectionTable, anionStandardColumnTemperature, anionStandardSuppressorCurrentLookup, anionStandardDetectionTemperatureLookup,
			anionStandardSuppressorCurrent, anionStandardDetectionTemperature, anionStandardSuppressorModeLookup, anionStandardSuppressorVoltageLookup, anionStandardSuppressorMode,
			myGradient, maxFlowRate, maxEluentConc, defaultMinAnionSuppressorCurrent, defaultMaxAnionSuppressorCurrent, anionStandardSuppressorVoltage, anionStandardSuppressorModeConflictQ},

			If[!anionStandardExistQ || MatchQ[mapThreadFriendlyAnionStandardOptions, Null],

				{Null, Null, Null, Null, Null, False},

				Transpose[MapThread[Function[{mySample, myResolvedGradient, myMapThreadOptions},

					injectionTableWithID = Map[
						If[MatchQ[#[[2]], ObjectP[]],
							Join[ToList@#[[1]], ToList@Download[#[[2]], Object], #[[3 ;; Length[#]]]],
							#
						]&,
						anionInjectionTableLookupRounded
					];

					(* If InjectionTable is not the default value of automatic, then look up the gradient object specified for mySample *)
					gradientInInjectionTable = If[!MatchQ[injectionTableWithID, ListableP[Automatic]],
						Cases[injectionTableWithID, {Standard, Download[mySample, Object], _, _, gradientObj : ObjectP[Object[Method, IonChromatographyGradient]]} :> gradientObj],
						Null
					];

					(* Download the gradient object from fullCache and extract column temperature information *)
					anionStandardColumnTemperature = Which[

						(* If user has already specified anion column temperature, go with that *)
						!MatchQ[Lookup[myMapThreadOptions, AnionStandardColumnTemperature], ListableP[Automatic | Null]],
						Lookup[myMapThreadOptions, AnionStandardColumnTemperature],

						(* If the specified AnionGradient is a method object, extract column temperature from there *)
						MatchQ[myResolvedGradient, ObjectP[Object[Method, IonChromatographyGradient]]],
						If[MatchQ[ Lookup[fetchPacketFromCache[Download[myResolvedGradient, Object], fullCache], AnionColumnTemperature], {} | Null | {Null}],
							Ambient,
							Lookup[fetchPacketFromCache[Download[myResolvedGradient, Object], fullCache], AnionColumnTemperature]
						],

						(* If the specified gradient in the InjectionTable is an Object, extract column temperature from there *)
						MatchQ[gradientInInjectionTable, ObjectP[Object[Method, IonChromatographyGradient]]],
						Lookup[fetchPacketFromCache[Download[gradientInInjectionTable, Object], fullCache], AnionColumnTemperature],

						MatchQ[resolvedAnionColumnTemperature, {Null} | Null | {}],
						Ambient,

						MatchQ[resolvedAnionColumnTemperature[[1]], Ambient],
						Ambient,

						True,
						resolvedAnionColumnTemperature[[1]]
					];

					(* Look up the specified options from the map thread friendly version of the anion options *)
					{
						anionStandardSuppressorModeLookup,
						anionStandardSuppressorVoltageLookup,
						anionStandardSuppressorCurrentLookup,
						anionStandardDetectionTemperatureLookup
					} = Lookup[myMapThreadOptions,
						{
							AnionStandardSuppressorMode,
							AnionStandardSuppressorVoltage,
							AnionStandardSuppressorCurrent,
							AnionStandardDetectionTemperature
						}
					];

					(* If user specified AnionSuppressorMode, go with that *)
					anionStandardSuppressorMode = Which[

						(* If user specified suppressor mode, then go with that *)
						MatchQ[anionStandardSuppressorModeLookup, Except[Null | Automatic]],
						anionStandardSuppressorModeLookup,

						(* If user does not specify suppressor mode but instead specify suppressor voltage, set suppressorMode to DynamicMode *)
						MatchQ[anionStandardSuppressorVoltageLookup, Except[Null | Automatic]],
						DynamicMode,

						(* Similarly, if user does not specify suppressor mode but instead specify suppressor current, set suppressorMode to LegacyMode *)
						MatchQ[anionStandardSuppressorCurrentLookup, Except[Null | Automatic]],
						LegacyMode,

						(* If nothing is specified, resolve to DynamicMode *)
						True,
						LegacyMode
					];

					(*Get the actual gradient list*)
					myGradient = If[MatchQ[myResolvedGradient, ObjectP[Object[Method]]],
						(*If our resolved gradient is an object, we need to extract the actual gradient from the correct field*)
						Lookup[fetchPacketFromCache[Download[myResolvedGradient, Object], fullCache], AnionGradient],
						(*Otherwise it is already a list of sample and flow rate*)
						myResolvedGradient
					];

					(* Preparation to resolve anionSuppressorCurrent *)
					(* anionSuppressorCurrent (mA) = FlowRate (min/mL) x [Eluent] x suppressor specific Factor *)
					maxFlowRate = Convert[Max[myGradient[[All, -1]]], Milliliter / Minute];
					maxEluentConc = Convert[Max[myGradient[[All, 2]]], Millimolar];
					defaultMinAnionSuppressorCurrent = SafeRound[Unitless[maxFlowRate * maxEluentConc * anionSuppressorSpecificFactor], 1, Round -> Up] * Milli * Ampere;
					defaultMaxAnionSuppressorCurrent = If[SafeRound[defaultMinAnionSuppressorCurrent * 1.61, 1, Round -> Down] > maxAnionSuppressorCurrent,
						maxAnionSuppressorCurrent,
						SafeRound[defaultMinAnionSuppressorCurrent * 1.61, 1, Round -> Down]
					];

					{anionStandardSuppressorVoltage, anionStandardSuppressorCurrent, anionStandardSuppressorModeConflictQ} = Which[

						(* If AnionSuppressorMode option is set to DynamicMode, then we need to resolve AnionSuppressorVoltage and set AnionSuppressorCurrent to Null *)
						MatchQ[anionStandardSuppressorMode, DynamicMode],
						If[
							(* First we need to make sure when AnionSuppressorMode is set to DynamicMode, AnionSuppressorCurrent is not specified *)
							(* If it is specified, set error tracking variable to True so that we can throw error later *)
							MatchQ[anionStandardSuppressorVoltageLookup, Null],
							{Null, Null, True},

							Which[
								(* If AnionSuppressorVoltage is specified, go with that *)
								MatchQ[anionStandardSuppressorVoltageLookup, Except[Automatic]],
								{anionStandardSuppressorVoltageLookup, Null, False},

								(* If not, use the factory recommended value of the suppressor *)
								MatchQ[anionStandardSuppressorVoltageLookup, Automatic],
								{anionSuppressorRecommendedVoltage, Null, False},

								True,
								{anionSuppressorRecommendedVoltage, Null, False}
							]
						],

						(* If AnionSuppressorMode option is set to LegacyMode, then we need to resolve AnionSuppressorCurrent and set AnionSuppressotVoltage to Null *)
						MatchQ[anionStandardSuppressorMode, LegacyMode],
						If[
							(* First we need to make sure when AnionSuppressorMode is set to LegacyModel, AnionSuppressorVoltage is not specified *)
							(* If it is specified, set error tracking variable to True so that we can throw error later *)
							MatchQ[anionStandardSuppressorCurrentLookup, Null],
							{Null, Null, True},

							Which[
								(* If AnionSuppressorCurrent is specified, go with that *)
								MatchQ[anionStandardSuppressorCurrentLookup, Except[Automatic]],
								{Null, anionStandardSuppressorCurrentLookup, False},

								(* If not, use the factory recommended value of the suppressor *)
								MatchQ[anionStandardSuppressorCurrentLookup, Automatic],
								{Null, defaultMinAnionSuppressorCurrent, False},

								True,
								{Null, defaultMinAnionSuppressorCurrent, False}
							]
						],

						True,
						{Null, Null, False}

					];

					(* If user specified AnionDetectionTemperature, go with that *)
					anionStandardDetectionTemperature = If[MatchQ[anionStandardDetectionTemperatureLookup, Except[Automatic | Null]],
						anionStandardDetectionTemperatureLookup,
						(* Otherwise, use Ambient detection *)
						Which[
							MatchQ[resolvedAnionDetectionTemperature, Null | {} | {Null}],
							Ambient,

							MatchQ[resolvedAnionDetectionTemperature[[1]], Ambient],
							Ambient,

							Not[Between[resolvedAnionDetectionTemperature[[1]], {minAnionDetectionTemperature /. Null -> -Infinity Celsius, maxAnionDetectionTemperature /. Null -> Infinity Celsius}]],
							Ambient,

							True,
							resolvedAnionDetectionTemperature[[1]]
						]
					];

					(* Gather MapThread results *)
					{
						anionStandardColumnTemperature,
						anionStandardSuppressorMode,
						anionStandardSuppressorVoltage,
						anionStandardSuppressorCurrent,
						anionStandardDetectionTemperature,
						anionStandardSuppressorModeConflictQ
					}
				],
					{ToList@resolvedAnionStandard, resolvedAnionStandardGradient, mapThreadFriendlyAnionStandardOptions}
				]]]];

		(* == Error Checking == *)
		(* 36.1 Suppressor mode error check *)
		(* Pull out the anion samples that have conflicting suppressor mode and compile a list of conflicting suppressor mode*)
		conflictingAnionSuppressorModeStandards = If[Length[ToList@resolvedAnionStandard] == 0,
			{},
			PickList[ToList@resolvedAnionStandard, conflictingAnionStandardSuppressorModeErrors, True]
		];

		(* Throw error message and collect invalid option *)
		conflictingAnionStandardSuppressorModeOptions = If[Length[conflictingAninSuppressorModeStandards] > 0 && messagesQ,
			(
				Message[Error::ConflictingSuppressorMode, ObjectToString[conflictingAninSuppressorModeStandards, Cache -> fullCache, Simulation -> updatedSimulation], AnionStandardSuppressorMode, AnionStandardSuppressorVoltage, AnionStandardSuppressorCurrent];
				{AnionStandardSuppressorMode, AnionStandardSuppressorVoltage, AnionStandardSuppressorCurrent}
			),
			{}
		];

		(* Generate test for conflicting suppressor mode *)
		anionStandardSuppressorModeTests = testOrNullIndexMatched["AnionStandardSuppressorVoltage and AnionStandardSuppressorCurrent are set if AnionStandardSuppressorMode is set to DynamicMode and LegacyMode respectively:", resolvedAnionStandard, conflictingAnionStandardSuppressorModeErrors];

		(* Don't need those checks anymore - upper bound is built into the widget
        (* 36.2 Suppressor voltage error check *)
        (* Pull out the anion samples that have incompatible suppressor current and compile a list of incompatible suppressor current *)
        incompatibleSuppressorVoltageAnionStandards=If[Length[ToList@resolvedAnionStandard]==0,
            {},
            PickList[ToList@resolvedAnionStandard,incompatibleAnionStandardSuppressorVoltageErrors,True]
        ];
        incompatibleAnionStandardSuppressorVoltage=If[Length[ToList@resolvedAnionStandard]==0,
            {},
            PickList[resolvedAnionStandardSuppressorVoltage,incompatibleAnionStandardSuppressorVoltageErrors,True]
        ];

        (* Throw error message and collect invalid option *)
        invalidAnionStandardSuppressorVoltageOptions=If[Length[incompatibleSuppressorVoltageAnionStandard]>0&&messagesQ,
            (
                Message[Error::IncompatibleSuppressorVoltage,incompatibleAnionStandardSuppressorVoltage,AnionStandard,ObjectToString[incompatibleSuppressorVoltageAnionStandards,Cache -> fullCache, Simulation -> updatedSimulation],maxAnionSuppressorVoltage/.Null->Infinity Volt];
                {AnionStandardSuppressorVoltage}
            ),
            {}
        ];

        (* Generate test for invalid max acceleration *)
        anionStandardSuppressorVoltageTests=testOrNullIndexMatched["AnionStandardSuppressorVoltage is less than the maximum suppressor voltage supported by the instrument:",resolvedAnionStandard,incompatibleAnionStandardSuppressorVoltageErrors];

        (* 36.3 Check whether the resolved anion standard column temperature is within the acceptable temperature range *)
        (* Identify resolved anion samples that have incompatible column temperature and also compiled a list of incompatible temperatures *)
        incompatibleColumnTemperatureAnionStandard=If[Length[ToList@resolvedAnionStandard]==0,
            {},
            PickList[ToList@resolvedAnionStandard,ToList@incompatibleAnionStandardColumnTemperatureErrors,True]
        ];
        incompatibleAnionStandardColumnTemperature=If[Length[ToList@resolvedAnionStandard]==0,
            {},
            PickList[resolvedAnionStandardColumnTemperature,ToList@incompatibleAnionStandardColumnTemperatureErrors,True]
        ];

        (* If there are any incompatible column temperatures and we are throwing messages, throw an error and collect in valid option *)
        incompatibleAnionStandardColumnTemperatureOptions=If[Length[incompatibleAnionStandardColumnTemperature]>0&&messagesQ,
            (
                Message[Error::IncompatibleAnionColumnTemperature,incompatibleAnionStandardColumnTemperature,AnionStandard,ObjectToString[incompatibleColumnTemperatureAnionStandard,Cache -> fullCache, Simulation -> updatedSimulation],allowedAnionColumnTemperatureRange[[1]],allowedAnionColumnTemperatureRange[[2]]];
                {AnionStandardColumnTemperature}
            ),
            {}
        ];

        (* Generate tests for incompatible anion column temperature *)
        incompatibleAnionStandardColumnTemperatureTests=testOrNullIndexMatched["Specified AnionStandardColumnTemperature is within the range of supported temperature of the AnionColumn:",resolvedAnionStandard,incompatibleAnionStandardColumnTemperatureErrors];

        (* 36.4 Suppressor current error check *)
        (* Pull out the anion standard that have incompatible suppressor current and compile a list of incompatible suppressor current *)
        incompatibleSuppressorCurrentAnionStandard=If[Length[ToList@resolvedAnionStandard]==0,
            {},
            PickList[ToList@resolvedAnionStandard,incompatibleAnionStandardSuppressorCurrentErrors,True]
        ];
        incompatibleAnionStandardSuppressorCurrent=If[Length[ToList@resolvedAnionStandard]==0,
            {},
            PickList[resolvedAnionStandardSuppressorCurrent,incompatibleAnionStandardSuppressorCurrentErrors,True]
        ];

        (* Throw error message and collect invalid option *)
        invalidAnionStandardSuppressorCurrentOptions=If[Length[incompatibleSuppressorCurrentAnionStandard]>0&&messagesQ,
            (
                Message[Error::IncompatibleSuppressorCurrent,incompatibleAnionStandardSuppressorCurrent,AnionStandard,ObjectToString[incompatibleSuppressorCurrentAnionStandard,Cache -> fullCache, Simulation -> updatedSimulation],0 Milliampere,maxAnionSuppressorCurrent];
                {AnionStandardSuppressorCurrent}
            ),
            {}
        ];

        (* Generate test for invalid max acceleration *)
        anionStandardSuppressorCurrentTests=testOrNullIndexMatched["AnionStandardSuppressorCurrent is less than the maximum suppressor current supported by the instrument:",resolvedAnionStandard,incompatibleAnionStandardSuppressorCurrentErrors];

        (* 36.5 Detection Temperature error check *)
        (* Pull out the anion samples that have incompatible suppressor current and compile a list of incompatible suppressor current *)
        incompatibleDetectionTemperatureAnionStandard=If[Length[ToList@resolvedAnionStandard]==0,
            {},
            PickList[ToList@resolvedAnionStandard,incompatibleAnionStandardDetectionTemperatureErrors,True]
        ];
        incompatibleAnionStandardDetectionTemperature=If[Length[ToList@resolvedAnionStandard]==0,
            {},
            PickList[resolvedAnionStandardDetectionTemperature,incompatibleAnionStandardDetectionTemperatureErrors,True]
        ];

        (* Throw error message and collect invalid option *)
        invalidAnionStandardDetectionTemperatureOptions=If[Length[incompatibleDetectionTemperatureAnionStandard]>0&&messagesQ,
            (
                Message[Error::IncompatibleDetectionTemperature,incompatibleAnionStandardDetectionTemperature,AnionStandard,ObjectToString[incompatibleDetectionTemperatureAnionStandard,Cache -> fullCache, Simulation -> updatedSimulation],minAnionDetectionTemperature,maxAnionDetectionTemperature];
                {AnionStandardDetectionTemperature}
            ),
            {}
        ];

        (* Generate test for invalid max acceleration *)
        anionStandardDetectionTemperatureTests=testOrNullIndexMatched["AnionStandardDetectionTemperature is within the range of detection temperatures set by the instrument:",resolvedAnionStandard,incompatibleAnionStandardDetectionTemperatureErrors]; *)

		(* 37. CationStandard related option resolution: CationStandardGradientDuration, CationStandardFlowRate, StandardGradientA, StandardGradientB, CationStandardGradient *)

		(* Compile a list of cation gradient related options to pass into the MapThread below for resolving gradient *)
		cationStandardGradientOptions = {
			CationStandardGradientA,
			CationStandardGradientB,
			CationStandardGradientC,
			CationStandardGradientD,
			CationStandardGradientStart,
			CationStandardGradientEnd,
			CationStandardGradientDuration,
			CationStandardGradient,
			CationStandardFlowRate
		};

		(* Compile a list of electrochemical gradient related options to pass into the MapThread below for resolving gradient *)
		electrochemicalStandardGradientOptions = {
			StandardGradientA,
			StandardGradientB,
			StandardGradientC,
			StandardGradientD,
			StandardGradientStart,
			StandardGradientEnd,
			StandardGradientDuration,
			StandardGradient,
			StandardFlowRate
		};

		(* Resolution of gradient related options *)
		{
			{
				resolvedCationStandardGradient,
				resolvedCationStandardGradientStart,
				resolvedCationStandardGradientEnd,
				resolvedCationStandardGradientDuration,
				resolvedCationStandardFlowRate,
				resolvedCationStandardGradientA,
				resolvedCationStandardGradientB,
				resolvedCationStandardGradientC,
				resolvedCationStandardGradientD,
				cationStandardGradientStartEndSpecifiedErrors,
				cationStandardDurationOptionSpecifiedErrors,
				cationStandardGradientConsistentErrors,
				invalidCationStandardGradientCompositionErrors,
				cationStandardRemovedExtraErrors,
				cationStandardFlowRateErrors,
				cationStandardDurationConsistentErrors,
				overwriteCationStandardGradientBool
			},
			{
				resolvedStandardGradient,
				resolvedStandardGradientStart,
				resolvedStandardGradientEnd,
				resolvedStandardGradientDuration,
				resolvedStandardFlowRate,
				resolvedStandardGradientA,
				resolvedStandardGradientB,
				resolvedStandardGradientC,
				resolvedStandardGradientD,
				standardGradientStartEndSpecifiedErrors,
				standardDurationOptionSpecifiedErrors,
				standardGradientConsistentErrors,
				invalidStandardGradientCompositionErrors,
				standardRemovedExtraErrors,
				standardFlowRateErrors,
				standardDurationConsistentErrors,
				overwriteStandardGradientBool
			}
		} = Module[{
			standardGradientALookup, standardGradientBLookup, standardGradientCLookup, standardGradientDLookup, standardGradientStartLookup,
			standardGradientEndLookup, standardGradientDurationLookup, standardGradientLookup, standardFlowRateLookup, standardDurationConsistentQ,
			injectionTableSampleRoundedGradient, standardGradientStartEndSpecifiedQ, standardGradientConsistentQ, standardDurationOptionsSpecifiedQ,
			standardGradientStart, standardGradientEnd, standardRemovedExtrasQ, protoStandardGradientOptionTuple, standardGradientOptionTuple,
			defaultedStandardFlowRate, standardGradientReturned, initiallyResolvedStandardGradient, invalidStandardGradientCompositionQ, standardGradientA,
			standardGradientB, standardGradientC, standardGradientD, standardFlowRate, standardGradient, overwriteStandardGradientQ, injectionTableWithID,
			incompatibleStandardFlowRateQ, samples, mapThreadOptions, injectionTableLookup, gradientOptions, criteria, gradientColumnInInjectionTable,
			individualGradientSpecifiedQ},

			Map[Function[{entryVariable},

				{samples, mapThreadOptions, gradientOptions, injectionTableLookup, criteria, gradientColumnInInjectionTable} = entryVariable;

				If[criteria || MatchQ[mapThreadOptions, Null],
					(* If there is no resolvedCationSamples or samples for ElectrochemicalChannel, then set all cation gradient related options to Null, and all error tracking variable to False *)
					Join[ConstantArray[Null, 9], ConstantArray[False, 8]],

					(* Otherwise, run this giant map thread to resolve all anion gradient related options *)
					Transpose[MapThread[Function[{mySample, myMapFriendlyOptions},

						(* Look up the values of each options in the list *)
						{
							standardGradientALookup,
							standardGradientBLookup,
							standardGradientCLookup,
							standardGradientDLookup,
							standardGradientStartLookup,
							standardGradientEndLookup,
							standardGradientDurationLookup,
							standardGradientLookup,
							standardFlowRateLookup
						} = Lookup[myMapFriendlyOptions, gradientOptions];

						(* Setup: We first get the injection table gradients *)
						injectionTableSampleRoundedGradient = If[MatchQ[injectionTableLookup, Except[Automatic]],

							injectionTableWithID = Map[
								If[MatchQ[#[[2]], ObjectP[]],
									Join[ToList@#[[1]], ToList@Download[#[[2]], Object], #[[3 ;; Length[#]]]],
									#
								]&,
								injectionTableLookup
							];

							(* Extract the gradient specified in InjectionTable *)
							Which[
								gradientColumnInInjectionTable == 5,
								Cases[injectionTableWithID, {Standard, Download[mySample, Object], _, _, gradient_} :> gradient],

								gradientColumnInInjectionTable == 4,
								Cases[injectionTableWithID, {Standard, Download[mySample, Object], _, gradient_, ___} :> gradient],

								True,
								Automatic
							],

							(* If InjectionTable is not specified or has conflict with input samples, pad it with Automatics*)
							Automatic
						];

						(* First we need to make sure that the start end and duration options are either all specified or not *)
						standardGradientStartEndSpecifiedQ = !MatchQ[{standardGradientStartLookup, standardGradientEndLookup}, {PercentP, PercentP} | {Automatic | Null, Automatic | Null}];

						(* Then we need to make sure that the duration is specified either with start & end, or with eluent gradient *)
						standardDurationOptionsSpecifiedQ = If[MatchQ[standardGradientDurationLookup, TimeP],
							Not[MatchQ[{standardGradientStartLookup, standardGradientEndLookup}, {PercentP, PercentP}] || MatchQ[standardGradientALookup, PercentP] || MatchQ[standardGradientBLookup, PercentP] || MatchQ[standardGradientCLookup, PercentP] || MatchQ[standardGradientDLookup, PercentP]],
							False
						];

						(* Need to check if any of the individual gradient is specified in {Time,Percent} format *)
						individualGradientSpecifiedQ = Or[
							MatchQ[standardGradientALookup, Except[Automatic | PercentP]],
							MatchQ[standardGradientBLookup, Except[Automatic | PercentP]],
							MatchQ[standardGradientCLookup, Except[Automatic | PercentP]],
							MatchQ[standardGradientDLookup, Except[Automatic | PercentP]]
						];

						(* We also need to check if Duration specification is consistent with individual gradient *)
						standardDurationConsistentQ = If[individualGradientSpecifiedQ,

							If[MatchQ[standardGradientDurationLookup, TimeP],
								True,
								False
							],
							(* If none of the individual gradient is specified, then leave this error tracking variable to False *)
							False
						];

						(* If gradient is specied as a method object, check whether CationGradient and the injection table specify the same object*)
						standardGradientConsistentQ = If[MatchQ[standardGradientLookup, ObjectP[{Object[Method, IonChromatographyGradient], Object[Method, Gradient]}]] && MatchQ[injectionTableSampleRoundedGradient, ObjectP[{Object[Method, IonChromatographyGradient], Object[Method, Gradient]}]],
							Not[MatchQ[Lookup[fetchPacketFromCache[standardGradientLookup, fullCache], Object], Lookup[fetchPacketFromCache[injectionTableSampleRoundedGradient, fullCache], Object]]],
							False
						];

						(* Extract or default GradientStart and GradientEnd values *)
						{standardGradientStart, standardGradientEnd} = Switch[{standardGradientStartLookup, standardGradientEndLookup, standardGradientDurationLookup},

							(* If valid cationGradientStart and cationGradientEnd are given, go with that *)
							{PercentP, PercentP, _} | {Null, Null, Null | TimeP}, {standardGradientStartLookup, standardGradientEndLookup},

							(* Default to cationGradientStart if something is wrong with gradientEnd *)
							{PercentP, _, _}, {standardGradientStartLookup, standardGradientStartLookup},

							(* Default to 0 Percent if something is wrong with cationGradeintStart *)
							{_, PercentP, _}, {0 Percent, standardGradientEndLookup},

							(* Otherwise, both Null*)
							_, {Null, Null}
						];

						(* If Gradient option is an object, pull Gradient value from packet *)
						protoStandardGradientOptionTuple = Which[

							(* If CationGradient specifies a method object, extract Gradient information from the packet *)
							MatchQ[standardGradientLookup, ObjectP[Object[Method, IonChromatographyGradient]]],
							Lookup[fetchPacketFromCache[Download[standardGradientLookup, Object], fullCache], CationGradient],

							(* If CationGradient specifies a method object, extract Gradient information from the packet *)
							MatchQ[standardGradientLookup, ObjectP[Object[Method, Gradient]]],
							Lookup[fetchPacketFromCache[Download[standardGradientLookup, Object], fullCache], Gradient],

							(* If InjectionTable specifies a method object, extract Gradient information from the packet *)
							MatchQ[standardGradientLookup, Automatic] && MatchQ[injectionTableSampleRoundedGradient, ObjectP[Object[Method, IonChromatographyGradient]]],
							Lookup[fetchPacketFromCache[Download[injectionTableSampleRoundedGradient, Object], fullCache], CationGradient],

							(* If InjectionTable specifies a method object, extract Gradient information from the packet *)
							MatchQ[standardGradientLookup, Automatic] && MatchQ[injectionTableSampleRoundedGradient, ObjectP[Object[Method, Gradient]]],
							Lookup[fetchPacketFromCache[Download[injectionTableSampleRoundedGradient, Object], fullCache], Gradient],

							(* Otherwise, namely if anionGradient is not a method object, then use what's specified in AnionGradient *)
							True, standardGradientLookup
						];

						(* Update CationFlowRate in the gradient method object if the option is specified *)
						standardGradientOptionTuple = If[MatchQ[standardFlowRateLookup, Except[Automatic]],

							(* If CationFlowRate is specified, use the specified flow rate and replace the default flowrate of the method object *)
							(* In IonChromatography Gradient method, CationGradient goes "Time", "BufferA Composition", "BufferB Composition", "BufferC Composition", "BufferD Composition", "FlowRate". FlowRate is in the third column *)
							ReplacePart[protoStandardGradientOptionTuple, Table[{x, 6} -> standardFlowRateLookup, {x, 1, Length[protoStandardGradientOptionTuple]}]],

							(* Otherwise, use the default flow rate in the gradient object *)
							protoStandardGradientOptionTuple
						];

						(* Default FlowRate to option value, gradient tuple values, or the pre-calculated optimal flow rate for the column *)
						(* note that it's ok to have this flow rate either match FlowRateP, or be a list of pairs of time and flow rate since resolveGradient can handle either *)
						defaultedStandardFlowRate = Which[

							(* If the AnionFlowRate is specified, go with the user specified value *)
							MatchQ[standardFlowRateLookup, Except[Automatic]], standardFlowRateLookup,

							(* If the AnionFlowRate is specified as part of the gradient method object, extract the flow rate from the object *)
							MatchQ[standardGradientOptionTuple, {TimeP, PercentP, PercentP, PercentP, PercentP, FlowRateP}], standardGradientOptionTuple[[All, {1, 6}]],

							(* If no flow rate is specified, use the optional flow rate determined for the column *)
							True, optimalColumnFlowRate
						];

						(* Track whether CationFlowRate is compatible with the instrument, and the column *)
						incompatibleStandardFlowRateQ = Not[Between[defaultedStandardFlowRate, {minFlowRate, maxFlowRate}]];

						(* finally run our helper resolution function *)
						standardGradientReturned = If[MatchQ[{standardGradientOptionTuple, standardGradientALookup, standardGradientBLookup, standardGradientCLookup, standardGradientDLookup, standardGradientStart, standardGradientEnd, standardGradientDurationLookup, standardFlowRateLookup}, {(Null | Automatic)..}] || standardGradientStartEndSpecifiedQ || standardDurationOptionsSpecifiedQ,
							resolveICCationGradient[defaultGradientIC[resolvedChannelSelection, defaultedStandardFlowRate], standardGradientALookup, standardGradientBLookup, standardGradientCLookup, standardGradientDLookup, defaultedStandardFlowRate, standardGradientStartLookup, standardGradientEndLookup, standardGradientDurationLookup],
							resolveICCationGradient[standardGradientOptionTuple, standardGradientALookup, standardGradientBLookup, standardGradientCLookup, standardGradientDLookup, defaultedStandardFlowRate, standardGradientStartLookup, standardGradientEndLookup, standardGradientDurationLookup]
						];

						(*remove duplicate entries if need be*)
						initiallyResolvedStandardGradient = DeleteDuplicatesBy[standardGradientReturned, First[# * 1.] &];

						(*if it's not the same note that*)
						standardRemovedExtrasQ = !MatchQ[standardGradientReturned, initiallyResolvedStandardGradient];

						(*check whether the gradient composition adds up to 100 okay*)
						invalidStandardGradientCompositionQ = Not[AllTrue[initiallyResolvedStandardGradient, (#[[2]] + #[[3]] + #[[4]] + #[[5]] == 100 Percent)&]];

						(*now resolve all of the individual gradients and flow rate*)
						standardGradientA = If[MatchQ[standardGradientALookup, Automatic],
							collapseGradient[initiallyResolvedStandardGradient[[All, {1, 2}]]],
							standardGradientALookup
						];

						standardGradientB = If[MatchQ[standardGradientBLookup, Automatic],
							collapseGradient[initiallyResolvedStandardGradient[[All, {1, 3}]]],
							standardGradientBLookup
						];

						standardGradientC = If[MatchQ[standardGradientCLookup, Automatic],
							collapseGradient[initiallyResolvedStandardGradient[[All, {1, 4}]]],
							standardGradientCLookup
						];

						standardGradientD = If[MatchQ[standardGradientDLookup, Automatic],
							collapseGradient[initiallyResolvedStandardGradient[[All, {1, 5}]]],
							standardGradientDLookup
						];

						standardFlowRate = If[MatchQ[standardFlowRateLookup, Automatic],
							collapseGradient[initiallyResolvedStandardGradient[[All, {1, -1}]]],
							standardFlowRateLookup
						];

						overwriteStandardGradientQ = Which[
							MatchQ[standardGradientLookup, ObjectP[Object[Method, IonChromatographyGradient]]],
							!MatchQ[Lookup[fetchPacketFromCache[Download[standardGradientLookup, Object], fullCache], CationGradient], initiallyResolvedStandardGradient],

							MatchQ[standardGradientLookup, ObjectP[Object[Method, Gradient]]],
							!MatchQ[Lookup[fetchPacketFromCache[Download[standardGradientLookup, Object], fullCache], Gradient], initiallyResolvedStandardGradient],

							True,
							False
						];

						(*finally resolve the gradient*)
						standardGradient = Which[

							MatchQ[standardGradientLookup, ObjectP[Object[Method, IonChromatographyGradient]]] && !overwriteStandardGradientQ, standardGradientLookup,
							MatchQ[standardGradientLookup, ObjectP[Object[Method, Gradient]]] && !overwriteStandardGradientQ, standardGradientLookup,

							(*otherwise if the gradient is automatic and the injection table is set, should use that*)
							MatchQ[standardGradientLookup, Automatic] && MatchQ[injectionTableSampleRoundedGradient, ObjectP[Object[Method, IonChromatographyGradient]]],
							Lookup[fetchPacketFromCache[injectionTableSampleRoundedGradient, fullCache], Object],

							MatchQ[standardGradientLookup, Automatic] && MatchQ[injectionTableSampleRoundedGradient, ObjectP[Object[Method, Gradient]]],
							Lookup[fetchPacketFromCache[injectionTableSampleRoundedGradient, fullCache], Object],

							(*otherwise, it should be a tuple*)
							True, initiallyResolvedStandardGradient
						];

						(*return everything*)
						{
							standardGradient,
							standardGradientStart,
							standardGradientEnd,
							standardGradientDurationLookup,
							standardFlowRate,
							standardGradientA,
							standardGradientB,
							standardGradientC,
							standardGradientD,
							standardGradientStartEndSpecifiedQ,
							standardDurationOptionsSpecifiedQ,
							standardGradientConsistentQ,
							invalidStandardGradientCompositionQ,
							standardRemovedExtrasQ,
							incompatibleStandardFlowRateQ,
							standardDurationConsistentQ,
							overwriteStandardGradientQ
						}],
						{samples, mapThreadOptions}
					]]
				]],
				{
					{ToList@resolvedCationStandard, mapThreadFriendlyCationStandardOptions, cationStandardGradientOptions, cationInjectionTableLookupRounded, MatchQ[resolvedCationStandard, {} | {Null} | Null], 5},
					{ToList@resolvedStandard, mapThreadFriendlyElectrochemicalStandardOptions, electrochemicalStandardGradientOptions, electrochemicalInjectionTableLookupRounded, !MemberQ[ToList@resolvedStandardAnalysisChannel, ElectrochemicalChannel], 4}
				}
			]
		];

		(* == Error Checking == *)
		(*
        (* 37.1 If CationStandard are specified or resolved, some gradient options must be specified *)
        missingGradientCationStandard=If[Length[ToList@resolvedCationStandard]==0,
            {},
            PickList[ToList@resolvedCationStandard,cationStandardGradientMissingErrors,True]
        ];

        (* If there are any missing anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
        missingCationStandardGradientOptions=If[Length[missingGradientCationStandard]>0&&messagesQ,
            (
                Message[Error::MissingCationGradientOptions,CationStandard,ObjectToString[missingGradientCationStandard,Cache -> fullCache, Simulation -> updatedSimulation]];
                {StandardGradientA,CationStandardFlowRate,CationStandardGradient}
            ),
            {}
        ];

        (* Generate test for missing anion gradient options *)
        missingCationStandardGradientTests=testOrNullIndexMatched["If CationStandard are specified or resolved, cation standard gradient options are either specified in the option or the InjectionTable:",resolvedCationStandard,cationStandardGradientMissingErrors]; *)

		(* 37.2 If CatinoStandardGradient is specified simultaenously in the option and the InjectionTable as method object, they should be consistent with each other *)
		inconsistentGradientCationStandards = If[Length[ToList@resolvedCationStandard] == 0,
			{},
			PickList[ToList@resolvedCationStandard, ToList@cationStandardGradientConsistentErrors, True]
		];

		(* If there are any missing anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
		inconsistentCationStandardGradientOptions = If[Length[inconsistentGradientCationStandards] > 0 && messagesQ,
			(
				Message[Error::InconsistentGradientSpecification, CationStandardGraient, ObjectToString[inconsistentGradientCationStandards,Cache -> fullCache, Simulation -> updatedSimulation]];
				{CationStandardGradient, CationInjectionTable}
			),
			{}
		];

		(* Generate test to check whether gradient specification is consistent between CationStandardGradient and InjectionTable *)
		inconsistentCationStandardGradientTests = testOrNullIndexMatched["If specified, gradient methods in the CationStandardGradient option and the CationInjectionTable must be consistent:", resolvedCationStandard, cationStandardGradientConsistentErrors];

		(* 37.3 If either EluentGradient or AnionGradient is specified, the maximum concentration is within the range defined by the integrated eluent generator *)
		invalidGradientCompositionCationStandard = If[Length[ToList@resolvedCationStandard] == 0,
			{},
			PickList[ToList@resolvedCationStandard, invalidCationStandardGradientCompositionErrors, True]
		];

		(* If there are any invalid anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
		invalidCationStandardGradientCompositionOptions = If[Length[invalidGradientCompositionCationStandard] > 0 && messagesQ,
			(
				Message[Error::InvalidGradientComposition, CationStandard, ObjectToString[invalidGradientCompositionCationStandard,Cache -> fullCache, Simulation -> updatedSimulation]];
				{CationStandardGradientA, CationStandardGradientB, CationStandardGradientC, CationStandardGradientD, CationStandardGradient}
			),
			{}
		];

		(* Generate test for invalid anion gradient composition *)
		invalidCationStandardGradientTests = testOrNullIndexMatched["The specified CationStandardGradient has a total buffer composition of 100% at all times:", resolvedCationStandard, invalidGradientCompositionCationStandard];

		(* Covered by StandardOptionConflict error
        (* 37.4 If CationStandardGradientDuration is specified, StandardEluentGradient needs to be specified *)
        incompleteGradientOptionCationStandards=If[Length[ToList@resolvedCationStandard]==0,
            {},
            PickList[ToList@resolvedCationStandard,incompleteCationStandardGradientErrors,True]
        ];

        invalidCationStandardGradientOptions=If[Length[incompleteGradientOptionCationStandards]>0&&messagesQ,
            (
                Message[Error::MissingGradientOptionSpecification,CationStandard,ObjectToString[incompleteGradientOptionCationStandards,Cache -> fullCache, Simulation -> updatedSimulation],CationStandardGradientDuration,StandardGradientA];
                {CationStandardGradientDuration,StandardGradientA}
            ),
            {}
        ];

        invalidCationStandardGradientOptionTest=testOrNullIndexMatched["If CationStandardGradient is specified, StandardGradientA is also specified:",resolvedCationStandard,incompleteCationStandardGradientErrors]; *)

		(* 37.5 CationStandardFlowRate has to be within the range supported by the instrument, and the column *)
		(* If there are any invalid anion flow rates and we are throwing messages, then throw an error message and collect invalid options *)
		incompatibleCationStandardFlowRateOptions = If[MemberQ[cationStandardFlowRateErrors, True] && messagesQ,
			(
				Message[Error::FlowRateAboveMax, CationStandardFlowRate, PickList[resolvedCationStandardFlowRate, cationStandardFlowRateErrors, True], resolvedInstrument, resolvedCationColumn, maxFlowRate];
				{CationStandardFlowRate}
			),
			{}
		];

		(* Generate test for invalid anion gradient composition *)
		invalidCationStandardFlowRateTests = testOrNullIndexMatched["The specified CationStandardFlowRate has maximum flow rate less than that supported by the instrument and the column:", resolvedCationStandard, cationStandardFlowRateErrors];

		(* 37.6 If gradient duration is specified, either gradient start & end or eluent gradient is specified *)
		notSpecifiedCationStandardGradientDuration = If[MatchQ[resolvedCationStandard, {} | Null | {Null}],
			{},
			PickList[ToList@resolvedCationStandard, cationStandardDurationOptionSpecifiedErrors, True]
		];

		(* If there are any missing anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
		notSpecifiedCationStandardGradientDurationOptions = If[Length[notSpecifiedCationStandardGradientDuration] > 0 && messagesQ,
			(
				Message[Error::HPICGradientShortcutConflict, CationStandardGradientDuration, {CationStandardGradientStart, CationStandardGradientEnd}, "CationStandardGradientA/B/C/D"];
				{CationStandardGradientStart, CationStandardGradientEnd, CationStandardGradientDuration, CationStandardGradientA, CationStandardGradientB, CationStandardGradientC, CationStandardGradientD}
			),
			{}
		];

		(* Generate test for missing specification among anion gradient start, end and duration *)
		notSpecifiedCationStandardGradientDurationTests = testOrNullIndexMatched["CationStandardGradientDuration should be specified either with CationStandardGradientStart/CationStandardGradientEnd or any of the CationStandardGradientA/B/C/D:", resolvedCationStandard, cationStandardDurationOptionSpecifiedErrors];

		(* 37.7 If gradient duration and eluent gradient are both specified, their specified values are consistent *)
		inconsistentCationStandardGradientDuration = If[MatchQ[resolvedCationStandard, {} | Null | {Null}],
			{},
			PickList[ToList@resolvedCationStandard, cationStandardDurationConsistentErrors, True]
		];

		(* If there are any missing anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
		inconsistentCationStandardGradientDurationOptions = If[Length[inconsistentCationStandardGradientDuration] > 0 && messagesQ && notInEngine,
			(
				Message[Warning::HPICGradientShortcutAmbiguity, CationStandardGradientDuration, "CationStandardGradientA/B/C/D"];
				{}
			),
			{}
		];

		(* Generate test for missing specification among anion gradient start, end and duration *)
		consistentCationStandardGradientDurationTests = warningOrNullIndexMatched["Specified values for CationStandardGradientDuration and CationStandardGradientA/B/C/D are consistent:", resolvedCationStandard, cationStandardDurationConsistentErrors];


		(* 37.8 If any of the following gradient start, end and duration options are specified, all three options need to be specified *)
		notSpecifiedCationStandardGradientStartEnd = If[MatchQ[resolvedCationStandard, {} | Null | {Null}],
			{},
			PickList[ToList@resolvedCationStandard, cationStandardGradientStartEndSpecifiedErrors, True]
		];

		(* If there are any missing anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
		notSpecifiedCationStandardGradientStartEndOptions = If[Length[notSpecifiedCationStandardGradientStartEnd] > 0 && messagesQ,
			(
				Message[Error::HPICGradientStartEndConflict, {CationStandardGradientStart, CationStandardGradientEnd}, ObjectToString[notSpecifiedCationStandardGradientStartEnd, Cache -> fullCache, Simulation -> updatedSimulation]];
				{CationStandardGradientStart, CationStandardGradientEnd}
			),
			{}
		];

		(* Generate test for missing specification among anion gradient start, end and duration *)
		notSpecifiedCationStandardGradientStartEndTests = testOrNullIndexMatched["CationStandardGradientStart and CationStandardGradientEnd should be specified or set to Null simultaneously:", resolvedCationStandard, cationStandardGradientStartEndSpecifiedErrors];

		(* 37.9 If StandardGradient is specified simultaenously in the option and the InjectionTable as method object, they should be consistent with each other *)
		inconsistentGradientStandards = If[!MemberQ[resolvedStandardAnalysisChannel, ElectrochemicalChannel],
			{},
			PickList[ToList@resolvedStandard, standardGradientConsistentErrors, True]
		];

		(* If there are any missing anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
		inconsistentStandardGradientOptions = If[Length[inconsistentGradientStandards] > 0 && messagesQ,
			(
				Message[Error::InconsistentGradientSpecification, StandardGraient, ObjectToString[inconsistentGradientStandards, Cache -> fullCache, Simulation -> updatedSimulation]];
				{StandardGradient, ElectrochemicalInjectionTable}
			),
			{}
		];

		(* Generate test to check whether gradient specification is consistent between CationStandardGradient and InjectionTable *)
		inconsistentStandardGradientTests = testOrNullIndexMatched["If specified, gradient methods in the StandardGradient option and the ElectrochemicalInjectionTable must be consistent:", resolvedStandard, standardGradientConsistentErrors];

		(* 37.10 If any StandardGradientA-D is specified, the maximum concentration is within the range defined by the integrated eluent generator *)
		invalidGradientCompositionStandard = If[!MemberQ[ToList@resolvedStandardAnalysisChannel, ElectrochemicalChannel],
			{},
			PickList[ToList@resolvedStandard, invalidStandardGradientCompositionErrors, True]
		];

		(* If there are any invalid anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
		invalidStandardGradientCompositionOptions = If[Length[invalidGradientCompositionStandard] > 0 && messagesQ,
			(
				Message[Error::InvalidGradientComposition, Standard, ObjectToString[invalidGradientCompositionStandard,Cache -> fullCache, Simulation -> updatedSimulation]];
				{StandardGradientA, StandardGradientB, StandardGradientC, StandardGradientD, StandardGradient}
			),
			{}
		];

		(* Generate test for invalid anion gradient composition *)
		invalidStandardGradientTests = testOrNullIndexMatched["The specified StandardGradient has a total buffer composition of 100% at all times:", resolvedStandard, invalidStandardGradientCompositionErrors];

		(* 37.11 StandardFlowRate has to be within the range supported by the instrument, and the column *)
		(* If there are any invalid anion flow rates and we are throwing messages, then throw an error message and collect invalid options *)
		incompatibleStandardFlowRateOptions = If[MemberQ[standardFlowRateErrors, True] && messagesQ,
			(
				Message[Error::FlowRateAboveMax, StandardFlowRate, PickList[resolvedStandardFlowRate, standardFlowRateErrors, True], resolvedInstrument, resolvedColumn, maxFlowRate];
				{StandardFlowRate}
			),
			{}
		];

		(* Generate test for invalid anion gradient composition *)
		invalidStandardFlowRateTests = testOrNullIndexMatched["The specified StandardFlowRate has maximum flow rate less than that supported by the instrument and the column:", resolvedStandard, standardFlowRateErrors];

		(* 37.12 If any of the following gradient start, end and duration options are specified, all three options need to be specified *)
		notSpecifiedStandardGradientStartEnd = If[!MemberQ[resolvedStandardAnalysisChannel, ElectrochemicalChannel],
			{},
			PickList[ToList@resolvedStandard, standardGradientStartEndSpecifiedErrors, True]
		];

		(* If there are any missing anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
		notSpecifiedStandardGradientStartEndOptions = If[Length[notSpecifiedStandardGradientStartEnd] > 0 && messagesQ,
			(
				Message[Error::HPICGradientStartEndConflict, {StandardGradientStart, StandardGradientEnd}, ObjectToString[notSpecifiedStandardGradientStartEnd, Cache -> fullCache, Simulation -> updatedSimulation]];
				{StandardGradientStart, StandardGradientEnd}
			),
			{}
		];

		(* Generate test for missing specification among anion gradient start, end and duration *)
		notSpecifiedStandardGradientStartEndTests = testOrNullIndexMatched["StandardGradientStart and StandardGradientEnd should be specified or set to Null simultaneously:", resolvedStandard, standardGradientStartEndSpecifiedErrors];

		(* 37.13 If gradient duration is specified, either gradient start & end or eluent gradient is specified *)
		notSpecifiedStandardGradientDuration = If[!MemberQ[resolvedStandardAnalysisChannel, ElectrochemicalChannel],
			{},
			PickList[ToList@resolvedStandard, standardDurationOptionSpecifiedErrors, True]
		];

		(* If there are any missing anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
		notSpecifiedStandardGradientDurationOptions = If[Length[notSpecifiedStandardGradientDuration] > 0 && messagesQ,
			(
				Message[Error::HPICGradientShortcutConflict, StandardGradientDuration, {StandardGradientStart, StandardGradientEnd}, "StandardGradientA/B/C/D"];
				{StandardGradientStart, StandardGradientEnd, StandardGradientDuration, StandardGradientA, StandardGradientB, StandardGradientC, StandardGradientD}
			),
			{}
		];

		(* Generate test for missing specification among anion gradient start, end and duration *)
		notSpecifiedStandardGradientDurationTests = testOrNullIndexMatched["StandardGradientDuration should be specified either with StandardGradientStart/StandardGradientEnd or any of the StandardGradientA/B/C/D:", resolvedStandard, standardDurationOptionSpecifiedErrors];

		(* 37.14 If gradient duration and eluent gradient are both specified, their specified values are consistent *)
		inconsistentStandardGradientDuration = If[!MemberQ[resolvedStandardAnalysisChannel, ElectrochemicalChannel],
			{},
			PickList[ToList@resolvedStandard, standardDurationConsistentErrors, True]
		];

		(* If there are any missing anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
		inconsistentStandardGradientDurationOptions = If[Length[inconsistentStandardGradientDuration] > 0 && messagesQ && notInEngine,
			(
				Message[Warning::HPICGradientShortcutAmbiguity, StandardGradientDuration, "StandardGradientA/B/C/D"];
				{}
			),
			{}
		];

		(* Generate test for missing specification among anion gradient start, end and duration *)
		consistentStandardGradientDurationTests = warningOrNullIndexMatched["Specified values for StandardGradientDuration and StandardGradientA/B/C/D are consistent:", resolvedStandard, standardDurationConsistentErrors];

		(* 38. CationStandardColumnTemperature, CationStandardSuppressorCurrent, and CationStandardDetectionTemperature resolution *)

		{
			resolvedCationStandardColumnTemperature,
			resolvedCationStandardSuppressorMode,
			resolvedCationStandardSuppressorVoltage,
			resolvedCationStandardSuppressorCurrent,
			resolvedCationStandardDetectionTemperature,
			incompatibleCationStandardColumnTemperatureErrors,
			conflictingCationStandardSuppressorModeErrors,
			incompatibleCationStandardSuppressorVoltageErrors,
			incompatibleCationStandardSuppressorCurrentErrors,
			incompatibleCationStandardDetectionTemperatureErrors
		} = Module[{injectionTableWithID, gradientInInjectionTable, cationStandardColumnTemperature, cationStandardSuppressorCurrentLookup, cationStandardDetectionTemperatureLookup,
			cationStandardSuppressorCurrent, compatibleCationStandardSuppressorCurrentQ, cationStandardDetectionTemperature, compatibleCationStandardDetectionTemperatureQ,
			incompatibleCationStandardColumnTemperatureQ, cationStandardSuppressorModeLookup, cationStandardSuppressorVoltageLookup, cationStandardSuppressorMode, maxFlowRate,
			myGradient, maxBufferConc, defaultMinCationSuppressorCurrent, defaultMaxCationSuppressorCurrent, cationStandardSuppressorVoltage, cationStandardSuppressorModeConflictQ,
			compatibleCationStandardSuppressorVoltageQ, allBufferPercent, totalBufferConcentration},

			If[!cationStandardExistQ || MatchQ[mapThreadFriendlyCationStandardOptions, Null],
				{Null, Null, Null, Null, Null, False, False, False, False, False},

				Transpose[MapThread[Function[{mySample, myResolvedGradient, myMapThreadOptions},

					injectionTableWithID = Map[
						If[MatchQ[#[[2]], ObjectP[]],
							Join[ToList@#[[1]], ToList@Download[#[[2]], Object], #[[3 ;; Length[#]]]],
							#
						]&,
						cationInjectionTableLookupRounded
					];

					(* If InjectionTable is not the default value of automatic, then look up the gradient object specified for mySample *)
					gradientInInjectionTable = If[!MatchQ[injectionTableWithID, ListableP[Automatic]],
						Cases[injectionTableWithID, {Standard, Download[mySample, Object], _, _, gradientObj : ObjectP[Object[Method, IonChromatographyGradient]]} :> gradientObj],
						Null
					];

					(* Download the gradient object from fullCache and extract column temperature information *)
					cationStandardColumnTemperature = Which[

						(* If user has already specified anion column temperature, go with that *)
						!MatchQ[Lookup[myMapThreadOptions, CationStandardColumnTemperature], ListableP[Automatic | Null]],
						Lookup[myMapThreadOptions, CationStandardColumnTemperature],

						(* If the specified AnionGradient is a method object, extract column temperature from there *)
						MatchQ[myResolvedGradient, ObjectP[Object[Method, IonChromatographyGradient]]],
						If[NullQ[Lookup[fetchPacketFromCache[Download[myResolvedGradient, Object], fullCache], CationColumnTemperature]],
							Ambient,
							Lookup[fetchPacketFromCache[Download[myResolvedGradient, Object], fullCache], CationColumnTemperature]
						],

						(* If the specified gradient in the InjectionTable is an Object, extract column temperature from there *)
						MatchQ[gradientInInjectionTable, ObjectP[Object[Method, IonChromatographyGradient]]],
						Lookup[fetchPacketFromCache[Download[gradientInInjectionTable, Object], fullCache], CationColumnTemperature],

						MatchQ[resolvedCationColumnTemperature, {Null} | Null | {}],
						Ambient,

						MatchQ[resolvedCationColumnTemperature[[1]], Ambient],
						Ambient,

						True,
						resolvedCationColumnTemperature[[1]]
					];

					(* Look up the specified options from the map thread friendly version of the anion options *)
					{
						cationStandardSuppressorModeLookup,
						cationStandardSuppressorVoltageLookup,
						cationStandardSuppressorCurrentLookup,
						cationStandardDetectionTemperatureLookup
					} = Lookup[myMapThreadOptions,
						{
							CationStandardSuppressorMode,
							CationStandardSuppressorVoltage,
							CationStandardSuppressorCurrent,
							CationStandardDetectionTemperature
						}
					];

					(* If user specified AnionSuppressorMode, go with that *)
					cationStandardSuppressorMode = Which[

						(* If user specified suppressor mode, then go with that *)
						MatchQ[cationStandardSuppressorModeLookup, Except[Null | Automatic]],
						cationStandardSuppressorModeLookup,

						(* If user does not specify suppressor mode but instead specify suppressor voltage, set suppressorMode to DynamicMode *)
						MatchQ[cationStandardSuppressorVoltageLookup, Except[Null | Automatic]],
						DynamicMode,

						(* Similarly, if user does not specify suppressor mode but instead specify suppressor current, set suppressorMode to LegacyMode *)
						MatchQ[cationStandardSuppressorCurrentLookup, Except[Null | Automatic]],
						LegacyMode,

						(* If nothing is specified, resolve to DynamicMode *)
						True,
						LegacyMode
					];

					(*Get the actual gradient list*)
					myGradient = If[MatchQ[myResolvedGradient, ObjectP[Object[Method]]],
						(*If our resolved gradient is an object, we need to extract the actual gradient from the correct field*)
						Lookup[fetchPacketFromCache[Download[myResolvedGradient, Object], fullCache], CationGradient],
						(*Otherwise it is already a list of sample and flow rate*)
						myResolvedGradient
					];

					(* Pull out the percent of all 4 buffers from the resolvedGradient *)
					allBufferPercent = If[MatchQ[myResolvedGradient, ObjectP[Object[Method, IonChromatographyGradient]]],
						(Lookup[fetchPacketFromCache[Download[myResolvedGradient, Object], fullCache], CationGradient][[All, 2 ;; 5]]) / (100 Percent),
						myResolvedGradient[[All, 2 ;; 5]] / (100 Percent)
					];
					(* Calculate the total concentration of all 4 buffers *)
					totalBufferConcentration = Map[Times[#, {bufferAConcentration, bufferBConcentration, bufferCConcentration, bufferDConcentration}]&, allBufferPercent];

					(* Preparation to resolve cationSuppressorCurrent *)
					(* cationSuppressorCurrent (mA) = FlowRate (min/mL) x [Eluent] x suppressor specific Factor *)
					maxFlowRate = Convert[Max[myGradient[[All, -1]]], Milliliter / Minute];
					maxBufferConc = Max[totalBufferConcentration];
					defaultMinCationSuppressorCurrent = SafeRound[Unitless[maxFlowRate * maxBufferConc * cationSuppressorSpecificFactor], 1, Round -> Up] * Milli * Ampere;

					{cationStandardSuppressorVoltage, cationStandardSuppressorCurrent, cationStandardSuppressorModeConflictQ} = Which[

						(* If CationSuppressorMode option is set to DynamicMode, then we need to resolve CationSuppressorVoltage and set CationSuppressorCurrent to Null *)
						MatchQ[cationStandardSuppressorMode, DynamicMode],
						If[
							(* First we need to make sure when CationSuppressorMode is set to DynamicMode, CationSuppressorCurrent is not specified *)
							(* If it is specified, set error tracking variable to True so that we can throw error later *)
							MatchQ[cationStandardSuppressorVoltageLookup, Null],
							{Null, Null, True},

							Which[
								(* If CationSuppressorVoltage is specified, go with that *)
								MatchQ[cationStandardSuppressorVoltageLookup, Except[Automatic]],
								{cationStandardSuppressorVoltageLookup, Null, False},

								(* If not, use the factory recommended value of the suppressor *)
								MatchQ[cationStandardSuppressorVoltageLookup, Automatic],
								{cationSuppressorRecommendedVoltage, Null, False},

								True,
								{cationSuppressorRecommendedVoltage, Null, False}
							]
						],

						(* If CationSuppressorMode option is set to LegacyMode, then we need to resolve CationSuppressorCurrent and set CationSuppressotVoltage to Null *)
						MatchQ[cationStandardSuppressorMode, LegacyMode],
						If[
							(* First we need to make sure when CationSuppressorMode is set to LegacyModel, CationSuppressorVoltage is not specified *)
							(* If it is specified, set error tracking variable to True so that we can throw error later *)
							MatchQ[cationStandardSuppressorCurrentLookup, Null],
							{Null, Null, True},

							Which[
								(* If CationSuppressorCurrent is specified, go with that *)
								MatchQ[cationStandardSuppressorCurrentLookup, Except[Automatic]],
								{Null, cationStandardSuppressorCurrentLookup, False},

								(* If not, use the factory recommended value of the suppressor *)
								MatchQ[cationStandardSuppressorCurrentLookup, Automatic],
								{Null, defaultMinCationSuppressorCurrent, False},

								MatchQ[defaultMinCationSuppressorCurrent, 0 Milliampere],
								{Null, 15 Milliampere, False},

								True,
								{Null, defaultMinCationSuppressorCurrent, False}
							]
						],

						True,
						{Null, Null, False}

					];

					(* Check whether the resolved cation suppressor voltage is less than the maximum voltage allowed by the instrument; if not, the error tracking vraible will be set to True *)
					compatibleCationStandardSuppressorVoltageQ = If[NullQ[cationStandardSuppressorVoltage],
						False,
						Not[LessEqual[cationStandardSuppressorVoltage, maxCationSuppressorVoltage /. Null -> Infinity Volt]]
					];

					(* Check wether the resolved cation suppressor current is less than the maximum current allowed by the instrument; if not, the error tracking variable will be set to True *)
					compatibleCationStandardSuppressorCurrentQ = If[NullQ[cationStandardSuppressorCurrent],
						False,

						Not[LessEqual[cationStandardSuppressorCurrent, maxCationSuppressorCurrent]]
					];

					(* If user specified CationDetectionTemperature, go with that *)
					cationStandardDetectionTemperature = If[MatchQ[cationStandardDetectionTemperatureLookup, Except[Automatic | Null]],
						cationStandardDetectionTemperatureLookup,
						(* Otherwise, use Ambient detection *)
						Which[
							MatchQ[resolvedCationDetectionTemperature, Null | {} | {Null}],
							Ambient,

							MatchQ[resolvedCationDetectionTemperature[[1]], Ambient],
							Ambient,

							Not[Between[resolvedCationDetectionTemperature[[1]], {minCationDetectionTemperature /. Null -> -Infinity Celsius, maxCationDetectionTemperature /. Null -> Infinity Celsius}]],
							Ambient,

							True,
							resolvedCationDetectionTemperature[[1]]
						]
					];

					(* Check wether the resolved anion detection temperature is in the range of allowed detection temperature by the instrument; if not, the error tracking variable will be set to True *)
					compatibleCationStandardDetectionTemperatureQ = If[MatchQ[cationStandardDetectionTemperature, Ambient | Null],
						False,
						Not[Between[cationStandardDetectionTemperature, {minCationDetectionTemperature /. Null -> -Infinity Celsius, maxCationDetectionTemperature /. Null -> Infinity Celsius}]]
					];

					(* Gather MapThread results *)
					{
						cationStandardColumnTemperature,
						cationStandardSuppressorMode,
						cationStandardSuppressorVoltage,
						cationStandardSuppressorCurrent,
						cationStandardDetectionTemperature,
						incompatibleCationStandardColumnTemperatureQ,
						cationStandardSuppressorModeConflictQ,
						compatibleCationStandardSuppressorVoltageQ,
						compatibleCationStandardSuppressorCurrentQ,
						compatibleCationStandardDetectionTemperatureQ
					}
				],
					{ToList@resolvedCationStandard, resolvedCationStandardGradient, mapThreadFriendlyCationStandardOptions}
				]]]];

		(* == Error Checking == *)
		(* 38.1 Suppressor mode error check *)
		(* Pull out the cation samples that have conflicting suppressor mode and compile a list of conflicting suppressor mode*)
		conflictingCationSuppressorModeStandards = If[Length[ToList@resolvedCationStandard] == 0,
			{},
			PickList[ToList@resolvedCationStandard, conflictingCationStandardSuppressorModeErrors, True]
		];

		(* Throw error message and collect invalid option *)
		conflictingCationStandardSuppressorModeOptions = If[Length[conflictingCationSuppressorModeStandards] > 0 && messagesQ,
			(
				Message[Error::ConflictingSuppressorMode, ObjectToString[conflictingCationSuppressorModeStandards, Cache -> fullCache, Simulation -> updatedSimulation], CationStandardSuppressorMode, CationStandardSuppressorVoltage, CationStandardSuppressorCurrent];
				{CationStandardSuppressorMode, CationStandardSuppressorVoltage, CationStandardSuppressorCurrent}
			),
			{}
		];

		(* Generate test for conflicting suppressor mode *)
		cationStandardSuppressorModeTests = testOrNullIndexMatched["CationStandardSuppressorVoltage and CationStandardSuppressorCurrent are set if CationStandardSuppressorMode is set to DynamicMode and LegacyMode respectively:", resolvedCationStandard, conflictingCationStandardSuppressorModeErrors];

		(* Upper bounds built into widgets - no need for error checking
        (* 38.2 Suppressor voltage error check *)
        (* Pull out the cation samples that have incompatible suppressor current and compile a list of incompatible suppressor current *)
        incompatibleSuppressorVoltageCationStandards=If[Length[ToList@resolvedCationStandard]==0,
            {},
            PickList[ToList@resolvedCationStandard,incompatibleCationStandardSuppressorVoltageErrors,True]
        ];
        incompatibleCationStandardSuppressorVoltage=If[Length[ToList@resolvedCationStandard]==0,
            {},
            PickList[resolvedCationStandardSuppressorVoltage,incompatibleCationStandardSuppressorVoltageErrors,True]
        ];

        (* Throw error message and collect invalid option *)
        invalidCationStandardSuppressorVoltageOptions=If[Length[incompatibleSuppressorVoltageCationStandards]>0&&messagesQ,
            (
                Message[Error::IncompatibleSuppressorVoltage,incompatibleCationStandardSuppressorVoltage,CationStandard,ObjectToString[incompatibleSuppressorVoltageCationStandards,Cache -> fullCache, Simulation -> updatedSimulation],maxCationSuppressorVoltage/.Null->Infinity Volt];
                {CationStandardSuppressorVoltage}
            ),
            {}
        ];

        (* Generate test for invalid max acceleration *)
        cationStandardSuppressorVoltageTests=testOrNullIndexMatched["CationStandardSuppressorVoltage is less than the maximum suppressor voltage supported by the instrument:",resolvedCationStandard,incompatibleCationStandardSuppressorVoltageErrors];

        (* 38.3 Check whether the resolved cation standard column temperature is within the acceptable temperature range *)
        (* Identify resolved cation samples that have incompatible column temperature and also compiled a list of incompatible temperatures *)
        incompatibleColumnTemperatureCationStandard=If[Length[ToList@resolvedCationStandard]==0,
            {},
            PickList[ToList@resolvedCationStandard,incompatibleCationStandardColumnTemperatureErrors,True]
        ];
        incompatibleCationStandardColumnTemperature=If[Length[ToList@resolvedCationStandard]==0,
            {},
            PickList[resolvedCationStandardColumnTemperature,incompatibleCationStandardColumnTemperatureErrors,True]
        ];

        (* If there are any incompatible column temperatures and we are throwing messages, throw an error and collect in valid option *)
        incompatibleCationStandardColumnTemperatureOptions=If[Length[incompatibleCationStandardColumnTemperature]>0&&messagesQ,
            (
                Message[Error::IncompatibleCationColumnTemperature,incompatibleCationStandardColumnTemperature,CationStandard,ObjectToString[incompatibleColumnTemperatureCationStandard,Cache -> fullCache, Simulation -> updatedSimulation],allowedCationColumnTemperatureRange[[1]],allowedCationColumnTemperatureRange[[2]]];
                {CationStandardColumnTemperature}
            ),
            {}
        ];

        (* Generate tests for incompatible cation column temperature *)
        incompatibleCationStandardColumnTemperatureTests=testOrNullIndexMatched["Specified CationStandardColumnTemperature is within the range of supported temperature of the CationColumn:",resolvedCationStandard,incompatibleCationStandardColumnTemperatureErrors];

        (* 38.4 Suppressor current error check *)
        (* Pull out the cation standard that have incompatible suppressor current and compile a list of incompatible suppressor current *)
        incompatibleSuppressorCurrentCationStandard=If[Length[ToList@resolvedCationStandard]==0,
            {},
            PickList[ToList@resolvedCationStandard,incompatibleCationStandardSuppressorCurrentErrors,True]
        ];
        incompatibleCationStandardSuppressorCurrent=If[Length[ToList@resolvedCationStandard]==0,
            {},
            PickList[resolvedCationStandardSuppressorCurrent,incompatibleCationStandardSuppressorCurrentErrors,True]
        ];

        (* Throw error message and collect invalid option *)
        invalidCationStandardSuppressorCurrentOptions=If[Length[incompatibleSuppressorCurrentCationStandard]>0&&messagesQ,
            (
                Message[Error::IncompatibleSuppressorCurrent,incompatibleCationStandardSuppressorCurrent,CationStandard,ObjectToString[incompatibleSuppressorCurrentCationStandard,Cache -> fullCache, Simulation -> updatedSimulation],minAllowedCationStandardSuppressorCurrent,maxAllowedCationStandardSuppressorCurrent];
                {CationStandardSuppressorCurrent}
            ),
            {}
        ];

        (* Generate test for invalid max acceleration *)
        cationStandardSuppressorCurrentTests=testOrNullIndexMatched["CationStandardSuppressorCurrent is less than the maximum suppressor current supported by the instrument:",resolvedCationStandard,incompatibleCationStandardSuppressorCurrentErrors];

        (* 38.5 Detection Temperature error check *)
        (* Pull out the cation samples that have incompatible suppressor current and compile a list of incompatible suppressor current *)
        incompatibleDetectionTemperatureCationStandard=If[Length[ToList@resolvedCationStandard]==0,
            {},
            PickList[ToList@resolvedCationStandard,incompatibleCationStandardDetectionTemperatureErrors,True]
        ];
        incompatibleCationStandardDetectionTemperature=If[Length[ToList@resolvedCationStandard]==0,
            {},
            PickList[resolvedCationStandardDetectionTemperature,incompatibleCationStandardDetectionTemperatureErrors,True]
        ];

        (* Throw error message and collect invalid option *)
        invalidCationStandardDetectionTemperatureOptions=If[Length[incompatibleDetectionTemperatureCationStandard]>0&&messagesQ,
            (
                Message[Error::IncompatibleDetectionTemperature,incompatibleCationStandardDetectionTemperature,CationStandard,ObjectToString[incompatibleDetectionTemperatureCationStandard,Cache -> fullCache, Simulation -> updatedSimulation],minCationDetectionTemperature/.Null->-Infinity Celsius,maxCationDetectionTemperature/.Null->Infinity Celsius];
                {CationStandardDetectionTemperature}
            ),
            {}
        ];

        (* Generate test for invalid max acceleration *)
        cationStandardDetectionTemperatureTests=testOrNullIndexMatched["CationStandardDetectionTemperature is within the range of detection temperatures set by the instrument:",resolvedCationStandard,incompatibleCationStandardDetectionTemperatureErrors]; *)

		{
			resolvedStandardColumnTemperature,
			resolvedStandardAbsorbanceWavelength,
			resolvedStandardAbsorbanceSamplingRate,
			resolvedStandardElectrochemicalDetectionMode,
			resolvedStandardReferenceElectrodeMode,
			resolvedStandardVoltageProfile,
			resolvedStandardWaveformProfile,
			resolvedStandardElectrochemicalSamplingRate,
			resolvedStandardDetectionTemperature,
			standardAbsorbanceOptionConflictErrors,
			standardElectrochemicalOptionConflictErrors,
			standardElectrochemicalModeOptionConflictErrors,
			multipleStandardDetectionModeErrors,
			standardWaveformDetectionModeErrors,
			multipleStandardWaveformDurationErrors,
			duplicateStandardVoltageProfileTimeErrors,
			duplicateStandardWaveformProfileTimeErrors
		} = Module[{standardAbsorbanceOptionConflictQ, standardAbsorbanceWavelength, standardAbsorbanceSamplingRate, injectionTableWithID, injectionTableStandardWaveformEntry,
			standardElectrochemicalModeOptionConflictQ, standardWaveformDetectionMode, multipleStandardDetectionModeQ, standardElectrochemicalDetectionMode,
			standardWaveformDetectionModeConflictQ, gradientInInjectionTable, standardColumnTemperature, standardReferenceElectrodeMode,
			standardVoltageProfile, standardVoltageProfileDuplicateTimeQ, standardWaveformProfile, standardWaveformProfileDuplicateTimeQ, standardWaveformDuration,
			multipleStandardWaveformDurationQ, standardElectrochemicalSamplingRate, standardDetectionTemperature, injectionTableStandardVoltageEntry,
			standardElectrochemicalOptionConflictQ},

			If[
				MatchQ[resolvedStandard, {} | Null | {Null}] || !MemberQ[ToList@doubleResolvedStandardAnalysisChannel, ElectrochemicalChannel],
				Join[ConstantArray[{}, 9], ConstantArray[False, 8]],

				(* Set up map thread for resolving detection options *)
				Transpose[MapThread[Function[{mySample, myResolvedGradient, myMapThreadOptions},

					(* First download all the sample objects specified in the InjectionTable *)
					injectionTableWithID = Map[
						If[MatchQ[#[[2]], ObjectP[]],
							Join[ToList@#[[1]], ToList@Download[#[[2]], Object], #[[3 ;; Length[#]]]],
							#
						]&,
						electrochemicalInjectionTableLookupRounded
					];

					(* If InjectionTable is not the default value of automatic, then look up the gradient object specified for mySample *)
					gradientInInjectionTable = If[!MatchQ[injectionTableWithID, ListableP[Automatic]],
						Cases[injectionTableWithID, {Standard, Download[mySample, Object], _, _, gradientObj : ObjectP[Object[Method, Method]]} :> gradientObj],
						Null
					];

					(* Download the gradient object from fullCache and extract column temperature information *)
					standardColumnTemperature = Which[

						(* If user has already specified anion column temperature, go with that *)
						!MatchQ[Lookup[myMapThreadOptions, StandardColumnTemperature], ListableP[Automatic]],
						Lookup[myMapThreadOptions, StandardColumnTemperature],

						(* If the specified Gradient is a method object, extract column temperature from there *)
						MatchQ[myResolvedGradient, ObjectP[Object[Method, Gradient]]],
						If[NullQ[Lookup[fetchPacketFromCache[Download[myResolvedGradient, Object], fullCache], Temperature]],
							Ambient,
							Lookup[fetchPacketFromCache[Download[myResolvedGradient, Object], fullCache], Temperature]
						],

						(* If the specified gradient in the InjectionTable is an Object, extract column temperature from there *)
						MatchQ[gradientInInjectionTable, ObjectP[Object[Method, Gradient]]],
						Lookup[fetchPacketFromCache[Download[gradientInInjectionTable, Object], fullCache], Temperature] /. {Null :> Ambient},

						MatchQ[resolvedColumnTemperature, {Null} | Null | {}],
						Ambient,

						MatchQ[resolvedColumnTemperature[[1]], Ambient],
						Ambient,

						True,
						resolvedColumnTemperature[[1]]
					];

					(* Before resolving the absorbance options, first do some option conflict checks *)
					standardAbsorbanceOptionConflictQ = If[
						MemberQ[ToList@resolvedDetector, UVVis],
						Switch[
							(* We will look up the specified value of Absorbance related options *)
							Lookup[myMapThreadOptions, {StandardAbsorbanceWavelength, StandardAbsorbanceSamplingRate}],

							(* Both options cannot be null *)
							{Except[Null], Except[Null]},
							False,

							(* Otherwise set the error tracking variable to True *)
							{_, _},
							True
						],
						False
					];

					standardAbsorbanceWavelength = Which[
						(* If user specified absorbance wavelength, go with that *)
						MatchQ[Lookup[myMapThreadOptions, StandardAbsorbanceWavelength], Except[Automatic]],
						Lookup[myMapThreadOptions, StandardAbsorbanceWavelength],

						MatchQ[Lookup[myMapThreadOptions, StandardAbsorbanceSamplingRate], Null],
						Null,

						(* If absorbance wavelength is specified for the sample, use the first wavelength from the resolved absorbance wavelength *)
						MatchQ[resolvedAbsorbanceWavelength, Except[Automatic]],
						ToList[resolvedAbsorbanceWavelength][[1]],

						(* Otherwise, set to 280 nm *)
						True,
						280 Nanometer
					];

					standardAbsorbanceSamplingRate = Which[

						(* If user specified absorbance wavelength sampling rate, go with that *)
						MatchQ[Lookup[myMapThreadOptions, StandardAbsorbanceSamplingRate], Except[Automatic]],
						Lookup[myMapThreadOptions, StandardAbsorbanceSamplingRate],

						(* If Absorbance wavelength is already Null, set sampling rate to Null as well *)
						NullQ[standardAbsorbanceWavelength],
						Null,

						(* If we are only reading at one wavelength, then set sampling rate to 10/Second *)
						Length[ToList@standardAbsorbanceWavelength] == 1,
						10 / Second,

						(* If we are reading at multiple wavelengths, then set sampling rate to 1/Second *)
						Length[ToList@standardAbsorbanceWavelength] > 1,
						1 / Second,

						(* Otherwise, set to Null *)
						True,
						Null
					];

					(* Then find the entry of the particular sample in the injection table *)
					{injectionTableStandardWaveformEntry, injectionTableStandardVoltageEntry} = If[electrochemicalInjectionTableSpecifiedQ,
						If[MatchQ[Cases[injectionTableWithID, {Standard, Download[mySample, Object], ___}], {}],
							{Null, Null},
							First[Cases[injectionTableWithID, {Standard, Download[mySample, Object], ___}]][[5 ;; 6]]
						],
						{Automatic, Automatic}
					];

					(* Before resolving the electrochemical options, first do some option conflict checks *)
					standardElectrochemicalOptionConflictQ = If[MemberQ[ToList@resolvedDetector, ElectrochemicalDetector],
						Switch[
							(* We will look up the specified value of Absorbance related options *)
							Lookup[myMapThreadOptions, {StandardElectrochemicalDetectionMode, StandardReferenceElectrodeMode, StandardElectrochemicalSamplingRate, StandardDetectionTemperature}],

							(* Both options cannot be null *)
							{Except[Null], Except[Null], Except[Null], Except[Null]},
							False,

							(* Otherwise set the error tracking variable to True *)
							{_, _, _, _},
							True
						],
						False
					];

					(* Before resolving all the electrochemical detection mode option, first do some option conflict checks *)
					standardElectrochemicalModeOptionConflictQ = Switch[

						(* We will look up the specified value of Absorbance related options *)
						Lookup[myMapThreadOptions, {StandardElectrochemicalDetectionMode, StandardVoltageProfile, StandardWaveformProfile}],

						(* If they are both Null, there's no conflict *)
						{DCAmperometricDetection | {DCAmperometricDetection}, Null | {Null}, _},
						True,

						(* If they are both specified, there's also no conflict *)
						{PulsedAmperometricDetection | {PulsedAmperometricDetection}, _, Null | {Null}},
						True,

						(* If only one of the option value is Null, then set the conflict variable to True *)
						{IntegratedPulsedAmperometricDetection | {IntegratedPulsedAmperometricDetection}, _, Null | {Null}},
						True,

						{_, _, _},
						False
					];

					(* Before resolving electrochemical detection mode, let's first pull out the electrochemical mode from any waveforms specified *)
					standardWaveformDetectionMode = Which[

						(* If WaveformProfile is specified, detection mode can either be Pulsed Amperometry or Integrated Pulsed Amperometry *)
						MatchQ[Lookup[myMapThreadOptions, StandardWaveformProfile], Except[Automatic]],
						Which[

							(* If WaveformProfile is specified as a method object, then directly pull ElectrochemicalDetectionMode field from it *)
							MatchQ[Lookup[myMapThreadOptions, StandardWaveformProfile], ObjectP[Object[Method, Waveform]]],
							Lookup[fetchPacketFromCache[Download[Lookup[myMapThreadOptions, StandardWaveformProfile], Object], fullCache], ElectrochemicalDetectionMode],

							(* If WaveformProfile is specified as multiple method objects, then track ElectrochemicalDetectionMode of all methods and use ElectrochemicalDetectionMode from the first method *)
							MatchQ[Lookup[myMapThreadOptions, StandardWaveformProfile], {{TimeP, ObjectP[Object[Method, Waveform]]}...}],
							Lookup[fetchPacketFromCache[#, fullCache], ElectrochemicalDetectionMode]& /@ Download[Lookup[myMapThreadOptions, StandardWaveformProfile][[All, 2]], Object],

							(* If WaveformProfile is specified as tuples of {Time,Voltage,Boolean,Boolean}, then it gets a little more complicated *)
							(* We will have to look at the second Boolean and the Voltage value to determine ElectrochemicalDetectionMode *)
							(* If voltages specified are one constant value when the second Boolean is True then it is PulsedAmperometricDetection *)
							(* If voltages specified are more than one value when the second Boolean is True then it is IntegratedPulsedAmperometricDetection *)
							MatchQ[Lookup[myMapThreadOptions, StandardWaveformProfile], {{TimeP, VoltageP, BooleanP, BooleanP}...}],
							Module[{integratedEntries, integratedVoltages},

								(* First pick out the entries where the secnd Boolean is True, aka when integration happens *)
								integratedEntries = Select[Lookup[myMapThreadOptions, StandardWaveformProfile], #[[4]] == True&];

								(* Then pull out the voltages of the entire integration period *)
								integratedVoltages = integratedEntries[[All, 2]];
								If[Length[DeleteDuplicates[integratedVoltages]] == 1,
									PulsedAmperometricDetection,
									IntegratedPulsedAmperometricDetection
								]
							],

							(* Final case, if WaveformProfile is specified as tuples of {Time, {Time,Voltage,Boolean,Boolean}}, then we apply the logic above *)
							MatchQ[Lookup[myMapThreadOptions, StandardWaveformProfile], {{TimeP, {{TimeP, VoltageP, BooleanP, BooleanP}...}...}...}],
							Module[{waveforms, integratedEntries, integratedVoltages},

								(* First pick out the entries where the secnd Boolean is True, aka when integration happens *)
								waveforms = Lookup[myMapThreadOptions, StandardWaveformProfile][[All, 2]];
								integratedEntries = Map[
									Function[{waveform},
										Select[waveform, #[[4]] == True&]
									],
									waveforms
								];

								(* Then pull out the voltages of the entire integration period *)
								integratedVoltages = integratedEntries[[All, All, 2]];
								If[Length[DeleteDuplicates[#]] == 1,
									PulsedAmperometricDetection,
									IntegratedPulsedAmperometricDetection
								]& /@ integratedVoltages
							]
						],

						(* If WaveformProfile is specified in the injection table, detection mode can either be Pulsed Amperometry or Integrated Pulsed Amperometry *)
						MatchQ[injectionTableStandardWaveformEntry, Except[Automatic | Null]],
						Which[
							(* If WaveformProfile is specified in the injection table, download the method and pull ElectrochemicalDetectionMode *)
							MatchQ[injectionTableStandardWaveformEntry, ObjectP[Object[Method, Waveform]]],
							Lookup[fetchPacketFromCache[Download[injectionTableStandardWaveformEntry, Object], fullCache], ElectrochemicalDetectionMode],

							(* If WaveformProfile is specified as multiple method objects in the injection table, then track ElectrochemicalDetectionMode of all methods *)
							MatchQ[injectionTableStandardWaveformEntry, {{TimeP, ObjectP[Object[Method, Waveform]]}...}],
							Lookup[fetchPacketFromCache[#, fullCache], ElectrochemicalDetectionMode]& /@ Download[injectionTableStandardWaveformEntry[[All, 2]], Object],

							(* Similar logic applies for Waveform specified in the injection table *)
							MatchQ[injectionTableStandardWaveformEntry, {{TimeP, VoltageP, BooleanP, BooleanP}...}],
							Module[{integratedEntries, integratedVoltages},

								(* First pick out the entries where the secnd Boolean is True, aka when integration happens *)
								integratedEntries = Select[injectionTableStandardWaveformEntry, #[[4]] == True&];

								(* Then pull out the voltages of the entire integration period *)
								integratedVoltages = integratedEntries[[All, 2]];
								If[Length[DeleteDuplicates[integratedVoltages]] == 1,
									PulsedAmperometricDetection,
									IntegratedPulsedAmperometricDetection
								]
							],

							(* The injection table specified with same logic as above *)
							MatchQ[injectionTableStandardWaveformEntry, {{TimeP, {{TimeP, VoltageP, BooleanP, BooleanP}...}...}...}],
							Module[{waveforms, integratedEntries, integratedVoltages},

								(* First pick out the entries where the secnd Boolean is True, aka when integration happens *)
								waveforms = injectionTableStandardWaveformEntry[[All, 2]];
								integratedEntries = Map[
									Function[{waveform},
										Select[waveform, #[[4]] == True&]
									],
									waveforms
								];

								(* Then pull out the voltages of the entire integration period *)
								integratedVoltages = integratedEntries[[All, 2]];
								If[Length[DeleteDuplicates[#]] == 1,
									PulsedAmperometricDetection,
									IntegratedPulsedAmperometricDetection
								]& /@ integratedVoltages
							]
						],

						(* If all things fail, return PulsedAmperometricDetection *)
						True,
						Automatic
					];

					multipleStandardDetectionModeQ = Module[{uniqueDetectionMode},
						(* Get the unique detection modes from all waveforms specified *)
						uniqueDetectionMode = DeleteDuplicates[ToList[standardWaveformDetectionMode]];
						(* If there are more than 1 detection mode, set error tracking variable to True, otherwise set it to False *)
						If[Length[uniqueDetectionMode] == 1,
							False,
							True
						]
					];

					standardElectrochemicalDetectionMode = Which[

						(* If user specified electrochemical detection mode, go with that *)
						MatchQ[Lookup[myMapThreadOptions, StandardElectrochemicalDetectionMode], Except[Automatic]],
						Lookup[myMapThreadOptions, StandardElectrochemicalDetectionMode],

						!MemberQ[ToList@resolvedDetector, ElectrochemicalDetector],
						Null,

						(* If VoltageProfile is specified, set detection mode to DC Amperometry *)
						MatchQ[Lookup[myMapThreadOptions, StandardVoltageProfile], Except[Automatic]] || MatchQ[injectionTableStandardVoltageEntry, Except[Automatic | Null]],
						DCAmperometricDetection,

						MatchQ[First@ToList[standardWaveformDetectionMode], Except[Automatic]],
						First@ToList[standardWaveformDetectionMode],

						MatchQ[First[ToList[resolvedElectrochemicalDetectionMode]], Except[Null]],
						First[ToList[resolvedElectrochemicalDetectionMode]],

						(* Use the ElectrochemicalDetectionMode of the first waveform as the resolved electrochemicalDetection Mode *)
						True,
						PulsedAmperometricDetection
					];

					(* Here we check if the electrochemical detection mode and the specified waveform is in conflict *)
					(* If there is already multiple detection mode error, then we can pass on this error *)
					standardWaveformDetectionModeConflictQ = If[multipleStandardDetectionModeQ,
						False,
						If[MatchQ[standardElectrochemicalDetectionMode, Except[DCAmperometricDetection]],
							If[!MatchQ[standardWaveformDetectionMode, Automatic],
								!MatchQ[First@ToList[standardWaveformDetectionMode], standardElectrochemicalDetectionMode],
								False
							],
							False
						]
					];

					standardReferenceElectrodeMode = Which[

						(* If user specified reference electrode mode, go with that *)
						MatchQ[Lookup[myMapThreadOptions, StandardReferenceElectrodeMode], Except[Automatic]],
						Lookup[myMapThreadOptions, StandardReferenceElectrodeMode],

						(* If ElectrochemicalDetectionMode is set to DCAmperometry, set reference electrode mode to Null *)
						MatchQ[Lookup[myMapThreadOptions, StandardElectrochemicalDetectionMode], DCAmperometricDetection],
						Null,

						(* If VoltageProfile is specified, set reference electrode mode to DC Amperometry *)
						MatchQ[Lookup[myMapThreadOptions, StandardVoltageProfile], Except[Automatic]] || MatchQ[injectionTableStandardVoltageEntry, Except[Null | Automatic]],
						Null,

						(* If WaveformProfile is specified, detection mode can either be Pulsed Amperometry or Integrated Pulsed Amperometry *)
						MatchQ[Lookup[myMapThreadOptions, StandardWaveformProfile], Except[Automatic]],
						Which[

							(* If WaveformProfile is specified as a method object, then directly pull ReferenceElectrodeMode field from it *)
							MatchQ[Lookup[myMapThreadOptions, StandardWaveformProfile], ObjectP[Object[Method, Waveform]]],
							Lookup[fetchPacketFromCache[Download[Lookup[myMapThreadOptions, StandardWaveformProfile], Object], fullCache], ReferenceElectrodeMode],

							(* If WaveformProfile is specified as multiple method objects, then track ReferenceElectrodeMode of all methods and use ReferenceElectrodeMode from the first method *)
							MatchQ[Lookup[myMapThreadOptions, StandardWaveformProfile], {{TimeP, ObjectP[Object[Method, Waveform]]}...}],
							Lookup[fetchPacketFromCache[Download[Lookup[myMapThreadOptions, StandardWaveformProfile][[1, 2]], Object], fullCache], ReferenceElectrodeMode],

							True,
							AgCl
						],

						(* If WaveformProfile is specified, detection mode can either be Pulsed Amperometry or Integrated Pulsed Amperometry *)
						MatchQ[injectionTableStandardWaveformEntry, Except[Automatic]],
						Which[
							(* If WaveformProfile is specified in the injection table, download the method and pull ReferenceElectrodeMode *)
							MatchQ[injectionTableStandardWaveformEntry, ObjectP[Object[Method, Waveform]]],
							Lookup[fetchPacketFromCache[Download[injectionTableStandardWaveformEntry, Object], fullCache], ReferenceElectrodeMode],

							(* If WaveformProfile is specified as multiple method objects in the injection table, then track ReferenceElectrodeMode of all methods and use ReferenceElectrodeMode from the first method *)
							MatchQ[injectionTableStandardWaveformEntry, {{TimeP, ObjectP[Object[Method, Waveform]]}...}],
							Lookup[fetchPacketFromCache[Download[injectionTableStandardWaveformEntry, Object], fullCache], ReferenceElectrodeMode],

							True,
							AgCl
						],

						(* If there are resolved voltage profile for the samples, use the first resolved value there *)
						MatchQ[resolvedReferenceElectrodeMode, Except[Automatic]],
						ToList[resolvedReferenceElectrodeMode][[1]],

						(* If WaveformProfile is specified as tuples of {Time,Voltage,Boolean,Boolean} or {Time, {Time,Voltage,Boolean,Boolean}}, either in the option or in the injection table *)
						(* And this option is not specified, then go ahead and set reference electrode mode to AgCl *)
						True,
						AgCl
					];

					standardVoltageProfile = Which[

						(* If the user is not using DC Amperometry, set it to Null *)
						!MatchQ[standardElectrochemicalDetectionMode, DCAmperometricDetection],
						Null,

						(* If the user has specified voltage profile, go with it *)
						MatchQ[Lookup[myMapThreadOptions, StandardVoltageProfile], Except[Automatic]],
						Lookup[myMapThreadOptions, StandardVoltageProfile],

						(* If the user has specified voltage profile in the injection table, go with it *)
						MatchQ[injectionTableStandardVoltageEntry, Except[Automatic | Null]],
						injectionTableStandardVoltageEntry,

						(* If the user has specified voltage profile in the injection table, go with it *)
						MatchQ[injectionTableStandardWaveformEntry, Except[Automatic]],
						injectionTableStandardWaveformEntry,

						(* If nothing is sepcified, use the first resolved value for VoltageProfile option *)
						MatchQ[resolvedVoltageProfile, Except[Automatic | Null | {Null}]],
						If[duplicateVoltageProfileTimeErrors[[1]],
							0.1 Volt,
							ToList[resolvedVoltageProfile][[1]]
						],

						(* Otherwise, set it to 0.1 Volt throughout the whole gradient *)
						True,
						0.1 Volt
					];

					(* We need to check that the time specified in VoltageProfile is monotonically increasing *)
					standardVoltageProfileDuplicateTimeQ = Module[{timeDifferences},
						(* This check only makes sense when VoltageProfile is specified as tuples in the form of {Time,Voltage} *)
						If[MatchQ[standardVoltageProfile, {{TimeP, VoltageP}...}],
							timeDifferences = Differences[standardVoltageProfile[[All, 1]]];
							If[MatchQ[timeDifferences, {GreaterP[0 * Second]...}],
								False,
								True
							],
							False
						]
					];

					standardWaveformProfile = Which[

						(* If the user is using DC Amperometry, set it to Null *)
						MatchQ[standardElectrochemicalDetectionMode, DCAmperometricDetection],
						Null,

						(* If the user has specified waveform profile, go with it *)
						MatchQ[Lookup[myMapThreadOptions, StandardWaveformProfile], Except[Automatic]],
						Lookup[myMapThreadOptions, StandardWaveformProfile],

						(* If the user has specified waveform profile in the injection table, go with it *)
						MatchQ[injectionTableStandardWaveformEntry, Except[Automatic | Null]],
						injectionTableStandardWaveformEntry,

						(* If nothing is specified, use the first resolved waveform for the sample *)
						MatchQ[resolvedWaveformProfile, Except[Automatic | Null]],
						If[multipleWaveformDurationErrors[[1]],
							Values[Lookup[fetchPacketFromCache[Download[Object[Method, Waveform, "Gold Electrode Quad Potential for Carbohydrate Analysis"], Object], fullCache], Waveform]],
							ToList[resolvedWaveformProfile][[1]]
						],

						(* If nothing is specified, then first we look at the ElectrochemicalDetectionMode *)
						True,
						Which[

							(* If the detection mode is PulsedAmperometricDetection *)
							MatchQ[standardElectrochemicalDetectionMode, PulsedAmperometricDetection],

							If[MatchQ[fetchPacketFromCache[Download[resolvedWorkingElectrode, Object], fullCache], <||> | Null],
								Null,
								(* Then we look at the coat material of the working electrode and give default waveform *)
								Switch[
									Lookup[workingElectrodeModelPacket, CoatMaterial],

									Gold,
									Values[Lookup[fetchPacketFromCache[Download[Object[Method, Waveform, "Gold Electrode Quad Potential for Carbohydrate Analysis"], Object], fullCache], Waveform]],

									Silver,
									Values[Lookup[fetchPacketFromCache[Download[Object[Method, Waveform, "Silver Electrode for Sulfide, Cyanide, Iodide, Thiosulface Analysis"], Object], fullCache], Waveform]],

									Platinum,
									Values[Lookup[fetchPacketFromCache[Download[Object[Method, Waveform, "Platinum Electrode for Alcohols, Glycols, Carboxylates, Cyanide, Sulfide Analysis"], Object], fullCache], Waveform]],

									_,
									Null
								]
							],

							(* If the detection mode is IntegratedPulsedAmperometricDetection *)
							MatchQ[standardElectrochemicalDetectionMode, IntegratedPulsedAmperometricDetection],

							(* Then we look at the coat material of the working electrode and give default waveform *)
							If[MatchQ[fetchPacketFromCache[Download[resolvedWorkingElectrode, Object], fullCache], <||> | Null],
								Null,
								Switch[
									Lookup[workingElectrodeModelPacket, CoatMaterial],

									Gold,
									Object[Method, Waveform, "Gold AAA Electrode for Amino Acids, Carbohydrates, Water Soluble Vitamins Analysis"],

									_,
									Null
								]
							],

							True,
							Null
						]
					];

					(* We need to check that the time specified in WaveformProfile is monotonically increasing *)
					standardWaveformProfileDuplicateTimeQ = Module[{waveformTimeDifferences, retentionTimeDifferences},
						Which[
							(* We first check the waveform times specified as tuples in the form of {Time,Voltage,Interpolation,Integration} *)
							MatchQ[standardWaveformProfile, {{TimeP, VoltageP, BooleanP, BooleanP}...}],
							waveformTimeDifferences = Differences[standardWaveformProfile[[All, 1]]];
							If[MatchQ[waveformTimeDifferences, {GreaterP[0 * Second]...}],
								False,
								True
							],

							(* Then we check the waveform times as well as retention times specified as tuples in the form of {Time,{Time,Voltage,Interpolation,Integration}} *)
							MatchQ[standardWaveformProfile, {{TimeP, {{TimeP, VoltageP, BooleanP, BooleanP}...}...}...}],
							waveformTimeDifferences = Differences /@ ((Last /@ standardWaveformProfile)[[All, All, 1]]);
							retentionTimeDifferences = Differences[First /@ standardWaveformProfile];
							If[MatchQ[waveformTimeDifferences, {{GreaterP[0 * Second]...}...}] && MatchQ[retentionTimeDifferences, {GreaterP[0 * Second]...}],
								False,
								True
							],

							(* Finally we check waveform times specified in the form of {Time, Object[Method,Waveform]} *)
							MatchQ[standardWaveformProfile, {{TimeP, ObjectP[Object[Method, Waveform]]}...}],
							retentionTimeDifferences = Differences[First /@ standardWaveformProfile];
							If[MatchQ[retentionTimeDifferences, {GreaterP[0 * Second]...}],
								False,
								True
							],

							True,
							False
						]
					];

					(* Before resolving sampling rate, let's first get the waveform duration *)
					standardWaveformDuration = Which[

						(* If the resolved waveform profile consists of a single waveform, grab WaveformDuration from the method object *)
						MatchQ[standardWaveformProfile, ObjectP[Object[Method, Waveform]]],
						Lookup[fetchPacketFromCache[Download[standardWaveformProfile, Object], fullCache], WaveformDuration],

						(* If the resolved waveform profile consists of multiple waveforms, grab WaveformDuration from the first method object *)
						MatchQ[standardWaveformProfile, {{TimeP, ObjectP[Object[Method, Waveform]]}...}],
						Lookup[fetchPacketFromCache[#, fullCache], WaveformDuration]& /@ Download[standardWaveformProfile[[All, 2]], Object],

						(* If the resolved waveform profile consists of a tuple in the form of {Time,Voltage,Boolean,Boolean}, get the last time point to be the waveform duration *)
						MatchQ[standardWaveformProfile, {{TimeP, VoltageP, BooleanP, BooleanP}...}],
						Last[standardWaveformProfile][[1]],

						(* If the resolved waveform profile consists of multiple tuples in the form of {Time,{Time,Voltage,Boolean,Boolean}}, get the last time point of all waveforms *)
						MatchQ[standardWaveformProfile, {{TimeP, {{TimeP, VoltageP, BooleanP, BooleanP}...}...}...}],
						(Last /@ Last /@ standardWaveformProfile)[[All, 1]],

						True,
						Null
					];

					(* We need to check if the specified waveforms have multiple duration *)
					multipleStandardWaveformDurationQ = Module[{uniqueDuration},
						uniqueDuration = DeleteDuplicates[ToList[standardWaveformDuration]];
						(* If so, set the error tracking variable to True, otherwise set it to False *)
						If[Length[uniqueDuration] == 1,
							False,
							True
						]
					];

					standardElectrochemicalSamplingRate = Which[

						(* If the user specified sampling rate for electrochemical detection, go with it *)
						MatchQ[Lookup[myMapThreadOptions, StandardElectrochemicalSamplingRate], Except[Automatic]],
						Lookup[myMapThreadOptions, StandardElectrochemicalSamplingRate],

						MatchQ[standardElectrochemicalDetectionMode, Null | {Null}],
						Null,

						(* If the user is using DC Amperometry, set it to 1.67 Hz, which is the default Chromeleon gives *)
						MatchQ[standardElectrochemicalDetectionMode, DCAmperometricDetection],
						1.67 / Second,

						(* If the user is using Integrated Amperometry, then we set sampling rate based on the resolved waveform duration *)
						MatchQ[standardWaveformProfile, Except[Null]],
						1 / (Convert[ToList[standardWaveformDuration][[1]], Second]),

						True,
						Null
					];

					standardDetectionTemperature = Which[

						(* If the user specified sampling rate for electrochemical detection, go with it *)
						MatchQ[Lookup[myMapThreadOptions, StandardDetectionTemperature], Except[Automatic]],
						Lookup[myMapThreadOptions, StandardDetectionTemperature],

						MatchQ[standardElectrochemicalDetectionMode, Null | {Null}],
						Null,

						(* If not specified, use the first resolved detection temperature for the sample *)
						MatchQ[resolvedDetectionTemperature, Except[Automatic | Null]],
						ToList[resolvedDetectionTemperature][[1]],

						(* Otherwise default to ambient temperature *)
						True,
						Ambient
					];

					Which[
						(* If there is no standard, set all resolved variable to Null and error tracking variable to False *)
						MatchQ[resolvedStandard, {} | Null | {Null}],
						Join[ConstantArray[Null, 9], ConstantArray[False, 8]],

						True,
						{
							standardColumnTemperature,
							standardAbsorbanceWavelength,
							standardAbsorbanceSamplingRate,
							standardElectrochemicalDetectionMode,
							standardReferenceElectrodeMode,
							standardVoltageProfile,
							standardWaveformProfile,
							standardElectrochemicalSamplingRate,
							standardDetectionTemperature,
							standardAbsorbanceOptionConflictQ,
							standardElectrochemicalOptionConflictQ,
							standardElectrochemicalModeOptionConflictQ,
							multipleStandardDetectionModeQ,
							standardWaveformDetectionModeConflictQ,
							multipleStandardWaveformDurationQ,
							standardVoltageProfileDuplicateTimeQ,
							standardWaveformProfileDuplicateTimeQ
						}
					]],
					{ToList@resolvedStandard, ToList@resolvedStandardGradient, mapThreadFriendlyElectrochemicalStandardOptions}
				]]
			]
		];

		(* === Massive error checks for all UVVis and Electrochemical Detection parameters === *)

		(* 1. Check if absorbance parameter specification is in conflict *)
		(* If the absorbance options are in conflict and we are throwing message, throw an error and collect invalid options *)
		invalidStandardAbsorbanceOptions = If[MemberQ[standardAbsorbanceOptionConflictErrors, True] && messagesQ,
			(
				Message[Error::InvalidAbsorbanceOption, {StandardAbsorbanceWavelength, StandardAbsorbanceSamplingRate}];
				{StandardAbsorbanceWavelength, StandardAbsorbanceSamplingRate}
			),
			{}
		];

		(* Test for absorbance options *)
		standardAbsorbanceOptionTest = testOrNullIndexMatched["The standard absorbance options are either both Null or both specified with a value:", ToList@resolvedStandard, standardAbsorbanceOptionConflictErrors];

		(* 1.1 Check if absorbance parameter specification is in conflict *)
		(* If the absorbance options are in conflict and we are throwing message, throw an error and collect invalid options *)
		invalidStandardElectrochemicalOptions = If[MemberQ[standardElectrochemicalOptionConflictErrors, True] && messagesQ,
			(
				Message[Error::InvalidElectrochemicalOption, {StandardElectrochemicalDetectionMode, StandardReferenceElectrodeMode, StandardElectrochemicalSamplingRate, StandardDetectionTemperature}];
				{StandardElectrochemicalDetectionMode, StandardReferenceElectrodeMode, StandardElectrochemicalSamplingRate, StandardDetectionTemperature}
			),
			{}
		];

		(* Test for absorbance options *)
		standardElectrochemicalOptionTest = testOrNullIndexMatched["The standard electrochemical options are not set to Null if Detector is set to ElectrochemicalDetector:", ToList@resolvedStandard, standardElectrochemicalOptionConflictErrors];


		(* 2. Check if electrochemical detection mode related paramter specification is in conflict *)
		(* Specifically if ElectrochemicalDetectionMode is DCAmperometricDetection, then VoltageProfile cannot be Null; if it's any other mode, then WaveformProfile cannot be Null *)
		(* If the absorbance options are in conflict and we are throwing message, throw an error and collect invalid options *)
		invalidStandardElectrochemicalDetectionModeOptions = If[MemberQ[standardElectrochemicalModeOptionConflictErrors, True] && messagesQ,
			(
				Message[Error::InvalidElectrochemicalDetectionModeOption, StandardElectrochemicalDetectionMode, StandardVoltageProfile, StandardWaveformProfile];
				{StandardElectrochemicalDetectionMode, StandardVoltageProfile, StandardWaveformProfile}
			),
			{}
		];

		(* Test for absorbance options *)
		standardElectrochemicalModeOptionTest = testOrNullIndexMatched["The standard electrochemical detection mode options are set correctly. If detection mode is DCAmperometricDetection, StandardVoltageProfile cannot be Null; If detection mode is any other amperometric detection, StandardWaveformProfile cannot be Null:", ToList@resolvedStandard, standardElectrochemicalModeOptionConflictErrors];

		(* 3. Check if the specified waveforms render several detection modes *)
		(* If the waveform specified give more than 1 electrochemical detection mode and we are throwing message, throw a warning *)
		multipleStandardDetectionModeOptions = If[MemberQ[multipleStandardDetectionModeErrors, True] && messagesQ && notInEngine,
			(
				Message[Warning::MultipleElectrochemicalDetectionModes, StandardWaveformProfile, StandardElectrochemicalDetectionMode];
				{}
			),
			{}
		];

		(* Test for absorbance options *)
		multipleStandardDetectionModeOptionTest = warningOrNullIndexMatched["The specified waveforms in StandardWaveformProfile option or in the injection table have a unique ElectrochemicalDetectionMode value:", ToList@resolvedStandard, multipleStandardDetectionModeErrors];

		(* 4. Check if the specified waveforms and the specified detection modes are consistent *)
		(* If the two options have conflicting values, throw an error and collect invalid options *)
		invalidStandardWaveformDetectionModeOptions = If[MemberQ[standardWaveformDetectionModeErrors, True] && messagesQ,
			(
				Message[Error::ConflictingElectrochemicalDetectionModes, StandardWaveformProfile, StandardElectrochemicalDetectionMode];
				{StandardWaveformProfile, StandardElectrochemicalDetectionMode}
			),
			{}
		];

		(* Test for absorbance options *)
		invalidStandardWaveformDetectionModeTest = testOrNullIndexMatched["The specified waveforms in StandardWaveformProfile option or in the injection table have consistent ElectrochemicalDetectionMode:", ToList@resolvedStandard, multipleStandardDetectionModeErrors];

		(* 5. Check if the specified waveforms have the same duration *)
		multipleStandardWaveformDurationSamples = PickList[ToList@resolvedStandard, multipleStandardWaveformDurationErrors, True];

		(* If the specified waveforms have different duration and we are throwing messages, throw an error and collect invalid options *)
		multipleStandardWaveformDurationOptions = If[MemberQ[multipleStandardWaveformDurationErrors, True] && messagesQ,
			(
				Message[Error::MultipleWaveformDuration, ObjectToString[multipleStandardWaveformDurationSamples, Cache -> fullCache, Simulation -> updatedSimulation], ObjectToString[resolvedInstrument, Cache -> fullCache, Simulation -> updatedSimulation]];
				{StandardWaveformProfile, StandardElectrochemicalSamplingRate}
			),
			{}
		];

		(* Test for absorbance options *)
		multipleStandardWaveformDurationTest = testOrNullIndexMatched["The specified waveforms all have the same waveform duration:", ToList@resolvedStandard, multipleStandardWaveformDurationErrors];

		(* 6. Check if the times specified in voltage profile is monotonically increasing *)
		(* If the specified voltage profile has duplicate or decreasing time and we are throwing messages, throw an error and collect invalid options *)
		standardVoltageProfileTimeOptions = If[MemberQ[duplicateStandardVoltageProfileTimeErrors, True] && messagesQ,
			(
				Message[Error::InvalidTimeSpecification, StandardVoltageProfile];
				{StandardVoltageProfile}
			),
			{}
		];

		(* Test for absorbance options *)
		standardVoltageProfileTimeTest = testOrNullIndexMatched["The specified VoltageProfile in the form of {Time,Voltage} have monotonically increasing time:", ToList@resolvedStandard, Not[duplicateStandardVoltageProfileTimeErrors]];

		(* 6. Check if the times specified in voltage profile is monotonically increasing *)
		(* If the specified voltage profile has duplicate or decreasing time and we are throwing messages, throw an error and collect invalid options *)
		standardWaveformProfileTimeOptions = If[MemberQ[duplicateStandardWaveformProfileTimeErrors, True] && messagesQ,
			(
				Message[Error::InvalidTimeSpecification, StandardWaveformProfile];
				{StandardWaveformProfile}
			),
			{}
		];

		(* Test for absorbance options *)
		standardWaveformProfileTimeTest = testOrNullIndexMatched["The specified StandardWaveformProfile in the form of {Time,Voltage,Interpolation,Integration} or {Time,{Time,Voltage,Interpolation,Integration}} have monotonically increasing time:", ToList@resolvedStandard, Not[duplicateStandardWaveformProfileTimeErrors]];


		(* Set these variables for later use in referrring to whether AnionStandard and CationStandard exist *)
		anionBlankExistQ = !MatchQ[doubleResolvedAnionBlank, {} | Null | {Null}];
		cationBlankExistQ = !MatchQ[doubleResolvedCationBlank, {} | Null | {Null}];

		(* Setting up the map friendly options for Anion and Cation Blank here *)
		(* Generate MapThread friendly option for AnionBlank, similar to OptionsHandling`Private`mapThreadOptions. *)
		mapThreadFriendlyAnionBlankOptions = If[Length[doubleResolvedAnionBlank] > 0,
			If[MatchQ[imbalancedBlankAnionCationGroupingErrors, True],
				{},

				Transpose[Map[
					Function[{options},
						Module[{optionSymbol, optionValues, optionSymbolList, optionValuesList},
							(* Separate out the option symfbol from the option values. *)
							optionSymbol = options[[1]];
							optionValues = options[[2]];

							(* Get a list of optionSymbol that is the same length as optionValue. *)
							If[MatchQ[Length[ToList@optionValues], Length[doubleResolvedAnionBlank]],
								optionSymbolList = ConstantArray[optionSymbol, Length[ToList@optionValues]];optionValuesList = ToList@optionValues,
								optionSymbolList = ConstantArray[optionSymbol, Length[doubleResolvedAnionBlank]];optionValuesList = ConstantArray[optionValues, Length[doubleResolvedAnionBlank]]
							];

							MapThread[
								(#1 -> #2&),
								{optionSymbolList, optionValuesList}
							]
						]
					],
					extractedAnionBlankOptions
				]]
			],
			{}
		];

		(* Generate MapThread friendly option for CationBlank, similar to OptionsHandling`Private`mapThreadOptions. *)
		mapThreadFriendlyCationBlankOptions = If[Length[doubleResolvedCationBlank] > 0,
			If[MatchQ[imbalancedBlankAnionCationGroupingErrors, True],
				{},

				Transpose[Map[
					Function[{options},
						Module[{optionSymbol, optionValues, optionSymbolList, optionValuesList},
							(* Separate out the option symfbol from the option values. *)
							optionSymbol = options[[1]];
							optionValues = options[[2]];

							(* Get a list of optionSymbol that is the same length as optionValue. *)
							If[MatchQ[Length[ToList@optionValues], Length[doubleResolvedCationBlank]],
								optionSymbolList = ConstantArray[optionSymbol, Length[ToList@optionValues]];optionValuesList = ToList@optionValues,
								optionSymbolList = ConstantArray[optionSymbol, Length[doubleResolvedCationBlank]];optionValuesList = ConstantArray[optionValues, Length[doubleResolvedCationBlank]]
							];

							MapThread[
								(#1 -> #2&),
								{optionSymbolList, optionValuesList}
							]
						]
					],
					extractedCationBlankOptions
				]]
			],
			{}
		];

		(* Generate MapThread friendly option for Blanks with ElectrochemicalDetection, similar to OptionsHandling`Private`mapThreadOptions. *)
		mapThreadFriendlyElectrochemicalBlankOptions = If[MemberQ[ToList@doubleResolvedBlankAnalysisChannel, ElectrochemicalChannel],
			Transpose[Map[
				Function[{options},
					Module[{optionSymbol, optionValues, optionSymbolList, optionValuesList},
						(* Separate out the option symfbol from the option values. *)
						optionSymbol = options[[1]];
						optionValues = options[[2]];

						(* Get a list of optionSymbol that is the same length as optionValue. *)
						If[MatchQ[Length[ToList@optionValues], Length[ToList@resolvedBlank]],
							optionSymbolList = ConstantArray[optionSymbol, Length[ToList@optionValues]];optionValuesList = ToList@optionValues,
							optionSymbolList = ConstantArray[optionSymbol, Length[ToList@resolvedBlank]];optionValuesList = ConstantArray[optionValues, Length[ToList@resolvedBlank]]
						];

						MapThread[
							(#1 -> #2&),
							{optionSymbolList, optionValuesList}
						]
					]
				],
				extractedElectrochemicalBlankOptions
			]
			],
			{}
		];

		(* 39. AnionBlankFrequency and CationBlankFrequency Resolution *)

		(* If injecting a Blank, resolve BlankFrequency based on option value or default to FirstAndLast *)
		resolvedAnionBlankFrequency = If[MatchQ[doubleResolvedAnionBlank, {} | Null | {Null}],
			(* If there is no AnionBlank, then set this option to Null *)
			Null,

			If[MatchQ[specifiedAnionBlankFrequency, Except[Automatic]],
				specifiedAnionBlankFrequency,
				Which[
					(*if there is an injection table, then set to null*)
					MatchQ[anionInjectionTableLookupRounded, Except[Automatic]], Null,
					(*if we have Blanks otherwise, then we can do FirstAndLast*)
					anionBlankExistQ, FirstAndLast,
					(*otherwise, nothing*)
					True, None
				]
			]
		];

		(* == Error Checking == *)
		(* Similar to standards - this error is covered in BlankOptionConflict, don't need an additional error
        (* Check to see if AnionBlankFrequency is set if there are resolved AnionBlank *)

        (* If AnionBlankFrequency is set to Null or None AND if we are throwing messages, throw an error and collect invalid options *)
        noAnionBlankFrequencyButBlanksOptions=If[noAnionBlankFrequencyButBlanksQ&&messagesQ,
            (
                Message[Error::BlanksButNoFrequency];
                {AnionStandardFrequency,AnionStandard}
            ),
            {}
        ];

        (* Generate test for checking AnionBlankFrequency *)
        noAnionBlankFrequencyButBlanksTest=testOrNull["If AnionBlankFrequency is set, the AnionBlank option is not Null:",Not[noAnionBlankFrequencyButBlanksQ]]; *)

		(* If injecting a Blank, resolve BlankFrequency based on option value or default to FirstAndLast *)
		resolvedCationBlankFrequency = If[MatchQ[doubleResolvedCationBlank, {} | Null | {Null}],
			(* If there is no CationBlank, then set this option to Null *)
			Null,

			If[MatchQ[specifiedCationBlankFrequency, Except[Automatic]],
				specifiedCationBlankFrequency,
				Which[
					(*if there is an injection table, then set to null*)
					MatchQ[cationInjectionTableLookupRounded, Except[Automatic]], Null,
					(*if we have Blanks otherwise, then we can do FirstAndLast*)
					cationBlankExistQ, FirstAndLast,
					(*otherwise, nothing*)
					True, None
				]
			]
		];

		(* == Error Checking == *)
		(* Same here - covered in BlankOptionConflict error
        (* Check to see if CationBlankFrequency is set if there are resolved CationBlank *)

        (* If CationBlankFrequency is set to Null or None AND if we are throwing messages, throw an error and collect invalid options *)
        noCationBlankFrequencyButBlanksOptions=If[noCationBlankFrequencyButBlanksQ&&messagesQ,
            (
                Message[Error::BlanksButNoFrequency];
                {CationBlankFrequency,CationBlank}
            ),
            {}
        ];

        (* Generate test for checking CationBlankFrequency *)
        noCationBlankFrequencyButBlanksTests=testOrNull["If CationBlankFrequency is set, the CationBlank option is not Null:",Not[noCationBlankFrequencyButBlanksQ]]; *)

		(* Set these variables for later use in referrring to whether the protocol has Standards for Electrochemical Detection *)
		electrochemicalBlankExistQ = !MatchQ[resolvedBlank, {} | Null | {Null}] && MemberQ[ToList@doubleResolvedBlankAnalysisChannel, ElectrochemicalChannel];

		(* If injecting a standard, resolve StandardFrequency based on option value or default to FirstAndLast *)
		resolvedBlankFrequency = If[!MemberQ[ToList@doubleResolvedBlankAnalysisChannel, ElectrochemicalChannel],

			(* If there is no resolvedCationStandard, set the option to Null and error tracking variables to False *)
			Null,

			If[MatchQ[specifiedBlankFrequency, Except[Automatic]],
				specifiedBlankFrequency,
				Which[
					(*if there is an injection table, then set to null*)
					MatchQ[electrochemicalInjectionTableLookupRounded, Except[Automatic]], Null,
					(*if we have standards otherwise, then we can do FirstAndLast*)
					electrochemicalBlankExistQ, FirstAndLast,
					(*otherwise, nothing*)
					True, None
				]
			]
		];


		(* 40. BlankInjectionVolume resolution *)

		(* resolve the InjectionVolume option *)
		resolvedAnionBlankInjectionVolume = Module[{injectionTableBlankInjectionVolume, anionInjectionTableBlankList, anionInjectionTableLookupWithID},

			If[MatchQ[doubleResolvedAnionBlank, {} | Null | {Null}],
				Null,

				MapThread[
					Function[{mySample, myMapThreadOptions},

						anionInjectionTableBlankList = Cases[anionInjectionTableLookupRounded, {Blank, sample_, ___} :> Download[sample, Object]];
						anionInjectionTableLookupWithID = MapThread[ReplacePart[#1, 2 -> #2]&, {Cases[anionInjectionTableLookupRounded, {Blank, ___}], anionInjectionTableBlankList}];

						(*we need to extract out the injection volume from the injection table*)
						injectionTableBlankInjectionVolume = If[anionInjectionTableSpecifiedQ,
							Cases[anionInjectionTableLookupWithID, {Blank, Download[mySample, Object] | mySample, _, injectionVolume_, _} :> injectionVolume],

							(*otherwise pad automatic*)
							Automatic
						];

						Which[
							(*user specified*)
							MatchQ[Lookup[myMapThreadOptions, AnionBlankInjectionVolume], ListableP[VolumeP]], Lookup[myMapThreadOptions, AnionBlankInjectionVolume],
							(*injectionTable specified*)
							MatchQ[injectionTableBlankInjectionVolume, ListableP[VolumeP]], Sequence @@ injectionTableBlankInjectionVolume,
							(*if anion injection volume is not specified, then resolve to 10 microliter *)
							MatchQ[resolvedAnionInjectionVolume, {} | Null], 10 Microliter,
							(*otherwise, use the first value of the resolved injection volume for the sample *)
							True, resolvedAnionInjectionVolume[[1]]
						]
					],
					{
						ToList@doubleResolvedAnionBlank, mapThreadFriendlyAnionBlankOptions
					}
				]]];


		(* resolve the InjectionVolume option *)
		resolvedCationBlankInjectionVolume = Module[{injectionTableBlankInjectionVolume, cationInjectionTableBlankList, cationInjectionTableLookupWithID},

			If[MatchQ[doubleResolvedCationBlank, {} | Null | {Null}],
				Null,

				MapThread[
					Function[{mySample, myMapThreadOptions},

						cationInjectionTableBlankList = Cases[cationInjectionTableLookupRounded, {Blank, sample_, ___} :> Download[sample, Object]];
						cationInjectionTableLookupWithID = MapThread[ReplacePart[#1, 2 -> #2]&, {Cases[cationInjectionTableLookupRounded, {Blank, ___}], cationInjectionTableBlankList}];

						(*we need to extract out the injection volume from the injection table*)
						injectionTableBlankInjectionVolume = If[cationInjectionTableSpecifiedQ,
							Cases[cationInjectionTableLookupWithID, {Blank, Download[mySample, Object] | mySample, _, injectionVolume_, _} :> injectionVolume],

							(*otherwise pad automatic*)
							Automatic
						];

						Which[
							(*user specified*)
							MatchQ[Lookup[myMapThreadOptions, CationBlankInjectionVolume], ListableP[VolumeP]], Lookup[myMapThreadOptions, CationBlankInjectionVolume],
							(*injectionTable specified*)
							MatchQ[injectionTableBlankInjectionVolume, ListableP[VolumeP]], Sequence @@ injectionTableBlankInjectionVolume,
							(*if anion injection volume is not specified, then resolve to 10 microliter *)
							MatchQ[resolvedCationInjectionVolume, {} | Null], 10 Microliter,
							(*otherwise, use the first value of the resolved injection volume for the sample *)
							True, resolvedCationInjectionVolume[[1]]
						]
					],
					{
						ToList@doubleResolvedCationBlank, mapThreadFriendlyCationBlankOptions
					}
				]]];

		(* resolve the InjectionVolume option *)
		resolvedBlankInjectionVolume = Module[{injectionTableBlankInjectionVolume, electrochemicalInjectionTableBlankList, electrochemicalInjectionTableLookupWithID},

			If[!electrochemicalBlankExistQ,

				{},

				MapThread[
					Function[{mySample, myMapThreadOptions},

						electrochemicalInjectionTableBlankList = Cases[electrochemicalInjectionTableLookupRounded, {Blank, sample_, ___} :> Download[sample, Object]];
						electrochemicalInjectionTableLookupWithID = MapThread[ReplacePart[#1, 2 -> #2]&, {Cases[electrochemicalInjectionTableLookupRounded, {Blank, ___}], electrochemicalInjectionTableBlankList}];

						(*we need to extract out the injection volume from the injection table*)
						injectionTableBlankInjectionVolume = If[electrochemicalInjectionTableSpecifiedQ,
							Cases[electrochemicalInjectionTableLookupWithID, {Blank, Download[mySample, Object] | mySample, _, injectionVolume_, _, _, _} :> injectionVolume],

							(*otherwise pad automatic*)
							Automatic
						];

						Which[
							(*user specified*)
							MatchQ[Lookup[myMapThreadOptions, BlankInjectionVolume], VolumeP], Lookup[myMapThreadOptions, BlankInjectionVolume],
							(*injectionTable specified*)
							MatchQ[injectionTableBlankInjectionVolume, VolumeP], Sequence @@ injectionTableBlankInjectionVolume,
							(*if anion injection volume is not specified, then resolve to 10 microliter *)
							MatchQ[resolvedInjectionVolume, {} | Null], 25 Microliter,
							(*otherwise, use the first value of the resolved injection volume for the sample *)
							True, resolvedInjectionVolume[[1]]
						]
					],
					{
						ToList@resolvedBlank, mapThreadFriendlyElectrochemicalBlankOptions
					}
				]]];

		(* == Error Checking == *)

		(* No need for error checking here
        (* Check whether the specified sample temperature is within the range of allowed temperature of the instrument's autosampler *)
        validAnionBlankVolumeQ=If[!NullQ[resolvedAnionBlankInjectionVolume],
            Not[Between[#,{minSampleVolume,maxSampleVolume}]]&/@resolvedAnionBlankInjectionVolume,
            False
        ];
        validCationBlankVolumeQ=If[!NullQ[resolvedCationBlankInjectionVolume],
            Not[Between[#,{minSampleVolume,maxSampleVolume}]]&/@resolvedCationBlankInjectionVolume,
            False
        ];

        (* Pick out sample objects that have incompatible injection volume *)
        invalidAnionBlankInjectionVolumeObjects=If[!NullQ[resolvedAnionBlankInjectionVolume],
            PickList[ToList@doubleResolvedAnionBlank,validAnionBlankVolumeQ,True]
        ];
        invalidCationBlankInjectionVolumeObjects=If[!NullQ[resolvedCationBlankInjectionVolume],
            PickList[ToList@doubleResolvedCationBlank,validCationBlankVolumeQ,True]
        ];

        (* If the sample temperature is not compatible, and we are throwing messages, throw error message and collect invalid sample temperature option *)
        invalidAnionBlankSampleVolumeOption=If[(Or@@validAnionBlankVolumeQ)&&messagesQ,
            (
                Message[Error::IncompatibleInjectionVolume,invalidAnionBlankInjectionVolumeObjects,ObjectToString[resolvedInstrument,Cache -> fullCache, Simulation -> updatedSimulation],maxSampleVolume];
                {AnionBlankInjectionVolume}
            ),
            {}
        ];
        invalidCationBlankSampleVolumeOption=If[(Or@@validCationBlankVolumeQ)&&messagesQ,
            (
                Message[Error::IncompatibleInjectionVolume,invalidCationBlankInjectionVolumeObjects,ObjectToString[resolvedInstrument,Cache -> fullCache, Simulation -> updatedSimulation],maxSampleVolume];
                {CationBlankInjectionVolume}
            ),
            {}
        ];

        (* Generate tests for compatible injection volume *)
        validAnionBlankInjectionVolumeTests=If[!NullQ[doubleResolvedAnionBlank],
            testOrNullIndexMatched["Specified anion blank injectionVolume is within the range of the allowed injection volume of the instrument:",doubleResolvedAnionBlank,validAnionBlankVolumeQ],
            Nothing
        ];
        validCationBlankInjectionVolumeTests=If[!NullQ[doubleResolvedCationBlank],
            testOrNullIndexMatched["Specified cation blank injectionVolume is within the range of the allowed injection volume of the instrument:",doubleResolvedCationBlank,validCationBlankVolumeQ],
            Nothing
        ];*)

		(* 39. AnionBlank related option resolution: AnionBlankGradientDuration, AnionBlankFlowRate,BlankEluentGradient,AnionBlankGradient *)

		(* Resolution of gradient related options *)
		{
			resolvedAnionBlankGradient,
			resolvedAnionBlankGradientStart,
			resolvedAnionBlankGradientEnd,
			resolvedAnionBlankGradientDuration,
			resolvedAnionBlankFlowRate,
			resolvedBlankEluentGradient,
			anionBlankGradientConsistentErrors,
			anionBlankGradientStartEndSpecifiedErrors,
			anionBlankDurationOptionSpecifiedErrors,
			invalidAnionBlankGradientCompositionErrors,
			anionBlankRemovedExtraErrors,
			overwriteAnionBlankGradientBool,
			anionBlankDurationConsistentErrors,
			anionBlankFlowRateErrors
		} = Module[{
			blankEluentGradientLookup, anionBlankGradientDurationLookup, anionBlankGradientLookup, anionBlankFlowRateLookup, anionInjectionTableBlankRoundedGradient,
			anionBlankGradientConsistentQ, anionBlankRemovedExtrasQ, protoAnionBlankGradientOptionTuple, anionBlankGradientOptionTuple,
			defaultedAnionFlowRate, anionBlankGradientReturned, initiallyResolvedAnionBlankGradient, invalidAnionBlankGradientCompositionQ, blankEluentGradient,
			anionBlankFlowRate, anionBlankGradient, overwriteAnionBlankGradientQ, anionInjectionTableWithID, anionBlankDurationOptionsSpecifiedQ,
			incompatibleAnionBlankFlowRateQ, anionBlankGradientStartLookup, anionBlankGradientEndLookup, anionBlankDurationConsistentQ,
			anionBlankGradientStart, anionBlankGradientEnd, anionBlankGradientStartEndSpecifiedQ, individualGradientSpecifiedQ},

			If[!anionBlankExistQ || MatchQ[mapThreadFriendlyAnionBlankOptions, Null],
				(* If there is no resolvedAnionBlank, then set all anion gradient related options to Null, and all error tracking variable to False *)
				Join[ConstantArray[Null, 6], ConstantArray[False, 8]],

				(* Otherwise, run this giant map thread to resolve all anion gradient related options *)
				Transpose[MapThread[Function[{mySample, myMapFriendlyOptions},

					(* Look up the values of each options in the list *)
					{
						blankEluentGradientLookup,
						anionBlankGradientStartLookup,
						anionBlankGradientEndLookup,
						anionBlankGradientDurationLookup,
						anionBlankGradientLookup,
						anionBlankFlowRateLookup
					} = Lookup[myMapFriendlyOptions, {
						BlankEluentGradient,
						AnionBlankGradientStart,
						AnionBlankGradientEnd,
						AnionBlankGradientDuration,
						AnionBlankGradient,
						AnionBlankFlowRate
					}];

					(* Setup: We first get the injection table gradients *)
					anionInjectionTableBlankRoundedGradient = If[MatchQ[anionInjectionTableLookupRounded, Except[Automatic]],

						anionInjectionTableWithID = Map[
							If[MatchQ[#[[2]], ObjectP[]],
								Join[ToList@#[[1]], ToList@Download[#[[2]], Object], #[[3 ;; 5]]],
								#
							]&,
							anionInjectionTableLookupRounded
						];

						(* Extract the gradient specified in InjectionTable *)
						Cases[anionInjectionTableWithID, {Blank, mySample | Download[mySample, Object], __, gradient_} :> gradient],

						(* If InjectionTable is not specified or has conflict with input samples, pad it with Automatics*)
						Automatic
					];

					(* First we need to make sure that the start and end options are either all specified or not *)
					anionBlankGradientStartEndSpecifiedQ = !MatchQ[{anionBlankGradientStartLookup, anionBlankGradientEndLookup}, {ConcentrationP, ConcentrationP} | {Automatic | Null, Automatic | Null}];

					(* Then we need to make sure that the duration is specified either with start & end, or with eluent gradient *)
					anionBlankDurationOptionsSpecifiedQ = If[MatchQ[anionBlankGradientDurationLookup, TimeP],
						Not[MatchQ[{anionBlankGradientStartLookup, anionBlankGradientEndLookup}, {ConcentrationP, ConcentrationP}] || MatchQ[blankEluentGradientLookup, ConcentrationP]],
						False
					];

					(* Need to check if any of the individual gradient is specified in {Time,Percent} format *)
					individualGradientSpecifiedQ = MatchQ[blankEluentGradientLookup, Except[Automatic | ConcentrationP]];

					(* We also need to check if Duration specification is consistent with individual gradient *)
					anionBlankDurationConsistentQ = If[individualGradientSpecifiedQ,

						If[MatchQ[anionBlankGradientDurationLookup, TimeP],
							True,
							False
						],
						(* If none of the individual gradient is specified, then leave this error tracking variable to False *)
						False
					];

					(* If gradient is specied as a method object, check whether AnionBlankGradient and the injection table specify the same object*)
					anionBlankGradientConsistentQ = If[MatchQ[anionBlankGradientLookup, ObjectP[Object[Method, IonChromatographyGradient]]] && MatchQ[anionInjectionTableBlankRoundedGradient, {ObjectP[Object[Method, IonChromatographyGradient]]}],
						Not[MatchQ[ToList@Download[anionBlankGradientLookup, Object], Download[anionInjectionTableBlankRoundedGradient, Object]]],
						False
					];


					(* Extract or default GradientStart and GradientEnd values *)
					{anionBlankGradientStart, anionBlankGradientEnd} = Switch[{anionBlankGradientStartLookup, anionBlankGradientEndLookup, anionBlankGradientDurationLookup},

						(* If valid anionGradientStart and anionGradientEnd are given, go with that *)
						{ConcentrationP, ConcentrationP, _} | {Null, Null, Null | TimeP}, {anionBlankGradientStartLookup, anionBlankGradientEndLookup},

						(* Default to anionGradientStart if something is wrong with gradientEnd *)
						{ConcentrationP, _, _}, {anionBlankGradientStartLookup, anionBlankGradientStartLookup},

						(* Default to 0 Millimolar if something is wrong with anionGradeintStart *)
						{_, ConcentrationP, _}, {0 Millimolar, anionBlankGradientEndLookup},

						(* Otherwise, both Null*)
						_, {Null, Null}
					];

					(* If Gradient option is an object, pull Gradient value from packet *)
					protoAnionBlankGradientOptionTuple = Which[

						(* If AnionBlankGradient specifies a method object, extract Gradient information from the packet *)
						MatchQ[anionBlankGradientLookup, ObjectP[Object[Method, IonChromatographyGradient]]],
						Lookup[fetchPacketFromCache[Download[anionBlankGradientLookup, Object], fullCache], AnionGradient],

						(* If InjectionTable specifies a method object, extract Gradient information from the packet *)
						MatchQ[anionBlankGradientLookup, Automatic] && MatchQ[anionInjectionTableBlankRoundedGradient, ObjectP[Object[Method, IonChromatographyGradient]]],
						Lookup[fetchPacketFromCache[Download[anionInjectionTableBlankRoundedGradient, Object], fullCache], AnionGradient],

						(* Otherwise, namely if anionGradient is not a method object, then use what's specified in AnionGradient *)
						True, anionBlankGradientLookup
					];

					(* Update AnionBlanklowRate in the gradient method object if the option is specified *)
					anionBlankGradientOptionTuple = If[MatchQ[anionBlankFlowRateLookup, Except[Automatic]],

						(* If AnionBlankFlowRate is specified, use the specified flow rate and replace the default flowrate of the method object *)
						(* In IonChromatography Gradient method, AnionBlankGradient goes "Time", "Eluent Concentration", "FlowRate". FlowRate is in the third column *)
						ReplacePart[protoAnionBlankGradientOptionTuple, Table[{x, 3} -> anionBlankFlowRateLookup, {x, 1, Length[protoAnionBlankGradientOptionTuple]}]],

						(* Otherwise, use the default flow rate in the gradient object *)
						protoAnionBlankGradientOptionTuple
					];

					(* Default FlowRate to option value, gradient tuple values, or the pre-calculated optimal flow rate for the column *)
					(* note that it's ok to have this flow rate either match FlowRateP, or be a list of pairs of time and flow rate since resolveGradient can handle either *)
					defaultedAnionFlowRate = Which[

						(* If the AnionBlankFlowRate is specified, go with the user specified value *)
						MatchQ[anionBlankFlowRateLookup, Except[Automatic]], anionBlankFlowRateLookup,

						(* If the AnionBlankFlowRate is specified as part of the gradient method object, extract the flow rate from the object *)
						MatchQ[anionBlankGradientOptionTuple, {TimeP, ConcentrationP, FlowRateP}], anionBlankGradientOptionTuple[[All, {1, 3}]], (* TODO: made a new gradient type here; doublecheck *)

						(* If no flow rate is specified, use the optional flow rate determined for the column *)
						True, optimalAnionColumnFlowRate
					];

					(* Setup error tracking variable for error messages outside this map thread *)
					incompatibleAnionBlankFlowRateQ = Not[Between[defaultedAnionFlowRate, {minAnionFlowRate, maxAnionFlowRate}]];

					(* finally run our helper resolution function *)
					anionBlankGradientReturned = If[MatchQ[{anionBlankGradientOptionTuple, blankEluentGradientLookup, anionBlankGradientStartLookup, anionBlankGradientEndLookup, anionBlankGradientDurationLookup, anionBlankFlowRateLookup}, {(Null | Automatic)..}] || anionBlankGradientStartEndSpecifiedQ || anionBlankDurationOptionsSpecifiedQ,
						resolveICAnionGradient[defaultAnionGradientIC[defaultedAnionFlowRate], blankEluentGradientLookup, defaultedAnionFlowRate, anionBlankGradientStartLookup, anionBlankGradientEnd, anionBlankGradientDurationLookup],
						resolveICAnionGradient[anionBlankGradientOptionTuple, blankEluentGradientLookup, defaultedAnionFlowRate, anionBlankGradientStartLookup, anionBlankGradientEnd, anionBlankGradientDurationLookup]
					];

					(*remove duplicate entries if need be*)
					initiallyResolvedAnionBlankGradient = DeleteDuplicatesBy[anionBlankGradientReturned, First[# * 1.] &];

					(*if it's not the same note that*)
					anionBlankRemovedExtrasQ = !MatchQ[anionBlankGradientReturned, initiallyResolvedAnionBlankGradient];

					(*check whether the gradient composition adds up to 100 okay*)
					invalidAnionBlankGradientCompositionQ = Not[AllTrue[initiallyResolvedAnionBlankGradient, #[[2]] <= 100 Millimolar&]];

					(*now resolve all of the individual gradients and flow rate*)
					blankEluentGradient = If[MatchQ[initiallyResolvedAnionBlankGradient, {}],

						{},

						If[MatchQ[blankEluentGradientLookup, Automatic],
							collapseGradient[initiallyResolvedAnionBlankGradient[[All, {1, 2}]]],
							blankEluentGradientLookup
						]
					];
					anionBlankFlowRate = If[MatchQ[initiallyResolvedAnionBlankGradient, {}],

						{},

						If[MatchQ[anionBlankFlowRateLookup, Automatic],
							collapseGradient[initiallyResolvedAnionBlankGradient[[All, {1, -1}]]],
							anionBlankFlowRateLookup
						]
					];

					overwriteAnionBlankGradientQ = If[MatchQ[anionBlankGradientLookup, ObjectP[Object[Method, IonChromatographyGradient]]],
						!MatchQ[Lookup[fetchPacketFromCache[Download[anionBlankGradientLookup, Object], fullCache], AnionGradient], initiallyResolvedAnionBlankGradient],
						False
					];

					(*finally resolve the gradient*)
					anionBlankGradient = Which[
						MatchQ[anionBlankGradientLookup, ObjectP[Object[Method, IonChromatographyGradient]]] && !overwriteAnionBlankGradientQ, anionBlankGradientLookup,
						(*otherwise if the gradient is automatic and the injection table is set, should use that*)
						MatchQ[anionBlankGradientLookup, Automatic] && MatchQ[anionInjectionTableBlankRoundedGradient, ObjectP[Object[Method, IonChromatographyGradient]]], Download[anionInjectionTableBlankRoundedGradient, Object],
						(*otherwise, it should be a tuple*)
						True, initiallyResolvedAnionBlankGradient
					];

					(*return everything*)
					{
						anionBlankGradient,
						anionBlankGradientStart,
						anionBlankGradientEnd,
						anionBlankGradientDurationLookup,
						anionBlankFlowRate,
						blankEluentGradient,
						anionBlankGradientConsistentQ,
						anionBlankGradientStartEndSpecifiedQ,
						anionBlankDurationOptionsSpecifiedQ,
						invalidAnionBlankGradientCompositionQ,
						anionBlankRemovedExtrasQ,
						overwriteAnionBlankGradientQ,
						anionBlankDurationConsistentQ,
						incompatibleAnionBlankFlowRateQ
					}

				],
					{doubleResolvedAnionBlank, mapThreadFriendlyAnionBlankOptions}
				]]]];

		(* == Error Checking == *)
		(* Covered in BlankOptionConflict -- don't need an extra checking
        (* 39.1 If AnionBlank are specified or resolved, some gradient options must be specified *)
        missingGradientAnionBlanks=If[Length[doubleResolvedAnionBlank]==0,
            {},
            PickList[doubleResolvedAnionBlank,anionBlankGradientMissingErrors,True]
        ];

        (* If there are any missing anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
        missingAnionBlankGradientOptions=If[Length[missingGradientAnionBlanks]>0&&messagesQ,
            (
                Message[Error::MissingAnionGradientOptions,AnionBlank,ObjectToString[missingGradientAnionBlanks,Cache -> fullCache, Simulation -> updatedSimulation]];
                {BlankEluentGradient,AnionBlankFlowRate,AnionBlankGradient}
            ),
            {}
        ];

        (* Generate test for missing anion gradient options *)
        missingAnionBlankGradientTests=testOrNullIndexMatched["If AnionBlank are specified or resolved, anion blank gradient options are either specified in the option or the InjectionTable:",doubleResolvedAnionBlank,anionBlankGradientMissingErrors]; *)

		(* 39.2 If AnionBlankGradient is specified simultaenously in the option and the InjectionTable as method object, they should be consistent with each other *)
		inconsistentGradientAnionBlank = If[Length[ToList@doubleResolvedAnionBlank] == 0,
			{},
			PickList[doubleResolvedAnionBlank, ToList@anionBlankGradientConsistentErrors, True]
		];

		(* If there are any missing anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
		inconsistentAnionBlankGradientOptions = If[Length[inconsistentGradientAnionBlank] > 0 && messagesQ,
			(
				Message[Error::InconsistentGradientSpecification, AnionBlank, ObjectToString[inconsistentGradientAnionBlank, Cache -> fullCache, Simulation -> updatedSimulation]];
				{AnionBlankGradient, AnionInjectionTable}
			),
			{}
		];

		(* Generate test for missing specification among anion gradient start, end and duration *)
		inconsistentAnionBlankGradientTests = testOrNullIndexMatched["If specified, gradient methods in the AnionBlankGradient option and the AnionInjectionTable must be consistent:", doubleResolvedAnionBlank, anionBlankGradientConsistentErrors];

		(* 39.3 If either BlankEluentGradient or AnionBlankGradient is specified, the maximum concentration is within the range defined by the integrated eluent generator *)
		invalidGradientCompositionAnionBlank = If[Length[ToList@doubleResolvedAnionBlank] == 0,
			{},
			PickList[doubleResolvedAnionBlank, invalidAnionBlankGradientCompositionErrors, True]
		];

		(* If there are any invalid anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
		invalidAnionBlankGradientCompositionOptions = If[Length[inconsistentGradientAnionBlank] > 0 && messagesQ,
			(
				Message[Error::InvalidAnionGradientComposition, AnionBlank, ObjectToString[invalidGradientCompositionAnionBlank,Cache -> fullCache, Simulation -> updatedSimulation], maxEluentConcentration];
				{BlankEluentGradient, AnionBlankGradient}
			),
			{}
		];

		(* Generate test for invalid anion gradient composition *)
		invalidAnionBlankGradientTests = testOrNullIndexMatched["The specified AnionBlankGradient has maximum eluent concentrations less than the max concentration allowed by the eluent generator:", doubleResolvedAnionBlank, invalidGradientCompositionAnionBlank];

		(* Covered by BlankOptionConflictError )
        (* 39.4 If AnionBlankGradientDuration is specified, BlankEluentGradient needs to be specified *)
        incompleteGradientOptionAnionBlanks=If[Length[doubleResolvedAnionBlank]==0,
            {},
            PickList[doubleResolvedAnionBlank,incompleteAnionBlankGradientErrors,True]
        ];

        invalidAnionBlankGradientOptions=If[Length[incompleteGradientOptionAnionBlanks]>0&&messagesQ,
            (
                Message[Error::MissingGradientOptionSpecification,AnionBlank,ObjectToString[incompleteGradientOptionAnionBlanks,Cache -> fullCache, Simulation -> updatedSimulation],AnionBlankGradientDuration,BlankEluentGradient];
                {AnionBlankGradientDuration,BlankEluentGradient}
            ),
            {}
        ];

        invalidAnionBlankGradientOptionTest=testOrNullIndexMatched["If AnionBlankGradient is specified, BlankEluentGradient is also specified:",doubleResolvedAnionBlank,incompleteAnionBlankGradientErrors]; *)

		(* 39.5 AnionBlankFlowRate has to be within the range supported by the instrument, and the column *)
		(* If there are any invalid anion flow rates and we are throwing messages, then throw an error message and collect invalid options *)
		incompatibleAnionBlankFlowRateOptions = If[MemberQ[anionBlankFlowRateErrors, True] && messagesQ,
			(
				Message[Error::FlowRateAboveMax, AnionBlankFlowRate, PickList[resolvedAnionBlankFlowRate, anionBlankFlowRateErrors, True], resolvedInstrument, resolvedAnionColumn, maxAnionFlowRate];
				{AnionBlankFlowRate}
			),
			{}
		];

		(* Generate test for invalid anion gradient composition *)
		invalidAnionBlankFlowRateTests = testOrNullIndexMatched["The specified AnionBlankFlowRate has maximum flow rate less than that supported by the instrument and the column:", doubleResolvedAnionBlank, anionBlankFlowRateErrors];


		(* 39.6 If any of the following gradient start, end and duration options are specified, all three options need to be specified *)
		notSpecifiedAnionBlankGradientStartEnd = If[MatchQ[ToList@doubleResolvedAnionBlank, {} | Null | {Null}],
			{},
			PickList[ToList@doubleResolvedAnionBlank, anionBlankGradientStartEndSpecifiedErrors, True]
		];

		(* If there are any missing anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
		notSpecifiedAnionBlankGradientStartEndOptions = If[Length[notSpecifiedAnionBlankGradientStartEnd] > 0 && messagesQ,
			(
				Message[Error::HPICGradientStartEndConflict, {AnionBlankGradientStart, AnionBlankGradientEnd}, ObjectToString[notSpecifiedAnionBlankGradientStartEnd, Cache -> fullCache, Simulation -> updatedSimulation]];
				{AnionBlankGradientStart, AnionBlankGradientEnd}
			),
			{}
		];

		(* Generate test for missing specification among anion gradient start, end and duration *)
		notSpecifiedAnionBlankGradientStartEndTests = testOrNullIndexMatched["AnionBlankGradientStart, and AnionBlankGradientEnd should be specified or set to Null simultaneously:", resolvedAnionBlank, anionBlankGradientStartEndSpecifiedErrors];

		(* 39.7 If gradient duration is specified, either gradient start & end or eluent gradient is specified *)
		notSpecifiedAnionBlankGradientDuration = If[MatchQ[ToList@doubleResolvedAnionBlank, {} | Null | {Null}],
			{},
			PickList[ToList@doubleResolvedAnionBlank, anionBlankDurationOptionSpecifiedErrors, True]
		];

		(* If there are any missing anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
		notSpecifiedAnionBlankGradientDurationOptions = If[Length[notSpecifiedAnionBlankGradientDuration] > 0 && messagesQ,
			(
				Message[Error::HPICGradientShortcutConflict, AnionBlankGradientDuration, {AnionBlankGradientStart, AnionBlankGradientEnd}, "BlankEluentGradient"];
				{AnionBlankGradientStart, AnionBlankGradientEnd, AnionBlankGradientDuration, BlankEluentGradient}
			),
			{}
		];

		(* Generate test for missing specification among anion gradient start, end and duration *)
		notSpecifiedAnionBlankGradientDurationTests = testOrNullIndexMatched["AnionBlankGradientDuration should be specified either with AnionBlankGradientStart/AnionBlankGradientEnd or with BlankEluentGradient:", resolvedAnionBlank, anionBlankDurationOptionSpecifiedErrors];

		(* 39.8 If gradient duration and eluent gradient are both specified, their specified values are consistent *)
		inconsistentAnionBlankGradientDuration = If[MatchQ[ToList@doubleResolvedAnionBlank, {} | Null | {Null}],
			{},
			PickList[ToList@doubleResolvedAnionBlank, anionBlankDurationConsistentErrors, True]
		];

		(* If there are any missing anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
		inconsistentAnionBlankGradientDurationOptions = If[Length[inconsistentAnionBlankGradientDuration] > 0 && messagesQ && notInEngine,
			(
				Message[Warning::HPICGradientShortcutAmbiguity, AnionBlankGradientDuration, BlankEluentGradient];
				{}
			),
			{}
		];

		(* Generate test for missing specification among anion gradient start, end and duration *)
		consistentAnionBlankGradientDurationTests = warningOrNullIndexMatched["Specified values for AnionBlankGradientDuration and BlankEluentGradient are consistent:", resolvedAnionBlank, anionBlankDurationConsistentErrors];

		(* 40. AnionBlankColumnTemperature, AnionBlankSuppressorCurrent, and AnionBlankDetectionTemperature resolution *)

		{
			resolvedAnionBlankColumnTemperature,
			resolvedAnionBlankSuppressorMode,
			resolvedAnionBlankSuppressorVoltage,
			resolvedAnionBlankSuppressorCurrent,
			resolvedAnionBlankDetectionTemperature,
			conflictingAnionBlankSuppressorModeErrors
		} = Module[{anionInjectionTableLookup, gradientInInjectionTable, anionBlankColumnTemperature, anionBlankSuppressorCurrentLookup, anionBlankDetectionTemperatureLookup,
			anionBlankSuppressorCurrent, anionBlankDetectionTemperature, anionBlankSuppressorModeLookup, anionBlankSuppressorVoltageLookup, anionBlankSuppressorMode, myGradient, maxFlowRate,
			maxEluentConc, defaultMinAnionSuppressorCurrent, defaultMaxAnionSuppressorCurrent, anionBlankSuppressorVoltage, anionBlankSuppressorModeConflictQ},

			If[!anionBlankExistQ || MatchQ[mapThreadFriendlyAnionBlankOptions, Null],
				{Null, Null, Null, Null, Null, False},

				Transpose[MapThread[Function[{mySample, myResolvedGradient, myMapThreadOptions},

					(* Then check if InjectionTable option is filled *)
					anionInjectionTableLookup = Lookup[myMapThreadOptions, AnionInjectionTable, Null];

					(* If InjectionTable is not the default value of automatic, then look up the gradient object specified for mySample *)
					gradientInInjectionTable = If[!MatchQ[anionInjectionTableLookup, ListableP[Automatic]],
						Cases[anionInjectionTableLookup, {Blank, Download[mySample, Object], _, _, gradientObj : ObjectP[Object[Method, IonChromatographyGradient]]} :> gradientObj],
						Null
					];

					(* Download the gradient object from fullCache and extract column temperature information *)
					anionBlankColumnTemperature = Which[

						(* If user has already specified anion column temperature, go with that *)
						!MatchQ[Lookup[myMapThreadOptions, AnionBlankColumnTemperature], ListableP[Automatic | Null]],
						Lookup[myMapThreadOptions, AnionBlankColumnTemperature],

						(* If the specified AnionGradient is a method object, extract column temperature from there *)
						MatchQ[resolvedAnionBlankGradient, ObjectP[Object[Method, IonChromatographyGradient]]],
						If[NullQ[Lookup[fetchPacketFromCache[resolvedAnionBlankGradient, fullCache], AnionColumnTemperature]],
							Ambient,
							Lookup[fetchPacketFromCache[resolvedAnionBlankGradient, fullCache], AnionColumnTemperature]
						],

						(* If the specified gradient in the InjectionTable is an Object, extract column temperature from there *)
						MatchQ[gradientInInjectionTable, ObjectP[Object[Method, IonChromatographyGradient]]],
						Lookup[fetchPacketFromCache[gradientInInjectionTable, fullCache], AnionColumnTemperature],

						MatchQ[resolvedAnionColumnTemperature, {Null} | Null | {}],
						Ambient,

						MatchQ[resolvedAnionColumnTemperature[[1]], Ambient],
						Ambient,

						True,
						resolvedAnionColumnTemperature[[1]]
					];

					(* Look up the specified options from the map thread friendly version of the anion options *)
					{
						anionBlankSuppressorModeLookup,
						anionBlankSuppressorVoltageLookup,
						anionBlankSuppressorCurrentLookup,
						anionBlankDetectionTemperatureLookup
					} = Lookup[myMapThreadOptions,
						{
							AnionBlankSuppressorMode,
							AnionBlankSuppressorVoltage,
							AnionBlankSuppressorCurrent,
							AnionBlankDetectionTemperature
						}
					];

					(* If user specified AnionSuppressorMode, go with that *)
					anionBlankSuppressorMode = Which[

						(* If user specified suppressor mode, then go with that *)
						MatchQ[anionBlankSuppressorModeLookup, Except[Null | Automatic]],
						anionBlankSuppressorModeLookup,

						(* If user does not specify suppressor mode but instead specify suppressor voltage, set suppressorMode to DynamicMode *)
						MatchQ[anionBlankSuppressorVoltageLookup, Except[Null | Automatic]],
						DynamicMode,

						(* Similarly, if user does not specify suppressor mode but instead specify suppressor current, set suppressorMode to LegacyMode *)
						MatchQ[anionBlankSuppressorCurrentLookup, Except[Null | Automatic]],
						LegacyMode,

						(* If nothing is specified, resolve to DynamicMode *)
						True,
						LegacyMode
					];
					(*Get the actual gradient list*)
					myGradient = If[MatchQ[myResolvedGradient, ObjectP[Object[Method]]],
						(*If our resolved gradient is an object, we need to extract the actual gradient from the correct field*)
						Lookup[fetchPacketFromCache[Download[myResolvedGradient, Object], fullCache], AnionGradient],
						(*Otherwise it is already a list of sample and flow rate*)
						myResolvedGradient
					];

					(* Preparation to resolve anionSuppressorCurrent *)
					(* anionSuppressorCurrent (mA) = FlowRate (min/mL) x [Eluent] x suppressor specific Factor *)
					maxFlowRate = Convert[Max[myGradient[[All, -1]]], Milliliter / Minute];
					maxEluentConc = Convert[Max[myGradient[[All, 2]]], Millimolar];
					defaultMinAnionSuppressorCurrent = SafeRound[Unitless[maxFlowRate * maxEluentConc * anionSuppressorSpecificFactor], 1, Round -> Up] * Milli * Ampere;

					{anionBlankSuppressorVoltage, anionBlankSuppressorCurrent, anionBlankSuppressorModeConflictQ} = Which[

						(* If AnionSuppressorMode option is set to DynamicMode, then we need to resolve AnionSuppressorVoltage and set AnionSuppressorCurrent to Null *)
						MatchQ[anionBlankSuppressorMode, DynamicMode],
						If[
							(* First we need to make sure when AnionSuppressorMode is set to DynamicMode, AnionSuppressorCurrent is not specified *)
							(* If it is specified, set error tracking variable to True so that we can throw error later *)
							MatchQ[anionBlankSuppressorVoltageLookup, Null],
							{Null, Null, True},

							Which[
								(* If AnionSuppressorVoltage is specified, go with that *)
								MatchQ[anionBlankSuppressorVoltageLookup, Except[Automatic]],
								{anionBlankSuppressorVoltageLookup, Null, False},

								(* If not, use the factory recommended value of the suppressor *)
								MatchQ[anionBlankSuppressorVoltageLookup, Automatic],
								{anionSuppressorRecommendedVoltage, Null, False},

								True,
								{anionSuppressorRecommendedVoltage, Null, False}
							]
						],

						(* If AnionSuppressorMode option is set to LegacyMode, then we need to resolve AnionSuppressorCurrent and set AnionSuppressotVoltage to Null *)
						MatchQ[anionBlankSuppressorMode, LegacyMode],
						If[
							(* First we need to make sure when AnionSuppressorMode is set to LegacyModel, AnionSuppressorVoltage is not specified *)
							(* If it is specified, set error tracking variable to True so that we can throw error later *)
							MatchQ[anionBlankSuppressorCurrentLookup, Null],
							{Null, Null, True},

							Which[
								(* If AnionSuppressorCurrent is specified, go with that *)
								MatchQ[anionBlankSuppressorCurrentLookup, Except[Automatic]],
								{Null, anionBlankSuppressorCurrentLookup, False},

								(* If not, use the factory recommended value of the suppressor *)
								MatchQ[anionBlankSuppressorCurrentLookup, Automatic],
								{Null, defaultMinAnionSuppressorCurrent, False},

								True,
								{Null, defaultMinAnionSuppressorCurrent, False}
							]
						],

						True,
						{Null, Null, False}

					];

					(* If user specified CationDetectionTemperature, go with that *)
					anionBlankDetectionTemperature = If[MatchQ[anionBlankDetectionTemperatureLookup, Except[Automatic | Null]],
						anionBlankDetectionTemperatureLookup,

						(* Otherwise, use Ambient detection *)
						Which[
							MatchQ[resolvedAnionDetectionTemperature, Null | {} | {Null}],
							Ambient,

							MatchQ[resolvedAnionDetectionTemperature[[1]], Ambient],
							Ambient,

							Not[Between[resolvedAnionDetectionTemperature[[1]], {minAnionDetectionTemperature /. Null -> -Infinity Celsius, maxAnionDetectionTemperature /. Null -> Infinity Celsius}]],
							Ambient,

							True,
							resolvedAnionDetectionTemperature[[1]]
						]
					];


					(* Gather MapThread results *)
					{
						anionBlankColumnTemperature,
						anionBlankSuppressorMode,
						anionBlankSuppressorVoltage,
						anionBlankSuppressorCurrent,
						anionBlankDetectionTemperature,
						anionBlankSuppressorModeConflictQ
					}
				],
					{doubleResolvedAnionBlank, resolvedAnionBlankGradient, mapThreadFriendlyAnionBlankOptions}
				]]]];

		(* == Error Checking == *)
		(* 40.1 Suppressor mode error check *)
		(* Pull out the anion samples that have conflicting suppressor mode and compile a list of conflicting suppressor mode*)
		conflictingAnionSuppressorModeBlanks = If[Length[ToList@doubleResolvedAnionBlank] == 0,
			{},
			PickList[ToList@doubleResolvedAnionBlank, conflictingAnionBlankSuppressorModeErrors, True]
		];

		(* Throw error message and collect invalid option *)
		conflictingAnionBlankSuppressorModeOptions = If[Length[conflictingAninSuppressorModeBlanks] > 0 && messagesQ,
			(
				Message[Error::ConflictingSuppressorMode, ObjectToString[conflictingAninSuppressorModeBlanks, Cache -> fullCache, Simulation -> updatedSimulation], AnionBlankSuppressorMode, AnionBlankSuppressorVoltage, AnionBlankSuppressorCurrent];
				{AnionBlankSuppressorMode, AnionBlankSuppressorVoltage, AnionBlankSuppressorCurrent}
			),
			{}
		];

		(* Generate test for conflicting suppressor mode *)
		anionBlankSuppressorModeTests = testOrNullIndexMatched["AnionBlankSuppressorVoltage and AnionBlankSuppressorCurrent are set if AnionBlankSuppressorMode is set to DynamicMode and LegacyMode respectively:", doubleResolvedAnionBlank, conflictingAnionBlankSuppressorModeErrors];

		(* No need to error check
        (* 40.2 Suppressor voltage error check *)
        (* Pull out the anion samples that have incompatible suppressor current and compile a list of incompatible suppressor current *)
        incompatibleSuppressorVoltageAnionBlanks=If[Length[doubleResolvedAnionBlank]==0,
            {},
            PickList[doubleResolvedAnionBlank,incompatibleAnionBlankSuppressorVoltageErrors,True]
        ];
        incompatibleAnionBlankSuppressorVoltage=If[Length[doubleResolvedAnionBlank]==0,
            {},
            PickList[doubleResolvedAnionBlankSuppressorVoltage,incompatibleAnionBlankSuppressorVoltageErrors,True]
        ];

        (* Throw error message and collect invalid option *)
        invalidAnionBlankSuppressorVoltageOptions=If[Length[incompatibleSuppressorVoltageAnionBlank]>0&&messagesQ,
            (
                Message[Error::IncompatibleSuppressorVoltage,incompatibleAnionBlankSuppressorVoltage,AnionBlank,ObjectToString[incompatibleSuppressorVoltageAnionBlanks,Cache -> fullCache, Simulation -> updatedSimulation],maxAnionSuppressorVoltage/.Null->Infinity Volt];
                {AnionBlankSuppressorVoltage}
            ),
            {}
        ];

        (* Generate test for invalid max acceleration *)
        anionBlankSuppressorVoltageTests=testOrNullIndexMatched["AnionBlankSuppressorVoltage is less than the maximum suppressor voltage supported by the instrument:",doubleResolvedAnionBlank,incompatibleAnionBlankSuppressorVoltageErrors];

        (* 40.3 Check whether the resolved anion blank column temperature is within the acceptable temperature range *)
        (* Identify resolved anion samples that have incompatible column temperature and also compiled a list of incompatible temperatures *)
        incompatibleColumnTemperatureAnionBlank=If[Length[doubleResolvedAnionBlank]==0,
            {},
            PickList[doubleResolvedAnionBlank,incompatibleAnionBlankColumnTemperatureErrors,True]
        ];
        incompatibleAnionBlankColumnTemperature=If[Length[doubleResolvedAnionBlank]==0,
            {},
            PickList[resolvedAnionBlankColumnTemperature,incompatibleAnionBlankColumnTemperatureErrors,True]
        ];

        (* If there are any incompatible column temperatures and we are throwing messages, throw an error and collect in valid option *)
        incompatibleAnionBlankColumnTemperatureOptions=If[Length[incompatibleAnionBlankColumnTemperature]>0&&messagesQ,
            (
                Message[Error::IncompatibleAnionColumnTemperature,incompatibleAnionBlankColumnTemperature,AnionBlank,ObjectToString[incompatibleColumnTemperatureAnionBlank,Cache -> fullCache, Simulation -> updatedSimulation],allowedAnionColumnTemperatureRange[[1]],allowedAnionColumnTemperatureRange[[2]]];
                {AnionBlankColumnTemperature}
            ),
            {}
        ];

        (* Generate tests for incompatible anion column temperature *)
        incompatibleAnionBlankColumnTemperatureTests=testOrNullIndexMatched["Specified AnionBlankColumnTemperature is within the range of supported temperature of the AnionColumn:",doubleResolvedAnionBlank,incompatibleAnionBlankColumnTemperatureErrors];

        (* 40.4 Suppressor current error check *)
        (* Pull out the anion blank that have incompatible suppressor current and compile a list of incompatible suppressor current *)
        incompatibleSuppressorCurrentAnionBlank=If[Length[doubleResolvedAnionBlank]==0,
            {},
            PickList[doubleResolvedAnionBlank,incompatibleAnionBlankSuppressorCurrentErrors,True]
        ];
        incompatibleAnionBlankSuppressorCurrent=If[Length[doubleResolvedAnionBlank]==0,
            {},
            PickList[resolvedAnionBlankSuppressorCurrent,incompatibleAnionBlankSuppressorCurrentErrors,True]
        ];

        (* Throw error message and collect invalid option *)
        invalidAnionBlankSuppressorCurrentOptions=If[Length[incompatibleSuppressorCurrentAnionBlank]>0&&messagesQ,
            (
                Message[Error::IncompatibleSuppressorCurrent,incompatibleAnionBlankSuppressorCurrent,AnionBlank,ObjectToString[incompatibleSuppressorCurrentAnionBlank,Cache -> fullCache, Simulation -> updatedSimulation],0 Milliampere,maxAnionSuppressorCurrent];
                {AnionBlankSuppressorCurrent}
            ),
            {}
        ];

        (* Generate test for invalid max acceleration *)
        anionBlankSuppressorCurrentTests=testOrNullIndexMatched["AnionBlankSuppressorCurrent is less than the maximum suppressor current supported by the instrument:",doubleResolvedAnionBlank,incompatibleAnionBlankSuppressorCurrentErrors];

        (* 40.5 Detection Temperature error check *)
        (* Pull out the anion samples that have incompatible suppressor current and compile a list of incompatible suppressor current *)
        incompatibleDetectionTemperatureAnionBlank=If[Length[doubleResolvedAnionBlank]==0,
            {},
            PickList[doubleResolvedAnionBlank,incompatibleAnionBlankDetectionTemperatureErrors,True]
        ];
        incompatibleAnionBlankDetectionTemperature=If[Length[doubleResolvedAnionBlank]==0,
            {},
            PickList[resolvedAnionBlankDetectionTemperature,incompatibleAnionBlankDetectionTemperatureErrors,True]
        ];

        (* Throw error message and collect invalid option *)
        invalidAnionBlankDetectionTemperatureOptions=If[Length[incompatibleDetectionTemperatureAnionBlank]>0&&messagesQ,
            (
                Message[Error::IncompatibleDetectionTemperature,incompatibleAnionBlankDetectionTemperature,AnionBlank,ObjectToString[incompatibleDetectionTemperatureAnionBlank,Cache -> fullCache, Simulation -> updatedSimulation],minAnionDetectionTemperature,maxAnionDetectionTemperature];
                {AnionBlankDetectionTemperature}
            ),
            {}
        ];

        (* Generate test for invalid max acceleration *)
        anionBlankDetectionTemperatureTests=testOrNullIndexMatched["AnionBlankDetectionTemperature is within the range of detection temperatures set by the instrument:",doubleResolvedAnionBlank,incompatibleAnionBlankDetectionTemperatureErrors]; *)


		(* 41. CationBlank related option resolution: CationBlankGradientDuration, CationBlankFlowRate, BlankGradientA, BlankGradientB, CationBlankGradient *)

		(* Compile a list of cation gradient related options to pass into the MapThread below for resolving gradient *)
		cationBlankGradientOptions = {
			CationBlankGradientA,
			CationBlankGradientB,
			CationBlankGradientC,
			CationBlankGradientD,
			CationBlankGradientStart,
			CationBlankGradientEnd,
			CationBlankGradientDuration,
			CationBlankGradient,
			CationBlankFlowRate
		};

		(* Compile a list of electrochemical gradient related options to pass into the MapThread below for resolving gradient *)
		electrochemicalBlankGradientOptions = {
			BlankGradientA,
			BlankGradientB,
			BlankGradientC,
			BlankGradientD,
			BlankGradientStart,
			BlankGradientEnd,
			BlankGradientDuration,
			BlankGradient,
			BlankFlowRate
		};

		(* Resolution of gradient related options *)
		{
			{
				resolvedCationBlankGradient,
				resolvedCationBlankGradientStart,
				resolvedCationBlankGradientEnd,
				resolvedCationBlankGradientDuration,
				resolvedCationBlankFlowRate,
				resolvedCationBlankGradientA,
				resolvedCationBlankGradientB,
				resolvedCationBlankGradientC,
				resolvedCationBlankGradientD,
				cationBlankGradientStartEndSpecifiedErrors,
				cationBlankDurationOptionSpecifiedErrors,
				cationBlankGradientConsistentErrors,
				invalidCationBlankGradientCompositionErrors,
				cationBlankRemovedExtraErrors,
				cationBlankFlowRateErrors,
				cationBlankDurationConsistentErrors,
				overwriteCationBlankGradientBool
			},
			{
				resolvedBlankGradient,
				resolvedBlankGradientStart,
				resolvedBlankGradientEnd,
				resolvedBlankGradientDuration,
				resolvedBlankFlowRate,
				resolvedBlankGradientA,
				resolvedBlankGradientB,
				resolvedBlankGradientC,
				resolvedBlankGradientD,
				blankGradientStartEndSpecifiedErrors,
				blankDurationOptionSpecifiedErrors,
				blankGradientConsistentErrors,
				invalidBlankGradientCompositionErrors,
				blankRemovedExtraErrors,
				blankFlowRateErrors,
				blankDurationConsistentErrors,
				overwriteBlankGradientBool
			}
		} = Module[{
			blankGradientALookup, blankGradientBLookup, blankGradientCLookup, blankGradientDLookup, blankGradientDurationLookup, blankGradientLookup,
			blankFlowRateLookup, injectionTableSampleRoundedGradient, blankGradientConsistentQ, blankRemovedExtrasQ, blankDurationOptionsSpecifiedQ,
			protoBlankGradientOptionTuple, blankGradientOptionTuple, defaultedBlankFlowRate, blankGradientReturned, individualGradientSpecifiedQ,
			initiallyResolvedBlankGradient, invalidBlankGradientCompositionQ, blankGradientA, blankGradientB, blankGradientC, blankGradientD,
			blankFlowRate, blankGradient, overwriteBlankGradientQ, incompatibleBlankFlowRateQ, blankGradientStartLookup, blankGradientEndLookup,
			samples, mapThreadOptions, gradientOptions, injectionTableLookup, criteria, injectionTableWithID, blankGradientStartEndSpecifiedQ,
			blankGradientStart, blankGradientEnd, gradientColumnInInjectionTable, blankDurationConsistentQ},

			Map[Function[{entryVariable},

				{samples, mapThreadOptions, gradientOptions, injectionTableLookup, criteria, gradientColumnInInjectionTable} = entryVariable;

				If[criteria || MatchQ[mapThreadOptions, Null],
					(* If there is no resolvedCationSamples or samples for ElectrochemicalChannel, then set all cation gradient related options to Null, and all error tracking variable to False *)
					Join[ConstantArray[Null, 9], ConstantArray[False, 8]],

					(* Otherwise, run this giant map thread to resolve all cation blank gradient related options *)
					Transpose[MapThread[Function[{mySample, myMapFriendlyOptions},

						(* Look up the values of each options in the list *)
						{
							blankGradientALookup,
							blankGradientBLookup,
							blankGradientCLookup,
							blankGradientDLookup,
							blankGradientStartLookup,
							blankGradientEndLookup,
							blankGradientDurationLookup,
							blankGradientLookup,
							blankFlowRateLookup
						} = Lookup[myMapFriendlyOptions, gradientOptions];

						(* Setup: We first get the injection table gradients *)
						injectionTableSampleRoundedGradient = If[MatchQ[injectionTableLookup, Except[Automatic]],

							injectionTableWithID = Map[
								If[MatchQ[#[[2]], ObjectP[]],
									Join[ToList@#[[1]], ToList@Download[#[[2]], Object], #[[3 ;; Length[#]]]],
									#
								]&,
								injectionTableLookup
							];

							(* Extract the gradient specified in InjectionTable *)
							Which[
								gradientColumnInInjectionTable == 5,
								Cases[injectionTableWithID, {Blank, mySample | Download[mySample, Object], _, _, gradient_} :> gradient],

								gradientColumnInInjectionTable == 4,
								Cases[injectionTableWithID, {Blank, mySample | Download[mySample, Object], _, gradient_, ___} :> gradient],

								True,
								Automatic
							],
							(* If InjectionTable is not specified or has conflict with input samples, pad it with Automatics*)
							Automatic
						];

						(* First we need to make sure that the start end and duration options are either all specified or not *)
						blankGradientStartEndSpecifiedQ = !MatchQ[{blankGradientStartLookup, blankGradientEndLookup}, {PercentP, PercentP} | {Automatic | Null, Automatic | Null}];

						(* Then we need to make sure that the duration is specified either with start & end, or with eluent gradient *)
						blankDurationOptionsSpecifiedQ = If[MatchQ[blankGradientDurationLookup, TimeP],
							Not[MatchQ[{blankGradientStartLookup, blankGradientEndLookup}, {PercentP, PercentP}] || MatchQ[blankGradientALookup, PercentP] || MatchQ[blankGradientBLookup, PercentP] || MatchQ[blankGradientCLookup, PercentP] || MatchQ[blankGradientDLookup, PercentP]],
							False
						];

						(* Need to check if any of the individual gradient is specified in {Time,Percent} format *)
						individualGradientSpecifiedQ = Or[
							MatchQ[blankGradientALookup, Except[Automatic | PercentP]],
							MatchQ[blankGradientBLookup, Except[Automatic | PercentP]],
							MatchQ[blankGradientCLookup, Except[Automatic | PercentP]],
							MatchQ[blankGradientDLookup, Except[Automatic | PercentP]]
						];

						(* We also need to check if Duration specification is consistent with individual gradient *)
						blankDurationConsistentQ = If[individualGradientSpecifiedQ,

							If[MatchQ[blankGradientDurationLookup, TimeP],
								True,
								False
							],
							(* If none of the individual gradient is specified, then leave this error tracking variable to False *)
							False
						];

						(* If gradient is specied as a method object, check whether CationGradient and the injection table specify the same object*)
						blankGradientConsistentQ = If[MatchQ[blankGradientLookup, ObjectP[{Object[Method, IonChromatographyGradient], Object[Method, Gradient]}]] && MatchQ[injectionTableSampleRoundedGradient, ObjectP[{Object[Method, IonChromatographyGradient], Object[Method, Gradient]}]],
							Not[MatchQ[Lookup[fetchPacketFromCache[blankGradientLookup, fullCache], Object], Lookup[fetchPacketFromCache[injectionTableSampleRoundedGradient, fullCache], Object]]],
							False
						];

						(* Extract or default GradientStart and GradientEnd values *)
						{blankGradientStart, blankGradientEnd} = Switch[{blankGradientStartLookup, blankGradientEndLookup, blankGradientDurationLookup},

							(* If valid cationGradientStart and cationGradientEnd are given, go with that *)
							{PercentP, PercentP, _} | {Null, Null, Null | TimeP}, {blankGradientStartLookup, blankGradientEndLookup},

							(* Default to cationGradientStart if something is wrong with gradientEnd *)
							{PercentP, _, _}, {blankGradientStartLookup, blankGradientStartLookup},

							(* Default to 0 Percent if something is wrong with cationGradeintStart *)
							{_, PercentP, _}, {0 Percent, blankGradientEndLookup},

							(* Otherwise, both Null*)
							_, {Null, Null}
						];

						(* If Gradient option is an object, pull Gradient value from packet *)
						protoBlankGradientOptionTuple = Which[

							(* If CationGradient specifies a method object, extract Gradient information from the packet *)
							MatchQ[blankGradientLookup, ObjectP[Object[Method, IonChromatographyGradient]]],
							Lookup[fetchPacketFromCache[Download[blankGradientLookup, Object], fullCache], CationGradient],

							(* If CationGradient specifies a method object, extract Gradient information from the packet *)
							MatchQ[blankGradientLookup, ObjectP[Object[Method, Gradient]]],
							Lookup[fetchPacketFromCache[Download[blankGradientLookup, Object], fullCache], Gradient],

							(* If InjectionTable specifies a method object, extract Gradient information from the packet *)
							MatchQ[blankGradientLookup, Automatic] && MatchQ[injectionTableSampleRoundedGradient, ObjectP[Object[Method, IonChromatographyGradient]]],
							Lookup[fetchPacketFromCache[Download[injectionTableSampleRoundedGradient, Object], fullCache], CationGradient],

							(* If InjectionTable specifies a method object, extract Gradient information from the packet *)
							MatchQ[blankGradientLookup, Automatic] && MatchQ[injectionTableSampleRoundedGradient, ObjectP[Object[Method, Gradient]]],
							Lookup[fetchPacketFromCache[Download[injectionTableSampleRoundedGradient, Object], fullCache], Gradient],

							(* Otherwise, namely if anionGradient is not a method object, then use what's specified in AnionGradient *)
							True, blankGradientLookup
						];

						(* Update CationFlowRate in the gradient method object if the option is specified *)
						blankGradientOptionTuple = If[MatchQ[blankFlowRateLookup, Except[Automatic]],

							(* If CationFlowRate is specified, use the specified flow rate and replace the default flowrate of the method object *)
							(* In IonChromatography Gradient method, CationGradient goes "Time", "BufferA Composition", "BufferB Composition", "BufferC Composition", "BufferD Composition", "FlowRate". FlowRate is in the third column *)
							ReplacePart[protoBlankGradientOptionTuple, Table[{x, 6} -> blankFlowRateLookup, {x, 1, Length[protoBlankGradientOptionTuple]}]],

							(* Otherwise, use the default flow rate in the gradient object *)
							protoBlankGradientOptionTuple
						];

						(* Default FlowRate to option value, gradient tuple values, or the pre-calculated optimal flow rate for the column *)
						(* note that it's ok to have this flow rate either match FlowRateP, or be a list of pairs of time and flow rate since resolveGradient can handle either *)
						defaultedBlankFlowRate = Which[

							(* If the AnionFlowRate is specified, go with the user specified value *)
							MatchQ[blankFlowRateLookup, Except[Automatic]], blankFlowRateLookup,

							(* If the AnionFlowRate is specified as part of the gradient method object, extract the flow rate from the object *)
							MatchQ[blankGradientOptionTuple, {TimeP, PercentP, PercentP, PercentP, PercentP, FlowRateP}], blankGradientOptionTuple[[All, {1, 6}]],

							(* If no flow rate is specified, use the optional flow rate determined for the column *)
							True, optimalColumnFlowRate
						];

						(* Track whether CationFlowRate is compatible with the instrument, and the column *)
						incompatibleBlankFlowRateQ = Not[Between[defaultedBlankFlowRate, {minFlowRate, maxFlowRate}]];

						(* finally run our helper resolution function *)
						blankGradientReturned = If[MatchQ[{blankGradientOptionTuple, blankGradientALookup, blankGradientBLookup, blankGradientCLookup, blankGradientDLookup, blankGradientStart, blankGradientEnd, blankGradientDurationLookup, blankFlowRateLookup}, {(Null | Automatic)..}] || blankGradientStartEndSpecifiedQ || blankDurationOptionsSpecifiedQ,
							resolveICCationGradient[defaultGradientIC[resolvedChannelSelection, defaultedBlankFlowRate], blankGradientALookup, blankGradientBLookup, blankGradientCLookup, blankGradientDLookup, defaultedBlankFlowRate, blankGradientStartLookup, blankGradientEndLookup, blankGradientDurationLookup],
							resolveICCationGradient[blankGradientOptionTuple, blankGradientALookup, blankGradientBLookup, blankGradientCLookup, blankGradientDLookup, defaultedBlankFlowRate, blankGradientStartLookup, blankGradientEndLookup, blankGradientDurationLookup]
						];

						(*remove duplicate entries if need be*)
						initiallyResolvedBlankGradient = DeleteDuplicatesBy[blankGradientReturned, First[# * 1.] &];

						(*if it's not the same note that*)
						blankRemovedExtrasQ = !MatchQ[blankGradientReturned, initiallyResolvedBlankGradient];

						(*check whether the gradient composition adds up to 100 okay*)
						invalidBlankGradientCompositionQ = Not[AllTrue[initiallyResolvedBlankGradient, (#[[2]] + #[[3]] + #[[4]] + #[[5]] == 100 Percent)&]];

						(*now resolve all of the individual gradients and flow rate*)
						blankGradientA = If[MatchQ[blankGradientALookup, Automatic],
							collapseGradient[initiallyResolvedBlankGradient[[All, {1, 2}]]],
							blankGradientALookup
						];

						blankGradientB = If[MatchQ[blankGradientBLookup, Automatic],
							collapseGradient[initiallyResolvedBlankGradient[[All, {1, 3}]]],
							blankGradientBLookup
						];

						blankGradientC = If[MatchQ[blankGradientCLookup, Automatic],
							collapseGradient[initiallyResolvedBlankGradient[[All, {1, 4}]]],
							blankGradientCLookup
						];

						blankGradientD = If[MatchQ[blankGradientDLookup, Automatic],
							collapseGradient[initiallyResolvedBlankGradient[[All, {1, 5}]]],
							blankGradientDLookup
						];

						blankFlowRate = If[MatchQ[blankFlowRateLookup, Automatic],
							collapseGradient[initiallyResolvedBlankGradient[[All, {1, -1}]]],
							blankFlowRateLookup
						];

						overwriteBlankGradientQ = Which[
							MatchQ[blankGradientLookup, ObjectP[Object[Method, IonChromatographyGradient]]],
							!MatchQ[Lookup[fetchPacketFromCache[Download[blankGradientLookup, Object], fullCache], CationGradient], initiallyResolvedBlankGradient],

							MatchQ[blankGradientLookup, ObjectP[Object[Method, Gradient]]],
							!MatchQ[Lookup[fetchPacketFromCache[Download[blankGradientLookup, Object], fullCache], Gradient], initiallyResolvedBlankGradient],

							True,
							False
						];

						(*finally resolve the gradient*)
						blankGradient = Which[

							MatchQ[blankGradientLookup, ObjectP[Object[Method, IonChromatographyGradient]]] && !overwriteBlankGradientQ, blankGradientLookup,
							MatchQ[blankGradientLookup, ObjectP[Object[Method, Gradient]]], blankGradientLookup,

							(*otherwise if the gradient is automatic and the injection table is set, should use that*)
							MatchQ[blankGradientLookup, Automatic] && MatchQ[injectionTableSampleRoundedGradient, ObjectP[Object[Method, IonChromatographyGradient]]],
							Lookup[fetchPacketFromCache[injectionTableSampleRoundedGradient, fullCache], Object],

							MatchQ[blankGradientLookup, Automatic] && MatchQ[injectionTableSampleRoundedGradient, ObjectP[Object[Method, Gradient]]],
							Lookup[fetchPacketFromCache[injectionTableSampleRoundedGradient, fullCache], Object],

							(*otherwise, it should be a tuple*)
							True, initiallyResolvedBlankGradient
						];

						(*return everything*)
						{
							blankGradient,
							blankGradientStart,
							blankGradientEnd,
							blankGradientDurationLookup,
							blankFlowRate,
							blankGradientA,
							blankGradientB,
							blankGradientC,
							blankGradientD,
							blankGradientStartEndSpecifiedQ,
							blankDurationOptionsSpecifiedQ,
							blankGradientConsistentQ,
							invalidBlankGradientCompositionQ,
							blankRemovedExtrasQ,
							incompatibleBlankFlowRateQ,
							blankDurationConsistentQ,
							overwriteBlankGradientQ
						}],
						{samples, mapThreadOptions}
					]]
				]],
				{
					{ToList@doubleResolvedCationBlank, mapThreadFriendlyCationBlankOptions, cationBlankGradientOptions, cationInjectionTableLookupRounded, MatchQ[ToList@doubleResolvedCationBlank, {} | {Null} | Null], 5},
					{ToList@resolvedBlank, mapThreadFriendlyElectrochemicalBlankOptions, electrochemicalBlankGradientOptions, electrochemicalInjectionTableLookupRounded, !MemberQ[ToList@doubleResolvedBlankAnalysisChannel, ElectrochemicalChannel], 4}
				}
			]
		];


		(* == Error Checking == *)
		(*
        (* 41.1 If CationBlank are specified or resolved, some gradient options must be specified *)
        missingGradientCationBlank=If[Length[doubleResolvedCationBlank]==0,
            {},
            PickList[doubleResolvedCationBlank,cationBlankGradientMissingErrors,True]
        ];

        (* If there are any missing anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
        missingCationBlankGradientOptions=If[Length[missingGradientCationBlank]>0&&messagesQ,
            (
                Message[Error::MissingCationGradientOptions,CationBlank,ObjectToString[missingGradientCationBlank,Cache -> fullCache, Simulation -> updatedSimulation]];
                {BlankGradientA,CationBlankFlowRate,CationBlankGradient}
            ),
            {}
        ];

        (* Generate test for missing anion gradient options *)
        missingCationBlankGradientTests=testOrNullIndexMatched["If CationBlank are specified or resolved, cation blank gradient options are either specified in the option or the InjectionTable:",doubleResolvedCationBlank,cationBlankGradientMissingErrors]; *)

		(* 41.2 If CatinoBlankGradient is specified simultaenously in the option and the InjectionTable as method object, they should be consistent with each other *)
		inconsistentGradientCationBlanks = If[Length[doubleResolvedCationBlank] == 0,
			{},
			PickList[doubleResolvedCationBlank, ToList@cationBlankGradientConsistentErrors, True]
		];

		(* If there are any missing anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
		inconsistentCationBlankGradientOptions = If[Length[inconsistentGradientCationBlanks] > 0 && messagesQ,
			(
				Message[Error::InconsistentGradientSpecification, CationBlankGraient, ObjectToString[inconsistentGradientCationBlanks,Cache -> fullCache, Simulation -> updatedSimulation]];
				{CationBlankGradient, CationInjectionTable}
			),
			{}
		];

		(* Generate test to check whether gradient specification is consistent between CationBlankGradient and InjectionTable *)
		inconsistentCationBlankGradientTests = testOrNullIndexMatched["If specified, gradient methods in the CationblankGradient option and the CationInjectionTable must be consistent:", doubleResolvedCationBlank, cationBlankGradientConsistentErrors];

		(* 41.3 If either EluentGradient or AnionGradient is specified, the maximum concentration is within the range defined by the integrated eluent generator *)
		invalidGradientCompositionCationBlank = If[Length[doubleResolvedCationBlank] == 0,
			{},
			PickList[doubleResolvedCationBlank, invalidCationBlankGradientCompositionErrors, True]
		];

		(* If there are any invalid anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
		invalidCationBlankGradientCompositionOptions = If[Length[inconsistentGradientCationBlank] > 0 && messagesQ,
			(
				Message[Error::InvalidGradientComposition, CationBlank, ObjectToString[invalidGradientCompositionCationBlank,Cache -> fullCache, Simulation -> updatedSimulation]];
				{CationBlankGradientA, CationBlankGradientB, CationBlankGradientC, CationBlankGradientD, CationBlankGradient}
			),
			{}
		];

		(* Generate test for invalid anion gradient composition *)
		invalidCationBlankGradientTests = testOrNullIndexMatched["The specified CationBlankGradient has a total buffer composition of 100% at all times:", doubleResolvedCationBlank, invalidGradientCompositionCationBlank];

		(* Replaced with a more robust error checking that makes sure the last time point agrees as well
        (* 41.4 If CationBlankGradientDuration is specified, BlankGradientA needs to be specified *)
        incompleteGradientOptionCationBlanks=If[Length[doubleResolvedCationBlank]==0,
            {},
            PickList[doubleResolvedCationBlank,incompleteCationBlankGradientErrors,True]
        ];

        invalidCationBlankGradientOptions=If[Length[incompleteGradientOptionCationBlanks]>0&&messagesQ,
            (
                Message[Error::MissingGradientOptionSpecification,CationBlank,ObjectToString[incompleteGradientOptionCationBlanks,Cache -> fullCache, Simulation -> updatedSimulation],CationBlankGradientDuration,BlankGradientA];
                {CationBlankGradientDuration,BlankGradientA}
            ),
            {}
        ];

        invalidCationBlankGradientOptionTest=testOrNullIndexMatched["If CationBlankGradient is specified, BlankGradientA is also specified:",doubleResolvedCationBlank,incompleteCationBlankGradientErrors]; *)

		(* 41.5 CationBlankFlowRate has to be within the range supported by the instrument, and the column *)
		(* If there are any invalid anion flow rates and we are throwing messages, then throw an error message and collect invalid options *)
		incompatibleCationBlankFlowRateOptions = If[MemberQ[cationBlankFlowRateErrors, True] && messagesQ,
			(
				Message[Error::FlowRateAboveMax, CationBlankFlowRate, PickList[resolvedCationBlankFlowRate, cationBlankFlowRateErrors, True], resolvedInstrument, resolvedCationColumn, maxFlowRate];
				{CationBlankFlowRate}
			),
			{}
		];

		(* Generate test for invalid anion gradient composition *)
		invalidCationBlankFlowRateTests = testOrNullIndexMatched["The specified CationBlankFlowRate has maximum flow rate less than that supported by the instrument and the column:", doubleResolvedCationBlank, cationBlankFlowRateErrors];

		(* Covered by StandardOptionConflict error
        (* 37.6 CationStandardDuration has to be specified together with StandardGradientAt *)
        cationBlankGradientOptions=If[MemberQ[ToList@cationBlankGradientSpecificationErrors,True]&&messagesQ,
            (
                Message[Error::MissingGradientOptionSpecification,BlankGradientA,CationBlankGradientDuration,CationBlank];
                {BlankGradientA,CationBlankGradientDuration}
            ),
            {}
        ];

        (* Generate test for invalid anion gradient composition *)
        cationBlankGradientTests=testOrNull["If CationBlankGradientDuration is specified, BlankGradientA is also specified and consistent with the specified value of CationBlankGradientDuration:",Not[cationBlankGradientSpecificationErrors]]; *)

		(* 37.7 If any of the following gradient start, end and duration options are specified, all three options need to be specified *)
		notSpecifiedCationBlankGradientStartEnd = If[MatchQ[ToList@doubleResolvedCationBlank, {} | Null | {Null}],
			{},
			PickList[ToList@doubleResolvedCationBlank, cationBlankGradientStartEndSpecifiedErrors, True]
		];

		(* If there are any missing anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
		notSpecifiedCationBlankGradientStartEndOptions = If[Length[notSpecifiedCationBlankGradientStartEnd] > 0 && messagesQ,
			(
				Message[Error::HPICGradientStartEndConflict, {CationBlankGradientStart, CationBlankGradientEnd}, ObjectToString[notSpecifiedCationBlankGradientStartEnd, Cache -> fullCache, Simulation -> updatedSimulation]];
				{CationBlankGradientStart, CationBlankGradientEnd}
			),
			{}
		];

		(* Generate test for missing specification among anion gradient start, end and duration *)
		notSpecifiedCationBlankGradientStartEndTests = testOrNullIndexMatched["CationBlankGradientStart and CationBlankGradientEnd should be specified or set to Null simultaneously:", resolvedCationBlank, cationBlankGradientStartEndSpecifiedErrors];

		(* 37.8 If gradient duration is specified, either gradient start & end or eluent gradient is specified *)
		notSpecifiedCationBlankGradientDuration = If[MatchQ[ToList@doubleResolvedCationBlank, {} | Null | {Null}],
			{},
			PickList[ToList@doubleResolvedCationBlank, cationBlankDurationOptionSpecifiedErrors, True]
		];

		(* If there are any missing anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
		notSpecifiedCationBlankGradientDurationOptions = If[Length[notSpecifiedCationBlankGradientDuration] > 0 && messagesQ,
			(
				Message[Error::HPICGradientShortcutConflict, CationBlankGradientDuration, {CationBlankGradientStart, CationBlankGradientEnd}, "CationBlankGradientA/B/C/D"];
				{CationBlankGradientStart, CationBlankGradientEnd, CationBlankGradientDuration, CationBlankGradientA, CationBlankGradientB, CationBlankGradientC, CationBlankGradientD}
			),
			{}
		];

		(* Generate test for missing specification among anion gradient start, end and duration *)
		notSpecifiedCationBlankGradientDurationTests = testOrNullIndexMatched["CationBlankGradientDuration should be specified either with CationBlankGradientStart/CationBlankGradientEnd or any of the CationBlankGradientA/B/C/D:", resolvedCationBlank, cationBlankDurationOptionSpecifiedErrors];

		(* 37.9 If gradient duration and eluent gradient are both specified, their specified values are consistent *)
		inconsistentCationBlankGradientDuration = If[MatchQ[ToList@doubleResolvedCationBlank, {} | Null | {Null}],
			{},
			PickList[ToList@doubleResolvedCationBlank, cationBlankDurationConsistentErrors, True]
		];

		(* If there are any missing anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
		inconsistentCationBlankGradientDurationOptions = If[Length[inconsistentCationBlankGradientDuration] > 0 && messagesQ && notInEngine,
			(
				Message[Warning::HPICGradientShortcutAmbiguity, CationBlankGradientDuration, "CationBlankGradientA/B/C/D"];
				{}
			),
			{}
		];

		(* Generate test for missing specification among anion gradient start, end and duration *)
		consistentCationBlankGradientDurationTests = warningOrNullIndexMatched["Specified values for CationBlankGradientDuration and CationBlankGradientA/B/C/D are consistent:", resolvedCationBlank, cationBlankDurationConsistentErrors];


		(* 37.8 If BlankGradient is specified simultaenously in the option and the InjectionTable as method object, they should be consistent with each other *)
		inconsistentGradientBlanks = If[!MemberQ[resolvedBlankAnalysisChannel, ElectrochemicalChannel],
			{},
			PickList[ToList@resolvedBlank, blankGradientConsistentErrors, True]
		];

		(* If there are any missing anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
		inconsistentBlankGradientOptions = If[Length[inconsistentGradientBlanks] > 0 && messagesQ,
			(
				Message[Error::InconsistentGradientSpecification, BlankGraient, ObjectToString[inconsistentGradientBlanks, Cache -> fullCache, Simulation -> updatedSimulation]];
				{BlankGradient, ElectrochemicalInjectionTable}
			),
			{}
		];

		(* Generate test to check whether gradient specification is consistent between CationBlankGradient and InjectionTable *)
		inconsistentBlankGradientTests = testOrNullIndexMatched["If specified, gradient methods in the BlankGradient option and the ElectrochemicalInjectionTable must be consistent:", resolvedBlank, blankGradientConsistentErrors];

		(* 37.8 If any BlankGradientA-D is specified, the maximum concentration is within the range defined by the integrated eluent generator *)
		invalidGradientCompositionBlank = If[!MemberQ[ToList@resolvedBlankAnalysisChannel, ElectrochemicalChannel],
			{},
			PickList[ToList@resolvedBlank, invalidBlankGradientCompositionErrors, True]
		];

		(* If there are any invalid anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
		invalidBlankGradientCompositionOptions = If[Length[invalidGradientCompositionBlank] > 0 && messagesQ,
			(
				Message[Error::InvalidGradientComposition, Blank, ObjectToString[invalidGradientCompositionBlank,Cache -> fullCache, Simulation -> updatedSimulation]];
				{BlankGradientA, BlankGradientB, BlankGradientC, BlankGradientD, BlankGradient}
			),
			{}
		];

		(* Generate test for invalid anion gradient composition *)
		invalidBlankGradientTests = testOrNullIndexMatched["The specified BlankGradient has a total buffer composition of 100% at all times:", resolvedBlank, invalidBlankGradientCompositionErrors];

		(* 37.9 BlankFlowRate has to be within the range supported by the instrument, and the column *)
		(* If there are any invalid anion flow rates and we are throwing messages, then throw an error message and collect invalid options *)
		incompatibleBlankFlowRateOptions = If[MemberQ[blankFlowRateErrors, True] && messagesQ,
			(
				Message[Error::FlowRateAboveMax, BlankFlowRate, PickList[resolvedBlankFlowRate, blankFlowRateErrors, True], resolvedInstrument, resolvedColumn, maxFlowRate];
				{BlankFlowRate}
			),
			{}
		];

		(* Generate test for invalid anion gradient composition *)
		invalidBlankFlowRateTests = testOrNullIndexMatched["The specified BlankFlowRate has maximum flow rate less than that supported by the instrument and the column:", resolvedBlank, blankFlowRateErrors];

		(* 37.6 If any of the following gradient start, end and duration options are specified, all three options need to be specified *)
		notSpecifiedBlankGradientStartEnd = If[!MemberQ[resolvedBlankAnalysisChannel, ElectrochemicalChannel],
			{},
			PickList[ToList@resolvedBlank, blankGradientStartEndSpecifiedErrors, True]
		];

		(* If there are any missing anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
		notSpecifiedBlankGradientStartEndOptions = If[Length[notSpecifiedBlankGradientStartEnd] > 0 && messagesQ,
			(
				Message[Error::HPICGradientStartEndConflict, {BlankGradientStart, BlankGradientEnd}, ObjectToString[notSpecifiedBlankGradientStartEnd, Cache -> fullCache, Simulation -> updatedSimulation]];
				{BlankGradientStart, BlankGradientEnd}
			),
			{}
		];

		(* Generate test for missing specification among anion gradient start, end and duration *)
		notSpecifiedBlankGradientStartEndTests = testOrNullIndexMatched["BlankGradientStart, BlankGradientEnd, and BlankGradientDuration should be specified or set to Null simultaneously:", resolvedBlank, blankGradientStartEndSpecifiedErrors];


		(* 37.7 If gradient duration is specified, either gradient start & end or eluent gradient is specified *)
		notSpecifiedBlankGradientDuration = If[!MemberQ[resolvedBlankAnalysisChannel, ElectrochemicalChannel],
			{},
			PickList[ToList@resolvedBlank, blankDurationOptionSpecifiedErrors, True]
		];

		(* If there are any missing anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
		notSpecifiedBlankGradientDurationOptions = If[Length[notSpecifiedBlankGradientDuration] > 0 && messagesQ,
			(
				Message[Error::HPICGradientShortcutConflict, BlankGradientDuration, {BlankGradientStart, BlankGradientEnd}, "BlankGradientA/B/C/D"];
				{BlankGradientStart, BlankGradientEnd, BlankGradientDuration, BlankGradientA, BlankGradientB, BlankGradientC, BlankGradientD}
			),
			{}
		];

		(* Generate test for missing specification among anion gradient start, end and duration *)
		notSpecifiedBlankGradientDurationTests = testOrNullIndexMatched["BlankGradientDuration should be specified either with BlankGradientStart/BlankGradientEnd or any of the BlankGradientA/B/C/D:", resolvedBlank, standardDurationOptionSpecifiedErrors];

		(* 37.14 If gradient duration and eluent gradient are both specified, their specified values are consistent *)
		inconsistentBlankGradientDuration = If[!MemberQ[resolvedBlankAnalysisChannel, ElectrochemicalChannel],
			{},
			PickList[ToList@resolvedBlank, blankDurationConsistentErrors, True]
		];

		(* If there are any missing anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
		inconsistentBlankGradientDurationOptions = If[Length[inconsistentBlankGradientDuration] > 0 && messagesQ && notInEngine,
			(
				Message[Warning::HPICGradientShortcutAmbiguity, BlankGradientDuration, "BlankGradientA/B/C/D"];
				{}
			),
			{}
		];

		(* Generate test for missing specification among anion gradient start, end and duration *)
		consistentBlankGradientDurationTests = warningOrNullIndexMatched["Specified values for BlankGradientDuration and BlankGradientA/B/C/D are consistent:", resolvedBlank, standardDurationConsistentErrors];

		(* 42. CationBlankColumnTemperature, CationBlankSuppressorCurrent, and CationBlankDetectionTemperature resolution *)

		{
			resolvedCationBlankColumnTemperature,
			resolvedCationBlankSuppressorMode,
			resolvedCationBlankSuppressorVoltage,
			resolvedCationBlankSuppressorCurrent,
			resolvedCationBlankDetectionTemperature,
			conflictingCationBlankSuppressorModeErrors
		} = Module[{cationInjectionTableLookup, gradientInInjectionTable, cationBlankColumnTemperature, cationBlankSuppressorCurrentLookup, cationBlankDetectionTemperatureLookup,
			cationBlankSuppressorCurrent, cationBlankDetectionTemperature, cationBlankSuppressorModeLookup, cationBlankSuppressorVoltageLookup, cationBlankSuppressorMode,
			myGradient, maxFlowRate, maxBufferConc, defaultMinCationSuppressorCurrent, defaultMaxCationSuppressorCurrent, cationBlankSuppressorVoltage, cationBlankSuppressorModeConflictQ,
			allBufferPercent, totalBufferConcentration},

			If[!cationBlankExistQ || MatchQ[mapThreadFriendlyCationBlankOptions, Null],
				{Null, Null, Null, Null, Null, False},

				Transpose[MapThread[Function[{mySample, myResolvedGradient, myMapThreadOptions},

					(* Then check if InjectionTable option is filled *)
					cationInjectionTableLookup = Lookup[myMapThreadOptions, CationInjectionTable, Null];

					(* If InjectionTable is not the default value of automatic, then look up the gradient object specified for mySample *)
					gradientInInjectionTable = If[!MatchQ[cationInjectionTableLookup, ListableP[Automatic]],
						Cases[cationInjectionTableLookup, {Blank, Download[mySample, Object], _, _, gradientObj : ObjectP[Object[Method, IonChromatographyGradient]]} :> gradientObj],
						Null
					];

					(* Download the gradient object from fullCache and extract column temperature information *)
					cationBlankColumnTemperature = Which[

						(* If user has already specified anion column temperature, go with that *)
						!MatchQ[Lookup[myMapThreadOptions, CationBlankColumnTemperature], ListableP[Automatic | Null]],
						Lookup[myMapThreadOptions, CationBlankColumnTemperature],

						(* If the specified AnionGradient is a method object, extract column temperature from there *)
						MatchQ[myResolvedGradient, ObjectP[Object[Method, IonChromatographyGradient]]],
						If[NullQ[Lookup[fetchPacketFromCache[Download[myResolvedGradient, Object], fullCache], CationColumnTemperature]],
							Ambient,
							Lookup[fetchPacketFromCache[Download[myResolvedGradient, Object], fullCache], CationColumnTemperature]
						],

						(* If the specified gradient in the InjectionTable is an Object, extract column temperature from there *)
						MatchQ[gradientInInjectionTable, ObjectP[Object[Method, IonChromatographyGradient]]],
						Lookup[fetchPacketFromCache[gradientInInjectionTable, fullCache], CationColumnTemperature],

						MatchQ[resolvedCationColumnTemperature, {Null} | Null | {}],
						Ambient,

						MatchQ[resolvedCationColumnTemperature[[1]], Ambient],
						Ambient,

						True,
						resolvedCationColumnTemperature[[1]]
					];

					(* Look up the specified options from the map thread friendly version of the anion options *)
					{
						cationBlankSuppressorModeLookup,
						cationBlankSuppressorVoltageLookup,
						cationBlankSuppressorCurrentLookup,
						cationBlankDetectionTemperatureLookup
					} = Lookup[myMapThreadOptions,
						{
							CationBlankSuppressorMode,
							CationBlankSuppressorVoltage,
							CationBlankSuppressorCurrent,
							CationBlankDetectionTemperature
						}
					];

					(* If user specified AnionSuppressorMode, go with that *)
					cationBlankSuppressorMode = Which[

						(* If user specified suppressor mode, then go with that *)
						MatchQ[cationBlankSuppressorModeLookup, Except[Null | Automatic]],
						cationBlankSuppressorModeLookup,

						(* If user does not specify suppressor mode but instead specify suppressor voltage, set suppressorMode to DynamicMode *)
						MatchQ[cationBlankSuppressorVoltageLookup, Except[Null | Automatic]],
						DynamicMode,

						(* Similarly, if user does not specify suppressor mode but instead specify suppressor current, set suppressorMode to LegacyMode *)
						MatchQ[cationBlankSuppressorCurrentLookup, Except[Null | Automatic]],
						LegacyMode,

						(* If nothing is specified, resolve to DynamicMode *)
						True,
						LegacyMode
					];
					(*Get the actual gradient list*)
					myGradient = If[MatchQ[myResolvedGradient, ObjectP[Object[Method]]],
						(*If our resolved gradient is an object, we need to extract the actual gradient from the correct field*)
						Lookup[fetchPacketFromCache[Download[myResolvedGradient, Object], fullCache], CationGradient],
						(*Otherwise it is already a list of sample and flow rate*)
						myResolvedGradient
					];

					(* Pull out the percent of all 4 buffers from the resolvedGradient *)
					allBufferPercent = If[MatchQ[myResolvedGradient, ObjectP[Object[Method, IonChromatographyGradient]]],
						(Lookup[fetchPacketFromCache[Download[myResolvedGradient, Object], fullCache], CationGradient][[All, 2 ;; 5]]) / (100 Percent),
						myResolvedGradient[[All, 2 ;; 5]] / (100 Percent)
					];

					(* Calculate the total concentration of all 4 buffers *)
					totalBufferConcentration = Map[Times[#, {bufferAConcentration, bufferBConcentration, bufferCConcentration, bufferDConcentration}]&, allBufferPercent];

					(* Preparation to resolve cationSuppressorCurrent *)
					(* cationSuppressorCurrent (mA) = FlowRate (min/mL) x [Eluent] x suppressor specific Factor *)
					maxFlowRate = Convert[Max[myGradient[[All, -1]]], Milliliter / Minute];
					maxBufferConc = Max[totalBufferConcentration];
					defaultMinCationSuppressorCurrent = SafeRound[Unitless[maxFlowRate * maxBufferConc * cationSuppressorSpecificFactor], 1, Round -> Up] * Milli * Ampere;

					{cationBlankSuppressorVoltage, cationBlankSuppressorCurrent, cationBlankSuppressorModeConflictQ} = Which[

						(* If CationSuppressorMode option is set to DynamicMode, then we need to resolve CationSuppressorVoltage and set CationSuppressorCurrent to Null *)
						MatchQ[cationBlankSuppressorMode, DynamicMode],
						If[
							(* First we need to make sure when CationSuppressorMode is set to DynamicMode, CationSuppressorCurrent is not specified *)
							(* If it is specified, set error tracking variable to True so that we can throw error later *)
							MatchQ[cationBlankSuppressorVoltageLookup, Null],
							{Null, Null, True},

							Which[
								(* If CationSuppressorVoltage is specified, go with that *)
								MatchQ[cationBlankSuppressorVoltageLookup, Except[Automatic]],
								{cationBlankSuppressorVoltageLookup, Null, False},

								(* If not, use the factory recommended value of the suppressor *)
								MatchQ[cationBlankSuppressorVoltageLookup, Automatic],
								{cationSuppressorRecommendedVoltage, Null, False},

								True,
								{cationSuppressorRecommendedVoltage, Null, False}
							]
						],

						(* If CationSuppressorMode option is set to LegacyMode, then we need to resolve CationSuppressorCurrent and set CationSuppressotVoltage to Null *)
						MatchQ[cationBlankSuppressorMode, LegacyMode],
						If[
							(* First we need to make sure when CationSuppressorMode is set to LegacyModel, CationSuppressorVoltage is not specified *)
							(* If it is specified, set error tracking variable to True so that we can throw error later *)
							MatchQ[cationBlankSuppressorCurrentLookup, Null],
							{Null, Null, True},

							Which[
								(* If CationSuppressorCurrent is specified, go with that *)
								MatchQ[cationBlankSuppressorCurrentLookup, Except[Automatic]],
								{Null, cationBlankSuppressorCurrentLookup, False},

								(* If not, use the factory recommended value of the suppressor *)
								MatchQ[cationBlankSuppressorCurrentLookup, Automatic],
								{Null, defaultMinCationSuppressorCurrent, False},

								MatchQ[defaultMinCationSuppressorCurrent, 0 Milliampere],
								{Null, 15 Milliampere, False},

								True,
								{Null, defaultMinCationSuppressorCurrent, False}
							]
						],

						True,
						{Null, Null, False}

					];

					(* If user specified CationDetectionTemperature, go with that *)
					cationBlankDetectionTemperature = If[MatchQ[cationBlankDetectionTemperatureLookup, Except[Automatic | Null]],
						cationBlankDetectionTemperatureLookup,
						(* Otherwise, use Ambient detection *)
						Which[
							MatchQ[resolvedCationDetectionTemperature, Null | {} | {Null}],
							Ambient,

							MatchQ[resolvedCationDetectionTemperature[[1]], Ambient],
							Ambient,

							Not[Between[resolvedCationDetectionTemperature[[1]], {minCationDetectionTemperature /. Null -> -Infinity Celsius, maxCationDetectionTemperature /. Null -> Infinity Celsius}]],
							Ambient,

							True,
							resolvedCationDetectionTemperature[[1]]
						]
					];


					(* Gather MapThread results *)
					{
						cationBlankColumnTemperature,
						cationBlankSuppressorMode,
						cationBlankSuppressorVoltage,
						cationBlankSuppressorCurrent,
						cationBlankDetectionTemperature,
						cationBlankSuppressorModeConflictQ
					}
				],
					{doubleResolvedCationBlank, resolvedCationBlankGradient, mapThreadFriendlyCationBlankOptions}
				]]]
		];

		(* == Error Checking == *)
		(* 42.1 Suppressor mode error check *)
		(* Pull out the cation samples that have conflicting suppressor mode and compile a list of conflicting suppressor mode*)
		conflictingCationSuppressorModeBlanks = If[Length[doubleResolvedCationBlank] == 0,
			{},
			PickList[doubleResolvedCationBlank, conflictingCationBlankSuppressorModeErrors, True]
		];

		(* Throw error message and collect invalid option *)
		conflictingCationBlankSuppressorModeOptions = If[Length[conflictingCationSuppressorModeBlanks] > 0 && messagesQ,
			(
				Message[Error::ConflictingSuppressorMode, ObjectToString[conflictingCationSuppressorModeBlanks, Cache -> fullCache, Simulation -> updatedSimulation], CationBlankSuppressorMode, CationBlankSuppressorVoltage, CationBlankSuppressorCurrent];
				{CationBlankSuppressorMode, CationBlankSuppressorVoltage, CationBlankSuppressorCurrent}
			),
			{}
		];

		(* Generate test for conflicting suppressor mode *)
		cationBlankSuppressorModeTests = testOrNullIndexMatched["CationBlankSuppressorVoltage and CationBlankSuppressorCurrent are set if CationBlankSuppressorMode is set to DynamicMode and LegacyMode respectively:", doubleResolvedCationBlank, conflictingCationBlankSuppressorModeErrors];

		(* No need to error check
        (* 42.2 Suppressor voltage error check *)
        (* Pull out the cation samples that have incompatible suppressor current and compile a list of incompatible suppressor current *)
        incompatibleSuppressorVoltageCationBlanks=If[Length[doubleResolvedCationBlank]==0,
            {},
            PickList[doubleResolvedCationBlank,incompatibleCationBlankSuppressorVoltageErrors,True]
        ];
        incompatibleCationBlankSuppressorVoltage=If[Length[doubleResolvedCationBlank]==0,
            {},
            PickList[resolvedCationBlankSuppressorVoltage,incompatibleCationBlankSuppressorVoltageErrors,True]
        ];

        (* Throw error message and collect invalid option *)
        invalidCationBlankSuppressorVoltageOptions=If[Length[incompatibleSuppressorVoltageCationBlanks]>0&&messagesQ,
            (
                Message[Error::IncompatibleSuppressorVoltage,incompatibleCationBlankSuppressorVoltage,CationBlank,ObjectToString[incompatibleSuppressorVoltageCationBlanks,Cache -> fullCache, Simulation -> updatedSimulation],maxCationSuppressorVoltage/.Null->Infinity Volt];
                {CationBlankSuppressorVoltage}
            ),
            {}
        ];

        (* Generate test for invalid max acceleration *)
        cationBlankSuppressorVoltageTests=testOrNullIndexMatched["CationBlankSuppressorVoltage is within the range of voltage supported by the instrument:",doubleResolvedCationBlank,incompatibleCationBlankSuppressorVoltageErrors];


        (* 42.3 Check whether the resolved cation blank column temperature is within the acceptable temperature range *)
        (* Identify resolved cation samples that have incompatible column temperature and also compiled a list of incompatible temperatures *)
        incompatibleColumnTemperatureCationBlank=If[Length[doubleResolvedCationBlank]==0,
            {},
            PickList[doubleResolvedCationBlank,incompatibleCationBlankColumnTemperatureErrors,True]
        ];
        incompatibleCationBlankColumnTemperature=If[Length[doubleResolvedCationBlank]==0,
            {},
            PickList[resolvedCationBlankColumnTemperature,incompatibleCationBlankColumnTemperatureErrors,True]
        ];

        (* If there are any incompatible column temperatures and we are throwing messages, throw an error and collect in valid option *)
        incompatibleCationBlankColumnTemperatureOptions=If[Length[incompatibleCationBlankColumnTemperature]>0&&messagesQ,
            (
                Message[Error::IncompatibleCationColumnTemperature,incompatibleCationBlankColumnTemperature,CationBlank,ObjectToString[incompatibleColumnTemperatureCationBlank,Cache -> fullCache, Simulation -> updatedSimulation],allowedCationColumnTemperatureRange[[1]],allowedCationColumnTemperatureRange[[2]]];
                {CationBlankColumnTemperature}
            ),
            {}
        ];

        (* Generate tests for incompatible cation column temperature *)
        incompatibleCationBlankColumnTemperatureTests=testOrNullIndexMatched["Specified CationBlankColumnTemperature is within the range of supported temperature of the CationColumn:",doubleResolvedCationBlank,incompatibleCationBlankColumnTemperatureErrors];

        (* 42.4 Suppressor current error check *)
        (* Pull out the cation blank that have incompatible suppressor current and compile a list of incompatible suppressor current *)
        incompatibleSuppressorCurrentCationBlank=If[Length[doubleResolvedCationBlank]==0,
            {},
            PickList[doubleResolvedCationBlank,incompatibleCationBlankSuppressorCurrentErrors,True]
        ];
        incompatibleCationBlankSuppressorCurrent=If[Length[doubleResolvedCationBlank]==0,
            {},
            PickList[resolvedCationBlankSuppressorCurrent,incompatibleCationBlankSuppressorCurrentErrors,True]
        ];

        (* Throw error message and collect invalid option *)
        invalidCationBlankSuppressorCurrentOptions=If[Length[incompatibleSuppressorCurrentCationBlank]>0&&messagesQ,
            (
                Message[Error::IncompatibleSuppressorCurrent,incompatibleCationBlankSuppressorCurrent,CationBlank,ObjectToString[incompatibleSuppressorCurrentCationBlank,Cache -> fullCache, Simulation -> updatedSimulation],0 Milliampere,maxCationSuppressorCurrent];
                {CationBlankSuppressorCurrent}
            ),
            {}
        ];

        (* Generate test for invalid max acceleration *)
        cationBlankSuppressorCurrentTests=testOrNullIndexMatched["CationBlankSuppressorCurrent is less than the maximum suppressor current supported by the instrument:",doubleResolvedCationBlank,incompatibleCationBlankSuppressorCurrentErrors];

        (* 42.5 Detection Temperature error check *)
        (* Pull out the cation samples that have incompatible suppressor current and compile a list of incompatible suppressor current *)
        incompatibleDetectionTemperatureCationBlank=If[Length[doubleResolvedCationBlank]==0,
            {},
            PickList[doubleResolvedCationBlank,incompatibleCationBlankDetectionTemperatureErrors,True]
        ];
        incompatibleCationBlankDetectionTemperature=If[Length[doubleResolvedCationBlank]==0,
            {},
            PickList[resolvedCationBlankDetectionTemperature,incompatibleCationBlankDetectionTemperatureErrors,True]
        ];

        (* Throw error message and collect invalid option *)
        invalidCationBlankDetectionTemperatureOptions=If[Length[incompatibleDetectionTemperatureCationBlank]>0&&messagesQ,
            (
                Message[Error::IncompatibleDetectionTemperature,incompatibleCationBlankDetectionTemperature,CationBlank,ObjectToString[incompatibleDetectionTemperatureCationBlank,Cache -> fullCache, Simulation -> updatedSimulation],minCationDetectionTemperature/.Null->-Infinity Celsius,maxCationDetectionTemperature/.Null->Infinity Celsius];
                {CationBlankDetectionTemperature}
            ),
            {}
        ];

        (* Generate test for invalid max acceleration *)
        cationBlankDetectionTemperatureTests=testOrNullIndexMatched["CationBlankDetectionTemperature is within the range of detection temperatures set by the instrument:",doubleResolvedCationBlank,incompatibleCationBlankDetectionTemperatureErrors]; *)

		{
			resolvedBlankColumnTemperature,
			resolvedBlankAbsorbanceWavelength,
			resolvedBlankAbsorbanceSamplingRate,
			resolvedBlankElectrochemicalDetectionMode,
			resolvedBlankReferenceElectrodeMode,
			resolvedBlankVoltageProfile,
			resolvedBlankWaveformProfile,
			resolvedBlankElectrochemicalSamplingRate,
			resolvedBlankDetectionTemperature,
			blankAbsorbanceOptionConflictErrors,
			blankElectrochemicalOptionConflictErrors,
			blankElectrochemicalModeOptionConflictErrors,
			multipleBlankDetectionModeErrors,
			blankWaveformDetectionModeErrors,
			multipleBlankWaveformDurationErrors,
			duplicateBlankVoltageProfileTimeErrors,
			duplicateBlankWaveformProfileTimeErrors
		} = Module[{blankAbsorbanceOptionConflictQ, blankAbsorbanceWavelength, blankAbsorbanceSamplingRate, injectionTableWithID, injectionTableBlankWaveformEntry,
			blankElectrochemicalModeOptionConflictQ, blankWaveformDetectionMode, multipleBlankDetectionModeQ, blankElectrochemicalDetectionMode,
			blankWaveformDetectionModeConflictQ, gradientInInjectionTable, blankColumnTemperature, blankReferenceElectrodeMode,
			blankVoltageProfile, blankVoltageProfileDuplicateTimeQ, blankWaveformProfile, blankWaveformProfileDuplicateTimeQ, blankWaveformDuration,
			multipleBlankWaveformDurationQ, blankElectrochemicalSamplingRate, blankDetectionTemperature, injectionTableBlankVoltageEntry,
			blankElectrochemicalOptionConflictQ},

			If[
				MatchQ[resolvedBlank, {} | Null | {Null}] || !MemberQ[ToList@doubleResolvedBlankAnalysisChannel, ElectrochemicalChannel],
				Join[ConstantArray[{}, 9], ConstantArray[False, 8]],

				(* Set up map thread for resolving detection options *)
				Transpose[MapThread[Function[{mySample, myResolvedGradient, myMapThreadOptions},

					(* First download all the sample objects specified in the InjectionTable *)
					injectionTableWithID = Map[
						If[MatchQ[#[[2]], ObjectP[]],
							Join[ToList@#[[1]], ToList@Download[#[[2]], Object], #[[3 ;; Length[#]]]],
							#
						]&,
						electrochemicalInjectionTableLookupRounded
					];

					(* If InjectionTable is not the default value of automatic, then look up the gradient object specified for mySample *)
					gradientInInjectionTable = If[!MatchQ[injectionTableWithID, ListableP[Automatic]],
						Cases[injectionTableWithID, {Blank, Download[mySample, Object], _, _, gradientObj : ObjectP[Object[Method, Gradient]]} :> gradientObj],
						Null
					];

					(* Download the gradient object from fullCache and extract column temperature information *)
					blankColumnTemperature = Which[

						(* If user has already specified anion column temperature, go with that *)
						!MatchQ[Lookup[myMapThreadOptions, BlankColumnTemperature], ListableP[Automatic]],
						Lookup[myMapThreadOptions, BlankColumnTemperature],

						(* If the specified Gradient is a method object, extract column temperature from there *)
						MatchQ[myResolvedGradient, ObjectP[Object[Method, Gradient]]],
						If[NullQ[Lookup[fetchPacketFromCache[Download[myResolvedGradient, Object], fullCache], Temperature]],
							Ambient,
							Lookup[fetchPacketFromCache[Download[myResolvedGradient, Object], fullCache], Temperature]
						],

						(* If the specified gradient in the InjectionTable is an Object, extract column temperature from there *)
						MatchQ[gradientInInjectionTable, ObjectP[Object[Method, Gradient]]],
						Lookup[fetchPacketFromCache[Download[gradientInInjectionTable, Object], fullCache], Temperature] /. {Null :> Ambient},

						MatchQ[resolvedColumnTemperature, {Null} | Null | {}],
						Ambient,

						MatchQ[resolvedColumnTemperature[[1]], Ambient],
						Ambient,

						True,
						resolvedColumnTemperature[[1]]
					];

					(* Before resolving the absorbance options, first do some option conflict checks *)
					blankAbsorbanceOptionConflictQ = If[
						MemberQ[ToList@resolvedDetector, UVVis],
						Switch[
							(* We will look up the specified value of Absorbance related options *)
							Lookup[myMapThreadOptions, {BlankAbsorbanceWavelength, BlankAbsorbanceSamplingRate}],

							(* Both options cannot be null *)
							{Except[Null], Except[Null]},
							False,

							(* Otherwise set the error tracking variable to True *)
							{_, _},
							True
						],
						False
					];


					blankAbsorbanceWavelength = Which[
						(* If user specified absorbance wavelength, go with that *)
						MatchQ[Lookup[myMapThreadOptions, BlankAbsorbanceWavelength], Except[Automatic]],
						Lookup[myMapThreadOptions, BlankAbsorbanceWavelength],

						MatchQ[Lookup[myMapThreadOptions, BlankAbsorbanceSamplingRate], Null],
						Null,

						(* If absorbance wavelength is specified for the sample, use the first wavelength from the resolved absorbance wavelength *)
						MatchQ[resolvedAbsorbanceWavelength, Except[Automatic]],
						ToList[resolvedAbsorbanceWavelength][[1]],

						(* Otherwise, set to 280 nm *)
						True,
						280 Nanometer
					];

					blankAbsorbanceSamplingRate = Which[

						(* If user specified absorbance wavelength sampling rate, go with that *)
						MatchQ[Lookup[myMapThreadOptions, BlankAbsorbanceSamplingRate], Except[Automatic]],
						Lookup[myMapThreadOptions, BlankAbsorbanceSamplingRate],

						(* If the absorbance sampling rate is already resolved for sample, use the first value for BlankAbsorbanceSamplingRate *)
						NullQ[blankAbsorbanceWavelength],
						Null,

						(* If we are only reading at one wavelength, then set sampling rate to 10/Second *)
						Length[ToList@blankAbsorbanceWavelength] == 1,
						10 / Second,

						(* If we are reading at multiple wavelengths, then set sampling rate to 1/Second *)
						Length[ToList@blankAbsorbanceWavelength] > 1,
						1 / Second,

						(* Otherwise, set to Null *)
						True,
						Null
					];

					(* Then find the entry of the particular sample in the injection table *)
					{injectionTableBlankWaveformEntry, injectionTableBlankVoltageEntry} = If[electrochemicalInjectionTableSpecifiedQ,
						If[MatchQ[Cases[injectionTableWithID, {Blank, Download[mySample, Object], ___}], {}],
							{Null, Null},
							First[Cases[injectionTableWithID, {Blank, Download[mySample, Object], ___}]][[5 ;; 6]]
						],
						{Automatic, Automatic}
					];

					(* Before resolving the electrochemical options, first do some option conflict checks *)
					blankElectrochemicalOptionConflictQ = If[MemberQ[ToList@resolvedDetector, ElectrochemicalDetector],
						Switch[
							(* We will look up the specified value of Absorbance related options *)
							Lookup[myMapThreadOptions, {BlankElectrochemicalDetectionMode, BlankReferenceElectrodeMode, BlankElectrochemicalSamplingRate, BlankDetectionTemperature}],

							(* Both options cannot be null *)
							{Except[Null], Except[Null], Except[Null], Except[Null]},
							False,

							(* Otherwise set the error tracking variable to True *)
							{_, _, _, _},
							True
						],
						False
					];


					(* Before resolving all the electrochemical detection mode option, first do some option conflict checks *)
					blankElectrochemicalModeOptionConflictQ = Switch[

						(* We will look up the specified value of Absorbance related options *)
						Lookup[myMapThreadOptions, {BlankElectrochemicalDetectionMode, BlankVoltageProfile, BlankWaveformProfile}],

						(* If they are both Null, there's no conflict *)
						{DCAmperometricDetection | {DCAmperometricDetection}, Null | {Null}, _},
						True,

						(* If they are both specified, there's also no conflict *)
						{PulsedAmperometricDetection | {PulsedAmperometricDetection}, _, Null | {Null}},
						True,

						(* If only one of the option value is Null, then set the conflict variable to True *)
						{IntegratedPulsedAmperometricDetection | {IntegratedPulsedAmperometricDetection}, _, Null | {Null}},
						True,

						{_, _, _},
						False
					];

					(* Before resolving electrochemical detection mode, let's first pull out the electrochemical mode from any waveforms specified *)
					blankWaveformDetectionMode = Which[

						(* If WaveformProfile is specified, detection mode can either be Pulsed Amperometry or Integrated Pulsed Amperometry *)
						MatchQ[Lookup[myMapThreadOptions, BlankWaveformProfile], Except[Automatic]],
						Which[

							(* If WaveformProfile is specified as a method object, then directly pull ElectrochemicalDetectionMode field from it *)
							MatchQ[Lookup[myMapThreadOptions, BlankWaveformProfile], ObjectP[Object[Method, Waveform]]],
							Lookup[fetchPacketFromCache[Download[Lookup[myMapThreadOptions, BlankWaveformProfile], Object], fullCache], ElectrochemicalDetectionMode],

							(* If WaveformProfile is specified as multiple method objects, then track ElectrochemicalDetectionMode of all methods and use ElectrochemicalDetectionMode from the first method *)
							MatchQ[Lookup[myMapThreadOptions, BlankWaveformProfile], {{TimeP, ObjectP[Object[Method, Waveform]]}...}],
							Lookup[fetchPacketFromCache[#, fullCache], ElectrochemicalDetectionMode]& /@ Download[Lookup[myMapThreadOptions, BlankWaveformProfile][[All, 2]], Object],

							(* If WaveformProfile is specified as tuples of {Time,Voltage,Boolean,Boolean}, then it gets a little more complicated *)
							(* We will have to look at the second Boolean and the Voltage value to determine ElectrochemicalDetectionMode *)
							(* If voltages specified are one constant value when the second Boolean is True then it is PulsedAmperometricDetection *)
							(* If voltages specified are more than one value when the second Boolean is True then it is IntegratedPulsedAmperometricDetection *)
							MatchQ[Lookup[myMapThreadOptions, BlankWaveformProfile], {{TimeP, VoltageP, BooleanP, BooleanP}...}],
							Module[{integratedEntries, integratedVoltages},

								(* First pick out the entries where the secnd Boolean is True, aka when integration happens *)
								integratedEntries = Select[Lookup[myMapThreadOptions, BlankWaveformProfile], #[[4]] == True&];

								(* Then pull out the voltages of the entire integration period *)
								integratedVoltages = integratedEntries[[All, 2]];
								If[Length[DeleteDuplicates[integratedVoltages]] == 1,
									PulsedAmperometricDetection,
									IntegratedPulsedAmperometricDetection
								]
							],

							(* Final case, if WaveformProfile is specified as tuples of {Time, {Time,Voltage,Boolean,Boolean}}, then we apply the logic above *)
							MatchQ[Lookup[myMapThreadOptions, BlankWaveformProfile], {{TimeP, {{TimeP, VoltageP, BooleanP, BooleanP}...}...}...}],
							Module[{waveforms, integratedEntries, integratedVoltages},

								(* First pick out the entries where the secnd Boolean is True, aka when integration happens *)
								waveforms = Lookup[myMapThreadOptions, BlankWaveformProfile][[All, 2]];
								integratedEntries = Map[
									Function[{waveform},
										Select[waveform, #[[4]] == True&]
									],
									waveforms
								];

								(* Then pull out the voltages of the entire integration period *)
								integratedVoltages = integratedEntries[[All, All, 2]];
								If[Length[DeleteDuplicates[#]] == 1,
									PulsedAmperometricDetection,
									IntegratedPulsedAmperometricDetection
								]& /@ integratedVoltages
							]
						],

						(* If WaveformProfile is specified in the injection table, detection mode can either be Pulsed Amperometry or Integrated Pulsed Amperometry *)
						MatchQ[injectionTableBlankWaveformEntry, Except[Automatic | Null]],
						Which[
							(* If WaveformProfile is specified in the injection table, download the method and pull ElectrochemicalDetectionMode *)
							MatchQ[injectionTableBlankWaveformEntry, ObjectP[Object[Method, Waveform]]],
							Lookup[fetchPacketFromCache[Download[injectionTableBlankWaveformEntry, Object], fullCache], ElectrochemicalDetectionMode],

							(* If WaveformProfile is specified as multiple method objects in the injection table, then track ElectrochemicalDetectionMode of all methods *)
							MatchQ[injectionTableBlankWaveformEntry, {{TimeP, ObjectP[Object[Method, Waveform]]}...}],
							Lookup[fetchPacketFromCache[#, fullCache], ElectrochemicalDetectionMode]& /@ Download[injectionTableBlankWaveformEntry[[All, 2]], Object],

							(* Similar logic applies for Waveform specified in the injection table *)
							MatchQ[injectionTableBlankWaveformEntry, {{TimeP, VoltageP, BooleanP, BooleanP}...}],
							Module[{integratedEntries, integratedVoltages},

								(* First pick out the entries where the secnd Boolean is True, aka when integration happens *)
								integratedEntries = Select[injectionTableBlankWaveformEntry, #[[4]] == True&];

								(* Then pull out the voltages of the entire integration period *)
								integratedVoltages = integratedEntries[[All, 2]];
								If[Length[DeleteDuplicates[integratedVoltages]] == 1,
									PulsedAmperometricDetection,
									IntegratedPulsedAmperometricDetection
								]
							],

							(* The injection table specified with same logic as above *)
							MatchQ[injectionTableBlankWaveformEntry, {{TimeP, {{TimeP, VoltageP, BooleanP, BooleanP}...}...}...}],
							Module[{waveforms, integratedEntries, integratedVoltages},

								(* First pick out the entries where the secnd Boolean is True, aka when integration happens *)
								waveforms = injectionTableBlankWaveformEntry[[All, 2]];
								integratedEntries = Map[
									Function[{waveform},
										Select[waveform, #[[4]] == True&]
									],
									waveforms
								];

								(* Then pull out the voltages of the entire integration period *)
								integratedVoltages = integratedEntries[[All, 2]];
								If[Length[DeleteDuplicates[#]] == 1,
									PulsedAmperometricDetection,
									IntegratedPulsedAmperometricDetection
								]& /@ integratedVoltages
							]
						],

						(* If all things fail, return PulsedAmperometricDetection *)
						True,
						Automatic
					];

					multipleBlankDetectionModeQ = Module[{uniqueDetectionMode},
						(* Get the unique detection modes from all waveforms specified *)
						uniqueDetectionMode = DeleteDuplicates[ToList[blankWaveformDetectionMode]];
						(* If there are more than 1 detection mode, set error tracking variable to True, otherwise set it to False *)
						If[Length[uniqueDetectionMode] == 1,
							False,
							True
						]
					];

					blankElectrochemicalDetectionMode = Which[

						(* If user specified electrochemical detection mode, go with that *)
						MatchQ[Lookup[myMapThreadOptions, BlankElectrochemicalDetectionMode], Except[Automatic]],
						Lookup[myMapThreadOptions, BlankElectrochemicalDetectionMode],

						!MemberQ[ToList@resolvedDetector, ElectrochemicalDetector],
						Null,

						(* If VoltageProfile is specified, set detection mode to DC Amperometry *)
						MatchQ[Lookup[myMapThreadOptions, BlankVoltageProfile], Except[Automatic]] || MatchQ[injectionTableBlankVoltageEntry, Except[Automatic | Null]],
						DCAmperometricDetection,

						MatchQ[First@ToList[blankWaveformDetectionMode], Except[Automatic]],
						First@ToList[blankWaveformDetectionMode],


						MatchQ[First[ToList[resolvedElectrochemicalDetectionMode]], Except[Null]],
						First[ToList[resolvedElectrochemicalDetectionMode]],

						(* Use the ElectrochemicalDetectionMode of the first waveform as the resolved electrochemicalDetection Mode *)
						True,
						PulsedAmperometricDetection
					];

					(* Here we check if the electrochemical detection mode and the specified waveform is in conflict *)
					(* If there is already multiple detection mode error, then we can pass on this error *)
					blankWaveformDetectionModeConflictQ = If[multipleBlankDetectionModeQ,
						False,
						If[MatchQ[blankElectrochemicalDetectionMode, Except[DCAmperometricDetection]],
							If[!MatchQ[blankWaveformDetectionMode, Automatic],
								!MatchQ[First@ToList[blankWaveformDetectionMode], blankElectrochemicalDetectionMode],
								False
							],
							False
						]
					];

					blankReferenceElectrodeMode = Which[

						(* If user specified reference electrode mode, go with that *)
						MatchQ[Lookup[myMapThreadOptions, BlankReferenceElectrodeMode], Except[Automatic]],
						Lookup[myMapThreadOptions, BlankReferenceElectrodeMode],

						(* If ElectrochemicalDetectionMode is set to DCAmperometry, set reference electrode mode to Null *)
						MatchQ[Lookup[myMapThreadOptions, BlankElectrochemicalDetectionMode], DCAmperometricDetection],
						Null,

						(* If VoltageProfile is specified, set reference electrode mode to DC Amperometry *)
						MatchQ[Lookup[myMapThreadOptions, BlankVoltageProfile], Except[Automatic]] || MatchQ[injectionTableBlankVoltageEntry, Except[Automatic | Null]],
						Null,

						(* If WaveformProfile is specified, detection mode can either be Pulsed Amperometry or Integrated Pulsed Amperometry *)
						MatchQ[Lookup[myMapThreadOptions, BlankWaveformProfile], Except[Automatic]],
						Which[

							(* If WaveformProfile is specified as a method object, then directly pull ReferenceElectrodeMode field from it *)
							MatchQ[Lookup[myMapThreadOptions, BlankWaveformProfile], ObjectP[Object[Method, Waveform]]],
							Lookup[fetchPacketFromCache[Download[Lookup[myMapThreadOptions, BlankWaveformProfile], Object], fullCache], ReferenceElectrodeMode],

							(* If WaveformProfile is specified as multiple method objects, then track ReferenceElectrodeMode of all methods and use ReferenceElectrodeMode from the first method *)
							MatchQ[Lookup[myMapThreadOptions, BlankWaveformProfile], {{TimeP, ObjectP[Object[Method, Waveform]]}...}],
							Lookup[fetchPacketFromCache[Download[Lookup[myMapThreadOptions, BlankWaveformProfile][[1, 2]], Object], fullCache], ReferenceElectrodeMode],

							True,
							AgCl
						],

						(* If WaveformProfile is specified, detection mode can either be Pulsed Amperometry or Integrated Pulsed Amperometry *)
						MatchQ[injectionTableBlankWaveformEntry, Except[Automatic]],
						Which[
							(* If WaveformProfile is specified in the injection table, download the method and pull ReferenceElectrodeMode *)
							MatchQ[injectionTableBlankWaveformEntry, ObjectP[Object[Method, Waveform]]],
							Lookup[fetchPacketFromCache[Download[injectionTableBlankWaveformEntry, Object], fullCache], ReferenceElectrodeMode],

							(* If WaveformProfile is specified as multiple method objects in the injection table, then track ReferenceElectrodeMode of all methods and use ReferenceElectrodeMode from the first method *)
							MatchQ[injectionTableBlankWaveformEntry, {{TimeP, ObjectP[Object[Method, Waveform]]}...}],
							Lookup[fetchPacketFromCache[Download[injectionTableBlankWaveformEntry, Object], fullCache], ReferenceElectrodeMode],

							True,
							AgCl
						],

						(* If there are resolved voltage profile for the samples, use the first resolved value there *)
						MatchQ[resolvedReferenceElectrodeMode, Except[Automatic]],
						ToList[resolvedReferenceElectrodeMode][[1]],

						(* If WaveformProfile is specified as tuples of {Time,Voltage,Boolean,Boolean} or {Time, {Time,Voltage,Boolean,Boolean}}, either in the option or in the injection table *)
						(* And this option is not specified, then go ahead and set reference electrode mode to AgCl *)
						True,
						AgCl
					];

					blankVoltageProfile = Which[

						(* If the user is not using DC Amperometry, set it to Null *)
						!MatchQ[blankElectrochemicalDetectionMode, DCAmperometricDetection],
						Null,

						(* If the user has specified voltage profile, go with it *)
						MatchQ[Lookup[myMapThreadOptions, BlankVoltageProfile], Except[Automatic]],
						Lookup[myMapThreadOptions, BlankVoltageProfile],

						(* If the user has specified voltage profile in the injection table, go with it *)
						MatchQ[injectionTableBlankVoltageEntry, Except[Automatic | Null]],
						injectionTableBlankVoltageEntry,

						(* If the user has specified voltage profile in the injection table, go with it *)
						MatchQ[injectionTableBlankWaveformEntry, Except[Automatic]],
						injectionTableBlankWaveformEntry,

						(* If nothing is sepcified, use the first resolved value for VoltageProfile option *)
						MatchQ[resolvedVoltageProfile, Except[Automatic | Null | {Null}]],
						If[duplicateVoltageProfileTimeErrors[[1]],
							0.1 Volt,
							ToList[resolvedVoltageProfile][[1]]
						],

						(* Otherwise, set it to 0.1 Volt throughout the whole gradient *)
						True,
						0.1 Volt
					];

					(* We need to check that the time specified in VoltageProfile is monotonically increasing *)
					blankVoltageProfileDuplicateTimeQ = Module[{timeDifferences},
						(* This check only makes sense when VoltageProfile is specified as tuples in the form of {Time,Voltage} *)
						If[MatchQ[blankVoltageProfile, {{TimeP, VoltageP}...}],
							timeDifferences = Differences[blankVoltageProfile[[All, 1]]];
							If[MatchQ[timeDifferences, {GreaterP[0 * Second]...}],
								False,
								True
							],
							False
						]
					];

					blankWaveformProfile = Which[

						(* If the user is using DC Amperometry, set it to Null *)
						MatchQ[blankElectrochemicalDetectionMode, DCAmperometricDetection],
						Null,

						(* If the user has specified waveform profile, go with it *)
						MatchQ[Lookup[myMapThreadOptions, BlankWaveformProfile], Except[Automatic]],
						Lookup[myMapThreadOptions, BlankWaveformProfile],

						(* If the user has specified waveform profile in the injection table, go with it *)
						MatchQ[injectionTableBlankWaveformEntry, Except[Automatic | Null]],
						injectionTableBlankWaveformEntry,

						(* If nothing is specified, use the first resolved waveform for the sample *)
						MatchQ[resolvedWaveformProfile, Except[Automatic | Null]],
						If[multipleWaveformDurationErrors[[1]],
							Values[Lookup[fetchPacketFromCache[Download[Object[Method, Waveform, "Gold Electrode Quad Potential for Carbohydrate Analysis"], Object], fullCache], Waveform]],
							ToList[resolvedWaveformProfile][[1]]
						],

						(* If nothing is specified, then first we look at the ElectrochemicalDetectionMode *)
						True,
						Which[

							(* If the detection mode is PulsedAmperometricDetection *)
							MatchQ[blankElectrochemicalDetectionMode, PulsedAmperometricDetection],

							If[MatchQ[fetchPacketFromCache[Download[resolvedWorkingElectrode, Object], fullCache], <||> | Null],
								Null,
								(* Then we look at the coat material of the working electrode and give default waveform *)
								Switch[
									Lookup[workingElectrodeModelPacket, CoatMaterial],

									Gold,
									Values[Lookup[fetchPacketFromCache[Download[Object[Method, Waveform, "Gold Electrode Quad Potential for Carbohydrate Analysis"], Object], fullCache], Waveform]],

									Silver,
									Values[Lookup[fetchPacketFromCache[Download[Object[Method, Waveform, "Silver Electrode for Sulfide, Cyanide, Iodide, Thiosulface Analysis"], Object], fullCache], Waveform]],

									Platinum,
									Values[Lookup[fetchPacketFromCache[Download[Object[Method, Waveform, "Platinum Electrode for Alcohols, Glycols, Carboxylates, Cyanide, Sulfide Analysis"], Object], fullCache], Waveform]],

									_,
									Null
								]
							],

							(* If the detection mode is IntegratedPulsedAmperometricDetection *)
							MatchQ[blankElectrochemicalDetectionMode, IntegratedPulsedAmperometricDetection],

							If[MatchQ[fetchPacketFromCache[Download[resolvedWorkingElectrode, Object], fullCache], <||> | Null],
								Null,
								(* Then we look at the coat material of the working electrode and give default waveform *)
								Switch[
									Lookup[workingElectrodeModelPacket, CoatMaterial],

									Gold,
									Object[Method, Waveform, "Gold AAA Electrode for Amino Acids, Carbohydrates, Water Soluble Vitamins Analysis"],

									_,
									Null
								]
							],

							True,
							Null
						]
					];

					(* We need to check that the time specified in WaveformProfile is monotonically increasing *)
					blankWaveformProfileDuplicateTimeQ = Module[{waveformTimeDifferences, retentionTimeDifferences},
						Which[
							(* We first check the waveform times specified as tuples in the form of {Time,Voltage,Interpolation,Integration} *)
							MatchQ[blankWaveformProfile, {{TimeP, VoltageP, BooleanP, BooleanP}...}],
							waveformTimeDifferences = Differences[blankWaveformProfile[[All, 1]]];
							If[MatchQ[waveformTimeDifferences, {GreaterP[0 * Second]...}],
								False,
								True
							],

							(* Then we check the waveform times as well as retention times specified as tuples in the form of {Time,{Time,Voltage,Interpolation,Integration}} *)
							MatchQ[blankWaveformProfile, {{TimeP, {{TimeP, VoltageP, BooleanP, BooleanP}...}...}...}],
							waveformTimeDifferences = Differences /@ ((Last /@ blankWaveformProfile)[[All, All, 1]]);
							retentionTimeDifferences = Differences[First /@ blankWaveformProfile];
							If[MatchQ[waveformTimeDifferences, {{GreaterP[0 * Second]...}...}] && MatchQ[retentionTimeDifferences, {GreaterP[0 * Second]...}],
								False,
								True
							],

							(* Finally we check waveform times specified in the form of {Time, Object[Method,Waveform]} *)
							MatchQ[blankWaveformProfile, {{TimeP, ObjectP[Object[Method, Waveform]]}...}],
							retentionTimeDifferences = Differences[First /@ blankWaveformProfile];
							If[MatchQ[retentionTimeDifferences, {GreaterP[0 * Second]...}],
								False,
								True
							],

							True,
							False
						]
					];

					(* Before resolving sampling rate, let's first get the waveform duration *)
					blankWaveformDuration = Which[

						(* If the resolved waveform profile consists of a single waveform, grab WaveformDuration from the method object *)
						MatchQ[blankWaveformProfile, ObjectP[Object[Method, Waveform]]],
						Lookup[fetchPacketFromCache[Download[blankWaveformProfile, Object], fullCache], WaveformDuration],

						(* If the resolved waveform profile consists of multiple waveforms, grab WaveformDuration from the first method object *)
						MatchQ[blankWaveformProfile, {{TimeP, ObjectP[Object[Method, Waveform]]}...}],
						Lookup[fetchPacketFromCache[#, fullCache], WaveformDuration]& /@ Download[blankWaveformProfile[[All, 2]], Object],

						(* If the resolved waveform profile consists of a tuple in the form of {Time,Voltage,Boolean,Boolean}, get the last time point to be the waveform duration *)
						MatchQ[blankWaveformProfile, {{TimeP, VoltageP, BooleanP, BooleanP}...}],
						Last[blankWaveformProfile][[1]],

						(* If the resolved waveform profile consists of multiple tuples in the form of {Time,{Time,Voltage,Boolean,Boolean}}, get the last time point of all waveforms *)
						MatchQ[blankWaveformProfile, {{TimeP, {{TimeP, VoltageP, BooleanP, BooleanP}...}...}...}],
						(Last /@ Last /@ blankWaveformProfile)[[All, 1]],

						True,
						Null
					];

					(* We need to check if the specified waveforms have multiple duration *)
					multipleBlankWaveformDurationQ = Module[{uniqueDuration},
						uniqueDuration = DeleteDuplicates[ToList[blankWaveformDuration]];
						(* If so, set the error tracking variable to True, otherwise set it to False *)
						If[Length[uniqueDuration] == 1,
							False,
							True
						]
					];

					blankElectrochemicalSamplingRate = Which[

						(* If the user specified sampling rate for electrochemical detection, go with it *)
						MatchQ[Lookup[myMapThreadOptions, BlankElectrochemicalSamplingRate], Except[Automatic]],
						Lookup[myMapThreadOptions, BlankElectrochemicalSamplingRate],

						MatchQ[blankElectrochemicalDetectionMode, Null | {Null}],
						Null,

						(* If the user is using DC Amperometry, set it to 1.67 Hz, which is the default Chromeleon gives *)
						MatchQ[blankElectrochemicalDetectionMode, DCAmperometricDetection],
						1.67 / Second,

						(* If the user is using Integrated Amperometry, then we set sampling rate based on the resolved waveform duration *)
						MatchQ[blankWaveformProfile, Except[Null]],
						1 / (Convert[ToList[blankWaveformDuration][[1]], Second]),

						True,
						Null
					];

					blankDetectionTemperature = Which[

						(* If the user specified sampling rate for electrochemical detection, go with it *)
						MatchQ[Lookup[myMapThreadOptions, BlankDetectionTemperature], Except[Automatic]],
						Lookup[myMapThreadOptions, BlankDetectionTemperature],

						MatchQ[blankElectrochemicalDetectionMode, Null | {Null}],
						Null,

						(* If not specified, use the first resolved detection temperature for the sample *)
						MatchQ[resolvedDetectionTemperature, Except[Automatic | Null]],
						ToList[resolvedDetectionTemperature][[1]],

						(* Otherwise default to ambient temperature *)
						True,
						Ambient
					];

					Which[
						(* If there is no blank, set all resolved variable to Null and error tracking variable to False *)
						MatchQ[resolvedBlank, {} | Null | {Null}],
						Join[ConstantArray[Null, 9], ConstantArray[False, 8]],

						True,
						{
							blankColumnTemperature,
							blankAbsorbanceWavelength,
							blankAbsorbanceSamplingRate,
							blankElectrochemicalDetectionMode,
							blankReferenceElectrodeMode,
							blankVoltageProfile,
							blankWaveformProfile,
							blankElectrochemicalSamplingRate,
							blankDetectionTemperature,
							blankAbsorbanceOptionConflictQ,
							blankElectrochemicalOptionConflictQ,
							blankElectrochemicalModeOptionConflictQ,
							multipleBlankDetectionModeQ,
							blankWaveformDetectionModeConflictQ,
							multipleBlankWaveformDurationQ,
							blankVoltageProfileDuplicateTimeQ,
							blankWaveformProfileDuplicateTimeQ
						}
					]],
					{ToList@resolvedBlank, ToList@resolvedBlankGradient, mapThreadFriendlyElectrochemicalBlankOptions}
				]]
			]
		];

		(* === Massive error checks for all UVVis and Electrochemical Detection parameters === *)

		(* 1. Check if absorbance parameter specification is in conflict *)
		(* If the absorbance options are in conflict and we are throwing message, throw an error and collect invalid options *)
		invalidBlankAbsorbanceOptions = If[MemberQ[blankAbsorbanceOptionConflictErrors, True] && messagesQ,
			(
				Message[Error::InvalidAbsorbanceOption, {BlankAbsorbanceWavelength, BlankAbsorbanceSamplingRate}];
				{BlankAbsorbanceWavelength, BlankAbsorbanceSamplingRate}
			),
			{}
		];

		(* Test for absorbance options *)
		blankAbsorbanceOptionTest = testOrNullIndexMatched["The blank absorbance options are either both Null or both specified with a value:", ToList@resolvedBlank, Not[blankAbsorbanceOptionConflictErrors]];

		(* 1.1 Check if absorbance parameter specification is in conflict *)
		(* If the absorbance options are in conflict and we are throwing message, throw an error and collect invalid options *)
		invalidBlankElectrochemicalOptions = If[MemberQ[blankElectrochemicalOptionConflictErrors, True] && messagesQ,
			(
				Message[Error::InvalidElectrochemicalOption, {BlankElectrochemicalDetectionMode, BlankReferenceElectrodeMode, BlankElectrochemicalSamplingRate, BlankDetectionTemperature}];
				{BlankElectrochemicalDetectionMode, BlankReferenceElectrodeMode, BlankElectrochemicalSamplingRate, BlankDetectionTemperature}
			),
			{}
		];

		(* Test for absorbance options *)
		blankElectrochemicalOptionTest = testOrNullIndexMatched["The blank electrochemical options are not set to Null if Detector is set to ElectrochemicalDetector:", ToList@resolvedBlank, blankElectrochemicalOptionConflictErrors];


		(* 2. Check if electrochemical detection mode related paramter specification is in conflict *)
		(* Specifically if ElectrochemicalDetectionMode is DCAmperometricDetection, then VoltageProfile cannot be Null; if it's any other mode, then WaveformProfile cannot be Null *)
		(* If the absorbance options are in conflict and we are throwing message, throw an error and collect invalid options *)
		invalidBlankElectrochemicalDetectionModeOptions = If[MemberQ[blankElectrochemicalModeOptionConflictErrors, True] && messagesQ,
			(
				Message[Error::InvalidElectrochemicalDetectionModeOption, BlankElectrochemicalDetectionMode, BlankVoltageProfile, BlankWaveformProfile];
				{BlankElectrochemicalDetectionMode, BlankVoltageProfile, BlankWaveformProfile}
			),
			{}
		];

		(* Test for absorbance options *)
		blankElectrochemicalModeOptionTest = testOrNullIndexMatched["The blank electrochemical detection mode options are set correctly. If detection mode is DCAmperometricDetection, BlankVoltageProfile cannot be Null; If detection mode is any other amperometric detection, BlankWaveformProfile cannot be Null:", ToList@resolvedBlank, Not[blankElectrochemicalModeOptionConflictErrors]];

		(* 3. Check if the specified waveforms render several detection modes *)
		(* If the waveform specified give more than 1 electrochemical detection mode and we are throwing message, throw a warning *)
		multipleBlankDetectionModeOptions = If[MemberQ[multipleBlankDetectionModeErrors, True] && messagesQ && notInEngine,
			(
				Message[Warning::MultipleElectrochemicalDetectionModes, BlankWaveformProfile, BlankElectrochemicalDetectionMode];
				{}
			),
			{}
		];

		(* Test for absorbance options *)
		multipleBlankDetectionModeOptionTest = warningOrNullIndexMatched["The specified waveforms in BlankWaveformProfile option or in the injection table have a unique ElectrochemicalDetectionMode value:", ToList@resolvedBlank, Not[multipleBlankDetectionModeErrors]];

		(* 4. Check if the specified waveforms and the specified detection modes are consistent *)
		(* If the two options have conflicting values, throw an error and collect invalid options *)
		invalidBlankWaveformDetectionModeOptions = If[MemberQ[blankWaveformDetectionModeErrors, True] && messagesQ,
			(
				Message[Error::ConflictingElectrochemicalDetectionModes, BlankWaveformProfile, BlankElectrochemicalDetectionMode];
				{BlankWaveformProfile, BlankElectrochemicalDetectionMode}
			),
			{}
		];

		(* Test for absorbance options *)
		invalidBlankWaveformDetectionModeTest = testOrNullIndexMatched["The specified waveforms in BlankWaveformProfile option or in the injection table have consistent ElectrochemicalDetectionMode:", ToList@resolvedBlank, Not[multipleBlankDetectionModeErrors]];

		(* 5. Check if the specified waveforms have the same duration *)
		multipleBlankWaveformDurationSamples = PickList[ToList@resolvedBlank, multipleBlankWaveformDurationErrors, True];

		(* If the specified waveforms have different duration and we are throwing messages, throw an error and collect invalid options *)
		multipleBlankWaveformDurationOptions = If[MemberQ[multipleBlankWaveformDurationErrors, True] && messagesQ,
			(
				Message[Error::MultipleWaveformDuration, ObjectToString[multipleBlankWaveformDurationSamples, Cache -> fullCache, Simulation -> updatedSimulation], ObjectToString[resolvedInstrument, Cache -> fullCache, Simulation -> updatedSimulation]];
				{BlankWaveformProfile, BlankElectrochemicalSamplingRate}
			),
			{}
		];

		(* Test for absorbance options *)
		multipleBlankWaveformDurationTest = testOrNullIndexMatched["The specified waveforms all have the same waveform duration:", ToList@resolvedBlank, Not[multipleBlankWaveformDurationErrors]];

		(* 6. Check if the times specified in voltage profile is monotonically increasing *)
		(* If the specified voltage profile has duplicate or decreasing time and we are throwing messages, throw an error and collect invalid options *)
		blankVoltageProfileTimeOptions = If[MemberQ[duplicateBlankVoltageProfileTimeErrors, True] && messagesQ,
			(
				Message[Error::InvalidTimeSpecification, BlankVoltageProfile];
				{BlankVoltageProfile}
			),
			{}
		];

		(* Test for absorbance options *)
		blankVoltageProfileTimeTest = testOrNullIndexMatched["The specified VoltageProfile in the form of {Time,Voltage} have monotonically increasing time:", ToList@resolvedBlank, Not[duplicateBlankVoltageProfileTimeErrors]];

		(* 6. Check if the times specified in voltage profile is monotonically increasing *)
		(* If the specified voltage profile has duplicate or decreasing time and we are throwing messages, throw an error and collect invalid options *)
		blankWaveformProfileTimeOptions = If[MemberQ[duplicateBlankWaveformProfileTimeErrors, True] && messagesQ,
			(
				Message[Error::InvalidTimeSpecification, BlankWaveformProfile];
				{BlankWaveformProfile}
			),
			{}
		];

		(* Test for absorbance options *)
		blankWaveformProfileTimeTest = testOrNullIndexMatched["The specified BlankWaveformProfile in the form of {Time,Voltage,Interpolation,Integration} or {Time,{Time,Voltage,Interpolation,Integration}} have monotonically increasing time:", ToList@resolvedBlank, Not[duplicateBlankWaveformProfileTimeErrors]];


		(* 43. AnionColumnRefreshFrequency and CationColumnRefreshFrequency resolution *)

		(* First compile all the ColumnRefresh related options that cannot be Null when column prime/flush are specified*)
		anionColumnPrimeOptionNames = {
			AnionColumnPrimeTemperature,
			ColumnPrimeEluentGradient,
			AnionColumnPrimeFlowRate,
			AnionColumnPrimeGradient,
			AnionColumnPrimeSuppressorMode,
			AnionColumnPrimeDetectionTemperature
		};
		anionColumnFlushOptionNames = {
			AnionColumnFlushTemperature,
			ColumnFlushEluentGradient,
			AnionColumnFlushFlowRate,
			AnionColumnFlushGradient,
			AnionColumnFlushSuppressorMode,
			AnionColumnFlushDetectionTemperature
		};
		cationColumnPrimeOptionNames = {
			CationColumnPrimeTemperature,
			CationColumnPrimeGradientA,
			CationColumnPrimeGradientB,
			CationColumnPrimeGradientC,
			CationColumnPrimeGradientD,
			CationColumnPrimeFlowRate,
			CationColumnPrimeGradient,
			CationColumnPrimeSuppressorMode,
			CationColumnPrimeDetectionTemperature
		};
		cationColumnFlushOptionNames = {
			CationColumnFlushTemperature,
			CationColumnFlushGradientA,
			CationColumnFlushGradientB,
			CationColumnFlushGradientC,
			CationColumnFlushGradientD,
			CationColumnFlushFlowRate,
			CationColumnFlushGradient,
			CationColumnFlushSuppressorMode,
			CationColumnFlushDetectionTemperature
		};
		electrochemicalColumnPrimeOptionNames = {
			ColumnPrimeTemperature,
			ColumnPrimeGradientA,
			ColumnPrimeGradientB,
			ColumnPrimeGradientC,
			ColumnPrimeGradientD,
			ColumnPrimeFlowRate,
			ColumnPrimeGradient
		};
		electrochemicalColumnFlushOptionNames = {
			ColumnFlushTemperature,
			ColumnFlushGradientA,
			ColumnFlushGradientB,
			ColumnFlushGradientC,
			ColumnFlushGradientD,
			ColumnFlushFlowRate,
			ColumnFlushGradient
		};

		(*check to see if any of the column prime or flush options were nulled out*)
		anionColumnPrimeNullOutQ = MemberQ[Lookup[roundedOptionsAssociation, anionColumnPrimeOptionNames], Null];
		cationColumnPrimeNullOutQ = MemberQ[Lookup[roundedOptionsAssociation, cationColumnPrimeOptionNames], Null];
		anionColumnFlushNullOutQ = MemberQ[Lookup[roundedOptionsAssociation, anionColumnFlushOptionNames], Null];
		cationColumnFlushNullOutQ = MemberQ[Lookup[roundedOptionsAssociation, cationColumnFlushOptionNames], Null];
		columnPrimeNullOutQ = MemberQ[Lookup[roundedOptionsAssociation, electrochemicalColumnPrimeOptionNames], Null];
		columnFlushNullOutQ = MemberQ[Lookup[roundedOptionsAssociation, electrochemicalColumnFlushOptionNames], Null];

		(*resolved anion column refresh frequency*)
		resolvedAnionColumnRefreshFrequency = If[MatchQ[resolvedAnionColumn, {} | Null | {Null}],
			(* If there is no resolved Cation Column, then set this option to Null *)
			Null,

			Which[
				(*always accede to the user*)
				MatchQ[specifiedAnionColumnRefreshFrequency, Except[Automatic]], specifiedAnionColumnRefreshFrequency,
				(*check whether we have an InjectionTable. If so, Null.*)
				MatchQ[anionInjectionTableLookupRounded, Except[Automatic]], Null,
				(*check to see if any of the column prime options were Nulled out, but not the last*)
				anionColumnPrimeNullOutQ && !anionColumnFlushNullOutQ, Last,
				!anionColumnPrimeNullOutQ && anionColumnFlushNullOutQ, First,
				anionColumnPrimeNullOutQ && anionColumnFlushNullOutQ, None,
				(*otherwise, we'll do first and last*)
				True, FirstAndLast
			]
		];

		(*resolved cation column refresh frequency*)
		resolvedCationColumnRefreshFrequency = If[MatchQ[resolvedCationColumn, {} | Null | {Null}],
			(* If there is no resolved Cation Column, then set this option to Null *)
			Null,

			Which[
				(*always accede to the user*)
				MatchQ[specifiedCationColumnRefreshFrequency, Except[Automatic]], specifiedCationColumnRefreshFrequency,
				(*check whether we have an InjectionTable. If so, Null.*)
				MatchQ[cationInjectionTableLookupRounded, Except[Automatic]], Null,
				(*check to see if any of the column prime options were Nulled out, but not the last*)
				cationColumnPrimeNullOutQ && !cationColumnFlushNullOutQ, Last,
				!cationColumnPrimeNullOutQ && cationColumnFlushNullOutQ, First,
				cationColumnPrimeNullOutQ && cationColumnFlushNullOutQ, None,
				(*otherwise, we'll do first and last*)
				True, FirstAndLast
			]
		];

		(*resolved cation column refresh frequency*)
		resolvedColumnRefreshFrequency = If[MatchQ[resolvedColumn, {} | Null | {Null}],
			(* If there is no resolved Cation Column, then set this option to Null *)
			Null,

			Which[
				(*always accede to the user*)
				MatchQ[specifiedColumnRefreshFrequency, Except[Automatic]], specifiedColumnRefreshFrequency,
				(*check whether we have an InjectionTable. If so, Null.*)
				MatchQ[electrochemicalInjectionTableLookupRounded, Except[Automatic]], Null,
				(*check to see if any of the column prime options were Nulled out, but not the last*)
				columnPrimeNullOutQ && !columnFlushNullOutQ, Last,
				!columnPrimeNullOutQ && columnFlushNullOutQ, First,
				columnPrimeNullOutQ && columnFlushNullOutQ, None,
				(*otherwise, we'll do first and last*)
				True, FirstAndLast
			]
		];

		(* === Error check === *)

		(* Then compile other ColumnRefresh related options that can be Null even if column prime/flush are specified*)
		anionColumnPrimeOptions = Join[
			anionColumnPrimeOptionNames,
			{AnionColumnPrimeStart, AnionColumnPrimeEnd, AnionColumnPrimeDuration, AnionColumnPrimeSuppressorVoltage, AnionColumnPrimeSuppressorCurrent}
		];
		cationColumnPrimeOptions = Join[
			cationColumnPrimeOptionNames,
			{CationColumnPrimeStart, CationColumnPrimeEnd, CationColumnPrimeDuration, CationColumnPrimeSuppressorVoltage, CationColumnPrimeSuppressorCurrent}
		];
		electrochemicalColumnPrimeOptions = Join[electrochemicalColumnPrimeOptionNames,
			{ColumnPrimeStart, ColumnPrimeEnd, ColumnPrimeDuration, ColumnPrimeVoltageProfile, ColumnPrimeWaveformProfile, ColumnPrimeAbsorbanceWavelength,
				ColumnPrimeAbsorbanceSamplingRate, ColumnPrimeElectrochemicalDetectionMode, ColumnPrimeReferenceElectrodeMode, ColumnPrimeElectrochemicalSamplingRate,
				ColumnPrimeDetectionTemperature}
		];

		anionColumnFlushOptions = Join[
			anionColumnFlushOptionNames,
			{AnionColumnFlushStart, AnionColumnFlushEnd, AnionColumnFlushDuration, AnionColumnFlushSuppressorVoltage, AnionColumnFlushSuppressorCurrent}
		];
		cationColumnFlushOptions = Join[
			cationColumnFlushOptionNames,
			{CationColumnFlushStart, CationColumnFlushEnd, CationColumnFlushDuration, CationColumnFlushSuppressorVoltage, CationColumnFlushSuppressorCurrent}
		];
		electrochemicalColumnFlushOptions = Join[electrochemicalColumnFlushOptionNames,
			{ColumnFlushStart, ColumnFlushEnd, ColumnFlushDuration, ColumnFlushVoltageProfile, ColumnFlushWaveformProfile, ColumnFlushAbsorbanceWavelength,
				ColumnFlushAbsorbanceSamplingRate, ColumnFlushElectrochemicalDetectionMode, ColumnFlushReferenceElectrodeMode, ColumnFlushElectrochemicalSamplingRate,
				ColumnFlushDetectionTemperature}
		];


		(* -- Column Prime -- *)

		(*first we ask if any of the ColumnPrime options are defined*)
		anionColumnPrimeOptionSpecifiedBool = Map[
			MatchQ[Lookup[roundedOptionsAssociation, #], Except[ListableP[(Null | None | Automatic | Disposal)]]]&,
			anionColumnPrimeOptions
		];
		(* Check to see if column prime exists in the first place *)
		anionColumnPrimeExistsQ = !MatchQ[resolvedAnionColumnRefreshFrequency, None | Null] || MemberQ[anionColumnPrimeOptionSpecifiedBool, True] || MemberQ[anionInjectionTableTypes, ColumnPrime];

		cationColumnPrimeOptionSpecifiedBool = Map[
			MatchQ[Lookup[roundedOptionsAssociation, #], Except[ListableP[(Null | None | Automatic | Disposal)]]]&,
			anionColumnPrimeOptions
		];
		cationColumnPrimeExistsQ = !MatchQ[resolvedCationColumnRefreshFrequency, None | Null] || MemberQ[cationColumnPrimeOptionSpecifiedBool, True] || MemberQ[cationInjectionTableTypes, ColumnPrime];

		electrochemicalColumnPrimeOptionSpecifiedBool = Map[
			MatchQ[Lookup[roundedOptionsAssociation, #], Except[ListableP[(Null | None | Automatic)]]]&,
			electrochemicalColumnPrimeOptions
		];
		electrochemicalColumnPrimeExistsQ = !MatchQ[resolvedColumnRefreshFrequency, None | Null] || MemberQ[electrochemicalColumnPrimeOptionSpecifiedBool, True] || MemberQ[electrochemicalInjectionTableTypes, ColumnPrime];


		(* 9.2 If AnionColumnPrime is specified, all anion column prime related options, i.e. the gradient and detection options cannot be Null *)

		(*simultaneously, we should check to see if certain options were set to Null when they shouldn't have been*)
		anionColumnPrimeConflictQ = And[anionColumnPrimeExistsQ, MemberQ[Lookup[roundedOptionsAssociation, anionColumnPrimeOptionNames], ListableP[Null | None]]];

		(*do all of our error accounting *)
		invalidAnionColumnPrimeConflictOptions = If[anionColumnPrimeConflictQ && messagesQ,
			(
				Message[Error::ColumnRefreshOptionConflict, "Anion Column Prime", AnionChannel, PickList[anionColumnPrimeOptionNames, Lookup[roundedOptionsAssociation, anionColumnPrimeOptionNames], ListableP[Null | None]]];
				PickList[anionColumnPrimeOptionNames, Lookup[roundedOptionsAssociation, anionColumnPrimeOptionNames], ListableP[Null | None]]
			),
			{}
		];

		(* generate the test for mismatches between the injection table and the samples *)
		anionColumnPrimeConflictTest = testOrNull["If AnionColumnPrime is specified, the other pertinent options should not be set to Null:", Not[anionColumnPrimeConflictQ]];

		(* 9.3 If CationColumnPrime is specified, all cation column prime related options, i.e. the gradient and detection options cannot be Null *)
		(*simultaneously, we should check to see if certain options were set to Null when they shouldn't have been*)
		catonColumnPrimeConflictQ = And[cationColumnPrimeExistsQ, MemberQ[Lookup[roundedOptionsAssociation, cationColumnPrimeOptionNames], ListableP[Null | None]]];

		(*do all of our error accounting *)
		invalidCationColumnPrimeConflictOptions = If[catonColumnPrimeConflictQ && messagesQ,
			(
				Message[Error::ColumnRefreshOptionConflict, "Cation Column Prime", CationChannel, PickList[cationColumnPrimeOptionNames, Lookup[roundedOptionsAssociation, cationColumnPrimeOptionNames], ListableP[Null | None]]];
				PickList[cationColumnPrimeOptionNames, Lookup[roundedOptionsAssociation, cationColumnPrimeOptionNames], ListableP[Null | None]]
			),
			{}
		];

		(* generate the test for mismatches between the injection table and the samples *)
		cationColumnPrimeConflictTest = testOrNull["If CationColumnPrime is specified, the other pertinent options should not be set to Null:", Not[cationColumnPrimeConflictQ]];

		(* 9.4 If ColumnPrime is specified for electrochemical channel, all column prime related options, i.e. the gradient and detection options cannot be Null *)
		(*simultaneously, we should check to see if certain options were set to Null when they shouldn't have been*)
		electrochemicalColumnPrimeConflictQ = And[electrochemicalColumnPrimeExistsQ, MemberQ[Lookup[roundedOptionsAssociation, electrochemicalColumnPrimeOptionNames], ListableP[Null | None]]];

		(*do all of our error accounting *)
		invalidElectrochemicalColumnPrimeConflictOptions = If[electrochemicalColumnPrimeConflictQ && messagesQ,
			(
				Message[Error::ColumnRefreshOptionConflict, "Column Prime", ElectrochemicalChannel, PickList[electrochemicalColumnPrimeOptionNames, Lookup[roundedOptionsAssociation, electrochemicalColumnPrimeOptionNames], ListableP[Null | None]]];
				PickList[electrochemicalColumnPrimeOptionNames, Lookup[roundedOptionsAssociation, electrochemicalColumnPrimeOptionNames], ListableP[Null | None]]
			),
			{}
		];

		(* generate the test for mismatches between the injection table and the samples *)
		electrochemicalColumnPrimeConflictTest = testOrNull["If ColumnPrime is specified for electrochemical channel, the other pertinent options should not be set to Null:", Not[electrochemicalColumnPrimeConflictQ]];


		(* -- Column Flush -- *)

		(*first we ask if any of the ColumnFlush options are defined*)
		anionColumnFlushOptionSpecifiedBool = Map[
			MatchQ[Lookup[roundedOptionsAssociation, #], Except[ListableP[(Null | None | Automatic | Disposal)]]]&,
			anionColumnFlushOptions
		];
		(* Check to see if column prime exists in the first place *)
		anionColumnFlushExistsQ = !MatchQ[resolvedAnionColumnRefreshFrequency, None | Null | First | GradientChange | _?NumericQ] || MemberQ[anionColumnFlushOptionSpecifiedBool, True] || MemberQ[anionInjectionTableTypes, ColumnFlush];

		cationColumnFlushOptionSpecifiedBool = Map[
			MatchQ[Lookup[roundedOptionsAssociation, #], Except[ListableP[(Null | None | Automatic | Disposal)]]]&,
			anionColumnFlushOptions
		];
		cationColumnFlushExistsQ = !MatchQ[resolvedCationColumnRefreshFrequency, None | Null | First | GradientChange | _?NumericQ] || MemberQ[cationColumnFlushOptionSpecifiedBool, True] || MemberQ[cationInjectionTableTypes, ColumnFlush];

		electrochemicalColumnFlushOptionSpecifiedBool = Map[
			MatchQ[Lookup[roundedOptionsAssociation, #], Except[ListableP[(Null | None | Automatic)]]]&,
			electrochemicalColumnFlushOptions
		];
		electrochemicalColumnFlushExistsQ = !MatchQ[resolvedColumnRefreshFrequency, None | Null | First | GradientChange | _?NumericQ] || MemberQ[electrochemicalColumnFlushOptionSpecifiedBool, True] || MemberQ[electrochemicalInjectionTableTypes, ColumnFlush];


		(* 9.2 If AnionColumnFlush is specified, all anion column prime related options, i.e. the gradient and detection options cannot be Null *)

		(*simultaneously, we should check to see if certain options were set to Null when they shouldn't have been*)
		anionColumnFlushConflictQ = And[anionColumnFlushExistsQ, MemberQ[Lookup[roundedOptionsAssociation, anionColumnFlushOptionNames], ListableP[Null | None]]];

		(*do all of our error accounting *)
		invalidAnionColumnFlushConflictOptions = If[anionColumnFlushConflictQ && messagesQ,
			(
				Message[Error::ColumnRefreshOptionConflict, "Anion Column Flush", AnionChannel, PickList[anionColumnFlushOptionNames, Lookup[roundedOptionsAssociation, anionColumnFlushOptionNames], ListableP[Null | None]]];
				PickList[anionColumnFlushOptionNames, Lookup[roundedOptionsAssociation, anionColumnFlushOptionNames], ListableP[Null | None]]
			),
			{}
		];

		(* generate the test for mismatches between the injection table and the samples *)
		anionColumnFlushConflictTest = testOrNull["If AnionColumnFlush is specified, the other pertinent options should not be set to Null:", Not[anionColumnFlushConflictQ]];

		(* 9.3 If CationColumnFlush is specified, all cation column prime related options, i.e. the gradient and detection options cannot be Null *)
		(*simultaneously, we should check to see if certain options were set to Null when they shouldn't have been*)
		catonColumnFlushConflictQ = And[cationColumnFlushExistsQ, MemberQ[Lookup[roundedOptionsAssociation, cationColumnFlushOptionNames], ListableP[Null | None]]];

		(*do all of our error accounting *)
		invalidCationColumnFlushConflictOptions = If[catonColumnFlushConflictQ && messagesQ,
			(
				Message[Error::ColumnRefreshOptionConflict, "Cation Column Flush", CationChannel, PickList[cationColumnFlushOptionNames, Lookup[roundedOptionsAssociation, cationColumnFlushOptionNames], ListableP[Null | None]]];
				PickList[cationColumnFlushOptionNames, Lookup[roundedOptionsAssociation, cationColumnFlushOptionNames], ListableP[Null | None]]
			),
			{}
		];

		(* generate the test for mismatches between the injection table and the samples *)
		cationColumnFlushConflictTest = testOrNull["If CationColumnFlush is specified, the other pertinent options should not be set to Null:", Not[cationColumnFlushConflictQ]];

		(* 9.4 If ColumnFlush is specified for electrochemical channel, all column prime related options, i.e. the gradient and detection options cannot be Null *)
		(*simultaneously, we should check to see if certain options were set to Null when they shouldn't have been*)
		electrochemicalColumnFlushConflictQ = And[electrochemicalColumnFlushExistsQ, MemberQ[Lookup[roundedOptionsAssociation, electrochemicalColumnFlushOptionNames], ListableP[Null | None]]];

		(*do all of our error accounting *)
		invalidElectrochemicalColumnFlushConflictOptions = If[electrochemicalColumnFlushConflictQ && messagesQ,
			(
				Message[Error::ColumnRefreshOptionConflict, "Column Flush", ElectrochemicalChannel, PickList[electrochemicalColumnFlushOptionNames, Lookup[roundedOptionsAssociation, electrochemicalColumnFlushOptionNames], ListableP[Null | None]]];
				PickList[electrochemicalColumnFlushOptionNames, Lookup[roundedOptionsAssociation, electrochemicalColumnFlushOptionNames], ListableP[Null | None]]
			),
			{}
		];

		(* generate the test for mismatches between the injection table and the samples *)
		electrochemicalColumnFlushConflictTest = testOrNull["If ColumnFlush is specified for electrochemical channel, the other pertinent options should not be set to Null:", Not[electrochemicalColumnFlushConflictQ]];


		(* 44. Anion column prime and column flush related options *)

		(* All column prime options are not index matched, so it's similar to the regular gradient resolution but no map thread *)

		{
			{
				resolvedAnionColumnPrimeTemperature,
				resolvedAnionColumnPrimeGradient,
				resolvedColumnPrimeEluentGradient,
				resolvedAnionColumnPrimeFlowRate,
				resolvedAnionColumnPrimeStart,
				resolvedAnionColumnPrimeEnd,
				resolvedAnionColumnPrimeDuration,
				resolvedAnionColumnPrimeSuppressorMode,
				resolvedAnionColumnPrimeSuppressorVoltage,
				resolvedAnionColumnPrimeSuppressorCurrent,
				resolvedAnionColumnPrimeDetectionTemperature,
				anionColumnPrimeGradientConsistentErrors,
				anionColumnPrimeStartEndSpecifiedErrors,
				anionColumnPrimeDurationOptionSpecifiedErrors,
				invalidAnionColumnPrimeGradientCompositionErrors,
				anionColumnPrimeRemovedExtraErrors,
				anionColumnPrimeFlowRateErrors,
				conflictingAnionColumnPrimeSuppressorModeErrors,
				anionColumnPrimeDurationConsistentErrors,
				overwriteAnionColumnPrimeGradientBool
			},
			{
				resolvedAnionColumnFlushTemperature,
				resolvedAnionColumnFlushGradient,
				resolvedColumnFlushEluentGradient,
				resolvedAnionColumnFlushFlowRate,
				resolvedAnionColumnFlushStart,
				resolvedAnionColumnFlushEnd,
				resolvedAnionColumnFlushDuration,
				resolvedAnionColumnFlushSuppressorMode,
				resolvedAnionColumnFlushSuppressorVoltage,
				resolvedAnionColumnFlushSuppressorCurrent,
				resolvedAnionColumnFlushDetectionTemperature,
				anionColumnFlushGradientConsistentErrors,
				anionColumnFlushStartEndSpecifiedErrors,
				anionColumnFlushDurationOptionSpecifiedErrors,
				invalidAnionColumnFlushGradientCompositionErrors,
				anionColumnFlushRemovedExtraErrors,
				anionColumnFlushFlowRateErrors,
				conflictingAnionColumnFlushSuppressorModeErrors,
				anionColumnFlushDurationConsistentErrors,
				overwriteAnionColumnFlushGradientBool
			}
		} = Module[{
			specifiedRefreshfrequency, frequency, eluentgradient, gradient, flowrate, start, end, duration, cleaningType, defaultGradient, columnTemperature, suppressorCurrent, detectionTemperature,
			anionInjectionTableRoundedGradient, anionGradientConsistentQ, anionRemovedExtrasQ, protoAnionGradientOptionTuple, anionGradientOptionTuple,
			defaultedAnionFlowRate, anionGradientReturned, initiallyResolvedAnionGradient, invalidAnionGradientCompositionQ, eluentGradient, anionFlowRate, anionGradient,
			anionColumnTemperature, anionSuppressorCurrent, anionDetectionTemperature, overwriteAnionCleaningGradientQ, suppressorMode, suppressorVoltage, anionSuppressorMode,
			anionGradientTuples, maxFlowRate, maxEluentConc, defaultMinAnionSuppressorCurrent, anionSuppressorVoltage, anionSuppressorModeConflictQ, incompatibleAnionFlowRateQ,
			anionGradientStartEndSpecifiedQ, anionGradientStart, anionGradientEnd, anionDurationOptionsSpecifiedQ, anionDurationConsistentQ, individualGradientSpecifiedQ},

			Map[Function[{entryVariables},

				{specifiedRefreshfrequency, frequency, eluentgradient, gradient, flowrate, start, end, duration, cleaningType, defaultGradient, columnTemperature, suppressorMode, suppressorVoltage, suppressorCurrent, detectionTemperature} = entryVariables;

				If[
					Or[
						MatchQ[resolvedAnionColumn, {} | Null | {Null}],
						And[
							MatchQ[specifiedRefreshfrequency, frequency],
							Length[Cases[anionInjectionTableLookupRounded, {cleaningType, ___}]] == 0
						]
					],
					(* If there is no resolvedAnionBlank, then set all anion gradient related options to Null, and all error tracking variable to False *)
					Join[ConstantArray[Null, 11], ConstantArray[False, 9]],


					(* Setup: We first get the injection table gradients *)
					anionInjectionTableRoundedGradient = If[MatchQ[anionInjectionTableLookupRounded, Except[Automatic]],

						(* Extract the gradient specified in InjectionTable *)
						Cases[anionInjectionTableLookupRounded, {cleaningType, _, gradient_} :> gradient],

						(* If InjectionTable is not specified or has conflict with input samples, pad it with Automatics*)
						Automatic
					];

					(* First we need to make sure that the start and end options are either all specified or not *)
					anionGradientStartEndSpecifiedQ = !MatchQ[{start, end}, {ConcentrationP, ConcentrationP} | {Automatic | Null, Automatic | Null}];

					(* Then we need to make sure that the duration is specified either with start & end, or with eluent gradient *)
					anionDurationOptionsSpecifiedQ = If[MatchQ[duration, TimeP],
						Not[MatchQ[{start, end}, {ConcentrationP, ConcentrationP}] || MatchQ[eluentgradient, ConcentrationP]],
						False
					];

					(* Need to check if any of the individual gradient is specified in {Time,Percent} format *)
					individualGradientSpecifiedQ = MatchQ[eluentgradient, Except[Automatic | ConcentrationP]];

					(* We also need to check if Duration specification is consistent with individual gradient *)
					anionDurationConsistentQ = If[individualGradientSpecifiedQ,

						If[MatchQ[duration, TimeP],
							True,
							False
						],
						(* If none of the individual gradient is specified, then leave this error tracking variable to False *)
						False
					];

					(* If gradient is specied as a method object, check whether AnionBlankGradient and the injection table specify the same object*)
					anionGradientConsistentQ = If[
						MatchQ[gradient, ObjectP[Object[Method, IonChromatographyGradient]]] &&
							MatchQ[anionInjectionTableRoundedGradient, {ObjectP[Object[Method, IonChromatographyGradient]]}],

						Not[MatchQ[ToList@Download[gradient, Object], Download[anionInjectionTableRoundedGradient, Object]]],
						False
					];

					(* Extract or default GradientStart and GradientEnd values *)
					{anionGradientStart, anionGradientEnd} = Switch[{start, end, duration},

						(* If valid anionGradientStart and anionGradientEnd are given, go with that *)
						{ConcentrationP, ConcentrationP, _} | {Null, Null, Null | TimeP}, {start, end},

						(* Default to anionGradientStart if something is wrong with gradientEnd *)
						{ConcentrationP, _, _}, {start, start},

						(* Default to 0 Millimolar if something is wrong with anionGradeintStart *)
						{_, ConcentrationP, _}, {0 Millimolar, end},

						(* Otherwise, both Null*)
						_, {Null, Null}
					];

					(* If Gradient option is an object, pull Gradient value from packet *)
					protoAnionGradientOptionTuple = Which[

						(* If AnionBlankGradient specifies a method object, extract Gradient information from the packet *)
						MatchQ[gradient, ObjectP[Object[Method, IonChromatographyGradient]]],
						Lookup[fetchPacketFromCache[Download[gradient, Object], fullCache], AnionGradient],

						(* If InjectionTable specifies a method object, extract Gradient information from the packet *)
						MatchQ[gradient, Automatic] && MatchQ[anionInjectionTableRoundedGradient, ObjectP[Object[Method, IonChromatographyGradient]]],
						Lookup[fetchPacketFromCache[Download[anionInjectionTableRoundedGradient, Object], fullCache], AnionGradient],

						(* Otherwise, namely if anionGradient is not a method object, then use what's specified in AnionGradient *)
						True, gradient
					];

					(* Update AnionBlanklowRate in the gradient method object if the option is specified *)
					anionGradientOptionTuple = If[MatchQ[flowrate, Except[Automatic]],

						(* If AnionBlankFlowRate is specified, use the specified flow rate and replace the default flowrate of the method object *)
						(* In IonChromatography Gradient method, AnionBlankGradient goes "Time", "Eluent Concentration", "FlowRate". FlowRate is in the third column *)
						ReplacePart[protoAnionGradientOptionTuple, Table[{x, 3} -> flowrate, {x, 1, Length[protoAnionGradientOptionTuple]}]],

						(* Otherwise, use the default flow rate in the gradient object *)
						protoAnionGradientOptionTuple
					];

					(* Default FlowRate to option value, gradient tuple values, or the pre-calculated optimal flow rate for the column *)
					(* note that it's ok to have this flow rate either match FlowRateP, or be a list of pairs of time and flow rate since resolveGradient can handle either *)
					defaultedAnionFlowRate = Which[

						(* If the AnionBlankFlowRate is specified, go with the user specified value *)
						MatchQ[flowrate, Except[Automatic]], flowrate,

						(* If the AnionBlankFlowRate is specified as part of the gradient method object, extract the flow rate from the object *)
						MatchQ[anionGradientOptionTuple, {TimeP, ConcentrationP, FlowRateP}], anionGradientOptionTuple[[All, {1, 3}]], (* TODO: made a new gradient type here; doublecheck *)

						(* If no flow rate is specified, use the optional flow rate determined for the column *)
						True, optimalAnionColumnFlowRate
					];

					(* Setup error tracking variable for error messages outside this map thread *)
					incompatibleAnionFlowRateQ = Not[Between[defaultedAnionFlowRate, {minAnionFlowRate, maxAnionFlowRate}]];

					(* finally run our helper resolution function *)
					anionGradientReturned = If[MatchQ[{anionGradientOptionTuple, eluentgradient, start, end, duration, flowrate}, {(Null | Automatic)..}] || anionGradientStartEndSpecifiedQ || anionDurationOptionsSpecifiedQ,
						resolveICAnionGradient[defaultAnionGradientIC[defaultedAnionFlowRate], eluentgradient, defaultedAnionFlowRate, start, end, duration],
						resolveICAnionGradient[anionGradientOptionTuple, eluentgradient, defaultedAnionFlowRate, start, end, duration]
					];

					(*remove duplicate entries if need be*)
					initiallyResolvedAnionGradient = DeleteDuplicatesBy[anionGradientReturned, First[# * 1.] &];

					(*if it's not the same note that*)
					anionRemovedExtrasQ = !MatchQ[anionGradientReturned, initiallyResolvedAnionGradient];

					(*check whether the gradient composition adds up to 100 okay*)
					invalidAnionGradientCompositionQ = Not[AllTrue[initiallyResolvedAnionGradient, #[[2]] <= 100 Millimolar&]];

					(*now resolve all of the individual gradients and flow rate*)
					eluentGradient = If[MatchQ[initiallyResolvedAnionGradient, {}],

						{},

						If[MatchQ[eluentgradient, Automatic],
							collapseGradient[initiallyResolvedAnionGradient[[All, {1, 2}]]],
							eluentgradient
						]
					];

					anionFlowRate = If[MatchQ[initiallyResolvedAnionGradient, {}],

						{},

						If[MatchQ[flowrate, Automatic],
							collapseGradient[initiallyResolvedAnionGradient[[All, {1, -1}]]],
							flowrate
						]
					];

					overwriteAnionCleaningGradientQ = If[MatchQ[gradient, ObjectP[Object[Method, IonChromatographyGradient]]],
						!MatchQ[Lookup[fetchPacketFromCache[Download[gradient, Object], fullCache], AnionGradient], initiallyResolvedAnionGradient],
						False
					];

					(*finally resolve the gradient*)
					anionGradient = Which[
						MatchQ[gradient, ObjectP[Object[Method, IonChromatographyGradient]]] && !overwriteAnionCleaningGradientQ, gradient,
						(*otherwise if the gradient is automatic and the injection table is set, should use that*)
						MatchQ[gradient, Automatic] && MatchQ[anionInjectionTableRoundedGradient, ObjectP[Object[Method, IonChromatographyGradient]]], Download[anionInjectionTableRoundedGradient, Object],
						(*otherwise, it should be a tuple*)
						True, initiallyResolvedAnionGradient
					];

					(* Download the gradient object from fullCache and extract column temperature information *)
					anionColumnTemperature = Which[

						(* If user has already specified anion column temperature, go with that *)
						!MatchQ[columnTemperature, ListableP[Automatic | Null]],
						columnTemperature,

						(* If the specified AnionGradient is a method object, extract column temperature from there *)
						MatchQ[anionGradient, ObjectP[Object[Method, IonChromatographyGradient]]],
						If[NullQ[Lookup[fetchPacketFromCache[Download[anionGradient, Object], fullCache], AnionColumnTemperature]],
							Ambient,
							Lookup[fetchPacketFromCache[Download[anionGradient, Object], fullCache], AnionColumnTemperature]
						],

						(* If the specified gradient in the InjectionTable is an Object, extract column temperature from there *)
						MatchQ[anionInjectionTableRoundedGradient, ObjectP[Object[Method, IonChromatographyGradient]]],
						Lookup[fetchPacketFromCache[anionInjectionTableRoundedGradient, fullCache], AnionColumnTemperature],

						(* If AnionColumnTemperature is resolved to Null, set ColumnPrimeTemperature to be 25 Celsius *)
						MatchQ[resolvedAnionColumnTemperature, {} | Null | {Null}],
						Ambient,

						MatchQ[resolvedAnionColumnTemperature[[1]], Ambient],
						Ambient,

						True,
						resolvedAnionColumnTemperature[[1]]
					];

					(* If user specified AnionSuppressorMode, go with that *)
					anionSuppressorMode = Which[

						(* If user specified suppressor mode, then go with that *)
						MatchQ[suppressorMode, Except[Null | Automatic]],
						suppressorMode,

						(* If user does not specify suppressor mode but instead specify suppressor voltage, set suppressorMode to DynamicMode *)
						MatchQ[suppressorVoltage, Except[Null | Automatic]],
						DynamicMode,

						(* Similarly, if user does not specify suppressor mode but instead specify suppressor current, set suppressorMode to LegacyMode *)
						MatchQ[suppressorCurrent, Except[Null | Automatic]],
						LegacyMode,

						(* If nothing is specified, resolve to DynamicMode *)
						True,
						LegacyMode
					];
					anionGradientTuples = If[MatchQ[anionGradient, ObjectP[Object[Method]]],
						(*If our resolved gradient is an object, we need to extract the actual gradient from the correct field*)
						Lookup[fetchPacketFromCache[Download[anionGradient, Object], fullCache], AnionGradient],
						(*Otherwise it is already a list of sample and flow rate*)
						anionGradient
					];
					(* Preparation to resolve anionSuppressorCurrent *)
					(* anionSuppressorCurrent (mA) = FlowRate (min/mL) x [Eluent] x suppressor specific Factor *)
					maxFlowRate = Convert[Max[anionGradientTuples[[All, -1]]], Milliliter / Minute];
					maxEluentConc = Convert[Max[anionGradientTuples[[All, 2]]], Millimolar];
					defaultMinAnionSuppressorCurrent = SafeRound[Unitless[maxFlowRate * maxEluentConc * anionSuppressorSpecificFactor], 1, Round -> Up] * Milli * Ampere;

					{anionSuppressorVoltage, anionSuppressorCurrent, anionSuppressorModeConflictQ} = Which[

						(* If AnionSuppressorMode option is set to DynamicMode, then we need to resolve AnionSuppressorVoltage and set AnionSuppressorCurrent to Null *)
						MatchQ[anionSuppressorMode, DynamicMode],
						If[
							(* First we need to make sure when AnionSuppressorMode is set to DynamicMode, AnionSuppressorCurrent is not specified *)
							(* If it is specified, set error tracking variable to True so that we can throw error later *)
							MatchQ[suppressorVoltage, Null],
							{Null, Null, True},

							Which[
								(* If AnionSuppressorVoltage is specified, go with that *)
								MatchQ[suppressorVoltage, Except[Automatic]],
								{suppressorVoltage, Null, False},

								(* If not, use the factory recommended value of the suppressor *)
								MatchQ[suppressorVoltage, Automatic],
								{anionSuppressorRecommendedVoltage, Null, False},

								True,
								{anionSuppressorRecommendedVoltage, Null, False}
							]
						],

						(* If AnionSuppressorMode option is set to LegacyMode, then we need to resolve AnionSuppressorCurrent and set AnionSuppressotVoltage to Null *)
						MatchQ[anionSuppressorMode, LegacyMode],
						If[
							(* First we need to make sure when AnionSuppressorMode is set to LegacyModel, AnionSuppressorVoltage is not specified *)
							(* If it is specified, set error tracking variable to True so that we can throw error later *)
							MatchQ[suppressorCurrent, Null],
							{Null, Null, True},

							Which[
								(* If AnionSuppressorCurrent is specified, go with that *)
								MatchQ[suppressorCurrent, Except[Automatic]],
								{Null, suppressorCurrent, False},

								(* If not, use the factory recommended value of the suppressor *)
								MatchQ[suppressorCurrent, Automatic],
								{Null, defaultMinAnionSuppressorCurrent, False},

								MatchQ[defaultMinAnionSuppressorCurrent, 0 Milliampere],
								{Null, 15 Milliampere, False},

								True,
								{Null, defaultMinAnionSuppressorCurrent, False}
							]
						],

						True,
						{Null, Null, False}
					];

					(* If user specified CationDetectionTemperature, go with that *)
					anionDetectionTemperature = If[MatchQ[detectionTemperature, Except[Automatic | Null]],
						detectionTemperature,
						(* Otherwise, use Ambient detection *)
						Which[
							MatchQ[resolvedAnionDetectionTemperature, Null | {} | {Null}],
							Ambient,

							MatchQ[resolvedAnionDetectionTemperature[[1]], Ambient],
							Ambient,

							Not[Between[resolvedAnionDetectionTemperature[[1]], {minAnionDetectionTemperature /. Null -> -Infinity Celsius, maxAnionDetectionTemperature /. Null -> Infinity Celsius}]],
							Ambient,

							True,
							resolvedAnionDetectionTemperature[[1]]
						]
					];

					(*return everything*)
					{
						anionColumnTemperature,
						anionGradient,
						eluentGradient,
						anionFlowRate,
						anionGradientStart,
						anionGradientEnd,
						duration,
						anionSuppressorMode,
						anionSuppressorVoltage,
						anionSuppressorCurrent,
						anionDetectionTemperature,
						anionGradientConsistentQ,
						anionGradientStartEndSpecifiedQ,
						anionDurationOptionsSpecifiedQ,
						invalidAnionGradientCompositionQ,
						anionRemovedExtrasQ,
						incompatibleAnionFlowRateQ,
						anionSuppressorModeConflictQ,
						anionDurationConsistentQ,
						overwriteAnionCleaningGradientQ
					}
				]
			],
				{
					{resolvedAnionColumnRefreshFrequency, Null | None | Last, specifiedColumnPrimeEluentGradient, specifiedAnionColumnPrimeGradient, specifiedAnionColumnPrimeFlowRate, specifiedAnionColumnPrimeStart, specifiedAnionColumnPrimeEnd, specifiedAnionColumnPrimeDuration, ColumnPrime, defaultAnionPrimeGradientIC, specifiedAnionColumnPrimeTemperature, specifiedAnionColumnPrimeSuppressorMode, specifiedAnionColumnPrimeSuppressorVoltage, specifiedAnionColumnPrimeSuppressorCurrent, specifiedAnionColumnPrimeDetectionTemperature},
					{resolvedAnionColumnRefreshFrequency, Except[FirstAndLast | Last], specifiedColumnFlushEluentGradient, specifiedAnionColumnFlushGradient, specifiedAnionColumnFlushFlowRate, specifiedAnionColumnFlushStart, specifiedAnionColumnFlushEnd, specifiedAnionColumnFlushDuration, ColumnFlush, defaultAnionFlushGradientIC, specifiedAnionColumnFlushTemperature, specifiedAnionColumnFlushSuppressorMode, specifiedAnionColumnFlushSuppressorVoltage, specifiedAnionColumnFlushSuppressorCurrent, specifiedAnionColumnFlushDetectionTemperature}
				}
			]
		];

		(* == Error Checking == *)
		(* Don't need this test any more - if any options are missing, SampleOptionConflict should take care of it
        (* 44.1 If AnionColumn is specified or resolved, and column refresh frequency is specified/resolved, we need to have a gradient method *)

        (* If anion column refresh frequency is not Null, None or Last AND if anion column is resolved, then we must have a column prime gradient specified *)
        (* If column prime is specified in InjectionTable, the gradient option there cannot be Null and will be automatically resolved *)
        (* While the column refresh frequency will be set to Null and therefore, this error tracking variable will be False and will not eventually throw error *)
        missingAnionColumnPrimeGradientQ=If[!MatchQ[resolvedAnionColumn,{}|Null|{Null}]&&!MatchQ[resolvedAnionColumnRefreshFrequency,Null|None|Last],
            MatchQ[resolvedAnionColumnPrimeGradient,Null|{}|{Null}],
            False
        ];

        (* If there are any missing anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
        missingAnionColumnPrimeGradientOptions=If[missingAnionColumnPrimeGradientQ&&messagesQ,
            (
                Message[Error::MissingAnionRefreshGradientOptions,ObjectToString[resolvedAnionColumn,Cache -> fullCache, Simulation -> updatedSimulation],AnionColumnPrimeGradient,AnionColumnRefreshFrequency,resolvedAnionColumnRefreshFrequency];
                {AnionColumnRefreshFrequency,AnionColumnPrimeGradient}
            ),
            {}
        ];

        (* Generate test for missing anion gradient options *)
        missingAnionColumnPrimeGradientTests=testOrNull["If AnionColumn is specified and AnionColumnRefreshFrequency is not Null, None or Last, anion column prime gradient options are either specified in the option or the InjectionTable:",Not[missingAnionColumnPrimeGradientQ]];

        (* 44.2 If AnionColumn is specified or resolved, and column refresh frequency is specified/resolved, we need to have a gradient method *)

        (* If anion column refresh frequency is not Null, None or First AND if anion column is resolved, then we must have a column flush gradient specified *)
        (* If column flush is specified in InjectionTable, the gradient option there cannot be Null and will be automatically resolved *)
        (* While the column refresh frequency will be set to Null and therefore, this error tracking variable will be False and will not eventually throw error *)
        missingAnionColumnFlushGradientQ=If[!MatchQ[resolvedAnionColumn,{}|Null|{Null}]&&!MatchQ[resolvedAnionColumnRefreshFrequency,Null|None|First],
            MatchQ[resolvedAnionColumnFlushGradient,Null|{}|{Null}],
            False
        ];

        (* If there are any missing anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
        missingAnionColumnFlushGradientOptions=If[missingAnionColumnFlushGradientQ&&messagesQ,
            (
                Message[Error::MissingAnionRefreshGradientOptions,ObjectToString[resolvedAnionColumn,Cache -> fullCache, Simulation -> updatedSimulation],AnionColumnFlushGradient,AnionColumnRefreshFrequency,resolvedAnionColumnRefreshFrequency];
                {AnionColumnRefreshFrequency,AnionColumnFlushGradient}
            ),
            {}
        ];

        (* Generate test for missing anion gradient options *)
        missingAnionColumnFlushGradientTests=testOrNull["If AnionColumn is specified and AnionColumnRefreshFrequency is not Null, None or First, anion column flush gradient options are either specified in the option or the InjectionTable:",Not[missingAnionColumnFlushGradientQ]]; *)


		(* 44.3 If AnionColumnPrimeGradient is specified simultaenously in the option and the InjectionTable as method object, they should be consistent with each other *)
		(* If there are any missing anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
		inconsistentAnionColumnPrimeGradientOptions = If[anionColumnPrimeGradientConsistentErrors && messagesQ,
			(
				Message[Error::InconsistentRefreshGradientSpecification, "anion column prime"];
				{AnionColumnPrimeGradient, AnionInjectionTable}
			),
			{}
		];

		(* Generate test for missing specification among anion gradient start, end and duration *)
		inconsistentAnionColumnPrimeGradientTests = testOrNull["If specified, gradient methods in the AnionColumnPrimeGradient option and the AnionInjectionTable must be consistent:", Not[anionColumnPrimeGradientConsistentErrors]];

		(* 44.4 If AnionColumnFlushGradient is specified simultaenously in the option and the InjectionTable as method object, they should be consistent with each other *)
		(* If there are any missing anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
		inconsistentAnionColumnFlushGradientOptions = If[anionColumnFlushGradientConsistentErrors && messagesQ,
			(
				Message[Error::InconsistentRefreshGradientSpecification, "anion column flush"];
				{AnionColumnFlushGradient, AnionInjectionTable}
			),
			{}
		];

		(* Generate test for missing specification among anion gradient start, end and duration *)
		inconsistentAnionColumnFlushGradientTests = testOrNull["If specified, gradient methods in the AnionColumnFlushGradient option and the AnionInjectionTable must be consistent:", Not[anionColumnFlushGradientConsistentErrors]];

		(* 44.5 If either ColumnPrimeEluentGradient or AnionColumnPrimeGradient is specified, the maximum concentration is within the range defined by the integrated eluent generator *)
		(* If there are any invalid anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
		invalidAnionColumnPrimeGradientCompositionOptions = If[invalidAnionColumnPrimeGradientCompositionErrors && messagesQ,
			(
				Message[Error::InvalidAnionRefreshGradientComposition, "anion column prime", maxEluentConcentration];
				{ColumnPrimeEluentGradient, AnionColumnPrimeGradient}
			),
			{}
		];

		(* Generate test for invalid anion gradient composition *)
		invalidAnionColumnPrimeGradientCompositionTests = testOrNull["The specified AnionColumnPrimeGradient has maximum eluent concentrations less than the max concentration allowed by the eluent generator:", Not[invalidAnionColumnPrimeGradientCompositionErrors]];

		(* 44.6 If either ColumnFlushEluentGradient or AnionColumnFlushGradient is specified, the maximum concentration is within the range defined by the integrated eluent generator *)
		(* If there are any invalid anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
		invalidAnionColumnFlushGradientCompositionOptions = If[invalidAnionColumnFlushGradientCompositionErrors && messagesQ,
			(
				Message[Error::InvalidAnionRefreshGradientComposition, "anion column flush", maxEluentConcentration];
				{ColumnFlushEluentGradient, AnionColumnFlushGradient}
			),
			{}
		];

		(* Generate test for invalid anion gradient composition *)
		invalidAnionColumnFlushGradientCompositionTests = testOrNull["The specified AnionColumnFlushGradient has maximum eluent concentrations less than the max concentration allowed by the eluent generator:", Not[invalidAnionColumnFlushGradientCompositionErrors]];

		(* Don't need these error checks any more
        (* 44.7 Check whether the resolved anion column prime temperature is within the acceptable temperature range *)
        (* If there are any incompatible column temperatures and we are throwing messages, throw an error and collect in valid option *)
        incompatibleAnionColumnPrimeTemperatureOptions=If[incompatibleAnionColumnPrimeTemperatureErrors&&messagesQ,
            (
                Message[Error::IncompatibleRefreshColumnTemperature,AnionColumn,"anion column prime",allowedAnionColumnTemperatureRange[[1]],allowedAnionColumnTemperatureRange[[2]]];
                {AnionColumnPrimeTemperature}
            ),
            {}
        ];

        (* Generate tests for incompatible cation column temperature *)
        incompatibleAnionColumnPrimeTemperatureTests=testOrNull["Specified AnionColumnPrimeTemperature is within the range of supported temperature of the AnionColumn:",Not[incompatibleAnionColumnPrimeTemperatureErrors]];

        (* 44.8 Check whether the resolved anion column flush temperature is within the acceptable temperature range *)
        (* If there are any incompatible column temperatures and we are throwing messages, throw an error and collect in valid option *)
        incompatibleAnionColumnFlushTemperatureOptions=If[incompatibleAnionColumnFlushTemperatureErrors&&messagesQ,
            (
                Message[Error::IncompatibleRefreshColumnTemperature,AnionColumn,"anion column flush",allowedAnionColumnTemperatureRange[[1]],allowedAnionColumnTemperatureRange[[2]]];
                {AnionColumnFlushTemperature}
            ),
            {}
        ];

        (* Generate tests for incompatible cation column temperature *)
        incompatibleAnionColumnFlushTemperatureTests=testOrNull["Specified AnionColumnFlushTemperature is within the range of supported temperature of the AnionColumn:",Not[incompatibleAnionColumnFlushTemperatureErrors]];

        (* 44.9 Suppressor current error check *)
        (* Throw error message and collect invalid option *)
        invalidAnionColumnPrimeSuppressorCurrentOptions=If[incompatibleAnionColumnPrimeSuppressorCurrentErrors&&messagesQ,
            (
                Message[Error::IncompatibleColumnRefreshSuppressorCurrent,"anion column prime",0 Milliampere,maxAnionSuppressorCurrent];
                {AnionColumnPrimeSuppressorCurrent}
            ),
            {}
        ];

        (* Generate test for invalid max acceleration *)
        anionColumnPrimeSuppressorCurrentTests=testOrNull["AnionColumnPrimeSuppressorCurrent is less than the maximum suppressor current supported by the instrument:",Not[incompatibleAnionColumnPrimeSuppressorCurrentErrors]];

        (* 44.10 Suppressor current error check *)
        (* Throw error message and collect invalid option *)
        invalidAnionColumnFlushSuppressorCurrentOptions=If[incompatibleAnionColumnFlushSuppressorCurrentErrors&&messagesQ,
            (
                Message[Error::IncompatibleColumnRefreshSuppressorCurrent,"anion column flush",0 Milliampere,maxAnionSuppressorCurrent];
                {AnionColumnFlushSuppressorCurrent}
            ),
            {}
        ];

        (* Generate test for invalid max acceleration *)
        anionColumnFlushSuppressorCurrentTests=testOrNull["AnionColumnFlushSuppressorCurrent is less than the maximum suppressor current supported by the instrument:",Not[incompatibleAnionColumnFlushSuppressorCurrentErrors]];

        (* 44.11 Detection Temperature error check *)
        (* Throw error message and collect invalid option *)
        invalidAnionColumnPrimeDetectionTemperatureOptions=If[incompatibleAnionColumnPrimeDetectionTemperatureErrors&&messagesQ,
            (
                Message[Error::IncompatibleColumnRefreshDetectionTemperature,"anion column prime",minAnionDetectionTemperature,maxAnionDetectionTemperature];
                {AnionColumnPrimeDetectionTemperature}
            ),
            {}
        ];

        (* Generate test for invalid max acceleration *)
        anionColumnPrimeDetectionTemperatureTests=testOrNull["AnionColumnPrimeDetectionTemperature is within the range of detection temperatures set by the instrument:",Not[incompatibleAnionColumnPrimeDetectionTemperatureErrors]];

        (* 44.12 Detection Temperature error check *)
        (* Throw error message and collect invalid option *)
        invalidAnionColumnFlushDetectionTemperatureOptions=If[incompatibleAnionColumnFlushDetectionTemperatureErrors&&messagesQ,
            (
                Message[Error::IncompatibleColumnRefreshDetectionTemperature,"anion column flush",minAnionDetectionTemperature,maxAnionDetectionTemperature];
                {AnionColumnFlushDetectionTemperature}
            ),
            {}
        ];

        (* Generate test for invalid max acceleration *)
        anionColumnFlushDetectionTemperatureTests=testOrNull["AnionColumnFlushDetectionTemperature is within the range of detection temperatures set by the instrument:",Not[incompatibleAnionColumnFlushDetectionTemperatureErrors]]; *)

		(* 44.13 Suppressor mode error check *)
		(* Throw error message and collect invalid option *)
		conflictingAnionColumnPrimeSuppressorModeOptions = If[conflictingAnionColumnPrimeSuppressorModeErrors && messagesQ,
			(
				Message[Error::ConflictingColumnRefreshSuppressorMode, "anion column prime", AnionColumnPrimeSuppressorMode, AnionColumnPrimeSuppressorVoltage, AnionColumnPrimeSuppressorCurrent];
				{AnionColumnPrimeSuppressorMode, AnionColumnPrimeSuppressorVoltage, AnionColumnPrimeSuppressorCurrent}
			),
			{}
		];

		(* Generate test for conflicting suppressor mode *)
		anionColumnPrimeSuppressorModeTests = testOrNull["AnionColumnPrimeSuppressorVoltage and AnionColumnPrimeSuppressorCurrent are set if AnionColumnPrimeSuppressorMode is set to DynamicMode and LegacyMode respectively:", Not[conflictingAnionColumnPrimeSuppressorModeErrors]];

		(* 44.14 Suppressor mode error check *)
		(* Throw error message and collect invalid option *)
		conflictingAnionColumnFlushSuppressorModeOptions = If[conflictingAnionColumnFlushSuppressorModeErrors && messagesQ,
			(
				Message[Error::ConflictingColumnRefreshSuppressorMode, "anion column flush", AnionColumnFlushSuppressorMode, AnionColumnFlushSuppressorVoltage, AnionColumnFlushSuppressorCurrent];
				{AnionColumnFlushSuppressorMode, AnionColumnFlushSuppressorVoltage, AnionColumnFlushSuppressorCurrent}
			),
			{}
		];

		(* Generate test for conflicting suppressor mode *)
		anionColumnFlushSuppressorModeTests = testOrNull["AnionColumnFlushSuppressorVoltage and AnionColumnFlushSuppressorCurrent are set if AnionColumnFlushSuppressorMode is set to DynamicMode and LegacyMode respectively:", Not[conflictingAnionColumnFlushSuppressorModeErrors]];

		(* Don't need those checks anymore
        (* 44.15 Suppressor voltage error check *)
        (* Throw error message and collect invalid option *)
        invalidAnionColumnPrimeSuppressorVoltageOptions=If[incompatibleAnionColumnPrimeSuppressorVoltageErrors&&messagesQ,
            (
                Message[Error::IncompatibleColumnRefreshSuppressorVoltage,resolvedAnionColumnPrimeSuppressorVoltage,"anion column prime",maxAnionSuppressorVoltage/.Null->Infinity Volt];
                {AnionColumnPrimeSuppressorVoltage}
            ),
            {}
        ];

        (* Generate test for invalid max acceleration *)
        anionColumnPrimeSuppressorVoltageTests=testOrNull["AnionColumnPrimeSuppressorVoltage is less than the maximum suppressor voltage supported by the instrument:",Not[incompatibleAnionColumnPrimeSuppressorVoltageErrors]];

        (* 44.16 Suppressor voltage error check *)
        (* Throw error message and collect invalid option *)
        invalidAnionColumnFlushSuppressorVoltageOptions=If[incompatibleAnionColumnFlushSuppressorVoltageErrors&&messagesQ,
            (
                Message[Error::IncompatibleColumnRefreshSuppressorVoltage,resolvedAnionColumnFlushSuppressorVoltage,"anion column flush",maxAnionSuppressorVoltage/.Null->Infinity Volt];
                {AnionColumnFlushSuppressorVoltage}
            ),
            {}
        ];

        (* Generate test for invalid max acceleration *)
        anionColumnFlushSuppressorVoltageTests=testOrNull["AnionColumnFlushSuppressorVoltage is less than the maximum suppressor voltage supported by the instrument:",Not[incompatibleAnionColumnFlushSuppressorVoltageErrors]];

        (* 44.17 AnionColumnPrimeFlowRate has to be within the range supported by the instrument, and the column *)
        (* If there are any invalid anion flow rates and we are throwing messages, then throw an error message and collect invalid options *)
        incompatibleAnionColumnPrimeFlowRateOptions=If[MemberQ[ToList@anionColumnPrimeFlowRateErrors,True]&&messagesQ,
            (
                Message[Error::IncompatibleColumnRefreshFlowRate,AnionColumnPrimeFlowRate,resolvedAnionColumnPrimeFlowRate,resolvedInstrument,resolvedAnionColumn,maxAnionFlowRate];
                {AnionColumnPrimeFlowRate}
            ),
            {}
        ];

        (* Generate test for invalid anion gradient composition *)
        invalidAnionColumnPrimeFlowRateTests=testOrNull["The specified AnionColumnPrimeFlowRate has maximum flow rate less than that supported by the instrument and the column:",Not[anionColumnPrimeFlowRateErrors]];

        (* 44.17 AnionColumnPrimeFlowRate has to be within the range supported by the instrument, and the column *)
        (* If there are any invalid anion flow rates and we are throwing messages, then throw an error message and collect invalid options *)
        incompatibleAnionColumnFlushFlowRateOptions=If[MemberQ[ToList@anionColumnFlushFlowRateErrors,True]&&messagesQ,
            (
                Message[Error::IncompatibleColumnRefreshFlowRate,AnionColumnFlushFlowRate,resolvedAnionColumnFlushFlowRate,resolvedInstrument,resolvedAnionColumn,maxAnionFlowRate];
                {AnionColumnFlushFlowRate}
            ),
            {}
        ];

        (* Generate test for invalid anion gradient composition *)
        invalidAnionColumnFlushFlowRateTests=testOrNull["The specified AnionColumnFlushFlowRate has maximum flow rate less than that supported by the instrument and the column:",Not[anionColumnFlushFlowRateErrors]]; *)

		(* 44.18 AnionColumnPrimeStart, AnionColumnPrimeEnd, and AnionColumnPrimeDuration has to be specified or Nulled out together *)

		(* If there are any missing gradient and we are throwing messages, then throw an error message and collect invalid options *)
		notSpecifiedAnionColumnPrimeGradientStartEndOptions = If[MemberQ[ToList@anionColumnPrimeStartEndSpecifiedErrors, True] && messagesQ,
			(
				Message[Error::HPICGradientStartEndConflict, {AnionColumnPrimeStart, AnionColumnPrimeEnd}, "anion column prime"];
				{AnionColumnPrimeStart, AnionColumnPrimeEnd}
			),
			{}
		];

		(* Generate test for missing specification among anion gradient start, end and duration *)
		notSpecifiedAnionColumnPrimeGradientStartEndTests = testOrNull["AnionColumnPrimeStart and AnionColumnPrimeEnd should be specified or set to Null simultaneously:", Not[anionColumnPrimeStartEndSpecifiedErrors]];

		(* 44.18 AnionColumnFlushStart, AnionColumnFlushEnd, and AnionColumnFlushDuration has to be specified or Nulled out together *)
		notSpecifiedAnionColumnFlushGradientStartEndOptions = If[MemberQ[ToList@anionColumnFlushStartEndSpecifiedErrors, True] && messagesQ,
			(
				Message[Error::HPICGradientStartEndConflict, {AnionColumnFlushStart, AnionColumnFlushEnd, AnionColumnFlushDuration}, "anion column flush"];
				{AnionColumnFlushStart, AnionColumnFlushEnd, AnionColumnFlushDuration}
			),
			{}
		];

		(* Generate test for missing specification among anion gradient start, end and duration *)
		notSpecifiedAnionColumnFlushGradientStartEndTests = testOrNull["AnionColumnFlushStart, AnionColumnFlushEnd, and AnionColumnFlushDuration should be specified or set to Null simultaneously:", Not[anionColumnFlushStartEndSpecifiedErrors]];

		(* 44.19 If gradient duration is specified, either gradient start & end or eluent gradient is specified *)
		(* If there are any missing anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
		notSpecifiedAnionColumnPrimeGradientDurationOptions = If[MemberQ[ToList@anionColumnPrimeDurationOptionSpecifiedErrors, True] && messagesQ,
			(
				Message[Error::HPICGradientShortcutConflict, AnionColumnPrimeDuration, {AnionColumnPrimeStart, AnionColumnPrimeEnd}, "ColumnPrimeEluentGradient"];
				{AnionColumnPrimeStart, AnionColumnPrimeEnd, AnionColumnPrimeDuration, ColumnPrimeEluentGradient}
			),
			{}
		];

		(* Generate test for missing specification among anion gradient start, end and duration *)
		notSpecifiedAnionColumnPrimeGradientDurationTests = testOrNull["AnionColumnPrimeDuration should be specified either with AnionColumnPrimeStart/AnionColumnPrimeEnd or with ColumnPrimeEluentGradient:", Not[anionColumnPrimeDurationOptionSpecifiedErrors]];

		(* 44.20 If gradient duration and eluent gradient are both specified, their specified values are consistent *)
		(* If there are any missing anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
		inconsistentAnionColumnPrimeGradientDurationOptions = If[MemberQ[ToList@anionColumnPrimeDurationConsistentErrors, True] && messagesQ && notInEngine,
			(
				Message[Warning::HPICGradientShortcutAmbiguity, AnionColumnPrimeDuration, ColumnPrimeEluentGradient];
				{}
			),
			{}
		];

		(* Generate test for missing specification among anion gradient start, end and duration *)
		consistentAnionColumnPrimeGradientDurationTests = warningOrNull["Specified values for AnionColumnPrimeDuration and ColumnPrimeEluentGradient are consistent:", Not[anionColumnPrimeDurationConsistentErrors]];

		(* 44.21 If gradient duration is specified, either gradient start & end or eluent gradient is specified *)
		(* If there are any missing anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
		notSpecifiedAnionColumnFlushGradientDurationOptions = If[MemberQ[ToList@anionColumnFlushDurationOptionSpecifiedErrors, True] && messagesQ,
			(
				Message[Error::HPICGradientShortcutConflict, AnionColumnFlushDuration, {AnionColumnFlushStart, AnionColumnFlushEnd}, "ColumnFlushEluentGradient"];
				{AnionColumnFlushStart, AnionColumnFlushEnd, AnionColumnFlushDuration, ColumnFlushEluentGradient}
			),
			{}
		];

		(* Generate test for missing specification among anion gradient start, end and duration *)
		notSpecifiedAnionColumnFlushGradientDurationTests = testOrNull["AnionColumnFlushDuration should be specified either with AnionColumnFlushStart/AnionColumnFlushEnd or with ColumnFlushEluentGradient:", Not[anionColumnFlushDurationOptionSpecifiedErrors]];

		(* 44.22 If gradient duration and eluent gradient are both specified, their specified values are consistent *)
		(* If there are any missing anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
		inconsistentAnionColumnFlushGradientDurationOptions = If[MemberQ[ToList@anionColumnFlushDurationConsistentErrors, True] && messagesQ && notInEngine,
			(
				Message[Warning::HPICGradientShortcutAmbiguity, AnionColumnFlushDuration, ColumnFlushEluentGradient];
				{}
			),
			{}
		];

		(* Generate test for missing specification among anion gradient start, end and duration *)
		consistentAnionColumnFlushGradientDurationTests = warningOrNull["Specified values for AnionColumnFlushDuration and ColumnFlushEluentGradient are consistent:", Not[anionColumnFlushDurationConsistentErrors]];

		(* 45. CationBlank related option resolution: CationBlankGradientDuration, CationBlankFlowRate, BlankGradientA, BlankGradientB, CationBlankGradient *)
		{
			{
				resolvedCationColumnPrimeTemperature,
				resolvedCationColumnPrimeGradient,
				resolvedCationColumnPrimeGradientA,
				resolvedCationColumnPrimeGradientB,
				resolvedCationColumnPrimeGradientC,
				resolvedCationColumnPrimeGradientD,
				resolvedCationColumnPrimeFlowRate,
				resolvedCationColumnPrimeStart,
				resolvedCationColumnPrimeEnd,
				resolvedCationColumnPrimeDuration,
				resolvedCationColumnPrimeSuppressorMode,
				resolvedCationColumnPrimeSuppressorVoltage,
				resolvedCationColumnPrimeSuppressorCurrent,
				resolvedCationColumnPrimeDetectionTemperature,
				cationColumnPrimeGradientConsistentErrors,
				cationColumnPrimeStartEndSpecifiedErrors,
				cationColumnPrimeDurationOptionSpecifiedErrors,
				invalidCationColumnPrimeGradientCompositionErrors,
				cationColumnPrimeRemovedExtraErrors,
				cationColumnPrimeFlowRateErrors,
				conflictingCationColumnPrimeSuppressorModeErrors,
				cationColumnPrimeDurationConsistentErrors,
				overwriteCationColumnPrimeGradientBool
			},
			{
				resolvedCationColumnFlushTemperature,
				resolvedCationColumnFlushGradient,
				resolvedCationColumnFlushGradientA,
				resolvedCationColumnFlushGradientB,
				resolvedCationColumnFlushGradientC,
				resolvedCationColumnFlushGradientD,
				resolvedCationColumnFlushFlowRate,
				resolvedCationColumnFlushStart,
				resolvedCationColumnFlushEnd,
				resolvedCationColumnFlushDuration,
				resolvedCationColumnFlushSuppressorMode,
				resolvedCationColumnFlushSuppressorVoltage,
				resolvedCationColumnFlushSuppressorCurrent,
				resolvedCationColumnFlushDetectionTemperature,
				cationColumnFlushGradientConsistentErrors,
				cationColumnFlushStartEndSpecifiedErrors,
				cationColumnFlushDurationOptionSpecifiedErrors,
				invalidCationColumnFlushGradientCompositionErrors,
				cationColumnFlushRemovedExtraErrors,
				cationColumnFlushFlowRateErrors,
				conflictingCationColumnFlushSuppressorModeErrors,
				cationColumnFlushDurationConsistentErrors,
				overwriteCationColumnFlushGradientBool
			}
		} = Module[{
			specifiedRefreshfrequency, frequency, gradienta, gradientb, gradientc, gradientd, gradient, flowrate, duration, cleaningType, defaultGradient, columnTemperature, suppressorCurrent, detectionTemperature,
			cationInjectionTableRoundedGradient, cationGradientConsistentQ, cationRemovedExtrasQ, protoCationGradientOptionTuple, cationGradientOptionTuple, defaultedCationFlowRate,
			cationGradientReturned, initiallyResolvedCationGradient, invalidCationGradientCompositionQ, gradientA, gradientB, gradientC, gradientD, cationFlowRate, cationGradient,
			cationColumnTemperature, cationSuppressorCurrent, cationDetectionTemperature, overwriteCationCleaningGradientQ, suppressorMode, suppressorVoltage, cationSuppressorMode, maxFlowRate, cationGradientTuples,
			maxBufferConc, defaultMinCationSuppressorCurrent, cationSuppressorVoltage, cationSuppressorModeConflictQ, allBufferPercent, totalBufferConcentration, incompatibleCationFlowRateQ,
			gradientStartEndSpecifiedQ, start, end, gradientStart, gradientEnd, cationDurationOptionsSpecifiedQ, cationDurationConsistentQ, individualGradientSpecifiedQ},

			Map[Function[{entryVariables},

				{specifiedRefreshfrequency, frequency, gradienta, gradientb, gradientc, gradientd, gradient, flowrate, start, end, duration, cleaningType, defaultGradient, columnTemperature, suppressorMode, suppressorVoltage, suppressorCurrent, detectionTemperature} = entryVariables;

				If[
					Or[
						MatchQ[resolvedCationColumn, {} | Null | {Null}],
						And[
							MatchQ[specifiedRefreshfrequency, frequency],
							Length[Cases[cationInjectionTableLookupRounded, {cleaningType, ___}]] == 0
						]
					],
					(* If specified refresh frequency is set to Null or None, and one of the gradient options is set to Null, then set all cation column prime/flush related options to Null and error tracking variables to False *)
					Join[ConstantArray[Null, 14], ConstantArray[False, 9]],

					(* Setup: We first get the injection table gradients *)
					cationInjectionTableRoundedGradient = If[MatchQ[cationInjectionTableLookupRounded, Except[Automatic]],

						(* Extract the gradient specified in InjectionTable *)
						FirstCase[cationInjectionTableLookupRounded, {cleaningType, _, gradient_} :> gradient],

						(* If InjectionTable is not specified, pad it with Automatics*)
						Automatic
					];

					(* First we need to make sure that the start end and duration options are either all specified or not *)
					gradientStartEndSpecifiedQ = !MatchQ[{start, end}, {PercentP, PercentP} | {Automatic | Null, Automatic | Null}];

					(* Then we need to make sure that the duration is specified either with start & end, or with eluent gradient *)
					cationDurationOptionsSpecifiedQ = If[MatchQ[duration, TimeP],
						Not[MatchQ[{start, end}, {PercentP, PercentP}] || MatchQ[gradienta, PercentP] || MatchQ[gradientb, PercentP] || MatchQ[gradientc, PercentP] || MatchQ[gradientd, PercentP]],
						False
					];

					(* Need to check if any of the individual gradient is specified in {Time,Percent} format *)
					individualGradientSpecifiedQ = Or[
						MatchQ[gradienta, Except[Automatic | PercentP]],
						MatchQ[gradientb, Except[Automatic | PercentP]],
						MatchQ[gradientc, Except[Automatic | PercentP]],
						MatchQ[gradientd, Except[Automatic | PercentP]]
					];

					(* We also need to check if Duration specification is consistent with individual gradient *)
					cationDurationConsistentQ = If[individualGradientSpecifiedQ,

						If[MatchQ[duration, TimeP],
							True,
							False
						],
						(* If none of the individual gradient is specified, then leave this error tracking variable to False *)
						False
					];

					(* If gradient is specied as a method object, check whether CationGradient and the injection table specify the same object*)
					cationGradientConsistentQ = If[MatchQ[gradient, ObjectP[Object[Method, IonChromatographyGradient]]] && MatchQ[cationInjectionTableRoundedGradient, {ObjectP[Object[Method, IonChromatographyGradient]]}],
						Not[MatchQ[ToList@Download[gradient, Object], Download[cationInjectionTableRoundedGradient, Object]]],
						False
					];

					(* Extract or default GradientStart and GradientEnd values *)
					{gradientStart, gradientEnd} = Switch[{start, end, duration},

						(* If valid cationGradientStart and cationGradientEnd are given, go with that *)
						{PercentP, PercentP, _} | {Null, Null, Null | TimeP}, {start, end},

						(* Default to cationGradientStart if something is wrong with gradientEnd *)
						{PercentP, _, _}, {start, start},

						(* Default to 0 Percent if something is wrong with cationGradeintStart *)
						{_, PercentP, _}, {0 Percent, end},

						(* Otherwise, both Null*)
						_, {Null, Null}
					];

					(* If Gradient option is an object, pull Gradient value from packet *)
					protoCationGradientOptionTuple = Which[

						(* If CationGradient specifies a method object, extract Gradient information from the packet *)
						MatchQ[gradient, ObjectP[Object[Method, IonChromatographyGradient]]],
						Lookup[fetchPacketFromCache[Download[gradient, Object], fullCache], CationGradient],

						(* If InjectionTable specifies a method object, extract Gradient information from the packet *)
						MatchQ[gradient, Automatic] && MatchQ[cationInjectionTableRoundedGradient, ObjectP[Object[Method, IonChromatographyGradient]]],
						Lookup[fetchPacketFromCache[Download[cationInjectionTableRoundedGradient, Object], fullCache], CationGradient],

						(* Otherwise, namely if anionGradient is not a method object, then use what's specified in AnionGradient *)
						True, gradient
					];

					(* Update CationFlowRate in the gradient method object if the option is specified *)
					cationGradientOptionTuple = If[MatchQ[flowrate, Except[Automatic]],

						(* If CationFlowRate is specified, use the specified flow rate and replace the default flowrate of the method object *)
						(* In IonChromatography Gradient method, CationGradient goes "Time", "BufferA Composition", "BufferB Composition", "FlowRate". FlowRate is in the third column *)
						ReplacePart[protoCationGradientOptionTuple, Table[{x, 4} -> flowrate, {x, 1, Length[protoCationGradientOptionTuple]}]],

						(* Otherwise, use the default flow rate in the gradient object *)
						protoCationGradientOptionTuple
					];

					(* Default FlowRate to option value, gradient tuple values, or the pre-calculated optimal flow rate for the column *)
					(* note that it's ok to have this flow rate either match FlowRateP, or be a list of pairs of time and flow rate since resolveGradient can handle either *)
					defaultedCationFlowRate = Which[

						(* If the AnionFlowRate is specified, go with the user specified value *)
						MatchQ[flowrate, Except[Automatic]], flowrate,

						(* If the AnionFlowRate is specified as part of the gradient method object, extract the flow rate from the object *)
						MatchQ[cationGradientOptionTuple, {TimeP, PercentP, PercentP, PercentP, PercentP, FlowRateP}], cationGradientOptionTuple[[All, {1, 6}]],

						(* If no flow rate is specified, use the optional flow rate determined for the column *)
						True, optimalColumnFlowRate
					];

					(* Setup error tracking variable for error messages outside this map thread *)
					incompatibleCationFlowRateQ = Not[Between[defaultedCationFlowRate, {minCationFlowRate, maxFlowRate}]];

					(* finally run our helper resolution function *)
					cationGradientReturned = If[MatchQ[{cationGradientOptionTuple, gradienta, gradientb, gradientc, gradientd, start, end, duration, flowrate}, {(Null | Automatic)..}] || gradientStartEndSpecifiedQ || cationDurationOptionsSpecifiedQ,
						resolveICCationGradient[defaultGradient[defaultedCationFlowRate], gradienta, gradientb, gradientc, gradientd, defaultedCationFlowRate, start, end, duration],
						resolveICCationGradient[cationGradientOptionTuple, gradienta, gradientb, gradientc, gradientd, defaultedCationFlowRate, start, end, duration]
					];

					(*remove duplicate entries if need be*)
					initiallyResolvedCationGradient = DeleteDuplicatesBy[cationGradientReturned, First[# * 1.] &];

					(*if it's not the same note that*)
					cationRemovedExtrasQ = !MatchQ[cationGradientReturned, initiallyResolvedCationGradient];

					(*check whether the gradient composition adds up to 100 okay*)
					invalidCationGradientCompositionQ = Not[AllTrue[initiallyResolvedCationGradient, (#[[2]] + #[[3]] + #[[4]] + #[[5]] == 100 Percent)&]];

					(*now resolve all of the individual gradients and flow rate*)
					gradientA = If[MatchQ[gradienta, Automatic],
						collapseGradient[initiallyResolvedCationGradient[[All, {1, 2}]]],
						gradienta
					];

					gradientB = If[MatchQ[gradientb, Automatic],
						collapseGradient[initiallyResolvedCationGradient[[All, {1, 3}]]],
						gradientb
					];

					gradientC = If[MatchQ[gradientc, Automatic],
						collapseGradient[initiallyResolvedCationGradient[[All, {1, 4}]]],
						gradientc
					];

					gradientD = If[MatchQ[gradientd, Automatic],
						collapseGradient[initiallyResolvedCationGradient[[All, {1, 5}]]],
						gradientd
					];

					cationFlowRate = If[MatchQ[flowrate, Automatic],
						collapseGradient[initiallyResolvedCationGradient[[All, {1, -1}]]],
						flowrate
					];

					overwriteCationCleaningGradientQ = If[MatchQ[gradient, ObjectP[Object[Method, IonChromatographyGradient]]],
						!MatchQ[Lookup[fetchPacketFromCache[Download[gradient, Object], fullCache], CationGradient], initiallyResolvedCationGradient],
						False
					];

					(*finally resolve the gradient*)
					cationGradient = Which[
						MatchQ[gradient, ObjectP[Object[Method, IonChromatographyGradient]]] && !overwriteCationCleaningGradientQ, gradient,
						(*otherwise if the gradient is automatic and the injection table is set, should use that*)
						MatchQ[gradient, Automatic] && MatchQ[cationInjectionTableRoundedGradient, ObjectP[Object[Method, IonChromatographyGradient]]], Download[cationInjectionTableRoundedGradient, Object],
						(*otherwise, it should be a tuple*)
						True, initiallyResolvedCationGradient
					];

					(* Download the gradient object from fullCache and extract column temperature information *)
					cationColumnTemperature = Which[

						(* If user has already specified anion column temperature, go with that *)
						!MatchQ[columnTemperature, ListableP[Automatic | Null]],
						columnTemperature,

						(* If the specified AnionGradient is a method object, extract column temperature from there *)
						MatchQ[cationGradient, ObjectP[Object[Method, IonChromatographyGradient]]],
						If[NullQ[Lookup[fetchPacketFromCache[Download[cationGradient, Object], fullCache], CationColumnTemperature]],
							Ambient,
							Lookup[fetchPacketFromCache[Download[cationGradient, Object], fullCache], CationColumnTemperature]
						],

						(* If the specified gradient in the InjectionTable is an Object, extract column temperature from there *)
						MatchQ[cationInjectionTableRoundedGradient, ObjectP[Object[Method, IonChromatographyGradient]]],
						Lookup[fetchPacketFromCache[Download[cationInjectionTableRoundedGradient, Object], fullCache], CationColumnTemperature],

						MatchQ[resolvedCationColumnTemperature, Null | {} | {Null}],
						Ambient,

						MatchQ[resolvedCationColumnTemperature[[1]], Ambient],
						Ambient,

						True,
						resolvedCationColumnTemperature[[1]]
					];

					(* If user specified AnionSuppressorMode, go with that *)
					cationSuppressorMode = Which[

						(* If user specified suppressor mode, then go with that *)
						MatchQ[suppressorMode, Except[Null | Automatic]],
						suppressorMode,

						(* If user does not specify suppressor mode but instead specify suppressor voltage, set suppressorMode to DynamicMode *)
						MatchQ[suppressorVoltage, Except[Null | Automatic]],
						DynamicMode,

						(* Similarly, if user does not specify suppressor mode but instead specify suppressor current, set suppressorMode to LegacyMode *)
						MatchQ[suppressorCurrent, Except[Null | Automatic]],
						LegacyMode,

						(* If nothing is specified, resolve to DynamicMode *)
						True,
						LegacyMode
					];
					cationGradientTuples = If[MatchQ[cationGradient, ObjectP[Object[Method]]],
						(*If our resolved gradient is an object, we need to extract the actual gradient from the correct field*)
						Lookup[fetchPacketFromCache[Download[cationGradient, Object], fullCache], CationGradient],
						(*Otherwise it is already a list of sample and flow rate*)
						cationGradient
					];

					(* Pull out the percent of all 4 buffers from the resolvedGradient *)
					allBufferPercent = If[MatchQ[cationGradient, ObjectP[Object[Method, IonChromatographyGradient]]],
						(Lookup[fetchPacketFromCache[Download[cationGradient, Object], fullCache], CationGradient][[All, 2 ;; 5]]) / (100 Percent),
						cationGradient[[All, 2 ;; 5]] / (100 Percent)
					];
					(* Calculate the total concentration of all 4 buffers *)
					totalBufferConcentration = Map[Times[#, {bufferAConcentration, bufferBConcentration, bufferCConcentration, bufferDConcentration}]&, allBufferPercent];

					(* Preparation to resolve cationSuppressorCurrent *)
					(* cationSuppressorCurrent (mA) = FlowRate (min/mL) x [Eluent] x suppressor specific Factor *)
					maxFlowRate = Convert[Max[cationGradientTuples[[All, -1]]], Milliliter / Minute];
					maxBufferConc = Max[totalBufferConcentration];
					defaultMinCationSuppressorCurrent = SafeRound[Unitless[maxFlowRate * maxBufferConc * cationSuppressorSpecificFactor], 1, Round -> Up] * Milli * Ampere;

					{cationSuppressorVoltage, cationSuppressorCurrent, cationSuppressorModeConflictQ} = Which[

						(* If AnionSuppressorMode option is set to DynamicMode, then we need to resolve AnionSuppressorVoltage and set AnionSuppressorCurrent to Null *)
						MatchQ[cationSuppressorMode, DynamicMode],
						If[
							(* First we need to make sure when AnionSuppressorMode is set to DynamicMode, AnionSuppressorCurrent is not specified *)
							(* If it is specified, set error tracking variable to True so that we can throw error later *)
							MatchQ[suppressorVoltage, Null],
							{Null, Null, True},

							Which[
								(* If AnionSuppressorVoltage is specified, go with that *)
								MatchQ[suppressorVoltage, Except[Automatic]],
								{suppressorVoltage, Null, False},

								(* If not, use the factory recommended value of the suppressor *)
								MatchQ[suppressorVoltage, Automatic],
								{cationSuppressorRecommendedVoltage, Null, False},

								True,
								{cationSuppressorRecommendedVoltage, Null, False}
							]
						],

						(* If AnionSuppressorMode option is set to LegacyMode, then we need to resolve AnionSuppressorCurrent and set AnionSuppressotVoltage to Null *)
						MatchQ[cationSuppressorMode, LegacyMode],
						If[
							(* First we need to make sure when AnionSuppressorMode is set to LegacyModel, AnionSuppressorVoltage is not specified *)
							(* If it is specified, set error tracking variable to True so that we can throw error later *)
							MatchQ[suppressorCurrent, Null],
							{Null, Null, True},

							Which[
								(* If AnionSuppressorCurrent is specified, go with that *)
								MatchQ[suppressorCurrent, Except[Automatic]],
								{Null, suppressorCurrent, False},

								(* If not, use the factory recommended value of the suppressor *)
								MatchQ[suppressorCurrent, Automatic],
								{Null, defaultMinCationSuppressorCurrent, False},

								MatchQ[defaultMinCationSuppressorCurrent, 0 Milliampere],
								{Null, 15 Milliampere, False},

								True,
								{Null, defaultMinCationSuppressorCurrent, False}
							]
						],

						True,
						{Null, Null, False}

					];

					(* If user specified CationDetectionTemperature, go with that *)
					cationDetectionTemperature = If[MatchQ[detectionTemperature, Except[Automatic | Null]],
						detectionTemperature,
						(* Otherwise, use Ambient detection *)
						Which[
							MatchQ[resolvedCationDetectionTemperature, Null | {} | {Null}],
							Ambient,

							MatchQ[resolvedCationDetectionTemperature[[1]], Ambient],
							Ambient,

							Not[Between[resolvedCationDetectionTemperature[[1]], {minCationDetectionTemperature /. Null -> -Infinity Celsius, maxCationDetectionTemperature /. Null -> Infinity Celsius}]],
							Ambient,

							True,
							resolvedCationDetectionTemperature[[1]]
						]
					];

					(*return everything*)
					{
						cationColumnTemperature,
						cationGradient,
						gradientA,
						gradientB,
						gradientC,
						gradientD,
						cationFlowRate,
						gradientStart,
						gradientEnd,
						duration,
						cationSuppressorMode,
						cationSuppressorVoltage,
						cationSuppressorCurrent,
						cationDetectionTemperature,
						cationGradientConsistentQ,
						gradientStartEndSpecifiedQ,
						cationDurationOptionsSpecifiedQ,
						invalidCationGradientCompositionQ,
						cationRemovedExtrasQ,
						incompatibleCationFlowRateQ,
						cationSuppressorModeConflictQ,
						cationDurationConsistentQ,
						overwriteCationCleaningGradientQ
					}
				]
			],
				{
					{resolvedCationColumnRefreshFrequency, Null | None | Last, specifiedCationColumnPrimeGradientA, specifiedCationColumnPrimeGradientB, specifiedCationColumnPrimeGradientC, specifiedCationColumnPrimeGradientD, specifiedCationColumnPrimeGradient, specifiedCationColumnPrimeFlowRate, specifiedCationColumnPrimeStart, specifiedCationColumnPrimeEnd, specifiedCationColumnPrimeDuration, ColumnPrime, defaultCationPrimeGradientIC, specifiedCationColumnPrimeTemperature, specifiedCationColumnPrimeSuppressorMode, specifiedCationColumnPrimeSuppressorVoltage, specifiedCationColumnPrimeSuppressorCurrent, specifiedCationColumnPrimeDetectionTemperature},
					{resolvedCationColumnRefreshFrequency, Except[FirstAndLast | Last], specifiedCationColumnFlushGradientA, specifiedCationColumnFlushGradientB, specifiedCationColumnFlushGradientC, specifiedCationColumnFlushGradientD, specifiedCationColumnFlushGradient, specifiedCationColumnFlushFlowRate, specifiedCationColumnFlushStart, specifiedCationColumnFlushEnd, specifiedCationColumnFlushDuration, ColumnFlush, defaultCationFlushGradientIC, specifiedCationColumnFlushTemperature, specifiedCationColumnFlushSuppressorMode, specifiedCationColumnFlushSuppressorVoltage, specifiedCationColumnFlushSuppressorCurrent, specifiedCationColumnFlushDetectionTemperature}
				}
			]
		];
		(* == Error Checking == *)
		(*
        (* 45.1 If CationColumn is specified or resolved, and column refresh frequency is specified/resolved, we need to have a gradient method *)

        (* If cation column refresh frequency is not Null, None or Last AND if cation column is resolved, then we must have a column prime gradient specified *)
        (* If column prime is specified in InjectionTable, the gradient option there cannot be Null and will be automatically resolved *)
        (* While the column refresh frequency will be set to Null and therefore, this error tracking variable will be False and will not eventually throw error *)
        missingCationColumnPrimeGradientQ=If[!MatchQ[resolvedCationColumn,{}|Null|{Null}]&&!MatchQ[resolvedCationColumnRefreshFrequency,Null|None|Last],
            MatchQ[resolvedCationColumnPrimeGradient,Null|{}|{Null}],
            False
        ];

        (* If there are any missing cation gradient and we are throwing messages, then throw an error message and collect invalid options *)
        missingCationColumnPrimeGradientOptions=If[missingCationColumnPrimeGradientQ&&messagesQ,
            (
                Message[Error::MissingCationRefreshGradientOptions,ObjectToString[resolvedCationColumn,Cache -> fullCache, Simulation -> updatedSimulation],CationColumnPrimeGradient,CationColumnRefreshFrequency,resolvedCationColumnRefreshFrequency];
                {CationColumnRefreshFrequency,CationColumnPrimeGradient}
            ),
            {}
        ];

        (* Generate test for missing cation gradient options *)
        missingCationColumnPrimeGradientTests=testOrNull["If CationColumn is specified and CationColumnRefreshFrequency is not Null, None or Last, cation column prime gradient options are either specified in the option or the InjectionTable:",Not[missingCationColumnPrimeGradientQ]];

        (* 44.2 If CationColumn is specified or resolved, and column refresh frequency is specified/resolved, we need to have a gradient method *)

        (* If cation column refresh frequency is not Null, None or First AND if cation column is resolved, then we must have a column flush gradient specified *)
        (* If column flush is specified in InjectionTable, the gradient option there cannot be Null and will be automatically resolved *)
        (* While the column refresh frequency will be set to Null and therefore, this error tracking variable will be False and will not eventually throw error *)
        missingCationColumnFlushGradientQ=If[!MatchQ[resolvedCationColumn,{}|Null|{Null}]&&!MatchQ[resolvedCationColumnRefreshFrequency,Null|None|First],
            MatchQ[resolvedCationColumnFlushGradient,Null|{}|{Null}],
            False
        ];

        (* If there are any missing cation gradient and we are throwing messages, then throw an error message and collect invalid options *)
        missingCationColumnFlushGradientOptions=If[missingCationColumnFlushGradientQ&&messagesQ,
            (
                Message[Error::MissingCationRefreshGradientOptions,ObjectToString[resolvedCationColumn,Cache -> fullCache, Simulation -> updatedSimulation],CationColumnFlushGradient,CationColumnRefreshFrequency,resolvedCationColumnRefreshFrequency];
                {CationColumnRefreshFrequency,CationColumnFlushGradient}
            ),
            {}
        ];

        (* Generate test for missing cation gradient options *)
        missingCationColumnFlushGradientTests=testOrNull["If CationColumn is specified and CationColumnRefreshFrequency is not Null, None or First, cation column flush gradient options are either specified in the option or the InjectionTable:",Not[missingCationColumnFlushGradientQ]]; *)


		(* 44.3 If CationColumnPrimeGradient is specified simultaenously in the option and the InjectionTable as method object, they should be consistent with each other *)
		(* If there are any missing cation gradient and we are throwing messages, then throw an error message and collect invalid options *)
		inconsistentCationColumnPrimeGradientOptions = If[cationColumnPrimeGradientConsistentErrors && messagesQ,
			(
				Message[Error::InconsistentRefreshGradientSpecification, "cation column prime"];
				{CationColumnPrimeGradient, CationInjectionTable}
			),
			{}
		];

		(* Generate test for missing specification among cation gradient start, end and duration *)
		inconsistentCationColumnPrimeGradientTests = testOrNull["If specified, gradient methods in the CationColumnPrimeGradient option and the CationInjectionTable must be consistent:", Not[cationColumnPrimeGradientConsistentErrors]];

		(* 44.4 If CationColumnFlushGradient is specified simultaenously in the option and the InjectionTable as method object, they should be consistent with each other *)
		(* If there are any missing cation gradient and we are throwing messages, then throw an error message and collect invalid options *)
		inconsistentCationColumnFlushGradientOptions = If[cationColumnFlushGradientConsistentErrors && messagesQ,
			(
				Message[Error::InconsistentRefreshGradientSpecification, "cation column flush"];
				{CationColumnFlushGradient, CationInjectionTable}
			),
			{}
		];

		(* Generate test for missing specification among cation gradient start, end and duration *)
		inconsistentCationColumnFlushGradientTests = testOrNull["If specified, gradient methods in the CationColumnFlushGradient option and the CationInjectionTable must be consistent:", Not[cationColumnFlushGradientConsistentErrors]];

		(* 44.5 If either ColumnPrimeEluentGradient or CationColumnPrimeGradient is specified, the maximum concentration is within the range defined by the integrated eluent generator *)
		(* If there are any invalid cation gradient and we are throwing messages, then throw an error message and collect invalid options *)
		invalidCationColumnPrimeGradientCompositionOptions = If[invalidCationColumnPrimeGradientCompositionErrors && messagesQ,
			(
				Message[Error::InvalidRefreshGradientComposition, "cation column prime"];
				{CationColumnPrimeGradientA, CationColumnPrimeGradientB, CationCationColumnPrimeGradient}
			),
			{}
		];

		(* Generate test for invalid cation gradient composition *)
		invalidCationColumnPrimeGradientCompositionTests = testOrNull["The specified CationColumnPrimeGradient has maximum eluent concentrations less than the max concentration allowed by the eluent generator:", Not[invalidCationColumnPrimeGradientCompositionErrors]];

		(* 44.6 If either ColumnFlushEluentGradient or CationColumnFlushGradient is specified, the maximum concentration is within the range defined by the integrated eluent generator *)
		(* If there are any invalid cation gradient and we are throwing messages, then throw an error message and collect invalid options *)
		invalidCationColumnFlushGradientCompositionOptions = If[invalidCationColumnFlushGradientCompositionErrors && messagesQ,
			(
				Message[Error::InvalidRefreshGradientComposition, "cation column flush"];
				{CationColumnFlushGradientA, CationColumnFlushGradientB, CationColumnFlushGradient}
			),
			{}
		];

		(* Generate test for invalid cation gradient composition *)
		invalidCationColumnFlushGradientCompositionTests = testOrNull["The specified CationColumnFlushGradient has maximum eluent concentrations less than the max concentration allowed by the eluent generator:", Not[invalidCationColumnFlushGradientCompositionErrors]];

		(* Don't need these checks anymore
        (* 44.7 Check whether the resolved cation column prime temperature is within the acceptable temperature range *)
        (* If there are any incompatible column temperatures and we are throwing messages, throw an error and collect in valid option *)
        incompatibleCationColumnPrimeTemperatureOptions=If[incompatibleCationColumnPrimeTemperatureErrors&&messagesQ,
            (
                Message[Error::IncompatibleRefreshColumnTemperature,CationColumn,"cation column prime",allowedCationColumnTemperatureRange[[1]],allowedCationColumnTemperatureRange[[2]]];
                {CationColumnPrimeTemperature}
            ),
            {}
        ];

        (* Generate tests for incompatible cation column temperature *)
        incompatibleCationColumnPrimeTemperatureTests=testOrNull["Specified CationColumnPrimeTemperature is within the range of supported temperature of the CationColumn:",Not[incompatibleCationColumnPrimeTemperatureErrors]];

        (* 44.8 Check whether the resolved cation column flush temperature is within the acceptable temperature range *)
        (* If there are any incompatible column temperatures and we are throwing messages, throw an error and collect in valid option *)
        incompatibleCationColumnFlushTemperatureOptions=If[incompatibleCationColumnFlushTemperatureErrors&&messagesQ,
            (
                Message[Error::IncompatibleRefreshColumnTemperature,CationColumn,"cation column flush",allowedCationColumnTemperatureRange[[1]],allowedCationColumnTemperatureRange[[2]]];
                {CationColumnFlushTemperature}
            ),
            {}
        ];

        (* Generate tests for incompatible cation column temperature *)
        incompatibleCationColumnFlushTemperatureTests=testOrNull["Specified CationColumnFlushTemperature is within the range of supported temperature of the CationColumn:",Not[incompatibleCationColumnFlushTemperatureErrors]];

        (* 44.9 Suppressor current error check *)
        (* Throw error message and collect invalid option *)
        invalidCationColumnPrimeSuppressorCurrentOptions=If[incompatibleCationColumnPrimeSuppressorCurrentErrors&&messagesQ,
            (
                Message[Error::IncompatibleColumnRefreshSuppressorCurrent,"cation column prime",minAllowedCationColumnPrimeSuppressorCurrent,maxAllowedCationColumnPrimeSuppressorCurrent];
                {CationColumnPrimeSuppressorCurrent}
            ),
            {}
        ];

        (* Generate test for invalid max acceleration *)
        cationColumnPrimeSuppressorCurrentTests=testOrNull["CationColumnPrimeSuppressorCurrent is less than the maximum suppressor current supported by the instrument:",Not[incompatibleCationColumnPrimeSuppressorCurrentErrors]];

        (* 44.10 Suppressor current error check *)
        (* Throw error message and collect invalid option *)
        invalidCationColumnFlushSuppressorCurrentOptions=If[incompatibleCationColumnFlushSuppressorCurrentErrors&&messagesQ,
            (
                Message[Error::IncompatibleColumnRefreshSuppressorCurrent,"cation column flush",minAllowedCationColumnFlushSuppressorCurrent,maxAllowedCationColumnFlushSuppressorCurrent];
                {CationColumnFlushSuppressorCurrent}
            ),
            {}
        ];

        (* Generate test for invalid max acceleration *)
        cationColumnFlushSuppressorCurrentTests=testOrNull["CationColumnFlushSuppressorCurrent is less than the maximum suppressor current supported by the instrument:",Not[incompatibleCationColumnFlushSuppressorCurrentErrors]];

        (* 44.11 Detection Temperature error check *)
        (* Throw error message and collect invalid option *)
        invalidCationColumnPrimeDetectionTemperatureOptions=If[incompatibleCationColumnPrimeDetectionTemperatureErrors&&messagesQ,
            (
                Message[Error::IncompatibleColumnRefreshDetectionTemperature,"cation column prime",minCationDetectionTemperature/.Null->-Infinity Celsius,maxCationDetectionTemperature/.Null->Infinity Celsius];
                {CationColumnPrimeDetectionTemperature}
            ),
            {}
        ];

        (* Generate test for invalid max acceleration *)
        cationColumnPrimeDetectionTemperatureTests=testOrNull["CationColumnPrimeDetectionTemperature is within the range of detection temperatures set by the instrument:",Not[incompatibleCationColumnPrimeDetectionTemperatureErrors]];

        (* 44.12 Detection Temperature error check *)
        (* Throw error message and collect invalid option *)
        invalidCationColumnFlushDetectionTemperatureOptions=If[incompatibleCationColumnFlushDetectionTemperatureErrors&&messagesQ,
            (
                Message[Error::IncompatibleColumnRefreshDetectionTemperature,"cation column flush",minCationDetectionTemperature/.Null->-Infinity Celsius,maxCationDetectionTemperature/.Null->Infinity Celsius];
                {CationColumnFlushDetectionTemperature}
            ),
            {}
        ];

        (* Generate test for invalid max acceleration *)
        cationColumnFlushDetectionTemperatureTests=testOrNull["CationColumnFlushDetectionTemperature is within the range of detection temperatures set by the instrument:",Not[incompatibleCationColumnFlushDetectionTemperatureErrors]]; *)

		(* 44.13 Suppressor mode error check *)
		(* Throw error message and collect invalid option *)
		conflictingCationColumnPrimeSuppressorModeOptions = If[conflictingCationColumnPrimeSuppressorModeErrors && messagesQ,
			(
				Message[Error::ConflictingColumnRefreshSuppressorMode, "cation column prime", CationColumnPrimeSuppressorMode, CationColumnPrimeSuppressorVoltage, CationColumnPrimeSuppressorCurrent];
				{CationColumnPrimeSuppressorMode, CationColumnPrimeSuppressorVoltage, CationColumnPrimeSuppressorCurrent}
			),
			{}
		];

		(* Generate test for conflicting suppressor mode *)
		cationColumnPrimeSuppressorModeTests = testOrNull["CationColumnPrimeSuppressorVoltage and CationColumnPrimeSuppressorCurrent are set if CationColumnPrimeSuppressorMode is set to DynamicMode and LegacyMode respectively:", Not[conflictingCationColumnPrimeSuppressorModeErrors]];

		(* 44.14 Suppressor mode error check *)
		(* Throw error message and collect invalid option *)
		conflictingCationColumnFlushSuppressorModeOptions = If[conflictingCationColumnFlushSuppressorModeErrors && messagesQ,
			(
				Message[Error::ConflictingColumnRefreshSuppressorMode, "cation column flush", CationColumnFlushSuppressorMode, CationColumnFlushSuppressorVoltage, CationColumnFlushSuppressorCurrent];
				{CationColumnFlushSuppressorMode, CationColumnFlushSuppressorVoltage, CationColumnFlushSuppressorCurrent}
			),
			{}
		];

		(* Generate test for conflicting suppressor mode *)
		cationColumnFlushSuppressorModeTests = testOrNull["CationColumnFlushSuppressorVoltage and CationColumnFlushSuppressorCurrent are set if CationColumnFlushSuppressorMode is set to DynamicMode and LegacyMode respectively:", Not[conflictingCationColumnFlushSuppressorModeErrors]];

		(* Don't need this check - upper bound of suppressor voltage is already set in the widget
        (* 44.15 Suppressor voltage error check *)
        (* Throw error message and collect invalid option *)
        invalidCationColumnPrimeSuppressorVoltageOptions=If[incompatibleCationColumnPrimeSuppressorVoltageErrors&&messagesQ,
            (
                Message[Error::IncompatibleColumnRefreshSuppressorVoltage,resolvedCationColumnPrimeSuppressorVoltage,"cation column prime",maxCationSuppressorVoltage/.Null->Infinity Volt];
                {CationColumnPrimeSuppressorVoltage}
            ),
            {}
        ];

        (* Generate test for invalid max acceleration *)
        cationColumnPrimeSuppressorVoltageTests=testOrNull["CationColumnPrimeSuppressorVoltage is less than the maximum suppressor voltage supported by the instrument:",Not[incompatibleCationColumnPrimeSuppressorVoltageErrors]];

        (* 44.16 Suppressor voltage error check *)
        (* Throw error message and collect invalid option *)
        invalidCationColumnFlushSuppressorVoltageOptions=If[incompatibleCationColumnFlushSuppressorVoltageErrors&&messagesQ,
            (
                Message[Error::IncompatibleColumnRefreshSuppressorVoltage,resolvedCationColumnFlushSuppressorVoltage,"cation column flush",maxCationSuppressorVoltage/.Null->Infinity Volt];
                {CationColumnFlushSuppressorVoltage}
            ),
            {}
        ];

        (* Generate test for invalid max acceleration *)
        cationColumnFlushSuppressorVoltageTests=testOrNull["CationColumnFlushSuppressorVoltage is less than the maximum suppressor voltage supported by the instrument:",Not[incompatibleCationColumnFlushSuppressorVoltageErrors]];

        (* We don't need this test anymore. If buffer concentration is not found and suppressor mode is set to LegacyMode, suppressor current will just default to a value. *)
        (* 44.16 Suppressor current warning *)
        (* If concentration of the buffer is not found and SuppressorMode is set to LegacyMode, throw a warning *)
        allCationSuppressorMode={resolvedCationSuppressorMode,resolvedCationStandardSuppressorMode,resolvedCationBlankSuppressorMode,resolvedCationColumnPrimeSuppressorMode,resolvedCationColumnFlushSuppressorMode};
        totalBufferConcentration=Total[{bufferAConcentration,bufferBConcentration,bufferCConcentration,bufferDConcentration}];
        arbitraryCationSuppressorCurrentQ=If[MatchQ[resolvedCationColumn,Null|{Null}|{}],
            False,
            MemberQ[allCationSuppressorMode,LegacyMode]&&MatchQ[totalBufferConcentration,0 Millimolar|0]
        ];

        If[arbitraryCationSuppressorCurrentQ&&messagesQ,
            Message[Warning::ArbitraryCationSuppressorCurrent],
            {}
        ];

        (* Generate test for arbitraty cation suppressor current *)
        arbitraryCationSuppressorCurrentTests=If[!MatchQ[resolvedCationColumn,Null|{Null}|{}],
            warningOrNull["If concentration of BufferA-D cannot be calculated or found and CationSuppressorMode is set to LegacyMode, CationSuppressorCurrent is arbitrarily set:",arbitraryCationSuppressorCurrentQ],
            Nothing
        ];

        (* 44.17 AnionColumnPrimeFlowRate has to be within the range supported by the instrument, and the column *)
        (* If there are any invalid anion flow rates and we are throwing messages, then throw an error message and collect invalid options *)
        incompatibleCationColumnPrimeFlowRateOptions=If[MemberQ[ToList@cationColumnPrimeFlowRateErrors,True]&&messagesQ,
            (
                Message[Error::IncompatibleColumnRefreshFlowRate,CationColumnPrimeFlowRate,resolvedCationColumnPrimeFlowRate,resolvedInstrument,resolvedCationColumn,maxFlowRate];
                {CationColumnPrimeFlowRate}
            ),
            {}
        ];

        (* Generate test for invalid anion gradient composition *)
        invalidCationColumnPrimeFlowRateTests=testOrNull["The specified CationColumnPrimeFlowRate has maximum flow rate less than that supported by the instrument and the column:",Not[cationColumnPrimeFlowRateErrors]];

        (* 44.17 AnionColumnPrimeFlowRate has to be within the range supported by the instrument, and the column *)
        (* If there are any invalid anion flow rates and we are throwing messages, then throw an error message and collect invalid options *)
        incompatibleCationColumnFlushFlowRateOptions=If[MemberQ[ToList@cationColumnFlushFlowRateErrors,True]&&messagesQ,
            (
                Message[Error::IncompatibleColumnRefreshFlowRate,CationColumnFlushFlowRate,resolvedCationColumnFlushFlowRate,resolvedInstrument,resolvedCationColumn,maxFlowRate];
                {CationColumnFlushFlowRate}
            ),
            {}
        ];

        (* Generate test for invalid anion gradient composition *)
        invalidCationColumnFlushFlowRateTests=testOrNull["The specified CationColumnFlushFlowRate has maximum flow rate less than that supported by the instrument and the column:",Not[cationColumnFlushFlowRateErrors]]; *)

		(* 44.18 CationColumnPrimeStart, CationColumnPrimeEnd, and CationColumnPrimeDuration has to be specified or Nulled out together *)

		(* If there are any missing gradient and we are throwing messages, then throw an error message and collect invalid options *)
		notSpecifiedCationColumnPrimeGradientStartEndOptions = If[MemberQ[ToList@cationColumnPrimeStartEndSpecifiedErrors, True] && messagesQ,
			(
				Message[Error::HPICGradientStartEndConflict, {CationColumnPrimeStart, CationColumnPrimeEnd}, "cation column prime"];
				{CationColumnPrimeStart, CationColumnPrimeEnd}
			),
			{}
		];

		(* Generate test for missing specification among anion gradient start, end and duration *)
		notSpecifiedCationColumnPrimeGradientStartEndTests = testOrNull["CationColumnPrimeStart and CationColumnPrimeEnd should be specified or set to Null simultaneously:", Not[cationColumnPrimeStartEndSpecifiedErrors]];

		(* 44.18 CationColumnFlushStart, CationColumnFlushEnd, and CationColumnFlushDuration has to be specified or Nulled out together *)
		notSpecifiedCationColumnFlushGradientStartEndOptions = If[MemberQ[ToList@cationColumnFlushStartEndSpecifiedErrors, True] && messagesQ,
			(
				Message[Error::HPICGradientStartEndConflict, {CationColumnFlushStart, CationColumnFlushEnd}, "cation column flush"];
				{CationColumnFlushStart, CationColumnFlushEnd}
			),
			{}
		];

		(* Generate test for missing specification among anion gradient start, end and duration *)
		notSpecifiedCationColumnFlushGradientStartEndTests = testOrNull["CationColumnFlushStart and CationColumnFlushEnd should be specified or set to Null simultaneously:", Not[cationColumnFlushStartEndSpecifiedErrors]];

		(* 44.19 If gradient duration is specified, either gradient start & end or eluent gradient is specified *)
		(* If there are any missing anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
		notSpecifiedCationColumnPrimeGradientDurationOptions = If[MemberQ[ToList@cationColumnPrimeDurationOptionSpecifiedErrors, True] && messagesQ,
			(
				Message[Error::HPICGradientShortcutConflict, CationColumnPrimeDuration, {CationColumnPrimeStart, CationColumnPrimeEnd}, "CationColumnPrimeGradientA/B/C/D"];
				{CationColumnPrimeStart, CationColumnPrimeEnd, CationColumnPrimeDuration, CationColumnPrimeGradientA, CationColumnPrimeGradientB, CationColumnPrimeGradientC, CationColumnPrimeGradientD}
			),
			{}
		];

		(* Generate test for missing specification among anion gradient start, end and duration *)
		notSpecifiedCationColumnPrimeGradientDurationTests = testOrNull["CationColumnPrimeGradientDuration should be specified either with CationColumnPrimeGradientStart/CationColumnPrimeGradientEnd or any of the CationColumnPrimeGradientA/B/C/D:", Not[cationColumnPrimeDurationOptionSpecifiedErrors]];

		(* 44.20 If gradient duration is specified, either gradient start & end or eluent gradient is specified *)
		(* If there are any missing anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
		notSpecifiedCationColumnFlushGradientDurationOptions = If[MemberQ[ToList@cationColumnFlushDurationOptionSpecifiedErrors, True] && messagesQ,
			(
				Message[Error::HPICGradientShortcutConflict, CationColumnFlushDuration, {CationColumnFlushStart, CationColumnFlushEnd}, "CationColumnFlushGradientA/B/C/D"];
				{CationColumnFlushStart, CationColumnFlushEnd, CationColumnFlushDuration, CationColumnFlushGradientA, CationColumnFlushGradientB, CationColumnFlushGradientC, CationColumnFlushGradientD}
			),
			{}
		];

		(* Generate test for missing specification among anion gradient start, end and duration *)
		notSpecifiedCationColumnFlushGradientDurationTests = testOrNull["CationColumnFlushGradientDuration should be specified either with CationColumnFlushGradientStart/CationColumnFlushGradientEnd or any of the CationColumnFlushGradientA/B/C/D:", Not[cationColumnFlushDurationOptionSpecifiedErrors]];

		(* 37.9 If gradient duration and eluent gradient are both specified, their specified values are consistent *)
		(* If there are any missing anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
		inconsistentCationColumnPrimeGradientDurationOptions = If[MemberQ[ToList@cationColumnPrimeDurationConsistentErrors, True] && messagesQ && notInEngine,
			(
				Message[Warning::HPICGradientShortcutAmbiguity, CationColumnPrimeDuration, "CationColumnPrimeGradientA/B/C/D"];
				{}
			),
			{}
		];

		(* Generate test for missing specification among anion gradient start, end and duration *)
		consistentCationColumnPrimeGradientDurationTests = warningOrNull["Specified values for CationColumnPrimeDuration and CationColumnPrimeGradientA/B/C/D are consistent:", Not[cationColumnPrimeDurationConsistentErrors]];

		(* 37.10 If gradient duration and eluent gradient are both specified, their specified values are consistent *)
		(* If there are any missing anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
		inconsistentCationColumnFlushGradientDurationOptions = If[MemberQ[ToList@cationColumnPrimeDurationConsistentErrors, True] && messagesQ && notInEngine,
			(
				Message[Warning::HPICGradientShortcutAmbiguity, CationColumnFlushDuration, "CationColumnFlushGradientA/B/C/D"];
				{}
			),
			{}
		];

		(* Generate test for missing specification among anion gradient start, end and duration *)
		consistentCationColumnFlushGradientDurationTests = warningOrNull["Specified values for CationColumnFlushDuration and CationColumnFlushGradientA/B/C/D are consistent:", Not[cationColumnFlushDurationConsistentErrors]];

		(* Set up a massive map thread here to resolve all column prime and column flush paramaters *)
		{
			{
				resolvedColumnPrimeTemperature,
				resolvedColumnPrimeGradient,
				resolvedColumnPrimeGradientA,
				resolvedColumnPrimeGradientB,
				resolvedColumnPrimeGradientC,
				resolvedColumnPrimeGradientD,
				resolvedColumnPrimeFlowRate,
				resolvedColumnPrimeStart,
				resolvedColumnPrimeEnd,
				resolvedColumnPrimeDuration,
				resolvedColumnPrimeAbsorbanceWavelength,
				resolvedColumnPrimeAbsorbanceSamplingRate,
				resolvedColumnPrimeElectrochemicalDetectionMode,
				resolvedColumnPrimeReferenceElectrodeMode,
				resolvedColumnPrimeVoltageProfile,
				resolvedColumnPrimeWaveformProfile,
				resolvedColumnPrimeElectrochemicalSamplingRate,
				resolvedColumnPrimeDetectionTemperature,
				columnPrimeGradientConsistentErrors,
				columnPrimeStartEndSpecifiedErrors,
				columnPrimeDurationOptionSpecifiedErrors,
				invalidColumnPrimeGradientCompositionErrors,
				columnPrimeRemovedExtraErrors,
				columnPrimeFlowRateErrors,
				columnPrimeDurationConsistentErrors,
				overwriteColumnPrimeGradientBool,
				columnPrimeAbsorbanceOptionConflictErrors,
				columnPrimeElectrochemicalOptionConflictErrors,
				columnPrimeElectrochemicalModeOptionConflictErrors,
				multipleColumnPrimeDetectionModeErrors,
				columnPrimeWaveformDetectionModeErrors,
				multipleColumnPrimeWaveformDurationErrors,
				duplicateColumnPrimeVoltageProfileTimeErrors,
				duplicateColumnPrimeWaveformProfileTimeErrors
			},
			{
				resolvedColumnFlushTemperature,
				resolvedColumnFlushGradient,
				resolvedColumnFlushGradientA,
				resolvedColumnFlushGradientB,
				resolvedColumnFlushGradientC,
				resolvedColumnFlushGradientD,
				resolvedColumnFlushFlowRate,
				resolvedColumnFlushStart,
				resolvedColumnFlushEnd,
				resolvedColumnFlushDuration,
				resolvedColumnFlushAbsorbanceWavelength,
				resolvedColumnFlushAbsorbanceSamplingRate,
				resolvedColumnFlushElectrochemicalDetectionMode,
				resolvedColumnFlushReferenceElectrodeMode,
				resolvedColumnFlushVoltageProfile,
				resolvedColumnFlushWaveformProfile,
				resolvedColumnFlushElectrochemicalSamplingRate,
				resolvedColumnFlushDetectionTemperature,
				columnFlushGradientConsistentErrors,
				columnFlushStartEndSpecifiedErrors,
				columnFlushDurationOptionSpecifiedErrors,
				invalidColumnFlushGradientCompositionErrors,
				columnFlushRemovedExtraErrors,
				columnFlushFlowRateErrors,
				columnFlushDurationConsistentErrors,
				overwriteColumnFlushGradientBool,
				columnFlushAbsorbanceOptionConflictErrors,
				columnFlushElectrochemicalOptionConflictErrors,
				columnFlushElectrochemicalModeOptionConflictErrors,
				multipleColumnFlushDetectionModeErrors,
				columnFlushWaveformDetectionModeErrors,
				multipleColumnFlushWaveformDurationErrors,
				duplicateColumnFlushVoltageProfileTimeErrors,
				duplicateColumnFlushWaveformProfileTimeErrors
			}
		} = Module[{
			specifiedRefreshfrequency, frequency, gradienta, gradientb, gradientc, gradientd, gradient, flowrate, duration, cleaningType, defaultGradient, columnTemperature, detectionTemperature,
			electrochemicalInjectionTableRoundedGradient, gradientConsistentQ, removedExtrasQ, protoGradientOptionTuple, gradientOptionTuple, defaultedFlowRate,
			gradientReturned, initiallyResolvedGradient, invalidGradientCompositionQ, gradientA, gradientB, gradientC, gradientD, flowRate, gradientFinal,
			overwriteCleaningGradientQ, incompatibleFlowRateQ, gradientStartEndSpecifiedQ, start, end, gradientStart, gradientEnd, individualGradientSpecifiedQ,
			absorbancewavelength, absorbancesamplingrate, electrochemicaldetectionmode, referenceelectrodemode, voltageprofile, waveformprofile,
			electrochemicalsamplingrate, detectiontemperature, absorbanceWavelength, absorbanceSamplingRate, electrochemicalDetectionMode,
			referenceElectrodeMode, voltageProfile, waveformProfile, electrochemicalSamplingRate, absorbanceOptionConflictQ, injectionTableWaveformEntry,
			electrochemicalModeOptionConflictQ, waveformDetectionMode, multipleDetectionModeQ, waveformDetectionModeConflictQ, voltageProfileDuplicateTimeQ,
			waveformProfileDuplicateTimeQ, waveformDuration, multipleWaveformDurationQ, injectionTableVoltageEntry, durationOptionsSpecifiedQ, durationConsistentQ,
			electrochemicalOptionConflictQ
		},

			Map[Function[{entryVariables},

				{
					specifiedRefreshfrequency, frequency, gradienta, gradientb, gradientc, gradientd, gradient, flowrate, start, end, duration, cleaningType, defaultGradient, columnTemperature,
					absorbancewavelength, absorbancesamplingrate, electrochemicaldetectionmode, referenceelectrodemode, voltageprofile, waveformprofile, electrochemicalsamplingrate, detectiontemperature
				} = entryVariables;

				If[
					Or[
						MatchQ[resolvedColumn, {} | Null | {Null}],
						And[
							MatchQ[specifiedRefreshfrequency, frequency],
							Length[Cases[electrochemicalInjectionTableLookupRounded, {cleaningType, ___}]] == 0
						]
					],
					(* If specified refresh frequency is set to Null or None, and one of the gradient options is set to Null, then set all cation column prime/flush related options to Null and error tracking variables to False *)
					Join[ConstantArray[{}, 18], ConstantArray[False, 16]],

					(* Setup: We first get the injection table gradients *)
					electrochemicalInjectionTableRoundedGradient = If[MatchQ[electrochemicalInjectionTableLookupRounded, Except[Automatic]],

						(* Extract the gradient specified in InjectionTable *)
						Cases[electrochemicalInjectionTableLookupRounded, {cleaningType, gradient_, ___} :> gradient],

						(* If InjectionTable is not specified, pad it with Automatics*)
						Automatic
					];

					(* First we need to make sure that the start end and duration options are either all specified or not *)
					gradientStartEndSpecifiedQ = !MatchQ[{start, end}, {PercentP, PercentP} | {Automatic | Null, Automatic | Null}];

					(* Then we need to make sure that the duration is specified either with start & end, or with eluent gradient *)
					durationOptionsSpecifiedQ = If[MatchQ[duration, TimeP],
						Not[MatchQ[{start, end}, {PercentP, PercentP}] || MatchQ[gradienta, PercentP] || MatchQ[gradientb, PercentP] || MatchQ[gradientc, PercentP] || MatchQ[gradientd, PercentP]],
						False
					];

					(* Need to check if any of the individual gradient is specified in {Time,Percent} format *)
					individualGradientSpecifiedQ = Or[
						MatchQ[gradienta, Except[Automatic | PercentP]],
						MatchQ[gradientb, Except[Automatic | PercentP]],
						MatchQ[gradientc, Except[Automatic | PercentP]],
						MatchQ[gradientd, Except[Automatic | PercentP]]
					];

					(* We also need to check if Duration specification is consistent with individual gradient *)
					durationConsistentQ = If[individualGradientSpecifiedQ,

						If[MatchQ[duration, TimeP],
							True,
							False
						],
						(* If none of the individual gradient is specified, then leave this error tracking variable to False *)
						False
					];

					(* If gradient is specied as a method object, check whether CationGradient and the injection table specify the same object*)
					gradientConsistentQ = If[MatchQ[gradient, ObjectP[Object[Method, Gradient]]] && MatchQ[electrochemicalInjectionTableRoundedGradient, {ObjectP[Object[Method, Gradient]]}],
						Not[MatchQ[ToList@Download[gradient, Object], Download[electrochemicalInjectionTableRoundedGradient, Object]]],
						False
					];

					(* Extract or default GradientStart and GradientEnd values *)
					{gradientStart, gradientEnd} = Switch[{start, end, duration},

						(* If valid cationGradientStart and cationGradientEnd are given, go with that *)
						{PercentP, PercentP, _} | {Null, Null, Null | TimeP}, {start, end},

						(* Default to cationGradientStart if something is wrong with gradientEnd *)
						{PercentP, _, _}, {start, start},

						(* Default to 0 Percent if something is wrong with cationGradeintStart *)
						{_, PercentP, _}, {0 Percent, end},

						(* Otherwise, both Null*)
						_, {Null, Null}
					];

					(* If Gradient option is an object, pull Gradient value from packet *)
					protoGradientOptionTuple = Which[

						(* If CationGradient specifies a method object, extract Gradient information from the packet *)
						MatchQ[gradient, ObjectP[Object[Method, Gradient]]],
						Lookup[fetchPacketFromCache[Download[gradient, Object], fullCache], Gradient],

						(* If InjectionTable specifies a method object, extract Gradient information from the packet *)
						MatchQ[gradient, Automatic] && MatchQ[electrochemicalInjectionTableRoundedGradient, ObjectP[Object[Method, Gradient]]],
						Lookup[fetchPacketFromCache[Download[electrochemicalInjectionTableRoundedGradient, Object], fullCache], Gradient],

						(* Otherwise, namely if anionGradient is not a method object, then use what's specified in AnionGradient *)
						True, gradient
					];

					(* Update CationFlowRate in the gradient method object if the option is specified *)
					gradientOptionTuple = If[MatchQ[flowrate, Except[Automatic]],

						(* If CationFlowRate is specified, use the specified flow rate and replace the default flowrate of the method object *)
						(* In IonChromatography Gradient method, CationGradient goes "Time", "BufferA Composition", "BufferB Composition", "FlowRate". FlowRate is in the third column *)
						ReplacePart[protoGradientOptionTuple, Table[{x, 4} -> flowrate, {x, 1, Length[protoGradientOptionTuple]}]],

						(* Otherwise, use the default flow rate in the gradient object *)
						protoGradientOptionTuple
					];

					(* Default FlowRate to option value, gradient tuple values, or the pre-calculated optimal flow rate for the column *)
					(* note that it's ok to have this flow rate either match FlowRateP, or be a list of pairs of time and flow rate since resolveGradient can handle either *)
					defaultedFlowRate = Which[

						(* If the AnionFlowRate is specified, go with the user specified value *)
						MatchQ[flowrate, Except[Automatic]], flowrate,

						(* If the AnionFlowRate is specified as part of the gradient method object, extract the flow rate from the object *)
						MatchQ[gradientOptionTuple, {TimeP, PercentP, PercentP, PercentP, PercentP, FlowRateP}], gradientOptionTuple[[All, {1, 6}]],

						(* If no flow rate is specified, use the optional flow rate determined for the column *)
						True, optimalColumnFlowRate
					];

					(* Setup error tracking variable for error messages outside this map thread *)
					incompatibleFlowRateQ = Not[Between[defaultedFlowRate, {minFlowRate, maxFlowRate}]];

					(* finally run our helper resolution function *)
					gradientReturned = If[MatchQ[{gradientOptionTuple, gradienta, gradientb, gradientc, gradientd, start, end, duration, flowrate}, {(Null | Automatic)..}] || gradientStartEndSpecifiedQ || durationOptionsSpecifiedQ,
						resolveICCationGradient[defaultGradient[defaultedFlowRate], gradienta, gradientb, gradientc, gradientd, defaultedFlowRate, start, end, duration],
						resolveICCationGradient[gradientOptionTuple, gradienta, gradientb, gradientc, gradientd, defaultedFlowRate, start, end, duration]
					];

					(*remove duplicate entries if need be*)
					initiallyResolvedGradient = DeleteDuplicatesBy[gradientReturned, First[# * 1.] &];

					(*if it's not the same note that*)
					removedExtrasQ = !MatchQ[gradientReturned, initiallyResolvedGradient];

					(*check whether the gradient composition adds up to 100 okay*)
					invalidGradientCompositionQ = Not[AllTrue[initiallyResolvedGradient, (#[[2]] + #[[3]] + #[[4]] + #[[5]] == 100 Percent)&]];

					(*now resolve all of the individual gradients and flow rate*)
					gradientA = If[MatchQ[gradienta, Automatic],
						collapseGradient[initiallyResolvedGradient[[All, {1, 2}]]],
						gradienta
					];

					gradientB = If[MatchQ[gradientb, Automatic],
						collapseGradient[initiallyResolvedGradient[[All, {1, 3}]]],
						gradientb
					];

					gradientC = If[MatchQ[gradientc, Automatic],
						collapseGradient[initiallyResolvedGradient[[All, {1, 4}]]],
						gradientc
					];

					gradientD = If[MatchQ[gradientd, Automatic],
						collapseGradient[initiallyResolvedGradient[[All, {1, 5}]]],
						gradientd
					];

					flowRate = If[MatchQ[flowrate, Automatic],
						collapseGradient[initiallyResolvedGradient[[All, {1, -1}]]],
						flowrate
					];

					overwriteCleaningGradientQ = If[MatchQ[gradient, ObjectP[Object[Method, Gradient]]],
						!MatchQ[Lookup[fetchPacketFromCache[Download[gradient, Object], fullCache], Gradient], initiallyResolvedGradient],
						False
					];

					(*finally resolve the gradient*)
					gradientFinal = Which[
						MatchQ[gradient, ObjectP[Object[Method, Gradient]]] && !overwriteCleaningGradientQ, gradient,
						(*otherwise if the gradient is automatic and the injection table is set, should use that*)
						MatchQ[gradient, Automatic] && MatchQ[electrochemicalInjectionTableRoundedGradient, ObjectP[Object[Method, Gradient]]], Download[electrochemicalInjectionTableRoundedGradient, Object],
						(*otherwise, it should be a tuple*)
						True, initiallyResolvedGradient
					];

					(* Download the gradient object from fullCache and extract column temperature information *)
					columnTemperature = Which[

						(* If user has already specified anion column temperature, go with that *)
						!MatchQ[columnTemperature, ListableP[Automatic | Null]],
						columnTemperature,

						(* If the specified AnionGradient is a method object, extract column temperature from there *)
						MatchQ[gradientFinal, ObjectP[Object[Method, Gradient]]],
						If[NullQ[Lookup[fetchPacketFromCache[Download[gradient, Object], fullCache], Temperature]],
							Ambient,
							Lookup[fetchPacketFromCache[Download[gradient, Object], fullCache], Temperature]
						],

						(* If the specified gradient in the InjectionTable is an Object, extract column temperature from there *)
						MatchQ[electrochemicalInjectionTableRoundedGradient, ObjectP[Object[Method, Gradient]]],
						Lookup[fetchPacketFromCache[Download[electrochemicalInjectionTableRoundedGradient, Object], fullCache], Temperature] /. {Null :> Ambient},

						MatchQ[resolvedColumnTemperature, Null | {} | {Null}],
						Ambient,

						MatchQ[resolvedColumnTemperature[[1]], Ambient],
						Ambient,

						True,
						resolvedColumnTemperature[[1]]
					];

					(* Before resolving the absorbance options, first do some option conflict checks *)
					absorbanceOptionConflictQ = If[
						MemberQ[ToList@resolvedDetector, UVVis],
						Switch[
							(* We will look up the specified value of Absorbance related options *)
							{absorbancewavelength, absorbancesamplingrate},

							(* Both options cannot be null *)
							{Except[Null], Except[Null]},
							False,

							(* Otherwise set the error tracking variable to True *)
							{_, _},
							True
						],
						False
					];

					absorbanceWavelength = Which[
						(* If user specified absorbance wavelength, go with that *)
						MatchQ[absorbancewavelength, Except[Automatic]],
						absorbancewavelength,

						MatchQ[absorbancesamplingrate, Null],
						Null,

						(* If absorbance wavelength is specified for the sample, use the first wavelength from the resolved absorbance wavelength *)
						MatchQ[resolvedAbsorbanceWavelength, Except[Automatic]],
						ToList[resolvedAbsorbanceWavelength][[1]],

						(* Otherwise, set to 280 nm *)
						True,
						280 Nanometer
					];

					absorbanceSamplingRate = Which[

						(* If user specified absorbance wavelength sampling rate, go with that *)
						MatchQ[absorbancesamplingrate, Except[Automatic]],
						absorbancesamplingrate,

						(* If the absorbance sampling rate is already resolved for sample, use the first value for BlankAbsorbanceSamplingRate *)
						NullQ[absorbanceWavelength],
						Null,

						(* If we are only reading at one wavelength, then set sampling rate to 10/Second *)
						Length[ToList@absorbanceWavelength] == 1,
						10 / Second,

						(* If we are reading at multiple wavelengths, then set sampling rate to 1/Second *)
						Length[ToList@absorbanceWavelength] > 1,
						1 / Second,

						(* Otherwise, set to Null *)
						True,
						Null
					];

					(* Then find the entry of the particular sample in the injection table *)
					{injectionTableWaveformEntry, injectionTableVoltageEntry} = If[electrochemicalInjectionTableSpecifiedQ,
						If[MatchQ[Cases[electrochemicalInjectionTableLookupRounded, {cleaningType, ___}], {}],
							{Null, Null},
							FirstCase[electrochemicalInjectionTableLookupRounded, {cleaningType, ___}][[3 ;; 4]]
						],
						{Automatic, Automatic}
					];


					(* Before resolving the electrochemical options, first do some option conflict checks *)
					electrochemicalOptionConflictQ = If[
						MemberQ[ToList@resolvedDetector, ElectrochemicalDetector],
						Switch[
							(* We will look up the specified value of Absorbance related options *)
							{electrochemicaldetectionmode, referenceelectrodemode, electrochemicalsamplingrate, detectiontemperature},

							(* Both options cannot be null *)
							{Except[Null], Except[Null], Except[Null], Except[Null]},
							False,

							(* Otherwise set the error tracking variable to True *)
							{_, _, _, _},
							True
						],
						False
					];

					(* Before resolving all the electrochemical detection mode option, first do some option conflict checks *)
					electrochemicalModeOptionConflictQ = Switch[

						(* We will look up the specified value of Absorbance related options *)
						{electrochemicaldetectionmode, voltageprofile, waveformprofile},

						(* If they are both Null, there's no conflict *)
						{DCAmperometricDetection | {DCAmperometricDetection}, Null | {Null}, _},
						True,

						(* If they are both specified, there's also no conflict *)
						{PulsedAmperometricDetection | {PulsedAmperometricDetection}, _, Null | {Null}},
						True,

						(* If only one of the option value is Null, then set the conflict variable to True *)
						{IntegratedPulsedAmperometricDetection | {IntegratedPulsedAmperometricDetection}, _, Null | {Null}},
						True,

						{_, _, _},
						False
					];

					(* Before resolving electrochemical detection mode, let's first pull out the electrochemical mode from any waveforms specified *)
					waveformDetectionMode = Which[

						(* If WaveformProfile is specified, detection mode can either be Pulsed Amperometry or Integrated Pulsed Amperometry *)
						MatchQ[waveformprofile, Except[Automatic]],
						Which[

							(* If WaveformProfile is specified as a method object, then directly pull ElectrochemicalDetectionMode field from it *)
							MatchQ[waveformprofile, ObjectP[Object[Method, Waveform]]],
							Lookup[fetchPacketFromCache[Download[waveformprofile, Object], fullCache], ElectrochemicalDetectionMode],

							(* If WaveformProfile is specified as multiple method objects, then track ElectrochemicalDetectionMode of all methods and use ElectrochemicalDetectionMode from the first method *)
							MatchQ[waveformprofile, {{TimeP, ObjectP[Object[Method, Waveform]]}...}],
							Lookup[fetchPacketFromCache[#, fullCache], ElectrochemicalDetectionMode]& /@ Download[waveformprofile[[All, 2]], Object],

							(* If WaveformProfile is specified as tuples of {Time,Voltage,Boolean,Boolean}, then it gets a little more complicated *)
							(* We will have to look at the second Boolean and the Voltage value to determine ElectrochemicalDetectionMode *)
							(* If voltages specified are one constant value when the second Boolean is True then it is PulsedAmperometricDetection *)
							(* If voltages specified are more than one value when the second Boolean is True then it is IntegratedPulsedAmperometricDetection *)
							MatchQ[waveformprofile, {{TimeP, VoltageP, BooleanP, BooleanP}...}],
							Module[{integratedEntries, integratedVoltages},

								(* First pick out the entries where the secnd Boolean is True, aka when integration happens *)
								integratedEntries = Select[waveformprofile, #[[4]] == True&];

								(* Then pull out the voltages of the entire integration period *)
								integratedVoltages = integratedEntries[[All, 2]];
								If[Length[DeleteDuplicates[integratedVoltages]] == 1,
									PulsedAmperometricDetection,
									IntegratedPulsedAmperometricDetection
								]
							],

							(* Final case, if WaveformProfile is specified as tuples of {Time, {Time,Voltage,Boolean,Boolean}}, then we apply the logic above *)
							MatchQ[waveformprofile, {{TimeP, {{TimeP, VoltageP, BooleanP, BooleanP}...}...}...}],
							Module[{waveforms, integratedEntries, integratedVoltages},

								(* First pick out the entries where the secnd Boolean is True, aka when integration happens *)
								waveforms = waveformprofile[[All, 2]];
								integratedEntries = Map[
									Function[{waveform},
										Select[waveform, #[[4]] == True&]
									],
									waveforms
								];

								(* Then pull out the voltages of the entire integration period *)
								integratedVoltages = integratedEntries[[All, All, 2]];
								If[Length[DeleteDuplicates[#]] == 1,
									PulsedAmperometricDetection,
									IntegratedPulsedAmperometricDetection
								]& /@ integratedVoltages
							]
						],

						(* If WaveformProfile is specified in the injection table, detection mode can either be Pulsed Amperometry or Integrated Pulsed Amperometry *)
						MatchQ[injectionTableWaveformEntry, Except[Automatic | Null]],
						Which[
							(* If WaveformProfile is specified in the injection table, download the method and pull ElectrochemicalDetectionMode *)
							MatchQ[injectionTableWaveformEntry, ObjectP[Object[Method, Waveform]]],
							Lookup[fetchPacketFromCache[Download[injectionTableWaveformEntry, Object], fullCache], ElectrochemicalDetectionMode],

							(* If WaveformProfile is specified as multiple method objects in the injection table, then track ElectrochemicalDetectionMode of all methods *)
							MatchQ[injectionTableWaveformEntry, {{TimeP, ObjectP[Object[Method, Waveform]]}...}],
							Lookup[fetchPacketFromCache[#, fullCache], ElectrochemicalDetectionMode]& /@ Download[injectionTableWaveformEntry[[All, 2]], Object],

							(* Similar logic applies for Waveform specified in the injection table *)
							MatchQ[injectionTableWaveformEntry, {{TimeP, VoltageP, BooleanP, BooleanP}...}],
							Module[{integratedEntries, integratedVoltages},

								(* First pick out the entries where the secnd Boolean is True, aka when integration happens *)
								integratedEntries = Select[injectionTableWaveformEntry, #[[4]] == True&];

								(* Then pull out the voltages of the entire integration period *)
								integratedVoltages = integratedEntries[[All, 2]];
								If[Length[DeleteDuplicates[integratedVoltages]] == 1,
									PulsedAmperometricDetection,
									IntegratedPulsedAmperometricDetection
								]
							],

							(* The injection table specified with same logic as above *)
							MatchQ[injectionTableWaveformEntry, {{TimeP, {{TimeP, VoltageP, BooleanP, BooleanP}...}...}...}],
							Module[{waveforms, integratedEntries, integratedVoltages},

								(* First pick out the entries where the secnd Boolean is True, aka when integration happens *)
								waveforms = injectionTableWaveformEntry[[All, 2]];
								integratedEntries = Map[
									Function[{waveform},
										Select[waveform, #[[4]] == True&]
									],
									waveforms
								];

								(* Then pull out the voltages of the entire integration period *)
								integratedVoltages = integratedEntries[[All, 2]];
								If[Length[DeleteDuplicates[#]] == 1,
									PulsedAmperometricDetection,
									IntegratedPulsedAmperometricDetection
								]& /@ integratedVoltages
							]
						],

						(* If all things fail, return PulsedAmperometricDetection *)
						True,
						Automatic
					];

					multipleDetectionModeQ = Module[{uniqueDetectionMode},
						(* Get the unique detection modes from all waveforms specified *)
						uniqueDetectionMode = DeleteDuplicates[ToList[waveformDetectionMode]];
						(* If there are more than 1 detection mode, set error tracking variable to True, otherwise set it to False *)
						If[Length[uniqueDetectionMode] == 1,
							False,
							True
						]
					];

					electrochemicalDetectionMode = Which[

						(* If user specified electrochemical detection mode, go with that *)
						MatchQ[electrochemicaldetectionmode, Except[Automatic]],
						electrochemicaldetectionmode,

						!MemberQ[ToList@resolvedDetector, ElectrochemicalDetector],
						Null,

						(* If VoltageProfile is specified, set detection mode to DC Amperometry *)
						MatchQ[voltageprofile, Except[Automatic]] || MatchQ[injectionTableVoltageEntry, Except[Automatic | Null]],
						DCAmperometricDetection,

						MatchQ[First@ToList[waveformDetectionMode], Except[Automatic]],
						First@ToList[waveformDetectionMode],

						MatchQ[First[ToList[resolvedElectrochemicalDetectionMode]], Except[Null]],
						First[ToList[resolvedElectrochemicalDetectionMode]],

						(* Use the ElectrochemicalDetectionMode of the first waveform as the resolved electrochemicalDetection Mode *)
						True,
						PulsedAmperometricDetection
					];

					(* Here we check if the electrochemical detection mode and the specified waveform is in conflict *)
					(* If there is already multiple detection mode error, then we can pass on this error *)
					waveformDetectionModeConflictQ = If[multipleDetectionModeQ,
						False,
						If[MatchQ[electrochemicalDetectionMode, Except[DCAmperometricDetection]],
							If[!MatchQ[waveformDetectionMode, Automatic],
								!MatchQ[First@ToList[waveformDetectionMode], electrochemicalDetectionMode],
								False
							],
							False
						]
					];

					referenceElectrodeMode = Which[

						(* If user specified reference electrode mode, go with that *)
						MatchQ[referenceelectrodemode, Except[Automatic]],
						referenceelectrodemode,

						(* If ElectrochemicalDetectionMode is set to DCAmperometry, set reference electrode mode to Null *)
						MatchQ[electrochemicaldetectionmode, DCAmperometricDetection],
						Null,

						(* If VoltageProfile is specified, set reference electrode mode to DC Amperometry *)
						MatchQ[voltageprofile, Except[Automatic]] || MatchQ[injectionTableVoltageEntry, Except[Automatic | Null]],
						Null,

						(* If WaveformProfile is specified, detection mode can either be Pulsed Amperometry or Integrated Pulsed Amperometry *)
						MatchQ[waveformprofile, Except[Automatic]],
						Which[

							(* If WaveformProfile is specified as a method object, then directly pull ReferenceElectrodeMode field from it *)
							MatchQ[waveformprofile, ObjectP[Object[Method, Waveform]]],
							Lookup[fetchPacketFromCache[Download[waveformprofile, Object], fullCache], ReferenceElectrodeMode],

							(* If WaveformProfile is specified as multiple method objects, then track ReferenceElectrodeMode of all methods and use ReferenceElectrodeMode from the first method *)
							MatchQ[waveformprofile, {{TimeP, ObjectP[Object[Method, Waveform]]}...}],
							Lookup[fetchPacketFromCache[Download[waveformprofile[[1, 2]], Object], fullCache], ReferenceElectrodeMode],

							True,
							AgCl
						],

						(* If WaveformProfile is specified, detection mode can either be Pulsed Amperometry or Integrated Pulsed Amperometry *)
						MatchQ[injectionTableWaveformEntry, Except[Automatic]],
						Which[
							(* If WaveformProfile is specified in the injection table, download the method and pull ReferenceElectrodeMode *)
							MatchQ[injectionTableWaveformEntry, ObjectP[Object[Method, Waveform]]],
							Lookup[fetchPacketFromCache[Download[injectionTableWaveformEntry, Object], fullCache], ReferenceElectrodeMode],

							(* If WaveformProfile is specified as multiple method objects in the injection table, then track ReferenceElectrodeMode of all methods and use ReferenceElectrodeMode from the first method *)
							MatchQ[injectionTableWaveformEntry, {{TimeP, ObjectP[Object[Method, Waveform]]}...}],
							Lookup[fetchPacketFromCache[Download[injectionTableWaveformEntry, Object], fullCache], ReferenceElectrodeMode],

							True,
							AgCl
						],

						(* If there are resolved voltage profile for the samples, use the first resolved value there *)
						MatchQ[resolvedReferenceElectrodeMode, Except[Automatic]],
						ToList[resolvedReferenceElectrodeMode][[1]],

						(* If WaveformProfile is specified as tuples of {Time,Voltage,Boolean,Boolean} or {Time, {Time,Voltage,Boolean,Boolean}}, either in the option or in the injection table *)
						(* And this option is not specified, then go ahead and set reference electrode mode to AgCl *)
						True,
						AgCl
					];

					voltageProfile = Which[

						(* If the user is not using DC Amperometry, set it to Null *)
						!MatchQ[electrochemicalDetectionMode, DCAmperometricDetection],
						Null,

						(* If the user has specified voltage profile, go with it *)
						MatchQ[voltageprofile, Except[Automatic]],
						voltageprofile,

						(* If the user has specified voltage profile in the injection table, go with it *)
						MatchQ[injectionTableVoltageEntry, Except[Automatic | Null]],
						injectionTableVoltageEntry,

						(* If nothing is sepcified, use the first resolved value for VoltageProfile option *)
						MatchQ[resolvedVoltageProfile, Except[Automatic | Null | {Null}]],
						If[duplicateVoltageProfileTimeErrors[[1]],
							0.1 Volt,
							ToList[resolvedVoltageProfile][[1]]
						],

						(* Otherwise, set it to 0.1 Volt throughout the whole gradient *)
						True,
						0.1 Volt
					];

					(* We need to check that the time specified in VoltageProfile is monotonically increasing *)
					voltageProfileDuplicateTimeQ = Module[{timeDifferences},
						(* This check only makes sense when VoltageProfile is specified as tuples in the form of {Time,Voltage} *)
						If[MatchQ[voltageProfile, {{TimeP, VoltageP}...}],
							timeDifferences = Differences[voltageProfile[[All, 1]]];
							If[MatchQ[timeDifferences, {GreaterP[0 * Second]...}],
								False,
								True
							],
							False
						]
					];

					waveformProfile = Which[

						(* If the user is using DC Amperometry, set it to Null *)
						MatchQ[electrochemicalDetectionMode, DCAmperometricDetection],
						Null,

						(* If the user has specified waveform profile, go with it *)
						MatchQ[waveformprofile, Except[Automatic | Null]],
						waveformprofile,

						(* If the user has specified waveform profile in the injection table, go with it *)
						MatchQ[injectionTableWaveformEntry, Except[Automatic | Null]],
						injectionTableWaveformEntry,

						(* If nothing is specified, use the first resolved waveform for the sample *)
						MatchQ[resolvedWaveformProfile, Except[Automatic | Null]],
						If[multipleWaveformDurationErrors[[1]],
							Values[Lookup[fetchPacketFromCache[Download[Object[Method, Waveform, "Gold Electrode Quad Potential for Carbohydrate Analysis"], Object], fullCache], Waveform]],
							ToList[resolvedWaveformProfile][[1]]
						],

						(* If nothing is specified, then first we look at the ElectrochemicalDetectionMode *)
						True,
						Which[

							(* If the detection mode is PulsedAmperometricDetection *)
							MatchQ[electrochemicalDetectionMode, PulsedAmperometricDetection],

							(* Then we look at the coat material of the working electrode and give default waveform *)
							If[MatchQ[fetchPacketFromCache[Download[resolvedWorkingElectrode, Object], fullCache], <||> | Null],
								Null,
								Switch[
									Lookup[workingElectrodeModelPacket, CoatMaterial],

									Gold,
									Values[Lookup[fetchPacketFromCache[Download[Object[Method, Waveform, "Gold Electrode Quad Potential for Carbohydrate Analysis"], Object], fullCache], Waveform]],

									Silver,
									Values[Lookup[fetchPacketFromCache[Download[Object[Method, Waveform, "Silver Electrode for Sulfide, Cyanide, Iodide, Thiosulface Analysis"], Object], fullCache], Waveform]],

									Platinum,
									Values[Lookup[fetchPacketFromCache[Download[Object[Method, Waveform, "Platinum Electrode for Alcohols, Glycols, Carboxylates, Cyanide, Sulfide Analysis"], Object], fullCache], Waveform]],

									_,
									Null
								]
							],

							(* If the detection mode is IntegratedPulsedAmperometricDetection *)
							MatchQ[electrochemicalDetectionMode, IntegratedPulsedAmperometricDetection],

							(* Then we look at the coat material of the working electrode and give default waveform *)
							If[
								MatchQ[fetchPacketFromCache[Download[resolvedWorkingElectrode, Object], fullCache], <||> | Null],
								Null,
								Switch[
									Lookup[workingElectrodeModelPacket, CoatMaterial],

									Gold,
									Object[Method, Waveform, "Gold AAA Electrode for Amino Acids, Carbohydrates, Water Soluble Vitamins Analysis"],

									_,
									Null
								]
							],

							True,
							Null
						]
					];

					(* We need to check that the time specified in WaveformProfile is monotonically increasing *)
					waveformProfileDuplicateTimeQ = Module[{waveformTimeDifferences, retentionTimeDifferences},
						Which[
							(* We first check the waveform times specified as tuples in the form of {Time,Voltage,Interpolation,Integration} *)
							MatchQ[waveformProfile, {{TimeP, VoltageP, BooleanP, BooleanP}...}],
							waveformTimeDifferences = Differences[waveformProfile[[All, 1]]];
							If[MatchQ[waveformTimeDifferences, {GreaterP[0 * Second]...}],
								False,
								True
							],

							(* Then we check the waveform times as well as retention times specified as tuples in the form of {Time,{Time,Voltage,Interpolation,Integration}} *)
							MatchQ[waveformProfile, {{TimeP, {{TimeP, VoltageP, BooleanP, BooleanP}...}...}...}],
							waveformTimeDifferences = Differences /@ ((Last /@ waveformProfile)[[All, All, 1]]);
							retentionTimeDifferences = Differences[First /@ waveformProfile];
							If[MatchQ[waveformTimeDifferences, {{GreaterP[0 * Second]...}...}] && MatchQ[retentionTimeDifferences, {GreaterP[0 * Second]...}],
								False,
								True
							],

							(* Finally we check waveform times specified in the form of {Time, Object[Method,Waveform]} *)
							MatchQ[waveformProfile, {{TimeP, ObjectP[Object[Method, Waveform]]}...}],
							retentionTimeDifferences = Differences[First /@ waveformProfile];
							If[MatchQ[retentionTimeDifferences, {GreaterP[0 * Second]...}],
								False,
								True
							],

							True,
							False
						]
					];

					(* Before resolving sampling rate, let's first get the waveform duration *)
					waveformDuration = Which[

						(* If the resolved waveform profile consists of a single waveform, grab WaveformDuration from the method object *)
						MatchQ[waveformProfile, ObjectP[Object[Method, Waveform]]],
						Lookup[fetchPacketFromCache[Download[waveformProfile, Object], fullCache], WaveformDuration],

						(* If the resolved waveform profile consists of multiple waveforms, grab WaveformDuration from the first method object *)
						MatchQ[waveformProfile, {{TimeP, ObjectP[Object[Method, Waveform]]}...}],
						Lookup[fetchPacketFromCache[#, fullCache], WaveformDuration]& /@ Download[waveformProfile[[All, 2]], Object],

						(* If the resolved waveform profile consists of a tuple in the form of {Time,Voltage,Boolean,Boolean}, get the last time point to be the waveform duration *)
						MatchQ[waveformProfile, {{TimeP, VoltageP, BooleanP, BooleanP}...}],
						Last[waveformProfile][[1]],

						(* If the resolved waveform profile consists of multiple tuples in the form of {Time,{Time,Voltage,Boolean,Boolean}}, get the last time point of all waveforms *)
						MatchQ[waveformProfile, {{TimeP, {{TimeP, VoltageP, BooleanP, BooleanP}...}...}...}],
						(Last /@ Last /@ waveformProfile)[[All, 1]],

						True,
						Null
					];

					(* We need to check if the specified waveforms have multiple duration *)
					multipleWaveformDurationQ = Module[{uniqueDuration},
						uniqueDuration = DeleteDuplicates[ToList[waveformDuration]];
						(* If so, set the error tracking variable to True, otherwise set it to False *)
						If[Length[uniqueDuration] == 1,
							False,
							True
						]
					];

					electrochemicalSamplingRate = Which[

						(* If the user specified sampling rate for electrochemical detection, go with it *)
						MatchQ[electrochemicalsamplingrate, Except[Automatic]],
						electrochemicalsamplingrate,

						MatchQ[electrochemicalDetectionMode, Null | {Null}],
						Null,

						(* If the user is using DC Amperometry, set it to 1.67 Hz, which is the default Chromeleon gives *)
						MatchQ[electrochemicalDetectionMode, DCAmperometricDetection],
						1.67 / Second,

						(* If the user is using Integrated Amperometry, then we set sampling rate based on the resolved waveform duration *)
						MatchQ[waveformProfile, Except[Null]],
						1 / (Convert[ToList[waveformDuration][[1]], Second]),

						True,
						Null
					];

					detectionTemperature = Which[

						(* If the user specified sampling rate for electrochemical detection, go with it *)
						MatchQ[detectiontemperature, Except[Automatic]],
						detectiontemperature,

						MatchQ[electrochemicalDetectionMode, Null | {Null}],
						Null,

						(* If not specified, use the first resolved detection temperature for the sample *)
						MatchQ[resolvedDetectionTemperature, Except[Automatic | Null]],
						ToList[resolvedDetectionTemperature][[1]],

						(* Otherwise default to ambient temperature *)
						True,
						Ambient
					];


					(*return everything*)
					{
						columnTemperature,
						gradientFinal,
						gradientA,
						gradientB,
						gradientC,
						gradientD,
						flowRate,
						gradientStart,
						gradientEnd,
						duration,
						absorbanceWavelength,
						absorbanceSamplingRate,
						electrochemicalDetectionMode,
						referenceElectrodeMode,
						voltageProfile,
						waveformProfile,
						electrochemicalSamplingRate,
						detectionTemperature,
						gradientConsistentQ,
						gradientStartEndSpecifiedQ,
						durationOptionsSpecifiedQ,
						invalidGradientCompositionQ,
						removedExtrasQ,
						incompatibleFlowRateQ,
						durationConsistentQ,
						overwriteCleaningGradientQ,
						absorbanceOptionConflictQ,
						electrochemicalOptionConflictQ,
						electrochemicalModeOptionConflictQ,
						multipleDetectionModeQ,
						waveformDetectionModeConflictQ,
						multipleWaveformDurationQ,
						voltageProfileDuplicateTimeQ,
						waveformProfileDuplicateTimeQ
					}
				]
			],
				{
					{
						resolvedColumnRefreshFrequency, Null | None | Last, specifiedColumnPrimeGradientA, specifiedColumnPrimeGradientB, specifiedColumnPrimeGradientC, specifiedColumnPrimeGradientD, specifiedColumnPrimeGradient, specifiedColumnPrimeFlowRate, specifiedColumnPrimeStart, specifiedColumnPrimeEnd, specifiedColumnPrimeDuration, ColumnPrime, defaultCationPrimeGradientIC, specifiedColumnPrimeTemperature,
						specifiedColumnPrimeAbsorbanceWavelength, specifiedColumnPrimeAbsorbanceSamplingRate, specifiedColumnPrimeElectrochemicalDetectionMode, specifiedColumnPrimeReferenceElectrodeMode, specifiedColumnPrimeVoltageProfile, specifiedColumnPrimeWaveformProfile, specifiedColumnPrimeElectrochemicalSamplingRate, specifiedColumnPrimeDetectionTemperature
					},
					{
						resolvedColumnRefreshFrequency, Except[FirstAndLast | Last], specifiedColumnFlushGradientA, specifiedColumnFlushGradientB, specifiedColumnFlushGradientC, specifiedColumnFlushGradientD, specifiedColumnFlushGradient, specifiedColumnFlushFlowRate, specifiedColumnFlushStart, specifiedColumnFlushEnd, specifiedColumnFlushDuration, ColumnFlush, defaultCationFlushGradientIC, specifiedColumnFlushTemperature,
						specifiedColumnFlushAbsorbanceWavelength, specifiedColumnFlushAbsorbanceSamplingRate, specifiedColumnFlushElectrochemicalDetectionMode, specifiedColumnFlushReferenceElectrodeMode, specifiedColumnFlushVoltageProfile, specifiedColumnFlushWaveformProfile, specifiedColumnFlushElectrochemicalSamplingRate, specifiedColumnFlushDetectionTemperature
					}
				}
			]
		];


		(* == Error checking for column prime and column flush options == *)
		(* 1. If ColumnPrimeGradient is specified simultaenously in the option and the InjectionTable as method object, they should be consistent with each other *)
		(* If there are any missing cation gradient and we are throwing messages, then throw an error message and collect invalid options *)
		inconsistentColumnPrimeGradientOptions = If[columnPrimeGradientConsistentErrors && messagesQ,
			(
				Message[Error::InconsistentRefreshGradientSpecification, "column prime"];
				{ColumnPrimeGradient, ElectrochemicalInjectionTable}
			),
			{}
		];

		(* Generate test for missing specification among cation gradient start, end and duration *)
		inconsistentColumnPrimeGradientTests = testOrNull["If specified, gradient methods in the ColumnPrimeGradient option and the ElectrochemicalInjectionTable must be consistent:", Not[columnPrimeGradientConsistentErrors]];

		(* 2. If CationColumnFlushGradient is specified simultaenously in the option and the InjectionTable as method object, they should be consistent with each other *)
		(* If there are any missing cation gradient and we are throwing messages, then throw an error message and collect invalid options *)
		inconsistentColumnFlushGradientOptions = If[columnFlushGradientConsistentErrors && messagesQ,
			(
				Message[Error::InconsistentRefreshGradientSpecification, "column flush"];
				{ColumnFlushGradient, ElectrochemicalInjectionTable}
			),
			{}
		];

		(* Generate test for missing specification among cation gradient start, end and duration *)
		inconsistentColumnFlushGradientTests = testOrNull["If specified, gradient methods in the ColumnFlushGradient option and the ElectrochemicalInjectionTable must be consistent:", Not[columnFlushGradientConsistentErrors]];

		(* 3. If either ColumnPrimeEluentGradient or CationColumnPrimeGradient is specified, the maximum concentration is within the range defined by the integrated eluent generator *)
		(* If there are any invalid cation gradient and we are throwing messages, then throw an error message and collect invalid options *)
		invalidColumnPrimeGradientCompositionOptions = If[invalidColumnPrimeGradientCompositionErrors && messagesQ,
			(
				Message[Error::InvalidRefreshGradientComposition, "cation column prime"];
				{ColumnPrimeGradientA, ColumnPrimeGradientB, ColumnPrimeGradientC, ColumnPrimeGradientD, ColumnPrimeGradient}
			),
			{}
		];

		(* Generate test for invalid cation gradient composition *)
		invalidColumnPrimeGradientCompositionTests = testOrNull["The specified ColumnPrimeGradient has maximum eluent concentrations less than the max concentration allowed by the eluent generator:", Not[invalidColumnPrimeGradientCompositionErrors]];

		(* 4. If either ColumnFlushEluentGradient or CationColumnFlushGradient is specified, the maximum concentration is within the range defined by the integrated eluent generator *)
		(* If there are any invalid cation gradient and we are throwing messages, then throw an error message and collect invalid options *)
		invalidColumnFlushGradientCompositionOptions = If[invalidColumnFlushGradientCompositionErrors && messagesQ,
			(
				Message[Error::InvalidRefreshGradientComposition, "cation column flush"];
				{ColumnFlushGradientA, ColumnFlushGradientB, ColumnFlushGradientC, ColumnFlushGradientD, ColumnFlushGradient}
			),
			{}
		];

		(* Generate test for invalid cation gradient composition *)
		invalidColumnFlushGradientCompositionTests = testOrNull["The specified ColumnFlushGradient has maximum eluent concentrations less than the max concentration allowed by the eluent generator:", Not[invalidColumnFlushGradientCompositionErrors]];

		(* 5. ColumnPrimeFlowRate has to be within the range supported by the instrument, and the column *)
		(* If there are any invalid anion flow rates and we are throwing messages, then throw an error message and collect invalid options *)
		(*incompatibleColumnPrimeFlowRateOptions=If[columnPrimeFlowRateErrors&&messagesQ,
            (
                Message[Error::IncompatibleColumnRefreshFlowRate,ColumnPrimeFlowRate,resolvedColumnPrimeFlowRate,resolvedInstrument,resolvedColumn,maxFlowRate];
                {ColumnPrimeFlowRate}
            ),
            {}
        ];

        (* Generate test for invalid anion gradient composition *)
        invalidColumnPrimeFlowRateTests=testOrNull["The specified ColumnPrimeFlowRate has maximum flow rate less than that supported by the instrument and the column:",Not[columnPrimeFlowRateErrors]];

        (* 6. ColumnPrimeFlowRate has to be within the range supported by the instrument, and the column *)
        (* If there are any invalid anion flow rates and we are throwing messages, then throw an error message and collect invalid options *)
        incompatibleColumnFlushFlowRateOptions=If[columnFlushFlowRateErrors&&messagesQ,
            (
                Message[Error::IncompatibleColumnRefreshFlowRate,ColumnFlushFlowRate,resolvedColumnFlushFlowRate,resolvedInstrument,resolvedColumn,maxFlowRate];
                {ColumnFlushFlowRate}
            ),
            {}
        ];

        (* Generate test for invalid anion gradient composition *)
        invalidColumnFlushFlowRateTests=testOrNull["The specified ColumnFlushFlowRate has maximum flow rate less than that supported by the instrument and the column:",Not[columnFlushFlowRateErrors]]; *)

		(* 7. ColumnPrimeStart, ColumnPrimeEnd, and ColumnPrimeDuration has to be specified or Nulled out together *)
		(* If there are any missing gradient and we are throwing messages, then throw an error message and collect invalid options *)
		notSpecifiedColumnPrimeGradientStartEndOptions = If[columnPrimeStartEndSpecifiedErrors && messagesQ,
			(
				Message[Error::HPICGradientStartEndConflict, {ColumnPrimeStart, ColumnPrimeEnd, ColumnPrimeDuration}, "column prime"];
				{ColumnPrimeStart, ColumnPrimeEnd, ColumnPrimeDuration}
			),
			{}
		];

		(* Generate test for missing specification among anion gradient start, end and duration *)
		notSpecifiedColumnPrimeGradientStartEndTests = testOrNull["ColumnPrimeStart and ColumnPrimeEnd should be specified or set to Null simultaneously:", Not[columnPrimeStartEndSpecifiedErrors]];

		(* 8. ColumnFlushStart, ColumnFlushEnd, and ColumnFlushDuration has to be specified or Nulled out together *)
		notSpecifiedColumnFlushGradientStartEndOptions = If[columnFlushStartEndSpecifiedErrors && messagesQ,
			(
				Message[Error::HPICGradientStartEndConflict, {ColumnFlushStart, ColumnFlushEnd, ColumnFlushDuration}, "column flush"];
				{ColumnFlushStart, ColumnFlushEnd, ColumnFlushDuration}
			),
			{}
		];

		(* Generate test for missing specification among anion gradient start, end and duration *)
		notSpecifiedColumnFlushGradientStartEndTests = testOrNull["ColumnFlushStart and ColumnFlushEnd should be specified or set to Null simultaneously:", Not[columnFlushStartEndSpecifiedErrors]];

		(* 9. Check if absorbance parameter specification is in conflict *)
		(* If the absorbance options are in conflict and we are throwing message, throw an error and collect invalid options *)
		invalidColumnPrimeAbsorbanceOptions = If[columnPrimeAbsorbanceOptionConflictErrors && messagesQ,
			(
				Message[Error::InvalidAbsorbanceOption, {ColumnPrimeAbsorbanceWavelength, ColumnPrimeAbsorbanceSamplingRate}];
				{ColumnPrimeAbsorbanceWavelength, ColumnPrimeAbsorbanceSamplingRate}
			),
			{}
		];

		(* Test for absorbance options *)
		columnPrimeAbsorbanceOptionTest = testOrNull["The column prime absorbance options are either both Null or both specified with a value:", Not[columnPrimeAbsorbanceOptionConflictErrors]];



		(* 10. Check if absorbance parameter specification is in conflict *)
		(* If the absorbance options are in conflict and we are throwing message, throw an error and collect invalid options *)
		invalidColumnFlushAbsorbanceOptions = If[columnFlushAbsorbanceOptionConflictErrors && messagesQ,
			(
				Message[Error::InvalidAbsorbanceOption, {ColumnFlushAbsorbanceWavelength, ColumnFlushAbsorbanceSamplingRate}];
				{ColumnFlushAbsorbanceWavelength, ColumnFlushAbsorbanceSamplingRate}
			),
			{}
		];

		(* Test for absorbance options *)
		columnFlushAbsorbanceOptionTest = testOrNull["The column flush absorbance options are either both Null or both specified with a value:", Not[columnFlushAbsorbanceOptionConflictErrors]];

		(* 10.1 Check if absorbance parameter specification is in conflict *)
		(* If the absorbance options are in conflict and we are throwing message, throw an error and collect invalid options *)
		invalidColumnPrimeElectrochemicalOptions = If[MemberQ[ToList@columnPrimeElectrochemicalOptionConflictErrors, True] && messagesQ,
			(
				Message[Error::InvalidElectrochemicalOption, {ColumnPrimeElectrochemicalDetectionMode, ColumnPrimeReferenceElectrodeMode, ColumnPrimeElectrochemicalSamplingRate, ColumnPrimeDetectionTemperature}];
				{ColumnPrimeElectrochemicalDetectionMode, ColumnPrimeReferenceElectrodeMode, ColumnPrimeElectrochemicalSamplingRate, ColumnPrimeDetectionTemperature}
			),
			{}
		];

		(* Test for absorbance options *)
		columnPrimeElectrochemicalOptionTest = testOrNull["The column prime electrochemical options are not set to Null if Detector is set to ElectrochemicalDetector:", Not[columnPrimeElectrochemicalOptionConflictErrors]];

		(* 10.2 Check if absorbance parameter specification is in conflict *)
		(* If the absorbance options are in conflict and we are throwing message, throw an error and collect invalid options *)
		invalidColumnFlushElectrochemicalOptions = If[MemberQ[ToList@columnFlushElectrochemicalOptionConflictErrors, True] && messagesQ,
			(
				Message[Error::InvalidElectrochemicalOption, {ColumnFlushElectrochemicalDetectionMode, ColumnFlushReferenceElectrodeMode, ColumnFlushElectrochemicalSamplingRate, ColumnFlushDetectionTemperature}];
				{ColumnFlushElectrochemicalDetectionMode, ColumnFlushReferenceElectrodeMode, ColumnFlushElectrochemicalSamplingRate, ColumnFlushDetectionTemperature}
			),
			{}
		];

		(* Test for absorbance options *)
		columnFlushElectrochemicalOptionTest = testOrNull["The column flush electrochemical options are not set to Null if Detector is set to ElectrochemicalDetector:", Not[columnFlushElectrochemicalOptionConflictErrors]];

		(* 11. Check if electrochemical detection mode related paramter specification is in conflict *)
		(* Specifically if ElectrochemicalDetectionMode is DCAmperometricDetection, then VoltageProfile cannot be Null; if it's any other mode, then WaveformProfile cannot be Null *)
		(* If the absorbance options are in conflict and we are throwing message, throw an error and collect invalid options *)
		invalidColumnPrimeElectrochemicalDetectionModeOptions = If[columnPrimeElectrochemicalModeOptionConflictErrors && messagesQ,
			(
				Message[Error::InvalidElectrochemicalDetectionModeOption, ColumnPrimeElectrochemicalDetectionMode, ColumnPrimeVoltageProfile, ColumnPrimeWaveformProfile];
				{ColumnPrimeElectrochemicalDetectionMode, ColumnPrimeVoltageProfile, ColumnPrimeWaveformProfile}
			),
			{}
		];

		(* Test for absorbance options *)
		columnPrimeElectrochemicalModeOptionTest = testOrNull["The column prime electrochemical detection mode options are set correctly. If detection mode is DCAmperometricDetection, BlankVoltageProfile cannot be Null; If detection mode is any other amperometric detection, BlankWaveformProfile cannot be Null:", Not[columnPrimeElectrochemicalModeOptionConflictErrors]];

		(* 12. Check if electrochemical detection mode related paramter specification is in conflict *)
		(* Specifically if ElectrochemicalDetectionMode is DCAmperometricDetection, then VoltageProfile cannot be Null; if it's any other mode, then WaveformProfile cannot be Null *)
		(* If the absorbance options are in conflict and we are throwing message, throw an error and collect invalid options *)
		invalidColumnFlushElectrochemicalDetectionModeOptions = If[columnFlushElectrochemicalModeOptionConflictErrors && messagesQ,
			(
				Message[Error::InvalidElectrochemicalDetectionModeOption, ColumnFlushElectrochemicalDetectionMode, ColumnFlushVoltageProfile, ColumnFlushWaveformProfile];
				{ColumnFlushElectrochemicalDetectionMode, ColumnFlushVoltageProfile, ColumnFlushWaveformProfile}
			),
			{}
		];

		(* Test for absorbance options *)
		columnFlushElectrochemicalModeOptionTest = testOrNull["The column flush electrochemical detection mode options are set correctly. If detection mode is DCAmperometricDetection, BlankVoltageProfile cannot be Null; If detection mode is any other amperometric detection, BlankWaveformProfile cannot be Null:", Not[columnPrimeElectrochemicalModeOptionConflictErrors]];

		(* 13. Check if the specified waveforms render several detection modes *)
		(* If the waveform specified give more than 1 electrochemical detection mode and we are throwing message, throw a warning *)
		multipleColumnPrimeDetectionModeOptions = If[multipleColumnPrimeDetectionModeErrors && messagesQ && notInEngine,
			(
				Message[Warning::MultipleElectrochemicalDetectionModes, ColumnPrimeWaveformProfile, ColumnPrimeElectrochemicalDetectionMode];
				{}
			),
			{}
		];

		(* Test for absorbance options *)
		multipleColumnPrimeDetectionModeOptionTest = warningOrNull["The specified waveforms in ColumnPrimeWaveformProfile option or in the injection table have a unique ElectrochemicalDetectionMode value:", Not[multipleColumnPrimeDetectionModeErrors]];

		(* 14. Check if the specified waveforms render several detection modes *)
		(* If the waveform specified give more than 1 electrochemical detection mode and we are throwing message, throw a warning *)
		multipleColumnFlushDetectionModeOptions = If[multipleColumnFlushDetectionModeErrors && messagesQ && notInEngine,
			(
				Message[Warning::MultipleElectrochemicalDetectionModes, ColumnFlushWaveformProfile, ColumnFlushElectrochemicalDetectionMode];
				{}
			),
			{}
		];

		(* Test for absorbance options *)
		multipleColumnFlushDetectionModeOptionTest = warningOrNull["The specified waveforms in ColumnFlushWaveformProfile option or in the injection table have a unique ElectrochemicalDetectionMode value:", Not[multipleColumnFlushDetectionModeErrors]];

		(* 15. Check if the specified waveforms and the specified detection modes are consistent *)
		(* If the two options have conflicting values, throw an error and collect invalid options *)
		invalidColumnPrimeWaveformDetectionModeOptions = If[columnPrimeWaveformDetectionModeErrors && messagesQ,
			(
				Message[Error::ConflictingElectrochemicalDetectionModes, ColumnPrimeWaveformProfile, ColumnPrimeElectrochemicalDetectionMode];
				{ColumnPrimeWaveformProfile, ColumnPrimeElectrochemicalDetectionMode}
			),
			{}
		];

		(* Test for absorbance options *)
		invalidColumnPrimeWaveformDetectionModeTest = testOrNull["The specified waveforms in ColumnPrimeWaveformProfile option or in the injection table have consistent ElectrochemicalDetectionMode:", Not[multipleColumnPrimeDetectionModeErrors]];

		(* 16. Check if the specified waveforms and the specified detection modes are consistent *)
		(* If the two options have conflicting values, throw an error and collect invalid options *)
		invalidColumnFlushWaveformDetectionModeOptions = If[columnFlushWaveformDetectionModeErrors && messagesQ,
			(
				Message[Error::ConflictingElectrochemicalDetectionModes, ColumnFlushWaveformProfile, ColumnFlushElectrochemicalDetectionMode];
				{ColumnFlushWaveformProfile, ColumnFlushElectrochemicalDetectionMode}
			),
			{}
		];

		(* Test for absorbance options *)
		invalidColumnFlushWaveformDetectionModeTest = testOrNull["The specified waveforms in ColumnFlushWaveformProfile option or in the injection table have consistent ElectrochemicalDetectionMode:", Not[multipleColumnFlushDetectionModeErrors]];

		(* 17. Check if the specified waveforms have the same duration *)
		(* If the specified waveforms have different duration and we are throwing messages, throw an error and collect invalid options *)
		multipleColumnPrimeWaveformDurationOptions = If[multipleColumnPrimeWaveformDurationErrors && messagesQ,
			(
				Message[Error::ColumnRefreshMultipleWaveformDuration, "column prime", ObjectToString[resolvedInstrument, Cache -> fullCache, Simulation -> updatedSimulation]];
				{ColumnPrimeWaveformProfile, ColumnPrimeElectrochemicalSamplingRate}
			),
			{}
		];

		(* Test for absorbance options *)
		multipleColumnPrimeWaveformDurationTest = testOrNull["The specified waveforms all have the same waveform duration:", Not[multipleColumnPrimeWaveformDurationErrors]];

		(* 18. Check if the specified waveforms have the same duration *)
		(* If the specified waveforms have different duration and we are throwing messages, throw an error and collect invalid options *)
		multipleColumnFlushWaveformDurationOptions = If[multipleColumnFlushWaveformDurationErrors && messagesQ,
			(
				Message[Error::ColumnRefreshMultipleWaveformDuration, "column flush", ObjectToString[resolvedInstrument, Cache -> fullCache, Simulation -> updatedSimulation]];
				{ColumFlushWaveformProfile, ColumnFlushElectrochemicalSamplingRate}
			),
			{}
		];

		(* Test for absorbance options *)
		multipleColumnFlushWaveformDurationTest = testOrNull["The specified waveforms all have the same waveform duration:", Not[multipleColumnFlushWaveformDurationErrors]];

		(* 19. Check if the times specified in voltage profile is monotonically increasing *)
		(* If the specified voltage profile has duplicate or decreasing time and we are throwing messages, throw an error and collect invalid options *)
		columnPrimeVoltageProfileTimeOptions = If[duplicateColumnPrimeVoltageProfileTimeErrors && messagesQ,
			(
				Message[Error::InvalidTimeSpecification, ColumnPrimeVoltageProfile];
				{ColumnPrimeVoltageProfile}
			),
			{}
		];

		(* Test for absorbance options *)
		columnPrimeVoltageProfileTimeTest = testOrNull["The specified VoltageProfile in the form of {Time,Voltage} have monotonically increasing time:", Not[duplicateColumnPrimeVoltageProfileTimeErrors]];

		(* 20. Check if the times specified in voltage profile is monotonically increasing *)
		(* If the specified voltage profile has duplicate or decreasing time and we are throwing messages, throw an error and collect invalid options *)
		columnFlushVoltageProfileTimeOptions = If[duplicateColumnFlushVoltageProfileTimeErrors && messagesQ,
			(
				Message[Error::InvalidTimeSpecification, ColumnFlushVoltageProfile];
				{ColumnFlushVoltageProfile}
			),
			{}
		];

		(* Test for absorbance options *)
		columnFlushVoltageProfileTimeTest = testOrNull["The specified VoltageProfile in the form of {Time,Voltage} have monotonically increasing time:", Not[duplicateColumnFlushVoltageProfileTimeErrors]];

		(* 21. Check if the times specified in voltage profile is monotonically increasing *)
		(* If the specified voltage profile has duplicate or decreasing time and we are throwing messages, throw an error and collect invalid options *)
		columnPrimeWaveformProfileTimeOptions = If[MemberQ[duplicateColumnPrimeWaveformProfileTimeErrors, True] && messagesQ,
			(
				Message[Error::InvalidTimeSpecification, ColumnPrimeWaveformProfile];
				{ColumnPrimeWaveformProfile}
			),
			{}
		];

		(* Test for absorbance options *)
		columnPrimeWaveformProfileTimeTest = testOrNull["The specified ColumnPrimeWaveformProfile in the form of {Time,Voltage,Interpolation,Integration} or {Time,{Time,Voltage,Interpolation,Integration}} have monotonically increasing time:", Not[duplicateColumnPrimeWaveformProfileTimeErrors]];

		(* 22. Check if the times specified in voltage profile is monotonically increasing *)
		(* If the specified voltage profile has duplicate or decreasing time and we are throwing messages, throw an error and collect invalid options *)
		columnFlushWaveformProfileTimeOptions = If[MemberQ[duplicateColumnFlushWaveformProfileTimeErrors, True] && messagesQ,
			(
				Message[Error::InvalidTimeSpecification, ColumnFlushWaveformProfile];
				{ColumnFlushWaveformProfile}
			),
			{}
		];

		(* Test for absorbance options *)
		columnFlushWaveformProfileTimeTest = testOrNull["The specified ColumnFlushWaveformProfile in the form of {Time,Voltage,Interpolation,Integration} or {Time,{Time,Voltage,Interpolation,Integration}} have monotonically increasing time:", Not[duplicateColumnFlushWaveformProfileTimeErrors]];

		(* 44.19 If gradient duration is specified, either gradient start & end or eluent gradient is specified *)
		(* If there are any missing anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
		notSpecifiedColumnPrimeGradientDurationOptions = If[MemberQ[ToList@columnPrimeDurationOptionSpecifiedErrors, True] && messagesQ,
			(
				Message[Error::HPICGradientShortcutConflict, ColumnPrimeDuration, {ColumnPrimeStart, ColumnPrimeEnd}, "ColumnPrimeGradientA/B/C/D"];
				{ColumnPrimeStart, ColumnPrimeEnd, ColumnPrimeDuration, ColumnPrimeGradientA, ColumnPrimeGradientB, ColumnPrimeGradientC, ColumnPrimeGradientD}
			),
			{}
		];

		(* Generate test for missing specification among anion gradient start, end and duration *)
		notSpecifiedColumnPrimeGradientDurationTests = testOrNull["ColumnPrimeGradientDuration should be specified either with ColumnPrimeGradientStart/ColumnPrimeGradientEnd or any of the ColumnPrimeGradientA/B/C/D:", Not[columnPrimeDurationOptionSpecifiedErrors]];

		(* 44.20 If gradient duration is specified, either gradient start & end or eluent gradient is specified *)
		(* If there are any missing anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
		notSpecifiedColumnFlushGradientDurationOptions = If[MemberQ[ToList@columnFlushDurationOptionSpecifiedErrors, True] && messagesQ,
			(
				Message[Error::HPICGradientShortcutConflict, ColumnFlushDuration, {ColumnFlushStart, ColumnFlushEnd}, "ColumnFlushGradientA/B/C/D"];
				{ColumnFlushStart, ColumnFlushEnd, ColumnFlushDuration, ColumnFlushGradientA, ColumnFlushGradientB, ColumnFlushGradientC, ColumnFlushGradientD}
			),
			{}
		];

		(* Generate test for missing specification among anion gradient start, end and duration *)
		notSpecifiedColumnFlushGradientDurationTests = testOrNull["ColumnFlushGradientDuration should be specified either with ColumnFlushGradientStart/ColumnFlushGradientEnd or any of the ColumnFlushGradientA/B/C/D:", Not[columnFlushDurationOptionSpecifiedErrors]];

		(* 37.9 If gradient duration and eluent gradient are both specified, their specified values are consistent *)
		(* If there are any missing anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
		inconsistentColumnPrimeGradientDurationOptions = If[MemberQ[ToList@columnPrimeDurationConsistentErrors, True] && messagesQ && notInEngine,
			(
				Message[Warning::HPICGradientShortcutAmbiguity, ColumnPrimeDuration, "ColumnPrimeGradientA/B/C/D"];
				{}
			),
			{}
		];

		(* Generate test for missing specification among anion gradient start, end and duration *)
		consistentColumnPrimeGradientDurationTests = warningOrNull["Specified values for ColumnPrimeGradientDuration and ColumnPrimeGradientA/B/C/D are consistent:", Not[columnPrimeDurationConsistentErrors]];

		(* 37.10 If gradient duration and eluent gradient are both specified, their specified values are consistent *)
		(* If there are any missing anion gradient and we are throwing messages, then throw an error message and collect invalid options *)
		inconsistentColumnFlushGradientDurationOptions = If[MemberQ[ToList@columnPrimeDurationConsistentErrors, True] && messagesQ && notInEngine,
			(
				Message[Warning::HPICGradientShortcutAmbiguity, ColumnFlushDuration, "ColumnFlushGradientA/B/C/D"];
				{}
			),
			{}
		];

		(* Generate test for missing specification among anion gradient start, end and duration *)
		consistentColumnFlushGradientDurationTests = warningOrNull["Specified values for ColumnFlushGradientDuration and ColumnFlushGradientA/B/C/D are consistent:", Not[columnFlushDurationConsistentErrors]];


		(* 44.18 Check if any of the gradient is too long, e.g. longer than a week here *)
		maxGradientTimeLimit = 1 Week;

		{
			maxTimesAnionSamples,
			maxTimesAnionStandards,
			maxTimesAnionBlanks,
			maxTimeAnionColumnPrime,
			maxTimeAnionColumnFlush
		} = Map[
			Function[{analyticalGradientList},
				If[!MatchQ[analyticalGradientList, ListableP[Null]],
					Map[
						Function[{gradientTuples},
							(*the last tuple point should be the max time*)
							If[MatchQ[gradientTuples, ObjectP[Object[Method]]],
								gradientTuples[AnionGradient][[-1, 1]],
								gradientTuples[[-1, 1]]
							]
						],
						analyticalGradientList
					],
					{}
				]
			],
			{
				resolvedAnionGradient,
				resolvedAnionStandardGradient,
				resolvedAnionBlankGradient,
				List[resolvedAnionColumnPrimeGradient],
				List[resolvedAnionColumnFlushGradient]
			}
		];

		{
			maxTimesCationSamples,
			maxTimesCationStandards,
			maxTimesCationBlanks,
			maxTimeCationColumnPrime,
			maxTimeCationColumnFlush
		} = Map[
			Function[{analyticalGradientList},
				If[!MatchQ[analyticalGradientList, ListableP[Null]],
					Map[
						Function[{gradientTuples},
							(*the last tuple point should be the max time*)
							If[MatchQ[gradientTuples, ObjectP[Object[Method]]],
								gradientTuples[CationGradient][[-1, 1]],
								gradientTuples[[-1, 1]]
							]
						],
						analyticalGradientList
					],
					{}
				]
			],
			{
				resolvedCationGradient,
				resolvedCationStandardGradient,
				resolvedCationBlankGradient,
				List[resolvedCationColumnPrimeGradient],
				List[resolvedCationColumnFlushGradient]
			}
		];

		(*check if we have any gradients that are too long*)
		{
			maxTimeAnionSampleQ,
			maxTimeCationSampleQ,
			maxTimeAnionStandardQ,
			maxTimeCationStandardQ,
			maxTimeAnionBlankQ,
			maxTimeCationBlankQ,
			maxTimeAnionColumnPrimeQ,
			maxTimeCationColumnPrimeQ,
			maxTimeAnionColumnFlushQ,
			maxTimeCationColumnFlushQ
		} = Map[
			Function[{maxTimeList},
				MemberQ[maxTimeList, GreaterP[maxGradientTimeLimit]]
			],
			{
				maxTimesAnionSamples,
				maxTimesCationSamples,
				maxTimesAnionStandards,
				maxTimesCationStandards,
				maxTimesAnionBlanks,
				maxTimesCationBlanks,
				maxTimeAnionColumnPrime,
				maxTimeCationColumnPrime,
				maxTimeAnionColumnFlush,
				maxTimeCationColumnFlush
			}
		];

		(*do the error checking if need be*)


		(*Throw a warning whenever we're overwriting any of the gradient*)
		overwriteOptionBool = Map[
			Or @@ #&,
			{
				overwriteAnionGradientBool,
				overwriteCationGradientBool,
				overwriteGradientBool,
				overwriteAnionStandardGradientBool,
				overwriteCationStandardGradientBool,
				overwriteStandardGradientBool,
				overwriteAnionBlankGradientBool,
				overwriteCationBlankGradientBool,
				overwriteBlankGradientBool,
				overwriteAnionColumnPrimeGradientBool,
				overwriteCationColumnPrimeGradientBool,
				overwriteColumnPrimeGradientBool,
				overwriteAnionColumnFlushGradientBool,
				overwriteCationColumnFlushGradientBool,
				overwriteColumnFlushGradientBool
			}
		];

		(* if there is a mismatch between the Blank options and the injection table, throw an error *)
		If[messagesQ && Or @@ overwriteOptionBool && notInEngine,
			Message[Warning::OverwritingGradient, PickList[{AnionGradient, CationGradient, Gradient, AnionStandardGradient, CationStandardGradient, StandardGradient, AnionBlankGradient, CationBlankGradient,
				BlankGradient, AnionColumnPrimeGradient, CationColumnPrimeGradient, ColumnPrimeGradient, AnionColumnFlushGradient, CationColumnFlushGradient, ColumnFlushGradient}, overwriteOptionBool]]
		];


		(* 45. Standard Storage Conditions resolution *)

		compiledStandardInjectionVolumes = If[MemberQ[ToList@doubleResolvedStandardAnalysisChannel, ElectrochemicalChannel],

			resolvedStandardInjectionVolume,

			If[MatchQ[doubleResolvedStandardAnalysisChannel, {}],
				{},

				MapThread[
					(* Look at the standard analysis channel assignment of each standard *)
					Switch[#1,
						(* If its's AnionChannel, then find the position of the standard from the list of anion standard *)
						(* Finally pull out the injection volume from the list of resolved AnionStandardInjectionVolume *)
						AnionChannel,
						Part[Flatten[resolvedAnionStandardInjectionVolume], First@First@Position[ToList@Download[resolvedAnionStandard, Object], #2]],

						(* Repeat for cation standard *)
						CationChannel,
						Part[Flatten[resolvedCationStandardInjectionVolume], First@First@Position[ToList@Download[resolvedCationStandard, Object], #2]]
					]&,
					{ToList@doubleResolvedStandardAnalysisChannel, Download[Cases[ToList@resolvedStandard, Except[Null]], Object]}
				]
			]
		];

		resolvedStandardStorageCondition = Module[{standardVolume, modelStorageCondition},

			(* If there is no standard, resolve this option to Null *)
			If[MatchQ[resolvedStandard, Null | {Null} | {}] || MatchQ[compiledStandardInjectionVolumes, {}],
				Null,

				MapThread[Function[{standard, mapThreadFriendlyStandardOptions, standardInjectionVolume},

					standardVolume = Lookup[fetchPacketFromCache[Download[standard, Object], fullCache], Volume];
					modelStorageCondition = Lookup[fetchPacketFromCache[Download[standard, Object], fullCache], Model][DefaultStorageCondition][StorageCondition];

					Which[

						MatchQ[Lookup[mapThreadFriendlyStandardOptions, StandardStorageCondition], Except[Automatic]],
						Lookup[mapThreadFriendlyStandardOptions, StandardStorageCondition],

						MatchQ[standard, ObjectP[Model[Sample]]],
						Disposal,

						MatchQ[standard, ObjectP[Object[Sample]]],
						If[
							MatchQ[standardVolume, VolumeP],
							If[(standardVolume - standardInjectionVolume - autosamplerDeadVolume) > 500 Microliter,
								modelStorageCondition,
								Disposal
							],

							modelStorageCondition
						],

						True,
						modelStorageCondition
					]
				],
					{ToList@resolvedStandard, mapThreadFriendlyStandardOptions, compiledStandardInjectionVolumes}
				]
			]
		];

		(* 46. Blank Storage Condition resolution *)
		(* If there is no blank, resolve this option to Null *)
		resolvedBlankStorageCondition = If[MatchQ[resolvedBlank, Null | {Null} | {}],
			Null,

			Map[

				If[MatchQ[Lookup[#, BlankStorageCondition], Except[Automatic]],
					Lookup[#, BlankStorageCondition],
					Null
				]&,
				mapThreadFriendlyBlankOptions
			]
		];


		(* 47. The grand finale: INJECTION TABLE RESOLUTION! *)

		injectionTableAnionBlanks = If[MatchQ[anionInjectionTableLookupRounded, Null | Automatic],
			{},
			Cases[anionInjectionTableLookupRounded, {Blank, blank_, ___} :> blank]
		];

		injectionTableCationBlanks = If[MatchQ[cationInjectionTableLookupRounded, Null | Automatic],
			{},
			Cases[cationInjectionTableLookupRounded, {Blank, blank_, ___} :> blank]
		];

		injectionTableBlanks = If[MatchQ[electrochemicalInjectionTableLookupRounded, Null | Automatic],
			{},
			Cases[electrochemicalInjectionTableLookupRounded, {Blank, blank_, ___} :> blank]
		];

		injectionTableAnionStandards = If[MatchQ[anionInjectionTableLookupRounded, Null | Automatic],
			{},
			Cases[anionInjectionTableLookupRounded, {Standard, standard_, ___} :> standard]
		];

		injectionTableCationStandards = If[MatchQ[cationInjectionTableLookupRounded, Null | Automatic],
			{},
			Cases[cationInjectionTableLookupRounded, {Standard, standard_, ___} :> standard]
		];

		injectionTableStandards = If[MatchQ[electrochemicalInjectionTableLookupRounded, Null | Automatic],
			{},
			Cases[electrochemicalInjectionTableLookupRounded, {Standard, standard_, ___} :> standard]
		];

		(*we need to extract out the injection volume from the injection table*)
		injectionTableAnionStandardInjectionVolumes = Cases[anionInjectionTableLookupRounded, {Standard, _, _, injectionVolume_, _} :> injectionVolume];
		injectionTableCationStandardInjectionVolumes = Cases[cationInjectionTableLookupRounded, {Standard, _, _, injectionVolume_, _} :> injectionVolume];
		injectionTableStandardInjectionVolumes = Cases[electrochemicalInjectionTableLookupRounded, {Standard, _, injectionVolume_, _, _, _} :> injectionVolume];

		(*we need to extract our the injection volume from the injection table*)
		injectionTableAnionBlankInjectionVolumes = Cases[anionInjectionTableLookupRounded, {Blank, _, _, injectionVolume_, _} :> injectionVolume];
		injectionTableCationBlankInjectionVolumes = Cases[cationInjectionTableLookupRounded, {Blank, _, _, injectionVolume_, _} :> injectionVolume];
		injectionTableBlankInjectionVolumes = Cases[electrochemicalInjectionTableLookupRounded, {Blank, _, injectionVolume_, _, _, _} :> injectionVolume];

		(*we need to get all of the injection table gradients*)
		injectionTableAnionStandardGradients = Which[
			(*grab the gradients column of the injection table for standard samples*)
			standardExistsQ && anionInjectionTableSpecifiedQ, Cases[anionInjectionTableLookupRounded, {Standard, _, _, _, gradient_} :> gradient],
			(* otherwise just pad automatics *)
			standardExistsQ, ConstantArray[Automatic, Length[ToList@resolvedAnionStandard]],
			(* if no standard exists, then resolvedStandard is going to be {} so obvi no gradients either *)
			True, {}
		];

		(*we need to get all of the injection table gradients*)
		injectionTableCationStandardGradients = Which[
			(*grab the gradients column of the injection table for standard samples*)
			standardExistsQ && cationInjectionTableSpecifiedQ, Cases[anionInjectionTableSpecifiedQ, {Standard, _, _, _, gradient_} :> gradient],
			(* otherwise just pad automatics *)
			standardExistsQ, ConstantArray[Automatic, Length[ToList@resolvedCationStandard]],
			(* if no standard exists, then resolvedStandard is going to be {} so obvi no gradients either *)
			True, {}
		];

		(*we need to get all of the injection table gradients*)
		injectionTableStandardGradients = If[MemberQ[ToList@doubleResolvedStandardAnalysisChannel, ElectrochemicalChannel],
			Which[
				(*grab the gradients column of the injection table for standard samples*)
				standardExistsQ && electrochemicalInjectionTableSpecifiedQ, Cases[electrochemicalInjectionTableSpecifiedQ, {Standard, _, _, gradient_, _, _} :> gradient],
				(* otherwise just pad automatics *)
				standardExistsQ, ConstantArray[Automatic, Length[ToList@resolvedStandard]],
				(* if no standard exists, then resolvedStandard is going to be {} so obvi no gradients either *)
				True, {}
			],
			{}
		];

		injectionTableAnionBlankGradients = Which[
			(*grab the gradients column of the injection table for blank samples*)
			blankExistsQ && anionInjectionTableSpecifiedQ, Cases[anionInjectionTableSpecifiedQ, {Blank, _, _, _, gradient_} :> gradient],
			(* otherwise just pad automatics *)
			blankExistsQ, ConstantArray[Automatic, Length[doubleResolvedAnionBlank]],
			(* if no standard exists, then resolvedBlank is going to be {} so obvi no gradients either *)
			True, {}
		];

		injectionTableCationBlankGradients = Which[
			(*grab the gradients column of the injection table for blank samples*)
			blankExistsQ && cationInjectionTableSpecifiedQ, Cases[cationInjectionTableSpecifiedQ, {Blank, _, _, _, gradient_} :> gradient],
			(* otherwise just pad automatics *)
			blankExistsQ, ConstantArray[Automatic, Length[doubleResolvedCationBlank]],
			(* if no standard exists, then resolvedBlank is going to be {} so obvi no gradients either *)
			True, {}
		];

		(*we need to get all of the injection table gradients*)
		injectionTableBlankGradients = If[MemberQ[ToList@doubleResolvedBlankAnalysisChannel, ElectrochemicalChannel],
			Which[
				(*grab the gradients column of the injection table for standard samples*)
				blankExistsQ && electrochemicalInjectionTableSpecifiedQ, Cases[electrochemicalInjectionTableSpecifiedQ, {Blank, _, _, gradient_, _, _} :> gradient],
				(* otherwise just pad automatics *)
				blankExistsQ, ConstantArray[Automatic, Length[ToList@resolvedBlank]],
				(* if no standard exists, then resolvedStandard is going to be {} so obvi no gradients either *)
				True, {}
			],
			{}
		];

		(*we must adjust the overwrite if the standards and blanks are imbalanced in the injection table*)
		adjustedOverwriteAnionStandardBool = Which[
			Length[injectionTableAnionStandardGradients] > Length[resolvedAnionStandardGradient] && !MatchQ[injectionTableAnionStandardGradients, {} | Null], PadRight[overwriteAnionStandardGradientBool, Length[injectionTableAnionStandardGradients], False],
			Length[injectionTableAnionStandardGradients] < Length[resolvedAnionStandardGradient] && !MatchQ[injectionTableAnionStandardGradients, {} | Null], Take[overwriteAnionStandardGradientBool, Length[injectionTableAnionStandardGradients]],
			True, overwriteAnionStandardGradientBool
		];

		(*we must adjust the overwrite if the standards and blanks are imbalanced in the injection table*)
		adjustedOverwriteCationStandardBool = Which[
			Length[injectionTableCationStandardGradients] > Length[resolvedCationStandardGradient] && !MatchQ[injectionTableCationStandardGradients, {} | Null], PadRight[overwriteCationStandardGradientBool, Length[injectionTableCationStandardGradients], False],
			Length[injectionTableCationStandardGradients] < Length[resolvedCationStandardGradient] && !MatchQ[injectionTableCationStandardGradients, {} | Null], Take[overwriteCationStandardGradientBool, Length[injectionTableCationStandardGradients]],
			True, overwriteCationStandardGradientBool
		];

		adjustedOverwriteAnionBlankBool = Which[
			Length[injectionTableAnionBlankGradients] > Length[resolvedAnionBlankGradient] && !MatchQ[injectionTableAnionBlankGradients, {} | Null], PadRight[overwriteAnionBlankGradientBool, Length[injectionTableAnionBlankGradients], False],
			Length[injectionTableAnionBlankGradients] < Length[resolvedAnionBlankGradient] && !MatchQ[injectionTableAnionBlankGradients, {} | Null], Take[overwriteAnionBlankGradientBool, Length[injectionTableAnionBlankGradients]],
			True, overwriteAnionBlankGradientBool
		];

		adjustedOverwriteCationBlankBool = Which[
			Length[injectionTableCationBlankGradients] > Length[resolvedCationBlankGradient] && !MatchQ[injectionTableCationBlankGradients, {} | Null], PadRight[overwriteCationBlankGradientBool, Length[injectionTableCationBlankGradients], False],
			Length[injectionTableCationBlankGradients] < Length[resolvedCationBlankGradient] && !MatchQ[injectionTableCationBlankGradients, {} | Null], Take[overwriteCationBlankGradientBool, Length[injectionTableCationBlankGradients]],
			True, overwriteCationBlankGradientBool
		];

		(*we'll need to combine all of the relevant options for the injection table*)
		(* note that we are kind of cheating here for the Column value because the FPLC injection table doesn't actually _have_ columns,
         and so it doesn't actually matter what we put there, as long as it makes Karthik's great resolveInjectionTable function work properly (and then we will delete the injection table column afterwards) *)
		resolvedOptionsForInjectionTable = Association[
			ChannelSelection -> resolvedChannelSelection,

			(* Anion options *)
			AnionSamples -> resolvedAnionSamples,
			AnionColumn -> If[NullQ[resolvedAnionColumn], Null, ToList@resolvedAnionColumn],
			AnionInjectionVolume -> resolvedAnionInjectionVolume,
			AnionGradient -> ToList@resolvedAnionGradient /. Null -> Nothing,
			AnionGradientOverwrite -> If[MatchQ[resolvedAnionSamples, {}],
				{},
				ToList@overwriteAnionGradientBool
			],

			AnionStandard -> If[MatchQ[injectionTableAnionStandards, {} | Null] || Length[injectionTableAnionStandards] == Length[ToList@resolvedAnionStandard],
				resolvedAnionStandard,
				injectionTableAnionStandards
			],
			AnionStandardFrequency -> resolvedAnionStandardFrequency,
			AnionStandardInjectionVolume -> If[MatchQ[injectionTableAnionStandardInjectionVolumes, {}] || Length[injectionTableAnionStandardInjectionVolumes] == Length[resolvedAnionStandardInjectionVolume],
				resolvedAnionStandardInjectionVolume,
				injectionTableAnionStandardInjectionVolumes
			],
			AnionStandardGradient -> If[(MatchQ[injectionTableAnionStandardGradients, {}] || Length[injectionTableAnionStandardGradients] == Length[resolvedAnionStandardGradient]),
				ToList@resolvedAnionStandardGradient /. Null -> Nothing,
				injectionTableAnionStandardGradients
			],
			AnionStandardGradientOverwrite -> If[MatchQ[resolvedAnionStandard, {}],
				{},
				ToList@overwriteAnionStandardGradientBool
			],

			AnionBlank -> If[MatchQ[injectionTableAnionBlanks, {} | Null] || Length[injectionTableAnionBlanks] == Length[doubleResolvedAnionBlank],
				doubleResolvedAnionBlank,
				injectionTableAnionBlanks
			],
			AnionBlankFrequency -> resolvedAnionBlankFrequency,
			AnionBlankInjectionVolume -> If[MatchQ[injectionTableAnionBlankInjectionVolumes, {} | Null] || Length[injectionTableAnionBlankInjectionVolumes] == Length[resolvedAnionBlankInjectionVolume],
				resolvedAnionBlankInjectionVolume,
				injectionTableAnionBlankInjectionVolumes
			],
			AnionBlankGradient -> If[(MatchQ[injectionTableAnionBlankGradients, {} | Null] || Length[injectionTableAnionBlankGradients] == Length[resolvedAnionBlankGradient]),
				ToList@resolvedAnionBlankGradient /. Null -> Nothing,
				injectionTableAnionBlankGradients
			],
			AnionBlankGradientOverwrite -> If[MatchQ[doubleResolvedAnionBlank, {}],
				{},
				ToList@overwriteAnionBlankGradientBool
			],

			AnionColumnRefreshFrequency -> resolvedAnionColumnRefreshFrequency,
			AnionColumnPrimeGradient -> If[MatchQ[Lookup[roundedOptionsAssociation, AnionColumnPrimeGradient], ObjectP[Object[Method, IonChromatographyGradient]]],
				Lookup[roundedOptionsAssociation, AnionColumnPrimeGradient],
				resolvedAnionColumnPrimeGradient /. Null -> {}
			],
			AnionColumnFlushGradient -> If[MatchQ[Lookup[roundedOptionsAssociation, AnionColumnFlushGradient], ObjectP[Object[Method, IonChromatographyGradient]]],
				Lookup[roundedOptionsAssociation, AnionColumnFlushGradient],
				resolvedAnionColumnFlushGradient /. Null -> {}
			],
			AnionColumnPrimeGradientOverwrite -> ToList@overwriteAnionColumnPrimeGradientBool,
			AnionColumnFlushGradientOverwrite -> ToList@overwriteAnionColumnFlushGradientBool,
			AnionInjectionTable -> anionInjectionTableLookupRounded,


			(* Cation options *)
			CationSamples -> resolvedCationSamples,
			CationColumn -> If[NullQ[resolvedCationColumn], Null, ToList@resolvedCationColumn],
			CationInjectionVolume -> resolvedCationInjectionVolume,
			CationGradient -> ToList@resolvedCationGradient /. Null -> Nothing,
			CationGradientOverwrite -> If[MatchQ[resolvedCationSamples, {}],
				{},
				ToList@overwriteCationGradientBool
			],

			CationStandard -> If[MatchQ[injectionTableCationStandards, {} | Null] || Length[injectionTableCationStandards] == Length[ToList@resolvedCationStandard],
				resolvedCationStandard,
				injectionTableCationStandards
			],
			CationStandardFrequency -> resolvedCationStandardFrequency,
			CationStandardInjectionVolume -> If[MatchQ[injectionTableCationStandardInjectionVolumes, {}] || Length[injectionTableCationStandardInjectionVolumes] == Length[resolvedCationStandardInjectionVolume],
				resolvedCationStandardInjectionVolume,
				injectionTableCationStandardInjectionVolumes
			],
			CationStandardGradient -> If[(MatchQ[injectionTableCationStandardGradients, {}] || Length[injectionTableCationStandardGradients] == Length[resolvedCationStandardGradient]),
				ToList@resolvedCationStandardGradient /. Null -> Nothing,
				injectionTableCationStandardGradients
			],
			CationStandardGradientOverwrite -> If[MatchQ[resolvedCationStandard, {}],
				{},
				ToList@overwriteCationStandardGradientBool
			],

			CationBlank -> If[MatchQ[injectionTableCationBlanks, {} | Null] || Length[injectionTableCationBlanks] == Length[doubleResolvedCationBlank],
				doubleResolvedCationBlank,
				injectionTableCationBlanks
			],
			CationBlankFrequency -> resolvedCationBlankFrequency,
			CationBlankInjectionVolume -> If[MatchQ[injectionTableCationBlankInjectionVolumes, {} | Null] || Length[injectionTableCationBlankInjectionVolumes] == Length[resolvedCationBlankInjectionVolume],
				resolvedCationBlankInjectionVolume,
				injectionTableCationBlankInjectionVolumes
			],
			CationBlankGradient -> If[(MatchQ[injectionTableCationBlankGradients, {} | Null] || Length[injectionTableCationBlankGradients] == Length[resolvedCationBlankGradient]),
				ToList@resolvedCationBlankGradient /. Null -> Nothing,
				injectionTableCationBlankGradients
			],
			CationBlankGradientOverwrite -> If[MatchQ[doubleResolvedCationBlank, {}],
				{},
				ToList@overwriteCationBlankGradientBool
			],

			CationColumnRefreshFrequency -> resolvedCationColumnRefreshFrequency,
			CationColumnPrimeGradient -> If[MatchQ[Lookup[roundedOptionsAssociation, CationColumnPrimeGradient], ObjectP[Object[Method, IonChromatographyGradient]]],
				Lookup[roundedOptionsAssociation, CationColumnPrimeGradient],
				resolvedCationColumnPrimeGradient /. Null -> {}
			],
			CationColumnFlushGradient -> If[MatchQ[Lookup[roundedOptionsAssociation, CationColumnFlushGradient], ObjectP[Object[Method, IonChromatographyGradient]]],
				Lookup[roundedOptionsAssociation, CationColumnFlushGradient],
				resolvedCationColumnFlushGradient /. Null -> {}
			],
			CationColumnPrimeGradientOverwrite -> ToList@overwriteCationColumnPrimeGradientBool,
			CationColumnFlushGradientOverwrite -> ToList@overwriteAnionColumnFlushGradientBool,
			CationInjectionTable -> cationInjectionTableLookupRounded,


			(* Electrochemical options *)
			Column -> If[NullQ[resolvedColumn], Null, ToList@resolvedColumn],
			InjectionVolume -> resolvedInjectionVolume,
			Gradient -> ToList@resolvedGradient /. Null -> Nothing,
			GradientOverwrite -> If[MatchQ[resolvedGradient, Null | {}],
				{},
				ToList@overwriteGradientBool
			],
			ReferenceElectrodeMode -> resolvedReferenceElectrodeMode,
			VoltageProfile -> resolvedVoltageProfile,
			WaveformProfile -> resolvedWaveformProfile,

			Standard -> If[MemberQ[ToList@doubleResolvedStandardAnalysisChannel, ElectrochemicalChannel],
				If[MatchQ[injectionTableStandards, {} | Null] || Length[injectionTableStandards] == Length[ToList@resolvedStandard],
					resolvedStandard,
					injectionTableStandards
				],
				{}
			],
			StandardFrequency -> resolvedStandardFrequency,
			StandardInjectionVolume -> If[MemberQ[ToList@doubleResolvedStandardAnalysisChannel, ElectrochemicalChannel],
				If[MatchQ[injectionTableStandardInjectionVolumes, {} | Null] || Length[injectionTableStandardInjectionVolumes] == Length[ToList@resolvedStandardInjectionVolume],
					resolvedStandardInjectionVolume,
					injectionTableStandardInjectionVolumes
				],
				{}
			],
			StandardGradient -> If[MemberQ[ToList@doubleResolvedStandardAnalysisChannel, ElectrochemicalChannel],
				If[(MatchQ[injectionTableStandardGradients, {}] || Length[injectionTableStandardGradients] == Length[resolvedStandardGradient]),
					ToList@resolvedStandardGradient /. Null -> Nothing,
					injectionTableStandardGradients
				],
				{}
			],
			StandardGradientOverwrite -> If[MemberQ[ToList@doubleResolvedStandardAnalysisChannel, ElectrochemicalChannel],
				If[MatchQ[resolvedStandard, {} | Null],
					{},
					ToList@overwriteStandardGradientBool
				],
				{}
			],
			StandardReferenceElectrodeMode -> resolvedStandardReferenceElectrodeMode,
			StandardVoltageProfile -> resolvedStandardVoltageProfile,
			StandardWaveformProfile -> resolvedStandardWaveformProfile,

			Blank -> If[MemberQ[ToList@doubleResolvedBlankAnalysisChannel, ElectrochemicalChannel],
				If[MatchQ[injectionTableBlanks, {} | Null] || Length[injectionTableBlanks] == Length[ToList@resolvedBlank],
					resolvedBlank,
					injectionTableBlanks
				],
				{}
			],
			BlankFrequency -> resolvedBlankFrequency,
			BlankInjectionVolume -> If[MemberQ[ToList@doubleResolvedBlankAnalysisChannel, ElectrochemicalChannel],
				If[MatchQ[injectionTableBlankInjectionVolumes, {} | Null] || Length[injectionTableBlankInjectionVolumes] == Length[resolvedBlankInjectionVolume],
					resolvedBlankInjectionVolume,
					injectionTableBlankInjectionVolumes
				],
				{}
			],
			BlankGradient -> If[MemberQ[ToList@doubleResolvedBlankAnalysisChannel, ElectrochemicalChannel],
				If[(MatchQ[injectionTableBlankGradients, {}] || Length[injectionTableBlankGradients] == Length[resolvedBlankGradient]),
					ToList@resolvedBlankGradient /. Null -> Nothing,
					injectionTableBlankGradients
				],
				{}
			],
			BlankGradientOverwrite -> If[MemberQ[ToList@doubleResolvedBlankAnalysisChannel, ElectrochemicalChannel],
				If[MatchQ[resolvedBlank, {} | Null],
					{},
					ToList@overwriteBlankGradientBool
				],
				{}
			],
			BlankReferenceElectrodeMode -> resolvedBlankReferenceElectrodeMode,
			BlankVoltageProfile -> resolvedBlankVoltageProfile,
			BlankWaveformProfile -> resolvedBlankWaveformProfile,

			ColumnRefreshFrequency -> resolvedColumnRefreshFrequency,
			ColumnPrimeGradient -> resolvedColumnPrimeGradient,
			ColumnFlushGradient -> resolvedColumnFlushGradient,
			ColumnPrimeGradientOverwrite -> overwriteColumnPrimeGradientBool,
			ColumnFlushGradientOverwrite -> overwriteColumnFlushGradientBool,
			ColumnPrimeReferenceElectrodeMode -> resolvedColumnPrimeReferenceElectrodeMode,
			ColumnPrimeVoltageProfile -> resolvedColumnPrimeVoltageProfile,
			ColumnPrimeWaveformProfile -> resolvedColumnPrimeWaveformProfile,
			ColumnFlushReferenceElectrodeMode -> resolvedColumnFlushReferenceElectrodeMode,
			ColumnFlushVoltageProfile -> resolvedColumnFlushVoltageProfile,
			ColumnFlushWaveformProfile -> resolvedColumnFlushWaveformProfile,
			ElectrochemicalInjectionTable -> electrochemicalInjectionTableLookupRounded
		];

		(*call our shared helper function*)
		{{resolvedInjectionTable, invalidInjectionTableOptions}, invalidInjectionTableTests} = If[
			imbalancedAnionCationGroupingErrors || imbalancedStandardAnionCationGroupingErrors || imbalancedStandardAnionCationGroupingErrors || And @@ consistentAnionChannelQ || And @@ consistentCationChannelQ || And @@ consistentAnionStandardChannelQ || And @@ consistentCationStandardChannelQ || And @@ consistentAnionBlankChannelQ || And @@ consistentCationBlankChannelQ || validChannelQ,
			{{Null, Null}, False},

			If[gatherTests,
				resolveICInjectionTable[mySamples, resolvedOptionsForInjectionTable, Output -> {Result, Tests}],
				{resolveICInjectionTable[mySamples, resolvedOptionsForInjectionTable], {}}
			]
		];

		{resolvedAnionInjectionTable, resolvedCationInjectionTable, resolvedElectrochemicalInjectionTable} = If[NullQ[resolvedInjectionTable], {{}, {}, {}}, resolvedInjectionTable];

		(* == Error checking == *)

		(* 47.1 AnionSamples checks *)
		(* get the resolved values from the injection table *)
		resolvedInjectionTableAnionSamples = Cases[resolvedAnionInjectionTable, {Sample, sample_, ___} :> sample];
		resolvedInjectionTableAnionSampleInjectionVolumes = Cases[resolvedAnionInjectionTable, {Sample, _, _, injectionVolume_, ___} :> injectionVolume];
		resolvedInjectionTableAnionSampleGradients = Cases[resolvedAnionInjectionTable, {Sample, _, _, _, gradient_} :> gradient];

		(* is there something in the injection table that doesn't match what is specified in the options? *)
		foreignAnionSamplesQ = If[anionInjectionTableSpecifiedQ && Not[MatchQ[mapThreadFriendlyAnionSampleOptions, {}]],
			Or[
				(* make sure there are not blanks specified in the injection table but not the options (or vice versa) *)
				Length[DeleteCases[Download[resolvedAnionSamples, Object, Cache -> fullCache], Null | Alternatives @@ Download[resolvedInjectionTableAnionSamples, Object, Cache -> fullCache]]] > 0,
				Length[DeleteCases[Download[resolvedInjectionTableAnionSamples, Object, Cache -> fullCache], Null | Alternatives @@ Download[resolvedAnionSamples, Object, Cache -> fullCache]]] > 0,
				(* make sure there are not blank injection volumes specified in the injection table but not the options (or vice versa) *)
				Length[DeleteCases[resolvedAnionInjectionVolume, Null | Alternatives @@ resolvedInjectionTableAnionSampleInjectionVolumes]] > 0,
				Length[DeleteCases[resolvedInjectionTableAnionSampleInjectionVolumes, Null | Alternatives @@ resolvedAnionInjectionVolume]] > 0,
				(* for gradients, can't really cross-check everything so just make sure they have the same length *)
				Length[resolvedInjectionTableAnionSampleGradients] != Length[resolvedAnionGradient]
			],
			False
		];

		(* if there is a mismatch between the Blank options and the injection table, throw an error *)
		foreignAnionSampleOptions = If[messagesQ && foreignAnionSamplesQ,
			(
				Message[Error::InjectionTableForeignSamples, ObjectToString[anionSampleOption, Cache -> fullCache, Simulation -> updatedSimulation]];
				anionSampleOption
			),
			{}
		];

		(* make a test for the blank injection table options *)
		foreignAnionSampleTest = testOrNull["If any anion samples options are specified, they must agree with the values specified in the InjectionTable:", Not[foreignAnionSamplesQ]];

		(* 47.2 CationSamples checks *)
		(* get the resolved values from the injection table *)
		resolvedInjectionTableCationSamples = Cases[resolvedCationInjectionTable, {Sample, sample_, _, ___} :> sample];
		resolvedInjectionTableCationSampleInjectionVolumes = Cases[resolvedCationInjectionTable, {Sample, _, _, injectionVolume_, ___} :> injectionVolume];
		resolvedInjectionTableCationSampleGradients = Cases[resolvedCationInjectionTable, {Sample, _, _, _, gradient_} :> gradient];


		(* is there something in the injection table that doesn't match what is specified in the options? *)
		foreignCationSamplesQ = If[cationInjectionTableSpecifiedQ && Not[MatchQ[mapThreadFriendlyCationSampleOptions, {}]],
			Or[
				(* make sure there are not blanks specified in the injection table but not the options (or vice versa) *)
				Length[DeleteCases[Download[resolvedCationSamples, Object, Cache -> fullCache], Null | Alternatives @@ Download[resolvedInjectionTableCationSamples, Object, Cache -> fullCache]]] > 0,
				Length[DeleteCases[Download[resolvedInjectionTableCationSamples, Object, Cache -> fullCache], Null | Alternatives @@ Download[resolvedCationSamples, Object, Cache -> fullCache]]] > 0,
				(* make sure there are not blank injection volumes specified in the injection table but not the options (or vice versa) *)
				Length[DeleteCases[resolvedCationInjectionVolume, Null | Alternatives @@ resolvedInjectionTableCationSampleInjectionVolumes]] > 0,
				Length[DeleteCases[resolvedInjectionTableCationSampleInjectionVolumes, Null | Alternatives @@ resolvedCationInjectionVolume]] > 0,
				(* for gradients, can't really cross-check everything so just make sure they have the same length *)
				Length[resolvedInjectionTableCationSampleGradients] != Length[resolvedCationGradient]
			],
			False
		];

		(* if there is a mismatch between the Blank options and the injection table, throw an error *)
		foreignCationSampleOptions = If[messagesQ && foreignCationSamplesQ,
			(
				Message[Error::InjectionTableForeignSamples, ObjectToString[cationSampleOption, Cache -> fullCache, Simulation -> updatedSimulation]];
				cationSampleOption
			),
			{}
		];

		(* make a test for the blank injection table options *)
		foreignCationSampleTest = testOrNull["If any cation sample options are specified, they must agree with the values specified in the InjectionTable:", Not[foreignCationSamplesQ]];

		(* 47.3 Input Samples checks for electrochemical injection table *)
		(* get the resolved values from the injection table *)
		resolvedInjectionTableSamples = Cases[resolvedElectrochemicalInjectionTable, {Sample, sample_, ___} :> sample];
		resolvedInjectionTableSampleInjectionVolumes = Cases[resolvedElectrochemicalInjectionTable, {Sample, _, injectionVolume_, ___} :> injectionVolume];
		resolvedInjectionTableSampleGradients = Cases[resolvedElectrochemicalInjectionTable, {Sample, _, _, gradient_, ___} :> gradient];

		(* is there something in the injection table that doesn't match what is specified in the options? *)
		foreignSamplesQ = If[electrochemicalInjectionTableSpecifiedQ && Not[MatchQ[mapThreadFriendlyElectrochemicalSampleOptions, {}]],
			Or[
				(* make sure there are not blanks specified in the injection table but not the options (or vice versa) *)
				Length[DeleteCases[Download[simulatedSamples, Object], Null | Alternatives @@ Download[resolvedInjectionTableSamples, Object]]] > 0,
				Length[DeleteCases[Download[resolvedInjectionTableSamples, Object], Null | Alternatives @@ Download[simulatedSamples, Object]]] > 0,
				(* make sure there are not blank injection volumes specified in the injection table but not the options (or vice versa) *)
				Length[DeleteCases[resolvedInjectionVolume, Null | Alternatives @@ resolvedInjectionTableSampleInjectionVolumes]] > 0,
				Length[DeleteCases[resolvedInjectionTableSampleInjectionVolumes, Null | Alternatives @@ resolvedInjectionVolume]] > 0,
				(* for gradients, can't really cross-check everything so just make sure they have the same length *)
				Length[resolvedInjectionTableSampleGradients] != Length[resolvedGradient]
			],
			False
		];

		(* if there is a mismatch between the Blank options and the injection table, throw an error *)
		foreignSampleOptions = If[messagesQ && foreignSamplesQ,
			(
				Message[Error::InjectionTableForeignSamples, ObjectToString[electrochemicalSampleOption, Cache -> fullCache, Simulation -> updatedSimulation]];
				electrochemicalSampleOption
			),
			{}
		];

		(* make a test for the blank injection table options *)
		foreignSampleTest = testOrNull["If the electrochemica injection table is specified, the samples listed in the injection table must agree with the input sample:", Not[foreignSamplesQ]];


		(* 47.1 AnionBlank checks *)
		(* get the resolved values from the injection table *)
		resolvedInjectionTableAnionBlanks = Cases[resolvedAnionInjectionTable, {Blank, blank_, _, ___} :> blank];
		resolvedInjectionTableAnionBlankInjectionVolumes = Cases[resolvedAnionInjectionTable, {Blank, _, _, injectionVolume_, ___} :> injectionVolume];
		resolvedInjectionTableAnionBlankGradients = Cases[resolvedAnionInjectionTable, {Blank, _, _, _, gradient_} :> gradient];

		(* is there something in the injection table that doesn't match what is specified in the options? *)
		foreignAnionBlanksQ = If[anionInjectionTableSpecifiedQ && NullQ[resolvedAnionBlankFrequency] && Not[MatchQ[mapThreadFriendlyAnionBlankOptions, {}]],
			Or[
				(* make sure there are not blanks specified in the injection table but not the options (or vice versa) *)
				Length[DeleteCases[Download[doubleResolvedAnionBlank, Object, Cache -> fullCache], Null | Alternatives @@ Download[resolvedInjectionTableAnionBlanks, Object, Cache -> fullCache]]] > 0,
				Length[DeleteCases[Download[resolvedInjectionTableAnionBlanks, Object, Cache -> fullCache], Null | Alternatives @@ Download[doubleResolvedAnionBlank, Object, Cache -> fullCache]]] > 0,
				(* make sure there are not blank injection volumes specified in the injection table but not the options (or vice versa) *)
				Length[DeleteCases[resolvedAnionBlankInjectionVolume, Null | Alternatives @@ resolvedInjectionTableAnionBlankInjectionVolumes]] > 0,
				Length[DeleteCases[resolvedInjectionTableAnionBlankInjectionVolumes, Null | Alternatives @@ resolvedAnionBlankInjectionVolume]] > 0,
				(* for gradients, can't really cross-check everything so just make sure they have the same length *)
				Length[resolvedInjectionTableAnionBlankGradients] != Length[resolvedAnionBlankGradient]
			],
			False
		];

		(* if there is a mismatch between the Blank options and the injection table, throw an error *)
		foreignAnionBlankOptions = If[messagesQ && foreignAnionBlanksQ,
			(
				Message[Error::InjectionTableForeignBlanks, ObjectToString[anionBlankOptionNames, Cache -> fullCache, Simulation -> updatedSimulation]];
				anionBlankOptionNames
			),
			{}
		];

		(* make a test for the blank injection table options *)
		foreignAnionBlankTest = testOrNull["If any anion blank options are specified, they must agree with the values specified in the InjectionTable:", Not[foreignAnionBlanksQ]];

		(* 47.2 CationBlank checks *)
		(* get the resolved values from the injection table *)
		resolvedInjectionTableCationBlanks = Cases[resolvedCationInjectionTable, {Blank, blank_, _, ___} :> blank];
		resolvedInjectionTableCationBlankInjectionVolumes = Cases[resolvedCationInjectionTable, {Blank, _, _, injectionVolume_, ___} :> injectionVolume];
		resolvedInjectionTableCationBlankGradients = Cases[resolvedCationInjectionTable, {Blank, _, _, _, gradient_} :> gradient];

		(* is there something in the injection table that doesn't match what is specified in the options? *)
		foreignCationBlanksQ = If[cationInjectionTableSpecifiedQ && NullQ[resolvedCationBlankFrequency] && Not[MatchQ[mapThreadFriendlyCationBlankOptions, {}]],
			Or[
				(* make sure there are not blanks specified in the injection table but not the options (or vice versa) *)
				Length[DeleteCases[Download[doubleResolvedCationBlank, Object, Cache -> fullCache], Null | Alternatives @@ Download[resolvedInjectionTableCationBlanks, Object, Cache -> fullCache]]] > 0,
				Length[DeleteCases[Download[resolvedInjectionTableCationBlanks, Object, Cache -> fullCache], Null | Alternatives @@ Download[doubleResolvedCationBlank, Object, Cache -> fullCache]]] > 0,
				(* make sure there are not blank injection volumes specified in the injection table but not the options (or vice versa) *)
				Length[DeleteCases[resolvedCationBlankInjectionVolume, Null | Alternatives @@ resolvedInjectionTableCationBlankInjectionVolumes]] > 0,
				Length[DeleteCases[resolvedInjectionTableCationBlankInjectionVolumes, Null | Alternatives @@ resolvedCationBlankInjectionVolume]] > 0,
				(* for gradients, can't really cross-check everything so just make sure they have the same length *)
				Length[resolvedInjectionTableCationBlankGradients] != Length[resolvedCationBlankGradient]
			],
			False
		];

		(* if there is a mismatch between the Blank options and the injection table, throw an error *)
		foreignCationBlankOptions = If[messagesQ && foreignCationBlanksQ,
			(
				Message[Error::InjectionTableForeignBlanks, ObjectToString[cationBlankOptionNames, Cache -> fullCache, Simulation -> updatedSimulation]];
				cationBlankOptionNames
			),
			{}
		];

		(* make a test for the blank injection table options *)
		foreignCationBlankTest = testOrNull["If any cation blank options are specified, they must agree with the values specified in the InjectionTable:", Not[foreignCationBlanksQ]];

		(* 47.3 Blank check for electrochemical injection table *)
		(* get the resolved values from the injection table *)
		resolvedInjectionTableBlanks = Cases[resolvedElectrochemicalInjectionTable, {Blank, blank_, _, ___} :> blank];
		resolvedInjectionTableBlankInjectionVolumes = Cases[resolvedElectrochemicalInjectionTable, {Blank, _, injectionVolume_, ___} :> injectionVolume];
		resolvedInjectionTableBlankGradients = Cases[resolvedElectrochemicalInjectionTable, {Blank, _, _, gradient_, ___} :> gradient];

		(* is there something in the injection table that doesn't match what is specified in the options? *)
		foreignBlanksQ = If[electrochemicalInjectionTableSpecifiedQ && NullQ[resolvedBlankFrequency] && Not[MatchQ[mapThreadFriendlyElectrochemicalBlankOptions, {}]],
			Or[
				(* make sure there are not blanks specified in the injection table but not the options (or vice versa) *)
				Length[DeleteCases[Download[resolvedBlank, Object], Null | Alternatives @@ Download[resolvedInjectionTableBlanks, Object]]] > 0,
				Length[DeleteCases[Download[resolvedInjectionTableBlanks, Object], Null | Alternatives @@ Download[resolvedBlank, Object]]] > 0,
				(* make sure there are not blank injection volumes specified in the injection table but not the options (or vice versa) *)
				Length[DeleteCases[resolvedBlankInjectionVolume, Null | Alternatives @@ resolvedInjectionTableBlankInjectionVolumes]] > 0,
				Length[DeleteCases[resolvedInjectionTableBlankInjectionVolumes, Null | Alternatives @@ resolvedBlankInjectionVolume]] > 0,
				(* for gradients, can't really cross-check everything so just make sure they have the same length *)
				Length[resolvedInjectionTableBlankGradients] != Length[resolvedBlankGradient]
			],
			False
		];

		(* if there is a mismatch between the Blank options and the injection table, throw an error *)
		foreignBlankOptions = If[messagesQ && foreignBlanksQ,
			(
				Message[Error::InjectionTableForeignBlanks, ObjectToString[electrochemicalBlankOptionNames, Cache -> fullCache, Simulation -> updatedSimulation]];
				electrochemicalBlankOptionNames
			),
			{}
		];

		(* make a test for the blank injection table options *)
		foreignBlankTest = testOrNull["If any blank options are specified, they must agree with the values specified in the InjectionTable:", Not[foreignBlanksQ]];


		(* 47.1 AnionStandard checks *)
		(* get the resolved values from the injection table *)
		resolvedInjectionTableAnionStandards = Cases[resolvedAnionInjectionTable, {Standard, standard_, _, ___} :> standard];
		resolvedInjectionTableAnionStandardInjectionVolumes = Cases[resolvedAnionInjectionTable, {Standard, _, _, injectionVolume_, ___} :> injectionVolume];
		resolvedInjectionTableAnionStandardGradients = Cases[resolvedAnionInjectionTable, {Standard, _, _, _, gradient_} :> gradient];

		(* is there something in the injection table that doesn't match what is specified in the options? *)
		foreignAnionStandardsQ = If[anionInjectionTableSpecifiedQ && NullQ[resolvedAnionStandardFrequency] && Not[MatchQ[mapThreadFriendlyAnionStandardOptions, {}]],
			Or[
				(* make sure there are not standards specified in the injection table but not the options (or vice versa) *)
				Length[DeleteCases[Download[resolvedAnionStandard, Object, Cache -> fullCache], Null | Alternatives @@ Download[resolvedInjectionTableAnionStandards, Object, Cache -> fullCache]]] > 0,
				Length[DeleteCases[Download[resolvedInjectionTableAnionStandards, Object, Cache -> fullCache], Null | Alternatives @@ Download[resolvedAnionStandard, Object, Cache -> fullCache]]] > 0,
				(* make sure there are not standard injection volumes specified in the injection table but not the options (or vice versa) *)
				Length[DeleteCases[resolvedAnionStandardInjectionVolume, Null | Alternatives @@ resolvedInjectionTableAnionStandardInjectionVolumes]] > 0,
				Length[DeleteCases[resolvedInjectionTableAnionStandardInjectionVolumes, Null | Alternatives @@ resolvedAnionStandardInjectionVolume]] > 0,
				(* for gradients, can't really cross-check everything so just make sure they have the same length *)
				Length[resolvedInjectionTableAnionStandardGradients] != Length[resolvedAnionStandardGradient]
			],
			False
		];

		(* if there is a mismatch between the Standard options and the injection table, throw an error *)
		foreignAnionStandardOptions = If[messagesQ && foreignAnionStandardsQ,
			(
				Message[Error::InjectionTableForeignStandards, ObjectToString[anionStandardOptionNames, Cache -> fullCache, Simulation -> updatedSimulation]];
				anionStandardOptionNames
			),
			{}
		];

		(* make a test for the standard injection table options *)
		foreignAnionStandardTest = testOrNull["If any anion standard options are specified, they must agree with the values specified in the InjectionTable:", Not[foreignAnionStandardsQ]];


		(* 47.2 CationStandard checks *)
		(* get the resolved values from the injection table *)
		resolvedInjectionTableCationStandards = Cases[resolvedCationInjectionTable, {Standard, standard_, _, ___} :> standard];
		resolvedInjectionTableCationStandardInjectionVolumes = Cases[resolvedCationInjectionTable, {Standard, _, _, injectionVolume_, ___} :> injectionVolume];
		resolvedInjectionTableCationStandardGradients = Cases[resolvedCationInjectionTable, {Standard, _, _, _, gradient_} :> gradient];

		(* is there something in the injection table that doesn't match what is specified in the options? *)
		foreignCationStandardsQ = If[cationInjectionTableSpecifiedQ && NullQ[resolvedCationStandardFrequency] && Not[MatchQ[mapThreadFriendlyCationStandardOptions, {}]],
			Or[
				(* make sure there are not standards specified in the injection table but not the options (or vice versa) *)
				Length[DeleteCases[Download[resolvedCationStandard, Object, Cache -> fullCache], Null | Alternatives @@ Download[resolvedInjectionTableCationStandards, Object, Cache -> fullCache]]] > 0,
				Length[DeleteCases[Download[resolvedInjectionTableCationStandards, Object, Cache -> fullCache], Null | Alternatives @@ Download[resolvedCationStandard, Object, Cache -> fullCache]]] > 0,
				(* make sure there are not standard injection volumes specified in the injection table but not the options (or vice versa) *)
				Length[DeleteCases[resolvedCationStandardInjectionVolume, Null | Alternatives @@ resolvedInjectionTableCationStandardInjectionVolumes]] > 0,
				Length[DeleteCases[resolvedInjectionTableCationStandardInjectionVolumes, Null | Alternatives @@ resolvedCationStandardInjectionVolume]] > 0,
				(* for gradients, can't really cross-check everything so just make sure they have the same length *)
				Length[resolvedInjectionTableCationStandardGradients] != Length[resolvedCationStandardGradient]
			],
			False
		];

		(* if there is a mismatch between the Standard options and the injection table, throw an error *)
		foreignCationStandardOptions = If[messagesQ && foreignCationStandardsQ,
			(
				Message[Error::InjectionTableForeignStandards, ObjectToString[cationStandardOptionNames, Cache -> fullCache, Simulation -> updatedSimulation]];
				cationStandardOptionNames
			),
			{}
		];

		(* make a test for the standard injection table options *)
		foreignCationStandardTest = testOrNull["If any cation standard options are specified, they must agree with the values specified in the InjectionTable:", Not[foreignCationStandardsQ]];

		(* 47.3 Standard checks for electrochemical injection table*)
		(* get the resolved values from the injection table *)
		resolvedInjectionTableStandards = Cases[resolvedElectrochemicalInjectionTable, {Standard, standard_, _, ___} :> standard];
		resolvedInjectionTableStandardInjectionVolumes = Cases[resolvedElectrochemicalInjectionTable, {Standard, _, injectionVolume_, ___} :> injectionVolume];
		resolvedInjectionTableStandardGradients = Cases[resolvedElectrochemicalInjectionTable, {Standard, _, _, gradient_, ___} :> gradient];

		(* is there something in the injection table that doesn't match what is specified in the options? *)
		foreignStandardsQ = If[electrochemicalInjectionTableSpecifiedQ && NullQ[resolvedStandardFrequency] && Not[MatchQ[mapThreadFriendlyElectrochemicalStandardOptions, {}]],
			Or[
				(* make sure there are not standards specified in the injection table but not the options (or vice versa) *)
				Length[DeleteCases[Download[resolvedStandard, Object], Null | Alternatives @@ Download[resolvedInjectionTableStandards, Object]]] > 0,
				Length[DeleteCases[Download[resolvedInjectionTableStandards, Object], Null | Alternatives @@ Download[resolvedStandard, Object]]] > 0,
				(* make sure there are not standard injection volumes specified in the injection table but not the options (or vice versa) *)
				Length[DeleteCases[resolvedStandardInjectionVolume, Null | Alternatives @@ resolvedInjectionTableStandardInjectionVolumes]] > 0,
				Length[DeleteCases[resolvedInjectionTableStandardInjectionVolumes, Null | Alternatives @@ resolvedStandardInjectionVolume]] > 0,
				(* for gradients, can't really cross-check everything so just make sure they have the same length *)
				Length[resolvedInjectionTableStandardGradients] != Length[resolvedStandardGradient]
			],
			False
		];

		(* if there is a mismatch between the Standard options and the injection table, throw an error *)
		foreignStandardOptions = If[messagesQ && foreignStandardsQ,
			(
				Message[Error::InjectionTableForeignStandards, ObjectToString[electrochemicalStandardOptionsNames, Cache -> fullCache, Simulation -> updatedSimulation]];
				electrochemicalStandardOptionsNames
			),
			{}
		];

		(* make a test for the standard injection table options *)
		foreignStandardTest = testOrNull["If any standard options are specified, they must agree with the values specified in the InjectionTable:", Not[foreignCationStandardsQ]];



		(* 48. Hmm maybe InjectionTable is not the grand finale. Buffer Storage Conditions resolution *)

		(* Identify unresolved gradient that still exist as an gradient object rather than tuples *)
		cationUnresolvedGradientObjectPosition = Flatten@Position[resolvedCationGradient, ObjectP[Object[Method, IonChromatographyGradient]]];
		cationStandardUnresolvedGradientObjectPosition = Flatten@Position[resolvedCationStandardGradient, ObjectP[Object[Method, IonChromatographyGradient]]];
		cationBlankUnresolvedGradientObjectPosition = Flatten@Position[resolvedCationBlankGradient, ObjectP[Object[Method, IonChromatographyGradient]]];

		(* Extract any specified gradient objects for Download *)
		cationSampleGradientObjects = If[MatchQ[cationUnresolvedGradientObjectPosition, {} | Null | {Null}],
			Null,
			resolvedCationGradient[[cationUnresolvedGradientObjectPosition]]
		];

		(* Extract any specified gradient objects for Download *)
		cationBlankGradientObjects = If[MatchQ[cationBlankUnresolvedGradientObjectPosition, {} | Null | {Null}],
			Null,
			DeleteCases[ToList@resolvedCationBlankGradient, Null][[cationBlankUnresolvedGradientObjectPosition]]
		];

		(* Extract any specified gradient objects for Download *)
		cationStandardGradientObjects = If[MatchQ[cationStandardUnresolvedGradientObjectPosition, {} | Null | {Null}],
			Null,
			DeleteCases[ToList@resolvedCationStandardGradient, Null][[cationStandardUnresolvedGradientObjectPosition]]
		];

		(* If ColumnPrimeGradient is an object, Download Gradient from the object *)
		cationColumnPrimeGradientObject = If[MatchQ[resolvedCationColumnPrimeGradient, ObjectP[Object[Method, IonChromatographyGradient]]],
			resolvedCationColumnPrimeGradient,
			Null
		];

		(* If ColumnFlushGradient is an object, Download Gradient from the object *)
		cationColumnFlushGradientObject = If[MatchQ[resolvedCationColumnFlushGradient, ObjectP[Object[Method, IonChromatographyGradient]]],
			resolvedCationColumnFlushGradient /. {Null} -> Null,
			Null
		];

		(* Replace all gradient object in the resolved Gradient option with their gradient tuples *)
		cationSampleGradientsTuples = If[MatchQ[resolvedCationGradient, {} | Null | {Null}],

			Null,

			If[MatchQ[cationUnresolvedGradientObjectPosition, {}],
				resolvedCationGradient,
				ReplacePart[
					ToList@resolvedCationGradient,
					MapThread[
						Rule[#1, #2]&,
						{
							cationUnresolvedGradientObjectPosition,
							Lookup[fetchPacketFromCache[#, fullCache], CationGradient]& /@ cationSampleGradientObjects
						}
					]
				]
			]
		];

		(* Replace all gradient object in the resolved BlankGradient option with their gradient tuples *)
		cationBlankGradientsTuples = If[MatchQ[resolvedCationBlankGradient, {} | Null | {Null}],

			Null,

			If[MatchQ[cationBlankUnresolvedGradientObjectPosition, {}],
				DeleteCases[ToList@resolvedCationBlankGradient, Null],
				ReplacePart[
					DeleteCases[ToList@resolvedCationBlankGradient, Null],
					MapThread[
						Rule[#1, #2]&,
						{
							cationBlankUnresolvedGradientObjectPosition,
							Lookup[fetchPacketFromCache[#, fullCache], CationGradient]& /@ cationBlankGradientObjects
						}
					]
				]
			]
		];

		(* If StandardGradient is an object, set to Gradient object's tuples. *)
		cationStandardGradientsTuples = If[MatchQ[resolvedCationStandardGradient, {} | Null | {Null}],

			Null,

			If[MatchQ[cationStandardUnresolvedGradientObjectPosition, {}],
				DeleteCases[ToList@resolvedCationStandardGradient, Null],
				ReplacePart[
					DeleteCases[ToList@resolvedCationStandardGradient, Null],
					MapThread[
						Rule[#1, #2]&,
						{
							cationStandardUnresolvedGradientObjectPosition,
							Lookup[fetchPacketFromCache[#, fullCache], CationGradient]& /@ cationStandardGradientObjects
						}
					]
				]
			]
		];

		(* If ColumnPrimeGradient is an object, set to Gradient object's tuples. *)
		cationColumnPrimeGradientTuples = If[NullQ[cationColumnPrimeGradientObject],
			resolvedCationColumnPrimeGradient,
			Lookup[fetchPacketFromCache[resolvedCationColumnPrimeGradient, fullCache], CationGradient]
		];

		(* If ColumnFlushGradient is an object, set to Gradient object's tuples. *)
		cationColumnFlushGradientTuples = If[NullQ[cationColumnFlushGradientObject],
			resolvedCationColumnFlushGradient,
			Lookup[fetchPacketFromCache[resolvedCationColumnFlushGradient, fullCache], CationGradient]
		];

		(* get the positions of the standards *)
		cationStandardPositions = Flatten@Position[resolvedCationInjectionTable, {Standard, _, CationChannel, _}];

		(* Based on BlankFrequency option, determine the positions where blanks will run *)
		cationBlankPositions = Flatten@Position[resolvedCationInjectionTable, {Blank, _, CationChannel, _}];

		(* Based on ColumnRefreshFrequency option, determine the positions where primes/flushes will run *)
		cationColumnRefreshPositions = Flatten@Position[resolvedCationInjectionTable, {(ColumnPrime | ColumnFlush), _, CationChannel, _}];

		(* Build list of all gradient tuples used *)
		allCationGradientTuples = Join[
			ToList@cationSampleGradientsTuples,
			(* blankGradients is a list of lists of gradients (since more than once blank may be specified) *)
			Join @@ Table[cationBlankGradientsTuples, Length[cationBlankPositions]] /. {} -> {Null},
			Join @@ Table[cationStandardGradientsTuples, Length[cationStandardPositions]] /. {} -> {Null},
			(* At least one prime/flush gradient wil be run and additional may be run for column refreshes *)
			Table[cationColumnPrimeGradientTuples, Length[cationColumnRefreshPositions] + 1],
			Table[cationColumnFlushGradientTuples, Length[cationColumnRefreshPositions] + 1]
		] /. Null -> Nothing;


		(* == Repeat the section above for gradients used for electrochemical detection *)

		(* Identify unresolved gradient that still exist as an gradient object rather than tuples *)
		unresolvedGradientObjectPosition = Flatten@Position[resolvedGradient, ObjectP[Object[Method, Gradient]]];
		standardUnresolvedGradientObjectPosition = Flatten@Position[resolvedStandardGradient, ObjectP[Object[Method, Gradient]]];
		blankUnresolvedGradientObjectPosition = Flatten@Position[resolvedBlankGradient, ObjectP[Object[Method, Gradient]]];

		(* Extract any specified gradient objects for Download *)
		sampleGradientObjects = If[MatchQ[unresolvedGradientObjectPosition, {} | Null | {Null}],
			Null,
			resolvedGradient[[unresolvedGradientObjectPosition]]
		];

		(* Extract any specified gradient objects for Download *)
		blankGradientObjects = If[MatchQ[blankUnresolvedGradientObjectPosition, {} | Null | {Null}],
			Null,
			DeleteCases[ToList@resolvedBlankGradient, Null][[blankUnresolvedGradientObjectPosition]]
		];

		(* Extract any specified gradient objects for Download *)
		standardGradientObjects = If[MatchQ[standardUnresolvedGradientObjectPosition, {} | Null | {Null}],
			Null,
			DeleteCases[ToList@resolvedStandardGradient, Null][[standardUnresolvedGradientObjectPosition]]
		];

		(* If ColumnPrimeGradient is an object, Download Gradient from the object *)
		columnPrimeGradientObject = If[MatchQ[resolvedColumnPrimeGradient, ObjectP[Object[Method, Gradient]]],
			resolvedColumnPrimeGradient,
			Null
		];

		(* If ColumnFlushGradient is an object, Download Gradient from the object *)
		columnFlushGradientObject = If[MatchQ[resolvedColumnFlushGradient, ObjectP[Object[Method, Gradient]]],
			resolvedColumnFlushGradient /. {Null} -> Null,
			Null
		];

		(* Replace all gradient object in the resolved Gradient option with their gradient tuples *)
		sampleGradientsTuples = If[MatchQ[resolvedGradient, {} | Null | {Null}],

			Null,

			If[MatchQ[unresolvedGradientObjectPosition, {}],
				resolvedGradient,
				ReplacePart[
					ToList@resolvedGradient,
					MapThread[
						Rule[#1, #2]&,
						{
							unresolvedGradientObjectPosition,
							Lookup[fetchPacketFromCache[#, fullCache], Gradient]& /@ sampleGradientObjects
						}
					]
				]
			]
		];

		(* Replace all gradient object in the resolved BlankGradient option with their gradient tuples *)
		blankGradientsTuples = If[MatchQ[resolvedBlankGradient, {} | Null | {Null}],

			Null,

			If[MatchQ[blankUnresolvedGradientObjectPosition, {}],
				DeleteCases[ToList@resolvedBlankGradient, Null],
				ReplacePart[
					DeleteCases[ToList@resolvedBlankGradient, Null],
					MapThread[
						Rule[#1, #2]&,
						{
							blankUnresolvedGradientObjectPosition,
							Lookup[fetchPacketFromCache[#, fullCache], Gradient]& /@ blankGradientObjects
						}
					]
				]
			]
		];

		(* If StandardGradient is an object, set to Gradient object's tuples. *)
		standardGradientsTuples = If[MatchQ[resolvedStandardGradient, {} | Null | {Null}],

			Null,

			If[MatchQ[standardUnresolvedGradientObjectPosition, {}],
				DeleteCases[ToList@resolvedStandardGradient, Null],
				ReplacePart[
					DeleteCases[ToList@resolvedStandardGradient, Null],
					MapThread[
						Rule[#1, #2]&,
						{
							standardUnresolvedGradientObjectPosition,
							Lookup[fetchPacketFromCache[#, fullCache], CationGradient]& /@ standardGradientObjects
						}
					]
				]
			]
		];

		(* If ColumnPrimeGradient is an object, set to Gradient object's tuples. *)
		columnPrimeGradientTuples = If[NullQ[columnPrimeGradientObject],
			resolvedColumnPrimeGradient,
			Lookup[fetchPacketFromCache[resolvedColumnPrimeGradient, fullCache], Gradient]
		];

		(* If ColumnFlushGradient is an object, set to Gradient object's tuples. *)
		columnFlushGradientTuples = If[NullQ[columnFlushGradientObject],
			resolvedColumnFlushGradient,
			Lookup[fetchPacketFromCache[resolvedColumnFlushGradient, fullCache], Gradient]
		];

		(* get the positions of the standards *)
		standardPositions = Flatten@Position[resolvedElectrochemicalInjectionTable, {Standard, ___}];

		(* Based on BlankFrequency option, determine the positions where blanks will run *)
		blankPositions = Flatten@Position[resolvedElectrochemicalInjectionTable, {Blank, ___}];

		(* Based on ColumnRefreshFrequency option, determine the positions where primes/flushes will run *)
		columnRefreshPositions = Flatten@Position[resolvedElectrochemicalInjectionTable, {(ColumnPrime | ColumnFlush), ___}];

		(* Build list of all gradient tuples used *)
		allGradientTuples = Join[
			ToList@sampleGradientsTuples,
			(* blankGradients is a list of lists of gradients (since more than once blank may be specified) *)
			Join @@ Table[blankGradientsTuples, Length[blankPositions]] /. {} -> {Null},
			Join @@ Table[standardGradientsTuples, Length[standardPositions]] /. {} -> {Null},
			(* At least one prime/flush gradient wil be run and additional may be run for column refreshes *)
			Table[columnPrimeGradientTuples, Length[columnRefreshPositions] + 1],
			Table[columnFlushGradientTuples, Length[columnRefreshPositions] + 1]
		] /. Null -> Nothing;


		(* Determine volume of BufferA required for each gradient run *)
		(* calculateBufferUsage is a HPLC helper function *)
		(* 4 Inputs are: 1. tuples of gradient time points and buffer percentage, 2. max time point, 3. tuples of gradient time points and flow rates, and 4. final buffer percentage *)
		bufferAVolumePerGradient = Which[

			!MatchQ[allCationGradientTuples, ListableP[Null]],
			Map[
				calculateBufferUsage[
					#[[All, {1, 2}]],
					Max[#[[All, 1]]],
					#[[All, {1, -1}]],
					Last[#[[All, 2]]]
				]&,
				allCationGradientTuples
			],

			!MatchQ[allGradientTuples, ListableP[Null]],
			Map[
				calculateBufferUsage[
					#[[All, {1, 2}]],
					Max[#[[All, 1]]],
					#[[All, {1, -1}]],
					Last[#[[All, 2]]]
				]&,
				allGradientTuples
			],

			True,
			0 Milliliter
		];

		bufferBVolumePerGradient = Which[

			!MatchQ[allCationGradientTuples, ListableP[Null]],
			Map[
				calculateBufferUsage[
					#[[All, {1, 3}]],
					Max[#[[All, 1]]],
					#[[All, {1, -1}]],
					Last[#[[All, 3]]]
				]&,
				allCationGradientTuples
			],

			!MatchQ[allGradientTuples, ListableP[Null]],
			Map[
				calculateBufferUsage[
					#[[All, {1, 3}]],
					Max[#[[All, 1]]],
					#[[All, {1, -1}]],
					Last[#[[All, 3]]]
				]&,
				allGradientTuples
			],

			True,
			0 Milliliter
		];

		bufferCVolumePerGradient = Which[

			!MatchQ[allCationGradientTuples, ListableP[Null]],
			Map[
				calculateBufferUsage[
					#[[All, {1, 4}]],
					Max[#[[All, 1]]],
					#[[All, {1, -1}]],
					Last[#[[All, 4]]]
				]&,
				allCationGradientTuples
			],

			!MatchQ[allGradientTuples, ListableP[Null]],
			Map[
				calculateBufferUsage[
					#[[All, {1, 4}]],
					Max[#[[All, 1]]],
					#[[All, {1, -1}]],
					Last[#[[All, 4]]]
				]&,
				allGradientTuples
			],

			True,
			0 Milliliter
		];

		bufferDVolumePerGradient = Which[

			!MatchQ[allCationGradientTuples, ListableP[Null]],
			Map[
				calculateBufferUsage[
					#[[All, {1, 5}]],
					Max[#[[All, 1]]],
					#[[All, {1, -1}]],
					Last[#[[All, 5]]]
				]&,
				allCationGradientTuples
			],

			!MatchQ[allGradientTuples, ListableP[Null]],
			Map[
				calculateBufferUsage[
					#[[All, {1, 5}]],
					Max[#[[All, 1]]],
					#[[All, {1, -1}]],
					Last[#[[All, 5]]]
				]&,
				allGradientTuples
			],

			True,
			0 Milliliter
		];

		(* Identify the volume for the resolved buffer A and B if they are sample objects *)
		bufferAVolume = If[MatchQ[resolvedBufferA, ObjectP[Object[Sample]]],
			Lookup[fetchPacketFromCache[resolvedBufferA, fullCache], Volume],
			Null
		];
		bufferBVolume = If[MatchQ[resolvedBufferB, ObjectP[Object[Sample]]],
			Lookup[fetchPacketFromCache[resolvedBufferB, fullCache], Volume],
			Null
		];
		bufferCVolume = If[MatchQ[resolvedBufferC, ObjectP[Object[Sample]]],
			Lookup[fetchPacketFromCache[resolvedBufferC, fullCache], Volume],
			Null
		];
		bufferDVolume = If[MatchQ[resolvedBufferD, ObjectP[Object[Sample]]],
			Lookup[fetchPacketFromCache[resolvedBufferD, fullCache], Volume],
			Null
		];

		(* Estimate the amount of buffer needed for the experiment protocol *)
		(* 75 Milliliter incorporated for initial system purge *)
		neededBufferAVolume = (Total[bufferAVolumePerGradient] * resolvedNumberOfReplicates + 75 Milliliter) /. Null -> 1;
		neededBufferBVolume = (Total[bufferBVolumePerGradient] * resolvedNumberOfReplicates + 75 Milliliter) /. Null -> 1;
		neededBufferCVolume = (Total[bufferCVolumePerGradient] * resolvedNumberOfReplicates + 75 Milliliter) /. Null -> 1;
		neededBufferDVolume = (Total[bufferDVolumePerGradient] * resolvedNumberOfReplicates + 75 Milliliter) /. Null -> 1;

		resolvedBufferAStorageCondition = If[MatchQ[resolvedBufferA, Null | {} | {Null}],
			(* If there is no BufferA, then BufferA storage condition resolves to Null *)
			Null,

			Which[
				(* If user specified Buffer A storage condition, go with that *)
				MatchQ[specifiedBufferAStorageCondition, Except[Automatic | Null]],
				specifiedBufferAStorageCondition,

				(* If user specified BufferA as a model object, storage condition will go to disposal *)
				(* Because appropriate amount of buffer will be collected in the resource picking stage, so there won't be too much left *)
				MatchQ[resolvedBufferA, ObjectP[Model[Sample]]],
				Disposal,

				True,
				(
					(* Otherwise, then we look at the volume of the resolved buffer A if it's a sample object *)
					If[MatchQ[bufferAVolume, VolumeP],

						(* If the initial volume minus the needed volume for the experiment is more than 500 mL, then we store the remaining buffer according to the model's storage condition *)
						If[bufferAVolume - neededBufferAVolume > 500 Milliliter,
							If[DatabaseMemberQ[resolvedBufferA],
								Download[Lookup[fetchPacketFromCache[resolvedBufferA, fullCache], DefaultStorageCondition], StorageCondition, Date -> Now],
								AmbientStorage
							],

							(* Otherwise, we toss the remaining buffer *)
							Disposal
						],

						(* If volume is not specified, then we store the buffer to be safe *)
						Download[Lookup[fetchPacketFromCache[resolvedBufferA, fullCache], DefaultStorageCondition], StorageCondition, Date -> Now]
					]
				)
			]
		];

		resolvedBufferBStorageCondition = If[MatchQ[resolvedBufferB, Null | {} | {Null}],
			(* If there is no BufferB, then BufferB storage condition resolves to Null *)
			Null,

			Which[
				(* If user specified Buffer B storage condition, go with that *)
				MatchQ[specifiedBufferBStorageCondition, Except[Automatic | Null]],
				specifiedBufferBStorageCondition,

				(* If user specified BufferB as a model object, storage condition will go to disposal *)
				(* Because appropriate amount of buffer will be collected in the resource picking stage, so there won't be too much left *)
				MatchQ[resolvedBufferB, ObjectP[Model[Sample]]],
				Disposal,

				True,
				(
					(* If the initial volume minus the needed volume for the experiment is more than 500 mL, then we store the remaining buffer according to the model's storage condition *)
					If[MatchQ[bufferBVolume, VolumeP],
						If[bufferBVolume - neededBufferBVolume > 500 Milliliter,
							If[DatabaseMemberQ[resolvedBufferB],
								Download[Lookup[fetchPacketFromCache[resolvedBufferB, fullCache], DefaultStorageCondition], StorageCondition, Date -> Now],
								AmbientStorage
							],

							(* Otherwise, we toss the remaining buffer *)
							Disposal
						],

						(* If volume is not specified, then we store the buffer to be safe *)
						Download[Lookup[fetchPacketFromCache[resolvedBufferB, fullCache], DefaultStorageCondition], StorageCondition, Date -> Now]
					]
				)
			]
		];

		resolvedBufferCStorageCondition = If[MatchQ[resolvedBufferC, Null | {} | {Null}],
			(* If there is no BufferC, then BufferC storage condition resolves to Null *)
			Null,

			Which[
				(* If user specified Buffer C storage condition, go with that *)
				MatchQ[specifiedBufferCStorageCondition, Except[Automatic | Null]],
				specifiedBufferCStorageCondition,

				(* If user specified BufferC as a model object, storage condition will go to disposal *)
				(* Because appropriate amount of buffer will be collected in the resource picking stage, so there won't be too much left *)
				MatchQ[resolvedBufferC, ObjectP[Model[Sample]]],
				Disposal,

				True,
				(
					(* If the initial volume minus the needed volume for the experiment is more than 500 mL, then we store the remaining buffer according to the model's storage condition *)
					If[MatchQ[bufferCVolume, VolumeP],
						If[bufferCVolume - neededBufferCVolume > 500 Milliliter,
							If[DatabaseMemberQ[resolvedBufferC],
								Download[Lookup[fetchPacketFromCache[resolvedBufferC, fullCache], DefaultStorageCondition], StorageCondition],
								AmbientStorage
							],

							(* Otherwise, we toss the remaining buffer *)
							Disposal
						],

						(* If volume is not specified, then we store the buffer to be safe *)
						Download[Lookup[fetchPacketFromCache[resolvedBufferC, fullCache], DefaultStorageCondition], StorageCondition]
					]
				)
			]
		];

		resolvedBufferDStorageCondition = If[MatchQ[resolvedBufferD, Null | {} | {Null}],
			(* If there is no BufferD, then BufferD storage condition resolves to Null *)
			Null,

			Which[
				(* If user specified Buffer D storage condition, go with that *)
				MatchQ[specifiedBufferDStorageCondition, Except[Automatic | Null]],
				specifiedBufferDStorageCondition,

				(* If user specified BufferD as a model object, storage condition will go to disposal *)
				(* Because appropriate amount of buffer will be collected in the resource picking stage, so there won't be too much left *)
				MatchQ[resolvedBufferD, ObjectP[Model[Sample]]],
				Disposal,

				True,
				(
					(* If the initial volume minus the needed volume for the experiment is more than 500 mL, then we store the remaining buffer according to the model's storage condition *)
					If[MatchQ[bufferDVolume, VolumeP],
						If[bufferDVolume - neededBufferDVolume > 500 Milliliter,
							If[DatabaseMemberQ[resolvedBufferD],
								Download[Lookup[fetchPacketFromCache[resolvedBufferD, fullCache], DefaultStorageCondition], StorageCondition, Date -> Now],
								AmbientStorage
							],

							(* Otherwise, we toss the remaining buffer *)
							Disposal
						],

						(* If volume is not specified, then we store the buffer to be safe *)
						Download[Lookup[fetchPacketFromCache[resolvedBufferD, fullCache], DefaultStorageCondition], StorageCondition, Date -> Now]
					]
				)
			]
		];

		(* == Error Checking == *)
		(* 48.1 BufferA storage condition check *)
		(* If BufferA is specified, BufferAStorageCondition cannot be nulled out *)
		validBufferAStorageConditionQ = If[!MatchQ[resolvedBufferA, {} | Null | {Null}],
			MatchQ[resolvedBufferAStorageCondition, {} | Null{Null}],
			False
		];

		(* Collect invalid option and throw error *)
		invalidBufferAStorageConditionOptions = If[validBufferAStorageConditionQ && messagesQ,
			(
				Message[Error::UnspecifiedBufferStorageCondition, BufferA];
				{BufferAStorageCondition}
			),
			{}
		];

		(* Generate test for buffer storage conditions *)
		invalidBufferAStorageConditionTests = testOrNull["If BufferA is specified, BufferA storage condition is also specified:", Not[validBufferAStorageConditionQ]];

		(* 48.2 BufferB storage condition check *)
		(* If BufferB is specified, BufferBStorageCondition cannot be nulled out *)
		validBufferBStorageConditionQ = If[!MatchQ[resolvedBufferB, {} | Null | {Null}],
			MatchQ[resolvedBufferBStorageCondition, {} | Null{Null}],
			False
		];

		(* Collect invalid option and throw error *)
		invalidBufferBStorageConditionOptions = If[validBufferBStorageConditionQ && messagesQ,
			(
				Message[Error::UnspecifiedBufferStorageCondition, BufferB];
				{BufferBStorageCondition}
			),
			{}
		];

		(* Generate test for buffer storage conditions *)
		invalidBufferBStorageConditionTests = testOrNull["If BufferB is specified, BufferB storage condition is also specified:", Not[validBufferBStorageConditionQ]];

		(* 48.3 BufferC storage condition check *)
		(* If BufferC is specified, BufferCStorageCondition cannot be nulled out *)
		validBufferCStorageConditionQ = If[!MatchQ[resolvedBufferC, {} | Null | {Null}],
			MatchQ[resolvedBufferCStorageCondition, {} | Null{Null}],
			False
		];

		(* Collect invalid option and throw error *)
		invalidBufferCStorageConditionOptions = If[validBufferCStorageConditionQ && messagesQ,
			(
				Message[Error::UnspecifiedBufferStorageCondition, BufferC];
				{BufferCStorageCondition}
			),
			{}
		];

		(* Generate test for buffer storage conditions *)
		invalidBufferCStorageConditionTests = testOrNull["If BufferC is specified, BufferC storage condition is also specified:", Not[validBufferCStorageConditionQ]];

		(* 48.4 BufferD storage condition check *)
		(* If BufferD is specified, BufferDStorageCondition cannot be nulled out *)
		validBufferDStorageConditionQ = If[!MatchQ[resolvedBufferD, {} | Null | {Null}],
			MatchQ[resolvedBufferDStorageCondition, {} | Null{Null}],
			False
		];

		(* Collect invalid option and throw error *)
		invalidBufferDStorageConditionOptions = If[validBufferDStorageConditionQ && messagesQ,
			(
				Message[Error::UnspecifiedBufferStorageCondition, BufferD];
				{BufferDStorageCondition}
			),
			{}
		];

		(* Generate test for buffer storage conditions *)
		invalidBufferDStorageConditionTests = testOrNull["If BufferD is specified, BufferD storage condition is also specified:", Not[validBufferDStorageConditionQ]];


		allAnionSampleOptionCheck = If[!MatchQ[resolvedCationSamples, {} | Null | {Null}] && MatchQ[resolvedAnionSamples, {} | Null | {Null}],
			anySpecifiedQ[
				{
					AnionColumnTemperature,
					AnionInjectionVolume,
					EluentGradient,
					AnionFlowRate,
					AnionGradiendStart,
					AnionGradientEnd,
					AnionGradientDuration,
					AnionEquilibrationTime,
					AnionFlushTime,
					AnionGradient,
					AnionSuppressorMode,
					AnionSuppressorVoltage,
					AnionSuppressorCurrent,
					AnionDetectionTemperature
				},
				ionChromatographyOptionsAssociation
			],
			False
		];

		allCationSampleOptionCheck = If[!MatchQ[resolvedAnionSamples, {} | Null | {Null}] && MatchQ[resolvedCationSamples, {} | Null | {Null}],
			anySpecifiedQ[
				{
					CationColumnTemperature,
					CationInjectionVolume,
					BufferA,
					BufferB,
					BufferC,
					BufferD,
					CationGradientA,
					CationGradientB,
					CationGradientC,
					CationGradientD,
					CationFlowRate,
					CationGradientStart,
					CationGradientEnd,
					CationGradientDuration,
					CationEquilibrationTime,
					CationFlushTime,
					CationGradient,
					CationSuppressorMode,
					CationSuppressorVoltage,
					CationSuppressorCurrent,
					CationDetectionTemperature,
					BufferAStorageCondition,
					BufferBStorageCondition,
					BufferCStorageCondition,
					BufferDStorageCondition
				},
				ionChromatographyOptionsAssociation
			],
			False
		];

		(* If we are throwing messages, throw a warning about option specification *)
		wrongChannelOptionSpecification = MapThread[
			If[#1 && messagesQ && notInEngine,
				Message[Warning::OverwritingSamplelessChannelOptions, #2],
				Nothing
			]&,
			{
				{allAnionSampleOptionCheck, allCationSampleOptionCheck},
				{AnionSamples, CationSamples}
			}
		];

		(* One more error check -- throw a warning if there is no analyte in a particular channel but blank or standard is specified *)
		noSampleWarning = MapThread[
			If[MatchQ[#1, {} | {Null} | Null] && (!MatchQ[#2, {} | {Null} | Null] || !MatchQ[#3, {} | {Null} | Null]) && messagesQ && notInEngine,
				Message[Warning::NoAnalyteInAnalysisChannel, #4],
				Nothing
			]&,
			{
				{resolvedAnionSamples, resolvedCationSamples},
				{resolvedAnionStandard, resolvedCationStandard},
				{resolvedAnionBlank, resolvedCationBlank},
				{AnionChannel, CationChannel}
			}
		];

		(* resolve the Email option if Automatic *)
		resolvedEmail = If[!MatchQ[Lookup[roundedOptionsAssociation, Email], Automatic],
			(* If Email!=Automatic, use the supplied value *)
			Lookup[roundedOptionsAssociation, Email],
			(* If BOTH Upload -> True and Result is a member of Output, send emails. Otherwise, DO NOT send emails *)
			If[And[TrueQ[Lookup[roundedOptionsAssociation, Upload]], MemberQ[outputSpecification, Result]],
				True,
				False
			]
		];

		resolvedExperimentOptions = Association[
			ReplaceRule[myOptions, {
				Instrument -> resolvedInstrument,
				AnalysisChannel -> resolvedAnalysisChannel,
				AnionSamples -> resolvedAnionSamples,
				CationSamples -> resolvedCationSamples,
				ElectrochemicalSamples -> resolvedElectrochemicalSamples,
				Detector -> resolvedDetector,
				AnionColumn -> resolvedAnionColumn,
				CationColumn -> resolvedCationColumn,
				Column -> resolvedColumn,
				AnionGuardColumn -> resolvedAnionGuardColumn,
				CationGuardColumn -> resolvedCationGuardColumn,
				GuardColumn -> resolvedGuardColumn,
				AnionColumnTemperature -> resolvedAnionColumnTemperature,
				CationColumnTemperature -> resolvedCationColumnTemperature,
				ColumnTemperature -> resolvedColumnTemperature,
				NumberOfReplicates -> resolvedNumberOfReplicates,
				SampleTemperature -> resolvedSampleTemperature,
				AnionInjectionVolume -> resolvedAnionInjectionVolume,
				CationInjectionVolume -> resolvedCationInjectionVolume,
				InjectionVolume -> resolvedInjectionVolume,
				EluentGradient -> resolvedEluentGradient,
				AnionGradientStart -> resolvedAnionGradientStart,
				AnionGradientEnd -> resolvedAnionGradientEnd,
				AnionGradientDuration -> resolvedAnionGradientDuration,
				AnionEquilibrationTime -> resolvedAnionEquilibrationTime,
				AnionFlushTime -> resolvedAnionFlushTime,
				AnionFlowRate -> resolvedAnionFlowRate,
				AnionGradient -> resolvedAnionGradient,
				BufferA -> resolvedBufferA,
				BufferB -> resolvedBufferB,
				BufferC -> resolvedBufferC,
				BufferD -> resolvedBufferD,
				CationGradientA -> resolvedCationGradientA,
				CationGradientB -> resolvedCationGradientB,
				CationGradientC -> resolvedCationGradientC,
				CationGradientD -> resolvedCationGradientD,
				CationGradientStart -> resolvedCationGradientStart,
				CationGradientEnd -> resolvedCationGradientEnd,
				CationGradientDuration -> resolvedCationGradientDuration,
				CationEquilibrationTime -> resolvedCationEquilibrationTime,
				CationFlushTime -> resolvedCationFlushTime,
				CationFlowRate -> resolvedCationFlowRate,
				CationGradient -> resolvedCationGradient,
				GradientA -> resolvedGradientA,
				GradientB -> resolvedGradientB,
				GradientC -> resolvedGradientC,
				GradientD -> resolvedGradientD,
				GradientStart -> resolvedGradientStart,
				GradientEnd -> resolvedGradientEnd,
				GradientDuration -> resolvedGradientDuration,
				EquilibrationTime -> resolvedEquilibrationTime,
				FlushTime -> resolvedFlushTime,
				FlowRate -> resolvedFlowRate,
				Gradient -> resolvedGradient,
				NeedleWashSolution -> resolvedNeedleWashSolution,
				AnionSuppressorMode -> resolvedAnionSuppressorMode,
				AnionSuppressorVoltage -> resolvedAnionSuppressorVoltage,
				AnionSuppressorCurrent -> resolvedAnionSuppressorCurrent,
				AnionDetectionTemperature -> resolvedAnionDetectionTemperature,
				CationSuppressorMode -> resolvedCationSuppressorMode,
				CationSuppressorVoltage -> resolvedCationSuppressorVoltage,
				CationSuppressorCurrent -> resolvedCationSuppressorCurrent,
				CationDetectionTemperature -> resolvedCationDetectionTemperature,
				AbsorbanceWavelength -> resolvedAbsorbanceWavelength,
				AbsorbanceSamplingRate -> resolvedAbsorbanceSamplingRate,
				ElectrochemicalDetectionMode -> resolvedElectrochemicalDetectionMode,
				WorkingElectrode -> resolvedWorkingElectrode,
				WorkingElectrodeStorageCondition -> resolvedWorkingElectrodeStorageCondition,
				pHCalibration -> resolvedpHCalibration,
				NeutralpHCalibrationBuffer -> resolvedNeutralpHCalibrationBuffer,
				SecondarypHCalibrationBuffer -> resolvedSecondarypHCalibrationBuffer,
				SecondarypHCalibrationBufferTarget -> resolvedSecondarypHCalibrationBufferTarget,
				ReferenceElectrodeMode -> resolvedReferenceElectrodeMode,
				VoltageProfile -> resolvedVoltageProfile,
				WaveformProfile -> resolvedWaveformProfile,
				ElectrochemicalSamplingRate -> resolvedElectrochemicalSamplingRate,
				DetectionTemperature -> resolvedDetectionTemperature,
				BufferAStorageCondition -> resolvedBufferAStorageCondition,
				BufferBStorageCondition -> resolvedBufferBStorageCondition,
				BufferCStorageCondition -> resolvedBufferCStorageCondition,
				BufferDStorageCondition -> resolvedBufferDStorageCondition,
				Standard -> resolvedStandard,
				StandardAnalysisChannel -> doubleResolvedStandardAnalysisChannel,
				AnionStandard -> ToList@resolvedAnionStandard,
				CationStandard -> ToList@resolvedCationStandard,
				AnionStandardFrequency -> resolvedAnionStandardFrequency,
				CationStandardFrequency -> resolvedCationStandardFrequency,
				StandardFrequency -> resolvedStandardFrequency,
				AnionStandardInjectionVolume -> resolvedAnionStandardInjectionVolume,
				CationStandardInjectionVolume -> resolvedCationStandardInjectionVolume,
				StandardInjectionVolume -> resolvedStandardInjectionVolume,
				StandardEluentGradient -> resolvedStandardEluentGradient,
				AnionStandardFlowRate -> resolvedAnionStandardFlowRate,
				AnionStandardGradientStart -> resolvedAnionStandardGradientStart,
				AnionStandardGradientEnd -> resolvedAnionStandardGradientEnd,
				AnionStandardGradientDuration -> resolvedAnionStandardGradientDuration,
				AnionStandardGradient -> resolvedAnionStandardGradient,
				AnionStandardColumnTemperature -> resolvedAnionStandardColumnTemperature,
				AnionStandardSuppressorMode -> resolvedAnionStandardSuppressorMode,
				AnionStandardSuppressorVoltage -> resolvedAnionStandardSuppressorVoltage,
				AnionStandardSuppressorCurrent -> resolvedAnionStandardSuppressorCurrent,
				AnionStandardDetectionTemperature -> resolvedAnionStandardDetectionTemperature,
				CationStandardGradientA -> resolvedCationStandardGradientA,
				CationStandardGradientB -> resolvedCationStandardGradientB,
				CationStandardGradientC -> resolvedCationStandardGradientC,
				CationStandardGradientD -> resolvedCationStandardGradientD,
				CationStandardFlowRate -> resolvedCationStandardFlowRate,
				CationStandardGradientStart -> resolvedCationStandardGradientStart,
				CationStandardGradientEnd -> resolvedCationStandardGradientEnd,
				CationStandardGradientDuration -> resolvedCationStandardGradientDuration,
				CationStandardGradient -> resolvedCationStandardGradient,
				CationStandardColumnTemperature -> resolvedCationStandardColumnTemperature,
				CationStandardSuppressorMode -> resolvedCationStandardSuppressorMode,
				CationStandardSuppressorVoltage -> resolvedCationStandardSuppressorVoltage,
				CationStandardSuppressorCurrent -> resolvedCationStandardSuppressorCurrent,
				CationStandardDetectionTemperature -> resolvedCationStandardDetectionTemperature,
				StandardGradientA -> resolvedStandardGradientA,
				StandardGradientB -> resolvedStandardGradientB,
				StandardGradientC -> resolvedStandardGradientC,
				StandardGradientD -> resolvedStandardGradientD,
				StandardFlowRate -> resolvedStandardFlowRate,
				StandardGradientStart -> resolvedStandardGradientStart,
				StandardGradientEnd -> resolvedStandardGradientEnd,
				StandardGradientDuration -> resolvedStandardGradientDuration,
				StandardGradient -> resolvedStandardGradient,
				StandardColumnTemperature -> resolvedStandardColumnTemperature,
				StandardAbsorbanceWavelength -> resolvedStandardAbsorbanceWavelength,
				StandardAbsorbanceSamplingRate -> resolvedStandardAbsorbanceSamplingRate,
				StandardElectrochemicalDetectionMode -> resolvedStandardElectrochemicalDetectionMode,
				StandardReferenceElectrodeMode -> resolvedStandardReferenceElectrodeMode,
				StandardVoltageProfile -> resolvedStandardVoltageProfile,
				StandardWaveformProfile -> resolvedStandardWaveformProfile,
				StandardElectrochemicalSamplingRate -> resolvedStandardElectrochemicalSamplingRate,
				StandardDetectionTemperature -> resolvedStandardDetectionTemperature,
				StandardStorageCondition -> resolvedStandardStorageCondition,
				Blank -> ToList@resolvedBlank,
				BlankAnalysisChannel -> doubleResolvedBlankAnalysisChannel,
				AnionBlank -> ToList@doubleResolvedAnionBlank,
				CationBlank -> ToList@doubleResolvedCationBlank,
				AnionBlankFrequency -> resolvedAnionBlankFrequency,
				CationBlankFrequency -> resolvedCationBlankFrequency,
				BlankFrequency -> resolvedBlankFrequency,
				AnionBlankInjectionVolume -> resolvedAnionBlankInjectionVolume,
				CationBlankInjectionVolume -> resolvedCationBlankInjectionVolume,
				BlankInjectionVolume -> resolvedBlankInjectionVolume,
				BlankEluentGradient -> resolvedBlankEluentGradient,
				AnionBlankFlowRate -> resolvedAnionBlankFlowRate,
				AnionBlankGradientStart -> resolvedAnionBlankGradientStart,
				AnionBlankGradientEnd -> resolvedAnionBlankGradientEnd,
				AnionBlankGradientDuration -> resolvedAnionBlankGradientDuration,
				AnionBlankGradient -> resolvedAnionBlankGradient,
				AnionBlankColumnTemperature -> resolvedAnionBlankColumnTemperature,
				AnionBlankSuppressorMode -> resolvedAnionBlankSuppressorMode,
				AnionBlankSuppressorVoltage -> resolvedAnionBlankSuppressorVoltage,
				AnionBlankSuppressorCurrent -> resolvedAnionBlankSuppressorCurrent,
				AnionBlankDetectionTemperature -> resolvedAnionBlankDetectionTemperature,
				CationBlankGradientA -> resolvedCationBlankGradientA,
				CationBlankGradientB -> resolvedCationBlankGradientB,
				CationBlankGradientC -> resolvedCationBlankGradientC,
				CationBlankGradientD -> resolvedCationBlankGradientD,
				CationBlankFlowRate -> resolvedCationBlankFlowRate,
				CationBlankGradientStart -> resolvedCationBlankGradientStart,
				CationBlankGradientEnd -> resolvedCationBlankGradientEnd,
				CationBlankGradientDuration -> resolvedCationBlankGradientDuration,
				CationBlankGradient -> resolvedCationBlankGradient,
				CationBlankColumnTemperature -> resolvedCationBlankColumnTemperature,
				CationBlankSuppressorMode -> resolvedCationBlankSuppressorMode,
				CationBlankSuppressorVoltage -> resolvedCationBlankSuppressorVoltage,
				CationBlankSuppressorCurrent -> resolvedCationBlankSuppressorCurrent,
				CationBlankDetectionTemperature -> resolvedCationBlankDetectionTemperature,
				BlankGradientA -> resolvedBlankGradientA,
				BlankGradientB -> resolvedBlankGradientB,
				BlankGradientC -> resolvedBlankGradientC,
				BlankGradientD -> resolvedBlankGradientD,
				BlankFlowRate -> resolvedBlankFlowRate,
				BlankGradientStart -> resolvedBlankGradientStart,
				BlankGradientEnd -> resolvedBlankGradientEnd,
				BlankGradientDuration -> resolvedBlankGradientDuration,
				BlankGradient -> resolvedBlankGradient,
				BlankColumnTemperature -> resolvedBlankColumnTemperature,
				BlankAbsorbanceWavelength -> resolvedBlankAbsorbanceWavelength,
				BlankAbsorbanceSamplingRate -> resolvedBlankAbsorbanceSamplingRate,
				BlankElectrochemicalDetectionMode -> resolvedBlankElectrochemicalDetectionMode,
				BlankReferenceElectrodeMode -> resolvedBlankReferenceElectrodeMode,
				BlankVoltageProfile -> resolvedBlankVoltageProfile,
				BlankWaveformProfile -> resolvedBlankWaveformProfile,
				BlankElectrochemicalSamplingRate -> resolvedBlankElectrochemicalSamplingRate,
				BlankDetectionTemperature -> resolvedBlankDetectionTemperature,
				BlankStorageCondition -> resolvedBlankStorageCondition,
				AnionColumnRefreshFrequency -> resolvedAnionColumnRefreshFrequency,
				CationColumnRefreshFrequency -> resolvedCationColumnRefreshFrequency,
				ColumnRefreshFrequency -> resolvedColumnRefreshFrequency,
				AnionColumnPrimeTemperature -> resolvedAnionColumnPrimeTemperature,
				ColumnPrimeEluentGradient -> resolvedColumnPrimeEluentGradient,
				AnionColumnPrimeFlowRate -> resolvedAnionColumnPrimeFlowRate,
				AnionColumnPrimeStart -> resolvedAnionColumnPrimeStart,
				AnionColumnPrimeEnd -> resolvedAnionColumnPrimeEnd,
				AnionColumnPrimeDuration -> resolvedAnionColumnPrimeDuration,
				AnionColumnPrimeGradient -> resolvedAnionColumnPrimeGradient,
				AnionColumnPrimeSuppressorMode -> resolvedAnionColumnPrimeSuppressorMode,
				AnionColumnPrimeSuppressorVoltage -> resolvedAnionColumnPrimeSuppressorVoltage,
				AnionColumnPrimeSuppressorCurrent -> resolvedAnionColumnPrimeSuppressorCurrent,
				AnionColumnPrimeDetectionTemperature -> resolvedAnionColumnPrimeDetectionTemperature,
				AnionColumnFlushTemperature -> resolvedAnionColumnFlushTemperature,
				ColumnFlushEluentGradient -> resolvedColumnFlushEluentGradient,
				AnionColumnFlushFlowRate -> resolvedAnionColumnFlushFlowRate,
				AnionColumnFlushStart -> resolvedAnionColumnFlushStart,
				AnionColumnFlushEnd -> resolvedAnionColumnFlushEnd,
				AnionColumnFlushDuration -> resolvedAnionColumnFlushDuration,
				AnionColumnFlushGradient -> resolvedAnionColumnFlushGradient,
				AnionColumnFlushSuppressorMode -> resolvedAnionColumnFlushSuppressorMode,
				AnionColumnFlushSuppressorVoltage -> resolvedAnionColumnFlushSuppressorVoltage,
				AnionColumnFlushSuppressorCurrent -> resolvedAnionColumnFlushSuppressorCurrent,
				AnionColumnFlushDetectionTemperature -> resolvedAnionColumnFlushDetectionTemperature,
				CationColumnPrimeTemperature -> resolvedCationColumnPrimeTemperature,
				CationColumnPrimeGradientA -> resolvedCationColumnPrimeGradientA,
				CationColumnPrimeGradientB -> resolvedCationColumnPrimeGradientB,
				CationColumnPrimeGradientC -> resolvedCationColumnPrimeGradientC,
				CationColumnPrimeGradientD -> resolvedCationColumnPrimeGradientD,
				CationColumnPrimeFlowRate -> resolvedCationColumnPrimeFlowRate,
				CationColumnPrimeStart -> resolvedCationColumnPrimeStart,
				CationColumnPrimeEnd -> resolvedCationColumnPrimeEnd,
				CationColumnPrimeDuration -> resolvedCationColumnPrimeDuration,
				CationColumnPrimeGradient -> resolvedCationColumnPrimeGradient,
				CationColumnPrimeSuppressorMode -> resolvedCationColumnPrimeSuppressorMode,
				CationColumnPrimeSuppressorVoltage -> resolvedCationColumnPrimeSuppressorVoltage,
				CationColumnPrimeSuppressorCurrent -> resolvedCationColumnPrimeSuppressorCurrent,
				CationColumnPrimeDetectionTemperature -> resolvedCationColumnPrimeDetectionTemperature,
				CationColumnFlushTemperature -> resolvedCationColumnFlushTemperature,
				CationColumnFlushGradientA -> resolvedCationColumnFlushGradientA,
				CationColumnFlushGradientB -> resolvedCationColumnFlushGradientB,
				CationColumnFlushGradientC -> resolvedCationColumnFlushGradientC,
				CationColumnFlushGradientD -> resolvedCationColumnFlushGradientD,
				CationColumnFlushFlowRate -> resolvedCationColumnFlushFlowRate,
				CationColumnFlushStart -> resolvedCationColumnFlushStart,
				CationColumnFlushEnd -> resolvedCationColumnFlushEnd,
				CationColumnFlushDuration -> resolvedCationColumnFlushDuration,
				CationColumnFlushGradient -> resolvedCationColumnFlushGradient,
				CationColumnFlushSuppressorMode -> resolvedCationColumnFlushSuppressorMode,
				CationColumnFlushSuppressorVoltage -> resolvedCationColumnFlushSuppressorVoltage,
				CationColumnFlushSuppressorCurrent -> resolvedCationColumnFlushSuppressorCurrent,
				CationColumnFlushDetectionTemperature -> resolvedCationColumnFlushDetectionTemperature,
				ColumnPrimeTemperature -> resolvedColumnPrimeTemperature,
				ColumnPrimeGradientA -> resolvedColumnPrimeGradientA,
				ColumnPrimeGradientB -> resolvedColumnPrimeGradientB,
				ColumnPrimeGradientC -> resolvedColumnPrimeGradientC,
				ColumnPrimeGradientD -> resolvedColumnPrimeGradientD,
				ColumnPrimeFlowRate -> resolvedColumnPrimeFlowRate,
				ColumnPrimeStart -> resolvedColumnPrimeStart,
				ColumnPrimeEnd -> resolvedColumnPrimeEnd,
				ColumnPrimeDuration -> resolvedColumnPrimeDuration,
				ColumnPrimeGradient -> resolvedColumnPrimeGradient,
				ColumnPrimeAbsorbanceWavelength -> resolvedColumnPrimeAbsorbanceWavelength,
				ColumnPrimeAbsorbanceSamplingRate -> resolvedColumnPrimeAbsorbanceSamplingRate,
				ColumnPrimeElectrochemicalDetectionMode -> resolvedColumnPrimeElectrochemicalDetectionMode,
				ColumnPrimeReferenceElectrodeMode -> resolvedColumnPrimeReferenceElectrodeMode,
				ColumnPrimeVoltageProfile -> resolvedColumnPrimeVoltageProfile,
				ColumnPrimeWaveformProfile -> resolvedColumnPrimeWaveformProfile,
				ColumnPrimeElectrochemicalSamplingRate -> resolvedColumnPrimeElectrochemicalSamplingRate,
				ColumnPrimeDetectionTemperature -> resolvedColumnPrimeDetectionTemperature,
				ColumnFlushGradientA -> resolvedColumnFlushGradientA,
				ColumnFlushGradientB -> resolvedColumnFlushGradientB,
				ColumnFlushGradientC -> resolvedColumnFlushGradientC,
				ColumnFlushGradientD -> resolvedColumnFlushGradientD,
				ColumnFlushFlowRate -> resolvedColumnFlushFlowRate,
				ColumnFlushStart -> resolvedColumnFlushStart,
				ColumnFlushEnd -> resolvedColumnFlushEnd,
				ColumnFlushDuration -> resolvedColumnFlushDuration,
				ColumnFlushGradient -> resolvedColumnFlushGradient,
				ColumnFlushAbsorbanceWavelength -> resolvedColumnFlushAbsorbanceWavelength,
				ColumnFlushAbsorbanceSamplingRate -> resolvedColumnFlushAbsorbanceSamplingRate,
				ColumnFlushElectrochemicalDetectionMode -> resolvedColumnFlushElectrochemicalDetectionMode,
				ColumnFlushReferenceElectrodeMode -> resolvedColumnFlushReferenceElectrodeMode,
				ColumnFlushVoltageProfile -> resolvedColumnFlushVoltageProfile,
				ColumnFlushWaveformProfile -> resolvedColumnFlushWaveformProfile,
				ColumnFlushElectrochemicalSamplingRate -> resolvedColumnFlushElectrochemicalSamplingRate,
				ColumnFlushDetectionTemperature -> resolvedColumnFlushDetectionTemperature,
				ColumnFlushTemperature -> resolvedColumnFlushTemperature,
				AnionInjectionTable -> resolvedAnionInjectionTable,
				CationInjectionTable -> resolvedCationInjectionTable,
				ElectrochemicalInjectionTable -> resolvedElectrochemicalInjectionTable
			}] /. {} | {Null} -> Null
		];

		(*-- UNRESOLVABLE OPTION CHECKS --*)

		(* Check our invalid input and invalid option variables and throw Error::InvalidInput or Error::InvalidOption if necessary. *)
		invalidInputs = DeleteDuplicates[Flatten[{discardedInvalidInputs, containerlessInvalidInputs}]];
		invalidOptions = DeleteDuplicates[Flatten[{
			nameInvalidOptions,
			instrumentInvalidOption,
			imbalancedAnionCationGroupingOption,
			inconsistentAnionChannelOption,
			inconsistentCationChannelOption,
			invalidSampleGroupingOption,
			invalidStandardConflictOptions,
			invalidAnionStandardConflictOptions,
			invalidCationStandardConflictOptions,
			inconsistentAnionStandardChannelOption,
			inconsistentCationStandardChannelOption,
			invalidStandardGroupingOption,
			invalidBlankConflictOptions,
			invalidAnionBlankConflictOptions,
			invalidCationBlankConflictOptions,
			imbalancedBlankAnionCationGroupingOption,
			inconsistentAnionBlankChannelOption,
			inconsistentCationBlankChannelOption,
			invalidBlankGroupingOption,
			anionColumnInvalidOptions,
			cationColumnInvalidOptions,
			anionGuardColumnInvalidOption,
			cationGuardColumnInvalidOption,
			invalidAnionSampleConflictOptions,
			notSpecifiedAnionGradientStartEndOptions,
			inconsistentAnionGradientOptions,
			incompatibleAnionFlowRateOptions,
			invalidAnionGradientCompositionOptions,
			invalidCationSampleConflictOptions,
			notSpecifiedCationGradientStartEndOptions,
			inconsistentCationGradientOptions,
			incompatibleCationFlowRateOptions,
			invalidCationGradientCompositionOptions,
			notSpecifiedGradientStartEndOptions,
			conflictingAnionSuppressorModeOptions,
			conflictingCationSuppressorModeOptions,
			inconsistentAnionStandardGradientOptions,
			invalidAnionStandardGradientCompositionOptions,
			incompatibleAnionStandardFlowRateOptions,
			notSpecifiedAnionStandardGradientStartEndOptions,
			conflictingAnionStandardSuppressorModeOptions,
			inconsistentCationStandardGradientOptions,
			incompatibleCationStandardFlowRateOptions,
			invalidCationStandardGradientCompositionOptions,
			notSpecifiedCationStandardGradientStartEndOptions,
			conflictingCationStandardSuppressorModeOptions,
			inconsistentStandardGradientOptions,
			invalidStandardGradientCompositionOptions,
			incompatibleStandardFlowRateOptions,
			notSpecifiedStandardGradientStartEndOptions,
			inconsistentAnionBlankGradientOptions,
			invalidAnionBlankGradientCompositionOptions,
			incompatibleAnionBlankFlowRateOptions,
			notSpecifiedAnionBlankGradientStartEndOptions,
			conflictingAnionBlankSuppressorModeOptions,
			inconsistentCationBlankGradientOptions,
			invalidCationBlankGradientCompositionOptions,
			incompatibleCationBlankFlowRateOptions,
			notSpecifiedCationBlankGradientStartEndOptions,
			inconsistentBlankGradientOptions,
			invalidBlankGradientCompositionOptions,
			incompatibleBlankFlowRateOptions,
			notSpecifiedBlankGradientStartEndOptions,
			conflictingCationBlankSuppressorModeOptions,
			inconsistentAnionColumnPrimeGradientOptions,
			inconsistentAnionColumnFlushGradientOptions,
			invalidAnionColumnPrimeGradientCompositionOptions,
			invalidAnionColumnFlushGradientCompositionOptions,
			conflictingAnionColumnPrimeSuppressorModeOptions,
			conflictingAnionColumnFlushSuppressorModeOptions,
			inconsistentCationColumnPrimeGradientOptions,
			inconsistentCationColumnFlushGradientOptions,
			invalidCationColumnPrimeGradientCompositionOptions,
			invalidCationColumnFlushGradientCompositionOptions,
			conflictingCationColumnPrimeSuppressorModeOptions,
			conflictingCationColumnFlushSuppressorModeOptions,
			notSpecifiedAnionColumnPrimeGradientStartEndOptions,
			notSpecifiedAnionColumnFlushGradientStartEndOptions,
			notSpecifiedCationColumnPrimeGradientStartEndOptions,
			notSpecifiedCationColumnFlushGradientStartEndOptions,
			notSpecifiedColumnPrimeGradientStartEndOptions,
			notSpecifiedColumnFlushGradientStartEndOptions,
			foreignAnionBlankOptions,
			foreignCationBlankOptions,
			foreignBlankOptions,
			foreignAnionStandardOptions,
			foreignCationStandardOptions,
			foreignStandardOptions,
			invalidBufferAStorageConditionOptions,
			invalidBufferBStorageConditionOptions,
			invalidBufferCStorageConditionOptions,
			invalidBufferDStorageConditionOptions,
			foreignAnionSampleOptions,
			foreignCationSampleOptions,
			foreignSampleOptions,
			incompatibleCationFlowRateOptions,
			invalidElectrochemicalSampleConflictOptions,
			invalidAbsorbanceOptions,
			invalidElectrochemicalDetectionModeOptions,
			invalidWaveformDetectionModeOptions,
			multipleWaveformDurationOptions,
			voltageProfileTimeOptions,
			waveformProfileTimeOptions,
			invalidStandardAbsorbanceOptions,
			invalidStandardElectrochemicalDetectionModeOptions,
			multipleStandardDetectionModeOptions,
			invalidStandardWaveformDetectionModeOptions,
			multipleStandardWaveformDurationOptions,
			standardVoltageProfileTimeOptions,
			standardWaveformProfileTimeOptions,
			invalidBlankAbsorbanceOptions,
			invalidBlankElectrochemicalDetectionModeOptions,
			multipleBlankDetectionModeOptions,
			invalidBlankWaveformDetectionModeOptions,
			multipleBlankWaveformDurationOptions,
			blankVoltageProfileTimeOptions,
			blankWaveformProfileTimeOptions,
			invalidColumnPrimeAbsorbanceOptions,
			invalidColumnPrimeElectrochemicalDetectionModeOptions,
			multipleColumnPrimeDetectionModeOptions,
			invalidColumnPrimeWaveformDetectionModeOptions,
			multipleColumnPrimeWaveformDurationOptions,
			columnPrimeVoltageProfileTimeOptions,
			columnPrimeWaveformProfileTimeOptions,
			invalidColumnFlushAbsorbanceOptions,
			invalidColumnFlushElectrochemicalDetectionModeOptions,
			multipleColumnFlushDetectionModeOptions,
			invalidColumnFlushWaveformDetectionModeOptions,
			multipleColumnFlushWaveformDurationOptions,
			columnFlushVoltageProfileTimeOptions,
			columnFlushWaveformProfileTimeOptions,
			notSpecifiedAnionGradientDurationOptions,
			notSpecifiedCationGradientDurationOptions,
			notSpecifiedGradientDurationOptions,
			notSpecifiedAnionStandardGradientDurationOptions,
			notSpecifiedCationStandardGradientDurationOptions,
			notSpecifiedStandardGradientDurationOptions,
			notSpecifiedAnionBlankGradientDurationOptions,
			notSpecifiedCationBlankGradientDurationOptions,
			notSpecifiedAnionColumnPrimeGradientDurationOptions,
			notSpecifiedCationColumnPrimeGradientDurationOptions,
			notSpecifiedColumnPrimeGradientDurationOptions,
			notSpecifiedAnionColumnFlushGradientDurationOptions,
			notSpecifiedCationColumnFlushGradientDurationOptions,
			notSpecifiedColumnFlushGradientDurationOptions,
			invalidAnalysisChannelOption,
			invalidpHCalibrationOptions,
			instrumentIncompatibleOption,
			invalidGradientCompositionOptions,
			detectionOptionConflictOptions,
			invalidElectrochemicalOptions,
			invalidStandardElectrochemicalOptions,
			invalidBlankElectrochemicalOptions,
			invalidColumnPrimeElectrochemicalOptions,
			invalidColumnFlushElectrochemicalOptions,
			invalidElectrochemicalStandardConflictOptions,
			invalidElectrochemicalBlankConflictOptions,
			invalidAnionColumnPrimeConflictOptions,
			invalidCationColumnPrimeConflictOptions,
			invalidElectrochemicalColumnPrimeConflictOptions,
			invalidAnionColumnFlushConflictOptions,
			invalidCationColumnFlushConflictOptions,
			invalidElectrochemicalColumnFlushConflictOptions,
			nullBlankOption,
			nullStandardOption
		}]];


		(*combine all of the tests*)
		allTests = Cases[Flatten[{
			validNameTest,
			notRetiredInstrumentTests,
			notDeprecatedInstruemntTests,
			repeatedGroupingTests,
			anionChannelSpecificationTests,
			cationChannelSpecificationTests,
			sampleGroupingTests,
			standardConflictTest,
			anionStandardConflictTest,
			cationStandardConflictTest,
			anionStandardChannelSpecificationTests,
			cationStandardChannelSpecificationTests,
			standardGroupingTests,
			blankConflictTest,
			anionBlankConflictTest,
			cationBlankConflictTest,
			repeatedBlankGroupingTests,
			anionBlankChannelSpecificationTests,
			cationBlankChannelSpecificationTests,
			blankGroupingTests,
			anionColumnTechniqueTests,
			cationColumnTechniqueTests,
			anionColumnAnalysisChannelTests,
			cationColumnAnalysisChannelTests,
			anionGuardColumnTypeTests,
			anionGuardColumnTechniqueTests,
			cationGuardColumnTypeTests,
			cationGuardColumnTechniqueTests,
			recommendedInjectionVolumeTests,
			anionSampleConflictTest,
			notSpecifiedAnionGradientStartEndTests,
			inconsistentAnionGradientTests,
			invalidAnionGradientTests,
			cationSampleConflictTest,
			notSpecifiedCationGradientStartEndTests,
			inconsistentCationGradientTests,
			invalidCationGradientTests,
			anionSuppressorModeTests,
			cationSuppressorModeTests,
			inconsistentAnionStandardGradientTests,
			invalidAnionStandardGradientTests,
			notSpecifiedAnionStandardGradientStartEndTests,
			anionStandardSuppressorModeTests,
			inconsistentCationStandardGradientTests,
			invalidCationStandardGradientTests,
			notSpecifiedCationStandardGradientStartEndTests,
			cationStandardSuppressorModeTests,
			inconsistentAnionBlankGradientTests,
			invalidAnionBlankGradientTests,
			notSpecifiedAnionBlankGradientStartEndTests,
			anionBlankSuppressorModeTests,
			inconsistentCationBlankGradientTests,
			invalidCationBlankGradientTests,
			notSpecifiedCationBlankGradientStartEndTests,
			inconsistentBlankGradientTests,
			invalidBlankGradientTests,
			notSpecifiedBlankGradientStartEndTests,
			cationBlankSuppressorModeTests,
			inconsistentAnionColumnPrimeGradientTests,
			inconsistentAnionColumnFlushGradientTests,
			invalidAnionColumnPrimeGradientCompositionTests,
			invalidAnionColumnFlushGradientCompositionTests,
			anionColumnPrimeSuppressorModeTests,
			anionColumnFlushSuppressorModeTests,
			inconsistentCationColumnPrimeGradientTests,
			inconsistentCationColumnFlushGradientTests,
			invalidCationColumnPrimeGradientCompositionTests,
			invalidCationColumnFlushGradientCompositionTests,
			cationColumnPrimeSuppressorModeTests,
			cationColumnFlushSuppressorModeTests,
			notSpecifiedAnionColumnPrimeGradientStartEndTests,
			notSpecifiedAnionColumnFlushGradientStartEndTests,
			notSpecifiedCationColumnPrimeGradientStartEndTests,
			notSpecifiedCationColumnFlushGradientStartEndTests,
			foreignAnionBlankTest,
			foreignCationBlankTest,
			foreignBlankTest,
			foreignAnionStandardTest,
			foreignCationStandardTest,
			foreignStandardTest,
			invalidBufferAStorageConditionTests,
			invalidBufferBStorageConditionTests,
			invalidBufferCStorageConditionTests,
			invalidBufferDStorageConditionTests,
			foreignAnionSampleTest,
			foreignCationSampleTest,
			foreignSampleTest,
			invalidAnionFlowRateTests,
			invalidCationFlowRateTests,
			invalidAnionStandardFlowRateTests,
			invalidCationStandardFlowRateTests,
			invalidStandardFlowRateTests,
			invalidAnionBlankFlowRateTests,
			invalidCationBlankFlowRateTests,
			invalidBlankFlowRateTests,
			electrochemicalSampleConflictTest,
			absorbanceOptionTest,
			electrochemicalModeOptionTest,
			multipleDetectionModeOptionTest,
			invalidWaveformDetectionModeTest,
			multipleWaveformDurationTest,
			voltageProfileTimeTest,
			waveformProfileTimeTest,
			standardAbsorbanceOptionTest,
			standardElectrochemicalModeOptionTest,
			multipleStandardDetectionModeOptionTest,
			invalidStandardWaveformDetectionModeTest,
			multipleStandardWaveformDurationTest,
			standardVoltageProfileTimeTest,
			standardWaveformProfileTimeTest,
			blankAbsorbanceOptionTest,
			blankElectrochemicalModeOptionTest,
			multipleBlankDetectionModeOptionTest,
			invalidBlankWaveformDetectionModeTest,
			multipleBlankWaveformDurationTest,
			blankVoltageProfileTimeTest,
			blankWaveformProfileTimeTest,
			columnPrimeAbsorbanceOptionTest,
			columnPrimeElectrochemicalModeOptionTest,
			multipleColumnPrimeDetectionModeOptionTest,
			invalidColumnPrimeWaveformDetectionModeTest,
			multipleColumnPrimeWaveformDurationTest,
			columnPrimeVoltageProfileTimeTest,
			columnPrimeWaveformProfileTimeTest,
			columnFlushAbsorbanceOptionTest,
			columnFlushElectrochemicalModeOptionTest,
			multipleColumnFlushDetectionModeOptionTest,
			invalidColumnFlushWaveformDetectionModeTest,
			multipleColumnFlushWaveformDurationTest,
			columnFlushVoltageProfileTimeTest,
			columnFlushWaveformProfileTimeTest,
			notSpecifiedAnionGradientDurationTests,
			notSpecifiedCationGradientDurationTests,
			notSpecifiedGradientDurationTests,
			notSpecifiedAnionStandardGradientDurationTests,
			notSpecifiedCationStandardGradientDurationTests,
			notSpecifiedGradientDurationTests,
			notSpecifiedAnionBlankGradientDurationTests,
			notSpecifiedCationBlankGradientDurationTests,
			notSpecifiedBlankGradientDurationTests,
			notSpecifiedAnionColumnPrimeGradientDurationTests,
			notSpecifiedCationColumnPrimeGradientDurationTests,
			notSpecifiedColumnPrimeGradientDurationTests,
			notSpecifiedAnionColumnFlushGradientDurationTests,
			notSpecifiedCationColumnFlushGradientDurationTests,
			notSpecifiedColumnFlushGradientDurationTests,
			analysisChannelTests,
			pHCalibrationOptionTests,
			compatibleInstrumentTests,
			detectorTest,
			detectorConflictTest,
			electrochemicalOptionTest,
			standardElectrochemicalOptionTest,
			blankElectrochemicalOptionTest,
			columnPrimeElectrochemicalOptionTest,
			columnFlushElectrochemicalOptionTest,
			electrochemicalStandardConflictTest,
			electrochemicalBlankConflictTest,
			anionColumnPrimeConflictTest,
			cationColumnPrimeConflictTest,
			electrochemicalColumnPrimeConflictTest,
			anionColumnFlushConflictTest,
			cationColumnFlushConflictTest,
			electrochemicalColumnFlushConflictTest,
			nullBlankTests,
			nullStandardTests
		}], _EmeraldTest];


		(* Throw Error::InvalidInput if there are invalid inputs. *)
		If[Length[invalidInputs] > 0 && !gatherTests,
			Message[Error::InvalidInput, ObjectToString[invalidInputs, Cache -> fullCache, Simulation -> updatedSimulation]]
		];

		(* Throw Error::InvalidOption if there are invalid options. *)
		If[Length[invalidOptions] > 0 && !gatherTests,
			Message[Error::InvalidOption, invalidOptions]
		];

		(*-- CONTAINER GROUPING RESOLUTION --*)

		(* Get sampler container information *)
		sampleContainerPackets = Map[fetchPacketFromCache[#, fullCache]&, Download[Lookup[simulatedSamplePackets, Container, {}], Object]];
		sampleContainerModel = Download[If[NullQ[#], Null, Lookup[#, Model, Null]]& /@ sampleContainerPackets, Object];

		(* The default containers for autosampler is either 96 well 2 mL Deep well plate or HPLC vials of different materials and manufactureres. All the vials are similar enough in dimensions and we treat them the same way in Chromeleon software *)
		(* This is the same list we allow in HPLC *)
		defaultAliquotContainer = Flatten[{
			(* 96-well 2mL Deep Well Plate *)
			Model[Container, Plate, "id:L8kPEjkmLbvW"],
			(* We could assign this to a variable but it returns exactly what we need and is only used here so just inserting the memoized search directly. *)
			allLCCompatibleVialSearch["Memoization"]
		}];

		(* First determine if we are aliquoting *)
		(* If the input samples are in a container different than the default container for the instrument, we will aliquot them into default containers. otherwise we will respect the option or set to False to avoid aliquotting. *)
		resolvedAliquotQ = MapThread[
			If[MemberQ[defaultAliquotContainer, #1],
				#2/.{Automatic->False},
				True
			]&,
			{sampleContainerModel, Lookup[samplePrepOptions, Aliquot]}
		];

		(* Resolve RequiredAliquotContainers *)
		targetContainers = MapThread[
			Which[
				(* if we're not aliquoting, then this is already Null *)
				MatchQ[#1, False | Null], Null,
				(* if we are indeed aliquoting and the user specified an aliquot container that is the default container, then go with it *)
				MatchQ[#1, True] && MatchQ[#2, Except[Automatic]] && MemberQ[defaultAliquotContainer, Download[#2, Object]], #2,
				(* if 1. we are aliquoting AND 2. user specified aliquot containers that are different from the default containers *)
				(* then we need to check if the specified container has a compatible footprint *)
				MatchQ[#1, True] && MatchQ[#2, Except[Automatic]] && !MemberQ[defaultAliquotContainer, Download[#2, Object]],
				If[
					(* if the specified aliquot container is compatible, then leave it as it is *)
					CompatibleFootprintQ[Model[Container, Deck, "id:AEqRl954GG45"], #2, ExactMatch -> False, Cache -> fullCache],
					#2,
					(* otherwise, specify the aliquot container as the default container *)
					Model[Container, Plate, "96-well 2mL Deep Well Plate"]
				],
				(* the default aliquot container is 96 well plate *)
				True, Model[Container, Plate, "96-well 2mL Deep Well Plate"]
			]&,
			{resolvedAliquotQ, Lookup[samplePrepOptions, AliquotContainer]}
		];

		(* Injection Volumes were split into AnionInjectionVolume and CationInjectionVolume previous *)
		(* Now we have to compile the resolved injection volumes to a list index matching to the input samples *)
		resolvedInjectionVolumes = If[MemberQ[ToList@resolvedAnalysisChannel, ElectrochemicalChannel],

			resolvedInjectionVolume,

			If[imbalancedAnionCationGroupingErrors || And @@ ToList[consistentAnionChannelQ] || And @@ ToList[consistentCationChannelQ],
				0 Microliter,
				MapThread[
					(* Look at the standard analysis channel assignment of each standard *)
					Switch[#1,
						(* If its's AnionChannel, then find the position of the standard from the list of anion standard *)
						(* Finally pull out the injection volume from the list of resolved AnionStandardInjectionVolume *)
						AnionChannel,
						Part[Flatten[resolvedAnionInjectionVolume], First@First@Position[ToList@Download[resolvedAnionSamples, Object], #2]],

						(* Repeat for cation standard *)
						CationChannel,
						Part[Flatten[resolvedCationInjectionVolume], First@First@Position[ToList@Download[resolvedCationSamples, Object], #2]]
					]&,
					{ToList@resolvedAnalysisChannel, ToList@Download[simulatedSamples, Object]}
				]
			]
		];

		aliquotOptions = KeySelect[samplePrepOptions, And[MatchQ[#, Alternatives @@ ToExpression[Options[AliquotOptions][[All, 1]]]], MemberQ[Keys[samplePrepOptions], #]]&];

		(* Resolve Aliquot Options *)
		{resolvedAliquotOptions, aliquotTests} = If[imbalancedAnionCationGroupingErrors || imbalancedStandardAnionCationGroupingErrors || imbalancedBlankAnionCationGroupingErrors || And @@ consistentAnionChannelQ || And @@ consistentCationChannelQ || And @@ consistentAnionStandardChannelQ || And @@ consistentCationStandardChannelQ || And @@ consistentAnionBlankChannelQ || And @@ consistentCationBlankChannelQ,
			{{}, {}},

			If[gatherTests,
				(* Note: Also include AllowSolids\[Rule]True as an option to this function if your experiment function can take solid samples as input. Otherwise, resolveAliquotOptions will throw an error if solid samples will be given as input to your function. *)
				resolveAliquotOptions[
					ExperimentIonChromatography,
					mySamples,
					simulatedSamples,
					ReplaceRule[Normal@aliquotOptions, resolvedSamplePrepOptions],
					RequiredAliquotAmounts -> resolvedInjectionVolumes + 30 Microliter,
					AliquotWarningMessage -> "because the given samples are not in containers that are compatible with IonChromatography instrument.",
					Cache -> cache,
					Simulation->updatedSimulation,
					RequiredAliquotContainers -> targetContainers,
					Output -> {Result, Tests}
				],

				(* Note on the required aliquot amount: since the procedure is really long, 30 microliter, which is greater than the autosampler dead volume is added to injection volume to compensate for evaporation *)
				{
					resolveAliquotOptions[
						ExperimentIonChromatography,
						mySamples,
						simulatedSamples,
						ReplaceRule[Normal@aliquotOptions, resolvedSamplePrepOptions],
						RequiredAliquotAmounts -> resolvedInjectionVolumes + 30 Microliter,
						AliquotWarningMessage -> "because the given samples are not in containers that are compatible with IonChromatography instrument.",
						Cache -> cache,
						Simulation->updatedSimulation,
						RequiredAliquotContainers -> targetContainers,
						Output -> Result
					],
					{}
				}
			]
		];

		(* Resolve Post Processing Options *)
		resolvedPostProcessingOptions = resolvePostProcessingOptions[myOptions];

		(* Join all resolved options *)
		resolvedOptions = Normal@Join[
			resolvedExperimentOptions,
			Association@resolvedSamplePrepOptions,
			Association@resolvedAliquotOptions,
			Association@resolvedPostProcessingOptions,
			<|
				Cache -> Lookup[roundedOptionsAssociation, Cache],
				FastTrack -> Lookup[roundedOptionsAssociation, FastTrack],
				Template -> Lookup[roundedOptionsAssociation, Template],
				ParentProtocol -> Lookup[roundedOptionsAssociation, ParentProtocol],
				Operator -> Lookup[roundedOptionsAssociation, Operator],
				Confirm -> Lookup[roundedOptionsAssociation, Confirm],
				CanaryBranch -> Lookup[roundedOptionsAssociation, CanaryBranch],
				Name -> Lookup[roundedOptionsAssociation, Name],
				Upload -> Lookup[roundedOptionsAssociation, Upload],
				Output -> Lookup[roundedOptionsAssociation, Output],
				Email -> resolvedEmail,
				SamplesInStorageCondition -> Lookup[roundedOptionsAssociation, SamplesInStorageCondition]
			|>
		];

		(* Return our resolved options and/or tests. *)
		outputSpecification /. {
			Result -> resolvedOptions,
			Tests -> allTests
		}
	];


(* ::Subsubsection:: *)
(*ExperimentIonChromatography Resource Packets*)


DefineOptions[
	experimentIonChromatographyResourcePackets,
	Options :> {HelperOutputOption, CacheOption, SimulationOption}
];


experimentIonChromatographyResourcePackets[mySamples : {ObjectP[Object[Sample]]..}, myUnresolvedOptions : {___Rule}, myResolvedOptions : {___Rule}, ops : OptionsPattern[]] := Module[
	{
		expandedInputs, expandedResolvedOptions, resolvedOptionsNoHidden, outputSpecification, output, gatherTests, messages, inheritedCache, numReplicates, samplesWithReplicates,
		optionsWithReplicates,
		anionColumnLookup, anionGuardColumnLookup, cationColumnLookup, cationGuardColumnLookup, anionColumnResource, anionGuardColumnResource, cationColumnResource,
		cationGuardColumnResource, anionInjectionTable, cationInjectionTable, anionSamplePositions, anionStandardPositions, anionBlankPositions, anionColumnPrimePositions,
		anionColumnFlushPositions, cationSamplePositions, cationStandardPositions, cationBlankPositions, cationColumnPrimePositions, cationColumnFlushPositions,
		anionStandardLookup, cationStandardLookup, anionBlankLookup, cationBlankLookup, anionStandardMappingAssociation, cationStandardMappingAssociation, anionBlankMappingAssociation,
		cationBlankMappingAssociation, anionColumnPrimeMappingAssociation, cationColumnPrimeMappingAssociation, anionColumnFlushMappingAssociation, anionStandardReverseAssociation,
		cationStandardReverseAssociation, anionBlankReverseAssociation, cationBlankReverseAssociation, cationColumnFlushMappingAssociation, anionColumnPrimeReverseAssociation,
		cationColumnPrimeReverseAssociation, anionColumnFlushReverseAssociation, cationColumnFlushReverseAssociation, anionSampleReverseAssociation, cationSampleReverseAssociation,
		paddedAnionInjectionTable, paddedCationInjectionTable, anionSampleGradient, cationSampleGradient, anionStandardGradient, cationStandardGradient, anionBlankGradient,
		cationBlankGradient, anionInjectionTableWithLinks, cationInjectionTableWithLinks, uniqueAnionSamples, uniqueCationSamples,
		anionColumnPrimeGradient, cationColumnPrimeGradient, anionColumnFlushGradient, cationColumnFlushGradient, resolvedAnionGradients, resolvedCationGradients, anionGradientMethodInPlace,
		cationGradientMethodInPlace, anionGradientObjectsToMake, cationGradientObjectsToMake, anionSuppressor, cationSuppressor,
		anionStandardTuples, cationStandardTuples, assignedAnionStandardTuples, assignedCationStandardTuples, groupedAnionStandardsTuples, groupedCationStandardsTuples,
		groupedAnionStandardsPositionVolumes, groupedCationStandardsPositionVolumes, groupedAnionStandardShared, groupedCationStandardShared, groupedAnionStandard,
		groupedCationStandard, flatAnionStandardResources, flatCationStandardResources, linkedAnionStandardResources, linkedCationStandardResources, anionBlankTuples, cationBlankTuples,
		assignedAnionBlankTuples, assignedCationBlankTuples, groupedAnionBlanksTuples, groupedCationBlanksTuples, groupedAnionBlanksPositionVolumes, groupedCationBlanksPositionVolumes,
		groupedAnionBlankShared, groupedCationBlankShared, groupedAnionBlank, groupedCationBlank, flatAnionBlankResources, flatCationBlankResources, linkedAnionBlankResources,
		linkedCationBlankResources, linkedAnionSampleResources, linkedCationSampleResources, anionSamplePositionsCorresponded, cationSamplePositionsCorresponded, anionTableGradients,
		anionStandardPositionsCorresponded, cationStandardPositionsCorresponded, anionBlankPositionsCorresponded, cationBlankPositionsCorresponded, cationTableGradients,
		anionColumnPrimePositionsCorresponded, cationColumnPrimePositionsCorresponded, anionColumnFlushPositionsCorresponded, cationColumnFlushPositionsCorresponded,
		anionInjectionTableFull, cationInjectionTableFull, anionColumnTempAdded, cationColumnTempAdded, anionStandardColumnTempAdded, cationStandardColumnTempAdded, anionBlankColumnTempAdded,
		cationBlankColumnTempAdded, anionColumnPrimeTempAdded, cationColumnPrimeTempAdded, anionColumnFlushTempAdded, cationColumnFlushTempAdded, anionInjectionTableColumnTempFull,
		cationInjectionTableColumnTempFull, anionSampleTuples, cationSampleTuples, anionOffsets, cationOffsets, anionInsertionAssociation, cationInsertionAssociation, anionInjectionTableInserted,
		cationInjectionTableInserted, anionInjectionTableWithReplicates, cationInjectionTableWithReplicates, anionInjectionTableUploadable, cationInjectionTableUploadable,
		anionSystemPrimeGradientMethod, cationSystemPrimeGradientMethod, anionSystemFlushGradientMethod, cationSystemFlushGradientMethod, anionSystemPrimeGradientPacket,
		cationSystemPrimeGradientPacket, anionSystemFlushGradientPacket, cationSystemFlushGradientPacket, anionSystemPrimeGradient, cationSystemPrimeGradient, anionSystemFlushGradient,
		cationSystemFlushGradient, systemPrimeBufferContainer, systemFlushBufferContainer, bufferContainer, alkalineBufferContainer,
		bufferContainerDeadVolume, alkalineBufferContainerContainerDeadVolume, anionSystemPrimeInletSolutionVolume, cationSystemPrimeBufferAVolume, cationSystemPrimeBufferBVolume, cationSystemPrimeBufferCVolume, cationSystemPrimeBufferDVolume,
		anionSystemPrimeGradientInPercent, anionSystemFlushGradientInPercent, anionSystemPrimeInletSolutionResource, cationSystemPrimeBufferAResource, cationSystemPrimeBufferBResource,
		cationSystemPrimeBufferCResource, cationSystemPrimeBufferDResource, anionSystemFlushInletSolutionVolume, cationSystemFlushBufferAVolume, cationSystemFlushBufferBVolume,
		cationSystemFlushBufferCVolume, cationSystemFlushBufferDVolume, anionSystemFlushInletSolutionResource, cationSystemFlushBufferAResource, cationSystemFlushBufferBResource,
		cationSystemFlushBufferCResource, cationSystemFlushBufferDResource, needleWashSolution, anionColumnPrimeTemperatures, columnPrimeEluentGradients, anionColumnPrimeFlowRates,
		anionColumnPrimeGradients, anionColumnPrimeSuppressorModes, anionColumnPrimeSuppressorVoltages, anionColumnPrimeSuppressorCurrents, anionColumnPrimeDetectionTemperatures,
		cationColumnPrimeTemperatures, columnPrimeGradientA, columnPrimeGradientB, columnPrimeGradientC, columnPrimeGradientD, cationColumnPrimeFlowRates, cationColumnPrimeGradients,
		cationColumnPrimeSuppressorModes, cationColumnPrimeSuppressorVoltages, cationColumnPrimeSuppressorCurrents, cationColumnPrimeDetectionTemperatures, anionColumnTemperatures,
		eluentGradients, anionFlowRates, anionGradients, anionSuppressorModes, anionSuppressorVoltages, anionSuppressorCurrents, anionDetectionTemperatures, cationColumnTemperatures,
		gradientA, gradientB, gradientC, gradientD, cationFlowRates, cationGradients, cationSuppressorModes, cationSuppressorVoltages, cationSuppressorCurrents,
		cationDetectionTemperatures, anionStandardColumnTemperatures, standardEluentGradients, anionStandardFlowRates, anionStandardGradients, anionStandardSuppressorModes,
		anionStandardSuppressorVoltages, anionStandardSuppressorCurrents, anionStandardDetectionTemperatures, cationStandardColumnTemperatures, standardGradientA,
		standardGradientB, standardGradientC, standardGradientD, cationStandardFlowRates, cationStandardGradients, cationStandardSuppressorModes, cationStandardSuppressorVoltages,
		cationStandardSuppressorCurrents, cationStandardDetectionTemperatures, anionBlankColumnTemperatures, blankEluentGradients, anionBlankFlowRates, anionBlankGradients,
		anionBlankSuppressorModes, anionBlankSuppressorVoltages, anionBlankSuppressorCurrents, anionBlankDetectionTemperatures, cationBlankColumnTemperatures, blankGradientA,
		blankGradientB, blankGradientC, blankGradientD, cationBlankFlowRates, cationBlankGradients, cationBlankSuppressorModes, cationBlankSuppressorVoltages,
		cationBlankSuppressorCurrents, cationBlankDetectionTemperatures, anionColumnFlushTemperatures, columnFlushEluentGradients, anionColumnFlushFlowRates, anionColumnFlushGradients,
		anionColumnFlushSuppressorModes, anionColumnFlushSuppressorVoltages, anionColumnFlushSuppressorCurrents, anionColumnFlushDetectionTemperatures, cationColumnFlushTemperatures,
		columnFlushGradientA, columnFlushGradientB, columnFlushGradientC, columnFlushGradientD, cationColumnFlushFlowRates, cationColumnFlushGradients, cationColumnFlushSuppressorModes,
		cationColumnFlushSuppressorVoltages, cationColumnFlushSuppressorCurrents, cationColumnFlushDetectionTemperatures, allAnionGradients, allCationGradients, bufferAmodel,
		bufferBmodel, bufferCmodel, bufferDmodel, uniqueAnionGradientPackets, uniqueCationGradientPackets, allAnionGradientTuples, allCationGradientTuples,
		eluentGeneratorInletSolutionResource, bufferAResource, bufferBResource, bufferCResource, bufferDResource, anionSampleTimes, anionStandardTimes, anionBlankTimes,
		anionColumnPrimeTimes, anionColumnFlushTimes, anionInnerTimes, anionMappingGradientTuple, cationSampleTimes, cationStandardTimes, cationBlankTimes, cationColumnPrimeTimes,
		cationColumnFlushTimes, cationInnerTimes, cationMappingGradientTuple, allTimes, totalRunTime, anionChannelRequiredQ, cationChannelRequiredQ, standardResourceOrderless,
		standardRuleAssociation, linkedStandardResources, blankResourceOrderless, blankRuleAssociation, linkedBlankResources, uniqueSamplePositionsFormatted,
		compatibleVialContainers, vialContainerMaxVolumes, vialSampleMaxVolume, vialDeadVolume, uniqueAnionSamplePackets, uniqueCationSamplePackets, anionSampleContainers, cationSampleContainers,
		uniqueAnionPlateContainers, uniqueCationPlateContainers, uniquePlateContainers, uniqueSamples, uniqueSamplePackets, uniqueSampleContainers,
		anionSampleResources, cationSampleResources, instrumentModel, instrumentModelPacket, protocolPacket, unCollapsedResolvedOptions, sharedFieldPacket,
		finalizedPacket, allResourceBlobs, anionBufferDilutionFactor, cationBufferDilutionFactor, uniqueSampleResources, sampleResources,
		fulfillable, frqTests, testsRule, resultRule, allAnionGradientTuplesInPercent, blankSampleNameOrderless, standardSampleNameOrderless, allPackets, eluent,
		systemPrimeBufferContainerPlacements, systemFlushBufferContainerPlacements, makeReverseAssociation, analysisChannel, anionInjectionVolumes,
		cationInjectionVolumes, anionSamples, cationSamples, injectionVolumes, uniqueSamplePositions, uniqueInjectionVolumes, sampleVolumesRequired,
		columnLookup, guardColumnLookup, columnResource, guardColumnResource, electrochemicalInjectionTable, samplePositions, standardPositions, blankPositions,
		columnPrimePositions, columnFlushPositions, standardLookup, blankLookup, standardMappingAssociation, blankMappingAssociation, columnPrimeMappingAssociation,
		columnFlushMappingAssociation, standardReverseAssociation, blankReverseAssociation, columnPrimeReverseAssociation, columnFlushReverseAssociation,
		sampleReverseAssociation, paddedElectrochemicalInjectionTable, tableGradients, sampleGradient, standardGradient, blankGradient, columnPrimeGradient,
		columnFlushGradient, resolvedGradients, gradientMethodInPlace, gradientObjectsToMake, standardTuples, assignedStandardTuples, groupedStandardsTuples,
		groupedStandardPositionVolumes, groupedStandardShared, groupedStandard, flatStandardResources, linkedElectrochemicalStandardResources, blankTuples,
		assignedBlankTuples, groupedBlanksTuples, groupedBlanksPositionVolumes, groupedBlankShared, groupedBlank, flatBlankResources, linkedElectrochemicalBlankResources,
		linkedSampleResources, electrochemicalInjectionTableWithLinks, samplePositionsCorresponded, standardPositionsCorresponded, blankPositionsCorresponded,
		columnPrimePositionsCorresponded, columnFlushPositionsCorresponded, electrochemicalInjectionTableFull, bufferDilutionFactor, columnTempAdded,
		standardColumnTempAdded, blankColumnTempAdded, columnPrimeTempAdded, columnFlushTempAdded, electrochemicalInjectionTableColumnTempFull, sampleTuples, sampleOffsets,
		insertionAssociation, injectionTableInserted, electrochemicalInjectionTableWithReplicates, electrochemicalInjectionTableUploadable,
		electrochemicalChannelRequiredQ, systemPrimeGradientMethod, systemFlushGradientMethod, systemPrimeGradientPacket, systemFlushGradientPacket,
		systemPrimeGradient, systemFlushGradient, systemPrimeBufferAVolume, systemPrimeBufferBVolume, systemPrimeBufferCVolume, systemPrimeBufferDVolume,
		systemPrimeBufferAResource, systemPrimeBufferBResource, systemPrimeBufferCResource, systemPrimeBufferDResource, systemFlushBufferAVolume,
		systemFlushBufferBVolume, systemFlushBufferCVolume, systemFlushBufferDVolume, systemFlushBufferAResource, systemFlushBufferBResource, systemFlushBufferCResource,
		systemFlushBufferDResource, allGradients, cationColumnPrimeGradientA, cationColumnPrimeGradientB, cationColumnPrimeGradientC, cationColumnPrimeGradientD,
		columnPrimeTemperatures, columnPrimeFlowRates, columnPrimeGradients, columnPrimeAbsorbanceWavelength, columnPrimeAbsorbanceSamplingRate,
		columnPrimeElectrochemicalDetectionMode, columnPrimeReferenceElectrodeMode, columnPrimeVoltageProfile,
		columnPrimeElectrochemicalSamplingRate, columnPrimeDetectionTemperatures, cationGradientA,
		cationGradientB, cationGradientC, cationGradientD, columnTemperatures, flowRates, gradients, absorbanceWavelength, absorbanceSamplingRate,
		electrochemicalDetectionMode, referenceElectrodeMode, voltageProfile, electrochemicalSamplingRate,
		detectionTemperatures, cationStandardGradientA, cationStandardGradientB, cationStandardGradientC, cationStandardGradientD,
		standardFlowRates, standardGradients, standardAbsorbanceWavelength, standardAbsorbanceSamplingRate, standardElectrochemicalDetectionMode,
		standardReferenceElectrodeMode, standardVoltageProfile,
		standardElectrochemicalSamplingRate, standardDetectionTemperatures, standardColumnTemperatures, cationBlankGradientA, cationBlankGradientB,
		cationBlankGradientC, cationBlankGradientD, blankColumnTemperatures, blankFlowRates, blankGradients, blankAbsorbanceWavelength,
		blankAbsorbanceSamplingRate, blankElectrochemicalDetectionMode, blankReferenceElectrodeMode,
		blankVoltageProfile, blankElectrochemicalSamplingRate, blankDetectionTemperatures, cationColumnFlushGradientA,
		cationColumnFlushGradientB, cationColumnFlushGradientC, cationColumnFlushGradientD, columnFlushTemperatures, columnFlushFlowRates,
		columnFlushGradients, columnFlushAbsorbanceWavelength, columnFlushAbsorbanceSamplingRate, columnFlushElectrochemicalDetectionMode,
		columnFlushReferenceElectrodeMode, columnFlushVoltageProfile,
		columnFlushElectrochemicalSamplingRate, columnFlushDetectionTemperatures, referenceElectrode, workingElectrodeLookup,
		workingElectrodeResource, pHCalibrationQ, neutralpHCalibrationBufferResource, secondarypHCalibrationBufferResource,
		uniqueGradientPackets, allGradientTuples, sampleTimes, standardTimes, blankTimes, columnPrimeTimes, columnFlushTimes, innerTimes,
		mappingGradientTuple, paddedInjectionTableWithWaveform, tableWaveforms, sampleWaveform, standardWaveform, blankWaveform,
		columnPrimeWaveform, columnFlushWaveform, resolvedWaveforms, waveformMethodInPlace, waveformObjectsToMake, tableWaveformObjects,
		uniqueWaveformPackets, waveforms, standardWaveforms, blankWaveforms, columnPrimeWaveforms, columnFlushWaveforms,
		waveformObjects, standardWaveformObjects, blankWaveformObjects, columnPrimeWaveformObjects, columnFlushWaveformObjects,
		injectionVolumeCompiled
	},

	(* expand the resolved options if they weren't expanded already *)
	{expandedInputs, expandedResolvedOptions} = ExpandIndexMatchedInputs[ExperimentIonChromatography, {mySamples}, myResolvedOptions];

	(* Get the resolved collapsed index matching options that don't include hidden options *)
	resolvedOptionsNoHidden = CollapseIndexMatchedOptions[
		ExperimentIonChromatography,
		RemoveHiddenOptions[ExperimentIonChromatography, myResolvedOptions],
		Ignore -> myUnresolvedOptions,
		Messages -> False
	];

	(* Determine the requested return value from the function *)
	outputSpecification = OptionDefault[OptionValue[Output]];
	output = ToList[outputSpecification];

	(* Determine if we should keep a running list of tests to return to the user. *)
	gatherTests = MemberQ[output, Tests];
	messages = Not[gatherTests];

	(* Get the inherited cache *)
	inheritedCache = Lookup[ToList[ops], Cache];

	(* Pull out the number of replicates; make sure all Nulls become 1 *)
	numReplicates = Lookup[myResolvedOptions, NumberOfReplicates] /. {Null -> 1};

	(* Expand the options based on the number of replicates*)
	{samplesWithReplicates, optionsWithReplicates} = expandNumberOfReplicates[ExperimentIonChromatography, (mySamples /. x_Link :> Download[x, Object]), myResolvedOptions];


	(* --- Input Sample Resource --- *)
	(* Delete any duplicate input samples to create a single resource per unique sample *)
	uniqueSamples = DeleteDuplicates@Download[mySamples, Object];
	analysisChannel = Lookup[myResolvedOptions, AnalysisChannel];
	uniqueAnionSamples = DeleteDuplicates@PickList[mySamples, analysisChannel, AnionChannel];
	uniqueCationSamples = DeleteDuplicates@PickList[mySamples, analysisChannel, CationChannel];

	(* From resolved anion injection volumes and cation injection volumes, compile a list of injection volumes *)
	(* Index-matched to the input samples *)
	(* First, set up the variable needed to compile injection volumes *)
	anionSamples = PickList[Download[mySamples, Object], analysisChannel, AnionChannel];
	anionInjectionVolumes = Lookup[myResolvedOptions, AnionInjectionVolume];
	cationSamples = PickList[Download[mySamples, Object], analysisChannel, CationChannel];
	cationInjectionVolumes = Lookup[myResolvedOptions, CationInjectionVolume];
	injectionVolumes = Lookup[myResolvedOptions, InjectionVolume];
	injectionVolumeCompiled = MapThread[
		Switch[#1,
			AnionChannel,
			Sequence @@ anionInjectionVolumes[[Flatten[Position[ToList@Download[anionSamples, Object], #2]]]],
			CationChannel,
			Sequence @@ cationInjectionVolumes[[Flatten[Position[ToList@Download[cationSamples, Object], #2]]]],
			ElectrochemicalChannel,
			Sequence @@ injectionVolumes[[Flatten[Position[ToList@Download[mySamples, Object], #2]]]]
		]&,
		{analysisChannel, Download[mySamples, Object]}
	];

	(* Then, calculate the volume needed for each samplesIn *)
	(* If some SamplesIn are the same, we only make 1 resource *)
	(* so when calculating volumes, we need to cover multiple injections potentially *)
	uniqueSamplePositions = Position[mySamples, #]& /@ uniqueSamples;
	uniqueSamplePositionsFormatted = Partition[#[[All, 1]], 1]& /@ uniqueSamplePositions;
	uniqueInjectionVolumes = Total[Extract[injectionVolumeCompiled, #]]& /@ uniqueSamplePositionsFormatted;
	(*The uniqueInjectionVolume is multiplied by 6 as for a Push Full 25 microliter injection, the loop is flushed 5 times with the sample before it is added.*)
	sampleVolumesRequired = 150 Microliter + uniqueInjectionVolumes * 6;

	(* Extract packets for sample objects *)
	uniqueSamplePackets = fetchPacketFromCache[#, inheritedCache]& /@ Download[uniqueSamples, Object];
	uniqueAnionSamplePackets = fetchPacketFromCache[#, inheritedCache]& /@ Download[uniqueAnionSamples, Object];
	uniqueCationSamplePackets = fetchPacketFromCache[#, inheritedCache]& /@ Download[uniqueCationSamples, Object];

	(*get the unique sample containers*)
	uniqueSampleContainers = Download[Lookup[uniqueSamplePackets, Container], Object];
	anionSampleContainers = If[MatchQ[uniqueAnionSamplePackets, {} | Null | {Null}],
		{},
		Download[Lookup[uniqueAnionSamplePackets, Container], Object]
	];
	cationSampleContainers = If[MatchQ[uniqueCationSamplePackets, {} | Null | {Null}],
		{},
		Download[Lookup[uniqueCationSamplePackets, Container], Object]
	];

	(*get the number of unique plate containers*)
	uniqueAnionPlateContainers = DeleteDuplicates[Cases[anionSampleContainers, ObjectP[Object[Container, Plate]]]];
	uniqueCationPlateContainers = DeleteDuplicates[Cases[cationSampleContainers, OjbectP[Object[Container, Plate]]]];
	uniquePlateContainers = Which[
		!MatchQ[Lookup[myResolvedOptions, ElectrochemicalInjectionTable], {} | Null | {Null}],
		DeleteDuplicates[Cases[uniqueSampleContainers, ObjectP[Object[Container, Plate]]]],

		!MatchQ[Lookup[myResolvedOptions, AnionInjectionTable], {} | Null | {Null}] || MatchQ[Lookup[myResolvedOptions, CationInjectionTable], {} | Null | {Null}],
		DeleteDuplicates@Join[ToList@uniqueAnionPlateContainers, ToList@uniqueCationPlateContainers],

		True,
		0
	];

	(* Create Resource for SamplesIn *)
	uniqueSampleResources = MapThread[
		Resource[
			Sample -> #1,
			Name -> CreateUUID[],
			Amount -> #2
		]&,
		{uniqueSamples, sampleVolumesRequired}
	];

	(* Expand sample resources to index match mySamples *)
	sampleResources = Map[
		uniqueSampleResources[[First[FirstPosition[uniqueSamples, #]]]]&,
		Download[mySamples, Object]
	];
	anionSampleResources = Module[{position, analysisChannel},
		position = Sequence @@@ Position[Download[mySamples, Object], (First@#)[Sample]]& /@ sampleResources;
		analysisChannel = (Lookup[myResolvedOptions, AnalysisChannel])[[#]]& /@ position;
		If[MemberQ[ToList[analysisChannel[[#]]], AnionChannel],
			sampleResources[[#]],
			Nothing
		]& /@ Range[Length[analysisChannel]]
	];
	cationSampleResources = Module[{position, analysisChannel},
		position = Sequence @@@ Position[Download[mySamples, Object], (First@#)[Sample]]& /@ sampleResources;
		analysisChannel = (Lookup[myResolvedOptions, AnalysisChannel])[[#]]& /@ position;
		If[MemberQ[ToList[analysisChannel[[#]]], CationChannel],
			sampleResources[[#]],
			Nothing
		]& /@ Range[Length[analysisChannel]]
	] /. {} -> Nothing;

	(* --- Column Resource --- *)
	(* Look up whether there are anion and cation column/guard columns *)
	anionColumnLookup = Lookup[myResolvedOptions, AnionColumn];
	anionGuardColumnLookup = Lookup[myResolvedOptions, AnionGuardColumn];
	cationColumnLookup = Lookup[myResolvedOptions, CationColumn];
	cationGuardColumnLookup = Lookup[myResolvedOptions, CationGuardColumn];
	columnLookup = Lookup[myResolvedOptions, Column];
	guardColumnLookup = Lookup[myResolvedOptions, GuardColumn];

	(* Make the column resources *)
	{anionColumnResource, anionGuardColumnResource, cationColumnResource, cationGuardColumnResource, columnResource, guardColumnResource} = Map[
		If[MatchQ[#, Except[Null | {} | {Null}]],
			Resource[Sample -> #, Name -> CreateUUID[]],
			Null]&,
		{anionColumnLookup, anionGuardColumnLookup, cationColumnLookup, cationGuardColumnLookup, columnLookup, guardColumnLookup}
	];

	(* --- Working Electrode Resource --- *)

	(* Look up whether working electrode is specified  *)
	workingElectrodeLookup = Lookup[myResolvedOptions, WorkingElectrode];

	(* Make the working electrode resource *)
	workingElectrodeResource = If[MatchQ[workingElectrodeLookup, Except[Null | {} | {Null}]],
		Resource[
			Sample -> workingElectrodeLookup,
			Name -> CreateUUID[]
		],
		Null
	];

	(* --- Reference Electrode Calibration Resources --- *)
	(* Look up whether calibration is required *)
	pHCalibrationQ = Lookup[myResolvedOptions, pHCalibration];

	(* If we are calibrating, then make the resources, otherwise, just set to Null *)
	{neutralpHCalibrationBufferResource, secondarypHCalibrationBufferResource} = If[
		TrueQ[pHCalibrationQ],
		Map[
			Resource[
				Sample -> #,
				Amount -> 50 Milli Liter,
				(* 50 mL conical tube *)
				Container -> Model[Container, Vessel, "id:bq9LA0dBGGR6"],
				RentContainer -> True
			]&,
			{Lookup[myResolvedOptions, NeutralpHCalibrationBuffer], Lookup[myResolvedOptions, SecondarypHCalibrationBuffer]}
		],
		{Null, Null}
	];

	(* Getting fillable resources from resolved InjectionTable option *)

	(* Get the resolved InjectionTable which has pretty much everything we need for a particular run of IonChromatography experiment *)
	anionInjectionTable = Lookup[myResolvedOptions, AnionInjectionTable];
	cationInjectionTable = Lookup[myResolvedOptions, CationInjectionTable];
	electrochemicalInjectionTable = Lookup[myResolvedOptions, ElectrochemicalInjectionTable];

	(* Get all of the positions so that it's easy to update the injection table*)
	{anionSamplePositions, anionStandardPositions, anionBlankPositions} = Map[
		Sequence @@@ Position[anionInjectionTable, {#, ___}]&
		, {Sample, Standard, Blank}
	];

	{cationSamplePositions, cationStandardPositions, cationBlankPositions} = Map[
		Sequence @@@ Position[cationInjectionTable, {#, ___}]&
		, {Sample, Standard, Blank}
	];

	{samplePositions, standardPositions, blankPositions, columnPrimePositions, columnFlushPositions} = Map[
		Sequence @@@ Position[electrochemicalInjectionTable, {#, ___}]&
		, {Sample, Standard, Blank, ColumnPrime, ColumnFlush}
	];

	{anionColumnPrimePositions, anionColumnFlushPositions} = Map[
		Sequence @@@ Position[anionInjectionTable, {#, ___}]&
		, {ColumnPrime, ColumnFlush}
	];

	{cationColumnPrimePositions, cationColumnFlushPositions} = Map[
		Sequence @@@ Position[cationInjectionTable, {#, ___}]&
		, {ColumnPrime, ColumnFlush}
	];

	(* Look up the standards and the blanks*)
	{anionStandardLookup, cationStandardLookup, anionBlankLookup, cationBlankLookup} = ToList /@ Lookup[myResolvedOptions, {AnionStandard, CationStandard, AnionBlank, CationBlank}];
	{standardLookup, blankLookup} = ToList /@ Lookup[myResolvedOptions, {Standard, Blank}];

	(* First do the standards, anion and cation *)
	anionStandardMappingAssociation = If[MatchQ[anionStandardLookup, Null | {Null} | {}] || MatchQ[anionStandardPositions, {}],
		(*first check whether there is anything here*)
		Null,
		(*otherwise we have to partition the positions by the length of our standards and map through*)
		Association@MapIndexed[Function[{positionSet, index}, First[index] -> positionSet], Transpose@Partition[anionStandardPositions, Length[anionStandardLookup]]]
	];

	cationStandardMappingAssociation = If[MatchQ[cationStandardLookup, Null | {Null} | {}] || MatchQ[cationStandardPositions, {}],
		(*first check whether there is anything here*)
		Null,
		(*otherwise we have to partition the positions by the length of our standards and map through*)
		Association@MapIndexed[Function[{positionSet, index}, First[index] -> positionSet], Transpose@Partition[cationStandardPositions, Length[cationStandardLookup]]]
	];

	standardMappingAssociation = If[MatchQ[standardLookup, Null | {Null} | {}] || MatchQ[standardPositions, {}],
		(*first check whether there is anything here*)
		Null,
		If[MatchQ[electrochemicalInjectionTable, {} | {Null} | Null],
			(* If electrochemical injection table is empty, then we set to association to Null *)
			Null,
			(*otherwise we have to partition the positions by the length of our standards and map through*)
			Association@MapIndexed[Function[{positionSet, index}, First[index] -> positionSet], Transpose@Partition[standardPositions, Length[standardLookup]]]
		]
	];

	(* Do the blanks in the same way *)
	anionBlankMappingAssociation = If[MatchQ[anionBlankLookup, Null | {Null} | {}] || MatchQ[anionBlankPositions, {}],
		(*first check whether there is anything here*)
		Null,
		(*otherwise we have to partition the positions by the length of our blank and map through*)
		Association@MapIndexed[Function[{positionSet, index}, First[index] -> positionSet], Transpose@Partition[anionBlankPositions, Length[anionBlankLookup]]]
	];

	(* Do the blanks in the same way *)
	cationBlankMappingAssociation = If[MatchQ[cationBlankLookup, Null | {Null} | {}] || MatchQ[cationBlankPositions, {}],
		(*first check whether there is anything here*)
		Null,
		(*otherwise we have to partition the positions by the length of our blank and map through*)
		Association@MapIndexed[Function[{positionSet, index}, First[index] -> positionSet], Transpose@Partition[cationBlankPositions, Length[cationBlankLookup]]]
	];

	blankMappingAssociation = If[MatchQ[blankLookup, Null | {Null} | {}] || MatchQ[blankPositions, {}],
		(*first check whether there is anything here*)
		Null,
		If[MatchQ[electrochemicalInjectionTable, {} | {Null} | Null],
			(* If electrochemical injection table is empty, then we set to association to Null *)
			Null,
			(*otherwise we have to partition the positions by the length of our standards and map through*)
			Association@MapIndexed[Function[{positionSet, index}, First[index] -> positionSet], Transpose@Partition[blankPositions, Length[blankLookup]]]
		]
	];

	(* For the column prime and flush, it's a bit easier because we can set 1-> injectionTable position *)
	anionColumnPrimeMappingAssociation = If[MatchQ[anionColumnLookup, Except[Null | {} | {Null}]],
		Association[1 -> anionColumnPrimePositions]
	];

	cationColumnPrimeMappingAssociation = If[MatchQ[cationColumnLookup, Except[Null | {} | {Null}]],
		Association[1 -> cationColumnPrimePositions]
	];

	columnPrimeMappingAssociation = If[MatchQ[columnLookup, Except[Null | {} | {Null}]],
		Association[1 -> columnPrimePositions]
	];

	anionColumnFlushMappingAssociation = If[MatchQ[anionColumnLookup, Except[Null | {} | {Null}]],
		Association[1 -> anionColumnFlushPositions]
	];

	cationColumnFlushMappingAssociation = If[MatchQ[cationColumnLookup, Except[Null | {} | {Null}]],
		Association[1 -> cationColumnFlushPositions]
	];

	columnFlushMappingAssociation = If[MatchQ[columnLookup, Except[Null | {} | {Null}]],
		Association[1 -> columnFlushPositions]
	];

	(*a helper function used to make the reverse dictionary so that we can go from the injection table positon to the other variables*)
	makeReverseAssociation[inputAssociation : Null] := Null;
	makeReverseAssociation[inputAssociation_Association] := Association[
		SortBy[Flatten@Map[
			Function[{rule},
				Map[# -> First[rule]&, Last[rule]]
			], Normal@inputAssociation]
			, First]
	];

	(*make the reverse associations*)
	{
		anionStandardReverseAssociation,
		cationStandardReverseAssociation,
		standardReverseAssociation,
		anionBlankReverseAssociation,
		cationBlankReverseAssociation,
		blankReverseAssociation,
		anionColumnPrimeReverseAssociation,
		cationColumnPrimeReverseAssociation,
		columnPrimeReverseAssociation,
		anionColumnFlushReverseAssociation,
		cationColumnFlushReverseAssociation,
		columnFlushReverseAssociation
	} = Map[makeReverseAssociation,
		{
			anionStandardMappingAssociation,
			cationStandardMappingAssociation,
			standardMappingAssociation,
			anionBlankMappingAssociation,
			cationBlankMappingAssociation,
			blankMappingAssociation,
			anionColumnPrimeMappingAssociation,
			cationColumnPrimeMappingAssociation,
			columnPrimeMappingAssociation,
			anionColumnFlushMappingAssociation,
			cationColumnFlushMappingAssociation,
			columnFlushMappingAssociation
		}
	];

	(* Also make reverse association for the samples *)
	anionSampleReverseAssociation = Association@MapIndexed[
		Function[{position, index},
			position -> First[index]
		], anionSamplePositions
	];

	cationSampleReverseAssociation = Association@MapIndexed[
		Function[{position, index},
			position -> First[index]
		], cationSamplePositions
	];

	sampleReverseAssociation = Association@MapIndexed[
		Function[{position, index},
			position -> First[index]
		], samplePositions
	];

	(* First we need to pad the injection table with Null to Sample and InjectionVolume fields *)
	paddedAnionInjectionTable = If[MatchQ[#, {InjectionTableCleaningTypeP, ___}],
		Join[ToList@#[[1]], {Null}, ToList@#[[2]], {Null}, ToList@#[[3]]],
		#
	]& /@ anionInjectionTable;

	paddedCationInjectionTable = If[MatchQ[#, {InjectionTableCleaningTypeP, ___}],
		Join[ToList@#[[1]], {Null}, ToList@#[[2]], {Null}, ToList@#[[3]]],
		#
	]& /@ cationInjectionTable;

	paddedElectrochemicalInjectionTable = If[MatchQ[#, {InjectionTableCleaningTypeP, ___}],
		Join[ToList@#[[1]], {Null, Null}, ToList@#[[2]]],
		(* For electrochemical injection table, we are dropping waveform and voltage from the injection table *)
		(* because {Time, Object[Method,Waveform]} is not supported in the field space unless it's named-index *)
		#[[1 ;; -3]]
	]& /@ electrochemicalInjectionTable;

	(*we need to figure out which gradients to make*)
	(*dereference any named objects*)
	anionTableGradients = If[MatchQ[paddedAnionInjectionTable, {} | Null | {Null}],
		{},
		paddedAnionInjectionTable[[All, 5]] /. {x : ObjectP[Object[Method]] :> Download[x, Object]}
	];
	cationTableGradients = If[MatchQ[paddedCationInjectionTable, {} | Null | {Null}],
		{},
		paddedCationInjectionTable[[All, 5]] /. {x : ObjectP[Object[Method]] :> Download[x, Object]}
	];
	tableGradients = If[MatchQ[paddedElectrochemicalInjectionTable, {} | Null | {Null}],
		{},
		paddedElectrochemicalInjectionTable[[All, 4]] /. {x : ObjectP[Object[Method]] :> Download[x, Object]}
	];

	(*get all of the other gradients and see how many of them are objects*)
	{
		anionSampleGradient,
		anionStandardGradient,
		anionBlankGradient,
		anionColumnPrimeGradient,
		anionColumnFlushGradient
	} = Map[
		Function[{gradients},
			Map[
				Function[{gradient},
					If[MatchQ[gradient, ObjectP[Object[Method, IonChromatographyGradient]]],
						Lookup[fetchPacketFromCache[gradient, inheritedCache], AnionGradient],
						gradient
					]
				],
				gradients
			]
		],
		Lookup[myResolvedOptions,
			{
				AnionGradient,
				AnionStandardGradient,
				AnionBlankGradient,
				AnionColumnPrimeGradient,
				AnionColumnFlushGradient
			}
		]
	];

	{
		cationSampleGradient, cationStandardGradient, cationBlankGradient,
		cationColumnPrimeGradient, cationColumnFlushGradient
	} = Map[
		If[MatchQ[#, ObjectP[Object[Method, IonChromatographyGradient]]],
			Lookup[fetchPacketFromCache[#, inheritedCache], CationGradient],
			#
		]&,
		Lookup[myResolvedOptions,
			{
				CationGradient,
				CationStandardGradient,
				CationBlankGradient,
				CationColumnPrimeGradient,
				CationColumnFlushGradient
			}
		]
	];

	{
		sampleGradient,
		standardGradient,
		blankGradient,
		columnPrimeGradient,
		columnFlushGradient
	} = Map[
		If[MatchQ[#, ObjectP[Object[Method, Gradient]]],
			Lookup[fetchPacketFromCache[#, inheritedCache], Gradient],
			#
		]&,
		Lookup[myResolvedOptions,
			{
				Gradient,
				StandardGradient,
				BlankGradient,
				ColumnPrimeGradient,
				ColumnFlushGradient
			}
		]
	];


	(*all resolved gradient*)
	resolvedAnionGradients = Join[Cases[{anionSampleGradient, anionStandardGradient, anionBlankGradient, anionColumnPrimeGradient, anionColumnFlushGradient}, Except[Null | {Null} | {}]]];
	resolvedCationGradients = Join[Cases[{cationSampleGradient, cationStandardGradient, cationBlankGradient, cationColumnPrimeGradient, cationColumnFlushGradient}, Except[Null | {Null} | {}]]];
	resolvedGradients = Join[Cases[{sampleGradient, standardGradient, blankGradient, columnPrimeGradient, columnFlushGradient}, Except[Null | {Null} | {}]]];

	(*find all of the gradients where there is already a method*)
	anionGradientMethodInPlace = Flatten@Cases[resolvedAnionGradients, ListableP[ObjectP[Object[Method, IonChromatographyGradient]]]];
	cationGradientMethodInPlace = Flatten@Cases[resolvedCationGradients, ListableP[ObjectP[Object[Method, IonChromatographyGradient]]]];
	gradientMethodInPlace = Flatten@Cases[resolvedGradients, ListableP[ObjectP[Object[Method, Gradient]]]];

	(*take the complement of the table gradients and the ones already in place*)
	(*we'll need to create packets for all of these gradient objects*)
	anionGradientObjectsToMake = DeleteCases[anionTableGradients, Alternatives @@ Download[anionGradientMethodInPlace, Object]];
	cationGradientObjectsToMake = DeleteCases[cationTableGradients, Alternatives @@ Download[cationGradientMethodInPlace, Object]];
	gradientObjectsToMake = DeleteCases[tableGradients, Alternatives @@ Download[gradientMethodInPlace, Object]];

	(* ---- Creating New Waveform Objects ---- *)
	(*we need to figure out which waveforms to make*)
	(* First, we need to pad the injection table with waveforms *)
	paddedInjectionTableWithWaveform = If[MatchQ[#, {InjectionTableCleaningTypeP, ___}],
		Insert[Insert[#, Null, 2], Null, 3],
		(* For electrochemical injection table, we are dropping waveform and voltage from the injection table *)
		(* because {Time, Object[Method,Waveform]} is not supported in the field space unless it's named-index *)
		#
	]& /@ electrochemicalInjectionTable;

	(* Download all the waveforms specified in the injection table *)
	tableWaveforms = If[MatchQ[paddedInjectionTableWithWaveform, {} | Null | {Null}],
		{},
		paddedInjectionTableWithWaveform[[All, 5]] /. {x : ObjectP[Object[Method, Waveform]] :> Download[x, Object]}
	];

	(* It's possible that waveforms in the injection tables will be in the form of {Time, Waveform object} *)
	(* So we need to get rid of time and just pull out the waveform objects *)
	tableWaveformObjects = DeleteDuplicates[Cases[Flatten[tableWaveforms], ObjectP[Object[Method, Waveform]]]];

	(*get all of the other gradients and see how many of them are objects*)
	{
		sampleWaveform, standardWaveform, blankWaveform, columnPrimeWaveform, columnFlushWaveform,
		electrochemicalDetectionMode, standardElectrochemicalDetectionMode, blankElectrochemicalDetectionMode, columnPrimeElectrochemicalDetectionMode, columnFlushElectrochemicalDetectionMode,
		referenceElectrodeMode, standardReferenceElectrodeMode, blankReferenceElectrodeMode, columnPrimeReferenceElectrodeMode, columnFlushReferenceElectrodeMode
	} = Lookup[myResolvedOptions,
		{
			WaveformProfile, StandardWaveformProfile, BlankWaveformProfile, ColumnPrimeWaveformProfile, ColumnFlushWaveformProfile,
			ElectrochemicalDetectionMode, StandardElectrochemicalDetectionMode, BlankElectrochemicalDetectionMode, ColumnPrimeElectrochemicalDetectionMode, ColumnFlushElectrochemicalDetectionMode,
			ReferenceElectrodeMode, StandardReferenceElectrodeMode, BlankReferenceElectrodeMode, ColumnPrimeReferenceElectrodeMode, ColumnFlushReferenceElectrodeMode
		}
	];

	(*all resolved waveforms*)
	resolvedWaveforms = Join[Cases[{sampleWaveform, standardWaveform, blankWaveform, columnPrimeWaveform, columnFlushWaveform}, Except[Null | {Null} | {}]]];

	(*find all of the waveforms where there is already a method*)
	waveformMethodInPlace = Download[DeleteDuplicates[Cases[Flatten[resolvedWaveforms], ObjectP[Object[Method, Waveform]]]], Object];

	(*take the complement of the table waveforms and the ones already in place*)
	(*we'll need to create packets for all of these waveform objects*)
	waveformObjectsToMake = DeleteCases[tableWaveformObjects, Alternatives @@ waveformMethodInPlace];

	(*will map through and make a gradient for each based on the object ID*)
	uniqueWaveformPackets = If[MatchQ[electrochemicalInjectionTable, {} | Null | {Null}],

		{},

		Map[Function[{waveformObjectID},
			Module[{fullWaveformPosition, injectionTablePosition, resolvedWaveformPosition, currentType, waveformTuple,
				electrochemicalDetectionModes, referenceElectrodeModes, waveformDuration, waveformTupleFormatted},

				(*find the injection Table position*)
				(* In the case where waveform is specified like {Time,Waveform}, then position is a bit more complicated *)
				(* The position will show up like {_,_,_}, the first element is the injection table position *)
				(* The other two elements represent where the waveform appears in the {Time, Waveform} tuples *)
				fullWaveformPosition = FirstPosition[tableWaveforms, waveformObjectID];
				injectionTablePosition = First[fullWaveformPosition];
				resolvedWaveformPosition = Sequence @@ Rest[fullWaveformPosition];

				(*figure out the type, based on which, look up the waveform tuple*)
				currentType = First[paddedInjectionTableWithWaveform[[injectionTablePosition]]];

				(*get the waveform based on the type and the position*)
				waveformTuple = Switch[currentType,
					Sample,
					ToList[sampleWaveform][[injectionTablePosition /. sampleReverseAssociation]][[resolvedWaveformPosition]],

					Standard,
					ToList[standardWaveform][[injectionTablePosition /. standardReverseAssociation]][[resolvedWaveformPosition]],

					Blank,
					ToList[blankWaveform][[injectionTablePosition /. blankReverseAssociation]][[resolvedWaveformPosition]],

					ColumnPrime,
					{columnPrimeWaveform}[[injectionTablePosition /. columnPrimeReverseAssociation]][[resolvedWaveformPosition]],

					ColumnFlush,
					{columnFlushWaveform}[[injectionTablePosition /. columnFlushReverseAssociation]][[resolvedWaveformPosition]]
				];

				(* Once we have the waveform tuples, we have to reformatted into Association for upload call later *)
				waveformTupleFormatted = MapThread[
					Association[
						Time -> #1,
						Voltage -> #2,
						Interpolation -> #3,
						Integration -> #4
					]&,
					Transpose[waveformTuple]
				];

				(*get the electrochemical detection mode based on the type and the position*)
				electrochemicalDetectionModes = Switch[currentType,
					Sample,
					ToList[electrochemicalDetectionMode][[injectionTablePosition /. sampleReverseAssociation]],

					Standard,
					ToList[standardElectrochemicalDetectionMode][[injectionTablePosition /. standardReverseAssociation]],

					Blank,
					ToList[blankElectrochemicalDetectionMode][[injectionTablePosition /. blankReverseAssociation]],

					ColumnPrime,
					{columnPrimeElectrochemicalDetectionMode}[[injectionTablePosition /. columnPrimeReverseAssociation]],

					ColumnFlush,
					{columnFlushElectrochemicalDetectionMode}[[injectionTablePosition /. columnFlushReverseAssociation]]
				];

				(*get the reference electrode mode based on the type and the position*)
				referenceElectrodeModes = Switch[currentType,
					Sample,
					ToList[referenceElectrodeMode][[injectionTablePosition /. sampleReverseAssociation]],

					Standard,
					ToList[standardReferenceElectrodeMode][[injectionTablePosition /. standardReverseAssociation]],

					Blank,
					ToList[blankReferenceElectrodeMode][[injectionTablePosition /. blankReverseAssociation]],

					ColumnPrime,
					{columnPrimeReferenceElectrodeMode}[[injectionTablePosition /. columnPrimeReverseAssociation]],

					ColumnFlush,
					{columnFlushReferenceElectrodeMode}[[injectionTablePosition /. columnFlushReverseAssociation]]
				];

				(* From the tuples, pull out the last entry to get the duration of waveform *)
				waveformDuration = waveformTuple[[-1, 1]];

				(*make the gradient packet*)
				<|
					Object -> waveformObjectID,
					Type -> Object[Method, Waveform],
					ElectrochemicalDetectionMode -> electrochemicalDetectionModes,
					ReferenceElectrodeMode -> referenceElectrodeModes,
					WaveformDuration -> waveformDuration,
					Replace[Waveform] -> waveformTupleFormatted
				|>
			]], waveformObjectsToMake
		]
	];

	(* Now we have to fill in the resolved waveforms with the actual waveform method object *)
	{waveforms, standardWaveforms, blankWaveforms, columnPrimeWaveforms, columnFlushWaveforms} = Map[
		If[MatchQ[#, Null | {}],
			{},
			tableWaveforms[[#]]
		]&,
		{samplePositions, standardPositions, blankPositions, columnPrimePositions, columnFlushPositions}
	];

	(* Once all waveform objects are put back in, we then need to re-format waveforms for uploading to the protocol *)
	(* We are splitting waveform into two fields, one field with a single method object, another with {time, waveform} *)
	{waveformObjects, standardWaveformObjects, blankWaveformObjects, columnPrimeWaveformObjects, columnFlushWaveformObjects} = Map[
		Link[Cases[Flatten[#], ObjectP[Object[Method, Waveform]]]]&,
		{waveforms, standardWaveforms, blankWaveforms, columnPrimeWaveforms, columnFlushWaveforms}
	];

	(*all standards and blanks will be in vials, so we use the same value*)
	compatibleVialContainers =  allLCCompatibleVialSearch["Memoization"];

	(* Fetch container vial's max volume *)
	vialContainerMaxVolumes = Lookup[fetchPacketFromCache[#, inheritedCache], MaxVolume]& /@ compatibleVialContainers;

	(* Use the largest max volume for grouping *)
	vialSampleMaxVolume = Max[vialContainerMaxVolumes];
	vialDeadVolume = 50 Microliter;

	(*now we figure out injected resources*)
	(*get the standard samples out*)
	anionStandardTuples = If[MatchQ[anionInjectionTable, {} | Null | {Null}],
		{},
		anionInjectionTable[[anionStandardPositions]]
	];
	cationStandardTuples = If[MatchQ[cationInjectionTable, {} | Null | {Null}],
		{},
		cationInjectionTable[[cationStandardPositions]]
	];
	standardTuples = If[MatchQ[electrochemicalInjectionTable, {} | Null | {Null}],
		{},
		electrochemicalInjectionTable[[standardPositions]]
	];

	(*assign the position to these *)
	assignedAnionStandardTuples = MapThread[#1 -> #2&, {anionStandardPositions, anionStandardTuples}];
	assignedCationStandardTuples = MapThread[#1 -> #2&, {cationStandardPositions, cationStandardTuples}];
	assignedStandardTuples = MapThread[#1 -> #2&, {standardPositions, standardTuples}];

	(*then group by the sample sample type (e.g. <|standard1->{1->{Standard,standard1,10 Microliter,__},2->{Standard,standard1, 5 Microliter,__}}, standard2 ->... |>*)
	groupedAnionStandardsTuples = GroupBy[assignedAnionStandardTuples, Last[#][[2]]&];
	groupedCationStandardsTuples = GroupBy[assignedCationStandardTuples, Last[#][[2]]&];
	groupedStandardsTuples = GroupBy[assignedStandardTuples, Last[#][[2]]&];

	(*then simplify further by selecting out the positoin and the injection volume <|standard1->{{1,10 Microliter},{2,5 Microliter}}*)
	groupedAnionStandardsPositionVolumes = Map[Function[{eachUniqueStandard},
		Transpose[{Keys[eachUniqueStandard], Values[eachUniqueStandard][[All, 4]]}]
	],
		groupedAnionStandardsTuples
	];
	groupedCationStandardsPositionVolumes = Map[Function[{eachUniqueStandard},
		Transpose[{Keys[eachUniqueStandard], Values[eachUniqueStandard][[All, 4]]}]
	],
		groupedCationStandardsTuples
	];
	groupedStandardPositionVolumes = Map[Function[{eachUniqueStandard},
		Transpose[{Keys[eachUniqueStandard], Values[eachUniqueStandard][[All, 3]]}]
	],
		groupedStandardsTuples
	];

	(*we do a further grouping based on the total injection volume for example: <|Model[Sample, StockSolution, Standard,
     "id:N80DNj1rWzaq"] -> {{{3, Quantity[2, "Microliters"]}}, {{7,  Quantity[2, "Microliters"]}}}, ...|>*)
	groupedAnionStandardShared = Map[GroupByTotal[#, (vialSampleMaxVolume - vialDeadVolume)]&, groupedAnionStandardsPositionVolumes];
	groupedCationStandardShared = Map[GroupByTotal[#, (vialSampleMaxVolume - vialDeadVolume)]&, groupedCationStandardsPositionVolumes];
	groupedStandardShared = Map[GroupByTotal[#, (vialSampleMaxVolume - vialDeadVolume)]&, groupedStandardPositionVolumes];

	(*huff huff huff... now we can finally make the resources*)
	(*we'll be left with a list of positions to a resource e.g. {{1,2}->Resource1,{3,4,5}->Resource2}*)
	groupedAnionStandard = Map[Function[{rule},
		Sequence @@ Map[
			(*this is all of the positions*)
			(#[[All, 1]] ->
				Resource[
					Sample -> Download[First[rule], Object],
					(*total the volume for the given group*)
					Amount -> Total[#[[All, 2]]] + vialDeadVolume,
					(*allow all models that can hold the required amount *)
					Container -> PickList[compatibleVialContainers, vialContainerMaxVolumes, GreaterEqualP[(Total[#[[All, 2]]] + vialDeadVolume)]],
					Name -> CreateUUID[]
				])&
			, Last[rule]
		]],
		(*convert to a list*)
		Normal@groupedAnionStandardShared
	];

	groupedCationStandard = Map[Function[{rule},
		Sequence @@ Map[
			(*this is all of the positions*)
			(#[[All, 1]] ->
				Resource[
					Sample -> Download[First[rule], Object],
					(*total the volume for the given group*)
					Amount -> Total[#[[All, 2]]] + vialDeadVolume,
					(*allow all models that can hold the required amount *)
					Container -> PickList[compatibleVialContainers, vialContainerMaxVolumes, GreaterEqualP[(Total[#[[All, 2]]] + vialDeadVolume)]],
					Name -> CreateUUID[]
				])&
			, Last[rule]
		]],
		(*convert to a list*)
		Normal@groupedCationStandardShared
	];

	groupedStandard = Map[Function[{rule},
		Sequence @@ Map[
			(*this is all of the positions*)
			(#[[All, 1]] ->
				Resource[
					Sample -> Download[First[rule], Object],
					(*total the volume for the given group*)
					Amount -> Total[#[[All, 2]]] + vialDeadVolume,
					(*allow all models that can hold the required amount *)
					Container -> PickList[compatibleVialContainers, vialContainerMaxVolumes, GreaterEqualP[(Total[#[[All, 2]]] + vialDeadVolume)]],
					Name -> CreateUUID[]
				])&
			, Last[rule]
		]],
		(*convert to a list*)
		Normal@groupedStandardShared
	];

	(*gasp... now we can flatten this list to our standards, index matched to the samples {1->Resource1, 2->Resource1, ... }*)
	flatAnionStandardResources = SortBy[Map[Function[{rule},
		Sequence @@ Map[# -> Last[rule]&, First[rule]]
	], groupedAnionStandard], First];

	flatCationStandardResources = SortBy[Map[Function[{rule},
		Sequence @@ Map[# -> Last[rule]&, First[rule]]
	], groupedCationStandard], First];

	flatStandardResources = SortBy[Map[Function[{rule},
		Sequence @@ Map[# -> Last[rule]&, First[rule]]
	], groupedStandard], First];

	(*take the values and surround with link*)
	linkedAnionStandardResources = Map[Link, Values[flatAnionStandardResources]];
	linkedCationStandardResources = Map[Link, Values[flatCationStandardResources]];
	linkedElectrochemicalStandardResources = Map[Link, Values[flatStandardResources]];

	(* link each standard sample to their respective resource *)
	(* First join the resources from anion standard and cation standard *)
	(* Then make a assocation consisting of rules like standard sample object->resource *)
	(* Make an ordered list of standard resources *)
	standardResourceOrderless = Join[linkedAnionStandardResources, linkedCationStandardResources];
	standardSampleNameOrderless = #[Sample]& /@ Join[Values[flatAnionStandardResources], Values[flatCationStandardResources]];
	standardRuleAssociation = Association @@ MapThread[#1 -> #2&, {standardSampleNameOrderless, standardResourceOrderless}];
	linkedStandardResources = If[Length[Lookup[myResolvedOptions, Standard]] > 0,
		If[MatchQ[linkedElectrochemicalStandardResources, Except[{} | Null | {Null}]],
			linkedElectrochemicalStandardResources,
			Cases[Lookup[standardRuleAssociation, Download[Lookup[myResolvedOptions, Standard], Object], Null], Except[Null]]
		],
		Null
	];

	(*now do the same with the blanks*)

	(*get the standard samples out*)
	anionBlankTuples = If[MatchQ[anionInjectionTable, {} | Null | {Null}],
		{},
		anionInjectionTable[[anionBlankPositions]]
	];
	cationBlankTuples = If[MatchQ[cationInjectionTable, {} | Null | {Null}],
		{},
		cationInjectionTable[[cationBlankPositions]]
	];
	blankTuples = If[MatchQ[electrochemicalInjectionTable, {} | Null | {Null}],
		{},
		electrochemicalInjectionTable[[blankPositions]]
	];

	(*assign the position to these *)
	assignedAnionBlankTuples = MapThread[#1 -> #2&, {anionBlankPositions, anionBlankTuples}];
	assignedCationBlankTuples = MapThread[#1 -> #2&, {cationBlankPositions, cationBlankTuples}];
	assignedBlankTuples = MapThread[#1 -> #2&, {blankPositions, blankTuples}];

	(*then group by the sample sample type (e.g. <|blank1->{1->{Blank,blank1,10 Microliter,__},2->{Blank,blank1, 5 Microliter,__}}, blank2 ->... |>*)
	groupedAnionBlanksTuples = GroupBy[assignedAnionBlankTuples, Last[#][[2]]&];
	groupedCationBlanksTuples = GroupBy[assignedCationBlankTuples, Last[#][[2]]&];
	groupedBlanksTuples = GroupBy[assignedBlankTuples, Last[#][[2]]&];

	(*then simplify further by selecting out the positoin and the injection volume <|blank1->{{1,10 Microliter},{2,5 Microliter}}*)
	groupedAnionBlanksPositionVolumes = Map[Function[{eachUniqueBlank},
		Transpose[{Keys[eachUniqueBlank], Values[eachUniqueBlank][[All, 4]]}]
	],
		groupedAnionBlanksTuples
	];

	groupedCationBlanksPositionVolumes = Map[Function[{eachUniqueBlank},
		Transpose[{Keys[eachUniqueBlank], Values[eachUniqueBlank][[All, 4]]}]
	],
		groupedCationBlanksTuples
	];

	groupedBlanksPositionVolumes = Map[Function[{eachUniqueBlank},
		Transpose[{Keys[eachUniqueBlank], Values[eachUniqueBlank][[All, 3]]}]
	],
		groupedBlanksTuples
	];

	(*we do a further grouping based on the total injection volume for example: <|Model[Sample, StockSolution,
     "id:N80DNj1rWzaq"] -> {{{3, Quantity[2, "Microliters"]}}, {{7,  Quantity[2, "Microliters"]}}}, ...|>*)
	groupedAnionBlankShared = Map[GroupByTotal[#, (vialSampleMaxVolume - vialDeadVolume)]&, groupedAnionBlanksPositionVolumes];
	groupedCationBlankShared = Map[GroupByTotal[#, (vialSampleMaxVolume - vialDeadVolume)]&, groupedCationBlanksPositionVolumes];
	groupedBlankShared = Map[GroupByTotal[#, (vialSampleMaxVolume - vialDeadVolume)]&, groupedBlanksPositionVolumes];

	(*huff huff huff... now we can finally make the resources*)
	(*we'll be left with a list of positions to a resource e.g. {{1,2}->Resource1,{3,4,5}->Resource2}*)
	groupedAnionBlank = Map[Function[{rule},
		Sequence @@ Map[
			(*this is all of the positions*)
			(#[[All, 1]] ->
				Resource[
					Sample -> First[rule],
					(*total the volume for the given group*)
					Amount -> Total[#[[All, 2]]] + vialDeadVolume,
					(*allow all models that can hold the required amount *)
					Container -> PickList[compatibleVialContainers, vialContainerMaxVolumes, GreaterEqualP[(Total[#[[All, 2]]] + vialDeadVolume)]],
					Name -> CreateUUID[]
				])&
			, Last[rule]
		]],
		(*convert to a list*)
		Normal@groupedAnionBlankShared
	];

	groupedCationBlank = Map[Function[{rule},
		Sequence @@ Map[
			(*this is all of the positions*)
			(#[[All, 1]] ->
				Resource[
					Sample -> First[rule],
					(*total the volume for the given group*)
					Amount -> Total[#[[All, 2]]] + vialDeadVolume,
					(*allow all models that can hold the required amount *)
					Container -> PickList[compatibleVialContainers, vialContainerMaxVolumes, GreaterEqualP[(Total[#[[All, 2]]] + vialDeadVolume)]],
					Name -> CreateUUID[]
				])&
			, Last[rule]
		]],
		(*convert to a list*)
		Normal@groupedCationBlankShared
	];

	groupedBlank = Map[Function[{rule},
		Sequence @@ Map[
			(*this is all of the positions*)
			(#[[All, 1]] ->
				Resource[
					Sample -> First[rule],
					(*total the volume for the given group*)
					Amount -> Total[#[[All, 2]]] + vialDeadVolume,
					(*allow all models that can hold the required amount *)
					Container -> PickList[compatibleVialContainers, vialContainerMaxVolumes, GreaterEqualP[(Total[#[[All, 2]]] + vialDeadVolume)]],
					Name -> CreateUUID[]
				])&
			, Last[rule]
		]],
		(*convert to a list*)
		Normal@groupedBlankShared
	];

	(*gasp... now we can flatten this list to our blanks, index matched to the samples {1->Resource1, 2->Resource1, ... }*)
	flatAnionBlankResources = SortBy[Map[Function[{rule},
		Sequence @@ Map[# -> Last[rule]&, First[rule]]
	], groupedAnionBlank], First];

	flatCationBlankResources = SortBy[Map[Function[{rule},
		Sequence @@ Map[# -> Last[rule]&, First[rule]]
	], groupedCationBlank], First];

	flatBlankResources = SortBy[Map[Function[{rule},
		Sequence @@ Map[# -> Last[rule]&, First[rule]]
	], groupedBlank], First];

	(*take the values and surround with link*)
	linkedAnionBlankResources = Map[Link, Values[flatAnionBlankResources]];
	linkedCationBlankResources = Map[Link, Values[flatCationBlankResources]];
	linkedElectrochemicalBlankResources = Map[Link, Values[flatBlankResources]];

	(* link each standard sample to their respective resource *)
	(* First join the resources from anion standard and cation standard *)
	(* Then make a assocation consisting of rules like standard sample object->resource *)
	(* Make an ordered list of standard resources *)
	blankResourceOrderless = Join[linkedAnionBlankResources, linkedCationBlankResources];
	blankSampleNameOrderless = #[Sample]& /@ Join[Values[flatAnionBlankResources], Values[flatCationBlankResources]];
	blankRuleAssociation = Association @@ MapThread[#1 -> #2&, {blankSampleNameOrderless, blankResourceOrderless}];
	linkedBlankResources = If[Length[Lookup[myResolvedOptions, Blank]] > 0,
		If[MatchQ[linkedElectrochemicalBlankResources, Except[{} | Null | {Null}]],
			linkedElectrochemicalBlankResources,
			Cases[Lookup[blankRuleAssociation, Lookup[myResolvedOptions, Blank], Null], Except[Null]]
		],
		Null
	];

	(*now let's update everything within our injection table*)
	linkedAnionSampleResources = Link /@ anionSampleResources;
	linkedCationSampleResources = Link /@ cationSampleResources;
	linkedSampleResources = Link /@ sampleResources;

	(*initialize our injectionTable with links as well as padding Sample and InjectionVolume fields with Null*)
	anionInjectionTableWithLinks = paddedAnionInjectionTable;
	cationInjectionTableWithLinks = paddedCationInjectionTable;
	electrochemicalInjectionTableWithLinks = paddedElectrochemicalInjectionTable;

	(*update all of the samples*)
	If[MatchQ[anionInjectionTableWithLinks, {} | Null | {Null}],
		Nothing,
		anionInjectionTableWithLinks[[anionSamplePositions, 2]] = linkedAnionSampleResources;
		anionInjectionTableWithLinks[[anionStandardPositions, 2]] = linkedAnionStandardResources;
		anionInjectionTableWithLinks[[anionBlankPositions, 2]] = linkedAnionBlankResources;
		anionInjectionTableWithLinks[[All, 5]] = (Link /@ anionTableGradients);
	];

	If[MatchQ[cationInjectionTableWithLinks, {} | Null | {Null}],
		Nothing,
		cationInjectionTableWithLinks[[cationSamplePositions, 2]] = linkedCationSampleResources;
		cationInjectionTableWithLinks[[cationStandardPositions, 2]] = linkedCationStandardResources;
		cationInjectionTableWithLinks[[cationBlankPositions, 2]] = linkedCationBlankResources;
		cationInjectionTableWithLinks[[All, 5]] = (Link /@ cationTableGradients);

	];

	If[MatchQ[electrochemicalInjectionTableWithLinks, {} | Null | {Null}],
		Nothing,
		electrochemicalInjectionTableWithLinks[[samplePositions, 2]] = linkedSampleResources;
		electrochemicalInjectionTableWithLinks[[standardPositions, 2]] = linkedStandardResources;
		electrochemicalInjectionTableWithLinks[[blankPositions, 2]] = linkedBlankResources;
		electrochemicalInjectionTableWithLinks[[All, 4]] = (Link /@ tableGradients);

	];

	(*now let's add the extra columns to the injection table (dilution factor and column temperature*)

	(*to fill in the parameters we just need the injection table positions corresponded to the pertinent ones*)
	anionSamplePositionsCorresponded = If[Length[anionSamplePositions] > 0, Last /@ SortBy[Normal@anionSampleReverseAssociation, First]];
	cationSamplePositionsCorresponded = If[Length[cationSamplePositions] > 0, Last /@ SortBy[Normal@cationSampleReverseAssociation, First]];
	samplePositionsCorresponded = If[Length[samplePositions] > 0, Last /@ SortBy[Normal@sampleReverseAssociation, First]];

	anionStandardPositionsCorresponded = If[Length[anionStandardPositions] > 0, Last /@ SortBy[Normal@anionStandardReverseAssociation, First]];
	cationStandardPositionsCorresponded = If[Length[cationStandardPositions] > 0, Last /@ SortBy[Normal@cationStandardReverseAssociation, First]];
	standardPositionsCorresponded = If[Length[standardPositions] > 0, Last /@ SortBy[Normal@standardReverseAssociation, First]];

	anionBlankPositionsCorresponded = If[Length[anionBlankPositions] > 0, Last /@ SortBy[Normal@anionBlankReverseAssociation, First]];
	cationBlankPositionsCorresponded = If[Length[cationBlankPositions] > 0, Last /@ SortBy[Normal@cationBlankReverseAssociation, First]];
	blankPositionsCorresponded = If[Length[blankPositions] > 0, Last /@ SortBy[Normal@blankReverseAssociation, First]];

	anionColumnPrimePositionsCorresponded = If[Length[anionColumnPrimePositions] > 0, Last /@ SortBy[Normal@anionColumnPrimeReverseAssociation, First]];
	cationColumnPrimePositionsCorresponded = If[Length[cationColumnPrimePositions] > 0, Last /@ SortBy[Normal@cationColumnPrimeReverseAssociation, First]];
	columnPrimePositionsCorresponded = If[Length[columnPrimePositions] > 0, Last /@ SortBy[Normal@columnPrimeReverseAssociation, First]];

	anionColumnFlushPositionsCorresponded = If[Length[anionColumnFlushPositions] > 0, Last /@ SortBy[Normal@anionColumnFlushReverseAssociation, First]];
	cationColumnFlushPositionsCorresponded = If[Length[cationColumnFlushPositions] > 0, Last /@ SortBy[Normal@cationColumnFlushReverseAssociation, First]];
	columnFlushPositionsCorresponded = If[Length[columnFlushPositions] > 0, Last /@ SortBy[Normal@columnFlushReverseAssociation, First]];

	(*first append Nulls to all of the rows to initialize*)
	anionInjectionTableFull = Map[PadRight[#, 7, Null]&, anionInjectionTableWithLinks];
	cationInjectionTableFull = Map[PadRight[#, 7, Null]&, cationInjectionTableWithLinks];
	electrochemicalInjectionTableFull = Map[PadRight[#, 6, Null]&, electrochemicalInjectionTableWithLinks];

	(*get the dilution factors and inform that first*)
	anionBufferDilutionFactor = PickList[Lookup[myResolvedOptions, BufferDilutionFactor], Lookup[myResolvedOptions, AnalysisChannel], AnionChannel];
	cationBufferDilutionFactor = PickList[Lookup[myResolvedOptions, BufferDilutionFactor], Lookup[myResolvedOptions, AnalysisChannel], CationChannel];
	bufferDilutionFactor = PickList[Lookup[myResolvedOptions, BufferDilutionFactor], Lookup[myResolvedOptions, AnalysisChannel], ElectrochemicalChannel];

	If[MatchQ[anionInjectionTableFull, {} | Null | {Null}],
		Nothing,
		anionInjectionTableFull[[anionSamplePositions, 6]] = anionBufferDilutionFactor
	];
	If[MatchQ[cationInjectionTableFull, {} | Null | {Null}],
		Nothing,
		cationInjectionTableFull[[cationSamplePositions, 6]] = cationBufferDilutionFactor
	];
	If[MatchQ[electrochemicalInjectionTableFull, {} | Null | {Null}],
		Nothing,
		electrochemicalInjectionTableFull[[samplePositions, 6]] = bufferDilutionFactor
	];

	(*then we'll do the column temperature*)
	anionColumnTempAdded = If[Length[anionSamplePositions] > 0,
		ReplacePart[anionInjectionTableFull, MapThread[{#1, 7} -> #2&, {anionSamplePositions, Lookup[myResolvedOptions, AnionColumnTemperature] /. {Ambient -> 25 Celsius}}]],
		anionInjectionTableFull
	];
	anionStandardColumnTempAdded = If[Length[anionStandardPositions] > 0,
		ReplacePart[anionColumnTempAdded, MapThread[{#1, 7} -> #2&, {anionStandardPositions, Lookup[myResolvedOptions, AnionStandardColumnTemperature][[anionStandardPositionsCorresponded]] /. {Ambient -> 25 Celsius}}]],
		anionColumnTempAdded
	];
	anionBlankColumnTempAdded = If[Length[anionBlankPositions] > 0,
		ReplacePart[anionStandardColumnTempAdded, MapThread[{#1, 7} -> #2&, {anionBlankPositions, Lookup[myResolvedOptions, AnionBlankColumnTemperature][[anionBlankPositionsCorresponded]] /. {Ambient -> 25 Celsius}}]],
		anionStandardColumnTempAdded
	];
	anionColumnPrimeTempAdded = If[Length[anionColumnPrimePositions] > 0,
		ReplacePart[anionBlankColumnTempAdded, MapThread[{#1, 7} -> #2&, {anionColumnPrimePositions, ConstantArray[Lookup[myResolvedOptions, AnionColumnPrimeTemperature], Length[anionColumnPrimePositions]] /. {Ambient -> 25 Celsius}}]],
		anionBlankColumnTempAdded
	];
	anionColumnFlushTempAdded = If[Length[anionColumnFlushPositions] > 0,
		ReplacePart[anionColumnPrimeTempAdded, MapThread[{#1, 7} -> #2&, {anionColumnFlushPositions, ConstantArray[Lookup[myResolvedOptions, AnionColumnFlushTemperature], Length[anionColumnFlushPositions]] /. {Ambient -> 25 Celsius}}]],
		anionColumnPrimeTempAdded
	];

	cationColumnTempAdded = If[Length[cationSamplePositions] > 0,
		ReplacePart[cationInjectionTableFull, MapThread[{#1, 7} -> #2&, {cationSamplePositions, Lookup[myResolvedOptions, CationColumnTemperature] /. {Ambient -> 25 Celsius}}]],
		cationInjectionTableFull
	];
	cationStandardColumnTempAdded = If[Length[cationStandardPositions] > 0,
		ReplacePart[cationColumnTempAdded, MapThread[{#1, 7} -> #2&, {cationStandardPositions, Lookup[myResolvedOptions, CationStandardColumnTemperature][[cationStandardPositionsCorresponded]] /. {Ambient -> 25 Celsius}}]],
		cationColumnTempAdded
	];
	cationBlankColumnTempAdded = If[Length[cationBlankPositions] > 0,
		ReplacePart[cationStandardColumnTempAdded, MapThread[{#1, 7} -> #2&, {cationBlankPositions, Lookup[myResolvedOptions, CationBlankColumnTemperature][[cationBlankPositionsCorresponded]] /. {Ambient -> 25 Celsius}}]],
		cationStandardColumnTempAdded
	];
	cationColumnPrimeTempAdded = If[Length[cationColumnPrimePositions] > 0,
		ReplacePart[cationBlankColumnTempAdded, MapThread[{#1, 7} -> #2&, {cationColumnPrimePositions, ConstantArray[Lookup[myResolvedOptions, CationColumnPrimeTemperature], Length[cationColumnPrimePositions]] /. {Ambient -> 25 Celsius}}]],
		cationBlankColumnTempAdded
	];
	cationColumnFlushTempAdded = If[Length[cationColumnFlushPositions] > 0,
		ReplacePart[cationColumnPrimeTempAdded, MapThread[{#1, 7} -> #2&, {cationColumnFlushPositions, ConstantArray[Lookup[myResolvedOptions, CationColumnFlushTemperature], Length[cationColumnFlushPositions]] /. {Ambient -> 25 Celsius}}]],
		cationColumnPrimeTempAdded
	];

	columnTempAdded = If[Length[samplePositions] > 0,
		ReplacePart[electrochemicalInjectionTableFull, MapThread[{#1, 6} -> #2&, {samplePositions, Lookup[myResolvedOptions, ColumnTemperature] /. {Ambient -> 25 Celsius}}]],
		electrochemicalInjectionTableFull
	];
	standardColumnTempAdded = If[Length[standardPositions] > 0,
		ReplacePart[columnTempAdded, MapThread[{#1, 6} -> #2&, {standardPositions, Lookup[myResolvedOptions, StandardColumnTemperature][[standardPositionsCorresponded]] /. {Ambient -> 25 Celsius}}]],
		columnTempAdded
	];
	blankColumnTempAdded = If[Length[blankPositions] > 0,
		ReplacePart[standardColumnTempAdded, MapThread[{#1, 6} -> #2&, {blankPositions, Lookup[myResolvedOptions, BlankColumnTemperature][[blankPositionsCorresponded]] /. {Ambient -> 25 Celsius}}]],
		standardColumnTempAdded
	];
	columnPrimeTempAdded = If[Length[columnPrimePositions] > 0,
		ReplacePart[blankColumnTempAdded, MapThread[{#1, 6} -> #2&, {columnPrimePositions, ConstantArray[Lookup[myResolvedOptions, ColumnPrimeTemperature], Length[columnPrimePositions]] /. {Ambient -> 25 Celsius}}]],
		blankColumnTempAdded
	];
	columnFlushTempAdded = If[Length[columnFlushPositions] > 0,
		ReplacePart[columnPrimeTempAdded, MapThread[{#1, 6} -> #2&, {columnFlushPositions, ConstantArray[Lookup[myResolvedOptions, ColumnFlushTemperature], Length[columnFlushPositions]] /. {Ambient -> 25 Celsius}}]],
		columnPrimeTempAdded
	];

	anionInjectionTableColumnTempFull = anionColumnFlushTempAdded;
	cationInjectionTableColumnTempFull = cationColumnFlushTempAdded;
	electrochemicalInjectionTableColumnTempFull = columnFlushTempAdded;

	(*we'll need to use number of replicates to expand the effective injection table*)

	(*then get all of the sample tuples*)
	anionSampleTuples = If[MatchQ[anionInjectionTableColumnTempFull, {} | Null | {Null}],
		{},
		anionInjectionTableColumnTempFull[[anionSamplePositions]]
	];
	cationSampleTuples = If[MatchQ[cationInjectionTableColumnTempFull, {} | Null | {Null}],
		{},
		cationInjectionTableColumnTempFull[[cationSamplePositions]]
	];
	sampleTuples = If[MatchQ[electrochemicalInjectionTableColumnTempFull, {} | Null | {Null}],
		{},
		electrochemicalInjectionTableColumnTempFull[[samplePositions]]
	];

	(* make offsets for the sample positions for insertion into the injection table *)
	(* the position of each input sample needs to be accounted for such that the replicates for each input sample are inserted sequentially/after that input sample in the injection table - otherwise all of the replicates regardless of what input sample they are associated with are placed at the beginning of the injection table before the input samples  *)
	anionOffsets = Range@Length[anionSamplePositions];
	cationOffsets = Range@Length[cationSamplePositions];
	sampleOffsets = Range@Length[samplePositions];

	(*make our insertion association (e.g. in the format of position to be inserted (P) and list to be inserted <|2 -> {{Sample,sample1,___}...}, *)
	anionInsertionAssociation = MapThread[Function[{position, tuple, offset},
		(position + offset) -> ConstantArray[tuple, numReplicates - 1]
	], {anionSamplePositions, anionSampleTuples, anionOffsets}];
	cationInsertionAssociation = MapThread[Function[{position, tuple, offset},
		(position + offset) -> ConstantArray[tuple, numReplicates - 1]
	], {cationSamplePositions, cationSampleTuples, cationOffsets}];
	insertionAssociation = MapThread[Function[{position, tuple, offset},
		(position + offset) -> ConstantArray[tuple, numReplicates - 1]
	], {samplePositions, sampleTuples, sampleOffsets}];

	(*fold through and insert these tuples into our injection table*)
	anionInjectionTableInserted = If[MatchQ[anionInjectionTable, {} | Null | {Null}],
		{},
		Partition[Flatten[If[numReplicates > 1, Fold[Insert[#1, Last[#2], First[#2]]&, anionInjectionTableColumnTempFull, anionInsertionAssociation], anionInjectionTableColumnTempFull]], 7]
	];
	cationInjectionTableInserted = If[MatchQ[cationInjectionTable, {} | Null | {Null}],
		{},
		Partition[Flatten[If[numReplicates > 1, Fold[Insert[#1, Last[#2], First[#2]]&, cationInjectionTableColumnTempFull, cationInsertionAssociation], cationInjectionTableColumnTempFull]], 7]
	];
	injectionTableInserted = If[MatchQ[electrochemicalInjectionTable, {} | Null | {Null}],
		{},
		Partition[Flatten[If[numReplicates > 1, Fold[Insert[#1, Last[#2], First[#2]]&, electrochemicalInjectionTableColumnTempFull, insertionAssociation], electrochemicalInjectionTableColumnTempFull]], 6]
	];

	(*flatten and reform our injection table*)
	anionInjectionTableWithReplicates = Partition[Flatten[anionInjectionTableInserted], 7];
	cationInjectionTableWithReplicates = Partition[Flatten[cationInjectionTableInserted], 7];
	electrochemicalInjectionTableWithReplicates = Partition[Flatten[injectionTableInserted], 6];

	(*finally make our uploadable injection table*)
	anionInjectionTableUploadable = If[MatchQ[anionInjectionTable, {} | {Null} | Null],
		Null,
		MapThread[Function[{type, sample, analysisChannel, injectionVolume, gradient, dilutionFactor, columnTemperature},
			Association[
				Type -> type,
				Sample -> sample,
				AnalysisChannel -> analysisChannel,
				InjectionVolume -> injectionVolume,
				Gradient -> gradient,
				DilutionFactor -> dilutionFactor,
				ColumnTemperature -> columnTemperature,
				Data -> Null
			]
		], Transpose[anionInjectionTableWithReplicates]
		]
	];
	cationInjectionTableUploadable = If[MatchQ[cationInjectionTable, {} | Null | {Null}],
		Null,
		MapThread[Function[{type, sample, analysisChannel, injectionVolume, gradient, dilutionFactor, columnTemperature},
			Association[
				Type -> type,
				Sample -> sample,
				AnalysisChannel -> analysisChannel,
				InjectionVolume -> injectionVolume,
				Gradient -> gradient,
				DilutionFactor -> dilutionFactor,
				ColumnTemperature -> columnTemperature,
				Data -> Null
			]
		], Transpose[cationInjectionTableWithReplicates]
		]
	];
	electrochemicalInjectionTableUploadable = If[MatchQ[electrochemicalInjectionTable, {} | Null | {Null}],
		Null,
		MapThread[Function[{type, sample, injectionVolume, gradient, dilutionFactor, columnTemperature},
			Association[
				Type -> type,
				Sample -> sample,
				InjectionVolume -> injectionVolume,
				Gradient -> gradient,
				DilutionFactor -> dilutionFactor,
				ColumnTemperature -> columnTemperature,
				Data -> Null
			]
		], Transpose[electrochemicalInjectionTableWithReplicates]
		]
	];

	(*get the instrument model*)
	instrumentModel = If[MatchQ[Lookup[myResolvedOptions, Instrument], ObjectP[Object[Instrument]]],
		Lookup[fetchPacketFromCache[Download[Lookup[myResolvedOptions, Instrument], Object], inheritedCache], Model],
		Download[Lookup[myResolvedOptions, Instrument], Object]
	];

	(*get the instrument model packet*)
	instrumentModelPacket = fetchPacketFromCache[instrumentModel, inheritedCache];

	(*get the type of eluent used *)
	eluent = If[MatchQ[Lookup[instrumentModelPacket, IntegratedEluentGenerator], Null | {} | {Null}],
		Null,
		Lookup[fetchPacketFromCache[First@Lookup[instrumentModelPacket, IntegratedEluentGenerator], inheritedCache], Eluent, Null]
	];

	(*check whether anion or cation channel is used in this protocol *)
	anionChannelRequiredQ = !MatchQ[anionInjectionTable, Null | {Null} | {}];
	cationChannelRequiredQ = !MatchQ[cationInjectionTable, Null | {Null} | {}];
	electrochemicalChannelRequiredQ = !MatchQ[electrochemicalInjectionTable, Null | {Null} | {}];

	(*get the suppressor models *)
	{anionSuppressor, cationSuppressor} = Lookup[instrumentModelPacket, {AnionSuppressor, CationSuppressor}];

	(* get the reference electrode *)
	referenceElectrode = Lookup[instrumentModelPacket, ReferenceElectrode];
	(*
    referenceElectrodeResource=If[NullQ[referenceElectrode],
        Null,
        Resource[
            Sample->Download[referenceElectrode,Object],
            Name->CreateUUID[]
        ]
    ];*)

	(*for the system prime and flush we will defer to the default method*)
	anionSystemPrimeGradientMethod = Object[Method, IonChromatographyGradient, "ICS 6000 System Prime Method - Anion Channel"];
	cationSystemPrimeGradientMethod = Object[Method, IonChromatographyGradient, "ICS 6000 System Prime Method - Cation Channel"];
	anionSystemFlushGradientMethod = Object[Method, IonChromatographyGradient, "ICS 6000 System Flush Method - Anion Channel"];
	cationSystemFlushGradientMethod = Object[Method, IonChromatographyGradient, "ICS 6000 System Flush Method - Cation Channel"];
	systemPrimeGradientMethod = Object[Method, Gradient, "ICS 6000 with ED-UVVis Detectors System Prime Method"];
	systemFlushGradientMethod = Object[Method, Gradient, "ICS 6000 with ED-UVVis Detectors System Flush Method"];

	(*get the packet from the cache*)
	anionSystemPrimeGradientPacket = fetchPacketFromCache[Download[anionSystemPrimeGradientMethod, Object], inheritedCache];
	cationSystemPrimeGradientPacket = fetchPacketFromCache[Download[cationSystemPrimeGradientMethod, Object], inheritedCache];
	anionSystemFlushGradientPacket = fetchPacketFromCache[Download[anionSystemFlushGradientMethod, Object], inheritedCache];
	cationSystemFlushGradientPacket = fetchPacketFromCache[Download[cationSystemFlushGradientMethod, Object], inheritedCache];
	systemPrimeGradientPacket = fetchPacketFromCache[Download[systemPrimeGradientMethod, Object], inheritedCache];
	systemFlushGradientPacket = fetchPacketFromCache[Download[systemFlushGradientMethod, Object], inheritedCache];

	(*get the gradient tuple*)
	anionSystemPrimeGradient = Lookup[anionSystemPrimeGradientPacket, AnionGradient];
	cationSystemPrimeGradient = Lookup[cationSystemPrimeGradientPacket, CationGradient];
	anionSystemFlushGradient = Lookup[anionSystemFlushGradientPacket, AnionGradient];
	cationSystemFlushGradient = Lookup[cationSystemFlushGradientPacket, CationGradient];
	systemPrimeGradient = Lookup[systemPrimeGradientPacket, Gradient];
	systemFlushGradient = Lookup[systemFlushGradientPacket, Gradient];

	(*define the suitable containers for the priming*)
	systemPrimeBufferContainer = Model[Container, Vessel, "id:3em6Zv9Njjbv"]; (* Model[Container, Vessel, "id:4pO6dM5l83Vz"]; 2 liter detergent senstitive bottles*)
	systemFlushBufferContainer = Model[Container, Vessel, "id:3em6Zv9Njjbv"]; (* Model[Container, Vessel, "id:4pO6dM5l83Vz"]; 2 liter detergent senstitive bottles*)
	bufferContainer = Model[Container, Vessel, "id:3em6Zv9Njjbv"]; (* Model[Container, Vessel, "id:4pO6dM5l83Vz"]; 2 liter detergent senstitive bottles*)
	alkalineBufferContainer = Model[Container, Vessel, "id:mnk9jOkn6oMZ"]; (* Model[Container, Vessel, "Corning Reusable Plastic Reagent Bottles with GL-45 PP Screw Cap, 2L"]. Plastic eluent bottle compatible with special cap for alkaline buffers *)

	(* We have two possible bottles (bufferContainer and alkalineBufferContainer). Both are GL45 cover footprint and we equip the IonChromatography instrument with only 1 type of cap to fit both. However, alkalineBufferContainer requires a shorter tubing length. It means that bufferContainer will have a larger dead volume (measured to be about 320 mL in lab, using 350 mL to be safe). For alkalineBufferContainer, use 100 mL to be safe *)
	(* We also need ~ 300 mL dead volume for purging, leak test etc *)
	bufferContainerDeadVolume = (300+350) * Milliliter;
	alkalineBufferContainerContainerDeadVolume = (300+100) * Milliliter;

	(* Replace the concentration in the anion gradient with 100 percent so that it can be used as input for the helper function below *)
	anionSystemPrimeGradientInPercent = ReplacePart[anionSystemPrimeGradient, {_, 2} -> 100Percent];
	anionSystemFlushGradientInPercent = ReplacePart[anionSystemFlushGradient, {_, 2} -> 100Percent];

	(* Determine volume of DI water required for anion system prime run *)
	anionSystemPrimeInletSolutionVolume = calculateBufferUsage[
		anionSystemPrimeGradientInPercent[[All, {1, 2}]], (*the specific gradient*)
		Max[anionSystemPrimeGradientInPercent[[All, 1]]], (*the last time*)
		anionSystemPrimeGradientInPercent[[All, {1, -1}]], (*the flow rate profile*)
		Last[anionSystemPrimeGradientInPercent[[All, 2]]] (*the last percentage*)
	];

	(*do the same for the system flushes*)
	{cationSystemPrimeBufferAVolume, cationSystemPrimeBufferBVolume, cationSystemPrimeBufferCVolume, cationSystemPrimeBufferDVolume} =
		Map[calculateBufferUsage[
			cationSystemPrimeGradient[[All, {1, #}]], (*the specific gradient*)
			Max[cationSystemPrimeGradient[[All, 1]]], (*the last time*)
			cationSystemPrimeGradient[[All, {1, -1}]], (*the flow rate profile*)
			Last[cationSystemPrimeGradient[[All, #]]] (*the last percentage*)
		]&, Range[2, 5]];

	{systemPrimeBufferAVolume, systemPrimeBufferBVolume, systemPrimeBufferCVolume, systemPrimeBufferDVolume} =
		Map[calculateBufferUsage[
			systemPrimeGradient[[All, {1, #}]], (*the specific gradient*)
			Max[systemPrimeGradient[[All, 1]]], (*the last time*)
			systemPrimeGradient[[All, {1, -1}]], (*the flow rate profile*)
			Last[systemPrimeGradient[[All, #]]] (*the last percentage*)
		]&, Range[2, 5]];

	(* Create resource for SystemPrime's EluentGeneratorInletSolution for anion channel *)
	anionSystemPrimeInletSolutionResource = If[anionChannelRequiredQ,
		Resource[
			Sample -> Lookup[anionSystemPrimeGradientPacket, EluentGeneratorInletSolution],
			Amount -> anionSystemPrimeInletSolutionVolume + bufferContainerDeadVolume,
			Container -> systemPrimeBufferContainer,
			RentContainer -> True,
			Name -> CreateUUID[]
		],
		Null
	];

	(*create the resources for the system flush buffers*)
	{cationSystemPrimeBufferAResource, cationSystemPrimeBufferBResource, cationSystemPrimeBufferCResource, cationSystemPrimeBufferDResource} =
		MapThread[
			Function[{buffer, volume},
				If[cationChannelRequiredQ,
					Module[{sample, container, deadVolume, sampleModelPacket},
						sample = Lookup[cationSystemPrimeGradientPacket, buffer];
						sampleModelPacket = Switch[sample,
							ObjectP[Model[Sample]], fetchPacketFromCache[Download[sample, Object], inheritedCache],
							ObjectP[Object[Sample]], fetchPacketFromCache[Download[sample, Model], inheritedCache],
							_, Null];
						(*Determine we need the plastic bottle based on the buffer sample incompatible materials*)
						{container,deadVolume} = If[MatchQ[sampleModelPacket, PacketP[]] && MemberQ[Lookup[sampleModelPacket, IncompatibleMaterials], Alternatives[Glass, BorosilicateGlass]],
							{alkalineBufferContainer,alkalineBufferContainerContainerDeadVolume},
							{systemPrimeBufferContainer,bufferContainerDeadVolume}
						];
						(*Generate the resource*)
						Resource[
							Sample -> Lookup[cationSystemPrimeGradientPacket, buffer],
							Amount -> volume + deadVolume,
							Container -> container,
							RentContainer -> True,
							Name -> CreateUUID[]
						]
					],
					Null
				]
			],
			{
				{BufferA, BufferB, BufferC, BufferD},
				{cationSystemPrimeBufferAVolume, cationSystemPrimeBufferBVolume, cationSystemPrimeBufferCVolume, cationSystemPrimeBufferDVolume}
			}
		];

	{systemPrimeBufferAResource, systemPrimeBufferBResource, systemPrimeBufferCResource, systemPrimeBufferDResource} =
		MapThread[
			Function[{buffer, volume},
				If[electrochemicalChannelRequiredQ,
					Module[{sample, container, deadVolume, sampleModelPacket},
						sample = Lookup[systemPrimeGradientPacket, buffer];
						sampleModelPacket = Switch[sample,
							ObjectP[Model[Sample]], fetchPacketFromCache[Download[sample, Object], inheritedCache],
							ObjectP[Object[Sample]], fetchPacketFromCache[Download[sample, Model], inheritedCache],
							_, Null];
						(*Determine we need the plastic bottle based on the buffer sample incompatible materials*)
						{container,deadVolume} = If[MatchQ[sampleModelPacket, PacketP[]] && MemberQ[Lookup[sampleModelPacket, IncompatibleMaterials], Alternatives[Glass, BorosilicateGlass]],
							{alkalineBufferContainer,alkalineBufferContainerContainerDeadVolume},
							{systemPrimeBufferContainer,bufferContainerDeadVolume}
						];
						(*Generate the resource*)
						Resource[
							Sample -> sample,
							Amount -> volume + deadVolume,
							Container -> container,
							RentContainer -> True,
							Name -> CreateUUID[]
						]
					],
					Null
				]
			],
			{
				{BufferA, BufferB, BufferC, BufferD},
				{systemPrimeBufferAVolume, systemPrimeBufferBVolume, systemPrimeBufferCVolume, systemPrimeBufferDVolume}
			}
		];


	(* Determine volume of DI water required for anion system prime run *)
	anionSystemFlushInletSolutionVolume = calculateBufferUsage[
		anionSystemFlushGradientInPercent[[All, {1, 2}]], (*the specific gradient*)
		Max[anionSystemFlushGradientInPercent[[All, 1]]], (*the last time*)
		anionSystemFlushGradientInPercent[[All, {1, -1}]], (*the flow rate profile*)
		Last[anionSystemFlushGradientInPercent[[All, 2]]] (*the last percentage*)
	];

	(*do the same for the system flushes*)
	{cationSystemFlushBufferAVolume, cationSystemFlushBufferBVolume, cationSystemFlushBufferCVolume, cationSystemFlushBufferDVolume} =
		Map[calculateBufferUsage[
			cationSystemFlushGradient[[All, {1, #}]], (*the specific gradient*)
			Max[cationSystemFlushGradient[[All, 1]]], (*the last time*)
			cationSystemFlushGradient[[All, {1, -1}]], (*the flow rate profile*)
			Last[cationSystemFlushGradient[[All, #]]] (*the last percentage*)
		]&, Range[2, 5]];

	{systemFlushBufferAVolume, systemFlushBufferBVolume, systemFlushBufferCVolume, systemFlushBufferDVolume} =
		Map[calculateBufferUsage[
			systemFlushGradient[[All, {1, #}]], (*the specific gradient*)
			Max[systemFlushGradient[[All, 1]]], (*the last time*)
			systemFlushGradient[[All, {1, -1}]], (*the flow rate profile*)
			Last[systemFlushGradient[[All, #]]] (*the last percentage*)
		]&, Range[2, 5]];

	(* Create resource for SystemFlush's EluentGeneratorInletSolution for anion channel *)
	anionSystemFlushInletSolutionResource = If[anionChannelRequiredQ,
		Resource[
			Sample -> Lookup[anionSystemFlushGradientPacket, EluentGeneratorInletSolution],
			Amount -> anionSystemFlushInletSolutionVolume + bufferContainerDeadVolume,
			Container -> systemFlushBufferContainer,
			RentContainer -> True,
			Name -> CreateUUID[]
		]
	];

	(*create the resources for the system flush buffers*)
	{cationSystemFlushBufferAResource, cationSystemFlushBufferBResource, cationSystemFlushBufferCResource, cationSystemFlushBufferDResource} =
		MapThread[
			Function[{buffer, volume},
				If[cationChannelRequiredQ,
					Module[{sample, container, deadVolume, sampleModelPacket},
						sample = Lookup[cationSystemFlushGradientPacket, buffer];
						sampleModelPacket = Switch[sample,
							ObjectP[Model[Sample]], fetchPacketFromCache[Download[sample, Object], inheritedCache],
							ObjectP[Object[Sample]], fetchPacketFromCache[Download[sample, Model], inheritedCache],
							_, Null];
						(*Determine we need the plastic bottle based on the buffer sample incompatible materials*)
						{container,deadVolume} = If[MatchQ[sampleModelPacket, PacketP[]] && MemberQ[Lookup[sampleModelPacket, IncompatibleMaterials], Alternatives[Glass, BorosilicateGlass]],
							{alkalineBufferContainer,alkalineBufferContainerContainerDeadVolume},
							{systemPrimeBufferContainer,bufferContainerDeadVolume}
						];
						(* Generate the resource *)
						Resource[
							Sample -> Lookup[cationSystemFlushGradientPacket, buffer],
							Amount -> volume + deadVolume,
							Container -> container,
							RentContainer -> True,
							Name -> CreateUUID[]
						]
					],
					Null
				]
			],
			{
				{BufferA, BufferB, BufferC, BufferD},
				{cationSystemFlushBufferAVolume, cationSystemFlushBufferBVolume, cationSystemFlushBufferCVolume, cationSystemFlushBufferDVolume}
			}
		];

	{systemFlushBufferAResource, systemFlushBufferBResource, systemFlushBufferCResource, systemFlushBufferDResource} =
		MapThread[
			Function[{buffer, volume},
				If[electrochemicalChannelRequiredQ,
					Module[{sample, sampleModelPacket, container, deadVolume},
						sample = Lookup[systemFlushGradientPacket, buffer];
						sampleModelPacket = Switch[sample,
							ObjectP[Model[Sample]], fetchPacketFromCache[Download[sample, Object], inheritedCache],
							ObjectP[Object[Sample]], fetchPacketFromCache[Download[sample, Model], inheritedCache],
							_, Null];
						(*Determine we need the plastic bottle based on the buffer sample incompatible materials*)
						{container, deadVolume} = If[MatchQ[sampleModelPacket, PacketP[]] && MemberQ[Lookup[sampleModelPacket, IncompatibleMaterials], Alternatives[Glass, BorosilicateGlass]],
							{alkalineBufferContainer,alkalineBufferContainerContainerDeadVolume},
							{systemPrimeBufferContainer,bufferContainerDeadVolume}
						];
						(*Generate the resource*)
						Resource[
							Sample -> sample,
							Amount -> volume + deadVolume,
							Container -> container,
							RentContainer -> True,
							Name -> CreateUUID[]
						]
					],
					Null
				]
			],
			{
				{BufferA, BufferB, BufferC, BufferD},
				{systemFlushBufferAVolume, systemFlushBufferBVolume, systemFlushBufferCVolume, systemFlushBufferDVolume}
			}
		];

	(* Update system prime and system flush container placements fields using the resources created aboved*)
	systemPrimeBufferContainerPlacements = {
		If[MatchQ[anionSystemPrimeInletSolutionResource, {} | Null | {Null}], Nothing, {Link[anionSystemPrimeInletSolutionResource], {"EluentGeneratorInletSolution Slot"}}],
		If[MatchQ[cationSystemPrimeBufferAResource, {} | Null | {Null}], Nothing, {Link[cationSystemPrimeBufferAResource], {"Buffer A Slot"}}],
		If[MatchQ[cationSystemPrimeBufferBResource, {} | Null | {Null}], Nothing, {Link[cationSystemPrimeBufferBResource], {"Buffer B Slot"}}],
		If[MatchQ[cationSystemPrimeBufferCResource, {} | Null | {Null}], Nothing, {Link[cationSystemPrimeBufferCResource], {"Buffer C Slot"}}],
		If[MatchQ[cationSystemPrimeBufferDResource, {} | Null | {Null}], Nothing, {Link[cationSystemPrimeBufferDResource], {"Buffer D Slot"}}],
		If[MatchQ[systemPrimeBufferAResource, {} | Null | {Null}], Nothing, {Link[systemPrimeBufferAResource], {"Buffer A Slot"}}],
		If[MatchQ[systemPrimeBufferBResource, {} | Null | {Null}], Nothing, {Link[systemPrimeBufferBResource], {"Buffer B Slot"}}],
		If[MatchQ[systemPrimeBufferCResource, {} | Null | {Null}], Nothing, {Link[systemPrimeBufferCResource], {"Buffer C Slot"}}],
		If[MatchQ[systemPrimeBufferDResource, {} | Null | {Null}], Nothing, {Link[systemPrimeBufferDResource], {"Buffer D Slot"}}]
	};

	systemFlushBufferContainerPlacements = {
		If[MatchQ[anionSystemFlushInletSolutionResource, {} | Null | {Null}], Nothing, {Link[anionSystemFlushInletSolutionResource], {"EluentGeneratorInletSolution Slot"}}],
		If[MatchQ[cationSystemFlushBufferAResource, {} | Null | {Null}], Nothing, {Link[cationSystemFlushBufferAResource], {"Buffer A Slot"}}],
		If[MatchQ[cationSystemFlushBufferBResource, {} | Null | {Null}], Nothing, {Link[cationSystemFlushBufferBResource], {"Buffer B Slot"}}],
		If[MatchQ[cationSystemFlushBufferCResource, {} | Null | {Null}], Nothing, {Link[cationSystemFlushBufferCResource], {"Buffer C Slot"}}],
		If[MatchQ[cationSystemFlushBufferDResource, {} | Null | {Null}], Nothing, {Link[cationSystemFlushBufferDResource], {"Buffer D Slot"}}],
		If[MatchQ[systemFlushBufferAResource, {} | Null | {Null}], Nothing, {Link[systemFlushBufferAResource], {"Buffer A Slot"}}],
		If[MatchQ[systemFlushBufferBResource, {} | Null | {Null}], Nothing, {Link[systemFlushBufferBResource], {"Buffer B Slot"}}],
		If[MatchQ[systemFlushBufferCResource, {} | Null | {Null}], Nothing, {Link[systemFlushBufferCResource], {"Buffer C Slot"}}],
		If[MatchQ[systemFlushBufferDResource, {} | Null | {Null}], Nothing, {Link[systemFlushBufferDResource], {"Buffer D Slot"}}]
	};

	(*make the resources for the needle wash solution*)
	needleWashSolution = Resource[
		Sample -> Lookup[myResolvedOptions, NeedleWashSolution],
		Amount -> 500 Milli Liter,
		Container -> Model[Container, Vessel, "id:zGj91aR3ddXJ"],
		RentContainer -> True,
		Name -> CreateUUID[]
	];

	(*start with the anion column prime*)
	{
		anionColumnPrimeTemperatures,
		columnPrimeEluentGradients,
		anionColumnPrimeFlowRates,
		anionColumnPrimeGradients,
		anionColumnPrimeSuppressorModes,
		anionColumnPrimeSuppressorVoltages,
		anionColumnPrimeSuppressorCurrents,
		anionColumnPrimeDetectionTemperatures
	} = Map[
		If[!NullQ[anionColumnPrimePositionsCorresponded],
			If[MatchQ[#, ObjectP[Object[Method, IonChromatographyGradient]]],
				{#}[[anionColumnPrimePositionsCorresponded]][AnionGradient],
				{#}[[anionColumnPrimePositionsCorresponded]]
			]]&
		, Lookup[myResolvedOptions,
			{
				AnionColumnPrimeTemperature,
				ColumnPrimeEluentGradient,
				AnionColumnPrimeFlowRate,
				AnionColumnPrimeGradient,
				AnionColumnPrimeSuppressorMode,
				AnionColumnPrimeSuppressorVoltage,
				AnionColumnPrimeSuppressorCurrent,
				AnionColumnPrimeDetectionTemperature
			}
		]
	];

	(*then the cation column prime*)
	{
		cationColumnPrimeTemperatures,
		cationColumnPrimeGradientA,
		cationColumnPrimeGradientB,
		cationColumnPrimeGradientC,
		cationColumnPrimeGradientD,
		cationColumnPrimeFlowRates,
		cationColumnPrimeGradients,
		cationColumnPrimeSuppressorModes,
		cationColumnPrimeSuppressorVoltages,
		cationColumnPrimeSuppressorCurrents,
		cationColumnPrimeDetectionTemperatures
	} = Map[
		If[!NullQ[cationColumnPrimePositionsCorresponded],
			If[MatchQ[#, ObjectP[Object[Method, IonChromatographyGradient]]],
				{#}[[cationColumnPrimePositionsCorresponded]][CationGradient],
				{#}[[cationColumnPrimePositionsCorresponded]]
			]]&
		, Lookup[myResolvedOptions,
			{
				CationColumnPrimeTemperature,
				CationColumnPrimeGradientA,
				CationColumnPrimeGradientB,
				CationColumnPrimeGradientC,
				CationColumnPrimeGradientD,
				CationColumnPrimeFlowRate,
				CationColumnPrimeGradient,
				CationColumnPrimeSuppressorMode,
				CationColumnPrimeSuppressorVoltage,
				CationColumnPrimeSuppressorCurrent,
				CationColumnPrimeDetectionTemperature
			}
		]
	];

	(*then the column prime for electrochemical detection*)
	{
		columnPrimeTemperatures,
		columnPrimeGradientA,
		columnPrimeGradientB,
		columnPrimeGradientC,
		columnPrimeGradientD,
		columnPrimeFlowRates,
		columnPrimeGradients,
		columnPrimeAbsorbanceWavelength,
		columnPrimeAbsorbanceSamplingRate,
		columnPrimeVoltageProfile,
		columnPrimeElectrochemicalSamplingRate,
		columnPrimeDetectionTemperatures
	} = Map[
		If[!NullQ[columnPrimePositionsCorresponded],
			If[MatchQ[#, ObjectP[Object[Method, Gradient]]],
				{#}[[columnPrimePositionsCorresponded]][Gradient],
				{#}[[columnPrimePositionsCorresponded]]
			]]&
		, Lookup[myResolvedOptions,
			{
				ColumnPrimeTemperature,
				ColumnPrimeGradientA,
				ColumnPrimeGradientB,
				ColumnPrimeGradientC,
				ColumnPrimeGradientD,
				ColumnPrimeFlowRate,
				ColumnPrimeGradient,
				ColumnPrimeAbsorbanceWavelength,
				ColumnPrimeAbsorbanceSamplingRate,
				ColumnPrimeVoltageProfile,
				ColumnPrimeElectrochemicalSamplingRate,
				ColumnPrimeDetectionTemperature
			}
		]
	];

	(*now get the anion samples, we don't always have anion samples, so we need to check first*)
	{
		anionColumnTemperatures,
		eluentGradients,
		anionFlowRates,
		anionGradients,
		anionSuppressorModes,
		anionSuppressorVoltages,
		anionSuppressorCurrents,
		anionDetectionTemperatures
	} = Map[
		If[!NullQ[anionSamplePositionsCorresponded],
			If[MatchQ[#, ObjectP[Object[Method, IonChromatographyGradient]]],
				(ToList@#)[[anionSamplePositionsCorresponded]][AnionGradient],
				(ToList@#)[[anionSamplePositionsCorresponded]]
			]]&
		, Lookup[myResolvedOptions,
			{
				AnionColumnTemperature,
				EluentGradient,
				AnionFlowRate,
				AnionGradient,
				AnionSuppressorMode,
				AnionSuppressorVoltage,
				AnionSuppressorCurrent,
				AnionDetectionTemperature
			}
		]
	];

	(*then the cation samples, again we don't always have cation samples*)
	{
		cationColumnTemperatures,
		cationGradientA,
		cationGradientB,
		cationGradientC,
		cationGradientD,
		cationFlowRates,
		cationGradients,
		cationSuppressorModes,
		cationSuppressorVoltages,
		cationSuppressorCurrents,
		cationDetectionTemperatures
	} = Map[
		If[!NullQ[cationSamplePositionsCorresponded],
			If[MatchQ[#, ObjectP[Object[Method, IonChromatographyGradient]]],
				(ToList@#)[[cationSamplePositionsCorresponded]][CationGradient],
				(ToList@#)[[cationSamplePositionsCorresponded]]
			]]&
		, Lookup[myResolvedOptions,
			{
				CationColumnTemperature,
				CationGradientA,
				CationGradientB,
				CationGradientC,
				CationGradientD,
				CationFlowRate,
				CationGradient,
				CationSuppressorMode,
				CationSuppressorVoltage,
				CationSuppressorCurrent,
				CationDetectionTemperature
			}
		]
	];

	(*then the samples for electrochemical detection, again we don't always have electrochemical samples*)
	{
		columnTemperatures,
		gradientA,
		gradientB,
		gradientC,
		gradientD,
		flowRates,
		gradients,
		absorbanceWavelength,
		absorbanceSamplingRate,
		voltageProfile,
		electrochemicalSamplingRate,
		detectionTemperatures
	} = Map[
		If[!NullQ[samplePositionsCorresponded],
			If[MatchQ[#, ObjectP[Object[Method, Gradient]]],
				(ToList@#)[[samplePositionsCorresponded]][Gradient],
				(ToList@#)[[samplePositionsCorresponded]]
			]]&
		, Lookup[myResolvedOptions,
			{
				ColumnTemperature,
				GradientA,
				GradientB,
				GradientC,
				GradientD,
				FlowRate,
				Gradient,
				AbsorbanceWavelength,
				AbsorbanceSamplingRate,
				VoltageProfile,
				ElectrochemicalSamplingRate,
				DetectionTemperature
			}
		]
	];

	(*now get the anion standard, we don't always have anion standard, so we need to check first*)
	{
		anionStandardColumnTemperatures,
		standardEluentGradients,
		anionStandardFlowRates,
		anionStandardGradients,
		anionStandardSuppressorModes,
		anionStandardSuppressorVoltages,
		anionStandardSuppressorCurrents,
		anionStandardDetectionTemperatures
	} = Map[
		If[!NullQ[anionStandardPositionsCorresponded],
			If[MatchQ[#, ObjectP[Object[Method, IonChromatographyGradient]]],
				(ToList@#)[[DeleteDuplicates@anionStandardPositionsCorresponded]][AnionGradient],
				(ToList@#)[[DeleteDuplicates@anionStandardPositionsCorresponded]]
			]]&
		, Lookup[myResolvedOptions,
			{
				AnionStandardColumnTemperature,
				StandardEluentGradient,
				AnionStandardFlowRate,
				AnionStandardGradient,
				AnionStandardSuppressorMode,
				AnionStandardSuppressorVoltage,
				AnionStandardSuppressorCurrent,
				AnionStandardDetectionTemperature
			}
		]
	];

	(*then the cation standard, again we don't always have cation standard*)
	{
		cationStandardColumnTemperatures,
		cationStandardGradientA,
		cationStandardGradientB,
		cationStandardGradientC,
		cationStandardGradientD,
		cationStandardFlowRates,
		cationStandardGradients,
		cationStandardSuppressorModes,
		cationStandardSuppressorVoltages,
		cationStandardSuppressorCurrents,
		cationStandardDetectionTemperatures
	} = Map[
		If[!NullQ[cationStandardPositionsCorresponded],
			If[MatchQ[#, ObjectP[Object[Method, IonChromatographyGradient]]],
				(ToList@#)[[DeleteDuplicates@cationStandardPositionsCorresponded]][CationGradient],
				(ToList@#)[[DeleteDuplicates@cationStandardPositionsCorresponded]]
			]]&
		, Lookup[myResolvedOptions,
			{
				CationStandardColumnTemperature,
				CationStandardGradientA,
				CationStandardGradientB,
				CationStandardGradientC,
				CationStandardGradientD,
				CationStandardFlowRate,
				CationStandardGradient,
				CationStandardSuppressorMode,
				CationStandardSuppressorVoltage,
				CationStandardSuppressorCurrent,
				CationStandardDetectionTemperature
			}
		]
	];

	(*then the standard for electrochemical detection, again we don't always have electrochemical standard*)
	{
		standardColumnTemperatures,
		standardGradientA,
		standardGradientB,
		standardGradientC,
		standardGradientD,
		standardFlowRates,
		standardGradients,
		standardAbsorbanceWavelength,
		standardAbsorbanceSamplingRate,
		standardVoltageProfile,
		standardElectrochemicalSamplingRate,
		standardDetectionTemperatures
	} = Map[
		If[!NullQ[standardPositionsCorresponded],
			If[MatchQ[#, ObjectP[Object[Method, Gradient]]],
				(ToList@#)[[DeleteDuplicates@standardPositionsCorresponded]][Gradient],
				(ToList@#)[[DeleteDuplicates@standardPositionsCorresponded]]
			]]&
		, Lookup[myResolvedOptions,
			{
				StandardColumnTemperature,
				StandardGradientA,
				StandardGradientB,
				StandardGradientC,
				StandardGradientD,
				StandardFlowRate,
				StandardGradient,
				StandardAbsorbanceWavelength,
				StandardAbsorbanceSamplingRate,
				StandardVoltageProfile,
				StandardElectrochemicalSamplingRate,
				StandardDetectionTemperature
			}
		]
	];

	(*now get the anion blank, we don't always have anion blank, so we need to check first*)
	{
		anionBlankColumnTemperatures,
		blankEluentGradients,
		anionBlankFlowRates,
		anionBlankGradients,
		anionBlankSuppressorModes,
		anionBlankSuppressorVoltages,
		anionBlankSuppressorCurrents,
		anionBlankDetectionTemperatures
	} = Map[
		If[!NullQ[anionBlankPositionsCorresponded],
			If[MatchQ[#, ObjectP[Object[Method, IonChromatographyGradient]]],
				(ToList@#)[[DeleteDuplicates@anionBlankPositionsCorresponded]][AnionGradient],
				(ToList@#)[[DeleteDuplicates@anionBlankPositionsCorresponded]]
			]]&
		, Lookup[myResolvedOptions,
			{
				AnionBlankColumnTemperature,
				BlankEluentGradient,
				AnionBlankFlowRate,
				AnionBlankGradient,
				AnionBlankSuppressorMode,
				AnionBlankSuppressorVoltage,
				AnionBlankSuppressorCurrent,
				AnionBlankDetectionTemperature
			}
		]
	];

	(*then the cation blank, again we don't always have cation blank*)
	{
		cationBlankColumnTemperatures,
		cationBlankGradientA,
		cationBlankGradientB,
		cationBlankGradientC,
		cationBlankGradientD,
		cationBlankFlowRates,
		cationBlankGradients,
		cationBlankSuppressorModes,
		cationBlankSuppressorVoltages,
		cationBlankSuppressorCurrents,
		cationBlankDetectionTemperatures
	} = Map[
		If[!NullQ[cationBlankPositionsCorresponded],
			If[MatchQ[#, ObjectP[Object[Method, IonChromatographyGradient]]],
				(ToList@#)[[DeleteDuplicates@cationBlankPositionsCorresponded]][CationGradient],
				(ToList@#)[[DeleteDuplicates@cationBlankPositionsCorresponded]]
			]]&
		, Lookup[myResolvedOptions,
			{
				CationBlankColumnTemperature,
				CationBlankGradientA,
				CationBlankGradientB,
				CationBlankGradientC,
				CationBlankGradientD,
				CationBlankFlowRate,
				CationBlankGradient,
				CationBlankSuppressorMode,
				CationBlankSuppressorVoltage,
				CationBlankSuppressorCurrent,
				CationBlankDetectionTemperature
			}
		]
	];

	(*then the cation blank, again we don't always have cation blank*)
	{
		blankColumnTemperatures,
		blankGradientA,
		blankGradientB,
		blankGradientC,
		blankGradientD,
		blankFlowRates,
		blankGradients,
		blankAbsorbanceWavelength,
		blankAbsorbanceSamplingRate,
		blankVoltageProfile,
		blankElectrochemicalSamplingRate,
		blankDetectionTemperatures
	} = Map[
		If[!NullQ[blankPositionsCorresponded],
			If[MatchQ[#, ObjectP[Object[Method, Gradient]]],
				(ToList@#)[[DeleteDuplicates@blankPositionsCorresponded]][Gradient],
				(ToList@#)[[DeleteDuplicates@blankPositionsCorresponded]]
			]]&
		, Lookup[myResolvedOptions,
			{
				BlankColumnTemperature,
				BlankGradientA,
				BlankGradientB,
				BlankGradientC,
				BlankGradientD,
				BlankFlowRate,
				BlankGradient,
				BlankAbsorbanceWavelength,
				BlankAbsorbanceSamplingRate,
				BlankVoltageProfile,
				BlankElectrochemicalSamplingRate,
				BlankDetectionTemperature
			}
		]
	];

	(*finally the anion column flush*)
	{
		anionColumnFlushTemperatures,
		columnFlushEluentGradients,
		anionColumnFlushFlowRates,
		anionColumnFlushGradients,
		anionColumnFlushSuppressorModes,
		anionColumnFlushSuppressorVoltages,
		anionColumnFlushSuppressorCurrents,
		anionColumnFlushDetectionTemperatures
	} = Map[
		If[!NullQ[anionColumnFlushPositionsCorresponded], {#}[[anionColumnFlushPositionsCorresponded]]]&
		, Lookup[myResolvedOptions,
			{
				AnionColumnFlushTemperature,
				ColumnFlushEluentGradient,
				AnionColumnFlushFlowRate,
				AnionColumnFlushGradient,
				AnionColumnFlushSuppressorMode,
				AnionColumnFlushSuppressorVoltage,
				AnionColumnFlushSuppressorCurrent,
				AnionColumnFlushDetectionTemperature
			}
		]
	];

	(*then the cation column flush*)
	{
		cationColumnFlushTemperatures,
		cationColumnFlushGradientA,
		cationColumnFlushGradientB,
		cationColumnFlushGradientC,
		cationColumnFlushGradientD,
		cationColumnFlushFlowRates,
		cationColumnFlushGradients,
		cationColumnFlushSuppressorModes,
		cationColumnFlushSuppressorVoltages,
		cationColumnFlushSuppressorCurrents,
		cationColumnFlushDetectionTemperatures
	} = Map[
		If[!NullQ[cationColumnFlushPositionsCorresponded], {#}[[cationColumnFlushPositionsCorresponded]]]&
		, Lookup[myResolvedOptions,
			{
				CationColumnFlushTemperature,
				CationColumnFlushGradientA,
				CationColumnFlushGradientB,
				CationColumnFlushGradientC,
				CationColumnFlushGradientD,
				CationColumnFlushFlowRate,
				CationColumnFlushGradient,
				CationColumnFlushSuppressorMode,
				CationColumnFlushSuppressorVoltage,
				CationColumnFlushSuppressorCurrent,
				CationColumnFlushDetectionTemperature
			}
		]
	];

	(*then the cation column flush*)
	{
		columnFlushTemperatures,
		columnFlushGradientA,
		columnFlushGradientB,
		columnFlushGradientC,
		columnFlushGradientD,
		columnFlushFlowRates,
		columnFlushGradients,
		columnFlushAbsorbanceWavelength,
		columnFlushAbsorbanceSamplingRate,
		columnFlushVoltageProfile,
		columnFlushElectrochemicalSamplingRate,
		columnFlushDetectionTemperatures
	} = Map[
		If[!NullQ[columnFlushPositionsCorresponded], {#}[[columnFlushPositionsCorresponded]]]&
		, Lookup[myResolvedOptions,
			{
				ColumnFlushTemperature,
				ColumnFlushGradientA,
				ColumnFlushGradientB,
				ColumnFlushGradientC,
				ColumnFlushGradientD,
				ColumnFlushFlowRate,
				ColumnFlushGradient,
				ColumnFlushAbsorbanceWavelength,
				ColumnFlushAbsorbanceSamplingRate,
				ColumnFlushVoltageProfile,
				ColumnFlushElectrochemicalSamplingRate,
				ColumnFlushDetectionTemperature
			}
		]
	];

	(*now we figure out how much buffer to make for the cosolvent and make up solvent*)

	(*get all of the gradients used*)
	allAnionGradients = Download[anionInjectionTableInserted[[All, 5]], Object];
	allCationGradients = Download[cationInjectionTableInserted[[All, 5]], Object];
	allGradients = Download[injectionTableInserted[[All, 4]], Object];

	(*get all of the buffer models for the gradients*)
	{bufferAmodel, bufferBmodel, bufferCmodel, bufferDmodel} = Map[
		If[MatchQ[#, ObjectP[Object[Sample]]],
			Lookup[fetchPacketFromCache[Download[#, Object], inheritedCache], Model],
			(*if not an object. keep the same*)
			#
		]&
		, Lookup[myResolvedOptions, {BufferA, BufferB, BufferC, BufferD}]
	];

	(*will map through and make a gradient for each based on the object ID*)
	uniqueAnionGradientPackets = Map[Function[{gradientObjectID},
		Module[{injectionTablePosition, currentType, currentChannel, anionGradientTuple},

			(*find the injection Table position*)
			injectionTablePosition = First@FirstPosition[anionTableGradients, gradientObjectID];

			(*figure out the type, based on which, look up the gradient tuple*)
			currentType = First[anionInjectionTableColumnTempFull[[injectionTablePosition]]];
			currentChannel = (anionInjectionTableColumnTempFull[[injectionTablePosition]])[[3]];

			(*get the anion gradient based on the type and the position*)
			anionGradientTuple = If[MatchQ[currentChannel, AnionChannel],

				Switch[currentType,
					Sample,
					ToList[anionSampleGradient][[injectionTablePosition /. anionSampleReverseAssociation]],

					Standard,
					ToList[anionStandardGradient][[injectionTablePosition /. anionStandardReverseAssociation]],

					Blank,
					ToList[anionBlankGradient][[injectionTablePosition /. anionBlankReverseAssociation]],

					ColumnPrime,
					{anionColumnPrimeGradient}[[injectionTablePosition /. anionColumnPrimeReverseAssociation]],

					ColumnFlush,
					{anionColumnFlushGradient}[[injectionTablePosition /. anionColumnFlushReverseAssociation]]
				]
			];

			(*make the gradient packet*)
			<|
				Object -> gradientObjectID,
				Type -> Object[Method, IonChromatographyGradient],
				EluentGeneratorInletSolution -> Link[Model[Sample, "Milli-Q water"]],
				Replace[AnionGradient] -> anionGradientTuple,
				Replace[EluentGradient] -> anionGradientTuple[[All, {1, 2}]],
				Replace[AnionFlowRate] -> anionGradientTuple[[All, {1, 3}]],
				AnionInitialFlowRate -> anionGradientTuple[[1, 3]],
				(*we also need our column temperature*)
				AnionColumnTemperature -> anionInjectionTableColumnTempFull[[injectionTablePosition]][[7]]
			|>
		]], anionGradientObjectsToMake
	];

	(*will map through and make a gradient for each based on the object ID*)
	uniqueCationGradientPackets = Map[Function[{gradientObjectID},
		Module[{injectionTablePosition, currentType, currentChannel, cationGradientTuple},

			(*find the injection Table position*)
			injectionTablePosition = First@FirstPosition[cationTableGradients, gradientObjectID];

			(*figure out the type, based on which, look up the gradient tuple*)
			currentType = First[cationInjectionTableColumnTempFull[[injectionTablePosition]]];
			currentChannel = (cationInjectionTableColumnTempFull[[injectionTablePosition]])[[3]];

			(*get the cation gradient based on the type and the position*)
			cationGradientTuple = If[MatchQ[currentChannel, CationChannel],

				Switch[currentType,
					Sample,
					ToList[cationSampleGradient][[injectionTablePosition /. cationSampleReverseAssociation]],

					Standard,
					ToList[cationStandardGradient][[injectionTablePosition /. cationStandardReverseAssociation]],

					Blank,
					ToList[cationBlankGradient][[injectionTablePosition /. cationBlankReverseAssociation]],

					ColumnPrime,
					{cationColumnPrimeGradient}[[injectionTablePosition /. cationColumnPrimeReverseAssociation]],

					ColumnFlush,
					{cationColumnFlushGradient}[[injectionTablePosition /. cationColumnFlushReverseAssociation]]
				]
			];

			(*make the gradient packet*)
			<|
				Object -> gradientObjectID,
				Type -> Object[Method, IonChromatographyGradient],
				BufferA -> Link[bufferAmodel],
				BufferB -> Link[bufferBmodel],
				BufferC -> Link[bufferCmodel],
				BufferD -> Link[bufferDmodel],
				Replace[CationGradient] -> cationGradientTuple,
				Replace[GradientA] -> cationGradientTuple[[All, {1, 2}]],
				Replace[GradientB] -> cationGradientTuple[[All, {1, 3}]],
				Replace[GradientC] -> cationGradientTuple[[All, {1, 4}]],
				Replace[GradientD] -> cationGradientTuple[[All, {1, 5}]],
				Replace[CationFlowRate] -> cationGradientTuple[[All, {1, 6}]],
				CationInitialFlowRate -> cationGradientTuple[[1, 6]],
				(*we also need our column temperature*)
				CationColumnTemperature -> cationInjectionTableColumnTempFull[[injectionTablePosition]][[7]]
			|>
		]], cationGradientObjectsToMake
	];

	(*will map through and make a gradient for each based on the object ID*)
	uniqueGradientPackets = If[MatchQ[electrochemicalInjectionTableColumnTempFull, {} | Null | {Null}],

		{},

		Map[Function[{gradientObjectID},
			Module[{injectionTablePosition, currentType, currentChannel, gradientTuple, currentGradientTuple},

				(*find the injection Table position*)
				injectionTablePosition = First@FirstPosition[tableGradients, gradientObjectID];

				(*figure out the type, based on which, look up the gradient tuple*)
				currentType = First[electrochemicalInjectionTableColumnTempFull[[injectionTablePosition]]];

				(*get the gradient based on the type and the position*)
				gradientTuple = Switch[currentType,
					Sample,
					ToList[sampleGradient][[injectionTablePosition /. sampleReverseAssociation]],

					Standard,
					ToList[standardGradient][[injectionTablePosition /. standardReverseAssociation]],

					Blank,
					ToList[blankGradient][[injectionTablePosition /. blankReverseAssociation]],

					ColumnPrime,
					{columnPrimeGradient}[[injectionTablePosition /. columnPrimeReverseAssociation]],

					ColumnFlush,
					{columnFlushGradient}[[injectionTablePosition /. columnFlushReverseAssociation]]
				];

				currentGradientTuple = Switch[gradientTuple,
					binaryGradientP, Transpose@Nest[Insert[#, Repeat[0 Percent, Length[gradientTuple]], -2] &, Transpose@gradientTuple, 6],
					gradientP, Transpose@Nest[Insert[#, Repeat[0 Percent, Length[gradientTuple]], -2] &, Transpose@gradientTuple, 4],
					_, gradientTuple
				];

				(*make the gradient packet*)
				<|
					Object -> gradientObjectID,
					Type -> Object[Method, Gradient],
					BufferA -> Link[bufferAmodel],
					BufferB -> Link[bufferBmodel],
					BufferC -> Link[bufferCmodel],
					BufferD -> Link[bufferDmodel],
					Replace[Gradient] -> currentGradientTuple,
					Replace[GradientA] -> currentGradientTuple[[All, {1, 2}]],
					Replace[GradientB] -> currentGradientTuple[[All, {1, 3}]],
					Replace[GradientC] -> currentGradientTuple[[All, {1, 4}]],
					Replace[GradientD] -> currentGradientTuple[[All, {1, 5}]],
					Replace[GradientE] -> currentGradientTuple[[All, {1, 6}]],
					Replace[GradientF] -> currentGradientTuple[[All, {1, 7}]],
					Replace[GradientG] -> currentGradientTuple[[All, {1, 8}]],
					Replace[GradientH] -> currentGradientTuple[[All, {1, 9}]],
					Replace[FlowRate] -> currentGradientTuple[[All, {1, -1}]],
					InitialFlowRate -> currentGradientTuple[[1, -1]],
					(*we also need our column temperature*)
					Temperature -> electrochemicalInjectionTableColumnTempFull[[injectionTablePosition]][[6]]
				|>
			]], gradientObjectsToMake
		]
	];

	(*look everything up in the cache and extract out the gradient tuple*)
	allAnionGradientTuples = Map[
		Function[{gradientObject},
			Lookup[
				fetchPacketFromCache[gradientObject, Join[inheritedCache, uniqueAnionGradientPackets]],
				AnionGradient,
				(*otherwise check if there is a replace*)
				Lookup[fetchPacketFromCache[gradientObject, Join[inheritedCache, uniqueAnionGradientPackets]], Replace[AnionGradient]]
			]
		], allAnionGradients
	];

	(*look everything up in the cache and extract out the gradient tuple*)
	allCationGradientTuples = Map[
		Function[{gradientObject},
			Lookup[
				fetchPacketFromCache[gradientObject, Join[inheritedCache, uniqueCationGradientPackets]],
				CationGradient,
				(*otherwise check if there is a replace*)
				Lookup[fetchPacketFromCache[gradientObject, Join[inheritedCache, uniqueCationGradientPackets]], Replace[CationGradient]]
			]
		], allCationGradients
	];

	(*look everything up in the cache and extract out the gradient tuple*)
	allGradientTuples = Map[
		Function[{gradientObject},
			Lookup[
				fetchPacketFromCache[gradientObject, Join[inheritedCache, uniqueGradientPackets]],
				Gradient,
				(*otherwise check if there is a replace*)
				Lookup[fetchPacketFromCache[gradientObject, Join[inheritedCache, uniqueGradientPackets]], Replace[Gradient]]
			]
		], allGradients
	];

	(* Replace the concentration in the anion gradient with 100 percent so that it can be used as input for the helper function below *)
	allAnionGradientTuplesInPercent = ReplacePart[#, {_, 2} -> 100 Percent]& /@ allAnionGradientTuples;

	(* If anion channel is not used in the experiment and no anion gradient is specified, then we don't need to resource pick the eluent generator inlet solution *)
	eluentGeneratorInletSolutionResource = If[!anionChannelRequiredQ || MatchQ[allAnionGradients, {} | Null | {Null}],
		Null,

		(*otherwise we need to figure out exactly how much we need*)
		Module[{waterVolumes, totalVolumeNeeded},

			waterVolumes = Map[Function[{currentGradientTuple},
				calculateBufferUsage[
					currentGradientTuple[[All, {1, 2}]],
					Max[currentGradientTuple[[All, 1]]], (*last time point*)
					currentGradientTuple[[All, {1, -1}]],
					Last[currentGradientTuple[[All, 2]]] (*last percentage*)
				]
			], allAnionGradientTuplesInPercent];

			totalVolumeNeeded = Total[waterVolumes];

			(*now make our resource*)
			Resource[
				Sample -> Model[Sample, "Milli-Q water"],
				(*can't supply more than the volume of the container*)
				Amount -> Min[2 Liter, bufferContainerDeadVolume + totalVolumeNeeded],
				(*2 L bottle*)
				Container -> bufferContainer,
				RentContainer -> True,
				Name -> CreateUUID[]
			]
		]
	];

	{bufferAResource, bufferBResource, bufferCResource, bufferDResource} = Map[
		Function[{entry}, Module[{bufferOption, gradientIndex},

			(*split our entry*)
			{bufferOption, gradientIndex} = entry;

			(*first check if buffers options are given, if not, we don't need to resource pick anything*)
			If[MatchQ[bufferOption, {} | Null | {Null}],
				Null,

				(*otherwise we need to figure out exactly how much we need*)
				Module[{bufferVolumes, totalVolumeNeeded, bufferModelPacket, container, deadVolume, gradientTuples},

					gradientTuples = Which[
						(* We need to identify which gradient tuples to use *)
						(* Use cation gradient tuples for cation channel *)
						cationChannelRequiredQ, allCationGradientTuples,
						(* Use electrochemical gradient tuples for electrochemical channel *)
						electrochemicalChannelRequiredQ, allGradientTuples,
						True, {}
					];

					bufferVolumes = Map[Function[{currentGradientTuple},
						calculateBufferUsage[
							currentGradientTuple[[All, {1, gradientIndex}]],
							Max[currentGradientTuple[[All, 1]]], (*last time point*)
							currentGradientTuple[[All, {1, -1}]],
							Last[currentGradientTuple[[All, gradientIndex]]] (*last percentage*)
						]
					], gradientTuples];

					totalVolumeNeeded = Total[bufferVolumes];

					bufferModelPacket = Switch[bufferOption,
						ObjectP[Model[Sample]], fetchPacketFromCache[Download[bufferOption, Object, Cache -> inheritedCache], inheritedCache],
						ObjectP[Object[Sample]], fetchPacketFromCache[Download[bufferOption, Model, Cache -> inheritedCache], inheritedCache],
						_, Null];
					(*Determine what container we need based on the buffer sample and its model's incompatible materials*)
					{container,deadVolume} = If[MatchQ[bufferModelPacket, PacketP[]] && MemberQ[Lookup[bufferModelPacket, IncompatibleMaterials], Alternatives[Glass, BorosilicateGlass]],
						{alkalineBufferContainer,alkalineBufferContainerContainerDeadVolume},
						{systemPrimeBufferContainer,bufferContainerDeadVolume}
					];

					(*Generate the resource*)
					Resource[
						Sample -> bufferOption,
						(*can't supply more than the volume of the container*)
						Amount -> Min[2 Liter, deadVolume + totalVolumeNeeded],
						(*1 L bottle*)
						Container -> container,
						RentContainer -> True,
						Name -> CreateUUID[]
					]
				]
			]
		]],
		{
			{Lookup[myResolvedOptions, BufferA], 2},
			{Lookup[myResolvedOptions, BufferB], 3},
			{Lookup[myResolvedOptions, BufferC], 4},
			{Lookup[myResolvedOptions, BufferD], 5}
		}
	];

	(*we will need to get the times for each run*)
	{anionSampleTimes, anionStandardTimes, anionBlankTimes, anionColumnPrimeTimes, anionColumnFlushTimes} = MapThread[
		Function[{gradientOption, correspondingPositions},
			If[!NullQ[gradientOption],
				(*map through and get the tuple*)
				anionInnerTimes = Map[
					Function[{gradientElement},
						anionMappingGradientTuple = If[MatchQ[gradientElement, ObjectP[Object[Method, IonChromatographyGradient]]],
							(*fetch if a method*)
							Lookup[fetchPacketFromCache[gradientElement, Join[inheritedCache, uniqueAnionGradientPackets]], AnionGradient],
							gradientElement
						];
						(*we'll want the last time point*)
						anionMappingGradientTuple[[-1, 1]]
					],
					gradientOption];

				(*expand out by the corresponding positions*)
				anionInnerTimes[[correspondingPositions]]
			]
		]
		, {
			{anionGradients, anionStandardGradients, anionBlankGradients, anionColumnPrimeGradients, anionColumnFlushGradients},
			{anionSamplePositionsCorresponded, anionStandardPositionsCorresponded, anionBlankPositionsCorresponded, anionColumnPrimePositionsCorresponded, anionColumnFlushPositionsCorresponded}
		}
	];

	(*we will need to get the times for each run*)
	{cationSampleTimes, cationStandardTimes, cationBlankTimes, cationColumnPrimeTimes, cationColumnFlushTimes} = MapThread[
		Function[{gradientOption, correspondingPositions},
			If[!NullQ[gradientOption],
				(*map through and get the tuple*)

				cationInnerTimes = Map[
					Function[{gradientElement},
						cationMappingGradientTuple = If[MatchQ[gradientElement, ObjectP[Object[Method, IonChromatographyGradient]]],
							(*fetch if a method*)
							Lookup[fetchPacketFromCache[gradientElement, Join[inheritedCache, uniqueCationGradientPackets]], CationGradient],
							gradientElement
						];
						(*we'll want the last time point*)
						cationMappingGradientTuple[[-1, 1]]
					],
					gradientOption];

				(*expand out by the corresponding positions*)
				cationInnerTimes[[correspondingPositions]]
			]
		]
		, {
			{cationGradients, cationStandardGradients, cationBlankGradients, cationColumnPrimeGradients, cationColumnFlushGradients},
			{cationSamplePositionsCorresponded, cationStandardPositionsCorresponded, cationBlankPositionsCorresponded, cationColumnPrimePositionsCorresponded, cationColumnFlushPositionsCorresponded}
		}
	];

	(*we will need to get the times for each run*)
	{sampleTimes, standardTimes, blankTimes, columnPrimeTimes, columnFlushTimes} = MapThread[
		Function[{gradientOption, correspondingPositions},
			If[!NullQ[gradientOption],
				(*map through and get the tuple*)

				innerTimes = Map[
					Function[{gradientElement},
						mappingGradientTuple = If[MatchQ[gradientElement, ObjectP[Object[Method, Gradient]]],
							(*fetch if a method*)
							Lookup[fetchPacketFromCache[gradientElement, Join[inheritedCache, uniqueGradientPackets]], Gradient],
							gradientElement
						];
						(*we'll want the last time point*)
						mappingGradientTuple[[-1, 1]]
					],
					gradientOption];

				(*expand out by the corresponding positions*)
				innerTimes[[correspondingPositions]]
			]
		]
		, {
			{gradients, standardGradients, blankGradients, columnPrimeGradients, columnFlushGradients},
			{samplePositionsCorresponded, standardPositionsCorresponded, blankPositionsCorresponded, columnPrimePositionsCorresponded, columnFlushPositionsCorresponded}
		}
	];

	(*make an array of all the times*)
	allTimes = Join@Cases[{Sequence @@ ConstantArray[anionSampleTimes, numReplicates], Sequence @@ ConstantArray[cationSampleTimes, numReplicates], Sequence @@ ConstantArray[sampleTimes, numReplicates],
		anionColumnPrimeTimes, anionStandardTimes, anionBlankTimes, anionColumnFlushTimes,
		cationColumnPrimeTimes, cationStandardTimes, cationBlankTimes, cationColumnFlushTimes,
		columnPrimeTimes, standardTimes, blankTimes, columnFlushTimes
	}, Except[Null]];

	(*use this to calculate the total run time*)
	totalRunTime = Total[Total /@ allTimes] + 120 Minute;

	(* --- Generate the protocol packet --- *)
	protocolPacket = <|

		(* === General options === *)
		Type -> Object[Protocol, IonChromatography],
		Object -> CreateID[Object[Protocol, IonChromatography]],
		Name -> Lookup[myResolvedOptions, Name],
		Operator -> Link@Lookup[myResolvedOptions, Operator],
		Replace[SamplesIn] -> (Link[#, Protocols]& /@ sampleResources),
		Replace[ContainersIn] -> (Link[Resource[Sample -> #], Protocols]&) /@ uniqueSampleContainers,
		UnresolvedOptions -> myUnresolvedOptions,
		ResolvedOptions -> myResolvedOptions,
		NumberOfReplicates -> numReplicates,
		Instrument -> Link[
			Resource[
				Instrument -> Lookup[myResolvedOptions, Instrument],
				Time -> (totalRunTime + 1 Hour + 3 Hour + 90 Minute + 1 Hour + 2 Hour + 20 Minute + 15 Minute)
			]
		],

		Replace[AnalysisChannels] -> Lookup[myResolvedOptions, AnalysisChannel],
		Replace[ChannelSelection] -> Which[
			anionChannelRequiredQ && cationChannelRequiredQ,
			{AnionChannel, CationChannel},
			anionChannelRequiredQ,
			{AnionChannel},
			cationChannelRequiredQ,
			{CationChannel},
			True,
			Null
		],
		SeparationTime -> totalRunTime,
		TubingRinseSolution -> Link[
			Resource[
				Sample -> Model[Sample, "Milli-Q water"],
				Amount -> 500 Milli Liter,
				(* 1000 mL Glass Beaker *)
				Container -> Model[Container, Vessel, "id:O81aEB4kJJJo"],
				RentContainer -> True
			]
		],
		NeedleWashSolution -> Link[needleWashSolution],
		SampleTemperature -> Lookup[myResolvedOptions, SampleTemperature] /. {Ambient -> 25 Celsius},
		(* We will create Cover resources in the compiler, when we have the WorkingContainers and can prepare resources that are index matched to the WorkingContainers field *)
		Replace[SamplesInStorage] -> Lookup[myResolvedOptions, SamplesInStorageCondition],

		Replace[Standards] -> DeleteDuplicates@(linkedStandardResources /. Null -> {}),
		Replace[StandardAnalysisChannels] -> Lookup[myResolvedOptions, StandardAnalysisChannel],
		Replace[StandardsStorageConditions] -> Lookup[myResolvedOptions, StandardStorageCondition],

		Replace[Blanks] -> DeleteDuplicates@(linkedBlankResources /. Null -> {}),
		Replace[BlankAnalysisChannels] -> Lookup[myResolvedOptions, BlankAnalysisChannel],
		Replace[BlanksStorageConditions] -> Lookup[myResolvedOptions, BlankStorageCondition],

		Replace[SystemPrimeBufferContainerPlacements] -> systemPrimeBufferContainerPlacements,
		Replace[SystemFlushBufferContainerPlacements] -> systemFlushBufferContainerPlacements,


		(* === Anion replated options === *)
		Replace[AnionSamples] -> ToList[linkedAnionSampleResources],
		AnionColumn -> Link[anionColumnResource],
		AnionGuardColumn -> Link[anionGuardColumnResource],
		AnionSuppressor -> Link[anionSuppressor],
		AnionDetector -> If[anionChannelRequiredQ, Lookup[instrumentModelPacket, AnionDetector], Null],
		EluentGeneratorInletSolution -> Link[eluentGeneratorInletSolutionResource],
		Eluent -> If[anionChannelRequiredQ, Link[eluent], Null],
		Replace[EluentGradient] -> eluentGradients,
		Replace[AnionGradientMethods] -> If[MatchQ[anionInjectionTable, {} | {Null} | Null],
			Null,
			anionInjectionTableWithLinks[[anionSamplePositions, 5]]
		],
		Replace[AnionFlowRate] -> anionFlowRates,
		Replace[AnionColumnTemperature] -> Cases[anionInjectionTableColumnTempFull, {Sample, ___}][[All, 7]] /. {Ambient -> 25 Celsius},
		Replace[AnionSampleVolumes] -> If[Length[anionSamplePositions] > 0,
			InjectionVolume /. Flatten[DeleteDuplicates[Cases[anionInjectionTableUploadable, KeyValuePattern[Sample -> #]]]& /@ ToList[linkedAnionSampleResources]],
			Null
		],
		Replace[AnionSuppressorMode] -> anionSuppressorModes,
		Replace[AnionSuppressorVoltage] -> anionSuppressorVoltages,
		Replace[AnionSuppressorCurrent] -> anionSuppressorCurrents,
		Replace[AnionDetectionTemperature] -> anionDetectionTemperatures /. {Ambient -> 25 Celsius},
		Replace[AnionInjectionTable] -> anionInjectionTableUploadable,

		Replace[AnionStandards] -> DeleteDuplicates@linkedAnionStandardResources,
		Replace[AnionStandardColumnTemperature] -> anionStandardColumnTemperatures /. {Ambient -> 25 Celsius},
		Replace[AnionStandardSampleVolumes] -> If[Length[anionStandardPositions] > 0,
			InjectionVolume /. First[Flatten[DeleteDuplicates[Cases[anionInjectionTableUploadable, KeyValuePattern[Sample -> #]]]]& /@ ToList[linkedAnionStandardResources]],
			Null
		],
		Replace[StandardEluentGradient] -> standardEluentGradients,
		Replace[AnionStandardFlowRate] -> anionStandardFlowRates,
		Replace[AnionStandardGradientMethods] -> If[Length[anionStandardPositions] > 0,
			Gradient /. First[Flatten[DeleteDuplicates[Cases[anionInjectionTableUploadable, KeyValuePattern[Sample -> #]]]]& /@ ToList[linkedAnionStandardResources]],
			Null
		],
		Replace[AnionStandardSuppressorMode] -> anionStandardSuppressorModes,
		Replace[AnionStandardSuppressorVoltage] -> anionStandardSuppressorVoltages,
		Replace[AnionStandardSuppressorCurrent] -> anionStandardSuppressorCurrents,
		Replace[AnionStandardDetectionTemperature] -> anionStandardDetectionTemperatures /. {Ambient -> 25 Celsius},

		Replace[AnionBlanks] -> DeleteDuplicates@linkedAnionBlankResources,
		Replace[AnionBlankColumnTemperature] -> anionBlankColumnTemperatures /. {Ambient -> 25 Celsius},
		Replace[AnionBlankSampleVolumes] -> If[Length[anionBlankPositions] > 0,
			InjectionVolume /. First[Flatten[DeleteDuplicates[Cases[anionInjectionTableUploadable, KeyValuePattern[Sample -> #]]]]& /@ ToList[linkedAnionBlankResources]],
			Null
		],
		Replace[BlankEluentGradient] -> blankEluentGradients,
		Replace[AnionBlankFlowRate] -> anionBlankFlowRates,
		Replace[AnionBlankGradientMethods] -> If[Length[anionBlankPositions] > 0,
			Gradient /. First[Flatten[DeleteDuplicates[Cases[anionInjectionTableUploadable, KeyValuePattern[Sample -> #]]]]& /@ ToList[linkedAnionBlankResources]],
			Null
		],
		Replace[AnionBlankSuppressorMode] -> anionBlankSuppressorModes,
		Replace[AnionBlankSuppressorVoltage] -> anionBlankSuppressorVoltages,
		Replace[AnionBlankSuppressorCurrent] -> anionBlankSuppressorCurrents,
		Replace[AnionBlankDetectionTemperature] -> anionBlankDetectionTemperatures /. {Ambient -> 25 Celsius},

		SystemPrimeEluentGeneratorInletSolution -> If[anionChannelRequiredQ, anionSystemPrimeInletSolutionResource, Null],
		AnionSystemPrimeGradient -> If[anionChannelRequiredQ, Link[anionSystemPrimeGradientMethod], Null],

		Replace[ColumnPrimeEluentGradients] -> columnPrimeEluentGradients,
		Replace[AnionColumnPrimeGradients] -> If[Length[anionColumnPrimePositions] > 0, anionInjectionTableWithLinks[[anionColumnPrimePositions, 5]], Null],
		AnionColumnPrimeTemperature -> (If[Length[anionColumnPrimePositions] > 0, ((anionInjectionTableColumnTempFull[[anionColumnPrimePositions, 7]][[1]]) /. {Ambient -> 25 Celsius}), Null]),
		AnionColumnPrimeSuppressorMode -> If[!NullQ[anionColumnPrimeSuppressorModes], anionColumnPrimeSuppressorModes[[1]], Null],
		AnionColumnPrimeSuppressorVoltage -> If[!NullQ[anionColumnPrimeSuppressorVoltages], anionColumnPrimeSuppressorVoltages[[1]], Null],
		AnionColumnPrimeSuppressorCurrent -> If[!NullQ[anionColumnPrimeSuppressorCurrents], anionColumnPrimeSuppressorCurrents[[1]], Null],
		AnionColumnPrimeDetectionTemperature -> If[!NullQ[anionColumnPrimeDetectionTemperatures], anionColumnPrimeDetectionTemperatures[[1]] /. {Ambient -> 25 Celsius}, Null],

		Replace[ColumnFlushEluentGradients] -> columnFlushEluentGradients,
		Replace[AnionColumnFlushGradients] -> If[Length[anionColumnFlushPositions] > 0, anionInjectionTableWithLinks[[anionColumnFlushPositions, 5]], Null],
		AnionColumnFlushTemperature -> (If[Length[anionColumnFlushPositions] > 0, ((anionInjectionTableColumnTempFull[[anionColumnFlushPositions, 7]][[1]]) /. {Ambient -> 25 Celsius}), Null]),
		Replace[AnionColumnFlushSuppressorMode] -> If[!NullQ[anionColumnFlushSuppressorModes], anionColumnFlushSuppressorModes[[1]], Null],
		Replace[AnionColumnFlushSuppressorVoltage] -> If[!NullQ[anionColumnFlushSuppressorVoltages], anionColumnFlushSuppressorVoltages[[1]], Null],
		Replace[AnionColumnFlushSuppressorCurrent] -> If[!NullQ[anionColumnFlushSuppressorCurrents], anionColumnFlushSuppressorCurrents[[1]], Null],
		Replace[AnionColumnFlushDetectionTemperature] -> If[!NullQ[anionColumnFlushDetectionTemperatures], anionColumnFlushDetectionTemperatures[[1]] /. {Ambient -> 25 Celsius}, Null],

		SystemFlushEluentGeneratorInletSolution -> If[anionChannelRequiredQ, anionSystemFlushInletSolutionResource, Null],
		AnionSystemFlushGradient -> If[anionChannelRequiredQ, Link[anionSystemFlushGradientMethod], Null],

		AnionInitialPressureLowerLimit -> If[anionChannelRequiredQ, 200 PSI, Null],
		AnionInitialPressureUpperLimit -> If[anionChannelRequiredQ, 5000 PSI, Null],

		(* -- shared options between cation and electrochemical -- *)
		BufferA -> Link[bufferAResource],
		BufferB -> Link[bufferBResource],
		BufferC -> Link[bufferCResource],
		BufferD -> Link[bufferDResource],
		BufferAStorageCondition -> Lookup[myResolvedOptions, BufferAStorageCondition],
		BufferBStorageCondition -> Lookup[myResolvedOptions, BufferBStorageCondition],
		BufferCStorageCondition -> Lookup[myResolvedOptions, BufferCStorageCondition],
		BufferDStorageCondition -> Lookup[myResolvedOptions, BufferDStorageCondition],

		SystemPrimeBufferA -> Which[
			cationChannelRequiredQ, cationSystemPrimeBufferAResource,
			electrochemicalChannelRequiredQ, systemPrimeBufferAResource,
			True, Null
		],
		SystemPrimeBufferB -> Which[
			cationChannelRequiredQ, cationSystemPrimeBufferBResource,
			electrochemicalChannelRequiredQ, systemPrimeBufferBResource,
			True, Null
		],
		SystemPrimeBufferC -> Which[
			cationChannelRequiredQ, cationSystemPrimeBufferCResource,
			electrochemicalChannelRequiredQ, systemPrimeBufferCResource,
			True, Null
		],
		SystemPrimeBufferD -> Which[
			cationChannelRequiredQ, cationSystemPrimeBufferDResource,
			electrochemicalChannelRequiredQ, systemPrimeBufferDResource,
			True, Null
		],

		SystemFlushBufferA -> Which[
			cationChannelRequiredQ, cationSystemFlushBufferAResource,
			electrochemicalChannelRequiredQ, systemFlushBufferAResource,
			True, Null
		],
		SystemFlushBufferB -> Which[
			cationChannelRequiredQ, cationSystemFlushBufferBResource,
			electrochemicalChannelRequiredQ, systemFlushBufferBResource,
			True, Null
		],
		SystemFlushBufferC -> Which[
			cationChannelRequiredQ, cationSystemFlushBufferCResource,
			electrochemicalChannelRequiredQ, systemFlushBufferCResource,
			True, Null
		],
		SystemFlushBufferD -> Which[
			cationChannelRequiredQ, cationSystemFlushBufferDResource,
			electrochemicalChannelRequiredQ, systemFlushBufferDResource,
			True, Null
		],

		(* === Cation replated options === *)
		Replace[CationSamples] -> ToList[linkedCationSampleResources],
		CationColumn -> Link[cationColumnResource],
		CationGuardColumn -> Link[cationGuardColumnResource],
		CationSuppressor -> Link[cationSuppressor],
		CationDetector -> If[cationChannelRequiredQ, Lookup[instrumentModelPacket, CationDetector], Null],
		Replace[CationGradientA] -> cationGradientA,
		Replace[CationGradientB] -> cationGradientB,
		Replace[CationGradientC] -> cationGradientC,
		Replace[CationGradientD] -> cationGradientD,
		Replace[CationGradientMethods] -> If[MatchQ[cationInjectionTable, {} | Null | {Null}],
			Null,
			cationInjectionTableWithLinks[[cationSamplePositions, 5]]
		],
		Replace[CationFlowRate] -> cationFlowRates,
		Replace[CationColumnTemperature] -> Cases[cationInjectionTableColumnTempFull, {Sample, ___}][[All, 7]] /. {Ambient -> 25 Celsius},
		Replace[CationSampleVolumes] -> If[Length[cationSamplePositions] > 0,
			InjectionVolume /. Flatten[DeleteDuplicates[Cases[cationInjectionTableUploadable, KeyValuePattern[Sample -> #]]]& /@ ToList[linkedCationSampleResources]],
			Null
		],
		Replace[CationSuppressorMode] -> cationSuppressorModes,
		Replace[CationSuppressorVoltage] -> cationSuppressorVoltages,
		Replace[CationSuppressorCurrent] -> cationSuppressorCurrents,
		Replace[CationDetectionTemperature] -> cationDetectionTemperatures /. {Ambient -> 25 Celsius},
		Replace[CationInjectionTable] -> cationInjectionTableUploadable,

		Replace[CationStandards] -> DeleteDuplicates@linkedCationStandardResources,
		Replace[CationStandardColumnTemperature] -> cationStandardColumnTemperatures /. {Ambient -> 25 Celsius},
		Replace[CationStandardSampleVolumes] -> If[Length[cationStandardPositions] > 0,
			InjectionVolume /. First[Flatten[DeleteDuplicates[Cases[cationInjectionTableUploadable, KeyValuePattern[Sample -> #]]]]& /@ ToList[linkedCationStandardResources]],
			Null
		],
		Replace[CationStandardGradientA] -> cationStandardGradientA,
		Replace[CationStandardGradientB] -> cationStandardGradientB,
		Replace[CationStandardGradientC] -> cationStandardGradientC,
		Replace[CationStandardGradientD] -> cationStandardGradientD,
		Replace[CationStandardFlowRate] -> cationStandardFlowRates,
		Replace[CationStandardGradientMethods] -> If[Length[cationStandardPositions] > 0,
			Gradient /. First[Flatten[DeleteDuplicates[Cases[cationInjectionTableUploadable, KeyValuePattern[Sample -> #]]]]& /@ ToList[linkedCationStandardResources]],
			Null
		],
		Replace[CationStandardSuppressorMode] -> cationStandardSuppressorModes,
		Replace[CationStandardSuppressorVoltage] -> cationStandardSuppressorVoltages,
		Replace[CationStandardSuppressorCurrent] -> cationStandardSuppressorCurrents,
		Replace[CationStandardDetectionTemperature] -> cationStandardDetectionTemperatures /. {Ambient -> 25 Celsius},

		Replace[CationBlanks] -> DeleteDuplicates@linkedCationBlankResources,
		Replace[CationBlankColumnTemperature] -> cationBlankColumnTemperatures /. {Ambient -> 25 Celsius},
		Replace[CationBlankSampleVolumes] -> If[Length[cationBlankPositions] > 0,
			InjectionVolume /. First[Flatten[DeleteDuplicates[Cases[cationInjectionTableUploadable, KeyValuePattern[Sample -> #]]]]& /@ ToList[linkedCationBlankResources]],
			Null
		],
		Replace[CationBlankGradientA] -> cationBlankGradientA,
		Replace[CationBlankGradientB] -> cationBlankGradientB,
		Replace[CationBlankGradientC] -> cationBlankGradientC,
		Replace[CationBlankGradientD] -> cationBlankGradientD,
		Replace[CationBlankFlowRate] -> cationBlankFlowRates,
		Replace[CationBlankGradientMethods] -> If[Length[cationBlankPositions] > 0,
			Gradient /. First[Flatten[DeleteDuplicates[Cases[cationInjectionTableUploadable, KeyValuePattern[Sample -> #]]]]& /@ ToList[linkedCationBlankResources]],
			Null
		],
		Replace[CationBlankSuppressorMode] -> cationBlankSuppressorModes,
		Replace[CationBlankSuppressorVoltage] -> cationBlankSuppressorVoltages,
		Replace[CationBlankSuppressorCurrent] -> cationBlankSuppressorCurrents,
		Replace[CationBlankDetectionTemperature] -> cationBlankDetectionTemperatures /. {Ambient -> 25 Celsius},

		CationSystemPrimeGradient -> If[cationChannelRequiredQ, Link[cationSystemPrimeGradientMethod], Null],

		Replace[CationColumnPrimeGradientA] -> cationColumnPrimeGradientA,
		Replace[CationColumnPrimeGradientB] -> cationColumnPrimeGradientB,
		Replace[CationColumnPrimeGradientC] -> cationColumnPrimeGradientC,
		Replace[CationColumnPrimeGradientD] -> cationColumnPrimeGradientD,
		Replace[CationColumnPrimeGradients] -> If[Length[cationColumnPrimePositions] > 0, cationInjectionTableWithLinks[[cationColumnPrimePositions, 5]], Null],
		CationColumnPrimeTemperature -> (If[Length[cationColumnPrimePositions] > 0, ((cationInjectionTableColumnTempFull[[cationColumnPrimePositions, 7]][[1]]) /. {Ambient -> 25 Celsius}), Null]),
		CationColumnPrimeSuppressorMode -> If[!NullQ[cationColumnPrimeSuppressorModes], cationColumnPrimeSuppressorModes[[1]], Null],
		CationColumnPrimeSuppressorVoltage -> If[!NullQ[cationColumnPrimeSuppressorVoltages], cationColumnPrimeSuppressorVoltages[[1]], Null],
		CationColumnPrimeSuppressorCurrent -> If[!NullQ[cationColumnPrimeSuppressorCurrents], cationColumnPrimeSuppressorCurrents[[1]], Null],
		CationColumnPrimeDetectionTemperature -> If[!NullQ[cationColumnPrimeDetectionTemperatures], cationColumnPrimeDetectionTemperatures[[1]] /. {Ambient -> 25 Celsius}, Null],

		Replace[CationColumnFlushGradientA] -> cationColumnFlushGradientA,
		Replace[CationColumnFlushGradientB] -> cationColumnFlushGradientB,
		Replace[CationColumnFlushGradientC] -> cationColumnFlushGradientC,
		Replace[CationColumnFlushGradientD] -> cationColumnFlushGradientD,
		Replace[CationColumnFlushGradients] -> If[Length[cationColumnFlushPositions] > 0, cationInjectionTableWithLinks[[cationColumnFlushPositions, 5]], Null],
		CationColumnFlushTemperature -> (If[Length[cationColumnFlushPositions] > 0, ((cationInjectionTableColumnTempFull[[cationColumnFlushPositions, 7]][[1]]) /. {Ambient -> 25 Celsius}), Null]),
		Replace[CationColumnFlushSuppressorMode] -> If[!NullQ[cationColumnFlushSuppressorModes], cationColumnFlushSuppressorModes[[1]], Null],
		Replace[CationColumnFlushSuppressorVoltage] -> If[!NullQ[cationColumnFlushSuppressorVoltages], cationColumnFlushSuppressorVoltages[[1]], Null],
		Replace[CationColumnFlushSuppressorCurrent] -> If[!NullQ[cationColumnFlushSuppressorCurrents], cationColumnFlushSuppressorCurrents[[1]], Null],
		Replace[CationColumnFlushDetectionTemperature] -> If[!NullQ[cationColumnFlushDetectionTemperatures], cationColumnFlushDetectionTemperatures[[1]] /. {Ambient -> 25 Celsius}, Null],

		CationSystemFlushGradient -> If[cationChannelRequiredQ, Link[cationSystemFlushGradientMethod], Null],

		CationInitialPressureLowerLimit -> If[cationChannelRequiredQ, 0 PSI, Null],
		CationInitialPressureUpperLimit -> If[cationChannelRequiredQ, 5000 PSI, Null],


		(* === Electrochemical rreplated options === *)
		Column -> Link[columnResource],
		GuardColumn -> Link[guardColumnResource],
		Replace[Detectors] -> Lookup[myResolvedOptions, Detector],
		Replace[GradientA] -> gradientA,
		Replace[GradientB] -> gradientB,
		Replace[GradientC] -> gradientC,
		Replace[GradientD] -> gradientD,
		Replace[GradientMethods] -> If[MatchQ[electrochemicalInjectionTable, {} | Null | {Null}],
			Null,
			electrochemicalInjectionTableWithLinks[[samplePositions, 4]]
		],
		Replace[FlowRate] -> flowRates,
		Replace[ColumnTemperature] -> Cases[electrochemicalInjectionTableColumnTempFull, {Sample, ___}][[All, 6]] /. {Ambient -> 25 Celsius},
		Replace[SampleVolumes] -> If[Length[samplePositions] > 0,
			InjectionVolume /. Flatten[DeleteDuplicates[Cases[electrochemicalInjectionTableUploadable, KeyValuePattern[Sample -> #]]]& /@ ToList[linkedSampleResources]],
			Null
		],
		Replace[AbsorbanceWavelength] -> absorbanceWavelength,
		Replace[AbsorbanceSamplingRate] -> absorbanceSamplingRate,
		Replace[ElectrochemicalDetectionMode] -> electrochemicalDetectionMode,
		Replace[WorkingElectrode] -> Link[workingElectrodeResource],
		Replace[WorkingElectrodeStorageCondition] -> Lookup[myResolvedOptions, WorkingElectrodeStorageCondition],
		Replace[ReferenceElectrode] -> Link[referenceElectrode],
		Replace[ReferenceElectrodeMode] -> referenceElectrodeMode,
		Replace[VoltageProfile] -> voltageProfile,
		Replace[WaveformProfile] -> waveforms,
		Replace[WaveformObjects] -> DeleteDuplicates[waveformObjects],
		Replace[ElectrochemicalSamplingRate] -> electrochemicalSamplingRate,
		Replace[DetectionTemperature] -> detectionTemperatures /. {Ambient -> 25 Celsius},
		pHCalibration -> Lookup[myResolvedOptions, pHCalibration],
		Replace[NeutralpHCalibrationBuffer] -> Link[neutralpHCalibrationBufferResource],
		Replace[SecondarypHCalibrationBuffer] -> Link[secondarypHCalibrationBufferResource],
		Replace[SecondarypHCalibrationBufferTarget] -> Lookup[myResolvedOptions, SecondarypHCalibrationBufferTarget, Null],
		Replace[ElectrochemicalInjectionTable] -> electrochemicalInjectionTableUploadable,

		Replace[StandardColumnTemperature] -> standardColumnTemperatures /. {Ambient -> 25 Celsius},
		Replace[StandardSampleVolumes] -> If[Length[standardPositions] > 0,
			InjectionVolume /. First[Flatten[DeleteDuplicates[Cases[electrochemicalInjectionTableUploadable, KeyValuePattern[Sample -> #]]]]& /@ ToList[linkedStandardResources]],
			Null
		],
		Replace[StandardGradientA] -> standardGradientA,
		Replace[StandardGradientB] -> standardGradientB,
		Replace[StandardGradientC] -> standardGradientC,
		Replace[StandardGradientD] -> standardGradientD,
		Replace[StandardFlowRate] -> standardFlowRates,
		Replace[StandardGradientMethods] -> If[Length[standardPositions] > 0,
			Gradient /. First[Flatten[DeleteDuplicates[Cases[electrochemicalInjectionTableUploadable, KeyValuePattern[Sample -> #]]]]& /@ ToList[linkedStandardResources]],
			Null
		],
		Replace[StandardAbsorbanceWavelength] -> standardAbsorbanceWavelength,
		Replace[StandardAbsorbanceSamplingRate] -> standardAbsorbanceSamplingRate,
		Replace[StandardElectrochemicalDetectionMode] -> standardElectrochemicalDetectionMode,
		Replace[StandardReferenceElectrodeMode] -> standardReferenceElectrodeMode,
		Replace[StandardVoltageProfile] -> standardVoltageProfile,
		Replace[StandardWaveformProfile] -> standardWaveforms,
		Replace[StandardWaveformObjects] -> DeleteDuplicates[standardWaveformObjects],
		Replace[StandardElectrochemicalSamplingRate] -> standardElectrochemicalSamplingRate,
		Replace[StandardDetectionTemperature] -> standardDetectionTemperatures /. {Ambient -> 25 Celsius},

		Replace[BlankColumnTemperature] -> blankColumnTemperatures /. {Ambient -> 25 Celsius},
		Replace[BlankSampleVolumes] -> If[Length[blankPositions] > 0,
			InjectionVolume /. First[Flatten[DeleteDuplicates[Cases[electrochemicalInjectionTableUploadable, KeyValuePattern[Sample -> #]]]]& /@ ToList[linkedBlankResources]],
			Null
		],
		Replace[BlankGradientA] -> blankGradientA,
		Replace[BlankGradientB] -> blankGradientB,
		Replace[BlankGradientC] -> blankGradientC,
		Replace[BlankGradientD] -> blankGradientD,
		Replace[BlankFlowRate] -> blankFlowRates,
		Replace[BlankGradientMethods] -> If[Length[blankPositions] > 0,
			Gradient /. First[Flatten[DeleteDuplicates[Cases[electrochemicalInjectionTableUploadable, KeyValuePattern[Sample -> #]]]]& /@ ToList[linkedBlankResources]],
			Null
		],
		Replace[BlankAbsorbanceWavelength] -> blankAbsorbanceWavelength,
		Replace[BlankAbsorbanceSamplingRate] -> blankAbsorbanceSamplingRate,
		Replace[BlankElectrochemicalDetectionMode] -> blankElectrochemicalDetectionMode,
		Replace[BlankReferenceElectrodeMode] -> blankReferenceElectrodeMode,
		Replace[BlankVoltageProfile] -> blankVoltageProfile,
		Replace[BlankWaveformProfile] -> blankWaveforms,
		Replace[BlankWaveformObjects] -> DeleteDuplicates[blankWaveformObjects],
		Replace[BlankElectrochemicalSamplingRate] -> blankElectrochemicalSamplingRate,
		Replace[BlankDetectionTemperature] -> blankDetectionTemperatures /. {Ambient -> 25 Celsius},

		SystemPrimeGradient -> If[electrochemicalChannelRequiredQ, Link[systemPrimeGradientMethod], Null],

		Replace[ColumnPrimeGradientA] -> columnPrimeGradientA,
		Replace[ColumnPrimeGradientB] -> columnPrimeGradientB,
		Replace[ColumnPrimeGradientC] -> columnPrimeGradientC,
		Replace[ColumnPrimeGradientD] -> columnPrimeGradientD,
		Replace[ColumnPrimeGradients] -> If[Length[columnPrimePositions] > 0, electrochemicalInjectionTableWithLinks[[columnPrimePositions, 4]], Null],
		ColumnPrimeTemperature -> (If[Length[columnPrimePositions] > 0, ((electrochemicalInjectionTableColumnTempFull[[columnPrimePositions, 6]][[1]]) /. {Ambient -> 25 Celsius}), Null]),
		Replace[ColumnPrimeAbsorbanceWavelength] -> columnPrimeAbsorbanceWavelength,
		Replace[ColumnPrimeAbsorbanceSamplingRate] -> columnPrimeAbsorbanceSamplingRate,
		Replace[ColumnPrimeElectrochemicalDetectionMode] -> columnPrimeElectrochemicalDetectionMode,
		Replace[ColumnPrimeReferenceElectrodeMode] -> columnPrimeReferenceElectrodeMode,
		Replace[ColumnPrimeVoltageProfile] -> columnPrimeVoltageProfile,
		Replace[ColumnPrimeWaveformProfile] -> columnPrimeWaveforms,
		Replace[ColumnPrimeWaveformObjects] -> DeleteDuplicates[columnPrimeWaveformObjects],
		Replace[ColumnPrimeElectrochemicalSamplingRate] -> columnPrimeElectrochemicalSamplingRate,
		Replace[ColumnPrimeDetectionTemperature] -> columnPrimeDetectionTemperatures /. {Ambient -> 25 Celsius},

		Replace[ColumnFlushGradientA] -> columnFlushGradientA,
		Replace[ColumnFlushGradientB] -> columnFlushGradientB,
		Replace[ColumnFlushGradientC] -> columnFlushGradientC,
		Replace[ColumnFlushGradientD] -> columnFlushGradientD,
		Replace[ColumnFlushGradients] -> If[Length[columnFlushPositions] > 0, electrochemicalInjectionTableWithLinks[[columnFlushPositions, 4]], Null],
		ColumnFlushTemperature -> (If[Length[columnFlushPositions] > 0, ((electrochemicalInjectionTableColumnTempFull[[columnFlushPositions, 6]][[1]]) /. {Ambient -> 25 Celsius}), Null]),
		Replace[ColumnFlushAbsorbanceWavelength] -> columnFlushAbsorbanceWavelength,
		Replace[ColumnFlushAbsorbanceSamplingRate] -> columnFlushAbsorbanceSamplingRate,
		Replace[ColumnFlushElectrochemicalDetectionMode] -> columnFlushElectrochemicalDetectionMode,
		Replace[ColumnFlushReferenceElectrodeMode] -> columnFlushReferenceElectrodeMode,
		Replace[ColumnFlushVoltageProfile] -> columnFlushVoltageProfile,
		Replace[ColumnFlushWaveformProfile] -> columnFlushWaveforms,
		Replace[ColumnFlushWaveformObjects] -> DeleteDuplicates[columnFlushWaveformObjects],
		Replace[ColumnFlushElectrochemicalSamplingRate] -> columnFlushElectrochemicalSamplingRate,
		Replace[ColumnFlushDetectionTemperature] -> columnFlushDetectionTemperatures /. {Ambient -> 25 Celsius},

		SystemFlushGradient -> If[electrochemicalChannelRequiredQ, Link[systemFlushGradientMethod], Null],

		InitialPressureLowerLimit -> If[electrochemicalChannelRequiredQ, 0 PSI, Null],
		InitialPressureUpperLimit -> If[electrochemicalChannelRequiredQ, 4800 PSI, Null],

		Replace[Checkpoints] -> {
			{"Picking Resources", 1 Hour, "Buffers and columns required to run Ion Chromatography experiments are gathered.", Link[Resource[Operator -> $BaselineOperator, Time -> 1 Hour]]},
			{"Purging Instrument", 3 Hour, "System priming buffers are connected to an Ion Chromatography instrument and the instrument's buffer lines, needle and pump seals are purged at a high flow rates.", Link[Resource[Operator -> $BaselineOperator, Time -> 3 Hour]]},
			{"Preparing Instrument", 90 Minute, "An instrument is configured for the protocol.", Link[Resource[Operator -> $BaselineOperator, Time -> 90 Minute]]},
			{"Running Samples", totalRunTime, "Samples are injected onto an Ion Chromatography and subject to buffer gradients.", Link[Resource[Operator -> $BaselineOperator, Time -> totalRunTime]]},
			{"Sample Post-Processing", 1 Hour, "Any measuring of volume, weight, or sample imaging post experiment is performed.", Link[Resource[Operator -> $BaselineOperator, Time -> 1 Hour]]},
			{"Flushing Instrument", 2 Hour, "Buffers are connected to an Ion Chromatography instrument and the instrument is flushed with each buffer at a high flow rate.", Link[Resource[Operator -> $BaselineOperator, Time -> 2 Hour]]},
			{"Exporting Data", 20 Minute, "Acquired chromatography data is exported.", Link[Resource[Operator -> $BaselineOperator, Time -> 20 Minute]]},
			{"Returning Materials", 15 Minute, "Samples are returned to storage.", Link[Resource[Operator -> $BaselineOperator, Time -> 15 Minute]]}
		}
	|>;

	(* Expand the resolved options if they weren't expanded already *)
	unCollapsedResolvedOptions = Last[ExpandIndexMatchedInputs[ExperimentIonChromatography, {mySamples}, myResolvedOptions]];

	(* generate a packet with the shared fields *)
	sharedFieldPacket = populateSamplePrepFields[mySamples, myResolvedOptions, Cache -> inheritedCache];

	(* Merge the shared fields with the specific fields *)
	finalizedPacket = Join[sharedFieldPacket, protocolPacket];

	(* Return all generated packets *)
	allPackets = Join[
		{finalizedPacket},
		ToList@uniqueAnionGradientPackets,
		ToList@uniqueCationGradientPackets,
		ToList@uniqueGradientPackets,
		ToList@uniqueWaveformPackets
	];

	(* get all the resource symbolic representations *)
	(* need to pull these at infinite depth because otherwise all resources with Link wrapped around them won't be grabbed *)
	allResourceBlobs = DeleteDuplicates[Cases[Flatten[Values[finalizedPacket]], _Resource, Infinity]];

	(* call fulfillableResourceQ on all the resources we created *)
	{fulfillable, frqTests} = Which[
		MatchQ[$ECLApplication, Engine], {True, {}},
		gatherTests, Resources`Private`fulfillableResourceQ[allResourceBlobs, Output -> {Result, Tests}, FastTrack -> Lookup[myResolvedOptions, FastTrack], Site -> Lookup[myResolvedOptions, Site], Cache -> inheritedCache, Simulation -> Simulation[inheritedCache]],
		True, {Resources`Private`fulfillableResourceQ[allResourceBlobs, FastTrack -> Lookup[myResolvedOptions, FastTrack], Site -> Lookup[myResolvedOptions, Site], Messages -> messages, Cache -> inheritedCache, Simulation -> Simulation[inheritedCache]], Null}
	];

	(* generate the tests rule *)
	testsRule = Tests -> If[gatherTests,
		frqTests,
		Null
	];

	(* generate the Result output rule *)
	(* if not returning Result, or the resources are not fulfillable, Results rule is just $Failed *)
	resultRule = Result -> If[MemberQ[output, Result] && TrueQ[fulfillable],
		allPackets,
		$Failed
	];

	(* return the output as we desire it *)
	outputSpecification /. {resultRule, testsRule}
];


(* ::Subsubsection:: *)
(*resolveICAnionGradient*)


anionGradientP := {{TimeP, ConcentrationP, FlowRateP}...};

(* If AnionGradientStart and AnionGradientEnd are not specified, fill them in with Nulls and pass ont resolveICAnionGradient helper function *)
resolveICAnionGradient[myGradientValue : (Automatic | anionGradientP | Null), myEluentGradientValue : (Null | Automatic | {{TimeP, ConcentrationP}..} | ConcentrationP),
	myFlowRateValue : ({{TimeP, FlowRateP}..} | FlowRateP), myGradientDuration : (TimeP | Null)] :=
	resolveICAnionGradient[myGradientValue, myEluentGradientValue, myFlowRateValue, Null, Null, myGradientDuration];

resolveICAnionGradient[myGradientValue : (Automatic | anionGradientP | Null), myEluentGradientValue : (Null | Automatic | {{TimeP, ConcentrationP}..} | ConcentrationP),
	myFlowRateValue : ({{TimeP, FlowRateP}..} | FlowRateP), myGradientStart : (ConcentrationP | Null), myGradientEnd : (ConcentrationP | Null), myGradientDuration : (TimeP | Null)] :=
	Module[{eluentGradientTimepoints, flowRateTimepoints, eluentGradientSpecifiedTimes, flowRateSpecifiedTimes, minEluentTime, maxEluentTime, minFlowRateTime, maxFlowRateTime,
		specifiedTimes, maxTime, minTime, interpolationTimepointsEluent, interpolatedEluentGradientLookup, compositionTuples, protoCompositionTuples, allCompositionTuples,
		allTimes, protoFlowRateTuples, allFlowRates},

		(* If a full gradient is specified, use that gradient *)
		If[MatchQ[myGradientValue, anionGradientP],
			Return[myGradientValue]
		];

		eluentGradientTimepoints = Switch[myEluentGradientValue,

			(* If timepoints are specified, use them *)
			{{TimeP, ConcentrationP}...}, myEluentGradientValue,

			(* If a single isocratic percent is specified, build gradient as a constant percentage from 0 min to gradient duration *)
			ConcentrationP,
			{
				{0. Minute, myEluentGradientValue},
				(* If AnionGradientDuration is Null, then default to 0 min (full EluentGradient will be expanded below to the max time) *)
				If[NullQ[myGradientDuration],
					Nothing,
					{myGradientDuration, myEluentGradientValue}
				]
			},

			_,
			(* If Gradient option is specified, inherit EluentGradient from its value *)
			Switch[myGradientValue,

				(* If gradient tuples are specified, take the first index (time) and second (eluent concentration) *)
				anionGradientP,
				myGradientValue[[All, {1, 2}]],

				_,
				(* If start/end/duration is specified, they specify eluent concentration, fill it into EluentGradient *)
				If[MatchQ[myGradientStart, ConcentrationP],
					{
						{0. Minute, myGradientStart},

						(* If AnionGradientDuration is Null, then default to 0 min (full EluentGradient will be expanded below to the max time)*)
						If[NullQ[myGradientDuration],
							Nothing,
							{myGradientDuration, myGradientEnd}
						]
					},
					(* If nothing is specified, eluent generated in the flow path is not used *)
					{}
				]
			]
		];

		flowRateTimepoints = Switch[myFlowRateValue,

			(* If timepoints are specified, use them *)
			{{TimeP, FlowRateP}...}, myFlowRateValue,

			(* If a single value then we create the time *)
			FlowRateP,
			{
				{0. Minute, myFlowRateValue},
				(* If GradientDuration is Null, then default to 0 min
                (full flowrate will be expanded below to the max time)*)
				If[NullQ[myGradientDuration],
					Nothing,
					{myGradientDuration, myFlowRateValue}
				]
			},
			_,

			(* If Gradient option is specified, inherit flow rate from its value *)
			Switch[myGradientValue,
				(* If gradient tuples are specified, take the first index (time) and last index for the flow rate *)
				anionGradientP,
				myGradientValue[[All, {1, 3}]],
				_,
				(* If nothing is specified, flowrate is not used *)
				{}
			]
		];

		(* Fetch the times explicitly specified for each option *)
		eluentGradientSpecifiedTimes = DeleteDuplicates[Sort[Convert[eluentGradientTimepoints[[All, 1]], Minute]], (#1 == #2)&];
		flowRateSpecifiedTimes = DeleteDuplicates[Sort[Convert[flowRateTimepoints[[All, 1]], Minute]], (#1 == #2)&];

		(* Extract the min and max times (the time domain specified) *)
		{minEluentTime, maxEluentTime} = {Min[eluentGradientSpecifiedTimes], Max[eluentGradientSpecifiedTimes]};
		{minFlowRateTime, maxFlowRateTime} = {Min[flowRateSpecifiedTimes], Max[flowRateSpecifiedTimes]};

		(* Get all specified times (such that we can interpolate values for all times) *)
		specifiedTimes = DeleteDuplicates[
			Sort[
				Convert[
					Join[
						eluentGradientSpecifiedTimes,
						flowRateSpecifiedTimes
					],
					Minute
				]
			],
			(* Use == for the case where equivalent numbers like 0 and 0. are compared *)
			(#1 == #2)&
		];

		(* Fetch final time *)
		maxTime = Max[specifiedTimes];

		(* Fetch initial time *)
		minTime = Min[specifiedTimes];

		(* Find all the specified times within the time domain (these times we will interpolate to find the value of) *)
		interpolationTimepointsEluent = Cases[specifiedTimes, RangeP[minEluentTime, maxEluentTime]];

		(* Interpolate points that are not specified for EluentGradient *)
		interpolatedEluentGradientLookup = AssociationThread[interpolationTimepointsEluent -> getInterpolationValuesForTimesExperimentIC[eluentGradientTimepoints, interpolationTimepointsEluent]];

		(* Build tuples of eluent concentration for each specified time *)
		compositionTuples = Map[
			Function[time,
				Module[
					{eluentGradientValue, defaultedCompositionTuple},

					(* Fetch value for each gradient at the current time. If the value is not specified, it means the timepoint is outside the gradient's specified range *)
					eluentGradientValue = Lookup[interpolatedEluentGradientLookup, time, Null];

					(* By default, set the gradient composition outside the specified range to 0 *)
					defaultedCompositionTuple = Replace[{eluentGradientValue}, Null -> 0 Millimolar, {1}];

					(* Add time to first index of gradient timepoint *)
					Prepend[defaultedCompositionTuple, time]
				]
			],
			specifiedTimes
		];

		(* If the minimum specified time is not 0 min, then extend the composition at the minimum time to 0 min *)
		protoCompositionTuples = If[minTime != 0 Minute,
			Prepend[
				compositionTuples,
				ReplacePart[First[compositionTuples], 1 -> 0 Minute]
			],
			compositionTuples
		];

		(*if the composition tuples is still insufficient, tack on 10 minutes*)
		allCompositionTuples = If[Length[protoCompositionTuples] > 1,
			protoCompositionTuples,
			Append[
				protoCompositionTuples,
				ReplacePart[First[compositionTuples], 1 -> 10 Minute]
			]
		];

		(* Fetch all times for FlowRate interpolation *)
		allTimes = allCompositionTuples[[All, 1]];

		(* If the flowrate is a constant value, set same flow rate to all timepoints. Otherwise, like the gradients above, interpolate its value and append the final timepoint *)
		allFlowRates = If[MatchQ[myFlowRateValue, FlowRateP],
			Table[myFlowRateValue, Length[allTimes]],
			getInterpolationValuesForTimes[
				flowRateTimepoints,
				allTimes
			]
		];

		MapThread[
			Append,
			{allCompositionTuples, allFlowRates}
		]
	];


cationGradientP := {{TimeP, PercentP, PercentP, PercentP, PercentP, FlowRateP}...} | {{TimeP, PercentP, PercentP, PercentP, PercentP, PercentP, PercentP, PercentP, PercentP, FlowRateP}...};

(* If CationGradientStart and CationGradientEnd are not specified, fill them in with Nulls and pass ont resolveICCationGradient helper function *)
resolveICCationGradient[myGradientValue : (Automatic | cationGradientP | Null), myGradientAValue : (Null | Automatic | {{TimeP, PercentP}..} | PercentP), myGradientBValue : (Null | Automatic | {{TimeP, PercentP}..} | PercentP),
	myGradientCValue : (Null | Automatic | {{TimeP, PercentP}..} | PercentP), myGradientDValue : (Null | Automatic | {{TimeP, PercentP}..} | PercentP), myFlowRateValue : ({{TimeP, FlowRateP}..} | FlowRateP), myGradientDuration : (TimeP | Null)] :=
	resolveICCationGradient[myGradientValue, myGradientAValue, myGradientBValue, myGradientCValue, myGradientDValue, myFlowRateValue, Null, Null, myGradientDuration];

resolveICCationGradient[myGradientValue : (Automatic | cationGradientP | Null), myGradientAValue : (Null | Automatic | {{TimeP, PercentP}..} | PercentP), myGradientBValue : (Null | Automatic | {{TimeP, PercentP}..} | PercentP),
	myGradientCValue : (Null | Automatic | {{TimeP, PercentP}..} | PercentP), myGradientDValue : (Null | Automatic | {{TimeP, PercentP}..} | PercentP), myFlowRateValue : ({{TimeP, FlowRateP}..} | FlowRateP),
	myGradientStart : (PercentP | Null), myGradientEnd : (PercentP | Null), myGradientDuration : (TimeP | Null)] :=
	Module[{gradientATimepoints, gradientBTimepoints, gradientCTimepoints, gradientDTimepoints, flowRateTimepoints, gradientASpecifiedTimes, gradientBSpecifiedTimes, gradientCSpecifiedTimes,
		gradientDSpecifiedTimes, flowRateSpecifiedTimes, minATime, maxATime, minBTime, maxBTime, minCTime, maxCTime, minDTime, maxDTime, specifiedTimes, minTime, maxTime, interpolationTimepointsA,
		interpolationTimepointsB, interpolationTimepointsC, interpolationTimepointsD, interpolatedGradientALookup, interpolatedGradientBLookup, interpolatedGradientCLookup,
		interpolatedGradientDLookup, compositionTuples, protoCompositionTuples, allCompositionTuples, allTimes, allFlowRates, minFlowRateTime, maxFlowRateTime, interpolationTimepointsFlowRate,
		interpolatedFlowRateLookup},

		(* If a full gradient is specified, use that gradient *)
		If[MatchQ[myGradientValue, cationGradientP],
			Return[myGradientValue]
		];

		gradientATimepoints = Switch[myGradientAValue,

			(* If timepoints are specified, use them *)
			{{TimeP, PercentP}...}, myGradientAValue,

			(* If a single isocratic percent is specified, build gradient as a constant percentage from 0 min to gradient duration *)
			PercentP,
			{
				{0. Minute, myGradientAValue},
				(* If CationGradientDuration is Null, then default to 0 min (full GradientA will be expanded below to the max time) *)
				If[NullQ[myGradientDuration],
					Nothing,
					{myGradientDuration, myGradientAValue}
				]
			},

			_,
			(* If Gradient option is specified, inherit EluentGradient from its value *)
			Switch[myGradientValue,

				(* If gradient tuples are specified, take the first index (time) and second (Buffer A composition) *)
				cationGradientP,
				myGradientValue[[All, {1, 2}]],

				_,
				(* If start/end/duration is specified, they specify eluent concentration, fill it into EluentGradient *)
				If[MatchQ[myGradientStart, PercentP],
					{
						{0. Minute, 100 Percent - myGradientStart},

						(* If CationGradientDuration is Null, then default to 0 min (full Gradient will be expanded below to the max time)*)
						If[NullQ[myGradientDuration],
							Nothing,
							{myGradientDuration, 100 Percent - myGradientEnd}
						]
					},
					(* If nothing is specified, BufferA is not used *)
					{}
				]
			]
		];

		gradientBTimepoints = Switch[myGradientBValue,

			(* If timepoints are specified, use them *)
			{{TimeP, PercentP}...}, myGradientBValue,

			(* If a single isocratic percent is specified, build gradient as a constant percentage from 0 min to gradient duration *)
			PercentP,
			{
				{0. Minute, myGradientBValue},
				(* If GradientDuration is Null, then default to 0 min (full GradientB will be expanded below to the max time)*)
				If[NullQ[myGradientDuration],
					Nothing,
					{myGradientDuration, myGradientBValue}
				]
			},
			_,
			(* If Gradient option is specified, inherit GradientB from its value *)
			Switch[myGradientValue,
				(* If gradient tuples are specified, take the first index (time) and third (buffer B %) *)
				cationGradientP,
				myGradientValue[[All, {1, 3}]],
				_,
				(* If start/end/duration is specified, they specify buffer B composition *)
				If[MatchQ[myGradientStart, PercentP],
					{
						{0. Minute, myGradientStart},

						(* If GradientDuration is Null, then default to 0 min (full GradientA will be expanded below to the max time)*)
						If[NullQ[myGradientDuration],
							Nothing,
							{myGradientDuration, myGradientEnd}
						]
					},
					(* If nothing is specified, BufferB is not used *)
					{}
				]
			]
		];

		gradientCTimepoints = Switch[myGradientCValue,

			(* If timepoints are specified, use them *)
			{{TimeP, PercentP}...}, myGradientCValue,

			(* If a single isocratic percent is specified, build gradient as a constant percentage from 0 min to gradient duration *)
			PercentP,
			{
				{0. Minute, myGradientCValue},
				(* If GradientDuration is Null, then default to 0 min (full GradientB will be expanded below to the max time)*)
				If[NullQ[myGradientDuration],
					Nothing,
					{myGradientDuration, myGradientCValue}
				]
			},
			_,
			(* If Gradient option is specified, inherit GradientB from its value *)
			Switch[myGradientValue,
				(* If gradient tuples are specified, take the first index (time) and third (buffer B %) *)
				cationGradientP,
				myGradientValue[[All, {1, 4}]],

				_,
				{}
			]
		];

		gradientDTimepoints = Switch[myGradientDValue,

			(* If timepoints are specified, use them *)
			{{TimeP, PercentP}...}, myGradientDValue,

			(* If a single isocratic percent is specified, build gradient as a constant percentage from 0 min to gradient duration *)
			PercentP,
			{
				{0. Minute, myGradientDValue},
				(* If GradientDuration is Null, then default to 0 min (full GradientB will be expanded below to the max time)*)
				If[NullQ[myGradientDuration],
					Nothing,
					{myGradientDuration, myGradientDValue}
				]
			},
			_,
			(* If Gradient option is specified, inherit GradientB from its value *)
			Switch[myGradientValue,
				(* If gradient tuples are specified, take the first index (time) and third (buffer B %) *)
				cationGradientP,
				myGradientValue[[All, {1, 5}]],
				_,
				{}
			]
		];

		flowRateTimepoints = Switch[myFlowRateValue,

			(* If timepoints are specified, use them *)
			{{TimeP, FlowRateP}...}, myFlowRateValue,

			(* If a single value then we create the time *)
			FlowRateP,
			{
				{0. Minute, myFlowRateValue},
				(* If GradientDuration is Null, then default to 0 min
                (full flowrate will be expanded below to the max time)*)
				If[NullQ[myGradientDuration],
					Nothing,
					{myGradientDuration, myFlowRateValue}
				]
			},
			_,

			(* If Gradient option is specified, inherit flow rate from its value *)
			Switch[myGradientValue,
				(* If gradient tuples are specified, take the first index (time) and last index for the flow rate *)
				cationGradientP,
				myGradientValue[[All, {1, 6}]],
				_,
				(* If nothing is specified, flowrate is not used *)
				{}
			]
		];

		(* Fetch the times explicitly specified for each option *)
		gradientASpecifiedTimes = DeleteDuplicates[Sort[Convert[gradientATimepoints[[All, 1]], Minute]], (#1 == #2)&];
		gradientBSpecifiedTimes = DeleteDuplicates[Sort[Convert[gradientBTimepoints[[All, 1]], Minute]], (#1 == #2)&];
		gradientCSpecifiedTimes = DeleteDuplicates[Sort[Convert[gradientCTimepoints[[All, 1]], Minute]], (#1 == #2)&];
		gradientDSpecifiedTimes = DeleteDuplicates[Sort[Convert[gradientDTimepoints[[All, 1]], Minute]], (#1 == #2)&];
		flowRateSpecifiedTimes = DeleteDuplicates[Sort[Convert[flowRateTimepoints[[All, 1]], Minute]], (#1 == #2)&];

		(* Extract the min and max times (the doman specified) *)
		{minATime, maxATime} = {Min[gradientASpecifiedTimes], Max[gradientASpecifiedTimes]};
		{minBTime, maxBTime} = {Min[gradientBSpecifiedTimes], Max[gradientBSpecifiedTimes]};
		{minCTime, maxCTime} = {Min[gradientCSpecifiedTimes], Max[gradientCSpecifiedTimes]};
		{minDTime, maxDTime} = {Min[gradientDSpecifiedTimes], Max[gradientDSpecifiedTimes]};
		{minFlowRateTime, maxFlowRateTime} = {Min[flowRateSpecifiedTimes], Max[flowRateSpecifiedTimes]};

		(* Get all specified times (such that we can interpolate values for all times) *)
		specifiedTimes = DeleteDuplicates[
			Sort[
				Convert[
					Join[
						gradientASpecifiedTimes,
						gradientBSpecifiedTimes,
						gradientCSpecifiedTimes,
						gradientDSpecifiedTimes,
						flowRateSpecifiedTimes
					],
					Minute
				]
			],
			(* Use == for the case where equivalent numbers like 0 and 0. are compared *)
			(#1 == #2)&
		];


		(* Fetch final time *)
		maxTime = Max[specifiedTimes];

		(* Fetch initial time *)
		minTime = Min[specifiedTimes];

		(* Find all the specified times within the domain for each buffer gradient (these times we will interpolate to find the value of) *)
		interpolationTimepointsA = Cases[specifiedTimes, RangeP[minATime, maxATime]];
		interpolationTimepointsB = Cases[specifiedTimes, RangeP[minBTime, maxBTime]];
		interpolationTimepointsC = Cases[specifiedTimes, RangeP[minCTime, maxCTime]];
		interpolationTimepointsD = Cases[specifiedTimes, RangeP[minDTime, maxDTime]];

		(* Interpolate points that are not specified for GradientA *)
		interpolatedGradientALookup = AssociationThread[interpolationTimepointsA -> getInterpolationValuesForTimes[gradientATimepoints, interpolationTimepointsA]];
		interpolatedGradientBLookup = AssociationThread[interpolationTimepointsB -> getInterpolationValuesForTimes[gradientBTimepoints, interpolationTimepointsB]];
		interpolatedGradientCLookup = AssociationThread[interpolationTimepointsC -> getInterpolationValuesForTimes[gradientCTimepoints, interpolationTimepointsC]];
		interpolatedGradientDLookup = AssociationThread[interpolationTimepointsD -> getInterpolationValuesForTimes[gradientDTimepoints, interpolationTimepointsD]];

		(* Build tuples of each buffer composition for each specified time in the form {%A,%B,%C,%D} *)
		compositionTuples = Map[
			Function[time,
				Module[
					{gradientAValue, gradientBValue, gradientCValue, gradientDValue, flowRateValue, defaultedCompositionTuple, totalComposition, bufferCompositions},

					(* Fetch value for each gradient at the current time. If the value is not specified, it means the timepoint is outside the gradient's specified range *)
					gradientAValue = Lookup[interpolatedGradientALookup, time, Null];
					gradientBValue = Lookup[interpolatedGradientBLookup, time, Null];
					gradientCValue = Lookup[interpolatedGradientCLookup, time, Null];
					gradientDValue = Lookup[interpolatedGradientDLookup, time, Null];

					(* By default, set the gradient composition outside the specified range to 0 *)
					defaultedCompositionTuple = Replace[{gradientAValue, gradientBValue, gradientCValue, gradientDValue}, Null -> 0 Percent, {1}];

					(* Calculate the total specified composition (ie: the summed percentages for each gradient) *)
					totalComposition = Total[defaultedCompositionTuple];

					(* Decide how to default the gradient values (if needed) *)
					bufferCompositions = Which[
						(* If the composition at the current timepoint is already 100% then we don't need to fill in any extra composition.
                        If it is > 100% then the gradient specified is invalid and an error will be thrown downstream *)
						totalComposition >= 100 Percent,
						defaultedCompositionTuple,
						(* If the composition is < 100% then fill in the remaining composition with A *)
						NullQ[gradientAValue],
						ReplacePart[defaultedCompositionTuple, 1 -> (100 Percent - totalComposition)],
						NullQ[gradientBValue],
						ReplacePart[defaultedCompositionTuple, 2 -> (100 Percent - totalComposition)],
						NullQ[gradientCValue],
						ReplacePart[defaultedCompositionTuple, 3 -> (100 Percent - totalComposition)],
						NullQ[gradientDValue],
						ReplacePart[defaultedCompositionTuple, 4 -> (100 Percent - totalComposition)],

						(* Everything was specified and it still doesn't add to 100%  (in this case we throw error downstream) *)
						True,
						defaultedCompositionTuple
					];

					(* Add time to first index of gradient timepoint *)
					Prepend[bufferCompositions, time]
				]
			],
			specifiedTimes
		];

		(* If the minimum specified time is not 0 min, then extend the composition at the minimum time to 0 min *)
		protoCompositionTuples = If[minTime != 0 Minute,
			Prepend[
				compositionTuples,
				ReplacePart[First[compositionTuples], 1 -> 0 Minute]
			],
			compositionTuples
		];

		(*if the composition tuples is still insufficient, tack on 10 minutes*)
		allCompositionTuples = If[Length[protoCompositionTuples] > 1,
			protoCompositionTuples,
			Append[
				protoCompositionTuples,
				ReplacePart[First[compositionTuples], 1 -> 10 Minute]
			]
		];

		(* Fetch all times for FlowRate interpolation *)
		allTimes = allCompositionTuples[[All, 1]];

		(* If the flowrate is a constant value, set same flow rate to all timepoints. Otherwise, like the gradients above, interpolate its value and append the final timepoint *)
		allFlowRates = If[MatchQ[myFlowRateValue, FlowRateP],
			Table[myFlowRateValue, Length[allTimes]],
			getInterpolationValuesForTimes[
				flowRateTimepoints,
				allTimes
			]
		];

		MapThread[
			Append,
			{allCompositionTuples, allFlowRates}
		]
	];

(* NOTE: This only works if the times are in Minutes *)
(* These two helper functions are already in HPLC experiment. No need to include here again *)
(* Some learning notes:

(* This function creates an interpolation given a list of tuples in the form {Time, Eluent Concentration} *)
(* For example, if Interpolation[{{1 Minute, 1 Millimolar},{5 Minute, 5 Millimoar}}] is run, it should be able to compute {3 Minute, 3 Millimolar} *)
interpolationFunctionForGradient=Function[
	gradient,
	Interpolation[gradient,InterpolationOrder->1]
];

(* This function cleans up the interpolated gradient tuples *)
interpolatedPointsForTimes[times_]:=Function[

	(* The input interpolationFunction is here should be the output of the previous helper function, with Interpolation run on the list of Gradient tuples already *)
	interpolationFunction,
	Map[
		Function[

			(* Input of this function should be a list of time points where we are interpolating; ideally, this list of time points should be identical to the specified time points *)
			time,
			Which[

				(* If a given interpolating time point is outside the interpolation domain, set it to 0 + specified units of the gradient *)
				(* The output of the Interpolation function has something like "Domain":{{minTimePoint, maxTimePoint}} *)
				(* So First[First[interpolationFunction["Domain"]] extracts the minTimepoint; Last[First[interpolationFunction["Domain"]] extracts the maxTimepoint *)
				time < Quantity[First[First[interpolationFunction["Domain"]]], "Minutes"],
				0. Units@interpolationFunction[Quantity[First[First[interpolationFunction["Domain"]]], "Minutes"]],

				time > Quantity[Last[First[interpolationFunction["Domain"]]], "Minutes"],
				0. Units@interpolationFunction[Quantity[Last[First[interpolationFunction["Domain"]]], "Minutes"]],

				(* Otherwise, use the specified composition in the gradient *)
				True,
				interpolationFunction[time]
			]
		],
		times
	]
];
*)

(* NOTE: This only works if the times are in Minutes *)
getInterpolationValuesForTimesExperimentIC[{} | Null, times_] := Table[Quantity[0., "Millimolar"], {Length[times]}];
getInterpolationValuesForTimesExperimentIC[{{time : TimeP, composition : (ConcentrationP | PercentP | FlowRateP)}}, times_] := Table[composition, {Length[times]}];
(* RightComposition applies the first function to the input, then use the output of the first function as the input of the second function, so on *)
getInterpolationValuesForTimesExperimentIC[gradient_, times_] := RightComposition[
	interpolationFunctionForGradient,
	interpolatedPointsForTimes[times]
][gradient];


defaultAnionGradientIC[myDefaultFlowRate : FlowRateP] := {
	{Quantity[0., Minute], Quantity[10., Millimolar], myDefaultFlowRate},
	{Quantity[0.1, Minute], Quantity[10., Millimolar], myDefaultFlowRate},
	{Quantity[12., Minute], Quantity[22., Millimolar], myDefaultFlowRate},
	{Quantity[20., Minute], Quantity[50., Millimolar], myDefaultFlowRate},
	{Quantity[20.5, Minute], Quantity[50., Millimolar], myDefaultFlowRate},
	{Quantity[20.6, Minute], Quantity[10., Millimolar], myDefaultFlowRate},
	{Quantity[27., Minute], Quantity[10., Millimolar], myDefaultFlowRate}
};

defaultGradientIC[myChannelSelection_, myDefaultFlowRate : FlowRateP] := If[MemberQ[myChannelSelection, CationChannel],
	{
		{Quantity[0., Minute], Quantity[100., Percent], Quantity[0., Percent], Quantity[0., Percent], Quantity[0., Percent], myDefaultFlowRate},
		{Quantity[23., Minute], Quantity[60., Percent], Quantity[40., Percent], Quantity[0., Percent], Quantity[0., Percent], myDefaultFlowRate}
	},
	{
		{Quantity[0., Minute], Quantity[91., Percent], Quantity[9., Percent], Quantity[0., Percent], Quantity[0., Percent], myDefaultFlowRate},
		{Quantity[18., Minute], Quantity[91., Percent], Quantity[9., Percent], Quantity[0., Percent], Quantity[0., Percent], myDefaultFlowRate}
	}
];



defaultAnionPrimeGradientIC[myDefaultFlowRate : FlowRateP] := {
	{Quantity[0., Minute], Quantity[100., Millimolar], myDefaultFlowRate},
	{Quantity[5., Minute], Quantity[100., Millimolar], myDefaultFlowRate}
};


defaultCationPrimeGradientIC[myDefaultFlowRate : FlowRateP] := {
	{Quantity[0., Minute], Quantity[0., Percent], Quantity[0., Percent], Quantity[0., Percent], Quantity[100., Percent], myDefaultFlowRate},
	{Quantity[5., Minute], Quantity[0., Percent], Quantity[0., Percent], Quantity[0., Percent], Quantity[100., Percent], myDefaultFlowRate},
	{Quantity[5.1, Minute], Quantity[0., Percent], Quantity[0., Percent], Quantity[100., Percent], Quantity[0., Percent], myDefaultFlowRate},
	{Quantity[10, Minute], Quantity[0., Percent], Quantity[0., Percent], Quantity[100., Percent], Quantity[0., Percent], myDefaultFlowRate},
	{Quantity[10.1, Minute], Quantity[0., Percent], Quantity[100., Percent], Quantity[0., Percent], Quantity[0., Percent], myDefaultFlowRate},
	{Quantity[15, Minute], Quantity[0., Percent], Quantity[100., Percent], Quantity[0., Percent], Quantity[0., Percent], myDefaultFlowRate},
	{Quantity[15.1, Minute], Quantity[100., Percent], Quantity[0., Percent], Quantity[0., Percent], Quantity[0., Percent], myDefaultFlowRate},
	{Quantity[20, Minute], Quantity[100., Percent], Quantity[0., Percent], Quantity[0., Percent], Quantity[0., Percent], myDefaultFlowRate}
};

defaultAnionFlushGradientIC[myDefaultFlowRate : FlowRateP] := {
	{Quantity[0., Minute], Quantity[100., Millimolar], myDefaultFlowRate},
	{Quantity[5., Minute], Quantity[100., Millimolar], myDefaultFlowRate}
};

(* TODO: Adjust this to account for type (different prime for different conditions? *)
(* Below is the default for SizeExclusion *)
defaultCationFlushGradientIC[myDefaultFlowRate : FlowRateP] := {
	{Quantity[0., Minute], Quantity[0., Percent], Quantity[0., Percent], Quantity[0., Percent], Quantity[100., Percent], myDefaultFlowRate},
	{Quantity[5., Minute], Quantity[0., Percent], Quantity[0., Percent], Quantity[0., Percent], Quantity[100., Percent], myDefaultFlowRate},
	{Quantity[5.1, Minute], Quantity[0., Percent], Quantity[0., Percent], Quantity[100., Percent], Quantity[0., Percent], myDefaultFlowRate},
	{Quantity[10, Minute], Quantity[0., Percent], Quantity[0., Percent], Quantity[100., Percent], Quantity[0., Percent], myDefaultFlowRate},
	{Quantity[10.1, Minute], Quantity[0., Percent], Quantity[100., Percent], Quantity[0., Percent], Quantity[0., Percent], myDefaultFlowRate},
	{Quantity[15, Minute], Quantity[0., Percent], Quantity[100., Percent], Quantity[0., Percent], Quantity[0., Percent], myDefaultFlowRate},
	{Quantity[15.1, Minute], Quantity[100., Percent], Quantity[0., Percent], Quantity[0., Percent], Quantity[0., Percent], myDefaultFlowRate},
	{Quantity[20, Minute], Quantity[100., Percent], Quantity[0., Percent], Quantity[0., Percent], Quantity[0., Percent], myDefaultFlowRate}
};



(* ::Subsubsection:: *)
(*resolveICAnalysisChannel*)


resolveICAnalysisChannel[samples : ListableP[ObjectP[]] | Null | Automatic | {}, fullOptions_, mapThreadOptions_, sampleType_, analysisChannelOption_, anionOption_, cationOption_, cache_] := Module[
	{initiallyResolvedAnalysisChannel, anionInjectionTableLookupRounded, cationInjectionTableLookupRounded, anionInjectionTableSpecifiedQ, cationInjectionTableSpecifiedQ, anionLookup,
		cationLookup, injectionTableAnalysisChannel, analysisChannel, commonAnions, commonCations, sampleComponents, anionHits, anionNumberOfHits, cationHits, cationNumberOfHits,
		resolvedanalysisChannel, imbalancedAnionCationGroupingErrors, inputSampleTally, combinedSamples, talliedCombinedObjects, temporaryAnionSamples, temporaryCationSamples,
		anionInjectionTableSampleTuples, cationInjectionTableSampleTuples, duplicateSamples, duplicateSamplePositions, injectionTableLookupRounded, injectionTableSpecifiedQ,
		electrochemicalLookup
	},

	{
		initiallyResolvedAnalysisChannel
	}
		= If[MatchQ[samples, {} | Null | {Null} | Automatic],
		{{Null}},

		Transpose[MapThread[Function[{mySample, myMapThreadOptions},

			(* Look up injection table from the full list of options *)
			anionInjectionTableLookupRounded = Lookup[fullOptions, AnionInjectionTable];
			cationInjectionTableLookupRounded = Lookup[fullOptions, CationInjectionTable];

			(* Identify whether InjectionTable option is specified, aka it's value is not Automatic *)
			anionInjectionTableSpecifiedQ = MatchQ[anionInjectionTableLookupRounded, Except[Automatic]];
			cationInjectionTableSpecifiedQ = MatchQ[cationInjectionTableLookupRounded, Except[Automatic]];

			(* From the full list of options, look up the specified values for anion samples and cation samples; here samples can be sample, standard, and blank *)
			{anionLookup, cationLookup} = Lookup[fullOptions, {anionOption, cationOption}];

			(* Find the user specified AnalysisChannel for mySample from the InjectionTable *)
			anionInjectionTableSampleTuples = If[anionInjectionTableSpecifiedQ,
				Cases[anionInjectionTableLookupRounded, {sampleType, Download[mySample, Object] | mySample, ___}],
				{}
			];
			cationInjectionTableSampleTuples = If[cationInjectionTableSpecifiedQ,
				Cases[cationInjectionTableLookupRounded, {sampleType, Download[mySample, Object] | mySample, ___}],
				{}
			];

			injectionTableAnalysisChannel = Which[
				And[
					MemberQ[Download[anionInjectionTableSampleTuples[[All, 2]], Object], Download[mySample, Object]],
					MemberQ[Download[cationInjectionTableSampleTuples[[All, 2]], Object], Download[mySample, Object]]
				],
				Null,

				MemberQ[Download[anionInjectionTableSampleTuples[[All, 2]], Object], Download[mySample, Object]],
				AnionChannel,

				MemberQ[Download[cationInjectionTableSampleTuples[[All, 2]], Object], Download[mySample, Object]],
				CationChannel
			];

			(* Initial attempt in resolving AnalysisChannel. *)
			analysisChannel = Which[

				(* Case 2.1: If user already specified AnalysisChannel, go with user specified analysis channel *)
				MatchQ[Lookup[myMapThreadOptions, analysisChannelOption], Except[Automatic]],
				Lookup[myMapThreadOptions, analysisChannelOption],

				(* Case 2.2: If user specified AnalysisChannel in InjectionTable, go with that *)
				MatchQ[injectionTableAnalysisChannel, Except[Automatic | Null]],
				injectionTableAnalysisChannel,

				(* Case 2.3: THE COMPLICATED CASE! If the input object belongs to both AnionSamples and CationSamples, then we table it first by setting analysisChannel to TemporaryHolder *)
				(* An example of this case would be: InputSample ->{sample1, sample1, sample2}, AnionSamples->{sample1}, CationSamples->{sample1,sample2}. Here sample1 is in both groups *)
				And[
					MemberQ[
						ToList[anionLookup] /. {x : ObjectP[] :> Download[x, Object]},
						Lookup[fetchPacketFromCache[mySample, cache], Object]
					],
					MemberQ[
						ToList[cationLookup] /. {x : ObjectP[] :> Download[x, Object]},
						Lookup[fetchPacketFromCache[mySample, cache], Object]
					]
				],
				TemporaryHolder,

				(* Case 2.4: If the input object belongs to only AnionSamples, then assign AnalysisChannel to AnionChannel *)
				MemberQ[
					ToList[anionLookup] /. {x : ObjectP[] :> Download[x, Object]},
					Lookup[fetchPacketFromCache[mySample, cache], Object]
				],
				AnionChannel,

				(* Case 2.5: If the input object belongs to only Cationsamples, then assign AnalysisChannel to CationChannel *)
				MemberQ[
					ToList[cationLookup] /. {x : ObjectP[] :> Download[x, Object]},
					Lookup[fetchPacketFromCache[mySample, cache], Object]
				],
				CationChannel,
				(* Case 2.6: If the input object does not belong to neither group BUT AnionSamples are specified, then assign AnalysisChannel to CationChannel *)
				(* That is to say, if the user has 5 total samples, 2 samples are specified to be AnionSamples, the other 3 samples will automatically become CationSamples *)
				(* This condition also deals with the edge case where it can sort the second sample1 into CationSamples: input sample={sample1,sample2,sample1},AnionSamples={sample1} *)
				And[
					Length[Cases[Download[samples, Object], Download[mySample, Object]]] > Length[Cases[Download[anionLookup, Object], Download[mySample, Object]]],
					MatchQ[cationLookup, Null | ListableP[Automatic]],
					MatchQ[anionLookup, Except[ListableP[Automatic]]]
				],
				CationChannel,
				(* Case 2.7: If the input object does not belong to neither group BUT CationSamples are specified, then assign AnalysisChannel to AnionChannel *)
				And[
					Length[Cases[Download[samples, Object], Download[mySample, Object]]] > Length[Cases[Download[cationLookup, Object], Download[mySample, Object]]],
					MatchQ[anionLookup, Null | ListableP[Automatic]],
					MatchQ[cationLookup, Except[ListableP[Automatic]]]
				],
				AnionChannel,
				(* Case 2.8: If the input object contains "Anion" or "Hydroxide" in the object or model synonyms, then assign AnalysisChannel to AnionChannel *)
				Which[
					MatchQ[mySample, ObjectP[Object[Sample]]],
					Or[
						If[NullQ[Lookup[fetchPacketFromCache[#, cache]& /@ {mySample[Object], Quiet[mySample[Model][Object]]}, Name]],
							False,
							Or @@ StringContainsQ[ToString /@ Lookup[fetchPacketFromCache[#, cache]& /@ {mySample[Object], Quiet[mySample[Model][Object]]}, Name], "Anion", IgnoreCase -> True]
						],
						If[NullQ[Lookup[fetchPacketFromCache[#, cache]& /@ {mySample[Object], Quiet[mySample[Model][Object]]}, Name]],
							False,
							Or @@ StringContainsQ[ToString /@ Lookup[fetchPacketFromCache[#, cache]& /@ {mySample[Object], Quiet[mySample[Model][Object]]}, Name], "Hydroxide", IgnoreCase -> True]
						]
					],

					MatchQ[mySample, ObjectP[Model[Sample]]],
					Or[
						If[NullQ[Lookup[fetchPacketFromCache[Download[mySample, Object], cache], Name]],
							False,
							StringContainsQ[ToString /@ Lookup[fetchPacketFromCache[Download[mySample, Object], cache], Name], "Anion", IgnoreCase -> True]
						],
						If[NullQ[Lookup[fetchPacketFromCache[Download[mySample, Object], cache], Name]],
							False,
							StringContainsQ[ToString /@ Lookup[fetchPacketFromCache[Download[mySample, Object], cache], Name], "Hydroxide", IgnoreCase -> True]
						]
					]
				],
				AnionChannel,
				(* Case 2.9: If the input object contains "Cation" or "Acid" in the object or model synonyms, then assign AnalysisChannel to CationChannel *)
				Which[
					MatchQ[mySample, ObjectP[Object[Sample]]],
					Or[
						If[NullQ[Lookup[fetchPacketFromCache[#, cache]& /@ {mySample[Object], Quiet[mySample[Model][Object]]}, Name]],
							False,
							Or @@ StringContainsQ[ToString /@ Lookup[fetchPacketFromCache[#, cache]& /@ {mySample[Object], Quiet[mySample[Model][Object]]}, Name], "Cation", IgnoreCase -> True]
						],
						If[NullQ[Lookup[fetchPacketFromCache[#, cache]& /@ {mySample[Object], Quiet[mySample[Model][Object]]}, Name]],
							False,
							Or @@ StringContainsQ[ToString /@ Lookup[fetchPacketFromCache[#, cache]& /@ {mySample[Object], Quiet[mySample[Model][Object]]}, Name], "Acid", IgnoreCase -> True]
						]
					],

					MatchQ[mySample, ObjectP[Model[Sample]]],
					Or[
						If[NullQ[Lookup[fetchPacketFromCache[Download[mySample, Object], cache], Name]],
							False,
							StringContainsQ[ToString /@ Lookup[fetchPacketFromCache[Download[mySample, Object], cache], Name], "Cation", IgnoreCase -> True]
						],
						If[NullQ[Lookup[fetchPacketFromCache[Download[mySample, Object], cache], Name]],
							False,
							StringContainsQ[ToString /@ Lookup[fetchPacketFromCache[Download[mySample, Object], cache], Name], "Acid", IgnoreCase -> True]
						]
					]
				],
				CationChannel,

				(* Case 2.10: If use specified none of the options related to AnalysisChannel, including AnalysisChannel, AnionSamples/CationSamples, and InjectionTable *)
				(* Then resolve this options by looking at the composition/analytes of the input samples *)
				True, (
					(* Define common list of anions and cations *)
					commonAnions = {"Fluoride", "Chloride", "Bromide", "Nitrate", "Sulfate", "Phosphate"};
					commonCations = {"Lithium", "Sodium", "Ammonium", "Potassium", "Magnesium", "Calcium"};
					sampleComponents = Which[
						(* If Composition of the samples are specified, then extract the molecular components *)
						MemberQ[fetchPacketFromCache[mySample, cache], Composition],
						Download[Lookup[fetchPacketFromCache[mySample, cache], Composition, Date -> Now][[All, 2]], Name],
						(* If Analytes of the samples are specified, then extract the analytes *)
						MemberQ[fetchPacketFromCache[mySample, cache], Analytes],
						Download[Lookup[fetchPacketFromCache[mySample, cache], Analytes, Date -> Now], Name],
						(* All other cases, set sampleComposition to Null *)
						True,
						Null
					];
					(* Find the common anions and cations from sample components and compute how many hits there are for each ion group *)
					anionHits = If[MatchQ[sampleComponents, ListableP[Null]],
						{False},
						Table[StringContainsQ[sampleComponents[[i]] /. Null -> {}, #, IgnoreCase -> True], {i, 1, Length[sampleComponents]}]& /@ commonAnions
					];
					anionNumberOfHits = Count[Flatten[anionHits], True];
					cationHits = If[MatchQ[sampleComponents, ListableP[Null]],
						{False},
						Table[StringContainsQ[sampleComponents[[i]] /. Null -> {}, #, IgnoreCase -> True], {i, 1, Length[sampleComponents]}]& /@ commonCations
					];
					cationNumberOfHits = Count[Flatten[cationHits], True];
					Which[
						(* If there are less than 3 hits for both anion and cation, default to AnionChannel for the sammple *)
						anionNumberOfHits <= 2 && cationNumberOfHits <= 2,
						AnionChannel,
						(* If there are 3 or more hits for both anion and cation, default to AnionChannel for the sample *)
						anionNumberOfHits > 2 && cationNumberOfHits > 2,
						AnionChannel,
						(* If there are 3 or more anions and less than 3 cations, resolve to AnionChannel for the sample *)
						anionNumberOfHits > 2 && cationNumberOfHits < 2,
						AnionChannel,
						(* If there are less than 2 anions and 2 or more cations, resolve to CationChannel for the sample *)
						anionNumberOfHits < 2 && cationNumberOfHits > 2,
						CationChannel,
						(* All other cases, resolve to AnionChannel for the sample *)
						True,
						AnionChannel
					]
				)
			];
			(* Gather MapThread results *)
			{analysisChannel}
		],
			{ToList@samples, mapThreadOptions}
		]]];

	duplicateSamples = If[MatchQ[initiallyResolvedAnalysisChannel, {Null}],
		{},
		DeleteDuplicates@PickList[samples, initiallyResolvedAnalysisChannel, Null]
	];
	duplicateSamplePositions = Flatten@Module[{positions},
		Map[Function[{duplicate},
			positions = Sequence @@@ Position[samples, duplicate];
			MapThread[Rule,
				{
					positions,
					ReplacePart[ConstantArray[Null, Length[positions]], {_?OddQ -> AnionChannel, _?EvenQ -> CationChannel}]
				}
			]],
			ToList[duplicateSamples]
		]
	];

	initiallyResolvedAnalysisChannel /. duplicateSamplePositions;

	{
		resolvedanalysisChannel,
		imbalancedAnionCationGroupingErrors
	} =
		(* If initiallyResolvedAnalysisChannel already comes through with a valid assignment other than the temporarily tabled case, with value TemporaryHolder *)
		If[!MemberQ[Flatten@initiallyResolvedAnalysisChannel, TemporaryHolder],

			(* Then set resolvedAnalysisChannel to initiallyResolvedAnalysisChannel and set the error tracking variable to False*)
			{Flatten@initiallyResolvedAnalysisChannel, False},

			(* Otherwise, we first count the number of input samples *)
			inputSampleTally = Tally[Download[samples, Object]];

			(* Combine the list of AnionSamples and CationSamples *)
			combinedSamples = Download[Flatten@Lookup[fullOptions, {anionOption, cationOption}], Object];

			(* Tally the combined list of objects from AnionSamples and CationSamples *)
			(* Tally automatically sort the list of input objects *)
			talliedCombinedObjects = Tally[combinedSamples];

			(* Download the objects from CationSamples and AnionSamples *)
			temporaryAnionSamples = Download[Lookup[fullOptions, anionOption], Object];
			temporaryCationSamples = Download[Lookup[fullOptions, cationOption], Object];

			{
				(* Now we go through and see where the input samples were defined into the anion/cation groups*)
				(* We start with initially temporary lists that we take out samples from for each iteration of mapping *)
				Map[
					Which[
						(* If the object belongs to the temporaryAnionSamples, then assign AnalysisChannel to AnionChannel AND take out that sample from the temporaryAnionSamples *)
						(* So if the same sample (but has to have a sample objects repeated twice in the input object list) is assigned to both CationSamples and AnionSamples, it will be confused *)
						(* This algorithm also sets the first sample to AnionSamples if the same sample is meant to be run in both groups *)
						MemberQ[temporaryAnionSamples, #],
						temporaryAnionSamples = Delete[temporaryAnionSamples, FirstPosition[temporaryAnionSamples, #]];
						AnionChannel,

						(* Similarly if the object belongs to the temporaryCationSamples, assign AnalysisChannel to CationChannel AND take out that sample from the temporaryCationSamples *)
						MemberQ[temporaryCationSamples, #],
						temporaryCationSamples = Delete[temporaryCationSamples, FirstPosition[temporaryCationSamples, #]];
						CationChannel,

						(* If it does not belong to either group, assign AnlysisChannel to AnionChannel *)
						True,
						AnionChannel
					]&,
					Download[samples, Object]
				],

				(* Wet error tracking variable values; if the two tallies match, this error tracking variable will be false *)
				!MatchQ[inputSampleTally, talliedCombinedObjects]
			}
		]

];


(* ::Subsection:: *)
(*resolveICInjectionTable*)

(* ::Subsubsection::Closed:: *)
(*Options*)

DefineOptions[
	resolveICInjectionTable,
	Options :> {
		CacheOption,
		OutputOption
	}
];


(* ::Subsubsection::Closed:: *)
(*Source Code*)

resolveICInjectionTable::MissingFields = "resolveICInjectionTable requires the fields `1` to be passed in the options.";


(*this function is designed to *)
resolveICInjectionTable[mySamples_, partiallyResolvedOptions : _Association, myOptions : OptionsPattern[]] := Module[
	{
		safeOps, outputSpecification, cache, output, gatherTestsQ, messagesQ, commonRequiredFields, anionRequiredFields, cationRequiredFields,
		channelSelection, anionSamples, cationSamples, anionColumn, cationColumn, anionInjectionVolume, cationInjectionVolume,
		anionGradient, cationGradient, anionStandard, cationStandard, anionStandardFrequency, cationStandardFrequency, anionStandardInjectionVolumes,
		cationStandardInjectionVolumes, anionStandardGradient, cationStandardGradient, anionBlank, cationBlank, anionBlankFrequency, cationBlankFrequency,
		anionBlankInjectionVolumes, cationBlankInjectionVolumes, anionBlankGradient, cationBlankGradient, anionColumnRefreshFrequency, cationColumnRefreshFrequency,
		anionColumnPrimeGradient, cationColumnPrimeGradient, anionColumnFlushGradient, cationColumnFlushGradient, anionInjectionTable, cationInjectionTable,
		resolvedAnionSamplesObjects, resolvedCationSamplesObjects, resolvedAnionStandardObjects, resolvedCationStandardObjects, resolvedAnionBlankObjects,
		resolvedCationBlankObjects, overwriteAnionGradient, overwriteCationGradient, overwriteAnionBlankGradient, overwriteCationBlankGradient,
		overwriteAnionStandardGradient, overwriteCationStandardGradient, overwriteAnionColumnPrimeGradientInitial, overwriteCationColumnPrimeGradientInitial,
		overwriteAnionColumnFlushGradientInitial, overwriteCationColumnFlushGradientInitial, overwriteAnionColumnPrimeGradient,
		overwriteCationColumnPrimeGradient, overwriteAnionColumnFlushGradient, overwriteCationColumnFlushGradient, anionColumnQ, cationColumnQ, anionColumnPrimeQ,
		cationColumnPrimeQ, anionColumnFlushQ, cationColumnFlushQ, anionSampleExistsQ, cationSampleExistsQ, anionStandardExistsQ, cationStandardExistsQ,
		anionBlankExistsQ, cationBlankExistsQ, overwritingQ, resolvedAnionInjectionTable, resolvedCationInjectionTable, anionColumnPrimeGradientInitial,
		cationColumnPrimeGradientInitial, anionColumnFlushGradientInitial, cationColumnFlushGradientInitial, anionInjectionTableSpecifiedQ,
		cationInjectionTableSpecifiedQ, allAnionTupledGradients, allCationTupledGradients, anionHashDictionary, cationHashDictionary, injectionTableAnionSampleConflictQ,
		injectionTableCationSampleConflictQ, anionSampleInjectionVolumeConflictQ, cationSampleInjectionVolumeConflictQ, anionStandardInjectionVolumeConflictQ,
		cationStandardInjectionVolumeConflictQ, anionBlankInjectionVolumeConflictQ, cationBlankInjectionVolumeConflictQ, electrochemicalRequiredFields,
		injectionVolumeConflictOptions, injectionVolumeConflictTest, invalidOptions, invalidTests, injectionTableResult, resultRule, testsRule, column, injectionVolume,
		gradient, standard, standardFrequency, standardInjectionVolumes, standardGradient, blank, blankFrequency, blankInjectionVolumes, blankGradient,
		columnRefreshFrequency, columnPrimeGradientInitial, columnFlushGradientInitial, electrochemicalInjectionTable, overwriteGradient, overwriteStandardGradient,
		overwriteBlankGradient, overwriteColumnPrimeGradientInitial, overwriteColumnFlushGradientInitial, overwriteColumnPrimeGradient,
		overwriteColumnFlushGradient, resolvedSampleObjects, resolvedStandardObjects, resolvedBlankObjects, columnPrimeGradient, columnFlushGradient,
		allTupledGradients, hashDictionary, columnQ, columnPrimeQ, columnFlushQ, standardExistsQ, blankExistsQ, electrochemicalInjectionTableSpecifiedQ,
		injectionTableSampleConflictQ, resolvedElectrochemicalInjectionTable, voltageProfile, waveformProfile, standardWaveformProfile, standardVoltageProfile,
		blankVoltageProfile, columnPrimeVoltageProfile, columnPrimeWaveformProfile, columnFlushVoltageProfile, blankWaveformProfile, columnFlushWaveformProfile,
		allTupledWaveforms, hashWaveformDictionary, sampleInjectionVolumeConflictQ, standardInjectionVolumeConflictQ, blankInjectionVolumeConflictQ,
		referenceElectrodeMode, standardReferenceElectrodeMode, blankReferenceElectrodeMode, columnPrimeReferenceElectrodeMode, columnFlushReferenceElectrodeMode
	},

	(* get the safe options *)
	safeOps = SafeOptions[resolveICInjectionTable, ToList[myOptions]];

	(* get the output specification/output and cache options *)
	{outputSpecification, cache} = Lookup[safeOps, {Output, Cache}];
	output = ToList[outputSpecification];

	(* figure out if we are gathering tests or not *)
	gatherTestsQ = MemberQ[output, Tests];
	messagesQ = Not[gatherTestsQ];

	commonRequiredFields = {
		ChannelSelection
	};

	(*define the fields to pull out from the partially resolve options*)
	anionRequiredFields = {
		AnionSamples,
		AnionColumn,
		AnionInjectionVolume,
		AnionGradient,
		AnionStandard,
		AnionStandardFrequency,
		AnionStandardInjectionVolume,
		AnionStandardGradient,
		AnionBlank,
		AnionBlankFrequency,
		AnionBlankInjectionVolume,
		AnionBlankGradient,
		AnionColumnRefreshFrequency,
		AnionColumnPrimeGradient,
		AnionColumnFlushGradient,
		AnionInjectionTable
	};

	cationRequiredFields = {
		CationSamples,
		CationColumn,
		CationInjectionVolume,
		CationGradient,
		CationStandard,
		CationStandardFrequency,
		CationStandardInjectionVolume,
		CationStandardGradient,
		CationBlank,
		CationBlankFrequency,
		CationBlankInjectionVolume,
		CationBlankGradient,
		CationColumnRefreshFrequency,
		CationColumnPrimeGradient,
		CationColumnFlushGradient,
		CationInjectionTable
	};

	electrochemicalRequiredFields = {
		Column,
		InjectionVolume,
		Gradient,
		ReferenceElectrodeMode,
		VoltageProfile,
		WaveformProfile,
		Standard,
		StandardFrequency,
		StandardInjectionVolume,
		StandardGradient,
		StandardReferenceElectrodeMode,
		StandardVoltageProfile,
		StandardWaveformProfile,
		Blank,
		BlankFrequency,
		BlankInjectionVolume,
		BlankGradient,
		BlankReferenceElectrodeMode,
		BlankVoltageProfile,
		BlankWaveformProfile,
		ColumnRefreshFrequency,
		ColumnPrimeGradient,
		ColumnFlushGradient,
		ColumnPrimeReferenceElectrodeMode,
		ColumnPrimeVoltageProfile,
		ColumnPrimeWaveformProfile,
		ColumnFlushReferenceElectrodeMode,
		ColumnFlushVoltageProfile,
		ColumnFlushWaveformProfile,
		ElectrochemicalInjectionTable
	};

	(*Check that we have all the needed fields in order to resolve the injectiontable*)
	(*this error message should only be thrown for developers*)
	If[!SubsetQ[Keys[partiallyResolvedOptions], Join[commonRequiredFields, anionRequiredFields, cationRequiredFields, electrochemicalRequiredFields]],
		Message[resolveICInjectionTable::MissingFields, ToString[Complement[Keys[partiallyResolvedOptions], Join[commonRequiredFields, anionRequiredFields, cationRequiredFields, electrochemicalRequiredFields]]]];
		Return[$Failed]
	];

	(*pull the relevant information*)
	{
		channelSelection,
		anionSamples, anionColumn, anionInjectionVolume, anionGradient,
		anionStandard, anionStandardFrequency, anionStandardInjectionVolumes, anionStandardGradient,
		anionBlank, anionBlankFrequency, anionBlankInjectionVolumes, anionBlankGradient,
		anionColumnRefreshFrequency, anionColumnPrimeGradientInitial, anionColumnFlushGradientInitial,
		anionInjectionTable,

		cationSamples, cationColumn, cationInjectionVolume, cationGradient,
		cationStandard, cationStandardFrequency, cationStandardInjectionVolumes, cationStandardGradient,
		cationBlank, cationBlankFrequency, cationBlankInjectionVolumes, cationBlankGradient,
		cationColumnRefreshFrequency, cationColumnPrimeGradientInitial, cationColumnFlushGradientInitial,
		cationInjectionTable,

		column, injectionVolume, gradient, referenceElectrodeMode, voltageProfile, waveformProfile,
		standard, standardFrequency, standardInjectionVolumes, standardGradient, standardReferenceElectrodeMode, standardVoltageProfile, standardWaveformProfile,
		blank, blankFrequency, blankInjectionVolumes, blankGradient, blankReferenceElectrodeMode, blankVoltageProfile, blankWaveformProfile,
		columnRefreshFrequency, columnPrimeGradientInitial, columnFlushGradientInitial, columnPrimeReferenceElectrodeMode, columnPrimeVoltageProfile, columnPrimeWaveformProfile, columnFlushReferenceElectrodeMode, columnFlushVoltageProfile, columnFlushWaveformProfile,
		electrochemicalInjectionTable
	} = Lookup[partiallyResolvedOptions,
		Join[
			commonRequiredFields,
			anionRequiredFields,
			cationRequiredFields,
			electrochemicalRequiredFields
		]
	];

	(*we also need to see if we need to overwrite the gradient methods in the injection table. this
     happens if a user specifies a gradient object, but then changes the flow rate or something*)
	overwritingQ = SubsetQ[Keys[partiallyResolvedOptions],
		{
			AnionGradientOverwrite, CationGradientOverwrite, GradientOverwrite,
			AnionBlankGradientOverwrite, CationBlankGradientOverwrite, BlankGradientOverwrite,
			AnionStandardGradientOverwrite, CationStandardGradientOverwrite, StandardGradientOverwrite,
			AnionColumnFlushGradientOverwrite, CationColumnFlushGradientOverwrite, ColumnFlushGradientOverwrite,
			AnionColumnPrimeGradientOverwrite, CationColumnPrimeGradientOverwrite, ColumnPrimeGradientOverwrite
		}
	];

	{
		overwriteAnionGradient,
		overwriteCationGradient,
		overwriteGradient,
		overwriteAnionBlankGradient,
		overwriteCationBlankGradient,
		overwriteBlankGradient,
		overwriteAnionStandardGradient,
		overwriteCationStandardGradient,
		overwriteStandardGradient,
		overwriteAnionColumnPrimeGradientInitial,
		overwriteCationColumnPrimeGradientInitial,
		overwriteColumnPrimeGradientInitial,
		overwriteAnionColumnFlushGradientInitial,
		overwriteCationColumnFlushGradientInitial,
		overwriteColumnFlushGradientInitial
	} =
		(* If we are overwriting gradient, then look up the values of all the overwrite variable *)
		If[overwritingQ,
			Lookup[partiallyResolvedOptions, {
				AnionGradientOverwrite,
				CationGradientOverwrite,
				GradientOverwrite,
				AnionBlankGradientOverwrite,
				CationBlankGradientOverwrite,
				BlankGradientOverwrite,
				AnionStandardGradientOverwrite,
				CationStandardGradientOverwrite,
				StandardGradientOverwrite,
				AnionColumnPrimeGradientOverwrite,
				CationColumnPrimeGradientOverwrite,
				ColumnPrimeGradientOverwrite,
				AnionColumnFlushGradientOverwrite,
				CationColumnFlushGradientOverwrite,
				ColumnFlushGradientOverwrite
			}],

			(* Otherwise pad the list away with False *)
			Map[
				Function[{listOrNot},
					If[!MatchQ[listOrNot, Null | {}],
						ConstantArray[False, Length[listOrNot]]
					]
				],
				{
					anionGradient, cationGradient, gradient, anionBlankGradient, cationBlankGradient, blankGradient,
					anionStandardGradient, cationStandardGradient, standardGradient, anionColumnPrimeGradientInitial,
					cationColumnPrimeGradientInitial, columnPrimeGradientInitial, anionColumnFlushGradientInitial,
					cationColumnFlushGradientInitial, columnFlushGradientInitial
				}
			]
		];

	(* Download the objects of each groups of resolved samples, including samples, standards and blanks *)
	{
		resolvedSampleObjects, resolvedAnionSamplesObjects, resolvedCationSamplesObjects,
		resolvedStandardObjects, resolvedAnionStandardObjects, resolvedCationStandardObjects,
		resolvedBlankObjects, resolvedAnionBlankObjects, resolvedCationBlankObjects
	} = Module[{objects},
		objects = {
			ToList@mySamples, ToList@anionSamples, ToList@cationSamples,
			ToList@standard, ToList@anionStandard, ToList@cationStandard,
			ToList@blank, ToList@anionBlank, ToList@cationBlank
		};
		If[!NullQ[#],
			Download[#, Object],
			{}
		]& /@ objects
	];

	(* Reformat these resolved gradients *)
	{
		anionColumnPrimeGradient, anionColumnFlushGradient,
		cationColumnPrimeGradient, cationColumnFlushGradient,
		columnPrimeGradient, columnFlushGradient
	} = Map[{#}&,
		{
			anionColumnPrimeGradientInitial, anionColumnFlushGradientInitial,
			cationColumnPrimeGradientInitial, cationColumnFlushGradientInitial,
			columnPrimeGradientInitial, columnFlushGradientInitial
		}
	];

	(* Reformat singleton elements into individiual list. I am guess it's for easier mapping later on *)
	{
		overwriteAnionColumnPrimeGradient,
		overwriteAnionColumnFlushGradient,
		overwriteCationColumnPrimeGradient,
		overwriteCationColumnFlushGradient,
		overwriteColumnPrimeGradient,
		overwriteColumnFlushGradient
	} = Map[
		{#}&,
		{
			overwriteAnionColumnPrimeGradientInitial, overwriteAnionColumnFlushGradientInitial,
			overwriteCationColumnPrimeGradientInitial, overwriteCationColumnFlushGradientInitial,
			overwriteColumnPrimeGradientInitial, overwriteColumnFlushGradientInitial
		}
	];

	(*first find all of the gradients that are tupled (e.g. not Null or a method Object)*)
	(* First Cases command finds resolved gradient options that are not Null; the second Cases command finds resolved gradient options that are not method files, leaving only tuples *)
	allAnionTupledGradients = Cases[Join @@ Cases[{anionGradient, anionStandardGradient, anionBlankGradient, anionColumnPrimeGradient, anionColumnFlushGradient}, Except[Null]], Except[ObjectP[]]];
	allCationTupledGradients = Cases[Join @@ Cases[{cationGradient, cationStandardGradient, cationBlankGradient, cationColumnPrimeGradient, cationColumnFlushGradient}, Except[Null]], Except[ObjectP[]]];
	allTupledGradients = Cases[Join @@ Cases[{gradient, standardGradient, blankGradient, columnPrimeGradient, columnFlushGradient}, Except[Null]], Except[ObjectP[]]];
	(* It's a little bit complicated to pull out the waveforms *)
	allTupledWaveforms = DeleteDuplicates[
		MapThread[
			Sequence @@ Which[
				(* If multiple waveforms are specified in the following pattern, then only pull out the waveform components *)
				MatchQ[#1, {{TimeP, {{TimeP, VoltageP, BooleanP, BooleanP}...}...}...}],
				Transpose[{#1[[All, 2]], Repeat[#2, Length[#1[[All, 2]]]]}],
				(* If only one waveform is used, then leave it *)
				MatchQ[#1, {{TimeP, VoltageP, BooleanP, BooleanP}...}],
				{{#1, #2}},
				True,
				{}
			]&,

			(* Map through all the options that can specify waveform *)
			{
				Cases[Join[waveformProfile, standardWaveformProfile, blankWaveformProfile, {columnPrimeWaveformProfile}, {columnFlushWaveformProfile}], Except[Null | {Null}]],
				Cases[Join[referenceElectrodeMode, standardReferenceElectrodeMode, blankReferenceElectrodeMode, {columnPrimeReferenceElectrodeMode}, {columnFlushReferenceElectrodeMode}], Except[Null | {Null}]]
			}
		]
	];

	(*create a hash dictionary for each one that points to a temporary gradient method*)
	anionHashDictionary = Association[(# -> CreateID[Object[Method, IonChromatographyGradient]])& /@ DeleteDuplicates[(Hash /@ allAnionTupledGradients)]];
	cationHashDictionary = Association[(# -> CreateID[Object[Method, IonChromatographyGradient]])& /@ DeleteDuplicates[(Hash /@ allCationTupledGradients)]];
	hashDictionary = Association[(# -> CreateID[Object[Method, Gradient]])& /@ DeleteDuplicates[(Hash /@ allTupledGradients)]];
	hashWaveformDictionary = Association[(# -> CreateID[Object[Method, Waveform]])& /@ DeleteDuplicates[(Hash /@ allTupledWaveforms)]];

	anionColumnQ = !MatchQ[anionColumn, Null | {} | {Null}];
	cationColumnQ = !MatchQ[cationColumn, Null | {} | {Null}];
	columnQ = !MatchQ[column, Null | {} | {Null}];
	anionColumnPrimeQ = !MatchQ[anionColumnRefreshFrequency, Last];
	cationColumnPrimeQ = !MatchQ[cationColumnRefreshFrequency, Last];
	columnPrimeQ = !MatchQ[columnRefreshFrequency, Last];
	anionColumnFlushQ = !MatchQ[anionColumnFlushGradient, {} | Null];
	cationColumnFlushQ = !MatchQ[cationColumnFlushGradient, {} | Null];
	columnFlushQ = !MatchQ[columnFlushGradient, {} | Null];

	anionSampleExistsQ = !MatchQ[anionSamples, {} | Null | {Null}];
	cationSampleExistsQ = !MatchQ[cationSamples, {} | Null | {Null}];
	anionStandardExistsQ = !MatchQ[anionStandard, Null | {} | {Null}];
	cationStandardExistsQ = !MatchQ[cationStandard, Null | {} | {Null}];
	standardExistsQ = !MatchQ[standard, Null | {} | {Null}];
	anionBlankExistsQ = !MatchQ[anionBlank, Null | {} | {Null}];
	cationBlankExistsQ = !MatchQ[cationBlank, Null | {} | {Null}];
	blankExistsQ = !MatchQ[blank, Null | {} | {Null}];

	(*though this shouldn't ever be Null*)
	anionInjectionTableSpecifiedQ = MatchQ[anionInjectionTable, Except[Automatic | Null]];
	cationInjectionTableSpecifiedQ = MatchQ[cationInjectionTable, Except[Automatic | Null]];
	electrochemicalInjectionTableSpecifiedQ = MatchQ[electrochemicalInjectionTable, Except[Automatic | Null]];

	(*we need to make sure that if the injection table is specified that the samples and the input are compatible*)
	injectionTableAnionSampleConflictQ = If[anionInjectionTableSpecifiedQ,
		!SameQ[
			Sort[ToList@Download[Cases[anionInjectionTable, {Sample, ___}] /. {Sample, x_, ___} :> x, Object]],
			Sort[ToList@Download[anionSamples, Object]]
		],
		(**)
		False
	];
	injectionTableCationSampleConflictQ = If[cationInjectionTableSpecifiedQ,
		!SameQ[
			Sort[ToList@Download[Cases[cationInjectionTable, {Sample, ___}] /. {Sample, x_, ___} :> x, Object]],
			Sort[ToList@Download[cationSamples, Object]]
		],
		(**)
		False
	];
	injectionTableSampleConflictQ = If[electrochemicalInjectionTableSpecifiedQ,
		!SameQ[
			Sort[ToList@Download[Cases[electrochemicalInjectionTable, {Sample, ___}] /. {Sample, x_, ___} :> x, Object]],
			Sort[ToList@Download[mySamples, Object]]
		],
		False
	];

	(*there are two big paths here, the first is if the injection table is specified*)
	(*second is if the injection table is not specified and we need to build it from scratch*)
	resolvedAnionInjectionTable = If[!MemberQ[channelSelection, AnionChannel],
		{},

		If[anionInjectionTableSpecifiedQ,
			(*even though the injection table is specified, not all of the entries within may be (e.g. the sample, injection volume, column or gradient). We need to resolve all of these*)
			Module[{anionSamplePositions, anionStandardPositions, anionBlankPositions, anionColumnPrimePositions, anionColumnFlushPositions, resolvedAnionSampleTuples,
				resolvedAnionStandardTuples, resolvedAnionBlankTuples, anionColumnPrimeAutomaticPositions, anionColumnFlushAutomaticPositions, resolvedAnionColumnPrimeTuples,
				resolvedAnionColumnFlushTuples, semiResolvedAnionColumnPrimeTuples, semiResolvedAnionColumnFlushTuples, resolvedAnionInnerInjectionTable,
				anionSampleInjectionTableTuples, anionSampleLength, injectionTableAnionSampleLength, anionColumnPrimeDictionary, anionColumnFlushDictionary,
				anionColumnPrimeAutomaticGradientPositions, anionColumnFlushAutomaticGradientPositions, columnPrimeGradientResolution, columnFlushGradientResolution,
				resolvedAnionColumnPrimeTableGradients, resolvedAnionColumnFlushTableGradients, anionColumnPrimeWithChannel, anionColumnFlushWithChannel},

				(*first separate the injection table by the positions according to its type*)
				{anionSamplePositions, anionStandardPositions, anionBlankPositions, anionColumnPrimePositions, anionColumnFlushPositions} = Map[
					Sequence @@@ Position[anionInjectionTable, {#, ___}]&
					, {Sample, Standard, Blank, ColumnPrime, ColumnFlush}];

				(*get the respective lengths*)
				anionSampleLength = Length[anionSamples];
				injectionTableAnionSampleLength = Length[anionSamplePositions];

				(*now we can resolve the standard, blank, and standard tuples because of the 1:1 index matching*)
				{resolvedAnionSampleTuples, resolvedAnionStandardTuples, resolvedAnionBlankTuples} = Map[
					Function[{entry},
						Module[{tableTuples, samples, injectionVolumes, gradients, overwriteBool},

							(*split the entry*)
							{tableTuples, samples, injectionVolumes, gradients, overwriteBool} = entry;

							(*if there is misalignment with the input samples and the injection table (i.e. if injectionTableSampleConflictQ is true), then the consequent mapthread become difficult.*)
							(*therefore, we must pad/truncate if needbe*)
							anionSampleInjectionTableTuples = If[!injectionTableAnionSampleConflictQ,
								anionInjectionTable[[anionSamplePositions]],
								(*otherwise, will pad or subtract based on the length*)
								Which[
									(*if the same length, then it's easy*)
									anionSampleLength == injectionTableAnionSampleLength, anionInjectionTable[[anionSamplePositions]],
									(*if sample is longer, then we'll pad with the automatic tuple*)
									anionSampleLength > injectionTableAnionSampleLength, PadRight[anionInjectionTable[[anionSamplePositions]], anionSampleLength, {{Sample, Automatic, Automatic, Automatic, Automatic}}],
									(*otherwise, the injection sample length must be larger, so just take the subset*)
									(* First [[ ]] takes all the samples in the specified position; then the second [[ ]] takes only x number that matches the number of input samples *)
									True, anionInjectionTable[[anionSamplePositions]][[1 ;; anionSampleLength]]
								]
							];

							(*first check if there is something here (e.g. no standards), in which case return an empty list*)
							If[MatchQ[{tableTuples, samples, injectionVolumes, gradients, overwriteBool}, {(Null | {})..}],
								{},
								(*otherwise map thread and fill these tuples*)
								MapThread[
									Function[{tableTuple, sample, injectionVolume, gradient, overwriteQ},
										Module[{setSample, setAnalysisChannel, setInjectionVolume, gradientConverted, setGradient},
											(*check out much of the tupled is filled out*)
											(*Type, Sample, InjectionVolume, Column, Gradient*)
											setSample = If[MatchQ[tableTuple[[2]], Automatic],
												sample,
												tableTuple[[2]]
											];

											setAnalysisChannel = AnionChannel;

											setInjectionVolume = If[MatchQ[tableTuple[[4]], Automatic],
												injectionVolume,
												tableTuple[[4]]
											];

											(*convert the gradient if it's in tupled form*)
											gradientConverted = If[MatchQ[gradient, Except[ObjectP[Object[Method, IonChromatographyGradient]]]],
												Hash[gradient] /. anionHashDictionary,
												gradient
											];

											setGradient = If[!Sequence @@ overwriteQ,
												Switch[tableTuple[[5]],
													(*convert if need be*)
													Automatic, gradientConverted,
													_, tableTuple[[5]]
												],
												CreateID[Object[Method, IonChromatographyGradient]]
											];

											(*return the resolved tuple*)
											{First@tableTuple, setSample, setAnalysisChannel, setInjectionVolume, setGradient}

										]]
									, {tableTuples, samples, injectionVolumes, gradients, overwriteBool}]
							]
						]],
					{
						{anionSampleInjectionTableTuples, ToList@anionSamples, anionInjectionVolume, anionGradient, overwriteAnionGradient},
						{anionInjectionTable[[anionStandardPositions]], ToList@anionStandard, anionStandardInjectionVolumes, anionStandardGradient, overwriteAnionStandardGradient},
						{anionInjectionTable[[anionBlankPositions]], ToList@anionBlank, anionBlankInjectionVolumes, anionBlankGradient, overwriteAnionBlankGradient}
					}
				];

				(* Now we resolve the AnalysisChannel for ColumnPrimes and ColumnFlushes *)

				(*create the resolved sub tables with the AnalysisChannels*)
				semiResolvedAnionColumnPrimeTuples = anionInjectionTable[[anionColumnPrimePositions]];
				semiResolvedAnionColumnFlushTuples = anionInjectionTable[[anionColumnFlushPositions]];

				(*we'll now resolve the gradients*)
				(*for the gradients, we always want to associate the method to the appropriate analysis channel. accordingly, we need a dictionary*)
				anionColumnPrimeDictionary = Function[{anionPrimeGradient, anionColumnPrimeOverwriteQ},
					{
						AnionChannel -> If[!(Sequence @@ Flatten[anionColumnPrimeOverwriteQ]), anionPrimeGradient, CreateID[Object[Method, IonChromatographyGradient]]]
					}
				][anionColumnPrimeGradient, overwriteAnionColumnPrimeGradient];

				anionColumnFlushDictionary = Function[{anionFlushGradient, anionColumnFlushOverwriteQ},
					{
						AnionChannel -> If[!(Sequence @@ Flatten[anionColumnFlushOverwriteQ]), anionFlushGradient, CreateID[Object[Method, IonChromatographyGradient]]]
					}
				][anionColumnFlushGradient, overwriteAnionColumnFlushGradient];

				(*find all of the automatic gradient positions for each*)
				anionColumnPrimeAutomaticGradientPositions = Flatten@Position[anionInjectionTable[[anionColumnPrimePositions]][[All, 3]], Automatic];
				anionColumnFlushAutomaticGradientPositions = Flatten@Position[anionInjectionTable[[anionColumnFlushPositions]][[All, 3]], Automatic];

				(*fill in AnionChannel for all column prime and column flushes *)
				anionColumnPrimeWithChannel = ReplacePart[#, 2 -> AnionChannel]& /@ semiResolvedAnionColumnPrimeTuples;
				anionColumnFlushWithChannel = ReplacePart[#, 2 -> AnionChannel]& /@ semiResolvedAnionColumnFlushTuples;

				(*find the gradient for all these based on the column and dictionary*)
				columnPrimeGradientResolution = anionColumnPrimeWithChannel[[anionColumnPrimeAutomaticGradientPositions, 2]] /. anionColumnPrimeDictionary;
				columnFlushGradientResolution = anionColumnFlushWithChannel[[anionColumnFlushAutomaticGradientPositions, 2]] /. anionColumnFlushDictionary;

				(*fill these in into our semi-resolved tuples*)
				anionColumnPrimeWithChannel[[anionColumnPrimeAutomaticGradientPositions, 3]] = If[!MatchQ[columnPrimeGradientResolution, {}], First@columnPrimeGradientResolution, {}];
				anionColumnFlushWithChannel[[anionColumnFlushAutomaticGradientPositions, 3]] = If[!MatchQ[columnFlushGradientResolution, {}], First@columnFlushGradientResolution, {}];

				(*finally, we loop through and convert to a gradient object*)
				{resolvedAnionColumnPrimeTableGradients, resolvedAnionColumnFlushTableGradients} = Map[Function[{gradients},
					(*map through each and convert to an object *)
					Map[Function[{gradient},
						If[MatchQ[gradient, Except[ObjectP[Object[Method]]]],
							Hash[gradient] /. anionHashDictionary,
							gradient
						]]
						, gradients]]
					, {
						anionColumnPrimeWithChannel[[All, 3]],
						anionColumnFlushWithChannel[[All, 3]]
					}
				];

				(*make our final resolution*)
				resolvedAnionColumnPrimeTuples = anionColumnPrimeWithChannel;
				resolvedAnionColumnPrimeTuples[[All, 3]] = resolvedAnionColumnPrimeTableGradients;
				resolvedAnionColumnFlushTuples = anionColumnFlushWithChannel;
				resolvedAnionColumnFlushTuples[[All, 3]] = resolvedAnionColumnFlushTableGradients;

				(*returned the resolved injection table*)
				resolvedAnionInnerInjectionTable = anionInjectionTable;

				(*again, we must be mindful of injectiontable sample clashing*)
				resolvedAnionInnerInjectionTable[[anionSamplePositions]] = If[!injectionTableAnionSampleConflictQ,
					resolvedAnionSampleTuples,
					(*otherwise, we do it by the lengths*)
					If[anionSampleLength > injectionTableAnionSampleLength,
						resolvedAnionSampleTuples[[1 ;; injectionTableAnionSampleLength]],
						(*otherwise, should work*)
						resolvedAnionSampleTuples
					]
				];

				resolvedAnionInnerInjectionTable[[anionBlankPositions]] = resolvedAnionBlankTuples;
				resolvedAnionInnerInjectionTable[[anionStandardPositions]] = resolvedAnionStandardTuples;
				resolvedAnionInnerInjectionTable[[anionColumnPrimePositions]] = resolvedAnionColumnPrimeTuples;
				resolvedAnionInnerInjectionTable[[anionColumnFlushPositions]] = resolvedAnionColumnFlushTuples;

				resolvedAnionInnerInjectionTable

			],
			(*otherwise, we build it from the other options*)
			Module[{hashedAnionGradient, anionSamplesAsTuples, anionStandardsAsTuples, anionStandardAsTuples, anionBlanksAsTuples, anionBlankAsTuples,
				anionColumnPrimeAsTuples, anionColumnFlushAsTuples, anionStandardPositions, anionBlankPositions, anionColumnRefreshPositions,
				anionGatheredInserts, anionGatheredInsertsFormatted, sortedAnionInsertionTuples, anionGradientsConverted, anionStandardGradientsConverted,
				anionBlankGradientsConverted, anionColumnPrimeGradientsConverted, anionColumnFlushGradientsConverted, protoAnionInjectionList,
				replacementAnionList, replacedAnionInjectionList, completeAnionList},
				(*in this thread of the conditional we are building the injection table from scratch*)

				(*first we need all of the positional for the standards, blanks, and column refreshes *)

				(*for the gradient changes we can use the hashing dictionary to simplify things*)
				hashedAnionGradient = anionGradient /. anionHashDictionary;

				(*convert the gradients if they're in tupled form to methods*)
				{anionGradientsConverted, anionStandardGradientsConverted, anionBlankGradientsConverted, anionColumnPrimeGradientsConverted,
					anionColumnFlushGradientsConverted} = MapThread[
					If[!MatchQ[#1, {} | Null],
						MapThread[Function[{gradient, overwriteQ},
							If[MatchQ[gradient, Except[ObjectP[Object[Method]]]],
								Hash[gradient] /. anionHashDictionary,
								(*check to see if we need to overwrite the method and generate a new one*)
								If[!overwriteQ, gradient, CreateID[Object[Method, IonChromatographyGradient]]]
							]],
							{#1, #2}
						]
					]&, {
						{anionGradient, anionStandardGradient, anionBlankGradient, anionColumnPrimeGradient, anionColumnFlushGradient},
						{overwriteAnionGradient, overwriteAnionStandardGradient, overwriteAnionBlankGradient, Flatten@overwriteAnionColumnPrimeGradient, Flatten@overwriteAnionColumnFlushGradient}
					}
				];

				(*get the samples in to the tupled format for the list*)
				(*Type, Sample, AnalysisChannel, InjectionVolume, Gradient*)
				anionSamplesAsTuples = If[anionSampleExistsQ,
					MapThread[Function[{sample, injectionVolume, gradient},
						{Sample, sample, AnionChannel, injectionVolume, gradient}
					], {ToList@anionSamples, anionInjectionVolume, anionGradientsConverted}],
					{}
				];

				(*do the same for the standards and blanks*)
				anionStandardsAsTuples = If[anionStandardExistsQ,
					MapThread[Function[{sample, injectionVolume, gradient},
						{Standard, sample, AnionChannel, injectionVolume, gradient}
					], {ToList@anionStandard, anionStandardInjectionVolumes, anionStandardGradientsConverted}],
					{}
				];

				anionBlanksAsTuples = If[anionBlankExistsQ,
					MapThread[Function[{sample, injectionVolume, gradient},
						{Blank, sample, AnionChannel, injectionVolume, gradient}
					], {ToList@anionBlank, anionBlankInjectionVolumes, anionBlankGradientsConverted}]
					, {}
				];

				(*get the ColumnPrime and ColumnFlush in to the tupled format for the list*)
				anionColumnPrimeAsTuples = If[anionColumnQ && anionColumnPrimeQ,
					{ColumnPrime, AnionChannel, Sequence @@ anionColumnPrimeGradientsConverted},
					{}
				];

				anionColumnFlushAsTuples = If[anionColumnQ && anionColumnFlushQ,
					{ColumnFlush, AnionChannel, Sequence @@ anionColumnFlushGradientsConverted},
					{}
				];

				(* Based on StandardFrequency option, determine the positions where standards will run *)
				anionStandardPositions = If[!anionStandardExistsQ,
					{},

					Which[
						Length[ToList@anionStandard] > 0 && Length[ToList@anionSamples] > 0,

						DeleteDuplicates@Switch[anionStandardFrequency,
							None | Null, {},
							First, {1},
							Last, {Length[ToList@anionSamples] + 1},
							FirstAndLast, {1, Length[ToList@anionSamples] + 1},

							GradientChange,
							Module[{identicalGradientRuns},
								identicalGradientRuns = Most + Accumulate[Length /@ Split[hashedAnionGradient]];
								Join[{1}, identicalGradientRuns + 1, {Length[ToList@anionSamples] + 1}]
							],

							GreaterP[0, 1],
							Range[1, Length[ToList@anionSamples], anionStandardFrequency]
						],

						Length[ToList@anionStandard] > 0 && Length[ToList@anionSamples] == 0,

						DeleteDuplicates@Switch[anionStandardFrequency,
							None | Null, {},
							First, {1},
							Last, {1},
							FirstAndLast, {1, 2},
							GradientChange, {1},
							GreaterP[0, 1], {1}
						],

						True, {}
					]
				];

				(* Based on BlankFrequency option, determine the positions where blanks will run *)
				anionBlankPositions = If[!anionBlankExistsQ,
					{},

					Which[
						Length[ToList@anionBlank] > 0 && Length[ToList@anionSamples] > 0,

						DeleteDuplicates@Switch[anionBlankFrequency,
							None | Null, {},
							First, {1},
							Last, {Length[ToList@anionSamples] + 1},
							FirstAndLast, {1, Length[ToList@anionSamples] + 1},

							GradientChange,
							Module[{identicalGradientRuns},
								identicalGradientRuns = Most + Accumulate[Length /@ Split[hashedAnionGradient]];
								Join[{1}, identicalGradientRuns + 1, {Length[ToList@anionSamples] + 1}]
							],

							GreaterP[0, 1],
							Range[1, Length[ToList@anionSamples], anionBlankFrequency]
						],

						Length[ToList@anionBlank] > 0 && Length[ToList@anionSamples] == 0,

						DeleteDuplicates@Switch[anionBlankFrequency,
							None | Null, {},
							First, {1},
							Last, {1},
							FirstAndLast, {1, 2},
							GradientChange, {1},
							GreaterP[0, 1], {1}
						],

						True, {}
					]
				];

				(* Based on ColumnRefreshFrequency option, determine the positions where primes/flushes will run. Here we don't care about the initial ColumnPrime and terminal ColumnFlush. So we ignore the FirstAndLast *)
				anionColumnRefreshPositions = If[MatchQ[anionColumnRefreshFrequency, GreaterP[0, 1]],

					Range[1, Length[ToList@anionSamples], anionColumnRefreshFrequency],
					(*else nichts*)
					{}
				];

				(*Now we will figure out how to position these among the samples*)

				(*First create a gathered list of tuples. First entry in the tuple is the position, second entry is the placeholder information (BlankDummy, StandardDummy). We will rule replace these out eventually.*)
				anionGatheredInserts = GatherBy[Join[{#, AnionColumnPrimeDummy}& /@ anionColumnRefreshPositions,
					{#, AnionBlankDummy}& /@ anionBlankPositions,
					{#, AnionStandardDummy}& /@ anionStandardPositions], First];

				(*format it so that it's more understandable and useable*)
				anionGatheredInsertsFormatted = {#[[1, 1]], #[[All, 2]]}& /@ anionGatheredInserts;

				(*then sort it*)
				sortedAnionInsertionTuples = Reverse[SortBy[anionGatheredInsertsFormatted, First]];

				(*now insert into the sequence of samples*)
				protoAnionInjectionList = If[MatchQ[anionSamplesAsTuples, {}] && !MatchQ[sortedAnionInsertionTuples, {}],
					SortBy[sortedAnionInsertionTuples, First][[All, 2]],
					Fold[Insert[#1, #2[[2]], #2[[1]]]&, anionSamplesAsTuples, sortedAnionInsertionTuples]
				];

				replacementAnionList = If[MatchQ[#, _ -> {}],
					Nothing,
					#
				]& /@
					{
						AnionBlankDummy -> Sequence @@ anionBlanksAsTuples,
						AnionStandardDummy -> Sequence @@ anionStandardsAsTuples,
						AnionColumnPrimeDummy -> Sequence @@ anionColumnPrimeAsTuples
					};
				(*then rule replace the Dummys with our blanks, standards, and column primes*)
				replacedAnionInjectionList = Flatten /@ Partition[SplitBy[Flatten[protoAnionInjectionList /. replacementAnionList], MatchQ[#, InjectionTableCleaningTypeP | InjectionTableSampleTypeP]&], 2];

				(*finally add the initial and final flushes if necessary*)
				completeAnionList = Switch[anionColumnRefreshFrequency,
					FirstAndLast, Insert[Insert[replacedAnionInjectionList, anionColumnPrimeAsTuples, 1], anionColumnFlushAsTuples, Length[replacedAnionInjectionList] + 2],
					First, Insert[replacedAnionInjectionList, anionColumnPrimeAsTuples, 1],
					Last, Insert[replacedAnionInjectionList, anionColumnFlushAsTuples, Length[replacedAnionInjectionList] + 1],
					_, replacedAnionInjectionList
				]
			]
		]
	];


	(*now use the same strategy to resolve CationInjectionTable*)
	(*second is if the injection table is not specified and we need to build it from scratch*)
	resolvedCationInjectionTable = If[!MemberQ[channelSelection, CationChannel],
		{},

		If[cationInjectionTableSpecifiedQ,
			(*even though the injection table is specified, not all of the entries within may be (e.g. the sample, injection volume, column or gradient). We need to resolve all of these*)
			Module[{cationSamplePositions, cationStandardPositions, cationBlankPositions, cationColumnPrimePositions, cationColumnFlushPositions, resolvedCationSampleTuples,
				resolvedCationStandardTuples, resolvedCationBlankTuples, cationColumnPrimeAutomaticPositions, cationColumnFlushAutomaticPositions, resolvedCationColumnPrimeTuples,
				resolvedCationColumnFlushTuples, semiResolvedCationColumnPrimeTuples, semiResolvedCationColumnFlushTuples, resolvedCationInnerInjectionTable,
				cationSampleInjectionTableTuples, cationSampleLength, injectionTableCationSampleLength, cationColumnPrimeDictionary, cationColumnFlushDictionary,
				cationColumnPrimeAutomaticGradientPositions, cationColumnFlushAutomaticGradientPositions, columnPrimeGradientResolution, columnFlushGradientResolution,
				resolvedCationColumnPrimeTableGradients, resolvedCationColumnFlushTableGradients, cationColumnPrimeWithChannel, cationColumnFlushWithChannel},

				(*first separate the injection table by the positions according to its type*)
				{cationSamplePositions, cationStandardPositions, cationBlankPositions, cationColumnPrimePositions, cationColumnFlushPositions} = Map[
					Sequence @@@ Position[cationInjectionTable, {#, ___}]&
					, {Sample, Standard, Blank, ColumnPrime, ColumnFlush}];

				(*get the respective lengths*)
				cationSampleLength = Length[cationSamples];
				injectionTableCationSampleLength = Length[cationSamplePositions];

				(*now we can resolve the standard, blank, and standard tuples because of the 1:1 index matching*)
				{resolvedCationSampleTuples, resolvedCationStandardTuples, resolvedCationBlankTuples} = Map[
					Function[{entry},
						Module[{tableTuples, samples, injectionVolumes, gradients, overwriteBool},

							(*split the entry*)
							{tableTuples, samples, injectionVolumes, gradients, overwriteBool} = entry;

							(*if there is misalignment with the input samples and the injection table (i.e. if injectionTableSampleConflictQ is true), then the consequent mapthread become difficult.*)
							(*therefore, we must pad/truncate if needbe*)
							cationSampleInjectionTableTuples = If[!injectionTableCationSampleConflictQ,
								cationInjectionTable[[cationSamplePositions]],
								(*otherwise, will pad or subtract based on the length*)
								Which[
									(*if the same length, then it's easy*)
									cationSampleLength == injectionTableCationSampleLength, cationInjectionTable[[cationSamplePositions]],
									(*if sample is longer, then we'll pad with the automatic tuple*)
									cationSampleLength > injectionTableCationSampleLength, PadRight[cationInjectionTable[[cationSamplePositions]], cationSampleLength, {{Sample, Automatic, Automatic, Automatic, Automatic}}],
									(*otherwise, the injection sample length must be larger, so just take the subset*)
									(* First [[ ]] takes all the samples in the specified position; then the second [[ ]] takes only x number that matches the number of input samples *)
									True, cationInjectionTable[[cationSamplePositions]][[1 ;; cationSampleLength]]
								]
							];

							(*first check if there is something here (e.g. no standards), in which case return an empty list*)
							If[MatchQ[{tableTuples, samples, injectionVolumes, gradients, overwriteBool}, {(Null | {})..}],
								{},
								(*otherwise map thread and fill these tuples*)
								MapThread[
									Function[{tableTuple, sample, injectionVolume, gradient, overwriteQ},
										Module[{setSample, setAnalysisChannel, setInjectionVolume, gradientConverted, setGradient},
											(*check out much of the tupled is filled out*)
											(*Type, Sample, InjectionVolume, Column, Gradient*)
											setSample = If[MatchQ[tableTuple[[2]], Automatic],
												sample,
												tableTuple[[2]]
											];

											setAnalysisChannel = CationChannel;

											setInjectionVolume = If[MatchQ[tableTuple[[4]], Automatic],
												injectionVolume,
												tableTuple[[4]]
											];

											(*convert the gradient if it's in tupled form*)
											gradientConverted = If[MatchQ[gradient, Except[ObjectP[Object[Method]]]],
												Hash[gradient] /. cationHashDictionary,
												gradient
											];

											setGradient = If[!Sequence @@ overwriteQ,
												Switch[tableTuple[[5]],
													(*convert if need be*)
													Automatic, gradientConverted,
													_, tableTuple[[5]]
												],
												CreateID[Object[Method, IonChromatographyGradient]]
											];

											(*return the resolved tuple*)
											{First@tableTuple, setSample, setAnalysisChannel, setInjectionVolume, setGradient}

										]]
									,{tableTuples, samples, injectionVolumes, gradients, overwriteBool}]
							]
						]],
					{
						{cationSampleInjectionTableTuples, ToList@cationSamples, cationInjectionVolume, cationGradient, overwriteCationGradient},
						{cationInjectionTable[[cationStandardPositions]], ToList@cationStandard, cationStandardInjectionVolumes, cationStandardGradient, overwriteCationStandardGradient},
						{cationInjectionTable[[cationBlankPositions]], ToList@cationBlank, cationBlankInjectionVolumes, cationBlankGradient, overwriteCationBlankGradient}
					}
				];

				(* Now we resolve the AnalysisChannel for ColumnPrimes and ColumnFlushes *)

				(*create the resolved sub tables with the AnalysisChannels*)
				semiResolvedCationColumnPrimeTuples = cationInjectionTable[[cationColumnPrimePositions]];
				semiResolvedCationColumnFlushTuples = cationInjectionTable[[cationColumnFlushPositions]];

				(*we'll now resolve the gradients*)
				(*for the gradients, we always want to associate the method to the appropriate analysis channel. accordingly, we need a dictionary*)
				cationColumnPrimeDictionary = Function[{cationPrimeGradient, cationColumnPrimeOverwriteQ},
					{
						CationChannel -> If[!(Sequence @@ Flatten[cationColumnPrimeOverwriteQ]), cationPrimeGradient, CreateID[Object[Method, IonChromatographyGradient]]]
					}
				][cationColumnPrimeGradient, overwriteCationColumnPrimeGradient];

				cationColumnFlushDictionary = Function[{cationFlushGradient, cationColumnFlushOverwriteQ},
					{
						CationChannel -> If[!(Sequence @@ Flatten[cationColumnFlushOverwriteQ]), cationFlushGradient, CreateID[Object[Method, IonChromatographyGradient]]]
					}
				][cationColumnFlushGradient, overwriteCationColumnFlushGradient];

				(*find all of the automatic gradient positions for each*)
				cationColumnPrimeAutomaticGradientPositions = Flatten@Position[cationInjectionTable[[cationColumnPrimePositions]][[All, 3]], Automatic];
				cationColumnFlushAutomaticGradientPositions = Flatten@Position[cationInjectionTable[[cationColumnFlushPositions]][[All, 3]], Automatic];

				(*fill in AnionChannel for all column prime and column flushes *)
				cationColumnPrimeWithChannel = ReplacePart[#, 2 -> CationChannel]& /@ semiResolvedCationColumnPrimeTuples;
				cationColumnFlushWithChannel = ReplacePart[#, 2 -> CationChannel]& /@ semiResolvedCationColumnFlushTuples;

				(*find the gradient for all these based on the column and dictionary*)
				columnPrimeGradientResolution = cationColumnPrimeWithChannel[[cationColumnPrimeAutomaticGradientPositions, 2]] /. cationColumnPrimeDictionary;
				columnFlushGradientResolution = cationColumnFlushWithChannel[[cationColumnFlushAutomaticGradientPositions, 2]] /. cationColumnFlushDictionary;

				(*fill these in into our semi-resolved tuples*)
				cationColumnPrimeWithChannel[[cationColumnPrimeAutomaticGradientPositions, 3]] = If[!MatchQ[columnPrimeGradientResolution, {}], First@columnPrimeGradientResolution, {}];
				cationColumnFlushWithChannel[[cationColumnFlushAutomaticGradientPositions, 3]] = If[!MatchQ[columnFlushGradientResolution, {}], First@columnFlushGradientResolution, {}];

				(*finally, we loop through and convert to a gradient object*)
				{resolvedCationColumnPrimeTableGradients, resolvedCationColumnFlushTableGradients} = Map[Function[{gradients},
					(*map through each and convert to an object *)
					Map[Function[{gradient},
						If[MatchQ[gradient, Except[ObjectP[Object[Method]]]],
							Hash[gradient] /. cationHashDictionary,
							gradient
						]]
						, gradients]]
					, {
						cationColumnPrimeWithChannel[[All, 3]],
						cationColumnFlushWithChannel[[All, 3]]
					}
				];

				(*make our final resolution*)
				resolvedCationColumnPrimeTuples = cationColumnPrimeWithChannel;
				resolvedCationColumnPrimeTuples[[All, 3]] = resolvedCationColumnPrimeTableGradients;
				resolvedCationColumnFlushTuples = cationColumnFlushWithChannel;
				resolvedCationColumnFlushTuples[[All, 3]] = resolvedCationColumnFlushTableGradients;

				(*returned the resolved injection table*)
				resolvedCationInnerInjectionTable = cationInjectionTable;

				(*again, we must be mindful of injectiontable sample clashing*)
				resolvedCationInnerInjectionTable[[cationSamplePositions]] = If[!injectionTableCationSampleConflictQ,
					resolvedCationSampleTuples,
					(*otherwise, we do it by the lengths*)
					If[cationSampleLength > injectionTableCationSampleLength,
						resolvedCationSampleTuples[[1 ;; injectionTableCationSampleLength]],
						(*otherwise, should work*)
						resolvedCationSampleTuples
					]
				];

				resolvedCationInnerInjectionTable[[cationBlankPositions]] = resolvedCationBlankTuples;
				resolvedCationInnerInjectionTable[[cationStandardPositions]] = resolvedCationStandardTuples;
				resolvedCationInnerInjectionTable[[cationColumnPrimePositions]] = resolvedCationColumnPrimeTuples;
				resolvedCationInnerInjectionTable[[cationColumnFlushPositions]] = resolvedCationColumnFlushTuples;

				resolvedCationInnerInjectionTable

			],
			(*otherwise, we build it from the other options*)
			Module[{hashedCationGradient, cationSamplesAsTuples, cationStandardsAsTuples, cationStandardAsTuples, cationBlanksAsTuples, cationBlankAsTuples,
				cationColumnPrimeAsTuples, cationColumnFlushAsTuples, cationStandardPositions, cationBlankPositions, cationColumnRefreshPositions,
				cationGatheredInserts, cationGatheredInsertsFormatted, sortedCationInsertionTuples, cationGradientsConverted, cationStandardGradientsConverted,
				cationBlankGradientsConverted, cationColumnPrimeGradientsConverted, cationColumnFlushGradientsConverted, protoCationInjectionList,
				replacementCationList, replacedCationInjectionList, completeCationList},
				(*in this thread of the conditional we are building the injection table from scratch*)

				(*first we need all of the positional for the standards, blanks, and column refreshes *)

				(*for the gradient changes we can use the hashing dictionary to simplify things*)
				hashedCationGradient = cationGradient /. cationHashDictionary;

				(*convert the gradients if they're in tupled form to methods*)
				{cationGradientsConverted, cationStandardGradientsConverted, cationBlankGradientsConverted, cationColumnPrimeGradientsConverted,
					cationColumnFlushGradientsConverted} = MapThread[
					If[!MatchQ[#1, {} | Null],
						MapThread[Function[{gradient, overwriteQ},
							If[MatchQ[gradient, Except[ObjectP[Object[Method]]]],
								Hash[gradient] /. cationHashDictionary,
								(*check to see if we need to overwrite the method and generate a new one*)
								If[!overwriteQ, gradient, CreateID[Object[Method, IonChromatographyGradient]]]
							]],
							{#1, #2}
						]
					]&, {
						{cationGradient, cationStandardGradient, cationBlankGradient, cationColumnPrimeGradient, cationColumnFlushGradient},
						{overwriteCationGradient, overwriteCationStandardGradient, overwriteCationBlankGradient, Flatten@overwriteCationColumnPrimeGradient, Flatten@overwriteCationColumnFlushGradient}
					}
				];

				(*get the samples in to the tupled format for the list*)
				(*Type, Sample, AnalysisChannel, InjectionVolume, Gradient*)
				cationSamplesAsTuples = If[cationSampleExistsQ,
					MapThread[Function[{sample, injectionVolume, gradient},
						{Sample, sample, CationChannel, injectionVolume, gradient}
					], {ToList@cationSamples, cationInjectionVolume, cationGradientsConverted}],
					{}
				];

				(*do the same for the standards and blanks*)
				cationStandardsAsTuples = If[cationStandardExistsQ,
					MapThread[Function[{sample, injectionVolume, gradient},
						{Standard, sample, CationChannel, injectionVolume, gradient}
					], {ToList@cationStandard, cationStandardInjectionVolumes, cationStandardGradientsConverted}],
					{}
				];

				cationBlanksAsTuples = If[cationBlankExistsQ,
					MapThread[Function[{sample, injectionVolume, gradient},
						{Blank, sample, CationChannel, injectionVolume, gradient}
					], {ToList@cationBlank, cationBlankInjectionVolumes, cationBlankGradientsConverted}],
					{}
				];

				(*get the ColumnPrime and ColumnFlush in to the tupled format for the list*)
				cationColumnPrimeAsTuples = If[cationColumnQ && cationColumnPrimeQ,
					{ColumnPrime, CationChannel, Sequence @@ cationColumnPrimeGradientsConverted},
					{}
				];

				cationColumnFlushAsTuples = If[cationColumnQ && cationColumnFlushQ,
					{ColumnFlush, CationChannel, Sequence @@ cationColumnFlushGradientsConverted},
					{}
				];

				(* Based on StandardFrequency option, determine the positions where standards will run *)
				cationStandardPositions = If[!cationStandardExistsQ,
					{},

					Which[
						Length[ToList@cationStandard] > 0 && Length[ToList@cationSamples] > 0,

						DeleteDuplicates@Switch[cationStandardFrequency,
							None | Null, {},
							First, {1},
							Last, {Length[ToList@cationSamples] + 1},
							FirstAndLast, {1, Length[ToList@cationSamples] + 1},

							GradientChange,
							Module[{identicalGradientRuns},
								identicalGradientRuns = Most + Accumulate[Length /@ Split[hashedCationGradient]];
								Join[{1}, identicalGradientRuns + 1, {Length[ToList@cationSamples] + 1}]
							],

							GreaterP[0, 1],
							Range[1, Length[ToList@cationSamples], cationStandardFrequency]
						],

						Length[ToList@cationStandard] > 0 && Length[ToList@cationSamples] == 0,

						DeleteDuplicates@Switch[cationStandardFrequency,
							None | Null, {},
							First, {1},
							Last, {1},
							FirstAndLast, {1, 2},
							GradientChange, {1},
							GreaterP[0, 1], {1}
						],

						True, {}
					]
				];

				(* Based on BlankFrequency option, determine the positions where blanks will run *)
				cationBlankPositions = If[!cationBlankExistsQ,
					{},

					Which[
						Length[ToList@cationBlank] > 0 && Length[ToList@cationSamples] > 0,

						DeleteDuplicates@Switch[cationBlankFrequency,
							None | Null, {},
							First, {1},
							Last, {Length[ToList@cationSamples] + 1},
							FirstAndLast, {1, Length[ToList@cationSamples] + 1},

							GradientChange,
							Module[{identicalGradientRuns},
								identicalGradientRuns = Most + Accumulate[Length /@ Split[hashedCationGradient]];
								Join[{1}, identicalGradientRuns + 1, {Length[ToList@cationSamples] + 1}]
							],

							GreaterP[0, 1],
							Range[1, Length[ToList@cationSamples], cationBlankFrequency]
						],

						Length[ToList@cationBlank] > 0 && Length[ToList@cationSamples] == 0,

						DeleteDuplicates@Switch[cationBlankFrequency,
							None | Null, {},
							First, {1},
							Last, {1},
							FirstAndLast, {1, 2},
							GradientChange, {1},
							GreaterP[0, 1], {1}
						],

						True, {}
					]
				];

				(* Based on ColumnRefreshFrequency option, determine the positions where primes/flushes will run. Here we don't care about the initial ColumnPrime and terminal ColumnFlush. So we ignore the FirstAndLast *)
				cationColumnRefreshPositions = If[MatchQ[cationColumnRefreshFrequency, GreaterP[0, 1]],

					Range[1, Length[ToList@cationSamples], cationColumnRefreshFrequency],
					(*else nichts*)
					{}
				];

				(*Now we will figure out how to position these among the samples*)

				(*First create a gathered list of tuples. First entry in the tuple is the position, second entry is the placeholder information (BlankDummy, StandardDummy). We will rule replace these out eventually.*)
				cationGatheredInserts = GatherBy[Join[{#, CationColumnPrimeDummy}& /@ cationColumnRefreshPositions,
					{#, CationBlankDummy}& /@ cationBlankPositions,
					{#, CationStandardDummy}& /@ cationStandardPositions], First];

				(*format it so that it's more understandable and useable*)
				cationGatheredInsertsFormatted = {#[[1, 1]], #[[All, 2]]}& /@ cationGatheredInserts;

				(*then sort it*)
				sortedCationInsertionTuples = Reverse[SortBy[cationGatheredInsertsFormatted, First]];

				(*now insert into the sequence of samples*)
				protoCationInjectionList = If[MatchQ[cationSamplesAsTuples, {}] && !MatchQ[sortedCationInsertionTuples, {}],
					SortBy[sortedCationInsertionTuples, First][[All, 2]],
					Fold[Insert[#1, #2[[2]], #2[[1]]]&, cationSamplesAsTuples, sortedCationInsertionTuples]
				];

				replacementCationList = If[MatchQ[#, _ -> {}],
					Nothing,
					#
				]& /@
					{
						CationBlankDummy -> Sequence @@ cationBlanksAsTuples,
						CationStandardDummy -> Sequence @@ cationStandardsAsTuples,
						CationColumnPrimeDummy -> Sequence @@ cationColumnPrimeAsTuples
					};
				(*then rule replace the Dummys with our blanks, standards, and column primes*)
				replacedCationInjectionList = Flatten /@ Partition[SplitBy[Flatten[protoCationInjectionList /. replacementCationList], MatchQ[#, InjectionTableCleaningTypeP | InjectionTableSampleTypeP]&], 2];

				(*finally add the initial and final flushes if necessary*)
				completeCationList = Switch[cationColumnRefreshFrequency,
					FirstAndLast, Insert[Insert[replacedCationInjectionList, cationColumnPrimeAsTuples, 1], cationColumnFlushAsTuples, Length[replacedCationInjectionList] + 2],
					First, Insert[replacedCationInjectionList, cationColumnPrimeAsTuples, 1],
					Last, Insert[replacedCationInjectionList, cationColumnFlushAsTuples, Length[replacedCationInjectionList] + 1],
					_, replacedCationInjectionList
				]
			]
		]
	];


	(*there are two big paths here, the first is if the injection table is specified*)
	(*second is if the injection table is not specified and we need to build it from scratch*)
	resolvedElectrochemicalInjectionTable = If[!NullQ[channelSelection],
		{},

		If[electrochemicalInjectionTableSpecifiedQ,
			(*even though the injection table is specified, not all of the entries within may be (e.g. the sample, injection volume, column or gradient). We need to resolve all of these*)
			Module[{samplePositions, standardPositions, blankPositions, columnPrimePositions, columnFlushPositions, resolvedSampleTuples,
				resolvedStandardTuples, resolvedBlankTuples, columnPrimeAutomaticPositions, columnFlushAutomaticPositions, resolvedColumnPrimeTuples,
				resolvedColumnFlushTuples, semiResolvedColumnPrimeTuples, semiResolvedColumnFlushTuples, resolvedInnerInjectionTable,
				sampleInjectionTableTuples, sampleLength, injectionTableSampleLength, columnPrimeDictionary, columnFlushDictionary,
				columnPrimeAutomaticGradientPositions, columnFlushAutomaticGradientPositions, columnPrimeGradientResolution, columnFlushGradientResolution,
				resolvedColumnPrimeTableGradients, resolvedColumnFlushTableGradients, columnPrimeAutomaticWaveformPositions,
				columnFlushAutomaticWaveformPositions, columnPrimeAutomaticVoltagePositions, columnFlushAutomaticVoltagePositions,
				columnPrimeWaveformDictionary, columnFlushWaveformDictionary
			},

				(*first separate the injection table by the positions according to its type*)
				{samplePositions, standardPositions, blankPositions, columnPrimePositions, columnFlushPositions} = Map[
					Sequence @@@ Position[electrochemicalInjectionTable, {#, ___}]&
					, {Sample, Standard, Blank, ColumnPrime, ColumnFlush}];

				(*get the respective lengths*)
				sampleLength = Length[mySamples];
				injectionTableSampleLength = Length[samplePositions];

				(*now we can resolve the standard, blank, and standard tuples because of the 1:1 index matching*)
				{resolvedSampleTuples, resolvedStandardTuples, resolvedBlankTuples} = Map[
					Function[{entry},
						Module[{tableTuples, samples, injectionVolumes, gradients, voltageProfiles, waveformProfiles, overwriteBool, referenceElectrodeModes},

							(*split the entry*)
							{tableTuples, samples, injectionVolumes, gradients, voltageProfiles, waveformProfiles, overwriteBool, referenceElectrodeModes} = entry;

							(*if there is misalignment with the input samples and the injection table (i.e. if injectionTableSampleConflictQ is true), then the consequent mapthread become difficult.*)
							(*therefore, we must pad/truncate if needbe*)
							sampleInjectionTableTuples = If[!injectionTableSampleConflictQ,
								electrochemicalInjectionTable[[samplePositions]],
								(*otherwise, will pad or subtract based on the length*)
								Which[
									(*if the same length, then it's easy*)
									sampleLength == injectionTableSampleLength, electrochemicalInjectionTable[[samplePositions]],
									(*if sample is longer, then we'll pad with the automatic tuple*)
									sampleLength > injectionTableSampleLength, PadRight[electrochemicalInjectionTable[[samplePositions]], sampleLength, {{Sample, Automatic, Automatic, Automatic, Automatic, Automatic}}],
									(*otherwise, the injection sample length must be larger, so just take the subset*)
									(* First [[ ]] takes all the samples in the specified position; then the second [[ ]] takes only x number that matches the number of input samples *)
									True, electrochemicalInjectionTable[[samplePositions]][[1 ;; sampleLength]]
								]
							];

							(*first check if there is something here (e.g. no standards), in which case return an empty list*)
							If[MatchQ[{tableTuples, samples, injectionVolumes, gradients, voltageProfiles, waveformProfiles, overwriteBool}, {(Null | {})..}],
								{},
								(*otherwise map thread and fill these tuples*)
								MapThread[
									Function[{tableTuple, sample, injectionVolume, gradient, voltageProfile, waveformProfile, overwriteQ, electrodeMode},
										Module[{setSample, setInjectionVolume, gradientConverted, setGradient, setWaveformProfile, setVoltageProfile},

											(*check out much of the tupled is filled out*)
											(*Type, Sample, InjectionVolume, Column, Gradient*)
											setSample = If[MatchQ[tableTuple[[2]], Automatic],
												sample,
												tableTuple[[2]]
											];

											setInjectionVolume = If[MatchQ[tableTuple[[3]], Automatic],
												injectionVolume,
												tableTuple[[3]]
											];

											(*convert the gradient if it's in tupled form*)
											gradientConverted = If[MatchQ[gradient, Except[ObjectP[Object[Method, Gradient]]]],
												Hash[gradient] /. hashDictionary,
												gradient
											];

											setGradient = If[MatchQ[overwriteQ, {}] || !Sequence @@ overwriteQ,
												Switch[tableTuple[[4]],
													(*convert if need be*)
													Automatic, gradientConverted,
													_, tableTuple[[4]]
												],
												CreateID[Object[Method, Gradient]]
											];

											setWaveformProfile = If[MatchQ[tableTuple[[6]], Except[Automatic | Null]],

												(* Before setting waveform profile in the injection table, first look at the voltage profile in the injection table *)
												(* If it's already set then just set waveform profile to Null *)
												Null,

												If[MatchQ[tableTuple[[5]], Automatic],

													(* If the detection parameters have waveform objects already existing, then go ahead with the specified waveform *)
													If[
														MatchQ[waveformProfile], ObjectP[Object[Method, Waveform]] || MatchQ[waveformProfile, {{TimeP, ObjectP[Object[Method, Waveform]]}...}],
														waveformProfile,
														(* Otherwise, flatten it out and hash the waveform objects *)
														Which[
															(* If only one waveform is specified in the following pattern, hash it out directly *)
															MatchQ[waveformProfile, {{TimeP, VoltageP, BooleanP, BooleanP}...}],
															Hash[{waveformProfile, electrodeMode}] /. hashWaveformDictionary,

															(* If multiple waveforms are specified in the following pattern, then we only hash out the second part which is the waveform specification *)
															MatchQ[waveformProfile, {{TimeP, {{TimeP, VoltageP, BooleanP, BooleanP}...}...}...}],
															MapThread[
																{#1, Hash[{#2, #3}] /. hashWaveformDictionary}&,
																Join[Transpose[waveformProfile], {Repeat[electrodeMode, Length[waveformProfile]]}]
															],

															True,
															waveformProfile
														]
													],

													tableTuple[[5]]
												]
											];

											setVoltageProfile = If[MatchQ[tableTuple[[5]], Except[Automatic | Null]],

												(* Before setting waveform profile in the injection table, first look at the voltage profile in the injection table *)
												(* If it's already set then just set waveform profile to Null *)
												Null,

												If[MatchQ[tableTuple[[6]], Automatic],
													voltageProfile,
													tableTuple[[6]]
												]
											];

											(*return the resolved tuple*)
											{First@tableTuple, setSample, setInjectionVolume, setGradient, setWaveformProfile, setVoltageProfile}

										]]
									, {tableTuples, samples, injectionVolumes, gradients, voltageProfiles, waveformProfiles, overwriteBool, referenceElectrodeModes}]
							]
						]],
					{
						{sampleInjectionTableTuples, ToList@mySamples, injectionVolume, gradient, voltageProfile, waveformProfile, overwriteGradient, referenceElectrodeMode},
						{electrochemicalInjectionTable[[standardPositions]], ToList@standard, standardInjectionVolumes, standardGradient, standardVoltageProfile, standardWaveformProfile, overwriteStandardGradient, standardReferenceElectrodeMode},
						{electrochemicalInjectionTable[[blankPositions]], ToList@blank, blankInjectionVolumes, blankGradient, blankVoltageProfile, blankWaveformProfile, overwriteBlankGradient, blankReferenceElectrodeMode}
					}
				];

				(*create the resolved sub tables with the AnalysisChannels*)
				semiResolvedColumnPrimeTuples = electrochemicalInjectionTable[[columnPrimePositions]];
				semiResolvedColumnFlushTuples = electrochemicalInjectionTable[[columnFlushPositions]];

				(*we'll now resolve the gradients*)
				columnPrimeDictionary = Function[{primeGradient, columnPrimeOverwriteQ},
					If[!(Sequence @@ Flatten[columnPrimeOverwriteQ]),
						primeGradient,
						CreateID[Object[Method, Gradient]]
					]
				][columnPrimeGradient, overwriteColumnPrimeGradient];

				columnFlushDictionary = Function[{flushGradient, columnFlushOverwriteQ},
					If[!(Sequence @@ Flatten[columnFlushOverwriteQ]),
						flushGradient,
						CreateID[Object[Method, Gradient]]
					]
				][columnFlushGradient, overwriteColumnFlushGradient];

				(*find all of the automatic gradient positions for each*)
				columnPrimeAutomaticGradientPositions = Flatten@Position[electrochemicalInjectionTable[[columnPrimePositions]][[All, 2]], Automatic];
				columnFlushAutomaticGradientPositions = Flatten@Position[electrochemicalInjectionTable[[columnFlushPositions]][[All, 2]], Automatic];
				columnPrimeAutomaticWaveformPositions = Flatten@Position[electrochemicalInjectionTable[[columnPrimePositions]][[All, 3]], Automatic];
				columnFlushAutomaticWaveformPositions = Flatten@Position[electrochemicalInjectionTable[[columnFlushPositions]][[All, 3]], Automatic];
				columnPrimeAutomaticVoltagePositions = Flatten@Position[electrochemicalInjectionTable[[columnPrimePositions]][[All, 4]], Automatic];
				columnFlushAutomaticVoltagePositions = Flatten@Position[electrochemicalInjectionTable[[columnFlushPositions]][[All, 4]], Automatic];

				(*we'll now resolve the waveforms*)
				columnPrimeWaveformDictionary = Which[
					(* If the resolved column prime waveform profile also consists of method waveform objects, then we don't need to hash *)
					MatchQ[columnPrimeWaveformProfile, ObjectP[Object[Method, Waveform]]],
					columnPrimeWaveformProfile,

					MatchQ[columnPrimeWaveformProfile, {{TimeP, ObjectP[Object[Method, Waveform]]}...}],
					columnPrimeWaveformProfile,

					(* If not, then we do need to hash them *)
					(* If it's a single waveform, then we can directly hash it *)
					MatchQ[columnPrimeWaveformProfile, {{TimeP, VoltageP, BooleanP, BooleanP}...}],
					Hash[{columnPrimeWaveformProfile, columnPrimeReferenceElectrodeMode}] /. hashWaveformDictionary,

					(* If the profile contains more than one waveform, then we only hash the waveform specification part, aka second element in each list *)
					MatchQ[columnPrimeWaveformProfile, {{TimeP, {{TimeP, VoltageP, BooleanP, BooleanP}...}...}...}],
					MapThread[
						{#1, Hash[{#2, #3}] /. hashWaveformDictionary}&,
						Join[Transpose[columnPrimeWaveformProfile], {Repeat[columnPrimeReferenceElectrodeMode, Length[columnPrimeWaveformProfile]]}]
					]
				];

				(*we'll now resolve the waveforms*)
				columnFlushWaveformDictionary = Which[
					(* If the resolved column flush waveform profile also consists of method waveform objects, then we don't need to hash *)
					MatchQ[columnFlushWaveformProfile, ObjectP[Object[Method, Waveform]]],
					columnFlushWaveformProfile,

					MatchQ[columnFlushWaveformProfile, {{TimeP, ObjectP[Object[Method, Waveform]]}...}],
					columnFlushWaveformProfile,

					(* If not, then we do need to hash them *)
					(* If it's a single waveform, then we can directly hash it *)
					MatchQ[columnFlushWaveformProfile, {{TimeP, VoltageP, BooleanP, BooleanP}...}],
					Hash[{columnFlushWaveformProfile, columnFlushReferenceElectrodeMode}] /. hashWaveformDictionary,

					(* If the profile contains more than one waveform, then we only hash the waveform specification part, aka second element in each list *)
					MatchQ[columnFlushWaveformProfile, {{TimeP, {{TimeP, VoltageP, BooleanP, BooleanP}...}...}...}],
					MapThread[
						{#1, Hash[{#2, #3}] /. hashWaveformDictionary}&,
						Join[Transpose[columnFlushWaveformProfile], {Repeat[columnFlushReferenceElectrodeMode, Length[columnFlushWaveformProfile]]}]
					]
				];

				(*find the gradient for all these based on the column and dictionary*)
				semiResolvedColumnPrimeTuples[[columnPrimeAutomaticGradientPositions, 2]] = columnPrimeDictionary;
				semiResolvedColumnFlushTuples[[columnFlushAutomaticGradientPositions, 2]] = columnFlushDictionary;

				(*fill in the detection parameters for all column primes and column flushes*)
				semiResolvedColumnPrimeTuples[[columnPrimeAutomaticWaveformPositions, 3]] = columnPrimeWaveformDictionary;
				semiResolvedColumnFlushTuples[[columnFlushAutomaticWaveformPositions, 3]] = columnFlushWaveformDictionary;

				(*finally, we loop through and convert to a gradient object*)
				{resolvedColumnPrimeTableGradients, resolvedColumnFlushTableGradients} = Map[Function[{gradients},
					(*map through each and convert to an object *)
					Map[Function[{gradient},
						If[MatchQ[gradient, Except[ObjectP[Object[Method]]]],
							Hash[gradient] /. hashDictionary,
							gradient
						]]
						, gradients]]
					, {
						semiResolvedColumnPrimeTuples[[All, 2]],
						semiResolvedColumnFlushTuples[[All, 2]]
					}
				];

				(*make our final resolution*)
				resolvedColumnPrimeTuples = semiResolvedColumnPrimeTuples;
				resolvedColumnPrimeTuples[[All, 2]] = resolvedColumnPrimeTableGradients;
				resolvedColumnFlushTuples = semiResolvedColumnFlushTuples;
				resolvedColumnFlushTuples[[All, 2]] = resolvedColumnFlushTableGradients;

				(*returned the resolved injection table*)
				resolvedInnerInjectionTable = electrochemicalInjectionTable;

				(*again, we must be mindful of injectiontable sample clashing*)
				resolvedInnerInjectionTable[[samplePositions]] = If[!injectionTableSampleConflictQ,
					resolvedSampleTuples,
					(*otherwise, we do it by the lengths*)
					If[sampleLength > injectionTableSampleLength,
						resolvedSampleTuples[[1 ;; injectionTableSampleLength]],
						(*otherwise, should work*)
						resolvedSampleTuples
					]
				];

				resolvedInnerInjectionTable[[blankPositions]] = resolvedBlankTuples;
				resolvedInnerInjectionTable[[standardPositions]] = resolvedStandardTuples;
				resolvedInnerInjectionTable[[columnPrimePositions]] = resolvedColumnPrimeTuples;
				resolvedInnerInjectionTable[[columnFlushPositions]] = resolvedColumnFlushTuples;

				resolvedInnerInjectionTable
			],
			(*otherwise, we build it from the other options*)
			Module[{hashedGradient, hashedWaveform, hashedStandardWaveform, hashedBlankWaveform, hashedColumnPrimeWaveform,
				hashedColumnFlushWaveform, samplesAsTuples, standardsAsTuples, standardAsTuples, blanksAsTuples, blankAsTuples,
				columnPrimeAsTuples, columnFlushAsTuples, standardPositions, blankPositions, columnRefreshPositions,
				gatheredInserts, gatheredInsertsFormatted, sortedInsertionTuples, gradientsConverted, standardGradientsConverted,
				blankGradientsConverted, columnPrimeGradientsConverted, columnFlushGradientsConverted, protoInjectionList,
				replacementList, replacedInjectionList, completeList},
				(*in this thread of the conditional we are building the injection table from scratch*)

				(*first we need all of the positional for the standards, blanks, and column refreshes *)

				(*for the gradient changes we can use the hashing dictionary to simplify things*)
				hashedGradient = gradient /. hashDictionary;

				(* for the waveform changes, we need to break it down into categories and hash accordingly *)
				{hashedWaveform, hashedStandardWaveform, hashedBlankWaveform, hashedColumnPrimeWaveform, hashedColumnFlushWaveform} = Map[
					MapThread[
						Function[{waveform, electrodeMode},
							Which[
								(* If waveform profile already consists of method object, then we can use it directly *)
								MatchQ[waveform, ObjectP[Object[Method, Waveform]] | {{TimeP, ObjectP[Object[Method, Waveform]]}...}],
								waveform,

								MatchQ[waveform, {{TimeP, VoltageP, BooleanP, BooleanP}...}],
								Hash[{waveform, electrodeMode}] /. hashWaveformDictionary,

								MatchQ[waveform, {{TimeP, {{TimeP, VoltageP, BooleanP, BooleanP}...}...}...}],
								MapThread[
									{#1, Hash[{#2, #3}] /. hashWaveformDictionary}&,
									Join[Transpose[waveform], {Repeat[electrodeMode, Length[waveform]]}]
								]
							]
						],
						#
					]&,
					Transpose[{
						{waveformProfile, standardWaveformProfile, blankWaveformProfile, {columnPrimeWaveformProfile}, {columnFlushWaveformProfile}},
						{referenceElectrodeMode, standardReferenceElectrodeMode, blankReferenceElectrodeMode, {columnPrimeReferenceElectrodeMode}, {columnFlushReferenceElectrodeMode}}
					}]
				];

				(*convert the gradients if they're in tupled form to methods*)
				{gradientsConverted, standardGradientsConverted, blankGradientsConverted, columnPrimeGradientsConverted,
					columnFlushGradientsConverted} = MapThread[
					If[!MatchQ[#1, {} | Null],
						MapThread[Function[{gradient, overwriteQ},
							If[MatchQ[gradient, Except[ObjectP[Object[Method]]]],
								Hash[gradient] /. hashDictionary,
								(*check to see if we need to overwrite the method and generate a new one*)
								If[!overwriteQ, gradient, CreateID[Object[Method, Gradient]]]
							]],
							{#1, #2}
						]
					]&, {
						{gradient, standardGradient, blankGradient, columnPrimeGradient, columnFlushGradient},
						{overwriteGradient, overwriteStandardGradient, overwriteBlankGradient, overwriteColumnPrimeGradient, overwriteColumnFlushGradient}
					}
				];

				(*get the samples in to the tupled format for the list*)
				(*Type, Sample, AnalysisChannel, InjectionVolume, Gradient*)
				samplesAsTuples = MapThread[
					Function[{sample, injectionVolume, gradient, waveform, voltage},
						{Sample, sample, injectionVolume, gradient, waveform, voltage}
					],
					{ToList@mySamples, injectionVolume, gradientsConverted, hashedWaveform, voltageProfile}
				];

				(*do the same for the standards and blanks*)
				standardsAsTuples = If[standardExistsQ,
					MapThread[Function[{sample, injectionVolume, gradient, waveform, voltage},
						{Standard, sample, injectionVolume, gradient, waveform, voltage}
					], {ToList@standard, standardInjectionVolumes, standardGradientsConverted, hashedStandardWaveform, standardVoltageProfile}],
					{}
				];

				blanksAsTuples = If[blankExistsQ,
					MapThread[Function[{sample, injectionVolume, gradient, waveform, voltage},
						{Blank, sample, injectionVolume, gradient, waveform, voltage}
					], {ToList@blank, blankInjectionVolumes, blankGradientsConverted, hashedBlankWaveform, blankVoltageProfile}]
					, {}
				];

				(*get the ColumnPrime and ColumnFlush in to the tupled format for the list*)
				columnPrimeAsTuples = If[columnQ && columnPrimeQ,
					{ColumnPrime, Sequence @@ columnPrimeGradientsConverted, First@hashedColumnPrimeWaveform, columnPrimeVoltageProfile},
					{}
				];

				columnFlushAsTuples = If[columnQ && columnFlushQ,
					{ColumnFlush, Sequence @@ columnFlushGradientsConverted, First@hashedColumnFlushWaveform, columnFlushVoltageProfile},
					{}
				];

				(* Based on StandardFrequency option, determine the positions where standards will run *)
				standardPositions = If[!standardExistsQ,
					{},

					Which[
						Length[ToList@standard] > 0 && Length[ToList@mySamples] > 0,

						DeleteDuplicates@Switch[standardFrequency,
							None | Null, {},
							First, {1},
							Last, {Length[ToList@mySamples] + 1},
							FirstAndLast, {1, Length[ToList@mySamples] + 1},

							GradientChange,
							Module[{identicalGradientRuns},
								identicalGradientRuns = Most[Accumulate[Length /@ Split[hashedGradient]]];
								Join[{1}, identicalGradientRuns + 1, {Length[ToList@mySamples] + 1}]
							],

							GreaterP[0, 1],
							Range[1, Length[ToList@mySamples], standardFrequency]
						],

						Length[ToList@standard] > 0 && Length[ToList@mySamples] == 0,

						DeleteDuplicates@Switch[standardFrequency,
							None | Null, {},
							First, {1},
							Last, {1},
							FirstAndLast, {1, 2},
							GradientChange, {1},
							GreaterP[0, 1], {1}
						],

						True, {}
					]
				];

				(* Based on BlankFrequency option, determine the positions where blanks will run *)
				blankPositions = If[!blankExistsQ,
					{},

					Which[
						Length[ToList@blank] > 0 && Length[ToList@mySamples] > 0,

						DeleteDuplicates@Switch[blankFrequency,
							None | Null, {},
							First, {1},
							Last, {Length[ToList@mySamples] + 1},
							FirstAndLast, {1, Length[ToList@mySamples] + 1},

							GradientChange,
							Module[{identicalGradientRuns},
								identicalGradientRuns = Most[Accumulate[Length /@ Split[hashedGradient]]];
								Join[{1}, identicalGradientRuns + 1, {Length[ToList@mySamples] + 1}]
							],

							GreaterP[0, 1],
							Range[1, Length[ToList@mySamples], blankFrequency]
						],

						Length[ToList@blank] > 0 && Length[ToList@mySamples] == 0,

						DeleteDuplicates@Switch[blankFrequency,
							None | Null, {},
							First, {1},
							Last, {1},
							FirstAndLast, {1, 2},
							GradientChange, {1},
							GreaterP[0, 1], {1}
						],

						True, {}
					]
				];

				(* Based on ColumnRefreshFrequency option, determine the positions where primes/flushes will run. Here we don't care about the initial ColumnPrime and terminal ColumnFlush. So we ignore the FirstAndLast *)
				columnRefreshPositions = If[MatchQ[columnRefreshFrequency, GreaterP[0, 1]],

					Range[1, Length[ToList@mySamples], columnRefreshFrequency],
					(*else nichts*)
					{}
				];

				(*Now we will figure out how to position these among the samples*)

				(*First create a gathered list of tuples. First entry in the tuple is the position, second entry is the placeholder information (BlankDummy, StandardDummy). We will rule replace these out eventually.*)
				gatheredInserts = Join[{#, ColumnPrimeDummy}& /@ columnRefreshPositions,
					{#, BlankDummy}& /@ blankPositions,
					{#, StandardDummy}& /@ standardPositions];

				(*then sort it*)
				sortedInsertionTuples = Reverse[SortBy[gatheredInserts, First]];

				(*now insert into the sequence of samples*)
				protoInjectionList = If[MatchQ[samplesAsTuples, {}] && !MatchQ[sortedInsertionTuples, {}],
					Join @@ SortBy[sortedInsertionTuples, First][[All, 2]],
					Fold[Insert[#1, #2[[2]], #2[[1]]]&, samplesAsTuples, sortedInsertionTuples]
				];

				replacementList = If[MatchQ[#, _ -> {}],
					Nothing,
					#
				]& /@
					{
						BlankDummy -> Sequence @@ blanksAsTuples,
						StandardDummy -> Sequence @@ standardsAsTuples,
						ColumnPrimeDummy -> Sequence @@ columnPrimeAsTuples
					};
				(*then rule replace the Dummys with our blanks, standards, and column primes*)
				replacedInjectionList = protoInjectionList /. replacementList;

				(*finally add the initial and final flushes if necessary*)
				completeList = Switch[columnRefreshFrequency,
					FirstAndLast, Insert[Insert[replacedInjectionList, columnPrimeAsTuples, 1], columnFlushAsTuples, Length[replacedInjectionList] + 2],
					First, Insert[replacedInjectionList, columnPrimeAsTuples, 1],
					Last, Insert[replacedInjectionList, columnFlushAsTuples, Length[replacedInjectionList] + 1],
					_, replacedInjectionList
				]
			]
		]
	];



	(*do some error checking*)

	(*check to see if the injection volumes were specified in both the table and separately*)
	(*only have to worry about this if the injection table was specified*)
	anionSampleInjectionVolumeConflictQ = If[anionInjectionTableSpecifiedQ && !injectionTableAnionSampleConflictQ,
		Not[And @@ MapThread[#1 == #2&, {
			anionInjectionVolume,
			Cases[resolvedAnionInjectionTable, {Sample, ___}][[All, 4]]
		}]],
		False
	];
	cationSampleInjectionVolumeConflictQ = If[cationInjectionTableSpecifiedQ && !injectionTableCationSampleConflictQ,
		Not[And @@ MapThread[#1 == #2&, {
			cationInjectionVolume,
			Cases[resolvedCationInjectionTable, {Sample, ___}][[All, 4]]
		}]],
		False
	];
	sampleInjectionVolumeConflictQ = If[electrochemicalInjectionTableSpecifiedQ && !injectionTableSampleConflictQ,
		Not[And @@ MapThread[#1 == #2&, {
			injectionVolume,
			Cases[resolvedElectrochemicalInjectionTable, {Sample, ___}][[All, 3]]
		}]],
		False
	];
	anionStandardInjectionVolumeConflictQ = If[anionInjectionTableSpecifiedQ && anionStandardExistsQ,
		Not[And @@ MapThread[#1 == #2&, {
			anionStandardInjectionVolumes,
			Cases[resolvedAnionInjectionTable, {Standard, ___}][[All, 4]]
		}]],
		False
	];
	cationStandardInjectionVolumeConflictQ = If[cationInjectionTableSpecifiedQ && cationStandardExistsQ,
		Not[And @@ MapThread[#1 == #2&, {
			cationStandardInjectionVolumes,
			Cases[resolvedCationInjectionTable, {Standard, ___}][[All, 4]]
		}]],
		False
	];
	standardInjectionVolumeConflictQ = If[electrochemicalInjectionTableSpecifiedQ && standardExistsQ,
		Not[And @@ MapThread[#1 == #2&, {
			standardInjectionVolumes,
			Cases[resolvedElectrochemicalInjectionTable, {Standard, ___}][[All, 3]]
		}]],
		False
	];
	anionBlankInjectionVolumeConflictQ = If[anionInjectionTableSpecifiedQ && anionBlankExistsQ,
		Not[And @@ MapThread[#1 == #2&, {
			anionBlankInjectionVolumes,
			Cases[resolvedAnionInjectionTable, {Blank, ___}][[All, 4]]
		}]],
		False
	];
	cationBlankInjectionVolumeConflictQ = If[cationInjectionTableSpecifiedQ && cationBlankExistsQ,
		Not[And @@ MapThread[#1 == #2&, {
			cationBlankInjectionVolumes,
			Cases[resolvedCationInjectionTable, {Blank, ___}][[All, 4]]
		}]],
		False
	];
	blankInjectionVolumeConflictQ = If[electrochemicalInjectionTableSpecifiedQ && blankExistsQ,
		Not[And @@ MapThread[#1 == #2&, {
			blankInjectionVolumes,
			Cases[resolvedElectrochemicalInjectionTable, {Blank, ___}][[All, 3]]
		}]],
		False
	];

	(* if there is a mismatch between the Blank options and the injection table, throw an error *)
	injectionVolumeConflictOptions = If[messagesQ && Or[anionSampleInjectionVolumeConflictQ, cationSampleInjectionVolumeConflictQ, anionStandardInjectionVolumeConflictQ,
		cationStandardInjectionVolumeConflictQ, anionBlankInjectionVolumeConflictQ, cationBlankInjectionVolumeConflictQ],
		(
			Message[Error::InjectionVolumeConflict,
				PickList[{AnionInjectionVolume, CationInjectionVolume, InjectionVolume, AnionStandardInjectionVolume, CationStandardInjectionVolume, StandardInjectionVolume, AnionBlankInjectionVolume, CationBlankInjectionVolume, BlankInjectionVolume},
					{anionSampleInjectionVolumeConflictQ, cationSampleInjectionVolumeConflictQ, sampleInjectionVolumeConflictQ, anionStandardInjectionVolumeConflictQ, cationStandardInjectionVolumeConflictQ, standardInjectionVolumeConflictQ, anionBlankInjectionVolumeConflictQ, cationBlankInjectionVolumeConflictQ, blankInjectionVolumeConflictQ}]
			];
			PickList[{AnionInjectionVolume, CationInjectionVolume, InjectionVolume, AnionStandardInjectionVolume, CationStandardInjectionVolume, StandardInjectionVolume, AnionBlankInjectionVolume, CationBlankInjectionVolume, BlankInjectionVolume},
				{anionSampleInjectionVolumeConflictQ, cationSampleInjectionVolumeConflictQ, sampleInjectionVolumeConflictQ, anionStandardInjectionVolumeConflictQ, cationStandardInjectionVolumeConflictQ, standardInjectionVolumeConflictQ, anionBlankInjectionVolumeConflictQ, cationBlankInjectionVolumeConflictQ, blankInjectionVolumeConflictQ}]
		),
		{}
	];
	(* make a test for the blank injection table options *)
	injectionVolumeConflictTest = If[gatherTestsQ,
		Test["If both the injection table is specified as well as the injection volumes, there is no conflict:",
			Or[anionSampleInjectionVolumeConflictQ, cationSampleInjectionVolumeConflictQ, sampleInjectionVolumeConflictQ, anionStandardInjectionVolumeConflictQ, cationStandardInjectionVolumeConflictQ, standardInjectionVolumeConflictQ, anionBlankInjectionVolumeConflictQ, cationBlankInjectionVolumeConflictQ, blankInjectionVolumeConflictQ],
			False
		],
		Nothing
	];

	invalidOptions = Flatten[{injectionVolumeConflictOptions}];
	invalidTests = Flatten[{injectionVolumeConflictTest}];

	(*return the resolved injection table*)
	injectionTableResult = {resolvedAnionInjectionTable, resolvedCationInjectionTable, resolvedElectrochemicalInjectionTable};

	(* make the result and tests rules *)
	resultRule = Result -> {injectionTableResult, invalidOptions};
	testsRule = Tests -> invalidTests;

	outputSpecification /. {resultRule, testsRule}

];



(* ::Subsection:: *)
(*roundICGradientDetectionOptions*)

DefineOptions[roundICGradientDetectionOptions,
	Options :> {}
];

(* This helper function is based off of roundGradientOptions from SharedChromatography.m *)
(* During IonChromatography qualification, there are many gradients being passed into the resolver and this helper *)
(* It becomes a QuantityArray situation where this helper will take forever to run *)
(* So there are a few major changes in roundICGradientDetectionOptions compared to the original helper *)
(* 1. It will round gradient options specified in Millimolar instead of Percent *)
(* 2. It will pass in unitless option values for rounding *)
(* 3. In addition to rounding gradient options, it will also round detection options such as voltage profile *)
roundICGradientDetectionOptions[anionGradientOptions_, cationGradientOptions_, voltageOptions_, waveformOptions_, optionsAssociation_, gatherTests_, myOptions : OptionsPattern[]] := Module[{
	cationGradientTimeValuePositions, anionGradientTimeValuePositions, cationGradientPercentValuePositions, anionGradientConcentrationValuePositions,
	cationGradientFlowRateValuePositions, anionGradientFlowRateValuePositions, cationGradientTimeValueAssociation, anionGradientTimeValueAssociation,
	cationGradientPercentValueAssociation, anionGradientConcentrationValueAssociation, cationGradientFlowRateValueAssociation,
	anionGradientFlowRateValueAssociation, cationGradientTimeRoundedAssociation, cationGradientTimeRoundedTests, anionGradientTimeRoundedAssociation,
	anionGradientTimeRoundedTests, cationGradientPercentRoundedAssociation, cationGradientPercentRoundedTests, anionGradientConcentrationRoundedAssociation,
	anionGradientConcentrationRoundedTests, cationGradientFlowRateRoundedAssociation, cationGradientFlowRateRoundedTests, anionGradientFlowRateRoundedAssociation,
	anionGradientFlowRateRoundedTests, roundedCationGradientOptions, roundedAnionGradientOptions, roundedVoltageOptions, roundedWaveformOptions,
	flowRatePrecision, timePrecision, concentrationPrecision, voltagePrecision, waveformTimePrecision, percentPrecision, voltageTimeValuePositions,
	retentionTimeValuePositions, waveformTimeValuePositions, voltageValuePositions, voltageTimeValueAssociation, voltageValueAssociation, waveformVoltageValuePositions,
	retentionTimeValueAssociation, waveformTimeValueAssociation, waveformVoltageValueAssociation, voltageTimeRoundedAssociation,
	voltageTimeRoundedTests, voltageRoundedAssociation, voltageRoundedTests, retentionTimeRoundedAssociation, retentionTimeRoundedTests,
	waveformTimeRoundedAssociation, waveformTimeRoundedTests, waveformVoltageRoundedAssociation, waveformVoltageRoundedTests
},

	(*all precision setting*)
	flowRatePrecision = Unitless[10^-3 Milliliter / Minute];
	timePrecision = Unitless[10^-3 Minute];
	concentrationPrecision = Unitless[10^0 Millimolar];
	percentPrecision = Unitless[10^0 Percent];
	voltagePrecision = Unitless[10^-3 Volt];
	waveformTimePrecision = Unitless[10^-4 Second];


	(* Find all positions in the gradient options where a time exists *)
	cationGradientTimeValuePositions = Map[
		Position[ToList[#], GreaterEqualP[0 * Second], Infinity, Heads -> False]&,
		Lookup[optionsAssociation, cationGradientOptions]
	];
	anionGradientTimeValuePositions = Map[
		Position[ToList[#], GreaterEqualP[0 * Second], Infinity, Heads -> False]&,
		Lookup[optionsAssociation, anionGradientOptions]
	];

	(* Find all positions in the gradient options where a percent exists *)
	(*NOTE: using this weird pattern because GreaterEqualP[0*Percent] picks more *)
	cationGradientPercentValuePositions = Map[
		Position[ToList[#], _Quantity?PercentQ, Infinity, Heads -> False]&,
		Lookup[optionsAssociation, cationGradientOptions]
	];

	(* Find all positions in the gradient options where a flow rate exists *)
	anionGradientConcentrationValuePositions = Map[
		Position[ToList[#], GreaterEqualP[0 * Millimolar], Infinity, Heads -> False]&,
		Lookup[optionsAssociation, anionGradientOptions]
	];

	(* Find all positions in the gradient options where a flow rate exists *)
	cationGradientFlowRateValuePositions = Map[
		Position[ToList[#], GreaterEqualP[0 * Milliliter / Minute], Infinity, Heads -> False]&,
		Lookup[optionsAssociation, cationGradientOptions]
	];
	anionGradientFlowRateValuePositions = Map[
		Position[ToList[#], GreaterEqualP[0 * Milliliter / Minute], Infinity, Heads -> False]&,
		Lookup[optionsAssociation, anionGradientOptions]
	];

	(* Find all positions in the detection options where a time exist *)
	voltageTimeValuePositions = Map[
		Position[ToList[#], GreaterEqualP[0 * Second], Infinity, Heads -> False]&,
		Lookup[optionsAssociation, voltageOptions]
	];

	(* Find all positions in the detection options where a voltage exist *)
	voltageValuePositions = Map[
		Position[ToList[#], GreaterEqualP[0 * Volt], Infinity, Heads -> False]&,
		Lookup[optionsAssociation, voltageOptions]
	];

	(* Find all positions in the detection options where a time exist *)
	retentionTimeValuePositions = Map[
		Function[{optionValue},
			Module[{allTimes, groupedTimes, sortedIndiceTuples, indiceTuplesLength, splitIndiceTuples},

				(* This call will find all time entried in the waveform, including retention time and waveform time *)
				(* need to use the PatternUnion/TimeP stuff here because otherwise Mathematica's units system will get confused. *)
				(* Position[{Object[Method, Waveform, "id:12334"]}, GreaterEqualP[0 Minute], Infinity, Heads -> False] will correctly return {}, but it will think we need to check Quantity["id:12334"] which is nonsense. Doing the PatternUnion trick ensures we only check against actual times *)
				allTimes = Position[ToList[optionValue], PatternUnion[TimeP, GreaterEqualP[0 * Minute]], Infinity, Heads -> False];

				If[MatchQ[ToList[optionValue], ListableP[{{TimeP, ObjectP[Object[Method, Waveform]]}...}]],

					allTimes,

					(* We first group all the time found based on the index of the waveform where the time is pulled from *)
					(* All times pulled from the first waveform will have {1,___} form *)
					groupedTimes = GatherBy[allTimes, First];
					(* Once the times are grouped based on waveform, then we dig deeper to pick out the retention times and leave the waveform times behind *)

					(* Get the length of index from each waveform *)
					(* There is a few possible cases here we need to consider *)

					(* Case 1: Just one waveform, {{TimeP,VoltageP,BooleanP,BooleanP}...} *)
					(* The index tuples will look like {{{1, 1}}, {{2, 1}}, {{3, 1}}}, each element in the tuple will have a length of 2 *)

					(* Case 2: Just one waveform, {{TimeP,{{TimeP,VoltageP,BooleanP,BooleanP}...}}...} *)
					(* The index uptles will look like {{{1, 1}, {1, 2, 1, 1}, {1, 2, 2, 1}, {1, 2, 3, 1}}, {{2, 1}, {2, 2, 1, 1}, {2, 2, 2, 1}, {2, 2, 3, 1}}} *)
					(* The retention time will have a length of 2, the waveform time will have a length of 4 *)

					(* Case 3: Multiple waveforms, all in the form of {{TimeP,VoltageP,BooleanP,BooleanP}...} *)
					(* The index tuples will look like {{{1, 1, 1}, {1, 2, 1}, {1, 3, 1}}, {{2, 1, 1}, {2, 2, 1}, {2, 3, 1}}}, each element in the tuple will have a length of 3 *)

					(* Case 4: Multiple waveforms, all in the form of {{TimeP,{{TimeP,VoltageP,BooleanP,BooleanP}...}}...} *)
					(* The index tuples will look like {{{1, 1, 1}, {1, 1, 2, 1, 1}, {1, 1, 2, 2, 1}, {1, 1, 2, 3, 1}, {1, 2, 1}, {1, 2, 2, 1, 1}, {1, 2, 2, 2, 1}, {1, 2, 2, 3, 1}}, {{2, 1, 1}, {2, 1, 2, 1, 1}, {2, 1, 2, 2, 1}, {2, 1, 2, 3, 1}, {2, 2, 1}, {2, 2, 2, 1, 1}, {2, 2, 2, 2, 1}, {2, 2, 2, 3, 1}}} *)
					(* The retention time will have a length of 3, the waveform time will have a length of 5 *)

					(* Case 5: Multiple waveforms of mixed formats *)
					(* The index tuples will look like {{{1, 1, 1}, {1, 1, 2, 1, 1}, {1, 1, 2, 2, 1}, {1, 1, 2, 3, 1}, {1, 2,1}, {1, 2, 2, 1, 1}, {1, 2, 2, 2, 1}, {1, 2, 2, 3, 1}}, {{2, 1, 1}, {2, 2, 1}, {2, 3, 1}}} *)
					(* The retention time will have a length of 3 and the waveform time will have a length of 5 in the first list, and no retention time in the second list and all the waveform time have a length of 5 in the second list *)
					(* The logic here to pick out only the retention time is as follows *)

					(* In the grouped tuples, if all the lists have the same length, there's no retention time *)
					(* In the grouped tuples, if the lists have different lengths, then the retention time should be the ones with the shortest length *)

					(* First sort the indice tuples based on the length of the indice list *)
					sortedIndiceTuples = SortBy[#, Length]& /@ groupedTimes;
					(* Then further split the sorted list and look at how many tuples there are at each length *)
					splitIndiceTuples = SplitBy[#, Length]& /@ sortedIndiceTuples;
					indiceTuplesLength = Length /@ splitIndiceTuples;

					Join @@ MapThread[
						Which[
							#1 == 1,
							{},
							#1 > 1,
							#2[[1]]
						]&,
						{indiceTuplesLength, splitIndiceTuples}
					]
				]
			]
		],
		Lookup[optionsAssociation, waveformOptions]
	];

	waveformTimeValuePositions = Map[
		Function[{optionValue},
			Module[{allTimes, groupedTimes, sortedIndiceTuples, indiceTuplesLength, splitIndiceTuples},
				(* This call will find all time entried in the waveform, including retention time and waveform time *)
				(* need to use the PatternUnion/TimeP stuff here because otherwise Mathematica's units system will get confused. *)
				(* Position[{Object[Method, Waveform, "id:12334"]}, GreaterEqualP[0 Minute], Infinity, Heads -> False] will correctly return {}, but it will think we need to check Quantity["id:12334"] which is nonsense. Doing the PatternUnion trick ensures we only check against actual times *)
				allTimes = Position[ToList[optionValue], PatternUnion[TimeP, GreaterEqualP[0 * Minute]], Infinity, Heads -> False];

				If[MatchQ[ToList[optionValue], ListableP[{{TimeP, ObjectP[Object[Method, Waveform]]}...}]],

					{},
					(* We first group all the time found based on the index of the waveform where the time is pulled from *)
					(* All times pulled from the first waveform will have {1,___} form *)
					groupedTimes = GatherBy[allTimes, First];
					(* Once the times are grouped based on waveform, then we dig deeper to pick out the waveform times and leave the waveform times behind *)

					(* First sort the indice tuples based on the length of the indice list *)
					sortedIndiceTuples = SortBy[#, Length]& /@ groupedTimes;
					(* Then further split the sorted list and look at how many tuples there are at each length *)
					splitIndiceTuples = SplitBy[#, Length]& /@ sortedIndiceTuples;
					indiceTuplesLength = Length /@ splitIndiceTuples;

					MapThread[
						Which[
							#1 == 1,
							First[#2],
							#1 > 1,
							#2[[2]]
						]&,
						{indiceTuplesLength, splitIndiceTuples}
					]
				]
			]
		],
		Lookup[optionsAssociation, waveformOptions]
	];

	(* Find all positions in the detection options where a voltage exist *)
	(* need to use the PatternUnion/VoltageP stuff here because otherwise Mathematica's units system will get confused. *)
	(* Position[{Object[Method, Waveform, "id:12334"]}, GreaterEqualP[0 Volt], Infinity, Heads -> False] will correctly return {}, but it will think we need to check Quantity["id:12334"] which is nonsense. Doing the PatternUnion trick ensures we only check against actual voltages *)
	waveformVoltageValuePositions = Map[
		Position[ToList[#], PatternUnion[VoltageP, GreaterEqualP[0 * Volt]], Infinity, Heads -> False]&,
		Lookup[optionsAssociation, waveformOptions]
	];

	(* Build association with completely flattened time values.
      ex: {{{1 Minute, 30 Percent}, {2 Minute, 50 Percent}},{{1 Minute, 10 Percent},{10 Minute, 90 Percent}}}
      would transform to {1 Minute, 2 Minute, 1 Minute, 10 Minute} with gradientTimeValuePositions being:
      {{1,1,1},{1,2,1},{2,1,1},{2,2,1}} *)
	cationGradientTimeValueAssociation = Association@MapThread[
		Function[{optionName, indices},
			(optionName -> (Unitless[Convert[Extract[ToList[Lookup[optionsAssociation, optionName]], #], Minute]]& /@ indices))
		],
		{cationGradientOptions, cationGradientTimeValuePositions}
	];
	anionGradientTimeValueAssociation = Association@MapThread[
		Function[{optionName, indices},
			(optionName -> (Unitless[Convert[Extract[ToList[Lookup[optionsAssociation, optionName]], #], Minute]]& /@ indices))
		],
		{anionGradientOptions, anionGradientTimeValuePositions}
	];

	(* Build association with completely flattened percent/concentration values *)
	cationGradientPercentValueAssociation = Association@MapThread[
		Function[{optionName, indices},
			(optionName -> (Unitless[Extract[ToList[Lookup[optionsAssociation, optionName]], #]]& /@ indices))
		],
		{cationGradientOptions, cationGradientPercentValuePositions}
	];
	anionGradientConcentrationValueAssociation = Association@MapThread[
		Function[{optionName, indices},
			(optionName -> (Unitless[Extract[ToList[Lookup[optionsAssociation, optionName]], #]]& /@ indices))
		],
		{anionGradientOptions, anionGradientConcentrationValuePositions}
	];

	(* Build association with completely flattened flow rate values *)
	cationGradientFlowRateValueAssociation = Association@MapThread[
		Function[{optionName, indices},
			(optionName -> (Unitless[Extract[ToList[Lookup[optionsAssociation, optionName]], #]]& /@ indices))
		],
		{cationGradientOptions, cationGradientFlowRateValuePositions}
	];
	anionGradientFlowRateValueAssociation = Association@MapThread[
		Function[{optionName, indices},
			(optionName -> (Unitless[Extract[ToList[Lookup[optionsAssociation, optionName]], #]]& /@ indices))
		],
		{anionGradientOptions, anionGradientFlowRateValuePositions}
	];

	(* Build association with completely flattened time values *)
	voltageTimeValueAssociation = Association@MapThread[
		Function[{optionName, indices},
			(optionName -> (Unitless[Extract[ToList[Lookup[optionsAssociation, optionName]], #]]& /@ indices))
		],
		{voltageOptions, voltageTimeValuePositions}
	];

	(* Build association with completely flattened voltage values *)
	voltageValueAssociation = Association@MapThread[
		Function[{optionName, indices},
			(optionName -> (Unitless[Extract[ToList[Lookup[optionsAssociation, optionName]], #]]& /@ indices))
		],
		{voltageOptions, voltageValuePositions}
	];

	(* Build association with completely flattened time values *)
	retentionTimeValueAssociation = Association@MapThread[
		Function[{optionName, indices},
			(optionName -> (Unitless[Extract[ToList[Lookup[optionsAssociation, optionName]], #]]& /@ indices))
		],
		{waveformOptions, retentionTimeValuePositions}
	];
	waveformTimeValueAssociation = Association@MapThread[
		Function[{optionName, indices},
			(optionName -> (Unitless[Extract[ToList[Lookup[optionsAssociation, optionName]], #]]& /@ indices))
		],
		{waveformOptions, waveformTimeValuePositions}
	];

	(* Build association with completely flattened voltage values *)
	waveformVoltageValueAssociation = Association@MapThread[
		Function[{optionName, indices},
			(optionName -> (Unitless[Extract[ToList[Lookup[optionsAssociation, optionName]], #]]& /@ indices))
		],
		{waveformOptions, waveformVoltageValuePositions}
	];


	(* Pass built time association to get rounded values *)
	{cationGradientTimeRoundedAssociation, cationGradientTimeRoundedTests} = If[gatherTests,
		RoundOptionPrecision[
			cationGradientTimeValueAssociation,
			cationGradientOptions,
			Table[timePrecision, Length[cationGradientOptions]],
			Output -> {Result, Tests}
		],
		{
			RoundOptionPrecision[
				cationGradientTimeValueAssociation,
				cationGradientOptions,
				Table[timePrecision, Length[cationGradientOptions]]
			],
			{}
		}
	];

	{anionGradientTimeRoundedAssociation, anionGradientTimeRoundedTests} = If[gatherTests,
		RoundOptionPrecision[
			anionGradientTimeValueAssociation,
			anionGradientOptions,
			Table[timePrecision, Length[anionGradientOptions]],
			Output -> {Result, Tests}
		],
		{
			RoundOptionPrecision[
				anionGradientTimeValueAssociation,
				anionGradientOptions,
				Table[timePrecision, Length[anionGradientOptions]]
			],
			{}
		}
	];

	(* Pass built percent association to get rounded values *)
	{cationGradientPercentRoundedAssociation, cationGradientPercentRoundedTests} = If[gatherTests,
		RoundOptionPrecision[
			cationGradientPercentValueAssociation,
			cationGradientOptions,
			Table[percentPrecision, Length[cationGradientOptions]],
			Output -> {Result, Tests}
		],
		{
			RoundOptionPrecision[
				cationGradientPercentValueAssociation,
				cationGradientOptions,
				Table[percentPrecision, Length[cationGradientOptions]]
			],
			{}
		}
	];

	{anionGradientConcentrationRoundedAssociation, anionGradientConcentrationRoundedTests} = If[gatherTests,
		RoundOptionPrecision[
			anionGradientConcentrationValueAssociation,
			anionGradientOptions,
			Table[concentrationPrecision, Length[anionGradientOptions]],
			Output -> {Result, Tests}
		],
		{
			RoundOptionPrecision[
				anionGradientConcentrationValueAssociation,
				anionGradientOptions,
				Table[concentrationPrecision, Length[anionGradientOptions]]
			],
			{}
		}
	];

	(* Pass built flow rate association to get rounded values *)
	{cationGradientFlowRateRoundedAssociation, cationGradientFlowRateRoundedTests} = If[gatherTests,
		RoundOptionPrecision[
			cationGradientFlowRateValueAssociation,
			cationGradientOptions,
			Table[flowRatePrecision, Length[cationGradientOptions]],
			Output -> {Result, Tests}
		],
		{
			RoundOptionPrecision[
				cationGradientFlowRateValueAssociation,
				cationGradientOptions,
				Table[flowRatePrecision, Length[cationGradientOptions]]
			],
			{}
		}
	];

	{anionGradientFlowRateRoundedAssociation, anionGradientFlowRateRoundedTests} = If[gatherTests,
		RoundOptionPrecision[
			anionGradientFlowRateValueAssociation,
			anionGradientOptions,
			Table[flowRatePrecision, Length[anionGradientOptions]],
			Output -> {Result, Tests}
		],
		{
			RoundOptionPrecision[
				anionGradientFlowRateValueAssociation,
				anionGradientOptions,
				Table[flowRatePrecision, Length[anionGradientOptions]]
			],
			{}
		}
	];

	(* Pass built voltage time association to get rounded values *)
	{voltageTimeRoundedAssociation, voltageTimeRoundedTests} = If[gatherTests,
		RoundOptionPrecision[
			voltageTimeValueAssociation,
			voltageOptions,
			Table[timePrecision, Length[voltageOptions]],
			Output -> {Result, Tests}
		],
		{
			RoundOptionPrecision[
				voltageTimeValueAssociation,
				voltageOptions,
				Table[timePrecision, Length[voltageOptions]]
			],
			{}
		}
	];

	(* Pass built voltage association to get rounded values *)
	{voltageRoundedAssociation, voltageRoundedTests} = If[gatherTests,
		RoundOptionPrecision[
			voltageValueAssociation,
			voltageOptions,
			Table[voltagePrecision, Length[voltageOptions]],
			Output -> {Result, Tests}
		],
		{
			RoundOptionPrecision[
				voltageValueAssociation,
				voltageOptions,
				Table[voltagePrecision, Length[voltageOptions]]
			],
			{}
		}
	];

	(* Pass built retention time association to get rounded values *)
	{retentionTimeRoundedAssociation, retentionTimeRoundedTests} = If[gatherTests,
		RoundOptionPrecision[
			retentionTimeValueAssociation,
			waveformOptions,
			Table[timePrecision, Length[waveformOptions]],
			Output -> {Result, Tests}
		],
		{
			RoundOptionPrecision[
				retentionTimeValueAssociation,
				waveformOptions,
				Table[timePrecision, Length[waveformOptions]]
			],
			{}
		}
	];

	(* Pass built waveform time association to get rounded values *)
	{waveformTimeRoundedAssociation, waveformTimeRoundedTests} = If[gatherTests,
		RoundOptionPrecision[
			waveformTimeValueAssociation,
			waveformOptions,
			Table[waveformTimePrecision, Length[waveformOptions]],
			Output -> {Result, Tests}
		],
		{
			RoundOptionPrecision[
				waveformTimeValueAssociation,
				waveformOptions,
				Table[waveformTimePrecision, Length[waveformOptions]]
			],
			{}
		}
	];

	(* Pass built waveform time association to get rounded values *)
	{waveformVoltageRoundedAssociation, waveformVoltageRoundedTests} = If[gatherTests,
		RoundOptionPrecision[
			waveformVoltageValueAssociation,
			waveformOptions,
			Table[voltagePrecision, Length[waveformOptions]],
			Output -> {Result, Tests}
		],
		{
			RoundOptionPrecision[
				waveformVoltageValueAssociation,
				waveformOptions,
				Table[voltagePrecision, Length[waveformOptions]]
			],
			{}
		}
	];

	(* Rebuild the gradient options association by replacing the flat rounded values at the
    positions they were originally found in *)
	roundedCationGradientOptions = Association@MapThread[
		Function[{optionName, timePositions, percentPositions, flowRatePositions},
			optionName -> If[MatchQ[Lookup[optionsAssociation, optionName], _List],
				ReplacePart[
					Lookup[optionsAssociation, optionName],
					Join[
						MapThread[
							Rule,
							{timePositions, Lookup[cationGradientTimeRoundedAssociation, optionName] * Minute}
						],
						MapThread[
							Rule,
							{percentPositions, Lookup[cationGradientPercentRoundedAssociation, optionName] * Percent}
						],
						MapThread[
							Rule,
							{flowRatePositions, Lookup[cationGradientFlowRateRoundedAssociation, optionName] * Milliliter / Minute}
						]
					]
				],
				ReplacePart[
					ToList[Lookup[optionsAssociation, optionName]],
					Join[
						MapThread[
							Rule,
							{timePositions, Lookup[cationGradientTimeRoundedAssociation, optionName] * Minute}
						],
						MapThread[
							Rule,
							{percentPositions, Lookup[cationGradientPercentRoundedAssociation, optionName] * Percent}
						],
						MapThread[
							Rule,
							{flowRatePositions, Lookup[cationGradientFlowRateRoundedAssociation, optionName] * Milliliter / Minute}
						]
					]
				][[1]]
			]
		],
		{cationGradientOptions, cationGradientTimeValuePositions, cationGradientPercentValuePositions, cationGradientFlowRateValuePositions}
	];

	roundedAnionGradientOptions = Association@MapThread[
		Function[{optionName, timePositions, concentrationPositions, flowRatePositions},
			optionName -> If[MatchQ[Lookup[optionsAssociation, optionName], _List],
				ReplacePart[
					Lookup[optionsAssociation, optionName],
					Join[
						MapThread[
							Rule,
							{timePositions, Lookup[anionGradientTimeRoundedAssociation, optionName] * Minute}
						],
						MapThread[
							Rule,
							{concentrationPositions, Lookup[anionGradientConcentrationRoundedAssociation, optionName] * Millimolar}
						],
						MapThread[
							Rule,
							{flowRatePositions, Lookup[anionGradientFlowRateRoundedAssociation, optionName] * Milliliter / Minute}
						]
					]
				],
				ReplacePart[
					ToList[Lookup[optionsAssociation, optionName]],
					Join[
						MapThread[
							Rule,
							{timePositions, Lookup[anionGradientTimeRoundedAssociation, optionName] * Minute}
						],
						MapThread[
							Rule,
							{concentrationPositions, Lookup[anionGradientConcentrationRoundedAssociation, optionName] * Millimolar}
						],
						MapThread[
							Rule,
							{flowRatePositions, Lookup[anionGradientFlowRateRoundedAssociation, optionName] * Milliliter / Minute}
						]
					]
				][[1]]
			]
		],
		{anionGradientOptions, anionGradientTimeValuePositions, anionGradientConcentrationValuePositions, anionGradientFlowRateValuePositions}
	];

	roundedVoltageOptions = Association@MapThread[
		Function[{optionName, timePositions, voltagePositions},
			optionName -> If[MatchQ[Lookup[optionsAssociation, optionName], _List],
				ReplacePart[
					Lookup[optionsAssociation, optionName],
					Join[
						MapThread[
							Rule,
							{timePositions, Lookup[voltageTimeRoundedAssociation, optionName] * Minute}
						],
						MapThread[
							Rule,
							{voltagePositions, Lookup[voltageRoundedAssociation, optionName] * Volt}
						]
					]
				],
				ReplacePart[
					ToList[Lookup[optionsAssociation, optionName]],
					Join[
						MapThread[
							Rule,
							{timePositions, Lookup[voltageTimeRoundedAssociation, optionName] * Minute}
						],
						MapThread[
							Rule,
							{voltagePositions, Lookup[voltageRoundedAssociation, optionName] * Volt}
						]
					]
				][[1]]
			]
		],
		{voltageOptions, voltageTimeValuePositions, voltageValuePositions}
	];

	roundedWaveformOptions = Association@MapThread[
		Function[{optionName, retentionTimePositions, waveformTimePositions, waveformVoltagePositions},
			optionName -> If[MatchQ[Lookup[optionsAssociation, optionName], _List],
				ReplacePart[
					Lookup[optionsAssociation, optionName],
					Join[
						MapThread[
							Rule,
							{retentionTimePositions, Lookup[retentionTimeRoundedAssociation, optionName] * Minute}
						],
						Join @@ MapThread[
							Function[{timePosition, option},
								MapThread[
									Rule,
									{timePosition, ToList@option}
								]
							],
							{waveformTimePositions, Lookup[waveformTimeRoundedAssociation, optionName] * Second}
						],
						MapThread[
							Rule,
							{waveformVoltagePositions, Lookup[waveformVoltageRoundedAssociation, optionName] * Volt}
						]
					]
				],
				ReplacePart[
					ToList[Lookup[optionsAssociation, optionName]],
					Join[
						MapThread[
							Rule,
							{retentionTimePositions, Lookup[retentionTimeRoundedAssociation, optionName] * Minute}
						],
						MapThread[
							Rule,
							{waveformTimePositions, Lookup[waveformTimeRoundedAssociation, optionName] * Second}
						],
						MapThread[
							Rule,
							{waveformVoltagePositions, Lookup[waveformVoltageRoundedAssociation, optionName] * Volt}
						]
					]
				][[1]]
			]
		],
		{waveformOptions, retentionTimeValuePositions, waveformTimeValuePositions, waveformVoltageValuePositions}
	];

	(*return the rounded options and the tests*)
	{roundedCationGradientOptions, roundedAnionGradientOptions, roundedVoltageOptions, roundedWaveformOptions,
		Join[cationGradientTimeRoundedTests, anionGradientTimeRoundedTests, cationGradientPercentRoundedTests, anionGradientConcentrationRoundedTests,
			cationGradientFlowRateRoundedTests, anionGradientFlowRateRoundedTests, voltageTimeRoundedTests, voltageRoundedTests, retentionTimeRoundedTests,
			waveformTimeRoundedTests, waveformVoltageRoundedTests
		]}

];


(* ::Subsection::Closed:: *)
(*Sister Functions*)


(* ::Subsection::Closed:: *)
(*ExperimentIonChromatographyOptions*)


DefineOptions[ExperimentIonChromatographyOptions,
	Options :> {
		{
			OptionName -> OutputFormat,
			Default -> Table,
			AllowNull -> False,
			Widget -> Widget[Type -> Enumeration, Pattern :> Alternatives[Table, List]],
			Description -> "Indicates whether the function returns a table or a list of the options.",
			Category -> "Protocol"
		}
	},
	SharedOptions :> {ExperimentIonChromatography}
];

(*---Main function accepting sample/container objects as sample inputs and sample objects or Nulls as primer pair inputs---*)
ExperimentIonChromatographyOptions[
	mySamples : ListableP[ObjectP[{Object[Container], Object[Sample], Model[Sample]}] | _String],
	myOptions : OptionsPattern[ExperimentIonChromatographyOptions]
] := Module[
	{listedOptions, preparedOptions, resolvedOptions},

	(*Get the options as a list*)
	listedOptions = ToList[myOptions];

	(*Send in the correct Output option and remove the OutputFormat option*)
	preparedOptions = Normal@KeyDrop[Append[listedOptions, Output -> Options], {OutputFormat}];

	resolvedOptions = ExperimentIonChromatography[mySamples, preparedOptions];

	(* If options fail, return failure *)
	If[MatchQ[resolvedOptions, $Failed],
		Return[$Failed]
	];

	(*Return the option as a list or table*)
	If[MatchQ[Lookup[listedOptions, OutputFormat, Table], Table],
		LegacySLL`Private`optionsToTable[resolvedOptions, ExperimentIonChromatography],
		resolvedOptions
	]
];


(* ::Subsection::Closed:: *)
(*ValidExperimentIonChromatographyQ*)


DefineOptions[ValidExperimentIonChromatographyQ,
	Options :> {VerboseOption, OutputFormatOption},
	SharedOptions :> {ExperimentIonChromatography}
];

ValidExperimentIonChromatographyQ[mySamples : ListableP[ObjectP[{Object[Container], Object[Sample], Model[Sample]}] | _String], myOptions : OptionsPattern[ValidExperimentIonChromatographyQ]] := Module[
	{listedOptions, preparedOptions, ionChromatographyTests, initialTestDescription, allTests, verbose, outputFormat},

	(* Get the options as a list *)
	listedOptions = ToList[myOptions];

	(* Remove the output option before passing to the core function because it doesn't make sense here *)
	preparedOptions = DeleteCases[listedOptions, (Output | Verbose | OutputFormat) -> _];

	(* Return only the tests for ExperimentIonChromatography *)
	ionChromatographyTests = ExperimentIonChromatography[mySamples, Append[preparedOptions, Output -> Tests]];

	(* Define the general test description *)
	initialTestDescription = "All provided options and inputs match their provided patterns (no further testing can proceed if this test fails).";

	(*Make a list of all of the tests, including the blanket test *)
	allTests = If[MatchQ[ionChromatographyTests, $Failed],
		{Test[initialTestDescription, False, True]},
		Module[
			{initialTest, validObjectBooleans, voqWarnings, testResults},

			(* Generate the initial test, which we know will pass if we got this far (hopefully) *)
			initialTest = Test[initialTestDescription, True, True];

			(* Create warnings for invalid objects *)
			validObjectBooleans = ValidObjectQ[DeleteCases[ToList[mySamples], _String], OutputFormat -> Boolean];

			voqWarnings = MapThread[
				Warning[StringJoin[ToString[#1, InputForm], " is valid (run ValidObjectQ for more detailed information):"],
					#2,
					True
				]&,
				{DeleteCases[ToList[mySamples], _String], validObjectBooleans}
			];

			(* Get all the tests/warnings *)
			Flatten[{initialTest, ionChromatographyTests, voqWarnings}]
		]
	];

	(* Determine the Verbose and OutputFormat options; quiet the OptionValue::nodef message in case someone just passed nonsense *)
	{verbose, outputFormat} = Quiet[OptionDefault[OptionValue[{Verbose, OutputFormat}]], OptionValue::nodef];

	(* Run all the tests as requested *)
	Lookup[RunUnitTest[<|"ValidExperimentIonChromatographyQ" -> allTests|>, OutputFormat -> outputFormat, Verbose -> verbose], "ValidExperimentIonChromatographyQ"]

];


(* ::Subsection:: *)
(*ExperimentIonChromatographyPreview*)

DefineOptions[ExperimentIonChromatographyPreview,
	SharedOptions :> {ExperimentIonChromatography}
];

ExperimentIonChromatographyPreview[mySamples : ListableP[ObjectP[{Object[Container], Object[Sample], Model[Sample]}] | _String], myOptions : OptionsPattern[ExperimentIonChromatographyPreview]] := Module[
	{listedOptions},

	listedOptions = ToList[myOptions];

	ExperimentIonChromatography[mySamples, ReplaceRule[listedOptions, Output -> Preview]]
];
