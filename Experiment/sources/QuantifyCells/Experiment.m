(* ::Package:: *)

(* ::Text:: *)
(*\[Copyright] 2011-2024 Emerald Cloud Lab, Inc.*)


(* ::Subsection::Closed:: *)
(*ExperimentQuantifyCells Options*)



DefineOptions[ExperimentQuantifyCells,
	Options :> {
		(*------------------------------General------------------------------*)
		IndexMatching[
			IndexMatchingInput -> "experiment samples",
			{
				OptionName -> SampleLabel,
				Default -> Automatic,
				Description -> "A user defined word or phrase used to identify the input samples to be quantified, for use in downstream unit operations.",
				AllowNull -> False,
				Widget -> Widget[
					Type -> String,
					Pattern :> _String,
					Size -> Line
				],
				Category -> "General",
				UnitOperation -> True
			},
			{
				OptionName -> SampleContainerLabel,
				Default -> Automatic,
				Description -> "A user defined word or phrase used to identify the container of the input samples to be quantified, for use in downstream unit operations.",
				AllowNull -> False,
				Widget -> Widget[
					Type -> String,
					Pattern :> _String,
					Size -> Line
				],
				Category -> "General",
				UnitOperation -> True
			}
		],
		IndexMatching[
			IndexMatchingParent -> Methods,
			{
				OptionName -> Methods,
				Default -> Automatic,
				Description -> "The experimental instrumentation used to measure the cell concentration in the input cell samples. Instrumentation options include: 1) Absorbance, where the absorbance (at the provided Wavelength) of the cell sample is measured using a spectrophotometer or plate reader and then converted to QuantificationUnit using either the AbsorbanceStandardCurve or AbsorbanceStandardCoefficient; 2) Nephelometry, where the scattered light attenuation of the cell sample at 653 nm is measured using a nephelometer and then converted to QuantificationUnit using either the NephelometryStandardCurve or NephelometryStandardCoefficient. The order of methods dictates the order of operations when the protocol is executed in the lab.",
				ResolutionDescription -> "Automatically set to Absorbance if any Absorbance options are provided or Instruments is set to a Spectrophotometer or PlateReader. Automatically set to Nephelometry if any Nephelometry options are provided or Instruments is set to a Nephelometer. Otherwise, if QuantificationUnit is set, Methods is automatically set to the instrumentation capable of generating raw experimental results in that unit. If the QuantificationUnit cannot be directly generated by any instrumentation, Methods is automatically set to the instrumentation whose native output can be converted to the QuantificationUnit using the specified StandardCurve/StandardCoefficient, or using the standard curve found from cell models in the Composition of the input samples. Otherwise, Methods is automatically set to Absorbance.",
				AllowNull -> False,
				Widget -> Widget[
					Type -> Enumeration,
					Pattern :> CellQuantificationMethodP(* Absorbance | Nephelometry *)
				],
				Category -> "General"
			},
			{
				OptionName -> Instruments,
				Default -> Automatic,
				Description -> "The instrument used to measure the absorbance (at the provided Wavelength) or nephelometry (scattered light attenuation) for the input cell samples.",
				ResolutionDescription -> "Automatically set to include a spectrophotometer or plate reader model if Methods include Absorbance. Automatically set to include a nephelometer model if Methods include Nephelometry. Please see the documentation of ExperimentAbsorbanceIntensity and ExperimentNephelometry for more details on the how the instrument option is determined given the input cell samples and corresponding Absorbance/Nephelometry options.",
				AllowNull -> False,
				Widget -> Widget[
					Type -> Object,
					Pattern :> ObjectP[{
						(* AbsorbanceIntensity *)
						Model[Instrument, PlateReader], Object[Instrument, PlateReader],
						Model[Instrument, Spectrophotometer], Object[Instrument, Spectrophotometer],
						(* Nephelometry *)
						Model[Instrument, Nephelometer], Object[Instrument, Nephelometer]
					}],
					OpenPaths -> {
						{Object[Catalog, "Root"], "Instruments", "Spectrophotometers", "UV-Vis Spectrometers"},
						{Object[Catalog, "Root"], "Instruments", "Particle Analyzers", "Light Scattering Devices"}
					}
				],
				Category -> "General"
			},
			{
				(* this is an option that stores the calculated options from calling child experiment in Methods so we can use them to create the primitives in resource packet *)
				OptionName -> ResolvedMethodPrimitiveOptions,
				Default -> Automatic,
				Description -> "The options for each of the quantification method calculated by the child experiment functions.",
				AllowNull -> False,
				Widget -> Widget[
					Type -> Expression,
					Pattern :> {(_Rule | _RuleDelayed)...},
					Size -> Line
				],
				Category -> "Hidden"
			}
		],
		PreparationOption,
		WorkCellOption,
		ModifyOptions[
			AnalyticalNumberOfReplicatesOption,
			NumberOfReplicates,
			{
				Description -> "The number of times each of the input samples is analyzed using identical experimental parameters. If Absorbance/NephelometryAliquot is set to True, this specifies the number of replicate aliquots to prepare from each input cell sample under the same aliquot conditions.",
				Category -> "General"
			}
		],
		IndexMatching[
			IndexMatchingInput -> "experiment samples",
			(*------------------------------Post experiment------------------------------*)
			ModifyOptions[
				ExperimentAbsorbanceIntensity,
				RecoupSample,
				{
					Description -> "Indicates if the aliquots from the corresponding input cell samples used for quantification measurement are returned to those input cell samples after the protocol is completed."
				}
			],
			SamplesInStorageOption,
			(*------------------------------Analysis------------------------------*)
			{
				OptionName -> QuantificationUnit,
				Default -> Automatic,
				Description -> "The preferred unit of cell concentration to update the composition of the input sample after the quantification measurement. If the specified unit cannot be directly measured with the specified quantification Methods, Absorbance/NephelometryStandardCurve or Absorbance/NephelometryStandardCoefficient will be used to convert the raw experimental result. If the Absorbance/NephelometryStandardCurve or Absorbance/NephelometryStandardCoefficient information is neither provided nor available from the input samples' cell compositions, the unit that is directly measured with the specified quantification Methods will be used to update the composition. The final concentration used to update the composition is the mean value of any raw experimental results and any converted values from the raw experimental result in the unit of QuantificationUnit. If the QuantificationUnit is neither convertible nor directly measured by the quantification Methods, the composition of the input sample will not be updated. If the input sample contains more than one cell type, its composition will not be updated given that the quantification Methods only measure one overall quantity of all contents in the sample.",
				ResolutionDescription -> "Automatically set to \"EmeraldCell/Milliliter\" if a standard curve or standard coefficient is provided in StandardCurve/StandardCoefficient options or found from the input cell samples' cell Composition to convert the raw experimental result from Methods to \"EmeraldCell/Milliliter\". Otherwise, automatically set to \"OD600\".",
				AllowNull -> False,
				Widget -> Widget[
					Type -> Enumeration,
					Pattern :> CellQuantificationUnitStringP (*CellQuantificationUnitP*)
				],
				Category -> "Analysis"
			},
			(* --- Absorbance prefixes --- *)
			{
				OptionName -> AbsorbanceStandardCurve,
				Default -> Automatic,
				Description -> "The standard curve used to convert the raw experimental result, expressed in units of OD600 or AbsorbanceUnit, to the specified QuantificationUnit.",
				ResolutionDescription -> "Automatically set to the standard curve that is found from the input cell sample's cell Composition that can convert raw OD600 or AbsorbanceUnit to the target QuantificationUnit. Otherwise, automatically set to Null.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Object,
					Pattern :> ObjectP[Object[Analysis, StandardCurve]]
				],
				Category -> "Analysis"
			},
			{
				OptionName -> AbsorbanceStandardCoefficient,
				AllowNull -> True,
				Default -> Null,
				Description -> "The factor used to multiply the raw experimental result in units of OD600 or AbsorbanceUnit to the specified QuantificationUnit, assuming a linear relationship.",
				Widget -> Widget[
					Type -> Number,
					Pattern :> GreaterP[0]
				],
				Category -> "Analysis"
			},
			(* --- Nephelometry prefixes --- *)
			{
				OptionName -> NephelometryStandardCurve,
				Default -> Automatic,
				Description -> "The standard curve used to convert the raw experimental result, expressed in the unit of RelativeNephelometricUnit, to the specified QuantificationUnit.",
				ResolutionDescription -> "Automatically set to the standard curve that is found from the input cell sample's cell Composition that can convert raw RelativeNephelometricUnit to the target QuantificationUnit. Otherwise, automatically set to Null.",
				AllowNull -> True,
				Widget -> Widget[
					Type -> Object,
					Pattern :> ObjectP[Object[Analysis, StandardCurve]]
				],
				Category -> "Analysis"
			},
			{
				OptionName -> NephelometryStandardCoefficient,
				AllowNull -> True,
				Default -> Null,
				Description -> "The factor used to multiply the raw experimental result in units of RelativeNephelometricUnit to the specified QuantificationUnit, assuming a linear relationship.",
				Widget -> Widget[
					Type -> Number,
					Pattern :> GreaterP[0]
				],
				Category -> "Analysis"
			}
		],
		(*------------------------------Aliquoting------------------------------*)
		{
			OptionName -> MultiMethodAliquots,
			Default -> Shared,
			Description -> "Indicates if a single aliquot is taken from the input cell samples and reused in all quantification measurements (Shared) or if each measurement takes a new aliquot from the input cell samples (Individual).",
			AllowNull -> False,
			Widget -> Widget[
				Type -> Enumeration,
				Pattern :> MultiMethodAliquotsP
			],
			Category -> "General"
		},
		IndexMatching[
			IndexMatchingInput -> "experiment samples",
			(* --- Absorbance prefixes --- *)
			ModifyOptions[
				AliquotOptions,
				Aliquot,
				{
					OptionName -> AbsorbanceAliquot,
					AllowNull -> True,
					Description -> "Indicates if an aliquot is taken from the input cell sample or the aliquot from the previous quantification measurements (if any), and is used for the subsequent Absorbance measurement. If NumberOfReplicates is specified this indicates that the input samples will also be aliquoted that number of times."
				}
			],
			ModifyOptions[
				AliquotOptions,
				AssayBuffer,
				{
					OptionName -> AbsorbanceAssayBuffer,
					Description -> "The solution that is added to the aliquot taken from the input cell sample or the aliquot from the previous quantification measurements (if any). The volume of this solution added is the difference between the AbsorbanceAliquotAmount and the AbsorbanceAssayVolume."
				}
			],
			ModifyOptions[
				AliquotOptions,
				AliquotAmount,
				{
					OptionName -> AbsorbanceAliquotAmount,
					Description -> "The amount of the sample that is transferred from the input cell sample or the aliquot from the previous quantification measurements (if any) into the new aliquot.",
					Widget -> Alternatives[
						"Volume"->Widget[
							Type -> Quantity,
							Pattern :> RangeP[1 Microliter, $CuvetteMaxVolume],
							Units -> {1, {Microliter, {Microliter, Milliliter}}}
						],
						"All"->Widget[
							Type -> Enumeration,
							Pattern :> Alternatives[All]
						]
					]
				}
			],
			ModifyOptions[
				AliquotOptions,
				AssayVolume,
				{
					OptionName -> AbsorbanceAssayVolume,
					Description -> "The desired total volume of the aliquoted sample plus AbsorbanceAssayBuffer.",
					Widget -> Widget[
						Type->Quantity,
						Pattern:>RangeP[1 Microliter,$CuvetteMaxVolume],
						Units->{Milliliter,{Microliter,Milliliter}}
					]
				}
			]
		],
		ModifyOptions[
			AliquotOptions,
			AliquotContainer,
			{
				OptionName -> AbsorbanceAliquotContainer,
				Widget -> Alternatives[
					"Container" -> Widget[
						Type -> Object,
						Pattern :> ObjectP[{Model[Container], Object[Container]}],
						ObjectTypes -> {Model[Container], Object[Container]},
						OpenPaths -> {
							{
								Object[Catalog, "Root"],
								"Containers",
								"Plates",
								"PlateReader Assay Plates"
							},
							{
								Object[Catalog, "Root"],
								"Containers",
								"Cuvettes"
							}
						}
					],
					"Container with Index" -> {
						"Index" ->	Widget[
							Type -> Number,
							Pattern :> GreaterEqualP[1, 1]
						],
						"Container" -> Widget[
							Type -> Object,
							Pattern :> ObjectP[{Model[Container], Object[Container]}],
							ObjectTypes -> {Model[Container], Object[Container]},
							OpenPaths -> {
								{
									Object[Catalog, "Root"],
									"Containers",
									"Plates",
									"PlateReader Assay Plates"
								},
								{
									Object[Catalog, "Root"],
									"Containers",
									"Cuvettes"
								}
							}
						]
					},
					Adder[
						Alternatives[
							"Container" -> Widget[
								Type -> Object,
								Pattern :> ObjectP[{Model[Container], Object[Container]}],
								ObjectTypes -> {Model[Container], Object[Container]},
								OpenPaths -> {
									{
										Object[Catalog, "Root"],
										"Containers",
										"Plates",
										"PlateReader Assay Plates"
									},
									{
										Object[Catalog, "Root"],
										"Containers",
										"Cuvettes"
									}
								}
							],
							"Container with Index" -> {
								"Index" ->	Widget[
									Type -> Number,
									Pattern :> GreaterEqualP[1, 1]
								],
								"Container" -> Widget[
									Type -> Object,
									Pattern :> ObjectP[{Model[Container], Object[Container]}],
									ObjectTypes -> {Model[Container], Object[Container]},
									OpenPaths -> {
										{
											Object[Catalog, "Root"],
											"Containers",
											"Plates",
											"PlateReader Assay Plates"
										},
										{
											Object[Catalog, "Root"],
											"Containers",
											"Cuvettes"
										}
									}
								]
							}
						]
					]
				],
				Description -> "The desired type of container that is used to house the aliquot sample prior to the Absorbance measurement, with indices indicating grouping of samples in the same plates, if desired."
			}
		],
		ModifyOptions[
			AliquotOptions,
			DestinationWell,
			{
				OptionName -> AbsorbanceDestinationWell,
				Description -> "The desired position in the corresponding AbsorbanceAliquotContainer in which the aliquot sample will be placed."
			}
		],
		IndexMatching[
			IndexMatchingInput -> "experiment samples",
			ModifyOptions[
				AliquotOptions,
				AliquotSampleStorageCondition,
				{
					OptionName -> AbsorbanceAliquotSampleStorageCondition,
					Description -> "The non-default conditions under which any unused aliquot sample generated for Absorbance measurement is stored after the protocol is completed.",
					Widget -> Widget[Type->Enumeration,Pattern:>PostAnalysisCellSampleStorageTypeP|Disposal]
				}
			],
			(* --- Nephelometry prefixes --- *)
			ModifyOptions[
				AliquotOptions,
				Aliquot,
				{
					OptionName -> NephelometryAliquot,
					AllowNull -> True,
					Description -> "Indicates if an aliquot is taken from the input cell sample or the aliquot from the previous quantification measurements (if any), and is used for the subsequent Nephelometry measurement. If NumberOfReplicates is specified this indicates that the input samples will also be aliquoted that number of times."
				}
			],
			ModifyOptions[
				AliquotOptions,
				AssayBuffer,
				{
					OptionName -> NephelometryAssayBuffer,
					Description -> "The solution that is added to the aliquot taken from the input cell sample or the aliquot from the previous quantification measurements (if any). The volume of this solution added is the difference between the NephelometryAliquotAmount and the NephelometryAssayVolume."
				}
			],
			ModifyOptions[
				AliquotOptions,
				AliquotAmount,
				{
					OptionName -> NephelometryAliquotAmount,
					Description -> "The amount of the sample that is transferred from the input cell sample or the aliquot from the previous quantification measurements (if any) into the new aliquot.",
					Widget -> Alternatives[
						"Volume"->Widget[
							Type -> Quantity,
							Pattern :> RangeP[1 Microliter, $CuvetteMaxVolume],
							Units -> {1, {Microliter, {Microliter, Milliliter}}}
						],
						"All"->Widget[
							Type -> Enumeration,
							Pattern :> Alternatives[All]
						]
					]
				}
			],
			ModifyOptions[
				AliquotOptions,
				AssayVolume,
				{
					OptionName -> NephelometryAssayVolume,
					Description -> "The desired total volume of the aliquoted sample plus NephelometryAssayBuffer.",
					Widget -> Widget[
						Type->Quantity,
						Pattern:>RangeP[1 Microliter,$CuvetteMaxVolume],
						Units->{Milliliter,{Microliter,Milliliter}}
					]
				}
			]
		],
		ModifyOptions[
			AliquotOptions,
			AliquotContainer,
			{
				OptionName -> NephelometryAliquotContainer,
				Widget -> Alternatives[
					"Container" -> Widget[
						Type -> Object,
						Pattern :> ObjectP[{Model[Container], Object[Container]}],
						ObjectTypes -> {Model[Container], Object[Container]},
						OpenPaths -> {
							{
								Object[Catalog, "Root"],
								"Containers",
								"Plates",
								"PlateReader Assay Plates"
							}
						}
					],
					"Container with Index" -> {
						"Index" ->	Widget[
								Type -> Number,
								Pattern :> GreaterEqualP[1, 1]
							],
						"Container" -> Widget[
							Type -> Object,
							Pattern :> ObjectP[{Model[Container], Object[Container]}],
							ObjectTypes -> {Model[Container], Object[Container]},
							OpenPaths -> {
								{
									Object[Catalog, "Root"],
									"Containers",
									"Plates",
									"PlateReader Assay Plates"
								}
							}
						]
					},
					Adder[
						Alternatives[
							"Container" -> Widget[
								Type -> Object,
								Pattern :> ObjectP[{Model[Container], Object[Container]}],
								ObjectTypes -> {Model[Container], Object[Container]},
								OpenPaths -> {
									{
										Object[Catalog, "Root"],
										"Containers",
										"Plates",
										"PlateReader Assay Plates"
									}
								}
							],
							"Container with Index" -> {
								"Index" ->	Widget[
									Type -> Number,
									Pattern :> GreaterEqualP[1, 1]
								],
								"Container" -> Widget[
									Type -> Object,
									Pattern :> ObjectP[{Model[Container], Object[Container]}],
									ObjectTypes -> {Model[Container], Object[Container]},
									OpenPaths -> {
										{
											Object[Catalog, "Root"],
											"Containers",
											"Plates",
											"PlateReader Assay Plates"
										}
									}
								]
							}
						]
					]
				],
				Description -> "The desired type of container that is used to house the aliquot sample prior to the Nephelometry measurement, with indices indicating grouping of samples in the same plates, if desired."
			}
		],
		ModifyOptions[
			AliquotOptions,
			DestinationWell,
			{
				OptionName -> NephelometryDestinationWell,
				Description -> "The desired position in the corresponding NephelometryAliquotContainer in which the aliquot sample will be placed."
			}
		],
		IndexMatching[
			IndexMatchingInput -> "experiment samples",
			ModifyOptions[
				AliquotOptions,
				AliquotSampleStorageCondition,
				{
					OptionName -> NephelometryAliquotSampleStorageCondition,
					Description -> "The non-default conditions under which any unused aliquot sample generated for Nephelometry measurement is stored after the protocol is completed.",
					Widget -> Widget[Type->Enumeration,Pattern:>PostAnalysisCellSampleStorageTypeP|Disposal]
				}
			]
		],
		(*------------------------------Blank------------------------------*)
		(* --- Absorbance prefixes --- *)
		ModifyOptions[
			ExperimentAbsorbanceIntensity,
			BlankAbsorbance,
			{
				OptionName -> AbsorbanceBlankMeasurement,
				Default -> Automatic,
				AllowNull -> True,
				Description -> "Indicates if blank samples are prepared and measured prior to Absorbance measurement. The absorbance (at the provided Wavelength) of the blank samples are measured and background subtracted to account for any background signals.",
				Category->"Blanks"
			}
		],
		IndexMatching[
			IndexMatchingInput -> "experiment samples",
			ModifyOptions[
				ExperimentAbsorbanceIntensity,
				Blanks,
				{
					OptionName -> AbsorbanceBlank,
					Description -> "The source used to generate a blank sample used to account for the background signal prior to the Absorbance measurement of the cell samples of interest.",
					Category->"Blanks"
				}
			],
			ModifyOptions[
				ExperimentAbsorbanceIntensity,
				BlankVolumes,
				{
					OptionName -> AbsorbanceBlankVolume,
					Description -> "The volume of the blank that is transferred out and used for blank measurements prior to the Absorbance measurement. If AbsorbanceBlank is specified, AbsorbanceBlankVolume of Null indicates that the blanks are read inside their current containers. If AbsorbanceBlank is specified, AbsorbanceBlankVolume of a specific volume indicates the blanks are transferred to a container with the same model as the measurement container that holds the input cell samples or their aliquots for the Absorbance measurement.",
					Category->"Blanks"
				}
			]
		],
		(* --- Nephelometry prefixes --- *)
		ModifyOptions[
			ExperimentAbsorbanceIntensity,
			BlankAbsorbance,
			{
				OptionName -> NephelometryBlankMeasurement,
				Default -> Automatic,
				AllowNull -> True,
				Description -> "Indicates if blank samples are prepared and measured prior to Nephelometry measurement. The scattered light attenuation of the blank samples are measured and background subtracted to account for any background signals.",
				Category->"Blanks"
			}
		],
		IndexMatching[
			IndexMatchingInput -> "experiment samples",
			ModifyOptions[
				ExperimentAbsorbanceIntensity,
				Blanks,
				{
					OptionName -> NephelometryBlank,
					Description -> "The source used to generate a blank sample used to account for the background signal prior to the Nephelometry measurement of the cell samples of interest.",
					Category->"Blanks"
				}
			],
			ModifyOptions[
				ExperimentAbsorbanceIntensity,
				BlankVolumes,
				{
					OptionName -> NephelometryBlankVolume,
					Description -> "The volume of the blank that is transferred out and used for blank measurements prior to the Nephelometry measurement. If NephelometryBlank is specified, NephelometryBlankVolume of Null indicates that the blanks are read inside their current containers. If NephelometryBlank is specified, NephelometryBlankVolume of a specific volume indicates the blanks are transferred to a container with the same model as the measurement container that holds the input cell samples or their aliquots for the Nephelometry measurement.",
					Category->"Blanks"
				}
			]
		],
		(*------------------------------Sample handling------------------------------*)
		(* --- Absorbance prefixes --- *)
		ModifyOptions[
			ExperimentAbsorbanceIntensity,
			Temperature,
			{
				OptionName -> AbsorbanceAcquisitionTemperature,
				AllowNull -> True,
				Description -> "Indicates the temperature the cell samples are held at during data acquisition within the absorbance instrument.",
				Category -> "Absorbance Measurement"
			}
		],
		ModifyOptions[
			ExperimentAbsorbanceIntensity,
			EquilibrationTime,
			{
				OptionName -> AbsorbanceEquilibrationTime,
				Description -> "The length of time for which the cell samples are held at the requested temperature within the absorbance instrument before data acquisition.",
				Category -> "Absorbance Measurement"
			}
		],
		ModifyOptions[
			ExperimentAbsorbanceIntensity,
			TargetCarbonDioxideLevel,
			{
				OptionName -> AbsorbanceTargetCarbonDioxideLevel,
				Category -> "Absorbance Measurement"
			}
		],
		ModifyOptions[
			ExperimentAbsorbanceIntensity,
			TargetOxygenLevel,
			{
				OptionName -> AbsorbanceTargetOxygenLevel,
				Category -> "Absorbance Measurement"
			}
		],
		ModifyOptions[
			ExperimentAbsorbanceIntensity,
			AtmosphereEquilibrationTime,
			{
				OptionName -> AbsorbanceAtmosphereEquilibrationTime,
				Category -> "Absorbance Measurement"
			}
		],
		(* --- Nephelometry prefixes --- *)
		ModifyOptions[
			ExperimentNephelometry,
			Temperature,
			{
				OptionName -> NephelometryAcquisitionTemperature,
				AllowNull -> True,
				Description -> "Indicates the temperature the cell samples are held at during data acquisition within the nephelometer instrument.",
				Category -> "Nephelometry Measurement"
			}
		],
		ModifyOptions[
			ExperimentNephelometry,
			EquilibrationTime,
			{
				OptionName -> NephelometryEquilibrationTime,
				AllowNull -> True,
				Description -> "The length of time for which the cell samples are held at the requested temperature within the nephelometer instrument before data acquisition.",
				Category -> "Nephelometry Measurement"
			}
		],
		ModifyOptions[
			ExperimentNephelometry,
			TargetCarbonDioxideLevel,
			{
				OptionName -> NephelometryTargetCarbonDioxideLevel,
				Category -> "Nephelometry Measurement"
			}
		],
		ModifyOptions[
			ExperimentNephelometry,
			TargetOxygenLevel,
			{
				OptionName -> NephelometryTargetOxygenLevel,
				Category -> "Nephelometry Measurement"
			}
		],
		ModifyOptions[
			ExperimentNephelometry,
			AtmosphereEquilibrationTime,
			{
				OptionName -> NephelometryAtmosphereEquilibrationTime,
				Category -> "Nephelometry Measurement"
			}
		],
		(*------------------------------Absorbance Measurement------------------------------*)
		ModifyOptions[
			ExperimentAbsorbanceIntensity,
			NumberOfReadings,
			{
				Description -> "The number of times to acquire data from each input cell sample or its aliquot that is loaded into the instrument during the Absorbance measurement. Each data acquisition is performed on the same cell sample without reloading the instrument.",
				Category -> "Absorbance Measurement"
			}
		],
		ModifyOptions[
			ExperimentAbsorbanceIntensity,
			Methods,
			{
				OptionName -> AbsorbanceMethod,
				Widget -> Widget[
					Type -> Enumeration,
					Pattern :> Alternatives[PlateReader, Cuvette]
				],
				AllowNull -> True,
				Description -> "Indicates the type of container to be used to measure the absorbance of the input cell samples or its aliquot. PlateReader utilize an open well container that transverses light from top to bottom. Cuvette uses a square container with transparent sides to transverse light from the front to back at a fixed path length. Microfluidic uses small channels to load samples which are then gravity-driven towards chambers where light transverse from top to bottom and measured at a fixed path length.",
				Category -> "Absorbance Measurement"
			}
		],
		ModifyOptions[
			ExperimentAbsorbanceIntensity,
			SpectralBandwidth,
			{
				Description -> "When using the Cuvette Method, indicates the physical size of the slit from which light passes out from the monochromator. The narrower the bandwidth, the greater the resolution in measurements.",
				Category -> "Absorbance Measurement"
			}
		],
		IndexMatching[
			IndexMatchingInput -> "experiment samples",
			ModifyOptions[
				ExperimentAbsorbanceIntensity,
				Wavelength,
				{
					AllowNull -> True,
					Description -> "The specific wavelength which should be used to measure absorbance of the input cell samples or its aliquot.",
					Category -> "Absorbance Measurement"
				}
			]
		],
		(*------------------------------Nephelometry Measurement------------------------------*)
		ModifyOptions[
			ExperimentNephelometry,
			BeamAperture,
			{
				Default -> Automatic,
				AllowNull -> True,
				Description -> "The diameter of the opening allowing the source laser light to pass through to the cell sample. A larger BeamAperture allows more light to pass through to the sample, leading to a higher signal. A setting of 1.5 millimeters is recommended for all 384 and 96 well plates, and 2.5-3.5 millimeters for 48 or less well plates. For non-homogenous solutions, a higher BeamAperture is recommended, and for samples with a large meniscus effect, a smaller BeamAperture is recommended.",
				Category -> "Nephelometry Measurement"
			}
		],
		ModifyOptions[
			ExperimentNephelometry,
			BeamIntensity,
			{
				AllowNull -> True,
				Description -> "The percentage of the total amount of the laser source light passed through to reach the cell sample. For Solubility experiments, 80% is recommended, and for experiments with highly concentrated or highly turbid samples, such as those involving cells, a BeamIntensity of 10% is recommended.",
				Category -> "Nephelometry Measurement"
			}
		],
		ModifyOptions[
			ExperimentNephelometry,
			IntegrationTime,
			{
				AllowNull -> True,
				Description -> "The amount of time that scattered light is measured. Increasing the IntegrationTime leads to higher signal and noise intensity.",
				Category -> "Nephelometry Measurement"
			}
		],
		(*------------------------------Other Shared Options------------------------------*)
		ProtocolOptions,
		SimulationOption
	}
];


(* ::Subsection:: *)
(*ExperimentQuantifyCells*)

(* ::Subsubsection:: *)
(*ExperimentQuantifyCells messages*)


Error::DuplicatedMethods = "Quantification Methods: `1` are specified more than once in the Methods option. Please remove duplicates, make sure each quantification method is specified only once, or allow the option to be set automatically.";
Error::NoQuantifyCellsMethodToUse = "Methods option is not specified, but no possible method can be used based on the options specified. Options `1` are required options for using `2`, but are set to Null. Options `3` are required options for using `4`, but are set to Null. Please adjust the option values, or allow the options to be set automatically.";
Error::ConflictingMethodOptions = "Method-specific options are conflicting with the corresponding quantification methods: `1`. `2`Please adjust the option values, or allow the options to be set automatically.";
Warning::NoStandardCurveCoefficientAvailable = "For the following input object(s): `2` at indices: `1`, there is no standard curve/coefficient available to convert the raw experimental result generated by `3` to the target QuantificationUnit: `4`. `5`The protocol is still executable in lab but the composition of these samples will not be updated. If you wish the composition to be updated, please provide an alternative standard curve, or refer to the documentation of ExperimentQuantifyCells for how to obtain a standard curve empirically.";
Warning::AlternativeStandardCurveAvailable = "For the following input object(s): `2` at indices: `1`, `5`An alternative standard curve: `3` is found and will be used to convert the raw experimental result to the target QuantificationUnit: `4`. If you do not want to use this alternative standard curve, please provide another StandardCurve, or refer to the documentation of ExperimentQuantifyCells for how to obtain a standard curve empirically.";
Warning::RedundantStandardCurve = "For the following input object(s): `2` at indices: `1`, the specified standard curve: `4` in options: `3` will not be used while converting the raw experimental result to the target QuantificationUnit: `5` because the quantification unit is directly obtainable from this quantification method.";
Warning::RecoupContamination = "Because the following input object(s): `2` at indices: `1` contain cell components, setting RecoupSample to True can potentially result in cross-contamination from the aliquotted samples. It is strongly recommended to set RecoupSample to False while working with cell samples.";
Error::MissingQuantificationUnit = "For the following input object(s): `2` at indices: `1`, `3` are specified yet a QuantificationUnit is not provided. It is not possible to determine a suitable QuantificationUnit with StandardCoefficient alone. Please either remove the specified values for `3`, or specify the QuantifcationUnit at indices: `1`.";


(* ::Subsubsection:: *)
(*ExperimentQuantifyCells Constants*)

(* A information lookup that contain various information for options resolving with the following keys: *)

(*------------------------------REQUIRED KEYS------------------------------*)
(* Function (REQUIRED): which experiment head to call for the specific quantification method *)
(* Instrument (REQUIRED): types of instruments supported by the specific quantification method *)
(* RawDataField (REQUIRED): the field where the raw experimental data is stored in the corresponding Object[Data, Blah] *)
(* RawDataUnit (REQUIRED): the unit associated with the raw experimental data that is stored in the corresponding Object[Data, Blah] *)
(* DataField (REQUIRED): the field where the raw experimental data is stored in the output Object[Data, QuantifyCells] *)
(*------------------------------OPTIONAL KEYS------------------------------*)
(* OptionsMap (OPTIONAL): how to map the options from QuantifyCells to the child experiment head, this list identifies the options that need to be resolved by the child experiment function. *)
(* Note that if you wish some options to be resolved by the child experiment function, even they have the same option name as the child experiment function, you still need to explicitly add them to the OptionsMap in a fashion like:
OptionsMap -> {
	NumberOfReadings -> NumberOfReadings
	Wavelength -> Wavelength
	...
}
*)
(* OptionsDefault (OPTIONAL): default value for Automatic in QuantifyCells *)
(* ConstantOptions (OPTIONAL): any additional/constant options to pass to when calling the child experiment function, this can either be an option from QuantifyCells, or an option from the child experiment. *)


$QuantifyCellsMethodInformationLookup = <|
	Absorbance -> <|
		"Function" -> ExperimentAbsorbanceIntensity,
		"Instrument" -> {
			Model[Instrument, PlateReader], Object[Instrument, PlateReader],
			Model[Instrument, Spectrophotometer], Object[Instrument, Spectrophotometer]
		},
		"RawDataField" -> Absorbance,
		"RawDataUnit" -> AbsorbanceUnit,
		"DataField" -> Absorbances,
		"OptionsMap" -> {
			(* aliquot *)
			AbsorbanceAliquot -> Aliquot,
			AbsorbanceAssayBuffer -> AssayBuffer,
			AbsorbanceAliquotAmount -> AliquotAmount,
			AbsorbanceAssayVolume -> AssayVolume,
			AbsorbanceAliquotContainer -> AliquotContainer,
			AbsorbanceDestinationWell -> DestinationWell,
			AbsorbanceAliquotSampleStorageCondition -> AliquotSampleStorageCondition,
			(* blank *)
			AbsorbanceBlankMeasurement -> BlankAbsorbance,
			AbsorbanceBlank -> Blanks,
			AbsorbanceBlankVolume -> BlankVolumes,
			(* sample handling *)
			AbsorbanceAcquisitionTemperature -> Temperature,(* PlateReader-only*)
			AbsorbanceEquilibrationTime -> EquilibrationTime,(* PlateReader-only*)
			NumberOfReadings -> NumberOfReadings, (*For select plate readers *)
			(* measurement *)
			AbsorbanceTargetCarbonDioxideLevel -> TargetCarbonDioxideLevel, (* PlateReader-only*)
			AbsorbanceTargetOxygenLevel -> TargetOxygenLevel, (* PlateReader-only*)
			AbsorbanceAtmosphereEquilibrationTime -> AtmosphereEquilibrationTime, (* PlateReader-only*)
			AbsorbanceMethod -> Methods,
			SpectralBandwidth -> SpectralBandwidth, (*Cuvette-only*)
			Wavelength -> Wavelength
		},
		"OptionsDefault" -> {
			Wavelength -> 600 * Nanometer
		},
		(* List of options that cannot be Null if using this method. *)
		(* If any of these options gets set to Null, we resolve to not use the method if automatic *)
		"NotNullOptions" -> {
			AbsorbanceAliquot,
			AbsorbanceBlankMeasurement,
			AbsorbanceMethod,
			Wavelength
		}
	|>,
	Nephelometry -> <|
		"Function" -> ExperimentNephelometry,
		"Instrument" -> {
			Model[Instrument, Nephelometer], Object[Instrument, Nephelometer]
		},
		"RawDataField" -> Turbidities,
		"RawDataUnit" -> RelativeNephelometricUnit,
		"DataField" -> Turbidities,
		"OptionsMap" -> {
			(* aliquot *)
			NephelometryAliquot -> Aliquot,
			NephelometryAssayBuffer -> AssayBuffer,
			NephelometryAliquotAmount -> AliquotAmount,
			NephelometryAssayVolume -> AssayVolume,
			NephelometryAliquotContainer -> AliquotContainer,
			NephelometryDestinationWell -> DestinationWell,
			NephelometryAliquotSampleStorageCondition -> AliquotSampleStorageCondition,
			(* blank *)
			NephelometryBlankMeasurement -> BlankMeasurement,
			NephelometryBlank -> Blank,
			NephelometryBlankVolume -> BlankVolume,
			(* sample handling *)
			NephelometryAcquisitionTemperature -> Temperature,
			NephelometryEquilibrationTime -> EquilibrationTime,
			(* measurement *)
			NephelometryTargetCarbonDioxideLevel -> TargetCarbonDioxideLevel,
			NephelometryTargetOxygenLevel -> TargetOxygenLevel,
			NephelometryAtmosphereEquilibrationTime -> AtmosphereEquilibrationTime,
			BeamAperture -> BeamAperture,
			BeamIntensity -> BeamIntensity,
			IntegrationTime -> IntegrationTime
		},
		"OptionsDefault" -> {
			BeamIntensity -> 10 * Percent
		},
		(* List of options that cannot be Null if using this method *)
		(* If any of these options gets set to Null, we resolve to not use the method if automatic *)
		"NotNullOptions" -> {
			NephelometryAliquot,
			NephelometryBlankMeasurement,
			NephelometryAcquisitionTemperature,(* Can be Ambient, but Null will cause error in ExperimentNephelometry*)
			NephelometryEquilibrationTime,(* Can be 0 Second, but Null will cause error in ExperimentNephelometry*)
			BeamAperture,
			BeamIntensity,
			IntegrationTime
		}
	|>
|>;


(* Preferred experimental method order *)
(* this is the order of execution in lab when multiple methods are specified *)
$PreferredMethodOrder = {Absorbance, Nephelometry};

(* a flag whether debug mode is on *)
$QuantifyCellsDebugFlag = False;

(* This is used to convert CellQuantificationUnitP to its corresponding string form CellQuantificationUnitStringP *)
(* It cannot be simply converted using ToString as MM would smartly interpret "EmeraldCell/Milliliter" as "1 Cells per milliliter" *)
$CellQuantificationUnitToStringLookup = {
	UnitsP[EmeraldCell/Milliliter] -> "EmeraldCell/Milliliter",
	UnitsP[OD600] -> "OD600"
};

(* ::Subsubsection:: *)
(*Experiment function and overloads*)


(* --- Main Overload --- *)
ExperimentQuantifyCells[mySamples:ListableP[ObjectP[Object[Sample]]], myOptions:OptionsPattern[]] := Module[
	{
		outputSpecification, output, gatherTests, listedSamplesNamed, listedOptionsNamed, safeOpsNamed, safeOpsTests, listedSamples, safeOps, listedOptions, expandedListedSamples,
		validLengths, validLengthTests, templatedOptions, templateTests, inheritedOptions, expandedSafeOps, cache, simulation, userSpecifiedObjects, objectsExistQs,
		objectsExistTests, sampleFields, sampleModelFields, containerFields, containerModelFields, moleculeFields, standardCurveFields, instrumentFields, instrumentModelFields,
		specifiedBlankSamples, possibleAliquotContainers, allowedCuvettes, allStandardCurves, allInstrumentModels, specifiedInstruments, allDownloads, cacheBall, performSimulationQ,
		resolvedOptionsResult, resolvedOptions, resolvedOptionsTests, resolvedOptionsSimulation, collapsedResolvedOptions,
		collapsedResolvedOptionsNoHidden, optionsResolverOnly, returnEarlyQBecauseOptionsResolverOnly, returnEarlyQBecauseFailure, resourcePacketResults, resourcePacketSimulation, runTime,
		resourcePacketTests, resolvedPreparation, simulationAfterResourcePacket,
		simulatedProtocol, quantifyCellsSimulation, protocolObject
	},

	(* Determine the requested return value from the function *)
	outputSpecification = Quiet[OptionValue[Output]];
	output = ToList[outputSpecification];

	(* Determine if we should keep a running list of tests *)
	gatherTests = MemberQ[output, Tests];

	(* Remove temporal links *)
	{listedSamplesNamed, listedOptionsNamed} = removeLinks[ToList[mySamples], ToList[myOptions]];

	(* There is no sample prep options so no sample prep simulation for cell bio experiments *)
	(* Call SafeOptions to make sure all options match pattern *)
	{safeOpsNamed, safeOpsTests} = If[gatherTests,
		SafeOptions[ExperimentQuantifyCells, listedOptionsNamed, AutoCorrect -> False, Output -> {Result, Tests}],
		{SafeOptions[ExperimentQuantifyCells, listedOptionsNamed, AutoCorrect -> False], {}}
	];

	(* replace all objects referenced by Name to ID *)
	{listedSamples, safeOps, listedOptions} = sanitizeInputs[listedSamplesNamed, safeOpsNamed, listedOptionsNamed, Simulation->Lookup[safeOpsNamed, Simulation, Null]];

	(* If the specified options don't match their patterns or if option lengths are invalid return $Failed *)
	If[MatchQ[safeOps, $Failed],
		Return[outputSpecification /. {
			Result -> $Failed,
			Tests -> safeOpsTests,
			Options -> $Failed,
			Preview -> Null,
			Simulation -> Null
		}]
	];

	(* Call ValidInputLengthsQ to make sure all options are the right length *)
	{validLengths, validLengthTests} = If[gatherTests,
		ValidInputLengthsQ[ExperimentQuantifyCells, {listedSamples}, listedOptions, Output -> {Result, Tests}],
		{ValidInputLengthsQ[ExperimentQuantifyCells, {listedSamples}, listedOptions], Null}
	];

	(* If option lengths are invalid return $Failed (or the tests up to this point) *)
	If[!validLengths,
		Return[outputSpecification /. {
			Result -> $Failed,
			Tests -> Join[safeOpsTests, validLengthTests],
			Options -> $Failed,
			Preview -> Null,
			Simulation -> Null
		}]
	];

	(* Use any template options to get values for options not specified in myOptions *)
	{templatedOptions, templateTests} = If[gatherTests,
		ApplyTemplateOptions[ExperimentQuantifyCells, {listedSamples}, listedOptions, Output -> {Result, Tests}],
		{ApplyTemplateOptions[ExperimentQuantifyCells, {listedSamples}, listedOptions], Null}
	];

	(* Return early if the template cannot be used - will only occur if the template object does not exist. *)
	If[MatchQ[templatedOptions, $Failed],
		Return[outputSpecification /. {
			Result -> $Failed,
			Tests -> Join[safeOpsTests, validLengthTests, templateTests],
			Options -> $Failed,
			Preview -> Null,
			Simulation -> Null
		}]
	];

	(* Replace our safe options with our inherited options from our template. *)
	inheritedOptions = ReplaceRule[safeOps, templatedOptions];

	(* Expand index-matching options *)
	{{expandedListedSamples}, expandedSafeOps} = ExpandIndexMatchedInputs[ExperimentQuantifyCells, {listedSamples}, inheritedOptions, ExpandReplicates -> True];

	(* Fetch the Cache options *)
	cache = Lookup[expandedSafeOps, Cache, {}];

	(* Fetch the Simulation options *)
	simulation = Lookup[expandedSafeOps, Simulation, Null];

	(* Disallow Upload->False and Confirm->True. *)
	(* Not making a test here because Upload is a hidden option and we don't currently make tests for hidden options. *)
	If[MatchQ[Lookup[safeOps, Upload], False] && TrueQ[Lookup[safeOps, Confirm]],
		Message[Error::ConfirmUploadConflict];
		Return[outputSpecification /. {
			Result -> $Failed,
			Tests -> Flatten[{safeOpsTests, validLengthTests, templateTests}],
			Options -> $Failed,
			Preview -> Null,
			Simulation -> simulation
		}]
	];

	(* Make sure that all of our objects exist before downloading and going to resolver. Remove Cache and Simulation key to exclude objects that exist in the packets *)
	userSpecifiedObjects = DeleteDuplicates@Cases[
		{ToList[mySamples], KeyDrop[ToList[myOptions], {Cache, Simulation}]},
		ObjectP[],
		Infinity
	];

	objectsExistQs = DatabaseMemberQ[userSpecifiedObjects, Simulation -> simulation];

	(* Build tests for object existence. *)
	objectsExistTests = If[gatherTests,
		MapThread[
			Test[StringTemplate["Specified object `1` exists in the database:"][#1], #2, True]&,
			{userSpecifiedObjects, objectsExistQs}
		],
		{}
	];

	(* If objects do not exist, return failure *)
	If[!(And @@ objectsExistQs),
		If[!gatherTests,
			Message[Error::ObjectDoesNotExist, PickList[userSpecifiedObjects, objectsExistQs, False]];
			Message[Error::InvalidInput, PickList[userSpecifiedObjects, objectsExistQs, False]]
		];
		Return[outputSpecification /. {
			Result -> $Failed,
			Tests -> Join[safeOpsTests, validLengthTests, templateTests, objectsExistTests],
			Options -> $Failed,
			Preview -> Null,
			Simulation -> simulation
		}]
	];

	(*-- DOWNLOAD THE INFORMATION THAT WE NEED FOR OUR OPTION RESOLVER AND RESOURCE PACKET FUNCTION --*)
	(* Fields we need for different samples/containers/molecules *)
	sampleFields = DeleteDuplicates[Flatten[{CellType, Status, State, Model, Composition, Analytes, Media, Solvent, Container, IncompatibleMaterials, Well, RequestedResources, SamplePreparationCacheFields[Object[Sample], Format -> Sequence]}]];
	sampleModelFields = DeleteDuplicates[Flatten[{CellType, Deprecated, Products, UsedAsSolvent, ConcentratedBufferDiluent, ConcentratedBufferDilutionFactor, BaselineStock, IncompatibleMaterials, SamplePreparationCacheFields[Model[Sample]]}]];
	containerFields = DeleteDuplicates[Flatten[{SamplePreparationCacheFields[Object[Container]], ModelName, MaxVolume, MinVolume, NumberOfWells, WellDiameter, WellDimensions, WellColor}]];
	containerModelFields = SamplePreparationCacheFields[Model[Container]];
	moleculeFields = DeleteDuplicates[Flatten[{StandardCurves, StandardCurveProtocols, Molecule, ExtinctionCoefficients, PolymerType, MolecularWeight, IncubationTemperature, Density}]];
	standardCurveFields = DeleteDuplicates[Flatten[{DateCreated, InversePrediction, BestFitFunction, Protocol, StandardDataUnits}]];
	instrumentFields = {Model, Status, WettedMaterials, PlateReaderMode, SamplingPatterns, IntegratedLiquidHandler};
	instrumentModelFields = {WettedMaterials, PlateReaderMode, SamplingPatterns, IntegratedLiquidHandlers};

	(* get unique blanks for download *)
	specifiedBlankSamples = DeleteDuplicates[Cases[Flatten[Lookup[listedOptions, {NephelometryBlank, AbsorbanceBlank}]], ObjectP[{Object[Sample], Model[Sample]}]]];
	(* get the container we'll use for aliquots *)
	possibleAliquotContainers = Join[
		DeleteDuplicates[Cases[Flatten[Lookup[listedOptions, {NephelometryAliquotContainer, AbsorbanceAliquotContainer}]], ObjectP[{Object[Container, Model[Container]]}]]],
		{First[BMGCompatiblePlates[Nephelometry]]},
		{First[BMGCompatiblePlates[Absorbance]]},
		absorbanceAllowedCuvettes
	];
	allowedCuvettes = absorbanceAllowedCuvettesForAutomaticResolution["Memoization"];
	(* find any specified standard curves *)
	allStandardCurves = DeleteDuplicates[Cases[Flatten[Lookup[listedOptions, {AbsorbanceStandardCurve, NephelometryStandardCurve}]], ObjectP[Object[Analysis, StandardCurve]]]];
	(* Search for all plate reader models; we may need this to help resolve options *)
	allInstrumentModels = Join[Search[Model[Instrument, PlateReader], Deprecated != True && PlateReaderMode == {ExperimentAbsorbanceIntensity, AbsorbanceIntensity}], Search[Model[Instrument, Spectrophotometer], Deprecated != True && ElectromagneticRange == UV]];
	(* get all specified instruments *)
	specifiedInstruments = DeleteDuplicates[Cases[Flatten[Lookup[listedOptions, {Instruments}]], ObjectP[{Object[Instrument], Model[Instrument]}]]];

	If[TrueQ[$QuantifyCellsDebugFlag], time1 = Now;Echo["Big Download started at "<>DateString[time1], "Big Download"]];

	allDownloads = Quiet[
		Download[
			{
				listedSamples,
				allStandardCurves,
				specifiedBlankSamples,
				possibleAliquotContainers,
				allowedCuvettes,
				allInstrumentModels,
				specifiedInstruments
			},
			{
				{
					Evaluate[Packet @@ sampleFields],
					Packet[Model[sampleModelFields]],
					Packet[Composition[[All, 2]][moleculeFields]],
					(* Note: if adding any fields here for checkConvertible on standard curves, please add it to the download for ExperimentIncubateCells as well *)
					Packet[Composition[[All, 2]][StandardCurves][standardCurveFields]],
					Packet[Composition[[All, 2]][StandardCurves][Protocol][Instrument, Wavelengths]],
					Packet[Composition[[All, 2]][StandardCurves][Protocol][Instrument][instrumentFields]],
					Packet[Composition[[All, 2]][StandardCurves][Protocol][Instrument][Model][instrumentModelFields]],
					Packet[Container[containerFields]],
					Packet[Container[Model][containerModelFields]]
				},
				{
					Evaluate[Packet @@ standardCurveFields],
					Packet[Protocol[Instrument, Wavelengths]],
					Packet[Protocol[Instrument][instrumentFields]],
					Packet[Protocol[Instrument][Model][instrumentModelFields]]
				},
				{Packet[Container, State], Packet[Container[{Model}]], Packet[Container[Model][{MaxVolume, RecommendedFillVolume}]]},
				{Evaluate[Packet @@ containerFields], Evaluate[Packet @@ containerModelFields], Packet[Model[containerModelFields]]},
				{Evaluate[Packet @@ containerModelFields]},
				{Evaluate[Packet @@ instrumentModelFields]},
				{Evaluate[Packet @@ instrumentFields], Evaluate[Packet @@ instrumentModelFields], Packet[Model[instrumentModelFields]], Packet[IntegratedLiquidHandler[Model]], Packet[IntegratedLiquidHandler[Model][Object]], Packet[IntegratedLiquidHandlers[Object]]}
			},
			Cache -> cache,
			Simulation -> simulation
		],
		{Download::FieldDoesntExist, Download::NotLinkField}
	];

	If[TrueQ[$QuantifyCellsDebugFlag], time2 = Now;Echo["Big Download took "<>ToString[Convert[time2 - time1, Second]]<>" to finish!", "Big Download"]];

	cacheBall = FlattenCachePackets[{allDownloads, cache}];

	(* Build the resolved options, note that b/c 80 Percent of the work that QuantifyCells does is to call child experiment ExperimentAbsorbanceIntensity, and ExperimentNephelometry, and other cell quantification experiments in the future *)
	(* so this resolver will also return some simulation that comes from those child experiments if needed *)

	(* Figure out if we need to perform our simulation. If so, we can't return early even though we want to because we *)
	(* need to return some type of simulation to our parent function that called us. *)
	performSimulationQ = MemberQ[output, Simulation | Result];

	If[TrueQ[$QuantifyCellsDebugFlag], time0 = Now;Echo["Options Resolver started at "<>DateString[time0], "Options Resolver"]];

	resolvedOptionsResult = If[gatherTests,
		(* We are gathering tests. This silences any messages being thrown. *)
		(
			{resolvedOptions, resolvedOptionsTests, resolvedOptionsSimulation} = If[performSimulationQ,
				resolveExperimentQuantifyCellsOptions[
					expandedListedSamples,
					expandedSafeOps,
					Cache -> cacheBall,
					Simulation -> simulation,
					Output -> {Result, Tests, Simulation}
				],
				Module[{options, tests},
					{options, tests} = resolveExperimentQuantifyCellsOptions[
						expandedListedSamples,
						expandedSafeOps,
						Cache -> cacheBall,
						Simulation -> simulation,
						Output -> {Result, Tests}
					];
					{options, tests, simulation}
				]
			];
			(* Therefore, we have to run the tests to see if we encountered a failure. *)
			If[RunUnitTest[<|"Tests" -> resolvedOptionsTests|>, OutputFormat -> SingleBoolean, Verbose -> False],
				{resolvedOptions, resolvedOptionsTests},
				$Failed
			]
		),

		(* We are not gathering tests. Simply check for Error::InvalidInput and Error::InvalidOption. *)
		Check[
			(
				resolvedOptionsTests = {};
				{resolvedOptions, resolvedOptionsSimulation} = If[performSimulationQ,
					resolveExperimentQuantifyCellsOptions[
						expandedListedSamples,
						expandedSafeOps,
						Cache -> cacheBall,
						Simulation -> simulation,
						Output -> {Result, Simulation}
					],
					{
						resolveExperimentQuantifyCellsOptions[
							expandedListedSamples,
							expandedSafeOps,
							Cache -> cacheBall,
							Simulation -> simulation
						],
						simulation
					}
				]
			),
			$Failed,
			{Error::InvalidInput, Error::InvalidOption}
		]
	];

	If[TrueQ[$QuantifyCellsDebugFlag], time2 = Now;Echo["Options Resolver took "<>ToString[Convert[time2 - time0, Second]]<>" to finish!", "Options Resolver"]];

	(* Collapse the resolved options *)
	collapsedResolvedOptions = CollapseIndexMatchedOptions[
		ExperimentQuantifyCells,
		resolvedOptions,
		Ignore -> listedOptions,
		Messages -> False,
		CollapseReplicates -> True
	];

	(* Remove hidden options *)
	collapsedResolvedOptionsNoHidden = RemoveHiddenOptions[ExperimentQuantifyCells, collapsedResolvedOptions];

	(* lookup our OptionsResolverOnly option.  This will determine if we skip the resource packets and simulation functions *)
	(* if Output contains Result or Simulation, then we can't do this *)
	optionsResolverOnly = Lookup[resolvedOptions, OptionsResolverOnly];
	returnEarlyQBecauseOptionsResolverOnly = TrueQ[optionsResolverOnly] && Not[MemberQ[output, Result | Simulation]];

	(* run all the tests from the resolution; if any of them were False, then we should return early here *)
	(* need to do this because if we are collecting tests then the Check wouldn't have caught it *)
	(* basically, if _not_ all the tests are passing, then we do need to return early *)
	returnEarlyQBecauseFailure = Which[
		MatchQ[resolvedOptionsResult, $Failed], True,
		gatherTests, Not[RunUnitTest[<|"Tests" -> resolvedOptionsTests|>, Verbose -> False, OutputFormat -> SingleBoolean]],
		True, False
	];

	(* If option resolution failed and we aren't asked for the simulation or output, return early. *)
	If[(returnEarlyQBecauseFailure || returnEarlyQBecauseOptionsResolverOnly) && !performSimulationQ,
		Return[outputSpecification /. {
			Result -> $Failed,
			Tests -> Join[safeOpsTests, validLengthTests, templateTests, objectsExistTests, resolvedOptionsTests],
			Options -> collapsedResolvedOptionsNoHidden,
			Preview -> Null,
			Simulation -> resolvedOptionsSimulation
		}]
	];

	If[TrueQ[$QuantifyCellsDebugFlag], time1 = Now;Echo["Resource Packet started at "<>DateString[time1], "Resource Packet"]];

	(* Build packets with resources *)
	(* NOTE: Don't actually run our resource packets function if there was a problem with our option resolving. *)
	(* importantly, we are not passing simulation from options resolver to resource packet b/c that reflects the state of samples when all quantification methods are done, which we do not need to know during resource packet *)
	{{resourcePacketResults, resourcePacketSimulation, runTime}, resourcePacketTests} = If[(returnEarlyQBecauseFailure || returnEarlyQBecauseOptionsResolverOnly),
		{{$Failed, simulation, $Failed}, {}},
		If[gatherTests,
			experimentQuantifyCellsResourcePackets[expandedListedSamples, templatedOptions, resolvedOptions, Cache -> cacheBall, Simulation -> simulation, Output -> {Result, Tests}],
			{experimentQuantifyCellsResourcePackets[expandedListedSamples, templatedOptions, resolvedOptions, Cache -> cacheBall, Simulation -> simulation], {}}
		]
	];

	(* get resolved preparation *)
	resolvedPreparation = Lookup[resolvedOptions, Preparation];

	(* this is the simulation to feed/output after resource packet *)
	simulationAfterResourcePacket = If[MatchQ[resolvedPreparation, Robotic], resourcePacketSimulation, resolvedOptionsSimulation];

	If[TrueQ[$QuantifyCellsDebugFlag], time2 = Now;Echo["Resource Packet took "<>ToString[Convert[time2 - time1, Second]]<>" to finish!", "Resource Packet"]];

	If[TrueQ[$QuantifyCellsDebugFlag], time1 = Now;Echo["Simulation Function started at "<>DateString[time1], "Simulation Function"]];

	(* If we were asked for a simulation, also return a simulation. *)
	{simulatedProtocol, quantifyCellsSimulation} = Which[
		(* If resource packet failed, no need to go to simulation since it will fail for sure *)
		MatchQ[resourcePacketResults, $Failed],
		{$Failed, simulationAfterResourcePacket},
		(* otherwise go into simulation *)
		performSimulationQ,
		simulateExperimentQuantifyCells[
			If[MatchQ[resourcePacketResults, $Failed],
				$Failed,
				resourcePacketResults[[1]] (* protocolPacket *)
			],
			If[MatchQ[resourcePacketResults, $Failed],
				$Failed,
				resourcePacketResults[[2]] (* UnitOperation packets *)
			],
			expandedListedSamples,
			templatedOptions,
			resolvedOptions,
			Cache -> cacheBall,
			Simulation -> simulationAfterResourcePacket
		],
		(* catch all to make sure no weird result is output *)
		True,
		{Null, simulationAfterResourcePacket}
	];

	If[TrueQ[$QuantifyCellsDebugFlag], time2 = Now;Echo["Simulation Function started at "<>ToString[Convert[time2 - time1, Second]]<>" to finish!", "Simulation Function"]];

	(* If Result does not exist in the output, return everything without uploading,  don't bother calling UploadProtocol[...] *)
	If[!MemberQ[output, Result],
		Return[outputSpecification /. {
			Result -> Null,
			Tests -> Flatten[{safeOpsTests, validLengthTests, templateTests, resolvedOptionsTests, resourcePacketTests}],
			Options -> collapsedResolvedOptionsNoHidden,
			Preview -> Null,
			Simulation -> quantifyCellsSimulation,
			RunTime -> runTime
		}]
	];

	(* We have to return our result. Either return a protocol with a simulated procedure if SimulateProcedure\[Rule]True or return a real protocol that's ready to be run. *)
	protocolObject = Which[
		(* If there was a problem with our resource packets function or option resolver, we can't return a protocol. *)
		MatchQ[resourcePacketResults, $Failed] || MatchQ[resolvedOptionsResult, $Failed],
		$Failed,

		(* If we're doing Preparation->Robotic, return our unit operations packets back without RequireResources called if Upload->False. *)
		MatchQ[resolvedPreparation, Robotic] && MatchQ[Lookup[safeOps, Upload], False],
		resourcePacketResults[[2]], (* unitOperationPackets *)

		(* If we're doing Preparation->Robotic and Upload->True, call proper framework function with our primitive. *)
		MatchQ[resolvedPreparation, Robotic],
		Module[{primitive, roboticFunction},
			(* Create our primitive to feed into the framework function. *)
			primitive = QuantifyCells @@ Join[
				{
					Sample -> mySamples
				},
				(* feeding in the resolved option so framework does not spend time resolving WorkCell again *)
				RemoveHiddenPrimitiveOptions[QuantifyCells, collapsedResolvedOptionsNoHidden]
			];

			(* Memoize the value of ExperimentQuantifyCells so the framework doesn't spend time resolving it again. *)
			Internal`InheritedBlock[{ExperimentQuantifyCells, $PrimitiveFrameworkResolverOutputCache},
				$PrimitiveFrameworkResolverOutputCache = <||>;

				DownValues[ExperimentQuantifyCells] = {};

				ExperimentQuantifyCells[___, options:OptionsPattern[]] := Module[{frameworkOutputSpecification},
					(* Lookup the output specification the framework is asking for. *)
					frameworkOutputSpecification = Lookup[ToList[options], Output];

					frameworkOutputSpecification /. {
						Result -> resourcePacketResults[[2]],
						Options -> collapsedResolvedOptionsNoHidden,
						Preview -> Null,
						Simulation -> quantifyCellsSimulation,
						RunTime -> runTime
					}
				];
				(* mapping between workcell name and experiment function *)
				roboticFunction = Lookup[$WorkCellToExperimentFunction, Lookup[resolvedOptions, WorkCell]];
				roboticFunction[
					{primitive},
					Name -> Lookup[expandedSafeOps, Name],
					Upload -> Lookup[expandedSafeOps, Upload],
					Confirm -> Lookup[expandedSafeOps, Confirm],
					CanaryBranch -> Lookup[expandedSafeOps, CanaryBranch],
					ParentProtocol -> Lookup[expandedSafeOps, ParentProtocol],
					Priority -> Lookup[expandedSafeOps, Priority],
					StartDate -> Lookup[expandedSafeOps, StartDate],
					HoldOrder -> Lookup[expandedSafeOps, HoldOrder],
					QueuePosition -> Lookup[expandedSafeOps, QueuePosition],
					Cache -> cacheBall
				]
			]
		],

		(* Otherwise, upload a real protocol that's ready to be run. *)
		True,
		UploadProtocol[
			resourcePacketResults[[1]],
			Upload -> Lookup[expandedSafeOps, Upload],
			Confirm -> Lookup[expandedSafeOps, Confirm],
			CanaryBranch -> Lookup[expandedSafeOps, CanaryBranch],
			ParentProtocol -> Lookup[expandedSafeOps, ParentProtocol],
			ConstellationMessage -> Object[Protocol, QuantifyCells],
			Cache -> cacheBall,
			Priority -> Lookup[expandedSafeOps, Priority],
			StartDate -> Lookup[expandedSafeOps, StartDate],
			HoldOrder -> Lookup[expandedSafeOps, HoldOrder],
			QueuePosition -> Lookup[expandedSafeOps, QueuePosition],
			Simulation -> quantifyCellsSimulation
		]
	];

	(* Return requested output *)
	outputSpecification /. {
		Result -> protocolObject,
		Tests -> Flatten[{safeOpsTests, validLengthTests, templateTests, objectsExistTests, resolvedOptionsTests(*,resourcePacketTests*)}],
		Options -> collapsedResolvedOptionsNoHidden,
		Preview -> Null,
		Simulation -> quantifyCellsSimulation,
		RunTime -> runTime
	}
];


(* --- Container to Sample Overload --- *)
ExperimentQuantifyCells[myContainers:ListableP[ObjectP[{Object[Container], Object[Sample]}] | _String | {LocationPositionP, _String | ObjectP[Object[Container]]}], myOptions:OptionsPattern[]] := Module[
	{
		listedContainers, listedOptions, outputSpecification, output, gatherTests, cache, simulation,
		containerToSampleResult, containerToSampleOutput, samples, sampleOptions, containerToSampleTests, containerToSampleSimulation
	},

	(* Determine the requested return value from the function *)
	outputSpecification = Quiet[OptionValue[Output]];
	output = ToList[outputSpecification];

	(* Determine if we should keep a running list of tests *)
	gatherTests = MemberQ[output, Tests];

	(* Remove temporal links and named objects *)
	{listedContainers, listedOptions} = removeLinks[ToList[myContainers], ToList[myOptions]];

	(* Fetch the cache from listedOptions. *)
	cache = Lookup[listedOptions, Cache, {}];

	(* Fetch any simulation *)
	simulation = Lookup[listedOptions, Simulation, Null];

	(* Convert our given containers into samples and sample index-matched options. *)
	containerToSampleResult = If[gatherTests,
		(* We are gathering tests. This silences any messages being thrown. *)
		{containerToSampleOutput, containerToSampleTests, containerToSampleSimulation} = containerToSampleOptions[
			ExperimentQuantifyCells,
			listedContainers,
			listedOptions,
			Output -> {Result, Tests, Simulation},
			Cache -> cache,
			Simulation -> simulation
		];

		(* Therefore, we have to run the tests to see if we encountered a failure. *)
		If[RunUnitTest[<|"Tests" -> containerToSampleTests|>, OutputFormat -> SingleBoolean, Verbose -> False],
			Null,
			$Failed
		],

		(* We are not gathering tests. Simply check for Error::InvalidInput and Error::InvalidOption. *)
		Check[
			{containerToSampleOutput, containerToSampleSimulation} = containerToSampleOptions[
				ExperimentQuantifyCells,
				listedContainers,
				listedOptions,
				Output -> {Result, Simulation},
				Cache -> cache,
				Simulation -> simulation
			],
			$Failed,
			{Download::ObjectDoesNotExist, Error::EmptyContainer, Error::ContainerEmptyWells, Error::WellDoesNotExist}
		]
	];

	(* If we were given an empty container, return early. *)
	If[MatchQ[containerToSampleResult, $Failed],
		(* containerToSampleOptions failed - return $Failed *)
		outputSpecification /. {
			Result -> $Failed,
			Tests -> containerToSampleTests,
			Options -> $Failed,
			Preview -> Null,
			Simulation -> simulation
		},
		(* Split up our containerToSample result into the samples and sampleOptions. *)
		{samples, sampleOptions} = containerToSampleOutput;

		(* Call our main function with our samples and converted options. *)
		ExperimentQuantifyCells[samples, ReplaceRule[sampleOptions, {Simulation -> containerToSampleSimulation, Cache -> cache}]]
	]
];


(* ::Subsubsection:: *)
(*resolveExperimentQuantifyCellsOptions*)


DefineOptions[
	resolveExperimentQuantifyCellsOptions,
	Options :> {
		ExperimentOutputOption,
		CacheOption,
		SimulationOption
	}
];


resolveExperimentQuantifyCellsOptions[mySamples:{ObjectP[Object[Sample]]...}, myOptions:{___Rule}, myResolutionOptions:OptionsPattern[resolveExperimentQuantifyCellsOptions]] := Module[
	{
		safeOps,outputSpecification,output,gatherTests,messages,warnings,performSimulationQ,cache,simulation,fastCache,samplePackets,
		(* Input Validation Check *)
		discardedSamplePackets,discardedInvalidInputs,discardedTest,deprecatedInvalidInputs,
		deprecatedModelTest,nonLiquidSamplePackets,nonLiquidInvalidInputs,nonLiquidTest, deprecatedModels,
		(* Options Resolution *)
		mapThreadFriendlyOptions,resolvedSampleLabels,resolvedSampleContainerLabels,nonUniqueOptions,uniqueMethodOptions, joinWithMethodStandardOptions, allMethods, noMethodToUse,
		noMethodToUseInvalidOptions, noMethodToUseTest,
		specifiedQuantificationUnits,resolvedMethods,resolvedQuantificationUnits,expandedSpecifiedInstruments,
		preResolvedInstruments,resolvedAbsorbanceStandardCurves,resolvedNephelometryStandardCurves,preResolvedWavelengths,
		resolvedAbsorbanceMethod,resolvedAbsorbanceBlankMeasurement, resolvedNephelometryBlankMeasurement,
		simulationWithAliquot,sharedAliquotQ,samplesInput,sampleLabelsInput,sampleContainerLabelsInput,
		myOptionsWithMethods,preparationResult,allowedPreparation,preparationTest,resolvedPreparation,resolvedWorkCell,
		duplicateMethodQs,resolvedMethodOptions,resolvedInstruments,myOptionsWithPreresolvedOptions,
		resolvedChildExpTests,resolvedMethodPrimitiveOptions,resolvedPostProcessingOptions,specifiedEmail,
		specifiedParentProtocol,resolvedEmail,resolvedOptions,mapThreadFriendlyResolvedOptions,
		(* Error Checking *)
		duplicatedMethods,duplicatedMethodsInvalidOptions,duplicatedMethodsTest,conflictingMethodInfo, conflictingMethodClauses, convertibilityWarningClauses,
		conflictingMethodOptionsTest,mapThreadFriendlyConvertibilityCheckResults,noStandardCurveAvailableInfo,
		alternativeStandardCurvesInfo,redundantStandardCurveInfo,noStandardCurveAvailableTest,
		alternativeStandardCurveAvailableTest,redundantStandardCurveTest,recoupContaminationInfo,recoupContaminationTest,
		missingQuantificationUnitInfo,missingQuantificationUnitInvalidOptions,missingQuantificationUnitTest,invalidInputs,
		invalidOptions,existingLabels
	},

	(* get the safe options for this function *)
	safeOps = SafeOptions[resolveExperimentQuantifyCellsOptions, ToList[myResolutionOptions]];

	(* Determine the requested output format of this function. *)
	outputSpecification = Lookup[safeOps, Output];
	output = ToList[outputSpecification];

	(* Determine if we should keep a running list of tests to return to the user. *)
	gatherTests = MemberQ[output, Tests];
	(* if we are gathering tests, do not yell about errors/warnings *)
	messages = !gatherTests;
	(* if we are in Engine, do not yell about warning *)
	warnings = !gatherTests && !MatchQ[$ECLApplication, Engine];

	(* Fetch our cache from the parent function. *)
	cache = Lookup[safeOps, Cache, {}];
	simulation = Lookup[safeOps, Simulation, Null];

	(* Set up caches/fast assocs *)
	fastCache = makeFastAssocFromCache[cache];

	(* --- SET UP VARIABLES --- *)
	samplePackets = fetchPacketFromFastAssoc[#, fastCache]& /@ mySamples;

	(* --- INPUT VALIDATION CHECKS --- *)

	(* --- Discarded Samples --- *)
	(* pull out the sample packets with Status -> Discarded *)
	discardedSamplePackets = Cases[samplePackets, KeyValuePattern[Status -> Discarded]];

	(* set invalidInputs *)
	discardedInvalidInputs = Lookup[discardedSamplePackets, Object, {}];

	(* throw messages *)
	If[Length[discardedInvalidInputs] > 0 && messages,
		Message[Error::DiscardedSamples, ObjectToString[discardedInvalidInputs, Cache -> cache]]
	];

	(* make tests *)
	discardedTest = If[gatherTests,
		Module[{failingTest, passingTest},
			failingTest = If[Length[discardedInvalidInputs] == 0,
				Nothing,
				Test["Input samples "<>ObjectToString[discardedInvalidInputs, Cache -> cache]<>" are not discarded:", True, False]
			];
			passingTest = If[Length[discardedInvalidInputs] == Length[mySamples],
				Nothing,
				Test["Input samples "<>ObjectToString[UnsortedComplement[mySamples, discardedInvalidInputs], Cache -> cache]<>" are not discarded:", True, True]
			];
			{failingTest, passingTest}
		],
		Nothing
	];

	(* --- Sample's Model is not Deprecated --- *)
	(* pull out sample packets that have a model that is Deprecated *)
	deprecatedInvalidInputs = Select[
		samplePackets,
		TrueQ[fastAssocLookup[fastCache, Lookup[#, Object], {Model, Deprecated}]]&
	];

	(* set invalidInputs *)
	deprecatedModels = Lookup[deprecatedInvalidInputs, Model, {}];

	(* throw messages *)
	If[Length[deprecatedModels] > 0 && messages,
		Message[Error::DeprecatedModels, ObjectToString[deprecatedModels, Cache -> cache]]
	];

	(* make tests *)
	deprecatedModelTest = If[gatherTests,
		Module[{failingTest, passingTest},
			failingTest = If[Length[deprecatedModels] == 0,
				Nothing,
				Test["Input samples have models "<>ObjectToString[deprecatedModels, Cache -> cache]<>" that are not deprecated:", True, False]
			];
			passingTest = If[Length[deprecatedModels] == Length[mySamples],
				Nothing,
				Test["Input samples have models "<>ObjectToString[UnsortedComplement[mySamples, deprecatedModels], Cache -> cache]<>" that are not deprecated:", True, True]
			];
			{failingTest, passingTest}
		],
		Nothing
	];

	(* --- Only Liquid sample is supported --- *)
	(* pull out the sample packets with State that is not Liquid *)
	nonLiquidSamplePackets = Cases[samplePackets, KeyValuePattern[State -> Except[Liquid]]];

	(* set invalidInputs *)
	nonLiquidInvalidInputs = Lookup[nonLiquidSamplePackets, Object, {}];

	(* throw messages *)
	If[Length[nonLiquidInvalidInputs] > 0 && messages,
		Message[Error::NonLiquidSample, ObjectToString[nonLiquidInvalidInputs, Cache -> cache]]
	];

	(* make tests *)
	nonLiquidTest = If[gatherTests,
		Module[{failingTest, passingTest},
			failingTest = If[Length[nonLiquidInvalidInputs] == 0,
				Nothing,
				Test["Input samples "<>ObjectToString[nonLiquidInvalidInputs, Cache -> cache]<>" are not discarded:", True, False]
			];
			passingTest = If[Length[nonLiquidInvalidInputs] == Length[mySamples],
				Nothing,
				Test["Input samples "<>ObjectToString[UnsortedComplement[mySamples, nonLiquidInvalidInputs], Cache -> cache]<>" are not discarded:", True, True]
			];
			{failingTest, passingTest}
		],
		Nothing
	];

	(* No need for option precision checks as we will do'em in each of the child experiment calls, so not now here *)

	(* --- RESOLVE EXPERIMENT OPTIONS --- *)
	(* Convert our options into a MapThread friendly version. *)
	mapThreadFriendlyOptions = OptionsHandling`Private`mapThreadOptions[ExperimentQuantifyCells, myOptions];

	(* Resolve label options *)
	resolvedSampleLabels = Module[
		{specifiedSampleObjects, uniqueSamples, preResolvedSampleLabels, preResolvedSampleLabelLookup},

		(* Create a unique label for each unique sample in the input *)
		specifiedSampleObjects = Lookup[samplePackets, Object];
		uniqueSamples = DeleteDuplicates[specifiedSampleObjects];
		preResolvedSampleLabels = Table[CreateUniqueLabel["quantify cells input sample"], Length[uniqueSamples]];
		preResolvedSampleLabelLookup = MapThread[
			(#1 -> #2)&,
			{uniqueSamples, preResolvedSampleLabels}
		];

		(* Expand the sample-specific unique labels *)
		MapThread[
			Function[{object, label},
				Which[
					(* respect user specification *)
					MatchQ[label, Except[Automatic]],
					label,
					(* respect upstream LabelSample/LabelContainer input *)
					MatchQ[simulation, SimulationP] && MatchQ[LookupObjectLabel[simulation, object], _String],
					LookupObjectLabel[simulation, object],
					(* get a label from the lookup *)
					True,
					Lookup[preResolvedSampleLabelLookup, object]
				]
			],
			{specifiedSampleObjects, Lookup[mapThreadFriendlyOptions, SampleLabel]}
		]
	];

	resolvedSampleContainerLabels = Module[
		{specifiedContainerObjects, uniqueContainers, preResolvedSampleContainerLabels, preResolvedContainerLabelLookup},

		(* Create a unique label for each unique container in the input *)
		specifiedContainerObjects = Download[Lookup[samplePackets, Container, {}], Object];
		uniqueContainers = DeleteDuplicates[specifiedContainerObjects];
		preResolvedSampleContainerLabels = Table[CreateUniqueLabel["quantify cells input sample container"], Length[uniqueContainers]];
		preResolvedContainerLabelLookup = MapThread[
			(#1 -> #2)&,
			{uniqueContainers, preResolvedSampleContainerLabels}
		];

		(* Expand the sample-specific unique labels *)
		MapThread[
			Function[{object, label},
				Which[
					(* respect user specification *)
					MatchQ[label, Except[Automatic]],
					label,
					(* respect upstream LabelSample/LabelContainer input *)
					MatchQ[simulation, SimulationP] && MatchQ[LookupObjectLabel[simulation, object], _String],
					LookupObjectLabel[simulation, object],
					(* get a label from the lookup *)
					True,
					Lookup[preResolvedContainerLabelLookup, object]
				]
			],
			{specifiedContainerObjects, Lookup[myOptions, SampleContainerLabel]}
		]
	];

	(* get the non-unique options across all different quantification methods *)
	nonUniqueOptions = Module[{allMethodOptions, pairedOptionList},
		(* get all the option lists first *)
		allMethodOptions = Keys /@ Lookup[Values[$QuantifyCellsMethodInformationLookup], "OptionsMap", {}];
		(* pair them so can check if there are shared options *)
		pairedOptionList = Subsets[allMethodOptions, {2}];
		(* get the non-unique options *)
		DeleteDuplicates[Flatten[Intersection[#[[1]], #[[2]]]& /@ pairedOptionList]]
	];
	(* quick helper to get the unique options for a given method *)
	(* also memoize since we really do not need to do this over and over every time we call this helper *)
	uniqueMethodOptions[method:CellQuantificationMethodP] := uniqueMethodOptions[method] = Module[{methodOptions},
		(* pull all options that are relevant to the given method *)
		methodOptions = Keys[Lookup[Lookup[$QuantifyCellsMethodInformationLookup, method, <||>], "OptionsMap", {}]];
		(* get the unique options that are relevant to the given method exclusively *)
		Complement[methodOptions, nonUniqueOptions]
	];
	(* quick helper to join the unique method options with the standard curve and coefficient options for that method *)
	joinWithMethodStandardOptions[method: CellQuantificationMethodP, optionsList_List] := joinWithMethodStandardOptions[method, optionsList] = Join[
		optionsList,
		{
			ToExpression[ToString[method] <> "StandardCurve"],
			ToExpression[ToString[method] <> "StandardCoefficient"]
		}
	];

	(* get the specified values *)
	specifiedQuantificationUnits = Lookup[myOptions, QuantificationUnit] /. x : CellQuantificationUnitStringP :> ToExpression[x];

	allMethods = Keys[$QuantifyCellsMethodInformationLookup];
	(* Initiate error checking *)
	noMethodToUse = False;

	(* Resolve Methods *)
	resolvedMethods = Module[
		{specifiedMethods, specifiedInstruments, semiResolvedMethods, methodsToCheck, methodsToScreenOut, runningMethods, sortedRunningMethods, automaticPos, numberOfAutomatics, automaticReplaceRules, possibleMethods, methodToReplaceAutomatic},

		(* pull out the specified values for Methods *)
		{specifiedMethods, specifiedInstruments} = ToList /@ Lookup[myOptions, {Methods, Instruments}];

		(* semi resolve method based on instruments *)
		semiResolvedMethods = MapThread[
			Function[{method, instrument},
				Which[
					(* if it is set it is set *)
					MatchQ[method, Except[Automatic]],
					method,
					(* set based on instrument types *)
					MatchQ[instrument, Except[Automatic]],
					SelectFirst[allMethods, MatchQ[instrument, ObjectP[$QuantifyCellsMethodInformationLookup[#]["Instrument"]]]&],
					True,
					Automatic
				]
			],
			{specifiedMethods, specifiedInstruments}
		];

		(* we will only check if we may resolve to the methods that have not been specified by the user.
		This is b/c QuantifyCells only support each sample measured by each of the method only ONCE!
		Therefore we do not allow duplicates exist in Methods *)
		methodsToCheck = Complement[allMethods, semiResolvedMethods];
		(* If user specified any options to Null that cannot be Null of a method, we will screen it out. *)
		methodsToScreenOut = PickList[allMethods,
			MemberQ[
				Lookup[myOptions,
					Lookup[Lookup[$QuantifyCellsMethodInformationLookup, #, <||>], "NotNullOptions"]
				],
				ListableP[Null]
			]& /@ allMethods
		];
		(* Determine which method to use to replace automatic *)
		possibleMethods = Complement[allMethods, methodsToScreenOut];

		methodToReplaceAutomatic = Which[
			Length[possibleMethods]>0,
				First[possibleMethods],
			(* We don't have possible method, and we need to resolve Method, flip the error switch, and put Absorbance *)
			MatchQ[semiResolvedMethods, {Automatic}],
				noMethodToUse = True;
				Absorbance,
			True,
			(* We don't have possible method, but we don't need to resolve Methods, put Absorbance that won't be used *)
				Absorbance
		];

		(* initiate a running list to store any potential methods that we might resolve to *)
		runningMethods = {};
		(* check each method candidate to see if we can use them *)
		Map[
			Function[{method},
				If[
					And[
						(* Only consider this method when there's no options specified to Null that cannot be null for this method *)
						!MemberQ[methodsToScreenOut,method],
						Or[
							(* case 1: if any of the method specific options are set *)
							MemberQ[
								Lookup[
									myOptions,
									joinWithMethodStandardOptions[method, uniqueMethodOptions[method]]
								],
								Except[ListableP[Automatic | Null]]
							],
							(* case 2: if there exists a standard curve that can convert the raw experimental result from the specific method to the specified quantification unit (defaulting to Cell/mL) for each sample *)
							MemberQ[First[checkConvertible[samplePackets, method, specifiedQuantificationUnits /. {Automatic -> EmeraldCell / Milliliter}, specifiedQuantificationUnits, mapThreadFriendlyOptions, fastCache, cache]], True],
							(* case 3: if there exists a standard curve that can convert the raw experimental result from the specific method to the specified quantification unit (defaulting to OD600) for each sample *)
							MemberQ[First[checkConvertible[samplePackets, method, specifiedQuantificationUnits /. {Automatic -> OD600}, specifiedQuantificationUnits, mapThreadFriendlyOptions, fastCache, cache]], True]
						]
					],
					(* we add this method to the running list *)
					AppendTo[runningMethods, method]
				]
			],
			methodsToCheck
		];
		(* sort the found methods according to the preferred order *)
		sortedRunningMethods = SortBy[DeleteDuplicates[runningMethods], Position[$PreferredMethodOrder, #][[1]][[1]]&];

		(* if user did not specify Methods and we could not resolve one from instrument specification, we will expand the Methods to be whatever we found that is suitable after resolution *)
		If[MatchQ[{Lookup[myOptions, Methods], semiResolvedMethods}, {Automatic, {Automatic}}] && Length[sortedRunningMethods] > 0,
			Return[sortedRunningMethods, Module]
		];

		(* otherwise, do not expand Methods and just try to swap out Automatics from user-specified value *)
		(* get positions for all the Automatics we are going to replace in the Methods *)
		automaticPos = First /@ Position[semiResolvedMethods, Automatic];
		numberOfAutomatics = Length[automaticPos];

		(* try to create a rule to replace Automatic with the running methods *)
		automaticReplaceRules = Switch[numberOfAutomatics,
			(* no Automatic, no need to replace *)
			0,
			{},
			(* less Automatic *)
			LessEqualP[Length[sortedRunningMethods]],
			(* Rule @@@ Transpose converts {{a, b, c}, {1, 2, 3}} to {a -> 1, b -> 2, c -> 3} *)
			Rule @@@ Transpose[{automaticPos, Take[sortedRunningMethods, numberOfAutomatics]}],
			(* more Automatic than available methods, this is gonna be in error state any way so we just default any extra Automatic to Absorbance *)
			_,
			(* Rule @@@ Transpose converts {{a, b, c}, {1, 2, 3}} to {a -> 1, b -> 2, c -> 3} *)
			Rule @@@ Transpose[{automaticPos, PadRight[sortedRunningMethods, numberOfAutomatics, methodToReplaceAutomatic]}]
		];

		(* go back to fully resolve the remaining Automatics in Methods *)
		ReplacePart[
			semiResolvedMethods,
			automaticReplaceRules
		]
	];

	(* Resolve QuantificationUnit *)
	resolvedQuantificationUnits = Module[{cellPermLConvertibilityCheckResults, cellPermLConvertibleQs},

		(* use helper to check if we can convert from raw experimental result to Cell/mL *)
		cellPermLConvertibilityCheckResults = checkConvertible[samplePackets, #, ConstantArray[EmeraldCell / Milliliter, Length[mySamples]], specifiedQuantificationUnits, mapThreadFriendlyOptions, fastCache, cache]& /@ resolvedMethods;
		(* union all the booleans (from different methods) to be a single boolean for each sample *)
		cellPermLConvertibleQs = Or @@@ Transpose[cellPermLConvertibilityCheckResults[[All, 1]]];

		MapThread[
			Function[{options, cellPermLConvertibleQ},
				Which[
					(* if it is set it is set *)
					MatchQ[Lookup[options, QuantificationUnit], Except[Automatic]],
						Lookup[options, QuantificationUnit] /. x : CellQuantificationUnitStringP :> ToExpression[x],
					(* if we can find a std curve that converts to Cell/mL, set to Cell/mL *)
					cellPermLConvertibleQ,
						EmeraldCell / Milliliter,
					(* otherwise default to OD600 *)
					True,
						OD600
				]
			],
			{mapThreadFriendlyOptions, cellPermLConvertibleQs}
		]
	];

	(* pre Resolve Instruments *)
	(* expand the instrument only when it is Automatic, not even {Automatic} b/c {Automatic} indicates that user only wants to use 1 instrument/quantification method, and ExpandIndexMatchingInput would have caught any length mismatching already *)
	(* for Automatic case, b/c Instruments is index matched to Methods option, when Methods is specified to Automatic, resolvedMethods can be a list of methods with a length more than 1, therefore ExpandIndexMatchingInput wont really catch this for sure. We are expanding here manually to make sure Instruments option matches the resolvedMethods length *)
	expandedSpecifiedInstruments = If[MatchQ[Lookup[myOptions, Instruments], Automatic],
		ConstantArray[Automatic, Length[resolvedMethods]],
		ToList[Lookup[myOptions, Instruments]]
	];

	preResolvedInstruments = Module[{standardCurveInstruments},

		standardCurveInstruments = Map[
			Function[{method},
				If[MatchQ[method, Absorbance],
					(* if method includes absorbance, get the instrument that was used by the standard curve *)
					Module[{allAvailableStandardCurves},
						allAvailableStandardCurves = checkConvertible[samplePackets, method, resolvedQuantificationUnits, specifiedQuantificationUnits, mapThreadFriendlyOptions, fastCache, cache][[2]];
						FirstCase[fastAssocLookup[fastCache, #, {Protocol, Instrument}]& /@ allAvailableStandardCurves, ObjectP[$QuantifyCellsMethodInformationLookup[method]["Instrument"]], Null]
					],
					(* otherwise do not do this *)
					Null
				]
			],
			resolvedMethods
		];

		MapThread[
			Function[{method, instrument, standardCurveInstrument},
				Which[
					(* if user gives us a instrument model and we are doing Absorbance, then we need to replace this model with the object to make sure standard curve is usable *)
					MatchQ[fastAssocLookup[fastCache, standardCurveInstrument, Model], ObjectP[instrument]] && MatchQ[method, Absorbance],
					standardCurveInstrument,
					(* otherwise just respect user input *)
					MatchQ[instrument, Except[Automatic]],
					instrument,
					(* otherwise we have to use the EXACT SAME instrument when trying to measure OD600 *)
					MatchQ[method, Absorbance] && MatchQ[standardCurveInstrument, ObjectP[Object[Instrument]]],
					standardCurveInstrument,
					(* otherwise leave it automatic *)
					True,
					Automatic
				]
			],
			{resolvedMethods, expandedSpecifiedInstruments , standardCurveInstruments}
		]
	];

	(* enter MapThread and resolve StandardCurve options *)
	{
		resolvedAbsorbanceStandardCurves,
		resolvedNephelometryStandardCurves,
		preResolvedWavelengths
	} = Module[{availableAbsorbanceStandardCurves, availableNephelometryStandardCurves},
		(* if we can convert absorbance raw data to the specified quantification unit, call helper to get all the standard curves (already memoized so should be fast *)
		availableAbsorbanceStandardCurves = If[MemberQ[resolvedMethods, Absorbance],
			checkConvertible[samplePackets, Absorbance, resolvedQuantificationUnits, specifiedQuantificationUnits, mapThreadFriendlyOptions, fastCache, cache][[2]],
			ConstantArray[Null, Length[mySamples]]
		];

		(* if we can convert nephelometry raw data to the specified quantification unit, call helper to get all the standard curves (already memoized so should be fast *)
		availableNephelometryStandardCurves = If[MemberQ[resolvedMethods, Nephelometry],
			checkConvertible[samplePackets, Nephelometry, resolvedQuantificationUnits, specifiedQuantificationUnits, mapThreadFriendlyOptions, fastCache, cache][[2]],
			ConstantArray[Null, Length[mySamples]]
		];


		Transpose@MapThread[
			Function[{options, availableAbsorbanceStandardCurve, availableNephelometryStandardCurve},
				Module[{absorbanceStandardCurve, nephelometryStandardCurve, wavelength},
					(* Resolve AbsorbanceStandardCurve *)
					absorbanceStandardCurve = Which[
						(* If it is set it is set *)
						MatchQ[Lookup[options, AbsorbanceStandardCurve], Except[Automatic]],
						Lookup[options, AbsorbanceStandardCurve],
						(* if we can find a standard curve that converts the raw experiment to the target quantification unit, use that *)
						MatchQ[availableAbsorbanceStandardCurve, ObjectP[Object[Analysis, StandardCurve]]],
						availableAbsorbanceStandardCurve,
						(* otherwise default to Null *)
						True,
						Null
					];

					(* Resolve NephelometryStandardCurve *)
					nephelometryStandardCurve = Which[
						(* If it is set it is set *)
						MatchQ[Lookup[options, NephelometryStandardCurve], Except[Automatic]],
						Lookup[options, NephelometryStandardCurve],
						(* if we can find a standard curve that converts the raw experiment to the target quantification unit, use that *)
						MatchQ[availableNephelometryStandardCurve, ObjectP[Object[Analysis, StandardCurve]]],
						availableNephelometryStandardCurve,
						(* otherwise default to Null *)
						True,
						Null
					];

					(* pre resolve Wavelength *)
					wavelength = Which[
						(* if it is set it is set *)
						MatchQ[Lookup[options, Wavelength], Except[Automatic]],
						Lookup[options, Wavelength],
						(* if we can find a standard curve that converts the raw experiment to the target quantification unit, use that *)
						MatchQ[availableAbsorbanceStandardCurve, ObjectP[Object[Analysis, StandardCurve]]] && MemberQ[resolvedMethods, Absorbance],
						First[fastAssocLookup[fastCache, availableAbsorbanceStandardCurve, {Protocol, Wavelengths}], Automatic],
						(* otherwise, do not set yet *)
						True,
						Automatic
					];

					(* return *)
					{
						absorbanceStandardCurve,
						nephelometryStandardCurve,
						wavelength
					}
				]
			],
			{mapThreadFriendlyOptions, availableAbsorbanceStandardCurves, availableNephelometryStandardCurves}
		]
	];

	(* incorporate resolved methods/instruments and preresolved wavelength *)
	myOptionsWithMethods = ReplaceRule[
		myOptions,
		{
			Methods -> resolvedMethods,
			Wavelength -> preResolvedWavelengths,
			Instruments -> preResolvedInstruments
		}
	];

	(* resolve Preparation *)
	(* call the method resolver helper *)
	preparationResult = Check[
		{allowedPreparation, preparationTest} = If[gatherTests,
			resolveQuantifyCellsMethod[mySamples, ReplaceRule[myOptionsWithMethods, {Cache -> cache, Output -> {Result, Tests}, Simulation -> simulation}]],
			{
				resolveQuantifyCellsMethod[mySamples, ReplaceRule[myOptionsWithMethods, {Cache -> cache, Output -> Result, Simulation -> simulation}]],
				{}
			}
		],
		$Failed
	];

	(* If we have more than one allowable preparation method, just choose the first one. Our function returns multiple *)
	(* options so that OptimizeUnitOperations can perform primitive grouping. *)
	resolvedPreparation = First[ToList[allowedPreparation], Manual];

	(* resolve WorkCell using helper *)
	resolvedWorkCell = If[MatchQ[resolvedPreparation, Robotic],
		First[
			resolveQuantifyCellsWorkCell[
				mySamples,
				ReplaceRule[myOptionsWithMethods, {Cache -> cache, Preparation -> resolvedPreparation, Simulation -> simulation}]
			],
			Null
		],
		Null
	];

	(* --- ADD ANY METHOD SPECIFIC OPTIONS RESOLUTION --- *)

	(* Resolve AbsorbanceMethod *)
	(* copying logic from Experiment/AbsorbanceSpectroscopy/Experiment.m *)
	(* modifying a little bit that we DO NOT resolve to Microfluidic at anytime for cell samples b/c the channels/volumes are comparable to cell scale *)
	resolvedAbsorbanceMethod = Which[
		(* if it is set it is set *)
		MatchQ[Lookup[myOptions, AbsorbanceMethod], Except[Automatic]],
			Lookup[myOptions, AbsorbanceMethod],
		(* if we are not using Absorbance, resolve to Null *)
		!MemberQ[resolvedMethods, Absorbance],
			Null,
		(* if instrument set to plate reader instrument, set to PlateReader *)
		MemberQ[preResolvedInstruments, ObjectP[{Object[Instrument, PlateReader], Model[Instrument, PlateReader]}]],
			PlateReader,
		(* if instrument set to spectrophotometer, set to Cuvette *)
		MemberQ[preResolvedInstruments, ObjectP[{Object[Instrument, Spectrophotometer], Model[Instrument, Spectrophotometer]}]],
			Cuvette,
		(* if SpectralBandwidth is set, set to Cuvette *)
		MatchQ[Lookup[myOptions, SpectralBandwidth], Except[Automatic | Null]],
			Cuvette,
		(* if NumberOfReadings is set, set to PlateReader *)
		MatchQ[Lookup[myOptions, NumberOfReadings], Except[Automatic | Null]],
			PlateReader,
		(* we only have plate reader on robotic deck *)
		MatchQ[resolvedPreparation, Robotic],
			PlateReader,
		(* otherwise we need to have a minimum volume to make sure sample do not evaporate during heating equilibration *)
		MatchQ[Lookup[myOptions, AbsorbanceEquilibrationTime], Except[Automatic | Null]] || MatchQ[Lookup[myOptions, AbsorbanceAcquisitionTemperature], Except[Automatic | Null]],
			If[MemberQ[Lookup[samplePackets, Volume], GreaterEqualP[400 * Microliter]],
				Cuvette,
				PlateReader
			],
		(* default to PlateReader *)
		True,
			PlateReader
	];

	resolvedAbsorbanceBlankMeasurement = Which[
		(* if it is set it is set *)
		MatchQ[Lookup[myOptions, AbsorbanceBlankMeasurement], Except[Automatic]],
			Lookup[myOptions, AbsorbanceBlankMeasurement],
		(* If using absorbance and no absorbance blank option is specified as Null, we resolve the masterswitch to True *)
		MemberQ[resolvedMethods,Absorbance]&&!MemberQ[Flatten[Lookup[myOptions, {AbsorbanceBlank,AbsorbanceBlankVolume}]],Null],
			True,
		(* Otherwise if using absorbance and there is absorbance blank option specified as Null, we resolve the masterswitch to False*)
		MemberQ[resolvedMethods,Absorbance],
			False,
		(* Otherwise Absorbance is not used, leave it Null*)
		True,
			Null
	];
	resolvedNephelometryBlankMeasurement = Which[
		(* if it is set it is set *)
		MatchQ[Lookup[myOptions, NephelometryBlankMeasurement], Except[Automatic]],
			Lookup[myOptions, NephelometryBlankMeasurement],
		(* If using absorbance and no absorbance blank option is specified as Null, we resolve the masterswitch to True *)
		MemberQ[resolvedMethods,Nephelometry]&&!MemberQ[Flatten[Lookup[myOptions, {NephelometryBlank,NephelometryBlankVolume}]],Null],
			True,
		(* Otherwise if using absorbance and there is absorbance blank option specified as Null, we resolve the masterswitch to False*)
		MemberQ[resolvedMethods,Nephelometry],
			False,
		(* Otherwise Absorbance is not used, leave it Null*)
		True,
			Null
	];

	(* incorporate any pre-resolved options now *)
	myOptionsWithPreresolvedOptions = ReplaceRule[
		myOptionsWithMethods,
		{
			Preparation -> resolvedPreparation,
			WorkCell -> resolvedWorkCell,
			AbsorbanceMethod -> resolvedAbsorbanceMethod,
			AbsorbanceBlankMeasurement -> resolvedAbsorbanceBlankMeasurement,
			NephelometryBlankMeasurement -> resolvedNephelometryBlankMeasurement
		}
	];

	(* b/c we are going to call some child experiment functions later in this resolver, need to determine if we need to do simulation or not *)
	(* no need to perform simulation here if we are in Robotic mode, since resource packet will return simulation later *)
	performSimulationQ = MemberQ[output, Simulation] && MatchQ[resolvedPreparation, Manual];

	(* initiate the aliquot simulation *)
	simulationWithAliquot = If[MatchQ[simulation, SimulationP], simulation, Simulation[]];
	sharedAliquotQ = MatchQ[Lookup[myOptions, MultiMethodAliquots], Shared];

	(* initiate the variable to store sample/label input for the child function, may get updated if there is any aliquotting *)
	samplesInput = mySamples;
	sampleLabelsInput = resolvedSampleLabels;
	sampleContainerLabelsInput = resolvedSampleContainerLabels;

	(* create booleans indicating if this is a dulpicate method of the one that is already in the list, do not need to run child function at all since this is in error state anyway *)
	duplicateMethodQs = MapIndexed[
		MemberQ[Take[resolvedMethods, First[#2] - 1], #1]&,
		resolvedMethods
	];

	existingLabels=Lookup[simulationWithAliquot[[1]],{Labels, LabelFields}];

	(* resolve any shared options *)
	{resolvedMethodOptions, resolvedInstruments, resolvedChildExpTests, resolvedMethodPrimitiveOptions} = Module[
		{runningMethodAssoc},
		(* initiate the running association to store the method-specific info so we do not need to re-resolve in duplicate method case (error state) *)
		runningMethodAssoc = <||>;

		Transpose@MapThread[
			Function[{method, instrument, duplicateMethodQ, specifiedInstrument},
				Which[duplicateMethodQ,
					(* if this is a duplicate method, get the result from the association so we do not need to try to call resolver again *)
					runningMethodAssoc[method],
					(* If we resolved to have no possible methods due to user-specified Nulls for required options, null the options out although we were sent to resolve Absorbance *)
					noMethodToUse,
					{
						(* resolved method-specific options *)
						Normal[
							Join[
								(* split the method options out using our helper *)
								Association[splitMethodOptions[myOptionsWithPreresolvedOptions, method, instrument]/. Automatic -> Null],
								(* append sample label options and instrument option *)
								<|
									SampleLabel -> sampleLabelsInput,
									SampleContainerLabel -> sampleContainerLabelsInput,
									OptionsResolverOnly -> !performSimulationQ
								|>
							],
							Association
						],
						(* resolved instruments *)
						(* now we need to replace back the instrument to be the user specified value, since we overid user specified model to be the exact instrument object when pre-resolving instrument *)
						If[MatchQ[specifiedInstrument, Except[Automatic]],
							specifiedInstrument,
							Null
						],
						(* tests of the child experiment function calls *)
						{},
						(* We will hard error and won't need to create method primitive in resource packet *)
						<||>
					},
					True,
					(* otherwise continue to call the child resolver *)
					Module[{childFunction,optionsMap,childOutputSpecification,optionsInput,childOutput,childOutputRules,childOutputRulesWithDefaults,childFunctionTests,childOptions,childOptionsRenamed,childFunctionSimulation,result},

						(* get the child experiment function we are going to call to resolve the method-specific options *)
						childFunction = Lookup[Lookup[$QuantifyCellsMethodInformationLookup, method, <||>], "Function"];

						(* get the options map *)
						optionsMap = Lookup[Lookup[$QuantifyCellsMethodInformationLookup, method, <||>], "OptionsMap", {}];

						(* get the output spec for child experiment function call *)
						(* if we are returning simulation in this resolver then child experiment also needs to return simulation *)
						(* if we are asked for tests then we also need to return tests *)
						childOutputSpecification = Which[
							performSimulationQ && gatherTests,
							{Options, Tests, Simulation},
							performSimulationQ,
							{Options, Simulation},
							gatherTests,
							{Options, Tests},
							True,
							{Options}
						];

						(* get the options to resolve *)
						(* we are taking advance of MM's feature that Joining associations will replace duplicate keys *)
						optionsInput = Normal[
							Join[
								(* split the method options out using our helper *)
								Association[splitMethodOptions[myOptionsWithPreresolvedOptions, method, instrument]],
								(* append sample label options and instrument option *)
								<|
									SampleLabel -> sampleLabelsInput,
									SampleContainerLabel -> sampleContainerLabelsInput,
									(* The child resolver should not further expand based on number of replicates, since we are already working with replicate-expanded samples and options list *)
									NumberOfReplicates -> Null
								|>,
								(* append Output option *)
								<|
									(* if we are returning simulation in this resolver then child experiment also needs to return simulation, we cannot skip resource packet and simulation *)
									(* otherwise we can just add OptionsResolverOnly -> True to make things a little faster here *)
									OptionsResolverOnly -> !performSimulationQ,
									Output -> childOutputSpecification
								|>,
								(* if preparation resolving $Failed, just replace Preparation and WorkCell option to be Automatic so we do not throw a wall of reds *)
								If[FailureQ[preparationResult],
									<|
										Preparation -> Automatic,
										WorkCell -> Automatic
									|>,
									<||>
								]
							],
							Association
						];

						If[TrueQ[$QuantifyCellsDebugFlag], time1 = Now;Echo[ToString[childFunction]<>" options resolving started at "<>DateString[time1], "Options Resolver"]];

						(* call ModifyFunctionMessages[...] to resolve the options and optionally return simulation *)
						childOutput = If[GreaterQ[Lookup[myOptionsWithPreresolvedOptions,NumberOfReplicates],1],
							Quiet[
								ModifyFunctionMessages[
									childFunction,
									{samplesInput},
									"",
									optionsMap,
									optionsInput,
									Cache -> cache,
									Simulation -> simulationWithAliquot,
									Output -> Result
								],
								(* quieting these messages b/c we've checked them in the input validation check *)
								(* In addition, if we expanded the sample list because there is number of replicates, do not complain about repeated samples *)
								{Error::DiscardedSamples, Error::DeprecatedModels, Error::NonLiquidSample,Error::StateAmountMismatch, Error::DeprecatedModels, Warning::RepeatedPlateReaderSamples}
							],
							(* Otherwise just quiet the messages that we've checked in the input validation check *)
							Quiet[
								ModifyFunctionMessages[
									childFunction,
									{samplesInput},
									"",
									optionsMap,
									optionsInput,
									Cache -> cache,
									Simulation -> simulationWithAliquot,
									Output -> Result
								],
								(* quieting these messages b/c we've checked them in the input validation check *)
								(* In addition, if we expanded the sample list because there is number of replicates, do not complain about repeated samples *)
								{Error::DiscardedSamples, Error::DeprecatedModels, Error::NonLiquidSample,Error::StateAmountMismatch, Error::DeprecatedModels}
							]
						];

						If[TrueQ[$QuantifyCellsDebugFlag], time2 = Now;Echo[ToString[childFunction]<>" options resolving took "<>ToString[Convert[time2 - time1, Second]]<>" to finish!", "Options Resolver"]];

						(* make output specification rules for the actual child experiment function returns *)
						childOutputRules = Rule @@@ Transpose[{childOutputSpecification, childOutput}];

						(* default tests to {}, and simulation to the original simulation if Tests/Simulation keys are not included in the actual function returns *)
						childOutputRulesWithDefaults = ReplaceRule[
							{Options -> {}, Tests -> {}, Simulation -> simulationWithAliquot},
							childOutputRules
						];

						(* parse the output to options, simulation, and tests respectively *)
						{childOptions, childFunctionTests, childFunctionSimulation} = {Options, Tests, Simulation} /. childOutputRulesWithDefaults;

						(* return early if resolution fails due to pattern issue *)
						If[FailureQ[childOptions], Return[{{}, instrument, {}, childOptions}, Module]];

						(* remap the child options back to the name used in the child function *)
						childOptionsRenamed = ((#[[1]] /. optionsMap) -> #[[2]]&) /@ childOptions;

						If[TrueQ[$QuantifyCellsDebugFlag], time1 = Now;Echo["Updating aliquot simulation started at "<>DateString[time1], "Options Resolver"]];

						(* update aliquot simulation accordingly *)
						simulationWithAliquot = If[performSimulationQ, UpdateSimulation[simulationWithAliquot, childFunctionSimulation], simulationWithAliquot];
						(* update sample and label input according to MultiMethodAliquots and resolved aliquot options *)
						{samplesInput, sampleLabelsInput, sampleContainerLabelsInput} = Module[{aliquotQs, aliquotLabels},
							(* get the aliquot bool and aliquot labels *)
							{
								aliquotQs,
								aliquotLabels
							} = Lookup[childOptionsRenamed,
								{
									Aliquot,
									AliquotSampleLabel
								},
								ConstantArray[Null, Length[mySamples]]
							];

							Which[
								(* no need to update the aliquotted samples not simulation *)
								Or[
									(* if we are not sharing aliquots *)
									!sharedAliquotQ,
									(* or if we are not aliquotting *)
									!MemberQ[aliquotQs, True]
								],
								{samplesInput, sampleLabelsInput, sampleContainerLabelsInput},
								(* if we are performing simulation, simulationWithAliquot already contains the simulated aliquotted samples *)
								performSimulationQ,
								(* otherwise we have to get the aliquotted sample from simulation *)
								Module[{aliquotTruePos, aliquotLabelsNotNull, simulatedAliquottedSamples, sampleReplacementRules, labelReplacementRules, containerLabelReplacementRules},
									(* get the position of the aliquot True samples *)
									aliquotTruePos = First /@ Position[aliquotQs, True];

									(* get the aliquot sample labels *)
									aliquotLabelsNotNull = Cases[ToList[aliquotLabels], _String];

									(* get the simulated aliquot samples *)
									simulatedAliquottedSamples = LookupLabeledObject[simulationWithAliquot, aliquotLabelsNotNull];

									(* create replacement rule for sample, sample label, and container label *)
									sampleReplacementRules = Rule @@@ Transpose[{aliquotTruePos, simulatedAliquottedSamples}];
									labelReplacementRules = Rule @@@ Transpose[{aliquotTruePos, aliquotLabelsNotNull}];
									containerLabelReplacementRules = Rule @@@ Transpose[{aliquotTruePos, ConstantArray[Automatic, Length[aliquotTruePos]]}];

									(* do the replacement *)
									{ReplacePart[samplesInput, sampleReplacementRules], ReplacePart[sampleLabelsInput, labelReplacementRules], ReplacePart[sampleContainerLabelsInput, containerLabelReplacementRules]}
								],
								(* otherwise, we have to simulate using simulateSamplesResourcePacketsNew *)
								True,
								Module[{simulatedResults, aliquotTruePos, aliquotLabelsNotNull, labelReplacementRules, containerLabelReplacementRules},
									(* simulate the aliquotting process *)
									simulatedResults = simulateSamplesResourcePacketsNew[childFunction, samplesInput, childOptionsRenamed,
										Cache -> cache,
										Simulation -> simulationWithAliquot
									];

									(* get the position of the aliquot True samples *)
									aliquotTruePos = First /@ Position[aliquotQs, True];

									(* get the aliquot sample labels *)
									aliquotLabelsNotNull = Cases[ToList[aliquotLabels], _String];

									(* create replacement rule for sample label, and container label *)
									labelReplacementRules = Rule @@@ Transpose[{aliquotTruePos, aliquotLabelsNotNull}];
									containerLabelReplacementRules = Rule @@@ Transpose[{aliquotTruePos, ConstantArray[Automatic, Length[aliquotTruePos]]}];

									If[MatchQ[simulatedResults, {{__Object}, SimulationP}],
										(* if aliquot simulation is successful, update the simulation, and set to the aliquotted samples *)
										Module[{},
											simulationWithAliquot = UpdateSimulation[simulationWithAliquot, Last[simulatedResults, Simulation[]]];
											{First[simulatedResults], ReplacePart[sampleLabelsInput, labelReplacementRules], ReplacePart[sampleContainerLabelsInput, containerLabelReplacementRules]}
										],
										(* otherwise just set to SamplesIn *)
										{samplesInput, sampleLabelsInput, sampleContainerLabelsInput}
									]
								]

							]
						];

						If[TrueQ[$QuantifyCellsDebugFlag], time2 = Now;Echo["Updating aliquot simulation took "<>ToString[Convert[time2 - time1, Second]]<>" to finish!", "Options Resolver"]];

						(* assemble the results to return *)
						result = {
							(* resolved method-specific options *)
							ReplaceRule[
								Normal[KeyTake[optionsInput, Keys[optionsMap]], Association],
								childOptions,
								(* must specify Append to False b/c we do not wanna append any additional options in the child experiment function that does not exist in QuantifyCells *)
								Append -> False
							],
							(* resolved instruments *)
							(* now we need to replace back the instrument to be the user specified value, since we overid user specified model to be the exact instrument object when pre-resolving instrument *)
							If[MatchQ[specifiedInstrument, Except[Automatic]],
								specifiedInstrument,
								Lookup[childOptionsRenamed, Instrument]
							],
							(* tests of the child experiment function calls *)
							childFunctionTests,
							(* return the child options so we can use them to create the primitive in resource packet, drop the label option since we are going to create label primitives anyway *)
							Normal[KeyDrop[childOptionsRenamed, {SampleLabel, SampleContainerLabel}], Association]
						};

						(* append to the association *)
						AppendTo[runningMethodAssoc, method -> result];

						(* return *)
						result
					]]
			],
			{resolvedMethods, preResolvedInstruments, duplicateMethodQs, expandedSpecifiedInstruments}
		]
	];

	(* if our child did aliquots, we don't want those labels to be propagated upstream *)
	(* these aliquoted samples are only used internally by whatever `childFunction` we had *)
	(* and have no bearing on the QuantifyCells call, however, the presence of meaningless labels in the Simulation *)
	(* will cause trouble for us when we go into sample prep framework *)
	simulationWithAliquot = Module[{newLabels,newLabelsToDelete,sampleLabels,sampleLabelField,cleanedUpSimulation,postResolvingLabels},
		postResolvingLabels = Lookup[simulationWithAliquot[[1]],{Labels, LabelFields}];
		newLabels = Complement[postResolvingLabels[[1,All,1]],existingLabels[[1,All,1]]];
		newLabelsToDelete = Select[newLabels,StringContainsQ[#,"aliquot sample $"]&];

		(* return early if there are no new labels *)
		If[MatchQ[newLabelsToDelete,{}],
			Return[simulationWithAliquot,Module]
		];

		sampleLabels = DeleteCases[postResolvingLabels[[1]],Verbatim[Rule][Alternatives@@newLabelsToDelete,_]];
		sampleLabelField = DeleteCases[postResolvingLabels[[2]],Verbatim[Rule][Alternatives@@newLabelsToDelete,_]];

		(* we need to re-initialize the simulation here which will loose us the simulation ID inside telescope,
		but we don't have a mechanism to delete a label from the simulation otherwise *)
		(* we need to call UpdateSimulation to get those extra keys like Updated and NativeSimulationID back *)
		cleanedUpSimulation=UpdateSimulation[Simulation[],
			Simulation@{
				Packets->Lookup[simulationWithAliquot[[1]],Packets],
				Labels->sampleLabels,
				LabelFields->sampleLabelField,
				SimulatedObjects->Lookup[simulationWithAliquot[[1]],SimulatedObjects]
			}]
	];

	(* Resolve Post Processing Options *)
	resolvedPostProcessingOptions = resolvePostProcessingOptions[myOptionsWithPreresolvedOptions,Living->True];

	(* get the resolved Email option; for this experiment, the default is True if it's a parent protocol, and False if it's a sub *)
	{specifiedEmail, specifiedParentProtocol} = Lookup[myOptionsWithPreresolvedOptions, {Email, ParentProtocol}];
	resolvedEmail = If[MatchQ[specifiedEmail, Automatic],
		NullQ[specifiedParentProtocol],
		specifiedEmail
	];

	(* Gather all resolved options *)
	resolvedOptions = ReplaceRule[
		myOptionsWithPreresolvedOptions,
		Flatten[{
			{
				Preparation -> resolvedPreparation,
				WorkCell -> resolvedWorkCell,
				SampleLabel -> resolvedSampleLabels,
				SampleContainerLabel -> resolvedSampleContainerLabels,
				Methods -> resolvedMethods,
				QuantificationUnit -> resolvedQuantificationUnits /. $CellQuantificationUnitToStringLookup,
				Instruments -> resolvedInstruments,
				AbsorbanceStandardCurve -> resolvedAbsorbanceStandardCurves,
				NephelometryStandardCurve -> resolvedNephelometryStandardCurves,
				Email -> resolvedEmail,
				ResolvedMethodPrimitiveOptions -> resolvedMethodPrimitiveOptions
			},
			resolvedMethodOptions,
			resolvedPostProcessingOptions
		}],
		Append -> False
	] /. Automatic -> Null; (* at this point, it is safe to just replace any Automatic with Nulls since those remaining should pertain to a method that was not specified *)

	(* make a mapthread friendly resolved option for error checking *)
	mapThreadFriendlyResolvedOptions = OptionsHandling`Private`mapThreadOptions[ExperimentQuantifyCells, resolvedOptions];

	(* --- ERROR/WARNING CHECKING --- *)

	(* --- Error: each method can only be specified ONCE --- *)
	(* get the duplicated method names *)
	duplicatedMethods = Cases[
		Tally[resolvedMethods],
		{method_, GreaterP[1]} :> method
	];

	(* set invalid options *)
	duplicatedMethodsInvalidOptions = If[Length[duplicatedMethods] > 0, {Methods}, {}];

	(* throw messages *)
	If[Length[duplicatedMethods] > 0 && messages,
		Message[Error::DuplicatedMethods, duplicatedMethods]
	];

	(* make tests *)
	duplicatedMethodsTest = If[gatherTests,
		Test["Methods do not contain duplicated elements:",
			Length[duplicatedMethods] === 0,
			True
		],
		Nothing
	];
	(* --- Error:: no possible method options --- *)
	noMethodToUseInvalidOptions = If[TrueQ[noMethodToUse],
		Intersection[
			Keys[Select[myOptions, MatchQ[Values[#],ListableP[Null]]&]], Lookup[Lookup[$QuantifyCellsMethodInformationLookup, #, <||>], "NotNullOptions"]
		]& /@ allMethods,
		{}
	];
	(* throw messages *)
	If[Length[noMethodToUseInvalidOptions] > 0 && messages,
		Message[Error::NoQuantifyCellsMethodToUse,
			noMethodToUseInvalidOptions[[1]], allMethods[[1]],
			noMethodToUseInvalidOptions[[2]], allMethods[[2]]
		]
	];

	(* make tests *)
	noMethodToUseTest = If[gatherTests,
		Test["Specified options do not have Nulls for required options for both Absorbance and Nephelometry:",
			Length[noMethodToUseInvalidOptions] === 0,
			True
		],
		Nothing
	];


	(* --- Error:: conflicting method options --- *)
	(* set invalid options *)
	conflictingMethodInfo = If[TrueQ[noMethodToUse],
		(* If we triggered noMethodToUse, don't bother checking conflicting method options *)
		{},
		Map[
			Function[{methodToCheck},
				Module[{methodSpecificOptions, methodSpecificOptionsFullList, optionsMap, childFunction, mappedMethodSpecificOptions,
					allowNullQs, allowNullMethodSpecificOptions, requiredMethodSpecificOptions, runningConflictOptions},
					(* get the method specific options *)
					methodSpecificOptions = uniqueMethodOptions[methodToCheck];

					(* get the options map *)
					optionsMap = Lookup[Lookup[$QuantifyCellsMethodInformationLookup, methodToCheck, <||>], "OptionsMap", {}];

					(* get the child experiment function we are going to call to resolve the method-specific options *)
					childFunction = Lookup[Lookup[$QuantifyCellsMethodInformationLookup, methodToCheck, <||>], "Function"];

					(* get the allow null options from the child experiment function *)
					mappedMethodSpecificOptions = methodSpecificOptions /. optionsMap;
					allowNullQs = Map[
						Lookup[
							FirstCase[OptionDefinition[childFunction], KeyValuePattern["OptionSymbol" -> #], <||>],
							"AllowNull",
							False
						]&,
						mappedMethodSpecificOptions
					];
					allowNullMethodSpecificOptions = PickList[methodSpecificOptions, allowNullQs];

					(* get the options that MUST be specified or remain Null *)
					requiredMethodSpecificOptions = Complement[methodSpecificOptions, allowNullMethodSpecificOptions];

					runningConflictOptions = {};
					(* there is a conflict if: *)
					If[
						Or[
							(* if method and instrument are specified, instrument is not the type that method allows *)
							(* Note that resolvedInstrument could be left Automatic here if there were errors in child resolver. We do not want to throw a conflict here if it is Automatic. *)
							MemberQ[resolvedMethods, methodToCheck] && !MatchQ[resolvedInstruments,ListableP[Automatic]] && !MemberQ[resolvedInstruments, ObjectP[$QuantifyCellsMethodInformationLookup[methodToCheck]["Instrument"]]],
							(* instrument contains a type of a specific method that is not specified in Methods *)
							!MemberQ[resolvedMethods, methodToCheck] && !MatchQ[resolvedInstruments,ListableP[Automatic]] && MemberQ[resolvedInstruments, ObjectP[$QuantifyCellsMethodInformationLookup[methodToCheck]["Instrument"]]]
						],
						AppendTo[runningConflictOptions, Instruments]
					];

					(* options that must be specified are not specified *)
					If[
						MemberQ[resolvedMethods, methodToCheck] && MemberQ[Lookup[resolvedOptions, requiredMethodSpecificOptions], _?(MemberQ[ToList[#], NullP]&)],
						AppendTo[
							runningConflictOptions,
							PickList[
								requiredMethodSpecificOptions,
								Lookup[myOptions, requiredMethodSpecificOptions],
								_?(MemberQ[ToList[#], NullP]&)
							]
						]
					];
					(* Note that we have to add the standardXX options here so that the error will be thrown if e.g. NephelometryStandardCurve is specified but Methods is specified as Absorbance. It cannot be directly added to the evaluation of methodSpecificOptions  because are not options in child function. *)
					(* get a list that also include  the standard curve and coefficient options *)
					methodSpecificOptionsFullList = joinWithMethodStandardOptions[methodToCheck, methodSpecificOptions];
					(* if method is not specified options that must remain Null are not Null *)
					If[
						And[
							!MemberQ[resolvedMethods, methodToCheck],
							MemberQ[
								Lookup[
									resolvedOptions,
									methodSpecificOptionsFullList
								],
								Except[NullP|ListableP[Automatic]]
							]
						],
						AppendTo[
							runningConflictOptions,
							PickList[
								methodSpecificOptionsFullList,
								Lookup[myOptions, methodSpecificOptionsFullList],
								Except[NullP|ListableP[Automatic]]
							]
						]
					];

					(* return *)
					If[Length[Flatten[runningConflictOptions]] > 0,
						{methodToCheck, Flatten[runningConflictOptions]},
						Nothing
					]
				]
			],
			List @@ CellQuantificationMethodP
		]
	];
	conflictingMethodClauses = Module[{methodOptionsMustNotBeNull, methodOptionsMustBeNullOrAutomatic},
		(* Pull from conflictingMethodInfo *)
		methodOptionsMustNotBeNull = Intersection[conflictingMethodInfo[[All, 1]], resolvedMethods];
		methodOptionsMustBeNullOrAutomatic = Complement[conflictingMethodInfo[[All, 1]], resolvedMethods];
		(* Return the clauses by looping over the conflictingMethodInfo *)
		Map[
			Which[
				(* the method is specified, but it has method-specific required option speicifed to Null *)
				MemberQ[methodOptionsMustNotBeNull, #[[1]]],
					StringJoin[
						ToString[#[[1]]],
						" is specified in the Methods option, method-specific options ",
						ToString[#[[2]]],
						" must not contain Null or unsupported instrument types. "
					],
				(* the method is not specified, but it has method-specific required option speicifed to not Null or automatic *)
				MemberQ[methodOptionsMustBeNullOrAutomatic, #[[1]]],
					StringJoin[
						ToString[#[[1]]],
						" is not included in the specified Methods, method-specific options ",
						ToString[#[[2]]],
						" must remain Null or Automatic. "
					],
				True,
					Nothing
			]&,
			conflictingMethodInfo
		]
	];

	(* throw messages *)
	If[Length[conflictingMethodInfo] > 0 && messages,
		Message[Error::ConflictingMethodOptions,
			conflictingMethodInfo[[All, 1]],
			StringJoin[Sequence@@conflictingMethodClauses]
		]
	];

	(* make tests *)
	conflictingMethodOptionsTest = If[gatherTests,
		Test["Methods and method-specific options are compatible:",
			Length[conflictingMethodInfo] === 0,
			True
		],
		Nothing
	];

	(* --- STANDARD CURVE related error checking --- *)

	(* set up variables to check standard curve related warning/errors *)

	(* check for each sample, is it possible to convert from experimental raw unit to quantification unit and return the found standard curve along with the boolean - check definition for checkConvertible[...] helper *)
	(* Transpose[Transpose[...]/@ methods] so the result is index matched to the SamplesIn and in the form of

	{
		{{bool, stdCurve}, ...<< # of ResolvedMethods >>... ,{bool, stdCurve}},
		...<< # of SamplesIn >>... ,
		{{bool, stdCurve}, ...<< # of ResolvedMethods >>... ,{bool, stdCurve}}
	}

	 ================================================================
	||   sample   |   method1CheckResult   |   method2CheckResult   ||
	 ================================================================
	||  sample1   |    {True, stdCurve}    |      {False, Null}     ||
	||     .      |            .           |            .           ||
	||     .      |            .           |            .           ||
	||     .      |            .           |            .           ||
	||  sample1   |      {False, Null}     |    {True, stdCurve}    ||
	 ================================================================
	*)
	mapThreadFriendlyConvertibilityCheckResults = Transpose[Transpose[checkConvertible[samplePackets, #, resolvedQuantificationUnits, specifiedQuantificationUnits, mapThreadFriendlyResolvedOptions, fastCache, cache, True (* Yes to generate message clauses *)]]& /@ resolvedMethods];

	(* go through each sample and categorize the standard curve error in the following standard: *)
	{
		(* --- Warning: we cannot convert to quantification unit, nor the experimental raw unit is supported in composition --- *)
		noStandardCurveAvailableInfo,
		(* --- Warning: for a given quantification unit, there exists a standard curve, but is different from user-specified value --- *)
		alternativeStandardCurvesInfo,
		(* --- Warning: for a given quantification unit, we do not need the user specified standard curve to fulfill the conversion --- *)
		redundantStandardCurveInfo
	} = Module[{noStandardCurveAvailableInfoWithNulls, alternativeStandardCurvesInfoWithNulls, redundantStandardCurveInfoWithNulls},
		{
			noStandardCurveAvailableInfoWithNulls,
			alternativeStandardCurvesInfoWithNulls,
			redundantStandardCurveInfoWithNulls,
			convertibilityWarningClauses
		} = Transpose@MapThread[
			Function[{sample, convertibilityCheckResult, index},
				Module[{alternativeStandardCurvesInfoPerSampleWithNulls, redundantStandardCurveInfoPerSampleWithNulls, alternativeStandardCurvesInfoPerSample, redundantStandardCurveInfoPerSample, warningClauses},
					(* if we cannot convert to quantification unit using neither of the resolved Methods, mark this one as no standard curve available *)
					(* also return early in this case since we do not need to do the following checks *)
					If[MatchQ[convertibilityCheckResult, {{False, _, _}..}],
						Return[{{index, sample}, Null, Null, convertibilityCheckResult[[All, 3]]}, Module]
					];

					(* otherwise continue to do a few more checks and categorize *)
					{alternativeStandardCurvesInfoPerSampleWithNulls, redundantStandardCurveInfoPerSampleWithNulls, warningClauses} = Transpose@MapThread[
						Function[{resultPerMethod, method},
							Module[{convertibleQ, alternativeStdCurve, methodStdCurveOptionName, methodStdCoefficientOptionName, methodStdCurve, methodStdCoefficient, sameStdCurveQ, warningClause},

								(* get the bool indicating if we can convert to the target quantification unit or not *)
								(* get the alternative standard curve found by the helper *)
								{convertibleQ, alternativeStdCurve, warningClause} = resultPerMethod;

								(* get the method-specific standard curve/coefficient option names *)
								methodStdCurveOptionName = ToExpression[ToString[method]<>"StandardCurve"];
								methodStdCoefficientOptionName = ToExpression[ToString[method]<>"StandardCoefficient"];

								(* get the specific standard curve/coefficient for the specific sample and specific method *)
								methodStdCurve = Lookup[resolvedOptions, methodStdCurveOptionName][[index]];
								methodStdCoefficient = Lookup[resolvedOptions, methodStdCoefficientOptionName][[index]];

								(* check if the standard curve that can convert the raw experimental result to the target quantification unit is the same as the resolved value *)
								sameStdCurveQ = MatchQ[alternativeStdCurve, ObjectP[methodStdCurve] | methodStdCurve];

								(* if we can convert to the quantification unit, but not using the user-specified standard curve/coefficient *)
								Which[
									(* if alternative standard curve is indeed an object, mark this one as alternative standard curve available *)
									!sameStdCurveQ && MatchQ[alternativeStdCurve, ObjectP[Object[Analysis, StandardCurve]]],
										{{alternativeStdCurve, methodStdCurve, methodStdCurveOptionName}, Null, warningClause},
									(* if alternative standard curve is Null, that means we do not need standard curve to do this conversion, mark this one as standard curve not useful / redundant *)
									!sameStdCurveQ && MatchQ[alternativeStdCurve, Null],
										{Null, {methodStdCurve, methodStdCurveOptionName}, warningClause},
									True,
										{Null, Null, warningClause}
								]
							]
						],
						{convertibilityCheckResult, resolvedMethods}
					];

					(* remove Nulls *)
					alternativeStandardCurvesInfoPerSample = DeleteCases[alternativeStandardCurvesInfoPerSampleWithNulls, Null];
					redundantStandardCurveInfoPerSample = DeleteCases[redundantStandardCurveInfoPerSampleWithNulls, Null];

					(* return the check results *)
					{
						Null,
						If[Length[alternativeStandardCurvesInfoPerSample] > 0, Join[{index, sample}, Transpose[alternativeStandardCurvesInfoPerSample]], Null],
						If[Length[redundantStandardCurveInfoPerSample] > 0, Join[{index, sample}, Transpose[redundantStandardCurveInfoPerSample]], Null],
						Flatten[warningClauses]
					}
				]
			],
			{mySamples, mapThreadFriendlyConvertibilityCheckResults, Range[Length[mySamples]]}
		];

		(* remove Nulls *)
		DeleteCases[Null] /@ {
			noStandardCurveAvailableInfoWithNulls,
			alternativeStandardCurvesInfoWithNulls,
			redundantStandardCurveInfoWithNulls
		}
	];

	(* throw messages *)
	If[Length[noStandardCurveAvailableInfo] > 0 && warnings,
		Message[Warning::NoStandardCurveCoefficientAvailable,
			noStandardCurveAvailableInfo[[All, 1]],
			ObjectToString[noStandardCurveAvailableInfo[[All, 2]], Cache -> cache],
			resolvedMethods,
			Part[resolvedQuantificationUnits, noStandardCurveAvailableInfo[[All, 1]]],
			StringJoin[Sequence@@convertibilityWarningClauses]
		]
	];

	If[Length[alternativeStandardCurvesInfo] > 0 && warnings,
		Message[Warning::AlternativeStandardCurveAvailable,
			alternativeStandardCurvesInfo[[All, 1]],
			ObjectToString[alternativeStandardCurvesInfo[[All, 2]], Cache -> cache],
			ObjectToString[alternativeStandardCurvesInfo[[All, 3]], Cache -> cache],
			Part[resolvedQuantificationUnits, alternativeStandardCurvesInfo[[All, 1]]],
			StringJoin[Sequence@@convertibilityWarningClauses]
		]
	];

	If[Length[redundantStandardCurveInfo] > 0 && warnings,
		Message[Warning::RedundantStandardCurve,
			redundantStandardCurveInfo[[All, 1]],
			ObjectToString[redundantStandardCurveInfo[[All, 2]], Cache -> cache],
			redundantStandardCurveInfo[[All, -1]],
			ObjectToString[redundantStandardCurveInfo[[All, 3]], Cache -> cache],
			Part[resolvedQuantificationUnits, redundantStandardCurveInfo[[All, 1]]]
		]
	];

	(* make tests *)
	noStandardCurveAvailableTest = If[gatherTests,
		Module[{failingTest, passingTest},
			failingTest = If[Length[noStandardCurveAvailableInfo] == 0,
				Nothing,
				Warning["Samples "<>ObjectToString[noStandardCurveAvailableInfo[[All, 2]], Cache -> cache]<>" have standard curves/coefficients to convert the raw experimental result to the quantification unit:", False, True]
			];
			passingTest = If[Length[noStandardCurveAvailableInfo] == Length[mySamples],
				Nothing,
				Warning["Samples "<>ObjectToString[Complement[mySamples, noStandardCurveAvailableInfo[[All, 2]]], Cache -> cache]<>" have standard curves/coefficients to convert the raw experimental result to the quantification unit:", True, True]
			];
			{failingTest, passingTest}
		],
		Nothing
	];

	alternativeStandardCurveAvailableTest = If[gatherTests,
		Module[{failingTest, passingTest},
			failingTest = If[Length[alternativeStandardCurvesInfo] == 0,
				Nothing,
				Warning["Alternative standard curves exist to replace the specified standard curves for samples "<>ObjectToString[alternativeStandardCurvesInfo[[All, 2]], Cache -> cache]<>" and then used to convert the raw experimental result to the quantification unit:", False, True]
			];
			passingTest = If[Length[alternativeStandardCurvesInfo] == Length[mySamples],
				Nothing,
				Warning["Alternative standard curves exist to replace the specified standard curves for samples "<>ObjectToString[Complement[mySamples, alternativeStandardCurvesInfo[[All, 2]]], Cache -> cache]<>" and then used to convert the raw experimental result to the quantification unit:", True, True]
			];
			{failingTest, passingTest}
		],
		Nothing
	];

	redundantStandardCurveTest = If[gatherTests,
		Module[{failingTest, passingTest},
			failingTest = If[Length[redundantStandardCurveInfo] == 0,
				Nothing,
				Warning["Specified standard curves for samples "<>ObjectToString[redundantStandardCurveInfo[[All, 2]], Cache -> cache]<>" is necessary to convert the raw experimental result to the quantification unit:", False, True]
			];
			passingTest = If[Length[redundantStandardCurveInfo] == Length[mySamples],
				Nothing,
				Warning["Specified standard curves for samples "<>ObjectToString[Complement[mySamples, redundantStandardCurveInfo[[All, 2]]], Cache -> cache]<>" is necessary to convert the raw experimental result to the quantification unit:", True, True]
			];
			{failingTest, passingTest}
		],
		Nothing
	];

	(* --- Warning: recouping while sample contains cells --- *)
	recoupContaminationInfo = MapThread[
		Function[{sampleIn, samplePacket, index, recoupSampleQ},
			If[TrueQ[recoupSampleQ],
				Module[{allAnalytes, cellSampleQ},
					(* get all analytes from the given sample *)
					allAnalytes = selectAllAnalytesFromSample[samplePacket, Cache -> cache, AnalyteTypePattern -> ObjectP[Model[Cell]]];
					(* sample is a cell sample if *)
					cellSampleQ = Or[
						(* analytes contains cell molecule *)
						MemberQ[allAnalytes, ObjectP[Model[Cell]]],
						(* CellType is specified for the sample *)
						MatchQ[Lookup[samplePacket, CellType], CellTypeP],
						(* CellType is specified for the sample model *)
						MatchQ[fastAssocLookup[fastCache, sampleIn, {Model, CellType}], CellTypeP]
					];
					(* if this is a cell sample and we are recouping, gotta throw this warning *)
					If[cellSampleQ,
						{index, sampleIn},
						Nothing
					]
				],
				Nothing
			]
		],
		{mySamples, samplePackets, Range[Length[mySamples]], Lookup[resolvedOptions, RecoupSample]}
	];

	(* throw messages *)
	If[Length[recoupContaminationInfo] > 0 && warnings,
		Message[Warning::RecoupContamination,
			recoupContaminationInfo[[All, 1]],
			ObjectToString[recoupContaminationInfo[[All, 2]], Cache -> cache]
		]
	];

	(* make tests *)
	recoupContaminationTest = If[gatherTests,
		Module[{failingTest, passingTest},
			failingTest = If[Length[recoupContaminationInfo] == 0,
				Nothing,
				Warning["Samples "<>ObjectToString[recoupContaminationInfo[[All, 2]], Cache -> cache]<>" are not combined with recouped aliquot samples if they contain cell samples:", False, True]
			];
			passingTest = If[Length[recoupContaminationInfo] == Length[mySamples],
				Nothing,
				Warning["Samples "<>ObjectToString[Complement[mySamples, recoupContaminationInfo[[All, 2]]], Cache -> cache]<>" are not combined with recouped aliquot samples if they contain cell samples:", True, True]
			];
			{failingTest, passingTest}
		],
		Nothing
	];

	(* --- Error: XXXStandardCoefficient is specified but QuantificationUnit is left Automatic --- *)
	missingQuantificationUnitInfo = MapThread[
		Function[{sampleIn, index, specifiedQuantificationUnit, unresolvedOptions},
			Module[{methodStdCoefficientOptionNames, errorQ},

				(* get the option name for StandardCoefficient *)
				methodStdCoefficientOptionNames = ToExpression[ToString[#]<>"StandardCoefficient"]& /@ resolvedMethods;

				(* if StandardCoefficient is specified BUT quantification unit is not, throw error *)
				errorQ = And[
					MatchQ[specifiedQuantificationUnit, Automatic],
					MemberQ[Lookup[unresolvedOptions, methodStdCoefficientOptionNames], _?NumericQ]
				];

				(* collect information *)
				If[errorQ,
					{index, sampleIn, PickList[methodStdCoefficientOptionNames, Lookup[unresolvedOptions, methodStdCoefficientOptionNames], _?NumericQ]},
					Nothing
				]
			]
		],
		{mySamples, Range[Length[mySamples]], Lookup[myOptions, QuantificationUnit], mapThreadFriendlyOptions}
	];

	(* set invalid options *)
	missingQuantificationUnitInvalidOptions = If[Length[missingQuantificationUnitInfo] > 0,
		DeleteDuplicates[Flatten[{missingQuantificationUnitInfo[[All, -1]], QuantificationUnit}]],
		{}
	];

	(* throw messages *)
	If[Length[missingQuantificationUnitInfo] > 0 && messages,
		Message[
			Error::MissingQuantificationUnit,
			missingQuantificationUnitInfo[[All, 1]],
			ObjectToString[missingQuantificationUnitInfo[[All, 2]], Cache -> cache],
			missingQuantificationUnitInfo[[All, -1]]
		]
	];

	(* make tests *)
	missingQuantificationUnitTest = If[gatherTests,
		Module[{failingTest, passingTest},
			failingTest = If[Length[missingQuantificationUnitInfo] == 0,
				Nothing,
				Warning["Samples "<>ObjectToString[missingQuantificationUnitInfo[[All, 2]], Cache -> cache]<>" have QuantificationUnit specified if StandardCoefficient is provided:", False, True]
			];
			passingTest = If[Length[missingQuantificationUnitInfo] == Length[mySamples],
				Nothing,
				Warning["Samples "<>ObjectToString[Complement[mySamples, missingQuantificationUnitInfo[[All, 2]]], Cache -> cache]<>" have QuantificationUnit specified if StandardCoefficient is provided:", True, True]
			];
			{failingTest, passingTest}
		],
		Nothing
	];

	(* check invalid input and invalid option variables and throw Error::InvalidInput or Error::InvalidOption if necessary *)
	invalidInputs = DeleteDuplicates[Flatten[{
		discardedInvalidInputs,
		deprecatedInvalidInputs,
		nonLiquidInvalidInputs
	}]];
	invalidOptions = DeleteDuplicates[Flatten[{
		duplicatedMethodsInvalidOptions,
		noMethodToUseInvalidOptions,
		If[Length[conflictingMethodInfo] > 0,
			{conflictingMethodInfo[[All, 2]], Methods},
			Nothing
		],
		missingQuantificationUnitInvalidOptions,
		If[FailureQ[preparationResult], {Preparation}, {}],
		If[MemberQ[Values[resolvedPostProcessingOptions],$Failed],
			PickList[Keys[resolvedPostProcessingOptions],Values[resolvedPostProcessingOptions],$Failed],
			Nothing]
	}]];

	(* throw Error::InvalidInput *)
	If[Length[invalidInputs] > 0 && messages,
		Message[Error::InvalidInput, ObjectToString[invalidInputs, Cache -> cache]]
	];

	(* throw Error::InvalidOption *)
	If[Length[invalidOptions] > 0 && messages,
		Message[Error::InvalidOption, invalidOptions]
	];

	outputSpecification /. {
		Result -> resolvedOptions,
		Options -> resolvedOptions,
		Simulation -> simulationWithAliquot,
		Tests -> Flatten[{
			discardedTest,
			deprecatedModelTest,
			nonLiquidTest,
			resolvedChildExpTests,
			duplicatedMethodsTest,
			noMethodToUseTest,
			conflictingMethodOptionsTest,
			noStandardCurveAvailableTest,
			alternativeStandardCurveAvailableTest,
			redundantStandardCurveTest,
			recoupContaminationTest,
			missingQuantificationUnitTest,
			preparationTest,
			If[gatherTests,
				postProcessingTests[resolvedPostProcessingOptions],
				Nothing
			]
		}]
	}
];


(* ::Subsubsection:: *)
(*experimentQuantifyCellsResourcePackets*)


DefineOptions[experimentQuantifyCellsResourcePackets,
	Options :> {
		HelperOutputOption,
		CacheOption,
		SimulationOption
	}
];


experimentQuantifyCellsResourcePackets[mySamples:{ObjectP[Object[Sample]]..}, myUnresolvedOptions:{___Rule}, myResolvedOptions:{___Rule}, myOptions:OptionsPattern[]] := Module[
	{
		safeOps, outputSpecification, output, gatherTests, messages, cache, simulation, fastCache, samplePackets,
		sampleLabels, sampleContainerLabels, multiMethodAliquots, methods, instruments, numberOfReplicates, samplesInStorageCondition,
		recoupSamples, resolvedMethodPrimitiveOptions, preparation, sharedAliquotQ, allAliquottedSampleLabels,
		labelSamplePrimitive, samplesInputString, methodPrimitives, recoupSamplePrimitive, allPrimitives, samplesInResources, containersInResources, instrumentResources,
		checkpoints, resolvedOptionsNoHidden, protocolPacket, unitOperationPackets, simulationWithRoboticUOs, runTime, allResourceBlobs, fulfillable, frqTests, testsRule, resultRule
	},

	(* get the safe options *)
	safeOps = SafeOptions[experimentQuantifyCellsResourcePackets, ToList[myOptions]];

	(* pull out the output options *)
	outputSpecification = Lookup[safeOps, Output];
	output = ToList[outputSpecification];

	(* decide if we are gathering tests or throwing messages *)
	gatherTests = MemberQ[output, Tests];
	messages = !gatherTests;

	(* get the cache and simulation *)
	cache = Lookup[safeOps, Cache, {}];
	simulation = Lookup[safeOps, Simulation, Null];

	(* make fast cache *)
	fastCache = makeFastAssocFromCache[cache];

	(* fetch the sample packet *)
	samplePackets = fetchPacketFromFastAssoc[#, fastCache]& /@ mySamples;

	(* Lookup values from resolved options *)
	{
		sampleLabels,
		sampleContainerLabels,
		multiMethodAliquots,
		methods,
		instruments,
		numberOfReplicates,
		samplesInStorageCondition,
		recoupSamples,
		resolvedMethodPrimitiveOptions,
		preparation
	} = Lookup[myResolvedOptions,
		{
			SampleLabel,
			SampleContainerLabel,
			MultiMethodAliquots,
			Methods,
			Instruments,
			NumberOfReplicates,
			SamplesInStorageCondition,
			RecoupSample,
			ResolvedMethodPrimitiveOptions,
			Preparation
		}
	];

	(* --- Set variables --- *)
	(* are we sharing aliquots? *)
	sharedAliquotQ = MatchQ[multiMethodAliquots, Shared];
	allAliquottedSampleLabels = Module[{collapsedAliquotSampleLabels, sampleLengths},
		(* get the aliquot sample labels from resolved child options *)
		collapsedAliquotSampleLabels = ToList[Lookup[#, AliquotSampleLabel]]& /@ resolvedMethodPrimitiveOptions;

		(* get the length of the sample *)
		sampleLengths = Length[mySamples];

		(* pad Nulls if the label option is collapsed which is only possible if it is resolved to Null so it is okay to do padding here *)
		PadRight[#, sampleLengths, Null]& /@ collapsedAliquotSampleLabels
	];

	(* --- make primitives for each of the quantification method with the resolved options --- *)

	(* label primitives for SamplesIn, use ContainerLabel key to also label the ContainersIn *)
	labelSamplePrimitive = LabelSample[
		Sample -> mySamples,
		Label -> sampleLabels,
		ContainerLabel -> sampleContainerLabels
	];

	(* initiate a variable to store the current sample label so we know which one to track, may get updated with aliquotting *)
	samplesInputString = sampleLabels;

	(* for each method, create the corresponding primitive with resolved options *)
	methodPrimitives = MapThread[
		Function[{method, aliquotSampleLabels, methodPrimitiveOptions},
			Module[{childFunction, childPrimitiveHead, optionsInput, allowedPrimitiveOptions, optionsInputCleanedUp, methodPrimitive},

				(* --- get the primitive head --- *)
				(* get the child experiment function specific to the method *)
				childFunction = Lookup[Lookup[$QuantifyCellsMethodInformationLookup, method, <||>], "Function"];
				(* remove the 'Experiment' which will be the primitive head *)
				childPrimitiveHead = ToExpression[StringDelete[ToString[childFunction], "Experiment"]];

				(* --- get the options we are going to put inside the primitive --- *)
				(* these are very dependent on the specific instrument/method so we cannot hard code these to the info lookup table outside the function *)
				optionsInput = Which[
					(* add plate reader mix options, only when we are using a plate reader or nephelometry *)
					Or[
						MatchQ[method, Nephelometry] && !MatchQ[Lookup[methodPrimitiveOptions, PlateReaderMix], ListableP[True]],
						MatchQ[method, Absorbance] && MatchQ[Lookup[myResolvedOptions, AbsorbanceMethod], PlateReader] && !MatchQ[Lookup[methodPrimitiveOptions, PlateReaderMix], ListableP[True]]
					],
					Normal[
						Join[
							(* need to remove the plate reader mix options first before we reset it to True *)
							KeyDrop[methodPrimitiveOptions, {PlateReaderMix, PlateReaderMixRate, PlateReaderMixTime, PlateReaderMixMode}],
							<|PlateReaderMix -> True|>
						],
						Association
					],
					(* mix is a different set of options if we are using cuvette *)
					MatchQ[method, Absorbance] && MatchQ[Lookup[myResolvedOptions, AbsorbanceMethod], Cuvette] && Or[!MatchQ[Lookup[methodPrimitiveOptions, AcquisitionMix], ListableP[True]], !MatchQ[Lookup[methodPrimitiveOptions, AdjustMixRate], ListableP[True]]],
					Normal[
						Join[
							(* need to remove the plate reader mix options first before we reset it to True *)
							KeyDrop[methodPrimitiveOptions, {StirBar, AcquisitionMixRate, AdjustMixRate, MinAcquisitionMixRate, MaxAcquisitionMixRate, AcquisitionMixRateIncrements, MaxStirAttempts}],
							<|AcquisitionMix -> True, AdjustMixRate -> True|>
						],
						Association
					],
					True,
					methodPrimitiveOptions
					(* --- CAN EXPAND TO ADD MORE CASES HERE --- *)
					(* --- IF YOU MODIFY HERE, YOU MUST MODIFY THE SECTION IN HELPER <splitMethodOptions> AS WELL --- *)
				];

				(* get the allowed options for the primitive *)
				allowedPrimitiveOptions = Lookup[#, "OptionSymbol"]& /@ OptionDefinition[childPrimitiveHead];

				(* filter out options that do not exist for the primitive *)
				optionsInputCleanedUp = Normal[KeyTake[optionsInput, allowedPrimitiveOptions], Association];

				(* construct the primitive *)
				methodPrimitive = childPrimitiveHead[
					Sample -> samplesInputString,
					Sequence @@ optionsInputCleanedUp
				];

				(* update the aliquot sample label accordingly *)
				samplesInputString = If[sharedAliquotQ,
					(* if we are sharing aliquots *)
					(* do the replacement to update the aliquot sample labels *)
					MapThread[
						Function[{newLabel, oldLabel},
							If[MatchQ[newLabel, _String],
								newLabel,
								oldLabel
							]
						],
						{aliquotSampleLabels, samplesInputString}
					],
					(* otherwise just do not update *)
					samplesInputString
				];

				(* return the primitive *)
				methodPrimitive
			]
		],
		{methods, allAliquottedSampleLabels, resolvedMethodPrimitiveOptions}
	];

	(* create the recoup sample primitive for any remaining aliquot sample labels *)
	(* for each of the input sample, get all aliquotted samples from it *)
	recoupSamplePrimitive = MapThread[
		Function[{sampleLabel, recoupSampleQ, allAliquottedSampleLabelsPerSample},
			If[TrueQ[recoupSampleQ],
				Module[{aliquottedSampleNeedsRecouping},

					aliquottedSampleNeedsRecouping = If[sharedAliquotQ,
						(* if we are sharing aliquots, only get the first aliquot sample label since that is aliquotted out from the sample *)
						ToList[FirstCase[allAliquottedSampleLabelsPerSample, _String, {}]],
						(* other just get all aliquotted sample labels *)
						Cases[allAliquottedSampleLabelsPerSample, _String]
					];

					(* create the primitive if we have something to transfer back *)
					If[Length[aliquottedSampleNeedsRecouping] > 0,
						Transfer[
							Source -> aliquottedSampleNeedsRecouping,
							Destination -> ConstantArray[sampleLabel, Length[aliquottedSampleNeedsRecouping]],
							Amount -> All,
							SterileTechnique -> True
						],
						Nothing
					]
				],
				Nothing
			]
		],
		{sampleLabels, recoupSamples, Transpose[allAliquottedSampleLabels]}
	];

	(* combine all the primitives *)
	allPrimitives = Flatten[{
		labelSamplePrimitive,
		methodPrimitives,
		recoupSamplePrimitive
	}];

	(* create resources for samplesIn just so we can at least check resource availability with frq *)
	samplesInResources = Module[{uniqueSamples, sampleResourceRules},
		(* get the unique samplesIn *)
		uniqueSamples = DeleteDuplicates[Lookup[samplePackets, Object]];
		(* make the unique sample resource rule *)
		sampleResourceRules = (# -> Resource[Sample -> #, Name -> ToString[Unique[]]])& /@ uniqueSamples;
		(* replace sample with corresponding resources *)
		Lookup[samplePackets, Object] /. sampleResourceRules
	];

	containersInResources = Module[{uniqueContainers},
		(* get all unique containers *)
		uniqueContainers = DeleteDuplicates[Download[Lookup[samplePackets, Container, Null], Object]];
		(* make resources *)
		If[NullQ[#], #, Resource[Sample -> #, Name -> ToString[#]]]& /@ uniqueContainers
	];

	(* create resources for instrument just so we can at least check resource availability with frq *)
	instrumentResources = Resource[Instrument -> #, Time -> 1 * Hour, Name -> "cell quantification instrument "<>ToString[Unique[]]]& /@ instruments;

	(* estimate checkpoints *)
	checkpoints = Module[{quantificationTime},
		(* a super off hand estimate that each quantification method is gonna take 2 hour to finish *)
		quantificationTime = Length[methods] * 2 * Hour;

		(* make the checkpoint *)
		{
			{"Quantifying Samples", quantificationTime, "Cell concentrations of the input samples are measured by different experimental instrumentation specified in Methods.", Link[Resource[Operator -> $BaselineOperator, Time -> quantificationTime]]},
			{"Returning Materials", 20 * Minute, "Samples are retrieved from instrumentation and materials are cleaned and returned to storage.", Link[Resource[Operator -> $BaselineOperator, Time -> 20 * Minute]]}
		}
	];

	(* collapse the options and remove hidden options *)
	resolvedOptionsNoHidden = CollapseIndexMatchedOptions[
		ExperimentQuantifyCells,
		RemoveHiddenOptions[ExperimentQuantifyCells, myResolvedOptions],
		Ignore -> myUnresolvedOptions,
		Messages -> False
	];

	(* --- Generate our protocol and unit operation packet --- *)
	{protocolPacket, unitOperationPackets, simulationWithRoboticUOs, runTime} = If[MatchQ[preparation, Manual],
		(* generate standalone upload packet for Manual *)
		Module[{protocolPacketBasic, populateMethodSpecificFields},
			(* populate basic fields *)
			protocolPacketBasic = <|
				Object -> CreateID[Object[Protocol, QuantifyCells]],
				(* general *)
				Replace[SamplesIn] -> (Link[#, Protocols]& /@ samplesInResources),
				Replace[ContainersIn] -> (Link[#, Protocols]& /@ containersInResources),
				Replace[Instruments] -> instrumentResources,
				Replace[Methods] -> methods,
				Replace[QuantificationUnits] -> Lookup[myResolvedOptions, QuantificationUnit] /. x: CellQuantificationUnitStringP :> ToExpression[x],
				UnresolvedOptions -> myUnresolvedOptions,
				ResolvedOptions -> resolvedOptionsNoHidden,
				MultiMethodAliquots -> multiMethodAliquots,
				(* post processing *)
				Replace[SamplesInStorage] -> samplesInStorageCondition,
				(* developer fields *)
				Replace[QuantificationPrimitives] -> allPrimitives
			|>;

			(* helper to populate the method specific fields *)
			populateMethodSpecificFields[myUploadPacket_Association, myMethods:{CellQuantificationMethodP..}] := Module[{allKeyValuePairs},
				(* get all upload key value pairs *)
				allKeyValuePairs = Map[
					Function[{method},
						Module[{methodOptions},
							(* get the method specific options (might contain shared options between different methods but that is okay since we should have already pre-resolved them in the resolver so they are of the same value anyway *)
							methodOptions = Keys[Lookup[Lookup[$QuantifyCellsMethodInformationLookup, method, <||>], "OptionsMap", {}]];

							(* build the upload rules *)
							Map[
								Function[{option},
									Module[{optionDefinition, optionString, indexMatchedQ, uploadKey, uploadValue},

										(* get the string form of the option name *)
										optionString = ToString[option];

										(* if this is a label option, do not need to upload Label options to protocol object *)
										If[StringEndsQ[optionString, "Label"], Return[Nothing, Module]];

										(* get the option definition *)
										optionDefinition = FirstCase[OptionDefinition[ExperimentQuantifyCells], KeyValuePattern["OptionSymbol" -> option], <||>];

										(* check if the option is a index matched field or not *)
										indexMatchedQ = Or[
											MemberQ[Lookup[optionDefinition, {"IndexMatchingInput", "IndexMatchingParent"}], _String],
											(* if this is aliquot container, or destination well then it is index matched *)
											StringContainsQ[optionString, "AliquotContainer" | "DestinationWell"]
										];

										(* create the key for upload value *)
										uploadKey = If[indexMatchedQ,
											(* if this is an index matched option, we need to make sure the optionName gets pluralized, and wrap Replace around it *)
											Module[{optionStringPluralized, optionPluralized},
												(* pluralize the option name, MM function Pluralize somehow does not work so we are just dealing with some really simple cases here *)
												optionStringPluralized = Which[
													(* ends with y -> ies *)
													StringEndsQ[optionString, "y"],
													StringDrop[optionString, -1]<>"ies",
													(* ends with s, already pluralized *)
													StringEndsQ[optionString, "s"],
													optionString,
													(* just append s *)
													True,
													optionString<>"s"
												];

												(* get the field name symbol in the form of pluralized option name *)
												optionPluralized = ToExpression[optionStringPluralized];

												(* check if this field has a definition in the protocol type *)
												If[MemberQ[Fields[Object[Protocol, QuantifyCells], Output -> Short], optionPluralized],
													(* if the field exists in the object, then wrap Replace around it *)
													Replace[optionPluralized],
													(* otherwise return failed *)
													$Failed
												]
											],
											(* check if this field has a definition in the protocol type *)
											If[MemberQ[Fields[Object[Protocol, QuantifyCells], Output -> Short], option],
												(* if the field exists in the object, then return the field name *)
												option,
												(* otherwise return failed *)
												$Failed
											]
										];

										(* if this field is not defined in the protocol packet, then dont bother making the key value pair *)
										If[FailureQ[uploadKey], Return[Nothing, Module]];

										(* otherwise continue to get the upload value *)
										uploadValue = If[StringContainsQ[optionString, "AliquotContainer"],
											(* special treatment for aliquot container fields since the option may get resolved to something like {1, container} which is not taken by the field pattern *)
											Which[
												(* if it is Null, keep the option value *)
												MatchQ[Lookup[myResolvedOptions, option], Null],
												Lookup[myResolvedOptions, option],
												(* if it is singleton {1, container} or container, expand *)
												MatchQ[Lookup[myResolvedOptions, option], {Null | _?NumericQ, ObjectP[]} | ObjectP[]],
												Module[{container},
													container = FirstCase[Lookup[myResolvedOptions, option], ObjectP[], Null];
													(* expand to match the samples In *)
													ConstantArray[Link[container], Length[mySamples]]
												],
												(* otherwise, try to get the object container from the list *)
												True,
												FirstCase[ToList[#], obj:ObjectP[] :> Link[obj], Null]& /@ Lookup[myResolvedOptions, option]
											],
											(* otherwise do some massage to the option value *)
											Lookup[myResolvedOptions, option, Null] /. {
												(* if the value contains object, then it must be wrapped with Link, we do not have complicated bi-directional links for now so doing it in a simple way here *)
												obj:ObjectP[] :> Link[Download[obj, Object]],
												(* replace Ambient with 25 C *)
												Ambient -> $AmbientTemperature
											}
										];

										(* return the key value pair *)
										uploadKey -> uploadValue
									]
								],
								methodOptions
							]
						]
					],
					methods
				];

				(* we will just use association join since all duplicate keys should have the same value anyway, so it is okay to automatically override them *)
				Join[
					myUploadPacket,
					Association[allKeyValuePairs]
				]
			];

			(* return *)
			{
				(* populate method specific fields *)
				populateMethodSpecificFields[protocolPacketBasic, methods],
				{},
				simulation,
				Null
			}
		],
		(* generate unit operation for Robotic *)
		Module[{roboticFunction, quantificationRoboticUOPackets, quantificationRoboticRunTime, quantificationRoboticSimulation, quantifyCellsPrimitive, quantifyCellUOPacket},
			(* we have already made all the primitives, just need to wrap them with the correct RCP/RSP head *)
			(* get the experiment from the resolved workcell *)
			roboticFunction = Lookup[$WorkCellToExperimentFunction, Lookup[myResolvedOptions, WorkCell], ExperimentRoboticCellPreparation];

			(* get our robotic unit operation packets *)
			{{quantificationRoboticUOPackets, quantificationRoboticRunTime}, quantificationRoboticSimulation} = roboticFunction[
				allPrimitives,
				UnitOperationPackets -> True,
				Output -> {Result, Simulation},
				FastTrack -> Lookup[myResolvedOptions, FastTrack],
				ParentProtocol -> Lookup[myResolvedOptions, ParentProtocol],
				Name -> Lookup[myResolvedOptions, Name],
				Cache -> cache,
				Simulation -> simulation,
				Upload -> False,
				Priority -> Lookup[myResolvedOptions, Priority],
				StartDate -> Lookup[myResolvedOptions, StartDate],
				HoldOrder -> Lookup[myResolvedOptions, HoldOrder],
				QueuePosition -> Lookup[myResolvedOptions, QueuePosition],
				CoverAtEnd -> False
			];

			(* create QuantifyCells unit operation packet *)
			(* get the options plus input for QuantifyCells primitive *)
			quantifyCellsPrimitive = Module[{allowedOptions, simulatedObjectsToLabel, myResolvedOptionsWithLabels},
				(* get the options allowed in UnitOperation *)
				allowedOptions = Lookup[#, "OptionSymbol"]& /@ OptionDefinition[QuantifyCells];

				(* determine which objects in the simulation are simulated and make replace rules for those *)
				simulatedObjectsToLabel = If[NullQ[quantificationRoboticSimulation],
					{},
					Module[{allObjectsInSimulation, simulatedQ},
						(* Get all objects out of our simulation. *)
						allObjectsInSimulation = Download[Lookup[quantificationRoboticSimulation[[1]], Labels][[All, 2]], Object];

						(* Figure out which objects are simulated. *)
						simulatedQ = Experiment`Private`simulatedObjectQs[allObjectsInSimulation, quantificationRoboticSimulation];

						(Reverse /@ PickList[Lookup[quantificationRoboticSimulation[[1]], Labels], simulatedQ]) /. {link_Link :> Download[link, Object]}
					]
				];

				(* then replace any objects in the resolved options with labels from simulation *)
				myResolvedOptionsWithLabels = Module[{myResolvedOptionsWithoutSimulation, myResolvedOptionsAssocWithLabels},
					(* drop the simulation key first so we do not replace those, this returns an Association *)
					myResolvedOptionsWithoutSimulation = KeyDrop[myResolvedOptions, Simulation];

					(* replace any simulated objects with labels *)
					myResolvedOptionsAssocWithLabels = myResolvedOptionsWithoutSimulation /. simulatedObjectsToLabel;

					(* add back the simulation key *)
					myResolvedOptionsAssocWithLabels[Simulation] -> Lookup[myResolvedOptions, Simulation];

					(* convert Simulation to Association *)
					Normal[myResolvedOptionsAssocWithLabels, Association]
				];

				(* take the allowed options *)
				QuantifyCells@Join[
					Normal[KeyTake[myResolvedOptionsWithLabels, allowedOptions], Association],
					{
						Sample -> samplesInResources,
						RoboticUnitOperations -> (Link /@ Lookup[quantificationRoboticUOPackets, Object])
					}
				]
			];

			(* get the unit operation packet for quantify cells *)
			quantifyCellUOPacket = UploadUnitOperation[
				quantifyCellsPrimitive,
				Preparation -> Robotic,
				UnitOperationType -> Output,
				Upload -> False
			];

			(* since we are putting this UO inside RSP, we should re-do the LabelFields so they link via RoboticUnitOperations *)
			quantificationRoboticSimulation=If[Length[quantificationRoboticUOPackets]==0,
				quantificationRoboticSimulation,
				updateLabelFieldReferences[quantificationRoboticSimulation,RoboticUnitOperations]
			];

			(* return *)
			{
				Null,
				Flatten[{quantifyCellUOPacket, quantificationRoboticUOPackets}],
				quantificationRoboticSimulation,
				(* add 10 min to the sub RoboticUOs *)
				quantificationRoboticRunTime + 10 * Minute
			}
		]
	];

	(* get all the resource "symbolic representations" *)
	(* need to pull these at infinite depth because otherwise all resources with Link wrapped around them won't be grabbed *)
	allResourceBlobs = If[MatchQ[preparation, Manual],
		DeleteDuplicates[Cases[Flatten[Values[protocolPacket]], _Resource, Infinity]],
		{}
	];

	(* call fulfillableResourceQ on all resources we created *)
	{fulfillable, frqTests} = Which[
		MatchQ[$ECLApplication, Engine], {True, {}},
		gatherTests, Resources`Private`fulfillableResourceQ[allResourceBlobs, Output -> {Result, Tests}, FastTrack -> Lookup[myResolvedOptions, FastTrack], Cache -> cache, Simulation -> simulation],
		True, {Resources`Private`fulfillableResourceQ[allResourceBlobs, Output -> Result, FastTrack -> Lookup[myResolvedOptions, FastTrack], Messages -> messages, Cache -> cache, Simulation -> simulation], Null}
	];

	(* generate the tests rule *)
	testsRule = Tests -> If[gatherTests,
		frqTests,
		{}
	];

	(* generate the Result output rule *)
	(* if not returning Result, or the resources are not fulfillable, Results rule is just $Failed *)
	(* also returns simulation in the result *)
	resultRule = Result -> If[MemberQ[output, Result] && TrueQ[fulfillable],
		{{protocolPacket, unitOperationPackets}, simulationWithRoboticUOs, runTime},
		$Failed
	];

	(* return the output as we desire it *)
	outputSpecification /. {
		resultRule,
		testsRule
	}
];


(* ::Subsubsection:: *)
(*simulateExperimentQuantifyCells*)


DefineOptions[simulateExperimentQuantifyCells,
	Options :> {
		CacheOption,
		HelperOutputOption,
		SimulationOption
	}
];


simulateExperimentQuantifyCells[
	myResourcePacket:(PacketP[Object[Protocol, QuantifyCells], {Object, ResolvedOptions}] | $Failed | Null),
	myUnitOperationPackets:({PacketP[]...} | $Failed),
	mySamples:{ObjectP[Object[Sample]]...},
	myUnresolvedOptions:{___Rule},
	myResolvedOptions:{___Rule},
	myResolutionOptions:OptionsPattern[]
] := Module[
	{cache, simulation, fastCache, samplePackets, protocolObject, fulfillmentSimulation, compositionSimulation, simulationWithCompositionUpdate, labelSimulation},

	(* Lookup our cache and simulation *)
	cache = Lookup[ToList[myResolutionOptions], Cache, {}];
	simulation = Lookup[ToList[myResolutionOptions], Simulation, Null];

	(* make fast cache *)
	fastCache = makeFastAssocFromCache[cache];

	(* fetch the sample packet *)
	samplePackets = fetchPacketFromFastAssoc[#, fastCache]& /@ mySamples;

	(* Get our protocol ID. This should already be in our protocol packet, unless the resource packets failed. *)
	{protocolObject, fulfillmentSimulation} = Which[
		(* if we have a protocol packet we do not need to do anything here *)
		MatchQ[myResourcePacket, PacketP[Object[Protocol, QuantifyCells], {Object, ResolvedOptions}]],
		{Lookup[myResourcePacket, Object], SimulateResources[myResourcePacket, Cache -> cache, Simulation -> simulation]},
		(* if we are in robotic then we need to make a shell of the framework protocol object *)
		MatchQ[myUnitOperationPackets, {PacketP[]...}],
		Module[{roboticFunction, roboticProtocolObject, roboticProtocolPacket},
			(* create the prep experiment head *)
			roboticFunction = Lookup[$WorkCellToExperimentFunction, Lookup[myResolvedOptions, WorkCell], ExperimentRoboticCellPreparation];

			(* create the protocol ID *)
			roboticProtocolObject = SimulateCreateID[experimentFunctionTypeLookup[roboticFunction]];

			(* make a shell of the protocol packet *)
			roboticProtocolPacket = <|
				Object -> roboticProtocolObject,
				Replace[OutputUnitOperations] -> (Link[#, Protocol]&) /@ Lookup[myUnitOperationPackets, Object],
				ResolvedOptions -> {}
			|>;

			{
				roboticProtocolObject,
				SimulateResources[roboticProtocolPacket, myUnitOperationPackets, ParentProtocol -> Lookup[myResolvedOptions, ParentProtocol, Null], Simulation -> simulation]
			}
		],
		(* otherwise make a shell of quantify cells protocol object *)
		True,
		Module[{quantifyCellsProtocolObject, quantifyCellsProtocolPacket},
			(* create the protocol ID *)
			quantifyCellsProtocolObject = SimulateCreateID[Object[Protocol, QuantifyCells]];

			(* get the protocol packet *)
			quantifyCellsProtocolPacket = <|
				Object -> protocolObject,
				Replace[SamplesIn] -> (Resource[Sample -> #]&) /@ mySamples,
				ResolvedOptions -> myResolvedOptions
			|>;

			{protocolObject, SimulateResources[quantifyCellsProtocolPacket, Cache -> cache, Simulation -> simulation]}
		]
	];

	(* --- simulate the composition update --- *)
	compositionSimulation = Module[{methods, quantificationUnits, mapThreadFriendlyResolvedOptions, specifiedQuantificationUnits, convertibilityCheckResult, simulatedConcentrations},

		(* get the resolved methods, and quantification units *)
		{methods, quantificationUnits} = Lookup[myResolvedOptions, {Methods, QuantificationUnit}];

		(* get the mapthread friendly resolved options *)
		mapThreadFriendlyResolvedOptions = OptionsHandling`Private`mapThreadOptions[ExperimentQuantifyCells, myResolvedOptions];

		specifiedQuantificationUnits = If[KeyExistsQ[myUnresolvedOptions, QuantificationUnit],
			Module[{quantificationUnitsRaw},
				(* get the user specified value *)
				quantificationUnitsRaw = Lookup[myUnresolvedOptions, QuantificationUnit] /. x: CellQuantificationUnitStringP :> ToExpression[x];
				(* if it is already a list with matching length with mySamples, then it must have already been expanded *)
				(* Note that it is possible that it became a list of 1 when there's replicates and the call is made through framework, so we cannot just say it is already expanded if it is a list. *)
				If[MatchQ[quantificationUnitsRaw, _List] && MatchQ[Length[quantificationUnitsRaw],Length[mySamples]],
					quantificationUnitsRaw,
					(* otherwise expand *)
					ConstantArray[First[ToList[quantificationUnitsRaw]], Length[mySamples]]
				]
			],
			(* if user did not supply a value, this is Automatic for all samples *)
			ConstantArray[Automatic, Length[mySamples]]
		];

		(* we need to check if samples are really convertible to the quantification unit before we give it a simulated number *)
		convertibilityCheckResult = checkConvertible[
			samplePackets,
			#,
			quantificationUnits /. x: CellQuantificationUnitStringP :> ToExpression[x],
			specifiedQuantificationUnits,
			mapThreadFriendlyResolvedOptions,
			fastCache,
			cache
		]& /@ ToList[methods];

		(* simulate a flat value for composition update if any *)
		(* flat 0.8 OD600 or 10000 cell/mL - these are very arbitrary numbers though *)
		simulatedConcentrations = Lookup[myResolvedOptions, QuantificationUnit] /. {
			_?(MatchQ[ToExpression[#], UnitsP[OD600]]&) -> 0.8 * OD600,
			_?(MatchQ[ToExpression[#], UnitsP[EmeraldCell / Milliliter]]&) -> 10000 * EmeraldCell / Milliliter
		};

		(* call the helper function to generate the composition update packet, then wrap Simulation to make this a proper simulation *)
		Simulation[
			compositionUpdatePackets[
				samplePackets,
				simulatedConcentrations,
				Now,
				convertibilityCheckResult,
				cache
			]
		]
	];

	(* update the simulation with composition *)
	simulationWithCompositionUpdate = UpdateSimulation[fulfillmentSimulation, compositionSimulation];

	(* --- Upload Labels for unit operations --- *)
	labelSimulation = Simulation[
		Labels -> Join[
			Rule @@@ Cases[
				Transpose[{Lookup[myResolvedOptions, SampleLabel], Lookup[samplePackets, Object]}],
				{_String, ObjectP[]}
			],
			Rule @@@ Cases[
				Transpose[{Lookup[myResolvedOptions, SampleContainerLabel], Lookup[samplePackets, Container]}],
				{_String, ObjectP[]}
			]
		],
		LabelFields -> If[MatchQ[Lookup[myResolvedOptions, Preparation], Manual],
			Join[
				Rule @@@ Cases[
					Transpose[{Lookup[myResolvedOptions, SampleLabel], (Field[SampleLink[[#]]]&) /@ Range[Length[mySamples]]}],
					{_String, _}
				],
				Rule @@@ Cases[
					Transpose[{Lookup[myResolvedOptions, SampleContainerLabel], (Field[SampleLink[[#]][Container]]&) /@ Range[Length[mySamples]]}],
					{_String, _}
				]
			],
			{}
		]
	];

	(* return protocol id and simulation *)
	{
		protocolObject,
		UpdateSimulation[simulationWithCompositionUpdate, labelSimulation]
	}
];



(* ::Subsection:: *)
(*Helpers*)


(* ::Subsubsection:: *)
(*checkConvertible*)

(* helper to check if the raw experimental results can be converted to the given unit for each of the input samples *)
(* return a list of booleans (index matched to the input sample) and the standard curves found (if any) *)
(* also memoize since we really do not need to do this over and over every time we call this helper *)

(* Define an overload that if the input does not have a generateMessageClauses boolean, treat it as False *)
checkConvertible[
	mySamplePackets:{PacketP[Object[Sample]]..},
	myMethod:CellQuantificationMethodP,
	myQuantificationUnits:{CellQuantificationUnitP..},
	myUnresolvedQuantificationUnits:{(Automatic | CellQuantificationUnitP)..},
	myCurrentMapThreadFriendlyOptions_List,
	myFastCacheAssociation_Association,
	myCache_List
] := checkConvertible[mySamplePackets, myMethod, myQuantificationUnits, myUnresolvedQuantificationUnits, myCurrentMapThreadFriendlyOptions, myFastCacheAssociation, myCache] = Module[{},
	(* append to memoization if it has not already *)
	If[!MemberQ[$Memoization, Experiment`Private`checkConvertible],
		AppendTo[$Memoization, Experiment`Private`checkConvertible]
	];
	checkConvertible[mySamplePackets, myMethod, myQuantificationUnits, myUnresolvedQuantificationUnits, myCurrentMapThreadFriendlyOptions, myFastCacheAssociation, myCache, False]
];

checkConvertible[
	mySamplePackets:{PacketP[Object[Sample]]..},
	myMethod:CellQuantificationMethodP,
	myQuantificationUnits:{CellQuantificationUnitP..},
	myUnresolvedQuantificationUnits:{(Automatic | CellQuantificationUnitP)..},
	myCurrentMapThreadFriendlyOptions_List,
	myFastCacheAssociation_Association,
	myCache_List,
	generateMessageClauses: BooleanP
] := checkConvertible[mySamplePackets, myMethod, myQuantificationUnits, myUnresolvedQuantificationUnits, myCurrentMapThreadFriendlyOptions, myFastCacheAssociation, myCache, generateMessageClauses] = Module[{},
	(* append to memoization if it has not already *)
	If[!MemberQ[$Memoization, Experiment`Private`checkConvertible],
		AppendTo[$Memoization, Experiment`Private`checkConvertible]
	];

	(* go over each sample and check convertibility *)
	Transpose@MapThread[
		Function[{quantificationUnit, samplePacket, options, specifiedQuantificationUnit},
			Module[{
				methodUnit, specifiedStandardCoefficient, allAnalytes, specifiedStandardCurve, analyteStandardCurves,
				unitCompatibleQs, absorbanceSameInstrumentQs, absorbanceSameWavelengthQs, allCriteriaFulfilledQs,
				specifiedStandardCurvePackets, allStandardCurvePackets, allStandardCurveProtocolPackets,
				standardCurveTuples, filteredStandardCurveTuples, standardCurveCheckClauses, boolAndCurve},

				(* get the method's default unit *)
				(* special treatment for Absorbance b/c if Wavelength is not set to 600nm, we cannot use OD600 *)
				methodUnit = myMethod /. {
					Nephelometry -> RelativeNephelometricUnit,
					Absorbance -> If[MatchQ[Lookup[options, Wavelength], Automatic | EqualP[600 * Nanometer] | Null],
						OD600,
						AbsorbanceUnit
					]
				};

				(* Short circuit if method unit is the same as the quantification unit,
				of course we can convert it since there is no conversion nor standard curve needed *)
				Which[
					CompatibleUnitQ[methodUnit, quantificationUnit] && TrueQ[generateMessageClauses],
						Return[{True, Null, {}}, Module],
					CompatibleUnitQ[methodUnit, quantificationUnit],
						Return[{True, Null}, Module]
				];
				(* Short circuit if user already provided a XXXStandardCoefficient AND quantification unit for that sample is specified *)
				specifiedStandardCoefficient = Lookup[options, ToExpression[ToString[myMethod]<>"StandardCoefficient"]];
				If[MatchQ[specifiedStandardCoefficient, _?NumericQ] && CompatibleUnitQ[specifiedQuantificationUnit, quantificationUnit], Return[{True, specifiedStandardCoefficient}, Module]];

				(* find all analytes from my given sample *)
				allAnalytes = selectAllAnalytesFromSample[samplePacket, Cache -> myCache, AnalyteTypePattern -> ObjectP[Model[Cell]]];

				(* --- find all the standard curves and their associated protocols --- *)
				(* if user gives the standard curve, make sure we check that too *)
				specifiedStandardCurve = Lookup[options, ToExpression[ToString[myMethod]<>"StandardCurve"]];
				(* Grab their packets *)
				specifiedStandardCurvePackets = fetchPacketFromFastAssoc[specifiedStandardCurve, myFastCacheAssociation];
				(* find all standard curves from sample's composition *)
				analyteStandardCurves = Replace[Flatten[fastAssocPacketLookup[myFastCacheAssociation, #, StandardCurves]& /@ allAnalytes], {(Null | $Failed) -> Nothing}, {1}];
				(* prepend the user specified standard curve if needed *)
				allStandardCurvePackets = If[MatchQ[specifiedStandardCurve, ObjectP[Object[Analysis, StandardCurve]]],
					Prepend[analyteStandardCurves, specifiedStandardCurvePackets],
					analyteStandardCurves
				];
				allStandardCurveProtocolPackets = fastAssocPacketLookup[myFastCacheAssociation, #, Protocol]& /@ Lookup[allStandardCurvePackets, Object, {}];
				(* make a 2-element tuple of them *)
				standardCurveTuples = Transpose[{allStandardCurvePackets, allStandardCurveProtocolPackets}];

				(* --- select the standard curves based on different criteria --- *)
				(* tricky that we need to do special/a more strict selection for analysis curves for Absorbance here b/c it relies heavily on which exact instrument we used and setting *)
				(* So we have 3 checks: 1) unit convertibility, 2) absorbance instruments are the same, and 3) absorbance wavelengths are the same *)
				unitCompatibleQs = Map[
					Function[standardCurvePacket,
						If[MatchQ[myMethod, Absorbance],
							(* Absorbance *)
							If[TrueQ[Lookup[standardCurvePacket, InversePrediction]],
								(* if InversePrediction is True, input and output unit can be swapped *)
								Or[
									MatchQ[Lookup[standardCurvePacket, StandardDataUnits], {UnitsP[AbsorbanceUnit] | UnitsP[OD600], UnitsP[quantificationUnit]}],
									MatchQ[Lookup[standardCurvePacket, StandardDataUnits], {UnitsP[quantificationUnit], UnitsP[AbsorbanceUnit] | UnitsP[OD600]}]
								],
								(* otherwise input/output has to be in the exact order *)
								MatchQ[Lookup[standardCurvePacket, StandardDataUnits], {UnitsP[AbsorbanceUnit] | UnitsP[OD600], UnitsP[quantificationUnit]}]
							],
							(* Nephelometry *)
							If[TrueQ[Lookup[standardCurvePacket, InversePrediction]],
								(* if InversePrediction is True, input and output unit can be swapped *)
								Or[
									MatchQ[Lookup[standardCurvePacket, StandardDataUnits], {UnitsP[methodUnit], UnitsP[quantificationUnit]}],
									MatchQ[Lookup[standardCurvePacket, StandardDataUnits], {UnitsP[quantificationUnit], UnitsP[methodUnit]}]
								],
								(* otherwise input/output has to be in the exact order *)
								MatchQ[Lookup[standardCurvePacket, StandardDataUnits], {UnitsP[methodUnit], UnitsP[quantificationUnit]}]
							]
						]
					],
					standardCurveTuples[[All,1]]
				];
				absorbanceSameInstrumentQs = Map[
					Function[standardCurveProtocolPacket,
						If[MatchQ[myMethod, Absorbance],
							(* Absorbance *)
							Module[{methodInsts, absorbanceMethod, stdCurveInst},
								(* get the instrument used by the method *)
								methodInsts = PickList[ToList[Lookup[options, Instruments]], ToList[Lookup[options, Methods]], Absorbance];
								(* get the specified AbsorbanceMethod, instrument must be compatible with this method *)
								absorbanceMethod = Lookup[options, AbsorbanceMethod];
								(* get the instrument used by the standardCurveProtocol *)
								stdCurveInst = Lookup[standardCurveProtocolPacket, Instrument];
								Or[
									(* specified instrument is the EXACT SAME instrument object *)
									MemberQ[methodInsts, ObjectP[stdCurveInst]],
									(* specified instrument is a model that is EXACT SAME as the standard curve protocol instrument *)
									MemberQ[methodInsts, ObjectP[fastAssocLookup[myFastCacheAssociation, stdCurveInst, Model]]],
									(* otherwise the instrument used by the protocol must be compatible with the absorbance method and it is NOT Lunatic *)
									(!MatchQ[fastAssocLookup[myFastCacheAssociation, stdCurveInst, Model], ObjectP[Model[Instrument, PlateReader, "id:N80DNj1lbD66"]]]) && MatchQ[stdCurveInst, ObjectP[Object[Instrument, absorbanceMethod /. Cuvette -> Spectrophotometer]]],
									(* specified instrument and the specific absorbance method is Automatic, which is okay *)
									MatchQ[{methodInsts, absorbanceMethod}, {{Automatic..}, Automatic}]
								]
							],
							(* Nephelometry does not fail this check *)
							True
						]
					],
					standardCurveTuples[[All, 2]]
				];
				absorbanceSameWavelengthQs =  Map[
					Function[standardCurveProtocolPacket,
						If[MatchQ[myMethod, Absorbance],
							(* Absorbance *)
							If[MatchQ[Lookup[options, Wavelength], Except[Automatic]],
								(* To list just in case it fails in unexpected way, this ContainsOnly will still evaluate *)
								ContainsOnly[ToList[Lookup[standardCurveProtocolPacket, Wavelengths, Null]], ToList[Lookup[options, Wavelength]], SameTest -> Equal],
								True
							],
							(* Nephelometry does not fail this check *)
							True
						]
					],
					standardCurveTuples[[All, 2]]
				];
				(* combine results for each standard curve check *)
				allCriteriaFulfilledQs = (And @@ #) & /@ Transpose[{unitCompatibleQs, absorbanceSameInstrumentQs, absorbanceSameInstrumentQs}];

				(* If the user specified standard curves, check whats wrong and generate clauses as needed *)
				standardCurveCheckClauses = If[And[
					MatchQ[specifiedStandardCurve, ObjectP[Object[Analysis, StandardCurve]]],
					TrueQ[generateMessageClauses],
					MemberQ[allCriteriaFulfilledQs, False]
				],
					{
						"The standard curve ",
						ObjectToString[Download[specifiedStandardCurvePackets, Object]],
						" specified in option ",
						ToString[myMethod],
						"StandardCurve will not be used because ",
						(* Join them into ..., OR ... and ... OR ..., ..., and ... format as needed *)
						joinClauses[
							{
								(* If there's unit incompatible unit *)
								If[!TrueQ[unitCompatibleQs[[1]]],
								"the StandardDataUnits do not match the raw experimental unit and quantification unit",
								Nothing
								],
								(* If the absorbance instruments are not the same *)
								If[!TrueQ[absorbanceSameInstrumentQs[[1]]],
									"the Instrument of the protocol that obtained this standard curve is not the same object or model as the one used in this ExperimentQuantifyCells call",
									Nothing
								],
								If[!TrueQ[absorbanceSameWavelengthQs[[1]]],
									"the Wavelength used in the protocol that obtained this standard curve is not the same as the wavelength used in this ExperimentQuantifyCells call",
									Nothing
								]
							}
						]
					},
					(* Otherwise no need to generate message *)
					{}
				];

				(* use the criteria to filter to see if we have any analysis functions available *)
				filteredStandardCurveTuples = PickList[standardCurveTuples, allCriteriaFulfilledQs];
				(* Calculat the standard returns: boolean and standard curve found *)
				boolAndCurve = Which[
					(* if the user specified standard curve can be used, we will use that *)
					Length[filteredStandardCurveTuples] > 0 && MemberQ[Lookup[filteredStandardCurveTuples[[All, 1]]], specifiedStandardCurve],
					{True, Download[specifiedStandardCurve, Object]},
					(* otherwise use the most recent standard curve *)
					Length[filteredStandardCurveTuples] > 0,
					{True, Lookup[First[MaximalBy[filteredStandardCurveTuples[[All, 1]], Lookup[#, DateCreated]&]], Object]},
					(* otherwise we cannot do this conversion *)
					True,
					{False, Null}
				];
				(* return with or without messsage clauses *)
				If[TrueQ[generateMessageClauses],
					Append[boolAndCurve, standardCurveCheckClauses],
					boolAndCurve
				]
			]
		],
		{myQuantificationUnits, mySamplePackets, myCurrentMapThreadFriendlyOptions, myUnresolvedQuantificationUnits}
	]];


(* ::Subsection:: *)
(*helpers*)


(* ::Subsubsection:: *)
(*splitMethodOptions*)
(* split child method options from a list of given options for a given method *)
(* memoize since really there is no need to reevaluate this over and over again *)

splitMethodOptions[myOptions:{(_Rule | _RuleDelayed)...}, myMethod:CellQuantificationMethodP, myInstrument:(Automatic | ObjectP[{Object[Instrument], Model[Instrument]}])] := splitMethodOptions[myOptions, myMethod, myInstrument] = Module[
	{childFunction, optionsMap, additionalConstantOptions, methodOptions, methodOptionsWithDefault},

	(* append to memoization if it has not already *)
	If[!MemberQ[$Memoization, Experiment`Private`splitMethodOptions],
		AppendTo[$Memoization, Experiment`Private`splitMethodOptions]
	];

	(* get the child experiment function *)
	childFunction = Lookup[Lookup[$QuantifyCellsMethodInformationLookup, myMethod, <||>], "Function"];

	(* get the options map for the method *)
	optionsMap = Lookup[Lookup[$QuantifyCellsMethodInformationLookup, myMethod, <||>], "OptionsMap", {}];

	(* these are very dependent on the specific instrument/method so we cannot hard code these to the info lookup table outside the function *)
	additionalConstantOptions = Which[
		(* add plate reader mix options, only when we are using a plate reader or nephelometry *)
		Or[
			MatchQ[myMethod, Nephelometry],
			MatchQ[myMethod, Absorbance] && MatchQ[Lookup[myOptions, AbsorbanceMethod], PlateReader]
		],
		<|PlateReaderMix -> True|>,
		(* mix is a different set of options if we are using cuvette *)
		MatchQ[myMethod, Absorbance] && MatchQ[Lookup[myOptions, AbsorbanceMethod], Cuvette],
		<|AcquisitionMix -> True, AdjustMixRate -> True|>,
		True,
		<||>
		(* --- CAN EXPAND TO ADD MORE CASES HERE --- *)
		(* --- IF YOU MODIFY HERE, YOU MUST MODIFY THE RESOURCE PACKET AS WELL --- *)
	];

	(* sort out the initial method options *)
	methodOptions = Join[
		(* take the options from the optionsMap as well as any commonly shared options *)
		KeyTake[myOptions,
			Join[Keys[optionsMap], {Preparation, WorkCell, NumberOfReplicates, SamplesInStorageCondition}]
		],
		(* if there is any option that needs to stay constant in the info lookup, get those options *)
		Association[Lookup[Lookup[$QuantifyCellsMethodInformationLookup, myMethod, <||>], "ConstantOptions", {}]],
		(* plus the additional method dependent constant options *)
		additionalConstantOptions,
		(* plus the instrument option and that we are not doing post processing at all for cell bio *)
		<|
			Instrument -> myInstrument,
			MeasureWeight -> False,
			MeasureVolume -> False,
			ImageSample -> False
		|>
	];

	(* replace any Automatics with experiment default *)
	methodOptionsWithDefault = Module[{replacementRules},
		(* create a replacement rule to replace Automatic from defaults of either QuantifyCells or child experiment function option definitions *)
		replacementRules = KeyValueMap[
			Function[{option, value},
				Module[{quantifyCellDefaultValue, mappedOptionName, childFunctionDefaultValue},
					(* get the default value for the specific option if we have one from the info lookup *)
					quantifyCellDefaultValue = Lookup[Lookup[Lookup[$QuantifyCellsMethodInformationLookup, myMethod, <||>], "OptionsDefault", {}], option, Automatic];

					(* convert the option according to options map *)
					mappedOptionName = If[MemberQ[Keys[optionsMap], option],
						option /. optionsMap,
						option
					];
					(* get the default value for the specific option if we have one from the child experiment function *)
					childFunctionDefaultValue = ReleaseHold@Lookup[
						FirstCase[OptionDefinition[childFunction], KeyValuePattern["OptionSymbol" -> mappedOptionName], <||>],
						"Default",
						Automatic
					];
					(* create the replacement rule *)
					Which[
						MatchQ[quantifyCellDefaultValue, Except[Automatic]],
						option -> (value /. {Automatic -> quantifyCellDefaultValue}),
						MatchQ[childFunctionDefaultValue, Except[Automatic]],
						option -> (value /. {Automatic -> childFunctionDefaultValue}),
						True,
						Nothing
					]
				]
			],
			methodOptions
		];

		(* do the replacement using MM's default Association join rule (of replacing the same key) *)
		Join[
			methodOptions,
			Association[replacementRules]
		]
	];

	(* return the list form *)
	Normal[methodOptionsWithDefault, Association]
];


(* ::Subsubsection:: *)
(*compositionUpdatePackets*)


(* generate composition update packet for QuantifyCells expt *)
compositionUpdatePackets[
	mySamplePackets:{PacketP[Object[Sample]]..},
	myNewConcentrations:{(CompositionP | Null)..},
	myDate:(_?DateObjectQ | Null),
	myConvertibilityCheckResult:{{{BooleanP...}, {___}}...},
	myCache_List
] := Module[
	{
		quantificationUnitConvertibleQs,
		samplesAllAnalytes, exactlyOneAnalyteQs, compositionUpdatableQs, infoTuples
	},

	(* union all the booleans (from different methods) to be a single boolean for each sample *)
	quantificationUnitConvertibleQs = Or @@@ Transpose[myConvertibilityCheckResult[[All, 1]]];

	(* check how many analytes are there for each sample *)
	samplesAllAnalytes = selectAllAnalytesFromSample[mySamplePackets, Cache -> myCache, AnalyteTypePattern -> ObjectP[Model[Cell]]];
	exactlyOneAnalyteQs = Length[#] === 1& /@ samplesAllAnalytes;

	(* we consider a sample to be composition updatable if they are both: 1) there exists standard curve/coefficient to convert it to the quantification unit; 2) only one analyte is included in the composition *)
	compositionUpdatableQs = And @@@ Transpose[{quantificationUnitConvertibleQs, exactlyOneAnalyteQs}];

	(* collect the info we need for make new compositions *)
	infoTuples = MapThread[
		Function[{samplePacket, compositionUpdatableQ, allAnalytesPerSample, newConcentration},
			If[TrueQ[compositionUpdatableQ] && MatchQ[newConcentration, CompositionP],
				Module[{oldComposition, analyteToUpdate, newComposition},
					(* get the sample's current composition, scrub any existing link id *)
					oldComposition = Lookup[samplePacket, Composition] /. {link_Link :> Link[link]};

					(* get the analyte that we are going to update concentration with *)
					analyteToUpdate = First[allAnalytesPerSample];

					(* create the new composition *)
					newComposition = Prepend[
						DeleteCases[oldComposition, {_, LinkP[analyteToUpdate], _}],
						{newConcentration, Link[Download[analyteToUpdate, Object]], myDate}
					];

					(* return the info that DefineComposition needs *)
					{Lookup[samplePacket, Object], newComposition}
				],
				Nothing
			]
		],
		{mySamplePackets, compositionUpdatableQs, samplesAllAnalytes, myNewConcentrations}
	];

	(* create the composition update packet *)
	(* we are deleting duplicates since we do not want to update the composition for the same sample over and over again *)
	<|Object -> #[[1]], Replace[Composition] -> #[[2]]|>& /@ DeleteDuplicates[infoTuples]
];


