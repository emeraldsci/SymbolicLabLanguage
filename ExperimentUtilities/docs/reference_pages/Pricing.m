(* ::Package:: *)

(* ::Text:: *)
(*\[Copyright] 2011-2023 Emerald Cloud Lab, Inc.*)

(* ::Subsubsection:: *)
(*PriceProtocol*)

(* TODO the symbol is private, but the usage still should be updated at some point *)
DefineUsage[
	PriceProtocol,
	{
		BasicDefinitions -> {
			{"PriceProtocol[protocol]", "table", "provides a 'table' listing the pricing information for the 'protocol'."},
			{"PriceProtocol[notebook, Span[startDate, endDate]]", "table", "provides a 'table' listing the pricing information for all protocols in 'notebook' between the 'startDate' and 'endDate'."},
			{"PriceProtocol[notebook]", "table", "provides a 'table' listing the pricing information for all completed protocols in 'notebook' between Now and one month before Now."},
			{"PriceProtocol[team, Span[startDate, endDate]]", "table", "provides a 'table' listing the pricing information for all waste generated by all completed protocols in notebooks financed by 'team' between the 'startDate' and 'endDate'."},
			{"PriceProtocol[team]", "table", "provides a 'table' listing the pricing information for all waste generated by all completed protocols in notebooks financed by 'team' between Now and one month before Now."}
		},
		MoreInformation -> {
			"The pricing is based on the PricePerExperiment for the Bill used for this protocol and is the protocol was a Priority one.",
			"Pricing information is only calculated for Completed root protocols.",
			"For the Team or Notebook overloads, non-Completed and non-root protocols are filtered out and not displayed.",
			"By default, if teams or notebooks are specified and no date range is provided, function defaults to showing protocols completed in the past 30 days.",
			"Note that the prices displayed in this documentation are only for the sake of example and do not represent actual prices."
		},
		Input :> {
			{"protocol", ListableP[ObjectP[{Object[Protocol], Object[Qualification], Object[Maintenance]}]], "The protocol(s) whose pricing for waste generated is calculated."},
			{"notebook", ListableP[ObjectP[Object[LaboratoryNotebook]]], "The notebook(s) whose pricing for waste generated for all its protocols is calculated."},
			{"team", ListableP[ObjectP[Object[Team, Financing]]], "The team(s) whose pricing for waste generated for all its protocols is calculated."},
			{"startDate", _?DateObjectQ, "The start date for the span of time of protocols this function is pricing."},
			{"endDate", _?DateObjectQ, "The end date for the span of time of protocols this function is pricing."}
		},
		Output :> {
			{"table", _Pane, "A table displaying information about the price for each protocol."},
			{"associations", {WastePriceTableP...}, "A list of associations containing information about each waste generated, what protocol generated it, how much it generated, and the price for that weight (returned if OutputFormat -> Association)."}
		},
		Sync -> Automatic,
		SeeAlso -> {
			"PriceStorage",
			"PriceInstrumentTime",
			"PriceMaterials",
			"PriceTransactions"
		},
		Author -> {"alou", "robert", "dima"}
	}
];


(* ::Subsubsection:: *)
(*PriceStorage*)


DefineUsage[
	PriceStorage,
	{
		BasicDefinitions -> {
			{
				Definition -> {"PriceStorage[protocol]", "table"},
				Description -> "provides a 'table' listing the pricing information for all the items stored in the 'protocol'.",
				Inputs :> {
					{
						InputName -> "protocol",
						Description -> "The protocol(s) or transaction(s) whose pricing for item storage is calculated.",
						Widget -> Adder[Widget[Type -> Object, Pattern :> ObjectP[{Object[Protocol], Object[Qualification], Object[Maintenance], Object[Transaction]}]]]
					}
				},
				Outputs :> {
					{
						OutputName -> "table",
						Description -> "A table displaying information about each type of storage condition, including what object is stored, for how long, and its price for that length of time.",
						Pattern :> _Grid
					},
					{
						OutputName -> "associations",
						Description -> "A list of associations containing information about each item, its storage conditions, how long it has been stored at that condition within the provided date range, and the price for that item (returned if OutputFormat -> Association).",
						Pattern :> {StoragePriceTableP...}
					}
				}
			},


			{
				Definition -> {"PriceStorage[notebook]", "table"},
				Description -> "provides a 'table' listing the pricing information for all items stored in 'notebook' as a monthly rate based on the current status of all items.",
				Inputs :> {
					{
						InputName -> "notebook",
						Description -> "The notebook(s) whose pricing for item storage is calculated.",
						Widget -> Adder[Widget[Type -> Object, Pattern :> ObjectP[Object[LaboratoryNotebook]]]]
					}
				},
				Outputs :> {
					{
						OutputName -> "table",
						Description -> "A table displaying information about each type of storage condition, including what object is stored, for how long, and its price for that length of time.",
						Pattern :> _Grid
					},
					{
						OutputName -> "associations",
						Description -> "A list of associations containing information about each item, its storage conditions, how long it has been stored at that condition within the provided date range, and the price for that item (returned if OutputFormat -> Association).",
						Pattern :> {StoragePriceTableP...}
					}
				}
			},


			{
				Definition -> {"PriceStorage[notebook, dateRange]", "table"},
				Description -> "provides a 'table' listing the pricing information for all items stored in 'notebook' in the time period defined by the 'dateRange'.",
				Inputs :> {
					{
						InputName -> "notebook",
						Description -> "The notebook(s) whose pricing for item storage is calculated.",
						Widget -> Adder[Widget[Type -> Object, Pattern :> ObjectP[Object[LaboratoryNotebook]]]]
					},
					{
						InputName -> "dateRange",
						Description -> "The span of time of protocols this function is pricing.",
						(* TODO is this the correct type? *)
						Widget -> Widget[Type -> Expression, Pattern :> Span[_?DateObjectQ, _?DateObjectQ], Size -> Word]
					}
				},
				Outputs :> {
					{
						OutputName -> "table",
						Description -> "A table displaying information about each type of storage condition, including what object is stored, for how long, and its price for that length of time.",
						Pattern :> _Grid
					},
					{
						OutputName -> "associations",
						Description -> "A list of associations containing information about each item, its storage conditions, how long it has been stored at that condition within the provided date range, and the price for that item (returned if OutputFormat -> Association).",
						Pattern :> {StoragePriceTableP...}
					}
				}
			},


			{
				Definition -> {"PriceStorage[team]", "table"},
				Description -> "provides a 'table' listing the pricing information for all items stored in notebooks financed by 'team' as a monthly rate based on the current status of all items.",
				Inputs :> {
					{
						InputName -> "team",
						Description -> "The team(s) whose pricing for item storage is calculated.",
						Widget -> Widget[Type -> Object, Pattern :> ObjectP[Object[Team, Financing]]]
					}
				},
				Outputs :> {
					{
						OutputName -> "table",
						Description -> "A table displaying information about each type of storage condition, including what object is stored, for how long, and its price for that length of time.",
						Pattern :> _Grid
					},
					{
						OutputName -> "associations",
						Description -> "A list of associations containing information about each item, its storage conditions, how long it has been stored at that condition within the provided date range, and the price for that item (returned if OutputFormat -> Association).",
						Pattern :> {StoragePriceTableP...}
					}
				}
			},


			{
				Definition -> {"PriceStorage[team, dateRange]", "table"},
				Description -> "provides a 'table' listing the pricing information for all items stored in notebooks financed by 'team' in the time period defined by the 'dateRange'.",
				Inputs :> {
					{
						InputName -> "team",
						Description -> "The team(s) whose pricing for item storage is calculated.",
						Widget -> Widget[Type -> Object, Pattern :> ObjectP[Object[Team, Financing]]]
					},
					{
						InputName -> "dateRange",
						Description -> "The span of time of protocols this function is pricing.",
						(* TODO is this the correct type? *)
						Widget -> Widget[Type -> Expression, Pattern :> Span[_?DateObjectQ, _?DateObjectQ], Size -> Word]
					}
				},
				Outputs :> {
					{
						OutputName -> "table",
						Description -> "A table displaying information about each type of storage condition, including what object is stored, for how long, and its price for that length of time.",
						Pattern :> _Grid
					},
					{
						OutputName -> "associations",
						Description -> "A list of associations containing information about each item, its storage conditions, how long it has been stored at that condition within the provided date range, and the price for that item (returned if OutputFormat -> Association).",
						Pattern :> {StoragePriceTableP...}
					}
				}
			}
		},
		MoreInformation -> {
			"The pricing is based upon the PricingRate of each type of storage condition, how large the item being stored is, and for how long it has been stored.",
			"By default, if teams or notebooks are specified and no date range is provided, function shows all pricing information as a monthly rate based on the current status of all items.",
			"Note that if the storage condition of an item has changed within the provided date range, there will be multiple entries in the table for this item (one for each storage condition).",
			"If a protocol is provided, the output will consist of all items, containers, and parts that have the protocol or its subprotocols in their Source field.",
			"If a transaction is provided, the output will consist of all items, containers, and parts that have the transaction in their Source field.",
			"Note that the prices displayed in this documentation are only for the sake of example and do not represent actual prices.",
			"In order to find the real pricing rate for a type of storage condition, please Download the PricingRate field from the corresponding Model[StorageCondition] object."
		},
		Sync -> Automatic,
		SeeAlso -> {
			"PriceWaste",
			"PriceInstrumentTime",
			"PriceTransactions",
			"PriceMaterials",
			"PriceCleaning",
			"SummaryPrice"
		},
		Author -> {"alou", "robert", "steven", "dima"}
	}
];




(* ::Subsubsection:: *)
(*PriceWaste*)


DefineUsage[
	PriceWaste,
	{
		BasicDefinitions -> {
			{
				Definition -> {"PriceWaste[protocol]", "table"},
				Description -> "provides a 'table' listing the pricing information for all waste generated by the 'protocol'.",
				Inputs :> {
					{
						InputName -> "protocol",
						Description -> "The protocol(s) whose pricing for waste generated is calculated.",
						Widget -> Adder[Widget[Type -> Object, Pattern :> ObjectP[{Object[Protocol], Object[Qualification], Object[Maintenance]}]]]
					}
				},
				Outputs :> {
					{
						OutputName -> "table",
						Description -> "A table displaying information about each type of waste generated, including what protocol generated it, how much, and its price for that quantity.",
						Pattern :> _Grid
					},
					{
						OutputName -> "associations",
						Description -> "A list of associations containing information about each waste generated, what protocol generated it, how much it generated, and the price for that weight (returned if OutputFormat -> Association).",
						Pattern :> {WastePriceTableP...}
					}
				}
			},


			{
				Definition -> {"PriceWaste[notebook]", "table"},
				Description -> "provides a 'table' listing the pricing information for all waste generated by all completed protocols in 'notebook' within the last month.",
				Inputs :> {
					{
						InputName -> "notebook",
						Description -> "The notebook(s) whose pricing for waste generated for all its protocols is calculated.",
						Widget -> Adder[Widget[Type -> Object, Pattern :> ObjectP[Object[LaboratoryNotebook]]]]
					}
				},
				Outputs :> {
					{
						OutputName -> "table",
						Description -> "A table displaying information about each type of waste generated, including what protocol generated it, how much, and its price for that quantity.",
						Pattern :> _Grid
					},
					{
						OutputName -> "associations",
						Description -> "A list of associations containing information about each waste generated, what protocol generated it, how much it generated, and the price for that weight (returned if OutputFormat -> Association).",
						Pattern :> {WastePriceTableP...}
					}
				}
			},


			{
				Definition -> {"PriceWaste[notebook, dateRange]", "table"},
				Description -> "provides a 'table' listing the pricing information for all waste generated by completed protocols in 'notebook' in the time period defined by the 'dateRange'.",
				Inputs :> {
					{
						InputName -> "notebook",
						Description -> "The notebook(s) whose pricing for waste generated for all its protocols is calculated.",
						Widget -> Adder[Widget[Type -> Object, Pattern :> ObjectP[Object[LaboratoryNotebook]]]]
					},
					{
						InputName -> "dateRange",
						Description -> "The span of time of protocols this function is pricing.",
						(* TODO is this the correct type? *)
						Widget -> Widget[Type -> Expression, Pattern :> Span[_?DateObjectQ, _?DateObjectQ], Size -> Word]
					}
				},
				Outputs :> {
					{
						OutputName -> "table",
						Description -> "A table displaying information about each type of waste generated, including what protocol generated it, how much, and its price for that quantity.",
						Pattern :> _Grid
					},
					{
						OutputName -> "associations",
						Description -> "A list of associations containing information about each waste generated, what protocol generated it, how much it generated, and the price for that weight (returned if OutputFormat -> Association).",
						Pattern :> {WastePriceTableP...}
					}
				}
			},


			{
				Definition -> {"PriceWaste[team]", "table"},
				Description -> "provides a 'table' listing the pricing information for all waste generated by all completed protocols in notebooks financed by 'team' within the last month.",
				Inputs :> {
					{
						InputName -> "team",
						Description -> "The team(s) whose pricing for waste generated for all its protocols is calculated.",
						Widget -> Widget[Type -> Object, Pattern :> ObjectP[Object[Team, Financing]]]
					}
				},
				Outputs :> {
					{
						OutputName -> "table",
						Description -> "A table displaying information about each type of waste generated, including what protocol generated it, how much, and its price for that quantity.",
						Pattern :> _Grid
					},
					{
						OutputName -> "associations",
						Description -> "A list of associations containing information about each waste generated, what protocol generated it, how much it generated, and the price for that weight (returned if OutputFormat -> Association).",
						Pattern :> {WastePriceTableP...}
					}
				}
			},


			{
				Definition -> {"PriceWaste[team, dateRange]", "table"},
				Description -> "provides a 'table' listing the pricing information for all waste generated by all completed protocols in notebooks financed by 'team' in the time period defined by the 'dateRange'.",
				Inputs :> {
					{
						InputName -> "team",
						Description -> "The team(s) whose pricing for waste generated for all its protocols is calculated.",
						Widget -> Widget[Type -> Object, Pattern :> ObjectP[Object[Team, Financing]]]
					},
					{
						InputName -> "dateRange",
						Description -> "The span of time of protocols this function is pricing.",
						(* TODO is this the correct type? *)
						Widget -> Widget[Type -> Expression, Pattern :> Span[_?DateObjectQ, _?DateObjectQ], Size -> Word]
					}
				},
				Outputs :> {
					{
						OutputName -> "table",
						Description -> "A table displaying information about each type of waste generated, including what protocol generated it, how much, and its price for that quantity.",
						Pattern :> _Grid
					},
					{
						OutputName -> "associations",
						Description -> "A list of associations containing information about each waste generated, what protocol generated it, how much it generated, and the price for that weight (returned if OutputFormat -> Association).",
						Pattern :> {WastePriceTableP...}
					}
				}
			}
		},
		MoreInformation -> {
			"The pricing is based upon the PricingRate of each type of laboratory waste and how much was generated in the protocol.",
			"Pricing information is only calculated for Completed root protocols.",
			"For the Team or Notebook overloads, non-Completed and non-root protocols are filtered out and not displayed.",
			"By default, if teams or notebooks are specified and no date range is provided, function defaults to showing protocols completed in the past 30 days.",
			"Note that the prices displayed in this documentation are only for the sake of example and do not represent actual prices.",
			"In order to find the real pricing rate for a type of waste, please Download the PricingRate field from the corresponding Model[Sample] object."
		},
		Sync -> Automatic,
		SeeAlso -> {
			"PriceWaste",
			"PriceInstrumentTime",
			"PriceMaterials",
			"PriceTransactions",
			"SummaryPrice",
			"PriceCleanup"
		},
		Author -> {"alou", "robert", "steven", "dima"}
	}
];


(* ::Subsubsection:: *)
(*PriceInstrumentTime*)


DefineUsage[
	PriceInstrumentTime,
	{
		BasicDefinitions -> {
			{"PriceInstrumentTime[protocol]", "table", "provides a 'table' listing the pricing information for all instruments used by 'protocol'."},
			{"PriceInstrumentTime[notebook, Span[startDate, endDate]]", "table", "provides a 'table' listing the pricing information for all instruments used by completed protocols in 'notebook' between the 'startDate' and 'endDate'."},
			{"PriceInstrumentTime[notebook]", "table", "provides a 'table' listing the pricing information for all instruments used by all completed protocols in 'notebook' between Now and one month before Now."},
			{"PriceInstrumentTime[team, Span[startDate, endDate]]", "table", "provides a 'table' listing the pricing information for all instruments used by all completed protocols in notebooks financed by 'team' between the 'startDate' and 'endDate'."},
			{"PriceInstrumentTime[team]", "table", "provides a 'table' listing the pricing information for all instruments used by all completed protocols in notebooks financed by 'team' between Now and one month before Now."}
		},
		MoreInformation -> {
			"The pricing is based upon the PricingRate of each given instrument and how long that instrument was used in the protocol.",
			"Pricing information is only calculated for Completed root protocols.",
			"For the Team or Notebook overloads, non-Completed and non-root protocols are filtered out and not displayed.",
			"By default, if teams or notebooks are specified and no date range is provided, function defaults to showing protocols completed in the past 30 days.",
			"Note that the prices displayed in this documentation are only for the sake of example and do not represent actual prices.",
			"In order to find the real pricing rate for an instrument, please Download the PricingRate field from the corresponding Model[Instrument] object."
		},
		Input :> {
			{"protocol", ListableP[ObjectP[{Object[Protocol], Object[Qualification], Object[Maintenance]}]], "The protocol(s) whose instrument pricing is calculated."},
			{"notebook", ListableP[ObjectP[Object[LaboratoryNotebook]]], "The notebook(s) whose instrument pricing for all its protocols is calculated."},
			{"team", ListableP[ObjectP[Object[Team, Financing]]], "The team(s) whose instrument pricing for all its protocols is calculated."},
			{"startDate", _?DateObjectQ, "The start date for the span of time of protocols this function is pricing."},
			{"endDate", _?DateObjectQ, "The end date for the span of time of protocols this function is pricing."}
		},
		Output :> {
			{"table", _Grid, "A table displaying information about each instrument used, including what protocol used it, for how long, and its price for that time."},
			{"associations", {InstrumentPriceTableP...}, "A list of associations containing information about each instrument used, what protocol used it, for how long, and the price for that time (returned if OutputFormat -> Association)."}
		},
		Sync -> Automatic,
		SeeAlso -> {
			"PriceStorage",
			"PriceWaste",
			"PriceMaterials",
			"PriceTransactions"
		},
		Author -> {"xu.yi", "andrey.shur", "lei.tian", "jihan.kim", "steven"}
	}
];



(* ::Subsubsection:: *)
(*PriceOperatorTime*)


DefineUsage[
	PriceOperatorTime,
	{
		BasicDefinitions -> {
			{"PriceOperatorTime[protocol]", "table", "provides a 'table' listing the pricing information for all operators who worked on the 'protocol'."},
			{"PriceOperatorTime[notebook, Span[startDate, endDate]]", "table", "provides a 'table' listing the pricing information for all operators who worked completed protocols in 'notebook' between the 'startDate' and 'endDate'."},
			{"PriceOperatorTime[notebook]", "table", "provides a 'table' listing the pricing information for all operators who worked on all completed protocols in 'notebook' between Now and one month before Now."},
			{"PriceOperatorTime[team, Span[startDate, endDate]]", "table", "provides a 'table' listing the pricing information for all operators who worked on all completed protocols in notebooks financed by 'team' between the 'startDate' and 'endDate'."},
			{"PriceOperatorTime[team]", "table", "provides a 'table' listing the pricing information for all operators who worked on all completed protocols in notebooks financed by 'team' between Now and one month before Now."}
		},
		MoreInformation -> {
			"The pricing is based upon the PricingRate of each given operator and the time for which the operator was working on the protocol.",
			"Pricing information is only calculated for Completed root protocols.",
			"For the Team or Notebook overloads, non-Completed and non-root protocols are filtered out and not displayed.",
			"By default, if teams or notebooks are specified and no date range is provided, function defaults to showing protocols completed in the past 30 days.",
			"Note that the prices displayed in this documentation are only for the sake of example and do not represent actual prices."
		},
		Input :> {
			{"protocol", ListableP[ObjectP[{Object[Protocol], Object[Qualification], Object[Maintenance]}]], "The protocol(s) whose operator pricing is calculated."},
			{"notebook", ListableP[ObjectP[Object[LaboratoryNotebook]]], "The notebook(s) whose operator pricing for all its protocols is calculated."},
			{"team", ListableP[ObjectP[Object[Team, Financing]]], "The team(s) whose operator pricing for all its protocols is calculated."},
			{"dateRange", Span[_?DateObjectQ, _?DateObjectQ], "The span of time of protocols this function is pricing."}
		},
		Output :> {
			{"table", _Grid, "A table displaying information about each operator that participated in the protocol, including what protocol the operator worked on, for how long, and the price for that time."},
			{"associations", {OperatorPriceTableP...}, "A list of associations containing information about each operator involved, what protocol the operator worked on, for how long, and the price for that time (returned if OutputFormat -> Association)."}
		},
		Sync -> Automatic,
		SeeAlso -> {
			"PriceStorage",
			"PriceWaste",
			"PriceInstrumentTime",
			"PriceMaterials",
			"PriceTransactions"
		},
		Author -> {"alou", "robert", "steven"}
	}
];


(* ::Subsubsection:: *)
(*PriceMaterials*)


DefineUsage[
	PriceMaterials,
	{
		BasicDefinitions -> {
			{
				Definition -> {"PriceMaterials[protocol]", "table"},
				Description -> "provides a 'table' listing the pricing information for all materials used by 'protocol'.",
				Inputs :> {
					{
						InputName -> "protocol",
						Description -> "The protocol(s) whose material pricing is calculated.",
						Widget -> Adder[Widget[Type -> Object, Pattern :> ObjectP[{Object[Protocol], Object[Qualification], Object[Maintenance]}]]]
					}
				},
				Outputs :> {
					{
						OutputName -> "table",
						Description -> "A table displaying information about each priced material, including what protocol or transaction it is affiliated with, its model and its name, the price category, the amount that was used or shipped, and the corresponding price.",
						Pattern :> _Grid
					},
					{
						OutputName -> "associations",
						Description -> "A list of associations containing information about each priced material, what protocol or transaction it is affiliated with, its model and its name, the price category, how much was used or shipped, the price for that amount, and the date of protocol completion or transaction shipment. Returned if OutputFormat -> Association.",
						Pattern :> {MaterialsPriceTableP...}
					}
				}
			},

			{
				Definition -> {"PriceMaterials[transaction]", "table"},
				Description -> "provides a 'table' listing the pricing information for all materials in 'transaction'.",
				Inputs :> {
					{
						InputName -> "transaction",
						Description -> "The transaction(s) whose material pricing is calculated.",
						Widget -> Adder[Widget[Type -> Object, Pattern :> ObjectP[Object[Transaction]]]]
					}
				},
				Outputs :> {
					{
						OutputName -> "table",
						Description -> "A table displaying information about each priced material, including what protocol or transaction it is affiliated with, its model and its name, the price category, the amount that was used or shipped, and the corresponding price.",
						Pattern :> _Grid
					},
					{
						OutputName -> "associations",
						Description -> "A list of associations containing information about each priced material, what protocol or transaction it is affiliated with, its model and its name, the price category, how much was used or shipped, the price for that amount, and the date of protocol completion or transaction shipment. Returned if OutputFormat -> Association.",
						Pattern :> {MaterialsPriceTableP...}
					}
				}
			},


			{
				Definition -> {"PriceMaterials[notebook]", "table"},
				Description -> "provides a 'table' listing the pricing information for all materials from completed protocols or from received transaction orders in 'notebook' within the last month.",
				Inputs :> {
					{
						InputName -> "notebook",
						Description -> "The notebook(s) whose material pricing for all its protocols and transactions is calculated.",
						Widget -> Widget[Type -> Object, Pattern :> ObjectP[Object[LaboratoryNotebook]]]
					}
				},
				Outputs :> {
					{
						OutputName -> "table",
						Description -> "A table displaying information about each priced material, including what protocol or transaction it is affiliated with, its model and its name, the price category, the amount that was used or shipped, and the corresponding price.",
						Pattern :> _Grid
					},
					{
						OutputName -> "associations",
						Description -> "A list of associations containing information about each priced material, what protocol or transaction it is affiliated with, its model and its name, the price category, how much was used or shipped, the price for that amount, and the date of protocol completion or transaction shipment. Returned if OutputFormat -> Association.",
						Pattern :> {MaterialsPriceTableP...}
					}
				}
			},


			{
				Definition -> {"PriceMaterials[notebook, dateRange]", "table"},
				Description -> "provides a 'table' listing the pricing information for all materials from completed protocols or from received transaction orders in 'notebook' in the time period defined by the 'dateRange'.",
				Inputs :> {
					{
						InputName -> "notebook",
						Description -> "The notebook(s) whose material pricing for all its protocols and transactions is calculated.",
						Widget -> Widget[Type -> Object, Pattern :> ObjectP[Object[LaboratoryNotebook]]]
					},
					{
						InputName -> "dateRange",
						Description -> "The span of time of protocols this function is pricing.",
						(* TODO is this the correct type? *)
						Widget -> Widget[Type -> Expression, Pattern :> Span[_?DateObjectQ, _?DateObjectQ], Size -> Word]
					}
				},
				Outputs :> {
					{
						OutputName -> "table",
						Description -> "A table displaying information about each priced material, including what protocol or transaction it is affiliated with, its model and its name, the price category, the amount that was used or shipped, and the corresponding price.",
						Pattern :> _Grid
					},
					{
						OutputName -> "associations",
						Description -> "A list of associations containing information about each priced material, what protocol or transaction it is affiliated with, its model and its name, the price category, how much was used or shipped, the price for that amount, and the date of protocol completion or transaction shipment. Returned if OutputFormat -> Association.",
						Pattern :> {MaterialsPriceTableP...}
					}
				}
			},


			{
				Definition -> {"PriceMaterials[team]", "table"},
				Description -> "provides a 'table' listing the pricing information for all materials from completed protocols or from received transaction orders in notebooks financed by 'team' within the last month.",
				Inputs :> {
					{
						InputName -> "team",
						Description -> "The team(s) whose material pricing for all its protocols and transactions is calculated.",
						Widget -> Widget[Type -> Object, Pattern :> ObjectP[Object[Team, Financing]]]
					}
				},
				Outputs :> {
					{
						OutputName -> "table",
						Description -> "A table displaying information about each priced material, including what protocol or transaction it is affiliated with, its model and its name, the price category, the amount that was used or shipped, and the corresponding price.",
						Pattern :> _Grid
					},
					{
						OutputName -> "associations",
						Description -> "A list of associations containing information about each priced material, what protocol or transaction it is affiliated with, its model and its name, the price category, how much was used or shipped, the price for that amount, and the date of protocol completion or transaction shipment. Returned if OutputFormat -> Association.",
						Pattern :> {MaterialsPriceTableP...}
					}
				}
			},


			{
				Definition -> {"PriceMaterials[team, dateRange]", "table"},
				Description -> "provides a 'table' listing the pricing information from completed protocols or from received transaction orders in notebooks financed by 'team' in the time period defined by the 'dateRange'.",
				Inputs :> {
					{
						InputName -> "team",
						Description -> "The team(s) whose material pricing for all its protocols and transactions is calculated.",
						Widget -> Widget[Type -> Object, Pattern :> ObjectP[Object[Team, Financing]]]
					},
					{
						InputName -> "dateRange",
						Description -> "The span of time of protocols this function is pricing.",
						(* TODO is this the correct type? *)
						Widget -> Widget[Type -> Expression, Pattern :> Span[_?DateObjectQ, _?DateObjectQ], Size -> Word]
					}
				},
				Outputs :> {
					{
						OutputName -> "table",
						Description -> "A table displaying information about each priced material, including what protocol or transaction it is affiliated with, its model and its name, the price category, the amount that was used or shipped, and the corresponding price.",
						Pattern :> _Grid
					},
					{
						OutputName -> "associations",
						Description -> "A list of associations containing information about each priced material, what protocol or transaction it is affiliated with, its model and its name, the price category, how much was used or shipped, the price for that amount, and the date of protocol completion or transaction shipment. Returned if OutputFormat -> Association.",
						Pattern :> {MaterialsPriceTableP...}
					}
				}
			}
		},
		MoreInformation -> {
			"The pricing of protocols is based on the list price of each given material and how much of that material was used, plus the applicable sales tax rate depending on the location of the ECL facility where the protocol was performed.",
			"The pricing of transaction orders (items ordered from a supplier) is based on the list price of each given material and the quantity ordered, plus the applicable sales tax rate depending on the location of the ECL facility where the transaction was shipped to.",
			"For clarity, the pricing components (product list price and tax price) are displayed as individual entries in the output association or table.",
			"Pricing information is only calculated for completed root protocols and non-cancelled transactions.",
			"For the Team or Notebook overloads, only completed protocols and received transaction orders are priced; non-completed and/or non-root protocols as-well as pending transactions are filtered out and not displayed in the output.",
			"By default, if Teams or Notebooks are specified and no date range is provided, the function defaults to showing protocols and transactions completed in the past 30 days.",
			"Note that the prices displayed in this documentation are only for the sake of presentation and do not represent actual prices.",
			"In order to find the real list price for a material, please Download the Price field from the corresponding Object[Product].",
			"In order to find the applicable sale tax rate, please Download the SalesTaxRate field from the Model[Container,Site] object corresponding to the ECL site the user is submitting his protocols."
		},
		Sync -> Automatic,
		SeeAlso -> {
			"PriceWaste",
			"PriceInstrumentTime",
			"PriceOperatorTime",
			"PriceStorage",
			"PriceTransactions",
			"SummaryPrice"
		},
		Author -> {"xu.yi", "andrey.shur", "lei.tian", "jihan.kim", "alou", "dima", "steven", "waltraud.mair"}
	}
];


(* ::Subsubsection:: *)
(*PriceTransactions*)

DefineUsage[
	PriceTransactions,
	{
		BasicDefinitions -> {
			{
				Definition -> {"PriceTransactions[transaction]", "table"},
				Description -> "provides a 'table' listing the transactional pricing information for all materials in 'transaction'.",
				Inputs :> {
					{
						InputName -> "transaction",
						Description -> "The transaction(s) whose transactional pricing is calculated.",
						Widget -> Adder[Widget[Type -> Object, Pattern :> ObjectP[Object[Transaction]]]]
					}
				},
				Outputs :> {
					{
						OutputName -> "table",
						Description -> "A table displaying transactional information about each material, including what transaction it is affiliated with, its model and its name, the price category, the amount that was shipped or used, and the corresponding price.",
						Pattern :> _Grid
					},
					{
						OutputName -> "associations",
						Description -> "A list of associations containing information about each material used, what transaction it is affiliated with, its model and its name, the price category, how much was shipped or used, the price for that amount, and the date of transaction shipment. Returned if OutputFormat -> Association.",
						Pattern :> {TransactionsPriceTableP...}
					}
				}
			},


			{
				Definition -> {"PriceTransactions[notebook]", "table"},
				Description -> "provides a 'table' listing the transactional pricing information for all materials from received transaction orders in 'notebook' within the last month.",
				Inputs :> {
					{
						InputName -> "notebook",
						Description -> "The notebook(s) whose transactional pricing for all its transactions are calculated.",
						Widget -> Widget[Type -> Object, Pattern :> ObjectP[Object[LaboratoryNotebook]]]
					}
				},
				Outputs :> {
					{
						OutputName -> "table",
						Description -> "A table displaying transactional information about each material, including what transaction it is affiliated with, its model and its name, the price category, the amount that was shipped or used, and the corresponding price.",
						Pattern :> _Grid
					},
					{
						OutputName -> "associations",
						Description -> "A list of associations containing information about each material used, what transaction it is affiliated with, its model and its name, the price category, how much was shipped or used, the price for that amount, and the date of transaction shipment. Returned if OutputFormat -> Association.",
						Pattern :> {TransactionsPriceTableP...}
					}
				}
			},


			{
				Definition -> {"PriceTransactions[notebook, dateRange]", "table"},
				Description -> "provides a 'table' listing the transactional pricing information for all materials from received transaction orders in 'notebook' in the time period defined by the 'dateRange'.",
				Inputs :> {
					{
						InputName -> "notebook",
						Description -> "The notebook(s) whose transactional pricing for all its transactions are calculated.",
						Widget -> Widget[Type -> Object, Pattern :> ObjectP[Object[LaboratoryNotebook]]]
					},
					{
						InputName -> "dateRange",
						Description -> "The span of time of protocols this function is pricing.",
						(* TODO is this the correct type? *)
						Widget -> Widget[Type -> Expression, Pattern :> Span[_?DateObjectQ, _?DateObjectQ], Size -> Word]
					}
				},
				Outputs :> {
					{
						OutputName -> "table",
						Description -> "A table displaying transactional information about each material, including what transaction it is affiliated with, its model and its name, the price category, the amount that was shipped or used, and the corresponding price.",
						Pattern :> _Grid
					},
					{
						OutputName -> "associations",
						Description -> "A list of associations containing information about each material used, what transaction it is affiliated with, its model and its name, the price category, how much was shipped or used, the price for that amount, and the date of transaction shipment. Returned if OutputFormat -> Association.",
						Pattern :> {TransactionsPriceTableP...}
					}
				}
			},


			{
				Definition -> {"PriceTransactions[team]", "table"},
				Description -> "provides a 'table' listing the transactional pricing information for all materials from received transaction orders in notebooks financed by 'team' within the last month.",
				Inputs :> {
					{
						InputName -> "team",
						Description -> "The team(s) whose transactional pricing for all its transactions are calculated.",
						Widget -> Widget[Type -> Object, Pattern :> ObjectP[Object[Team, Financing]]]
					}
				},
				Outputs :> {
					{
						OutputName -> "table",
						Description -> "A table displaying transactional information about each material, including what transaction it is affiliated with, its model and its name, the price category, the amount that was shipped or used, and the corresponding price.",
						Pattern :> _Grid
					},
					{
						OutputName -> "associations",
						Description -> "A list of associations containing information about each material used, what transaction it is affiliated with, its model and its name, the price category, how much was shipped or used, the price for that amount, and the date of transaction shipment. Returned if OutputFormat -> Association.",
						Pattern :> {TransactionsPriceTableP...}
					}
				}
			},


			{
				Definition -> {"PriceTransactions[team, dateRange]", "table"},
				Description -> "provides a 'table' listing the transactional pricing information for all materials from received transaction orders in notebooks financed by 'team' in the time period defined by the 'dateRange'.",
				Inputs :> {
					{
						InputName -> "team",
						Description -> "The team(s) whose transactional pricing for all its transactions are calculated.",
						Widget -> Widget[Type -> Object, Pattern :> ObjectP[Object[Team, Financing]]]
					},
					{
						InputName -> "dateRange",
						Description -> "The span of time of protocols this function is pricing.",
						(* TODO is this the correct type? *)
						Widget -> Widget[Type -> Expression, Pattern :> Span[_?DateObjectQ, _?DateObjectQ], Size -> Word]
					}
				},
				Outputs :> {
					{
						OutputName -> "table",
						Description -> "A table displaying transactional information about each material, including what transaction it is affiliated with, its model and its name, the price category, the amount that was shipped or used, and the corresponding price.",
						Pattern :> _Grid
					},
					{
						OutputName -> "associations",
						Description -> "A list of associations containing information about each material used, what transaction it is affiliated with, its model and its name, the price category, how much was shipped or used, the price for that amount, and the date of transaction shipment. Returned if OutputFormat -> Association.",
						Pattern :> {TransactionsPriceTableP...}
					}
				}
			}
		},
		MoreInformation -> {
			"All items received by the ECL are charged a handling cost upon arrival (this applies to items originating from sent, dropshipped, and ordered transactions where the product is acquired through an external supplier). The handling cost consists of a receiving cost for each model object in a particular transaction, and an additional cost for each sample's weight or sample volume measurement, if applicable.",
			"All items shipped from the ECL to the user are charged a handling cost, packaging materials, shipping costs, and aliquoting, where applicable.",
			"For pending transactions to the user that are not yet shipped, shipment cost is estimated based on the latest shipping price report (Object[Report, ShippingPrices]) available for the transaction's source site, shipper, shipping speed, and shipping container(s).",
			"For clarity, all of the above described pricing components (receiving, handling, shipping, packaging and aliquoting) are displayed as individual entries in the output.",
			"Transactional pricing information is only calculated for non-cancelled transactions; pending or partially received transactions are included in the pricing.",
			"For the Team or Notebook overloads fully received transaction are priced; all other transactions are filtered out and not displayed in the output.",
			"By default, if Teams or Notebooks are specified and no date range is provided, the function defaults to showing transactions received in the past 30 days.",
			"Note that the prices displayed in this documentation are only for the sake of presentation and do not represent actual prices."
		},
		Sync -> Automatic,
		SeeAlso -> {
			"PriceWaste",
			"PriceInstrumentTime",
			"PriceOperatorTime",
			"PriceStorage",
			"PriceMaterials",
			"PriceTransactions",
			"SummaryPrice"
		},
		Author -> {"alou", "robert", "dima"}
	}
];



(* ::Subsubsection::Closed:: *)
(*PriceCleaning*)


DefineUsage[
	PriceCleaning,
	{
		BasicDefinitions -> {
			{
				Definition -> {"PriceCleaning[protocol]", "table"},
				Description -> "provides a 'table' listing the pricing information for the dishwashing and autoclaving of reusable containers generated during 'protocol'.",
				Inputs :> {
					{
						InputName -> "protocol",
						Description -> "The protocol which utilized the reusable objects that are dishwashed and/or autoclaved.",
						Widget -> Adder[Widget[Type -> Object, Pattern :> ObjectP[{Object[Protocol], Object[Maintenance], Object[Qualification]}]]]
					}
				},
				Outputs :> {
					{
						OutputName -> "table",
						Description -> "A table displaying information about the dishwashing and/or autoclaving of objects used by the relevant protocols, including the cleaning category, cleaning method, the item ID and name of its model, and the corresponding total price.",
						Pattern :> _Grid
					},
					{
						OutputName -> "associations",
						Description -> "A list of associations containing information about the dishwashing and/or autoclaving of objects used by the relevant protocols, including the cleaning category, cleaning method, the item ID and name of its model, and the corresponding total price. Returned if OutputFormat -> Association.",
						Pattern :> {CleaningPriceTableP...}
					}
				}
			},


			{
				Definition -> {"PriceCleaning[notebook]", "table"},
				Description -> "provides a 'table' listing the pricing information for the dishwashing and autoclaving of reusable containers affiliated with 'notebook' within the last month.",
				Inputs :> {
					{
						InputName -> "notebook",
						Description -> "The notebook(s) for which dishwashing and/or autoclaving priced.",
						Widget -> Widget[Type -> Object, Pattern :> ObjectP[Object[LaboratoryNotebook]]]
					}
				},
				Outputs :> {
					{
						OutputName -> "table",
						Description -> "A table displaying information about the dishwashing and/or autoclaving of objects used by the relevant protocols, including the cleaning category, cleaning method, the item ID and name of its model, and the corresponding total price.",
						Pattern :> _Grid
					},
					{
						OutputName -> "associations",
						Description -> "A list of associations containing information about the dishwashing and/or autoclaving of objects used by the relevant protocols, including the cleaning category, cleaning method, the item ID and name of its model, and the corresponding total price. Returned if OutputFormat -> Association.",
						Pattern :> {CleaningPriceTableP...}
					}
				}
			},


			{
				Definition -> {"PriceCleaning[notebook, dateRange]", "table"},
				Description -> "provides a 'table' listing the pricing information for the dishwashing and autoclaving of reusable containers affiliated with 'notebook' in the time period defined by the 'dateRange'.",
				Inputs :> {
					{
						InputName -> "notebook",
						Description -> "The notebook(s) for which dishwashing and/or autoclaving priced.",
						Widget -> Widget[Type -> Object, Pattern :> ObjectP[Object[LaboratoryNotebook]]]
					},
					{
						InputName -> "dateRange",
						Description -> "The span of time of protocols this function is pricing.",
						(* TODO is this the correct type? *)
						Widget -> Widget[Type -> Expression, Pattern :> Span[_?DateObjectQ, _?DateObjectQ], Size -> Word]
					}
				},
				Outputs :> {
					{
						OutputName -> "table",
						Description -> "A table displaying information about the dishwashing and/or autoclaving of objects used by the relevant protocols, including the cleaning category, cleaning method, the item ID and name of its model, and the corresponding total price.",
						Pattern :> _Grid
					},
					{
						OutputName -> "associations",
						Description -> "A list of associations containing information about the dishwashing and/or autoclaving of objects used by the relevant protocols, including the cleaning category, cleaning method, the item ID and name of its model, and the corresponding total price. Returned if OutputFormat -> Association.",
						Pattern :> {CleaningPriceTableP...}
					}
				}
			},


			{
				Definition -> {"PriceCleaning[team]", "table"},
				Description -> "provides a 'table' listing the pricing information for the dishwashing and autoclaving of reusable containers affiliated with notebooks financed by 'team' within the last month.",
				Inputs :> {
					{
						InputName -> "team",
						Description -> "The team(s) for which dishwashing and/or autoclaving priced.",
						Widget -> Widget[Type -> Object, Pattern :> ObjectP[Object[Team, Financing]]]
					}
				},
				Outputs :> {
					{
						OutputName -> "table",
						Description -> "A table displaying information about the dishwashing and/or autoclaving of objects used by the relevant protocols, including the cleaning category, cleaning method, the item ID and name of its model, and the corresponding total price.",
						Pattern :> _Grid
					},
					{
						OutputName -> "associations",
						Description -> "A list of associations containing information about the dishwashing and/or autoclaving of objects used by the relevant protocols, including the cleaning category, cleaning method, the item ID and name of its model, and the corresponding total price. Returned if OutputFormat -> Association.",
						Pattern :> {CleaningPriceTableP...}
					}
				}
			},


			{
				Definition -> {"PriceCleaning[team, dateRange]", "table"},
				Description -> "provides a 'table' listing the pricing information for the dishwashing and autoclaving of reusable containers affiliated with notebooks financed by 'team' in the time period defined by the 'dateRange'.",
				Inputs :> {
					{
						InputName -> "team",
						Description -> "The team(s) for which dishwashing and/or autoclaving priced.",
						Widget -> Widget[Type -> Object, Pattern :> ObjectP[Object[Team, Financing]]]
					},
					{
						InputName -> "dateRange",
						Description -> "The span of time of protocols this function is pricing.",
						(* TODO is this the correct type? *)
						Widget -> Widget[Type -> Expression, Pattern :> Span[_?DateObjectQ, _?DateObjectQ], Size -> Word]
					}
				},
				Outputs :> {
					{
						OutputName -> "table",
						Description -> "A table displaying information about the dishwashing and/or autoclaving of objects used by the relevant protocols, including the cleaning category, cleaning method, the item ID and name of its model, and the corresponding total price.",
						Pattern :> _Grid
					},
					{
						OutputName -> "associations",
						Description -> "A list of associations containing information about the dishwashing and/or autoclaving of objects used by the relevant protocols, including the cleaning category, cleaning method, the item ID and name of its model, and the corresponding total price. Returned if OutputFormat -> Association.",
						Pattern :> {CleaningPriceTableP...}
					}
				}
			}
		},
		MoreInformation -> {
			"By default, if Teams or Notebooks are specified and no date range is provided, the function defaults to include reusable objects used by protocols which completed in the past 30 days.",
			"Note that the prices displayed in this documentation are only for the sake of example and do not represent actual prices.",
			"In order to find the up to date price for a cleaning method, please download the CleanUpPricing field of the relevant Object[Bill]."
		},
		Sync -> Automatic,
		SeeAlso -> {
			"PriceWaste",
			"PriceInstrumentTime",
			"PriceOperatorTime",
			"PriceStorage",
			"PriceMaterials",
			"PriceTransactions",
			"SummaryPrice"
		},
		Author -> {"alou", "robert", "steven", "dima"}
	}
];


(* ::Subsubsection::Closed:: *)
(*PriceStocking*)


DefineUsage[PriceStocking,
	{
		BasicDefinitions -> {
			{
				Definition -> {"PriceStocking[protocol]", "table"},
				Description -> "provides a 'table' listing the pricing information for the restocking of public samples generated during 'protocol'.",
				Inputs :> {
					{
						InputName -> "protocol",
						Description -> "The protocol which consumed public resources which require restocking.",
						Widget -> Adder[Widget[Type -> Object, Pattern :> ObjectP[{Object[Protocol], Object[Maintenance], Object[Qualification]}]]]
					}
				},
				Outputs :> {
					{
						OutputName -> "table",
						Description -> "A table displaying information about the stocking of objects used by the relevant protocols, including the item ID and name of its model, and the corresponding total price.",
						Pattern :> _Grid
					},
					{
						OutputName -> "associations",
						Description -> "A list of associations containing information about the stocking of objects used by the relevant protocols, including the item ID and name of its model, and the corresponding total price. Returned if OutputFormat -> Association.",
						Pattern :> {StockingPriceTableP...}
					}
				}
			},


			{
				Definition -> {"PriceStocking[notebook]", "table"},
				Description -> "provides a 'table' listing the pricing information for the restocking of public samples affiliated with 'notebook' within the last month.",
				Inputs :> {
					{
						InputName -> "notebook",
						Description -> "The notebook(s) for which stocking is priced.",
						Widget -> Widget[Type -> Object, Pattern :> ObjectP[Object[LaboratoryNotebook]]]
					}
				},
				Outputs :> {
					{
						OutputName -> "table",
						Description -> "A table displaying information about the stocking of objects used by the relevant protocols, including the item ID and name of its model, and the corresponding total price.",
						Pattern :> _Grid
					},
					{
						OutputName -> "associations",
						Description -> "A list of associations containing information about the stocking of objects used by the relevant protocols, including the item ID and name of its model, and the corresponding total price. Returned if OutputFormat -> Association.",
						Pattern :> {StockingPriceTableP...}
					}
				}
			},


			{
				Definition -> {"PriceStocking[notebook, dateRange]", "table"},
				Description -> "provides a 'table' listing the pricing information for the restocking of public samples affiliated with 'notebook' in the time period defined by the 'dateRange'.",
				Inputs :> {
					{
						InputName -> "notebook",
						Description -> "The notebook(s) for which stocking is priced.",
						Widget -> Widget[Type -> Object, Pattern :> ObjectP[Object[LaboratoryNotebook]]]
					},
					{
						InputName -> "dateRange",
						Description -> "The span of time of protocols this function is pricing.",
						(* TODO is this the correct type? *)
						Widget -> Widget[Type -> Expression, Pattern :> Span[_?DateObjectQ, _?DateObjectQ], Size -> Word]
					}
				},
				Outputs :> {
					{
						OutputName -> "table",
						Description -> "A table displaying information about the stocking of objects used by the relevant protocols, including the item ID and name of its model, and the corresponding total price.",
						Pattern :> _Grid
					},
					{
						OutputName -> "associations",
						Description -> "A list of associations containing information about the stocking of objects used by the relevant protocols, including the item ID and name of its model, and the corresponding total price. Returned if OutputFormat -> Association.",
						Pattern :> {StockingPriceTableP...}
					}
				}
			},


			{
				Definition -> {"PriceStocking[team]", "table"},
				Description -> "provides a 'table' listing the pricing information for the restocking of public samples affiliated with notebooks financed by 'team' in the last month.",
				Inputs :> {
					{
						InputName -> "team",
						Description -> "The team(s) for which stocking is priced.",
						Widget -> Widget[Type -> Object, Pattern :> ObjectP[Object[Team, Financing]]]
					}
				},
				Outputs :> {
					{
						OutputName -> "table",
						Description -> "A table displaying information about the stocking of objects used by the relevant protocols, including the item ID and name of its model, and the corresponding total price.",
						Pattern :> _Grid
					},
					{
						OutputName -> "associations",
						Description -> "A list of associations containing information about the stocking of objects used by the relevant protocols, including the item ID and name of its model, and the corresponding total price. Returned if OutputFormat -> Association.",
						Pattern :> {StockingPriceTableP...}
					}
				}
			},


			{
				Definition -> {"PriceStocking[team, dateRange]", "table"},
				Description -> "provides a 'table' listing the pricing information for the restocking of public samples affiliated with notebooks financed by 'team' in the time period defined by the 'dateRange'.",
				Inputs :> {
					{
						InputName -> "team",
						Description -> "The team(s) for which stocking is priced.",
						Widget -> Widget[Type -> Object, Pattern :> ObjectP[Object[Team, Financing]]]
					},
					{
						InputName -> "dateRange",
						Description -> "The span of time of protocols this function is pricing.",
						(* TODO is this the correct type? *)
						Widget -> Widget[Type -> Expression, Pattern :> Span[_?DateObjectQ, _?DateObjectQ], Size -> Word]
					}
				},
				Outputs :> {
					{
						OutputName -> "table",
						Description -> "A table displaying information about the stocking of objects used by the relevant protocols, including the item ID and name of its model, and the corresponding total price.",
						Pattern :> _Grid
					},
					{
						OutputName -> "associations",
						Description -> "A list of associations containing information about the stocking of objects used by the relevant protocols, including the item ID and name of its model, and the corresponding total price. Returned if OutputFormat -> Association.",
						Pattern :> {StockingPriceTableP...}
					}
				}
			}
		},

		MoreInformation -> {
			"By default, if Teams or Notebooks are specified and no date range is provided, the function defaults to include restockable objects used by protocols which completed in the past 30 days.",
			"Note that the prices displayed in this documentation are only for the sake of example and do not represent actual prices.",
			"In order to find the up to date price for stocking a particular model, please download the StockingPricing field of the relevant Object[Bill]."
		},
		Sync -> Automatic,
		SeeAlso -> {
			"PriceStorage",
			"PriceWaste",
			"PriceInstrumentTime",
			"PriceOperatorTime",
			"PriceMaterials",
			"PriceCleaning",
			"SummaryPrice",
			"PriceTransactions"
		},
		Author -> {"alou", "robert", "dima", "steven"}
	}
];



(* ::Subsubsection::Closed:: *)
(*PriceData*)

(* TODO the symbol is private, but the usage still should be updated at some point *)
DefineUsage[
	PriceData,
	{
		BasicDefinitions -> {
			{"PriceData[team]", "table", "provides a 'table' listing the pricing information for the number of constellation objects stored by the team currently."},
			{"PriceData[team, date]", "table", "provides a 'table' listing the pricing information for the number of constellation objects stored by the team at the given 'date'."}
		},
		MoreInformation -> {
			"Note that the prices displayed in this documentation are only for the sake of example and do not represent actual prices.",
			"In order to find the up to date price for data usage, please refer to the relevant Object[Bill]."
		},
		Input :> {
			{"team", ListableP[ObjectP[Object[Team, Financing]]], "The team(s) for which data is priced."},
			{"date", _?DateObjectQ, "The date at which to examine the data pricing for a given financing team."}
		},
		Output :> {
			{"table", _Pane, "A table displaying information about the data charges for a given team."},
			{"associations", {DataPriceTableP...}, "A list association containing data price information. Returned if OutputFormat -> Association."}
		},
		Sync -> Automatic,
		SeeAlso -> {
			"PriceWaste",
			"PriceInstrumentTime",
			"PriceOperatorTime",
			"PriceStorage",
			"PriceMaterials",
			"PriceCleaning",
			"PriceRecurring"
		},
		Author -> {"alou", "robert", "steven"}
	}
];


(* ::Subsubsection::Closed:: *)
(*PriceRecurring*)

(* TODO the symbol is private, but the usage still should be updated at some point *)
DefineUsage[
	PriceRecurring,
	{
		BasicDefinitions -> {
			{"PriceRecurring[team]", "table", "provides a 'table' listing the pricing information for the recurring charges (e.g. command center licenses, number of threads) used by the team for a certain time period (last 1 month by default)."},
			{"PriceRecurring[team, Span[startDate, endDate]]", "table", "provides a 'table' listing the pricing information for the recurring charges (e.g. command center licenses, number of threads) for the given time span."}
		},
		MoreInformation -> {
			"Note that the prices displayed in this documentation are only for the sake of example and do not represent actual prices.",
			"In order to find the up to date price for data usage, please refer to the relevant Object[Bill]."
		},
		Input :> {
			{"team", ListableP[ObjectP[Object[Team, Financing]]], "The team(s) for which recurring charges are priced."},
			{"startDate", _?DateObjectQ, "The beginning date at which to examine the recurring pricing for a given financing team."},
			{"endDate", _?DateObjectQ, "The ending date at which to examine the recurring pricing for a given financing team."}
		},
		Output :> {
			{"table", _Pane, "A table displaying information about the recurring charges for a given team."},
			{"associations", {RecurringPriceTableP...}, "A list association containing recurring price information. Returned if OutputFormat -> Association."}
		},
		Sync -> Automatic,
		SeeAlso -> {
			"PriceWaste",
			"PriceInstrumentTime",
			"PriceOperatorTime",
			"PriceStorage",
			"PriceMaterials",
			"PriceCleaning",
			"PriceData"
		},
		Author -> {"alou", "robert", "steven"}
	}
];


(* ::Subsubsection:: *)
(*SummaryPrice*)


DefineUsage[SummaryPrice,
	{
		BasicDefinitions -> {
			{
				Definition -> {"SummaryPrice[protocol]", "table"},
				Description -> "provides a 'table' listing the pricing information for all of the charges associated to 'protocol'.",
				Inputs :> {
					{
						InputName -> "protocol",
						Description -> "The protocol(s) whose pricing is calculated.",
						Widget -> Widget[Type -> Object, Pattern :> ObjectP[Object[Protocol]]]
					}
				},
				Outputs :> {
					{
						OutputName -> "table",
						Description -> "A table displaying information about each operator that participated in the protocol, including what protocol the operator worked on, for how long, and the price for that time.",
						Pattern :> _Pane
					},
					{
						OutputName -> "associations",
						Description -> "A list of associations containing information about each operator involved, what protocol the operator worked on, for how long, and the price for that time (returned if OutputFormat -> Association).",
						Pattern :> {ExperimentPriceTableP...}
					}
				}
			},

			{
				Definition -> {"SummaryPrice[notebook]", "table"},
				Description -> "provides a 'table' listing the pricing information for all completed protocols in 'notebook' for the last month.",
				Inputs :> {
					{
						InputName -> "notebook",
						Description -> "The notebook(s) whose pricing for all its protocols is calculated.",
						Widget -> Widget[Type -> Object, Pattern :> ObjectP[Object[LaboratoryNotebook]]]
					}
				},
				Outputs :> {
					{
						OutputName -> "table",
						Description -> "A table displaying information about each operator that participated in the protocol, including what protocol the operator worked on, for how long, and the price for that time.",
						Pattern :> _Pane
					},
					{
						OutputName -> "associations",
						Description -> "A list of associations containing information about each operator involved, what protocol the operator worked on, for how long, and the price for that time (returned if OutputFormat -> Association).",
						Pattern :> {ExperimentPriceTableP...}
					}
				}
			},


			{
				Definition -> {"SummaryPrice[notebook, dateRange]", "table"},
				Description -> "provides a 'table' listing the pricing information for all completed protocols in 'notebook' in the time period defined by the 'dateRange'.",
				Inputs :> {
					{
						InputName -> "notebook",
						Description -> "The notebook(s) whose pricing for all its protocols is calculated.",
						Widget -> Widget[Type -> Object, Pattern :> ObjectP[Object[LaboratoryNotebook]]]
					},
					{
						InputName -> "dateRange",
						Description -> "The span of time of protocols this function is pricing.",
						(* TODO is this the correct type? *)
						Widget -> Widget[Type -> Expression, Pattern :> Span[_?DateObjectQ, _?DateObjectQ], Size -> Word]
					}
				},
				Outputs :> {
					{
						OutputName -> "table",
						Description -> "A table displaying information about each operator that participated in the protocol, including what protocol the operator worked on, for how long, and the price for that time.",
						Pattern :> _Pane
					},
					{
						OutputName -> "associations",
						Description -> "A list of associations containing information about each operator involved, what protocol the operator worked on, for how long, and the price for that time (returned if OutputFormat -> Association).",
						Pattern :> {ExperimentPriceTableP...}
					}
				}
			},


			{
				Definition -> {"SummaryPrice[team]", "table"},
				Description -> "provides a 'table' listing the pricing information for all completed protocols in notebooks financed by 'team' in the last month.",
				Inputs :> {
					{
						InputName -> "team",
						Description -> "The team(s) whose pricing for all its protocols is calculated.",
						Widget -> Widget[Type -> Object, Pattern :> ObjectP[Object[Team, Financing]]]
					}
				},
				Outputs :> {
					{
						OutputName -> "table",
						Description -> "A table displaying information about each operator that participated in the protocol, including what protocol the operator worked on, for how long, and the price for that time.",
						Pattern :> _Pane
					},
					{
						OutputName -> "associations",
						Description -> "A list of associations containing information about each operator involved, what protocol the operator worked on, for how long, and the price for that time (returned if OutputFormat -> Association).",
						Pattern :> {ExperimentPriceTableP...}
					}
				}
			},


			{
				Definition -> {"SummaryPrice[team, dateRange]", "table"},
				Description -> "provides a 'table' listing the pricing information for all completed protocols in notebooks financed by 'team' in the time period defined by the 'dateRange'.",
				Inputs :> {
					{
						InputName -> "team",
						Description -> "The notebook(s) whose operator pricing for all its protocols is calculated.",
						Widget -> Widget[Type -> Object, Pattern :> ObjectP[Object[Team, Financing]]]
					},
					{
						InputName -> "dateRange",
						Description -> "The span of time of protocols this function is pricing.",
						(* TODO is this the correct type? *)
						Widget -> Widget[Type -> Expression, Pattern :> Span[_?DateObjectQ, _?DateObjectQ], Size -> Word]
					}
				},
				Outputs :> {
					{
						OutputName -> "table",
						Description -> "A table displaying information about each operator that participated in the protocol, including what protocol the operator worked on, for how long, and the price for that time.",
						Pattern :> _Pane
					},
					{
						OutputName -> "associations",
						Description -> "A list of associations containing information about each operator involved, what protocol the operator worked on, for how long, and the price for that time (returned if OutputFormat -> Association).",
						Pattern :> {ExperimentPriceTableP...}
					}
				}
			}

		},

		MoreInformation -> {
			"The pricing is an aggregate of PriceInstrumentTime, PriceOperatorTime, PriceCleaning, PriceStocking, PriceWaste, PriceMaterials.",
			"Pricing information is only calculated for Completed root protocols.",
			"For the Team or Notebook overloads, non-Completed and non-root protocols are filtered out and not displayed.",
			"By default, if teams or notebooks are specified and no date range is provided, function defaults to showing protocols completed in the past 30 days.",
			"Note that the prices displayed in this documentation are only for the sake of example and do not represent actual prices."
		},
		Sync -> Automatic,
		SeeAlso -> {
			"PriceStorage",
			"PriceWaste",
			"PriceInstrumentTime",
			"PriceOperatorTime",
			"PriceMaterials",
			"PriceCleaning",
			"PriceTransactions",
			"PriceExperiment"
		},
		Author -> {"xu.yi"}
	}
];
(* ::Subsubsection:: *)
(*PriceExperiment*)


DefineUsage[PriceExperiment,
	{
		BasicDefinitions -> {
			{
				Definition -> {"PriceExperiment[protocol]", "table"},
				Description -> "provides all the pricing tables for all of the charges associated to 'protocol', including PirceWaste, PriceCleaning, PriceInstrumentTime, PriceOperatorTime, PriceMaterial and PriceStocking.",
				Inputs :> {
					{
						InputName -> "protocol",
						Description -> "The protocol(s) whose pricing is calculated.",
						Widget -> Widget[Type -> Object, Pattern :> ObjectP[Object[Protocol]]]
					}
				},
				Outputs :> {
					{
						OutputName -> "table",
						Description -> "A table displaying the details of each price function, including the protocol the operator worked on, the duration of the work, and the corresponding price for that time.",
						Pattern :> _Column
					}
				}
			},

			{
				Definition -> {"PriceExperiment[notebook]", "table"},
				Description -> "provides all the pricing tables for all of the charges associated to all completed protocols in 'notebook' for the last month.",
				Inputs :> {
					{
						InputName -> "notebook",
						Description -> "The notebook(s) whose pricing for all its protocols is calculated.",
						Widget -> Widget[Type -> Object, Pattern :> ObjectP[Object[LaboratoryNotebook]]]
					}
				},
				Outputs :> {
					{
						OutputName -> "table",
						Description -> "A table displaying the details of each price function, including the protocol the operator worked on, the duration of the work, and the corresponding price for that time.",
						Pattern :> _Column
					}
				}
			},


			{
				Definition -> {"PriceExperiment[notebook, dateRange]", "table"},
				Description -> "provides all the pricing tables for all of the charges associated to all completed protocols in 'notebook' in the time period defined by the 'dateRange'.",
				Inputs :> {
					{
						InputName -> "notebook",
						Description -> "The notebook(s) whose pricing for all its protocols is calculated.",
						Widget -> Widget[Type -> Object, Pattern :> ObjectP[Object[LaboratoryNotebook]]]
					},
					{
						InputName -> "dateRange",
						Description -> "The span of time of protocols this function is pricing.",
						Widget -> Widget[Type -> Expression, Pattern :> Span[_?DateObjectQ, _?DateObjectQ], Size -> Word]
					}
				},
				Outputs :> {
					{
						OutputName -> "table",
						Description ->"A table displaying the details of each price function, including the protocol the operator worked on, the duration of the work, and the corresponding price for that time.",
						Pattern :> _Column
					}
				}
			},


			{
				Definition -> {"PriceExperiment[team]", "table"},
				Description -> "provides all the pricing tables for all of the charges associated to all completed protocols in notebooks financed by 'team' in the last month.",
				Inputs :> {
					{
						InputName -> "team",
						Description -> "The team(s) whose pricing for all its protocols is calculated.",
						Widget -> Widget[Type -> Object, Pattern :> ObjectP[Object[Team, Financing]]]
					}
				},
				Outputs :> {
					{
						OutputName -> "table",
						Description -> "A column table displaying all the pricing tables about each operator that participated in the protocol, including what protocol the operator worked on, for how long, and the price for that time.",
						Pattern :> _Column
					}
				}
			},


			{
				Definition -> {"PriceExperiment[team, dateRange]", "table"},
				Description -> "provides all the pricing tables for all of the charges associated to all completed protocols in notebooks financed by 'team' in the time period defined by the 'dateRange'.",
				Inputs :> {
					{
						InputName -> "team",
						Description -> "The notebook(s) whose operator pricing for all its protocols is calculated.",
						Widget -> Widget[Type -> Object, Pattern :> ObjectP[Object[Team, Financing]]]
					},
					{
						InputName -> "dateRange",
						Description -> "The span of time of protocols this function is pricing.",
						Widget -> Widget[Type -> Expression, Pattern :> Span[_?DateObjectQ, _?DateObjectQ], Size -> Word]
					}
				},
				Outputs :> {
					{
						OutputName -> "table",
						Description -> "A table displaying all the pricing tables about each operator that participated in the protocol, including what protocol the operator worked on, for how long, and the price for that time.",
						Pattern :> _Column
					}
				}
			}

		},

		MoreInformation -> {
			"The pricing is an aggregate of PriceInstrumentTime, PriceOperatorTime, PriceCleaning, PriceStocking, PriceWaste, PriceMaterials, as well as any per experiment charges.",
			"Pricing information is only calculated for Completed root protocols.",
			"For the Team or Notebook overloads, non-Completed and non-root protocols are filtered out and not displayed.",
			"By default, if teams or notebooks are specified and no date range is provided, function defaults to showing protocols completed in the past 30 days.",
			"Note that the prices displayed in this documentation are only for the sake of example and do not represent actual prices."
		},
		Sync -> Automatic,
		SeeAlso -> {
			"PriceStorage",
			"PriceWaste",
			"PriceInstrumentTime",
			"PriceOperatorTime",
			"PriceMaterials",
			"PriceCleaning",
			"PriceTransactions",
			"SummaryPrice"
		},
		Author -> {"xu.yi"}
	}
];