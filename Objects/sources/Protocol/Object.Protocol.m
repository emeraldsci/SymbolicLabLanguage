(* ::Package:: *)

(* ::Text:: *)
(*\[Copyright] 2011-2025 Emerald Cloud Lab, Inc.*)


With[
	{insertMe=Sequence@@$OperationStatisticsSharedFields},
	DefineObjectType[Object[Protocol], {
		Description->"A detailed set of parameters describing the execution of an experiment on the ECL.",
		CreatePrivileges->None,
		Cache->Session,
		Fields -> {
			DateConfirmed -> {
				Format -> Single,
				Class -> Date,
				Pattern :> _?DateObjectQ,
				Description -> "The date on which the protocol first entered processing or a backlog.",
				Category -> "General",
				Abstract -> True
			},
			DateRequested -> {
				Format -> Single,
				Class -> Date,
				Pattern :> _?DateObjectQ,
				Description -> "The date on which the protocol was available for ECL to begin activities in order to run the protocol. If the protocol was in and out of the user's backlog this will be the final time the protocol exited the backlog. If the user immediately had threads available this will be the date the protocol was first marked as Processing. In the case where the protocol needed an instrument repair or materials before it could start, this is the time when when it entered ShippingMaterials or RepairingInstrumentation.",
				Category -> "General",
				Abstract -> True
			},
			DateEnqueued -> {
				Format -> Single,
				Class -> Date,
				Pattern :> _?DateObjectQ,
				Description -> "The date on which the protocol was accepted and added to the queue.",
				Category -> "General",
				Abstract -> True
			},
			DateStarted -> {
				Format -> Single,
				Class -> Date,
				Pattern :> _?DateObjectQ,
				Description -> "The date on which the protocol moved from the front of the queue to begin running in the lab.",
				Category -> "General"
			},
			DateCompleted -> {
				Format -> Single,
				Class -> Date,
				Pattern :> _?DateObjectQ,
				Description -> "The date on which the last step of this protocol's execution was finished.",
				Category -> "General",
				Abstract -> True
			},
			DateCanceled -> {
				Format -> Single,
				Class -> Date,
				Pattern :> _?DateObjectQ,
				Description -> "The date on which the protocol was removed from the queue prior to starting.",
				Category -> "General"
			},
			Author -> {
				Format -> Single,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Object[User][ProtocolsAuthored],
				Description -> "The investigator who created this protocol.",
				Category -> "Organizational Information"
			},
			Script -> {
				Format -> Single,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Object[Notebook][Protocols],
				Description -> "The experimental workflow (i.e., the script) that created this protocol.",
				Category -> "General",
				Abstract -> True
			},
			SubprotocolScripts -> {
				Format -> Multiple,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Object[Notebook, Script][ParentProtocol],
				Description -> "All experiment workflows (i.e., scripts) generated by this protocol as a list of subprotocols.",
				Category -> "General"
			},
			DeveloperObject -> {
				Format -> Single,
				Class -> Expression,
				Pattern :> BooleanP,
				Description -> "Indicates that this object is being used for test purposes only and is not supported by standard SLL features.",
				Category -> "General",
				Developer -> True,
				AdminWriteOnly->True
			},
			CanaryBranch -> {
				Format -> Single,
				Class -> String,
				Pattern :> _String,
				Description -> "The user-defined git branch other than the stable branch on which this protocol is meant to be run.",
				Category -> "General",
				Developer -> True,
				AdminWriteOnly->True
			},
			Distro-> {
				Format -> Single,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Object[Software,Distro],
				Description -> "The pre-built set of packages for a specific commit of SLL used to generate this protocol.",
				Category -> "General",
				Developer -> True
			},
			Commit -> {
				Format -> Single,
				Class -> String,
				Pattern :> _String,
				Description -> "The git SHA1 hash for the commit to load this protocol for specific distro with Engine.",
				Category -> "General",
				Developer -> True
			},
			Site -> {
				Format -> Single,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Object[Container,Site],
				Description -> "The ECL site at which this protocol was executed.",
				Category -> "General",
				Abstract -> True
			},
			SamplesIn -> {
				Format -> Multiple,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Alternatives[
					Object[Sample][Protocols],
					Model[Sample][Protocols],
					Model[Item][Protocols],
					Object[Item][Protocols]
				],
				Description -> "Input samples for this analytical or preparative experiment.",
				Category -> "General"
			},
			ContainersIn -> {
				Format -> Multiple,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Alternatives[
					Object[Container][Protocols],
					Model[Container]
				],
				Description -> "Any containers containing this protocols' SamplesIn.",
				Category -> "General"
			},
			NumberOfReplicates -> {
				Format -> Single,
				Class -> Integer,
				Pattern :> GreaterP[0, 1],
				Units -> None,
				Description -> "Indicates the number of times the experiment is repeated with identical parameters.",
				Category -> "General"
			},
			Status -> {
				Format -> Single,
				Class -> Expression,
				Pattern :> ProtocolStatusP,
				Description -> "A general status indicating the stage of execution of the protocol.  The most common states are before confirmation (InCart), after confirmation (Backlogged or Processing), or after completion (Completed).",
				Category -> "General",
				Abstract -> True
			},
			OperationStatus -> {
				Format -> Single,
				Class -> Expression,
				Pattern :> OperationStatusP,
				Description -> "A detailed status relevant during execution of the protocol that describes whether the protocol is actively being set up by an operator (OperatorProcessing), currently running on an instrument (InstrumentProcessing), or awaiting for further operator action (OperatorReady).",
				Category -> "General",
				Developer -> True
			},
			StatusLog -> {
				Format -> Multiple,
				Class -> {Expression, Expression, Link},
				Pattern :> {_?DateObjectQ, ProtocolStatusP | OperationStatusP, _Link},
				Relation -> {Null, Null, Object[User] | Object[Protocol] | Object[Qualification] | Object[Maintenance] | Object[Repair]},
				Description -> "Log of the history of the Status and OperationStatus fields for this protocol.",
				Category -> "General",
				Headers -> {"Date","Status","Responsible Party"},
				Developer -> True
			},
			CheckpointProgress -> {
				Format -> Multiple,
				Class -> {String, Date, Date},
				Pattern :> {_String, _?DateObjectQ, _?DateObjectQ | Null},
				Units -> {None, None, None},
				Description -> "A listing of all the checkpoints passed in the execution of this protocol.",
				Category -> "General",
				Headers -> {"Name","Start Time","End Time"}
			},
			ProcedureLog -> {
				Format -> Multiple,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Object[Program][Protocol],
				Description -> "A list of log events tracking every step that has occurred in the progress of the current protocol.",
				Category -> "General",
				Developer -> True
			},
			RemainingTasks -> {
				Format -> Multiple,
				Class -> Expression,
				Pattern :> RosettaTaskP[],
				Description -> "A cached list of outstanding Engine tasks saved at the last procedure exit of this protocol. If Null, outstanding tasks will be determined from the protocol's ProcedureLog events when the procedure is next opened.",
				Category -> "General",
				Developer -> True
			},
			CompletedTasks -> {
				Format -> Multiple,
				Class -> {Date,Date,Link,Expression,Expression},
				Pattern :> {_?DateObjectQ,_?DateObjectQ,_Link,_String|Null,_String|Null},
				Relation -> {None, None, Object[User], None, None},
				Description -> "A cached list of completed Engine tasks saved at the last procedure exit of this protocol. If Null, completed tasks will be determined from the protocol's ProcedureLog events when the procedure is next opened.",
				Category -> "General",
				Units -> {None,None,None,None,None},
				Headers -> {"Date Started","Date Completed","Operator", "Task ID","Task HTML"},
				Developer -> True
			},
			ParentProtocol -> {
				Format -> Single,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Alternatives[
					Object[Protocol][Subprotocols],
					Object[Qualification][Subprotocols],
					Object[Maintenance][Subprotocols]
				],
				Description -> "The protocol that generated this sub-protocol during its execution.",
				Category -> "General",
				Developer -> True
			},
			RootProtocol -> {
				Format -> Single,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Alternatives[
					Object[Protocol],
					Object[Qualification],
					Object[Maintenance]
				],
				Description -> "The highest-level parent protocol that generated this subprotocol (or the one that generated the subprotocol that generated this subprotocol, etc.) during its execution.  If this protocol is the highest-level parent protocol, then its RootProtocol field will link to itself.",
				Category -> "General",
				Developer -> True
			},
			Subprotocols -> {
				Format -> Multiple,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Alternatives[
					Object[Protocol][ParentProtocol],
					Object[Qualification][ParentProtocol],
					Object[Maintenance][ParentProtocol]
				],
				Description -> "Any specific-purpose protocols that were generated by this protocol during its execution.",
				Category -> "General",
				Developer -> True
			},
			SubprotocolDescription -> {
				Format -> Single,
				Class -> String,
				Pattern :> _String,
				Description -> "A short title indicating what this subprotocol accomplishes.",
				Category -> "General",
				Abstract -> True
			},
			BatchedUnitOperations -> {
				Format -> Multiple,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Object[UnitOperation][Protocol],
				Description -> "The individual groupings of operations as they will be executed in the lab. This is used if some subset of samples must be batched and run together during the procedure.",
				Category -> "General"
			},
			ReplacementProtocol -> {
				Format -> Single,
				Class -> Link,
				Pattern :> _Link,
				Relation ->  Alternatives[
					Object[Protocol],
					Object[Qualification],
					Object[Maintenance]
				],
				Description -> "If this protocol was aborted due to technical reasons, links to the replacement protocol run in its place.",
				Category -> "General"
			},
			CurrentInstruments -> {
				Format -> Multiple,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Object[Instrument][CurrentProtocol],
				Description -> "Any instruments which are actively being used by this protocol.",
				Category -> "General",
				Developer -> True
			},
			InstrumentLog -> {
				Format -> Multiple,
				Class -> {Date, Link},
				Pattern :> {_?DateObjectQ, _Link},
				Relation -> {Null, Object[Instrument]},
				Description -> "Log of the instruments used during execution of this protocol.",
				Category -> "General",
				Headers -> {"Date","Instrument"},
				Developer -> True
			},
			InstrumentRepairs -> {
				Format -> Multiple,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Object[Repair][AffectedProtocols],
				Description -> "A record of instrument maintenance or servicing required throughout this experiment.",
				Category -> "General",
				Developer -> True
			},
			ReservedStorageAvailability -> {
				Format -> Multiple,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Object[StorageAvailability][CurrentProtocol],
				Description -> "The positions used for storage that are reserved for this protocol during a storage task.",
				Category -> "Storage Information",
				Developer -> True
			},
			Sterile -> {
				Format -> Single,
				Class -> Expression,
				Pattern :> BooleanP,
				Description -> "Indicates if aseptic techniques are followed for handling this sample in lab. Aseptic techniques include sanitization, autoclaving, sterile filtration, or transferring in a biosafety cabinet during experimentation and storage.",
				Category -> "General"
			},
			WorkingSamples -> {
				Format -> Multiple,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Alternatives[
					Object[Sample],
					Model[Sample],
					Object[Item],
					Model[Item]
				],
				Description -> "For each member of SamplesIn, the derived sample on which the experiment acts. This list diverges from SamplesIn when input samples are transferred to new containers.",
				Category -> "Resources",
				Developer -> True
			},

			WorkingContainers -> {
				Format -> Multiple,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Alternatives[
					Object[Container],
					Model[Container]
				],
				Description ->"Containers of the samples corresponding to preparations of SamplesIn generated during sample preparation and intended for use in this experiment.",
				Category -> "Resources",
				Developer -> True
			},

			(* --- Replicate Experiments --- *)

			Template -> {
				Format -> Single,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Object[Protocol][ProtocolsTemplated],
				Description -> "The protocol whose option selections are be selected as the default options for this protocol.",
				Category -> "Replicate Experiments"
			},
			ProtocolsTemplated -> {
				Format -> Multiple,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Object[Protocol][Template],
				Description -> "Protocols which were generated using this protocol's options as a starting point for its option defaults.",
				Category -> "Replicate Experiments"
			},

			(* --- Protocol Support --- *)
			CartResources -> {
				Format -> Multiple,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Alternatives[
					Object[Sample],
					Object[Container],
					Object[Part],
					Object[Plumbing],
					Object[Item],
					Object[Sensor],
					Object[Wiring]
				],
				Description -> "Any resources that must be re-picked for use in this protocol upon resumption from scientific support or processing.",
				Category -> "Protocol Support",
				Developer -> True
			},
			CartInstruments -> {
				Format -> Multiple,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Object[Instrument],
				Description -> "Any instruments that must be re-selected for use in this protocol upon resumption from scientific support or processing.",
				Category -> "Protocol Support",
				Developer -> True
			},
			CoveredCartResources -> {
				Format -> Multiple,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Alternatives[
					Object[Sample],
					Object[Container],
					Object[Part],
					Object[Plumbing],
					Object[Item],
					Object[Sensor],
					Object[Wiring]
				],
				Description -> "Any resources that must be re-covered after resource picking of CartResources for use in this protocol upon resumption from scientific support or processing.",
				Category -> "Protocol Support",
				Developer -> True
			},

			(* --- Method Information --- *)
			ImagingSamples -> {
				Format -> Multiple,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Alternatives[
					Object[Sample],
					Object[Container]
				],
				Description -> "Any resources used during the course of this protocol that must be imaged.",
				Category -> "General",
				Developer -> True
			},
			VolumeMeasurementSamples -> {
				Format -> Multiple,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Alternatives[
					Object[Sample],
					Object[Container]
				],
				Description -> "Any resources used during the course of this protocol whose volumes must be updated.",
				Category -> "General",
				Developer -> True
			},
			WeightMeasurementSamples -> {
				Format -> Multiple,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Alternatives[
					Object[Sample],
					Object[Container]
				],
				Description -> "Any resources used during the course of this protocol whose weights must be updated.",
				Category -> "General",
				Developer -> True
			},
			LiquidHandlingLogs -> {
				Format -> Multiple,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Object[EmeraldCloudFile],
				Description -> "The instrumentation trace files that monitored and recorded the execution of robotic liquid handling performed in this protocol.",
				Category -> "General",
				AdminWriteOnly->True
			},
			LiquidHandlingLogPaths -> {
				Format -> Multiple,
				Class -> String,
				Pattern :> FilePathP,
				Description -> "The file paths of the instrumentation trace files that monitored and recorded the execution of robotic liquid handling performed in this protocol.",
				Category -> "General",
				Developer -> True,
				AdminWriteOnly->True
			},
			InSitu -> {
				Format -> Single,
				Class -> Boolean,
				Pattern :> BooleanP,
				Description -> "Indicates if the protocol runs the experiment on the SamplesIn while leaving them in their current location and state rather than moving them back and forth from storage or their previous location in a parent protocol.",
				Category -> "General",
				Developer -> True
			},

			(* --- Sample Preparation --- *)
			PreparatoryUnitOperations -> {
				Format -> Multiple,
				Class -> Expression,
				Pattern :> _|_,
				Description -> "A list of unit operations (such as transfers, aliquots, mixes and dilutions) that are be performed in the order listed to prepare samples prior to the experiment.",
				Category -> "Sample Preparation"
			},
			PreparatoryPrimitives -> {
				Format -> Multiple,
				Class -> Expression,
				Pattern :> _|_,
				Description -> "A list of SampleManipulation primitives (such as transfers, consolidations, aliquots, mixes and resuspensions) that are performed in the order listed to prepare samples prior to the experiment.",
				Category -> "Sample Preparation"
			},
			PreparedSamples -> {
				Format -> Multiple,
				Class -> {String, Expression, Integer, Expression, String},
				Pattern :> {_String, _Symbol, _Integer, _Integer|_Symbol,_String},
				Relation -> {Null, Null, Null, Null, Null},
				Units -> {None, None, None, None, None},
				Description -> "Prepared Samples that are used in this protocol and a description of the field in which a prepared sample's resolved object is stored. Position and index are Null when a prepared sample's resolution is stored in a single field.",
				Category -> "General",
				Headers->{"Define Name","Field Name","Field Position", "Field Index","Container Position"},
				Developer -> True
			},
			VolumeCheckSamplePrep -> {
				Format -> Single,
				Class -> Expression,
				Pattern :> BooleanP,
				Description -> "Indicates if any liquid samples prepared by using the PreparatoryUnitOperations option should have their volumes measured and updated before running the experiment.",
				Category -> "Sample Preparation"
			},
			InjectionSampleVolumeMeasurement-> {
				Format -> Single,
				Class -> Boolean,
				Pattern :> BooleanP,
				Description -> "Indicates if any liquid samples prepared by using the PreparatoryUnitOperations option in this chromatography protocol should have their volumes measured and updated before running the experiment.",
				Category -> "Sample Preparation",
				Developer -> True
			},
			IncubateSamplePreparation -> {
				Format -> Multiple,
				Class -> {
						Incubate -> Boolean,
						IncubationTemperature -> Real,
						IncubationTime -> Real,
						Mix -> Boolean,
						MixType -> Expression,
						MixUntilDissolved -> Boolean,
						MaxIncubationTime -> Real,
						IncubationInstrument -> Link,
						AnnealingTime -> Real,
						IncubateAliquotContainer -> Expression,
						IncubateAliquot -> Real,
						IncubateAliquotDestinationWell -> Expression
					},
				Pattern :> {
						Incubate -> BooleanP,
						IncubationTemperature -> GreaterEqualP[0 Kelvin],
						IncubationTime -> GreaterEqualP[0 Second],
						Mix -> BooleanP,
						MixType -> MixTypeP,
						MixUntilDissolved -> BooleanP,
						MaxIncubationTime -> GreaterEqualP[0 Second],
						IncubationInstrument -> ObjectP[{Object[Instrument], Model[Instrument]}],
						AnnealingTime -> GreaterEqualP[0 Second],
						IncubateAliquotContainer -> {_Integer|Null, ObjectP[Model[Container]]|Null},
						IncubateAliquot -> GreaterEqualP[0 Liter],
						IncubateAliquotDestinationWell -> Alternatives @@ Flatten[ECL`AllWells[NumberOfWells->384]]
					},
				Units -> {
						Incubate -> None,
						IncubationTemperature -> Celsius,
						IncubationTime -> Second,
						Mix -> None,
						MixType -> None,
						MixUntilDissolved -> None,
						MaxIncubationTime -> Second,
						IncubationInstrument -> None,
						AnnealingTime -> Second,
						IncubateAliquotContainer -> None,
						IncubateAliquot -> Liter,
						IncubateAliquotDestinationWell -> None
					},
				Relation -> {
						Incubate -> Null,
						IncubationTemperature -> Null,
						IncubationTime -> Null,
						Mix -> Null,
						MixType -> Null,
						MixUntilDissolved -> Null,
						MaxIncubationTime -> Null,
						IncubationInstrument -> Alternatives[Model[Instrument],Object[Instrument]],
						AnnealingTime -> Null,
						IncubateAliquotContainer -> Null,
						IncubateAliquot -> Null,
						IncubateAliquotDestinationWell -> Null
					},
				IndexMatching -> SamplesIn,
				Description -> "For each member of SamplesIn, parameters describing how the input samples should be heated and/or mixed prior to any aliquoting or the start of the experiment.",
				Category -> "Sample Preparation"
			},
			CentrifugeSamplePreparation -> {
				Format -> Multiple,
				Class -> {
					Centrifuge -> Boolean,
					CentrifugeInstrument -> Link,
					CentrifugeIntensity -> VariableUnit,
					CentrifugeTime -> Real,
					CentrifugeTemperature -> Real,
					CentrifugeAliquotContainer -> Expression,
					CentrifugeAliquot -> Real,
					CentrifugeAliquotDestinationWell -> Expression
				},
				Pattern :> {
					Centrifuge -> BooleanP,
					CentrifugeInstrument -> ObjectP[{Object[Instrument, Centrifuge], Model[Instrument, Centrifuge]}],
					CentrifugeIntensity -> GreaterEqualP[0 RPM] | GreaterEqualP[0 GravitationalAcceleration],
					CentrifugeTime -> GreaterEqualP[0 Second],
					CentrifugeTemperature -> GreaterEqualP[0 Kelvin],
					CentrifugeAliquotContainer -> {_Integer|Null, ObjectP[Model[Container]]|Null},
					CentrifugeAliquot -> GreaterEqualP[0 Liter],
					CentrifugeAliquotDestinationWell -> Alternatives @@ Flatten[ECL`AllWells[NumberOfWells->384]]
				},
				Relation -> {
					Centrifuge -> Null,
					CentrifugeInstrument -> Alternatives[Object[Instrument, Centrifuge], Model[Instrument, Centrifuge]],
					CentrifugeIntensity -> Null,
					CentrifugeTime -> Null,
					CentrifugeTemperature -> Null,
					CentrifugeAliquotContainer -> Null,
					CentrifugeAliquot -> Null,
					CentrifugeAliquotDestinationWell -> Null
				},
				Units -> {
					Centrifuge -> None,
					CentrifugeInstrument -> None,
					CentrifugeIntensity -> None,
					CentrifugeTime -> Minute,
					CentrifugeTemperature -> Celsius,
					CentrifugeAliquotContainer -> None,
					CentrifugeAliquot -> Liter,
					CentrifugeAliquotDestinationWell -> None
				},
				IndexMatching -> SamplesIn,
				Description -> "For each member of SamplesIn, parameters describing how the input samples should be centrifuged prior to any aliquoting or the start of the experiment.",
				Category -> "Sample Preparation"
			},
			FilterSamplePreparation -> {
				Format -> Multiple,
				Class -> {
					Filtration -> Boolean,
					FiltrationType -> Expression,
					Filter -> Link,
					FilterMaterial -> Expression,
					FilterPoreSize -> Real,
					FilterContainerOut -> Expression,
					FilterInstrument -> Link,
					FilterSyringe -> Link,
					FilterHousing -> Link,
					FilterIntensity -> VariableUnit,
					FilterTime -> Real,
					FilterTemperature -> Real,
					FilterSterile -> Boolean,
					FilterAliquotContainer -> Expression,
					FilterAliquot -> Real,
					PrefilterMaterial -> Expression,
					PrefilterPoreSize -> Real,
					FilterAliquotDestinationWell -> Expression
				},
				Pattern :> {
					Filtration -> BooleanP,
					FiltrationType -> FiltrationTypeP,
					(* TODO: Remove after item migration *)
					(* Post migration should no longer need references to Model[Sample]/Object[Sample] *)
					Filter->ObjectP[{Object[Container], Model[Container], Object[Sample], Model[Sample], Object[Item], Model[Item]}],
					FilterMaterial -> FilterMembraneMaterialP,
					FilterPoreSize -> FilterSizeP,
					FilterContainerOut -> {_Integer,ObjectP[{Model[Container],Object[Container]}]},
					FilterInstrument -> ObjectP[{
						Model[Instrument,FilterBlock],
						Object[Instrument,FilterBlock],
						Model[Instrument,PeristalticPump],
						Object[Instrument,PeristalticPump],
						Model[Instrument,VacuumPump],
						Object[Instrument,VacuumPump],
						Model[Instrument,Centrifuge],
						Object[Instrument,Centrifuge],
						Model[Instrument,SyringePump],
						Object[Instrument,SyringePump]
					}],
					FilterSyringe -> ObjectP[{
						Model[Container,Syringe],
						Object[Container,Syringe]
					}],
					FilterHousing -> ObjectP[{
						Model[Instrument,FilterHousing],
						Object[Instrument,FilterHousing]
					}],
					FilterIntensity -> GreaterP[0 RPM] | GreaterP[0 GravitationalAcceleration],
					FilterTime -> GreaterEqualP[0 Minute],
					FilterTemperature -> GreaterEqualP[0 Kelvin],
					FilterSterile -> BooleanP,
					FilterAliquotContainer -> {_Integer|Null, ObjectP[Model[Container]]|Null},
					FilterAliquot -> GreaterEqualP[0 Liter],
					PrefilterMaterial -> FilterMembraneMaterialP,
					PrefilterPoreSize -> FilterSizeP,
					FilterAliquotDestinationWell -> Alternatives @@ Flatten[ECL`AllWells[NumberOfWells->384]]
				},
				Units -> {
					Filtration -> None,
					FiltrationType -> None,
					Filter -> None,
					FilterMaterial -> None,
					FilterPoreSize -> Micrometer,
					FilterContainerOut -> None,
					FilterInstrument -> None,
					FilterSyringe -> None,
					FilterHousing -> None,
					FilterIntensity -> None,
					FilterTime -> Minute,
					FilterTemperature -> Celsius,
					FilterSterile -> None,
					FilterAliquotContainer -> None,
					FilterAliquot -> Liter,
					PrefilterMaterial -> None,
					PrefilterPoreSize -> Micrometer,
					FilterAliquotDestinationWell -> None
				},
				Relation -> {
					Filtration -> Null,
					FiltrationType -> Null,
					(* TODO: Remove after item migration *)
					(* Post migration should no longer need references to Model[Sample]/Object[Sample] *)
					Filter ->Alternatives[Object[Container], Model[Container],Object[Sample],Model[Sample],Object[Item],Model[Item]],
					FilterMaterial -> Null,
					FilterPoreSize -> Null,
					FilterContainerOut -> Null,
					FilterInstrument -> Alternatives[
						Model[Instrument,FilterBlock],
						Object[Instrument,FilterBlock],
						Model[Instrument,PeristalticPump],
						Object[Instrument,PeristalticPump],
						Model[Instrument,VacuumPump],
						Object[Instrument,VacuumPump],
						Model[Instrument,Centrifuge],
						Object[Instrument,Centrifuge],
						Model[Instrument,SyringePump],
						Object[Instrument,SyringePump]
					],
					FilterSyringe -> Alternatives[
						Model[Container,Syringe],
						Object[Container,Syringe]
					],
					FilterHousing -> Alternatives[
						Model[Instrument,FilterHousing],
						Object[Instrument,FilterHousing]
					],
					FilterIntensity -> Null,
					FilterTime -> Null,
					FilterTemperature -> Null,
					FilterSterile -> Null,
					FilterAliquotContainer -> Null,
					FilterAliquot -> Null,
					PrefilterMaterial -> Null,
					PrefilterPoreSize -> Null,
					FilterAliquotDestinationWell -> Null
				},
				IndexMatching -> SamplesIn,
				Description -> "For each member of SamplesIn, parameters describing how particulates should be separated from the input samples prior to any aliquoting or the start of the experiment.",
				Category -> "Sample Preparation"
			},
			SamplePreparationProtocols -> {
				Format -> Multiple,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Alternatives[
					Object[Protocol],
					Object[Notebook, Script]
				],
				Description -> "Protocols used to mix, incubate, centrifuge, filter, and aliquot the SamplesIn prior to starting the experiment.",
				Category -> "Sample Preparation"
			},

			AliquotSamplePreparation -> {
				Format -> Multiple,
				Class -> {
					Aliquot -> Boolean,
					AliquotAmount -> Expression,
					TargetConcentration -> Expression,
					AssayVolume -> Real,
					(* need this to be an expression; it's okay because we don't ever resource pick from this field; if we had multiple multiples this could be real links *)
					AliquotContainer -> Expression,
					AssayBuffer -> Link,
					BufferDiluent -> Link,
					BufferDilutionFactor -> Real,
					ConcentratedBuffer -> Link,
					DestinationWell -> Expression,
					TargetConcentrationAnalyte -> Expression,
					AliquotSampleLabel -> String
				},
				Pattern :> {
					Aliquot -> BooleanP,
					AliquotAmount -> ListableP[GreaterEqualP[0 Milliliter]|GreaterEqualP[0 Gram]|GreaterEqualP[0 Unit] |GreaterEqualP[0]|Null],
					TargetConcentration -> ListableP[GreaterEqualP[0*Micro*Molar] | GreaterEqualP[0 (Milligram/Milliliter)]|Null],
					AssayVolume -> GreaterP[0 Milliliter],
					AliquotContainer -> {_Integer, ObjectP[{Model[Container], Object[Container]}]},
					AssayBuffer -> ObjectP[{Object[Sample], Model[Sample]}],
					BufferDiluent -> ObjectP[{Object[Sample], Model[Sample]}],
					BufferDilutionFactor -> GreaterEqualP[1],
					ConcentratedBuffer -> ObjectP[{Object[Sample], Model[Sample]}],
					DestinationWell -> Alternatives @@ Flatten[ECL`AllWells[NumberOfWells->384]],
					TargetConcentrationAnalyte -> ListableP[ObjectP[Model[Molecule]]|Null],
					AliquotSampleLabel -> _String
				},
				Units -> {
					Aliquot -> None,
					AliquotAmount -> None,
					TargetConcentration -> None,
					AssayVolume -> Milliliter,
					AliquotContainer -> None,
					AssayBuffer -> None,
					BufferDiluent -> None,
					BufferDilutionFactor -> None,
					ConcentratedBuffer -> None,
					DestinationWell -> None,
					TargetConcentrationAnalyte -> None,
					AliquotSampleLabel -> None
				},
				Relation -> {
					Aliquot -> Null,
					AliquotAmount -> Null,
					TargetConcentration -> Null,
					AssayVolume -> Null,
					AliquotContainer -> Null,
					AssayBuffer -> Object[Sample] | Model[Sample],
					BufferDiluent -> Object[Sample] | Model[Sample],
					BufferDilutionFactor -> Null,
					ConcentratedBuffer -> Object[Sample] | Model[Sample],
					DestinationWell -> Null,
					TargetConcentrationAnalyte -> Null,
					AliquotSampleLabel -> Null
				},
				Description -> "For each member of AliquotSamples, parameters describing how aliquots are be drawn from the input samples after initial sample preparation in order to create new aliquot samples upon which the experiment proceeds.",
				Category -> "Aliquoting"
			},

			PooledSamplesIn -> {
				Format -> Multiple,
				Class -> Expression,
				Pattern :> {ObjectReferenceP[Object[Sample]]..},
				Units -> None,
				Description -> "The members of SamplesIn gathered into the groupings that are mixed in each AliquotContainer.",
				Category -> "General"
			},

			NestedIndexMatchingSamplesIn -> {
				Format -> Multiple,
				Class -> Expression,
				Pattern :> {(ObjectReferenceP[Object[Sample]]|_String)..},
				Units -> None,
				Description -> "The members of SamplesIn gathered into the groupings that are mixed in each AliquotContainer.",
				Category -> "General"
			},

			PooledIncubateSamplePreparation -> {
				Format -> Multiple,
				Class -> {
					Incubate -> Boolean,
					IncubationTemperature -> Real,
					IncubationTime -> Real,
					Mix -> Boolean,
					MixType -> Expression,
					MixUntilDissolved -> Boolean,
					MaxIncubationTime -> Real,
					IncubationInstrument -> Link,
					AnnealingTime -> Real,
					IncubateAliquotContainer -> Expression,
					IncubateAliquot -> Real,
					IncubateAliquotDestinationWell -> Expression
				},
				Pattern :> {
					Incubate -> BooleanP,
					IncubationTemperature -> GreaterEqualP[0 Kelvin],
					IncubationTime -> GreaterEqualP[0 Second],
					Mix -> BooleanP,
					MixType -> MixTypeP,
					MixUntilDissolved -> BooleanP,
					MaxIncubationTime -> GreaterEqualP[0 Second],
					IncubationInstrument -> ObjectP[{Object[Instrument], Model[Instrument]}],
					AnnealingTime -> GreaterEqualP[0 Second],
					IncubateAliquotContainer -> {_Integer|Null, ObjectP[Model[Container]]|Null},
					IncubateAliquot -> GreaterEqualP[0 Liter],
					IncubateAliquotDestinationWell -> Alternatives @@ Flatten[ECL`AllWells[NumberOfWells->384]]
				},
				Units -> {
					Incubate -> None,
					IncubationTemperature -> Celsius,
					IncubationTime -> Second,
					Mix -> None,
					MixType -> None,
					MixUntilDissolved -> None,
					MaxIncubationTime -> Second,
					IncubationInstrument -> None,
					AnnealingTime -> Second,
					IncubateAliquotContainer -> None,
					IncubateAliquot -> Liter,
					IncubateAliquotDestinationWell -> None
				},
				Relation -> {
					Incubate -> Null,
					IncubationTemperature -> Null,
					IncubationTime -> Null,
					Mix -> Null,
					MixType -> Null,
					MixUntilDissolved -> Null,
					MaxIncubationTime -> Null,
					IncubationInstrument -> Alternatives[Model[Instrument],Object[Instrument]],
					AnnealingTime -> Null,
					IncubateAliquotContainer -> Null,
					IncubateAliquot -> Null,
					IncubateAliquotDestinationWell -> Null
				},
				IndexMatching -> PooledSamplesIn,
				Description -> "For each member of PooledSamplesIn, parameters describing how the grouped samples should be mixed and/or incubated after aliquoting but prior to the start of the experiment.",
				Category -> "Sample Preparation"
			},

			NestedIndexMatchingIncubateSamplePreparation -> {
				Format -> Multiple,
				Class -> {
					Incubate -> Boolean,
					IncubationTemperature -> Real,
					IncubationTime -> Real,
					Mix -> Boolean,
					MixType -> Expression,
					MixUntilDissolved -> Boolean,
					MaxIncubationTime -> Real,
					IncubationInstrument -> Link,
					AnnealingTime -> Real,
					IncubateAliquotContainer -> Expression,
					IncubateAliquot -> Real,
					IncubateAliquotDestinationWell -> Expression
				},
				Pattern :> {
					Incubate -> BooleanP,
					IncubationTemperature -> GreaterEqualP[0 Kelvin],
					IncubationTime -> GreaterEqualP[0 Second],
					Mix -> BooleanP,
					MixType -> MixTypeP,
					MixUntilDissolved -> BooleanP,
					MaxIncubationTime -> GreaterEqualP[0 Second],
					IncubationInstrument -> ObjectP[{Object[Instrument], Model[Instrument]}],
					AnnealingTime -> GreaterEqualP[0 Second],
					IncubateAliquotContainer -> {_Integer|Null, ObjectP[Model[Container]]|Null},
					IncubateAliquot -> GreaterEqualP[0 Liter],
					IncubateAliquotDestinationWell -> Alternatives @@ Flatten[ECL`AllWells[NumberOfWells->384]]
				},
				Units -> {
					Incubate -> None,
					IncubationTemperature -> Celsius,
					IncubationTime -> Second,
					Mix -> None,
					MixType -> None,
					MixUntilDissolved -> None,
					MaxIncubationTime -> Second,
					IncubationInstrument -> None,
					AnnealingTime -> Second,
					IncubateAliquotContainer -> None,
					IncubateAliquot -> Liter,
					IncubateAliquotDestinationWell -> None
				},
				Relation -> {
					Incubate -> Null,
					IncubationTemperature -> Null,
					IncubationTime -> Null,
					Mix -> Null,
					MixType -> Null,
					MixUntilDissolved -> Null,
					MaxIncubationTime -> Null,
					IncubationInstrument -> Alternatives[Model[Instrument],Object[Instrument]],
					AnnealingTime -> Null,
					IncubateAliquotContainer -> Null,
					IncubateAliquot -> Null,
					IncubateAliquotDestinationWell -> Null
				},
				IndexMatching -> NestedIndexMatchingSamplesIn,
				Description -> "For each member of NestedIndexMatchingSamplesIn, parameters describing how the grouped samples should be mixed and/or incubated after aliquoting but prior to the start of the experiment.",
				Category -> "Sample Preparation"
			},

			PooledCentrifugeSamplePreparation -> {
				Format -> Multiple,
				Class -> {
					Centrifuge -> Boolean,
					CentrifugeInstrument -> Link,
					CentrifugeIntensity -> VariableUnit,
					CentrifugeTime -> Real,
					CentrifugeTemperature -> Real,
					CentrifugeAliquotContainer -> Expression,
					CentrifugeAliquot -> Real,
					CentrifugeAliquotDestinationWell -> Expression
				},
				Pattern :> {
					Centrifuge -> BooleanP,
					CentrifugeInstrument -> ObjectP[{Object[Instrument, Centrifuge], Model[Instrument, Centrifuge]}],
					CentrifugeIntensity -> GreaterEqualP[0 RPM] | GreaterEqualP[0 GravitationalAcceleration],
					CentrifugeTime -> GreaterEqualP[0 Second],
					CentrifugeTemperature -> GreaterEqualP[0 Kelvin],
					CentrifugeAliquotContainer -> {_Integer|Null, ObjectP[Model[Container]]|Null},
					CentrifugeAliquot -> GreaterEqualP[0 Liter],
					CentrifugeAliquotDestinationWell -> Alternatives @@ Flatten[ECL`AllWells[NumberOfWells->384]]
				},
				Relation -> {
					Centrifuge -> Null,
					CentrifugeInstrument -> Alternatives[Object[Instrument, Centrifuge], Model[Instrument, Centrifuge]],
					CentrifugeIntensity -> Null,
					CentrifugeTime -> Null,
					CentrifugeTemperature -> Null,
					CentrifugeAliquotContainer -> Null,
					CentrifugeAliquot -> Null,
					CentrifugeAliquotDestinationWell -> Null
				},
				Units -> {
					Centrifuge -> None,
					CentrifugeInstrument -> None,
					CentrifugeIntensity -> None,
					CentrifugeTime -> Minute,
					CentrifugeTemperature -> Celsius,
					CentrifugeAliquotContainer -> None,
					CentrifugeAliquot -> Liter,
					CentrifugeAliquotDestinationWell -> None
				},
				IndexMatching -> PooledSamplesIn,
				Description -> "For each member of PooledSamplesIn, parameters describing how the grouped samples should be centrifuged after aliquoting and pooled mixing but prior to the start of the experiment.",
				Category -> "Sample Preparation"
			},

			NestedIndexMatchingCentrifugeSamplePreparation -> {
				Format -> Multiple,
				Class -> {
					Centrifuge -> Boolean,
					CentrifugeInstrument -> Link,
					CentrifugeIntensity -> VariableUnit,
					CentrifugeTime -> Real,
					CentrifugeTemperature -> Real,
					CentrifugeAliquotContainer -> Expression,
					CentrifugeAliquot -> Real,
					CentrifugeAliquotDestinationWell -> Expression
				},
				Pattern :> {
					Centrifuge -> BooleanP,
					CentrifugeInstrument -> ObjectP[{Object[Instrument, Centrifuge], Model[Instrument, Centrifuge]}],
					CentrifugeIntensity -> GreaterEqualP[0 RPM] | GreaterEqualP[0 GravitationalAcceleration],
					CentrifugeTime -> GreaterEqualP[0 Second],
					CentrifugeTemperature -> GreaterEqualP[0 Kelvin],
					CentrifugeAliquotContainer -> {_Integer|Null, ObjectP[Model[Container]]|Null},
					CentrifugeAliquot -> GreaterEqualP[0 Liter],
					CentrifugeAliquotDestinationWell -> Alternatives @@ Flatten[ECL`AllWells[NumberOfWells->384]]
				},
				Relation -> {
					Centrifuge -> Null,
					CentrifugeInstrument -> Alternatives[Object[Instrument, Centrifuge], Model[Instrument, Centrifuge]],
					CentrifugeIntensity -> Null,
					CentrifugeTime -> Null,
					CentrifugeTemperature -> Null,
					CentrifugeAliquotContainer -> Null,
					CentrifugeAliquot -> Null,
					CentrifugeAliquotDestinationWell -> Null
				},
				Units -> {
					Centrifuge -> None,
					CentrifugeInstrument -> None,
					CentrifugeIntensity -> None,
					CentrifugeTime -> Minute,
					CentrifugeTemperature -> Celsius,
					CentrifugeAliquotContainer -> None,
					CentrifugeAliquot -> Liter,
					CentrifugeAliquotDestinationWell -> None
				},
				IndexMatching -> PooledSamplesIn,
				Description -> "For each member of PooledSamplesIn, parameters describing how the grouped samples should be centrifuged after aliquoting and pooled mixing but prior to the start of the experiment.",
				Category -> "Sample Preparation"
			},


			(* --- Aliquoting --- *)
			AliquotProtocols -> {
				Format -> Multiple,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Object[Protocol],
				Description -> "Protocols used to create AliquotSamples prior to starting the experiment.",
				Category -> "Aliquoting"
			},
			TargetContainer->{
				Format->Multiple,
				Class->Link,
				Pattern:>_Link,
				Relation->Alternatives[
					Object[Container],
					Model[Container]
				],
				Description->"For each member of SamplesIn, the container in which the sample resides following sample preparation in order to ensure that the sample is in a container compatible with the instrument(s) used in the experiment.",
				IndexMatching->SamplesIn,
				Category->"Aliquoting",
				Developer -> True
			},
			TargetSampleGroupings->{
				Format->Multiple,
				Class->Expression,
				Pattern:>{ObjectP[Object[Sample]] ..},
				Description->"A list of lists indicating which samples will be grouped together in each container after all sample preparation has completed.",
				Category->"Aliquoting",
				Developer->True
			},

			(* --- Sample Post-Processing --- *)
			PostProcessingProtocols -> {
				Format -> Multiple,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Object[Protocol],
				Description -> "Protocols used to perform measurements such as volume measurement or sample imaging after the main procedure is complete.",
				Category -> "Sample Post-Processing"
			},
			ImageSample -> {
				Format -> Single,
				Class -> Expression,
				Pattern :> BooleanP,
				Description -> "Indicates if the samples that are modified in the course of the experiment are imaged after running the experiment.",
				Category -> "Sample Post-Processing"
			},

			(* --- Experiment Results --- *)
			Data -> {
				Format -> Multiple,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Object[Data][Protocol],
				Description -> "Any primary data generated by this protocol.",
				Category -> "Experimental Results",
				AdminWriteOnly->True
			},
			NewSamples -> {
				Format -> Multiple,
				Class -> Expression,
				Pattern :> {{ObjectP[{Object[Sample],Object[Item],Object[Plumbing]}]..}..},
				Description -> "For each member of SamplesIn, the list of new samples generated	from each source sample.",
				Category -> "Experimental Results",
				IndexMatching->SamplesIn
			},
			SamplesOut -> {
				Format -> Multiple,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Object[Sample][Protocols]|Object[Item][Protocols]|Object[Plumbing][Protocols],
				Description -> "Any preparative samples generated by the protocol.",
				Category -> "Experimental Results",
				AdminWriteOnly->True
			},
			ContainersOut -> {
				Format -> Multiple,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Alternatives[
					Object[Container][Protocols],
					Model[Container]
				],
				Description -> "Any containers holding SamplesOut generated by this protocol.",
				Category -> "Experimental Results",
				AdminWriteOnly->True
			},
			EnvironmentalData -> {
				Format -> Multiple,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Object[Data][Protocol],
				Description -> "Measurements of environmental conditions (temperature and humidity) recorded during the execution of this protocol.",
				Category -> "Experimental Results",
				AdminWriteOnly->True
			},
			ExperimentReviewNotebook -> {
				Format -> Single,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Object[EmeraldCloudFile],
				Description -> "Document summarizing the key results from the experimental run, accompanied by relevant metadata and contextual information. This document is created automatically by GenerateExperimentReview.",
				Category -> "Experimental Results"
			},

			(* --- Sample Storage --- *)
			TransportChilledDevice -> {
				Format -> Multiple,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Object[Instrument, PortableCooler] | Model[Instrument, PortableCooler],
				Description -> "Indicates the instrument(s) used to transport chilled samples during this protocol.",
				Category -> "Sample Storage",
				Developer -> True
			},
			TransportChilledTemperature -> {
				Format -> Multiple,
				Class -> Real,
				Pattern :> GreaterP[0 Kelvin],
				Units -> Celsius,
				Description -> "The temperature(s) at which the TransportChilledDevice(s) were set during this protocol.",
				Category -> "Sample Storage",
				Developer -> True
			},
			TransportWarmedDevice -> {
				Format -> Multiple,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Object[Instrument, PortableHeater] | Model[Instrument, PortableHeater],
				Description -> "Indicates the instrument(s) used to transport warmed samples during this protocol.",
				Category -> "Sample Storage",
				Developer -> True
			},
			TransportWarmedTemperature -> {
				Format -> Multiple,
				Class -> Real,
				Pattern :> GreaterP[0 Kelvin],
				Units -> Celsius,
				Description -> "The temperature(s) at which the TransportWarmedDevice(s) were set during this protocol.",
				Category -> "Sample Storage",
				Developer -> True
			},

			InitialNitrogenPressure -> {
				Format -> Single,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Object[Data][Protocol],
				Description -> "The pressure data of the nitrogen gas source before starting the experiment.",
				Category -> "General",
				AdminWriteOnly->True
			},
			NitrogenPressureLog -> {
				Format -> Single,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Object[Data][Protocol],
				Description -> "The pressure log for the nitrogen gas source for the relevant section of the facility.",
				Category -> "General",
				AdminWriteOnly->True
			},
			InitialCO2Pressure -> {
				Format -> Single,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Object[Data][Protocol],
				Description -> "The pressure data of the CO2 gas source before starting the experiment.",
				Category -> "General",
				AdminWriteOnly->True
			},
			CO2PressureLog -> {
				Format -> Single,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Object[Data][Protocol],
				Description -> "The pressure log for the CO2 gas source for the relevant section of the facility.",
				Category -> "General",
				AdminWriteOnly->True
			},
			InitialArgonPressure -> {
				Format -> Single,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Object[Data][Protocol],
				Description -> "The pressure data of the argon gas source before starting the experiment.",
				Category -> "General",
				AdminWriteOnly->True
			},
			ArgonPressureLog -> {
				Format -> Single,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Object[Data][Protocol],
				Description -> "The pressure log for the argon gas source for the relevant section of the facility.",
				Category -> "General",
				Developer -> True,
				AdminWriteOnly->True
			},
			UserCommunications -> {
				Format -> Multiple,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Object[SupportTicket, UserCommunication][AffectedProtocol],
				Description -> "Discussions with users about the execution of this top-level protocol.",
				Category -> "Protocol Support"
			},
			InternalCommunications -> {
				Format -> Multiple,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Object[SupportTicket, Operations][AffectedProtocol],
				Description -> "Support tickets associated with the execution of this top-level protocol.",
				Category -> "Protocol Support",
				Developer -> True,
				AdminViewOnly -> True
			},
			ProtocolSpecificInternalCommunications -> {
				Format -> Multiple,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Object[SupportTicket][SourceProtocol],
				Description -> "Support tickets that were encountered during execution of this particular protocol (parent or subprotocol as the case may be).",
				Category -> "Protocol Support",
				Developer -> True,
				AdminViewOnly -> True
			},
			SupportNotebook -> {
				Format -> Single,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Object[Notebook, Page],
				Description -> "The record of manual intervention steps performed during scientific support of this protocol.",
				Category -> "Protocol Support",
				Developer -> True,
				AdminViewOnly -> True
			},

			(* ===== *)

			ObjectReplacementLog -> {
				Format -> Multiple,
				Class -> {Expression, Expression, Expression, Link, Link, Link},
				Pattern:> {_?DateObjectQ, _Link, _Field, _Link, _Link, _Link},
				Relation -> {
					Null,
					Alternatives[Object[Qualification],Object[Protocol],Object[Maintenance], Object[Resource], Object[UnitOperation], Object[Program]],
					Null,
					Alternatives[
						Object[Container],Object[Sample],Object[Item],Object[Instrument],Object[Plumbing],Object[Wiring],Object[Part],Object[Sensor],
						Model[Container],Model[Sample],Model[Item],Model[Instrument],Model[Plumbing],Model[Wiring],Model[Part],Model[Sensor]
					],
					Alternatives[
						Object[Container],Object[Sample],Object[Item],Object[Instrument],Object[Plumbing],Object[Wiring],Object[Part],Object[Sensor],
						Model[Container],Model[Sample],Model[Item],Model[Instrument],Model[Plumbing],Model[Wiring],Model[Part],Model[Sensor]
					],
					Object[User]
				},
				Description -> "A list of labware replaced during the course of running this protocol.",
				Headers -> {"Date", "Object Updated", "Field Updated", "Original Labware", "New Labware", "UpdatedBy"},
				Developer -> True,
				Category->"Protocol Support"
			},
			CurrentOperator -> {
				Format -> Single,
				Class -> Link,
				Pattern :> _Link,
				(* If we are operating this as our main protocol (not in a interrupting snapback), we upload the backlink. *)
				(* Otherwise, we upload this without a backlink because we want to allow the user to operator more than one protocol and the same time. *)
				(* Also because we can't backlink to the PriorityProtocol field since that field is set by the scheduler to tell the user about the interrupt (before they start operating). *)
				Relation -> Object[User,Emerald][CurrentProtocol]|Object[User,Emerald],
				Description -> "The operator that is currently assigned to execute this protocol.",
				Category -> "General",
				Developer -> True
			},
			CurrentTablet -> {
				Format -> Single,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Object[Part,Computer],
				Description -> "The tablet computer on which the protocol is currently being executed in Engine.",
				Category -> "General",
				Developer -> True
			},
			ActiveCart -> {
				Format -> Single,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Object[Container],
				Description -> "The operator cart currently in use by the CurrentOperator for this protocol.",
				Category -> "General",
				Developer -> True
			},
			CartLog -> {
				Format -> Multiple,
				Class -> {Date, Link},
				Pattern :> {_?DateObjectQ, _Link},
				Relation -> {Null, Object[Container,OperatorCart]},
				Description -> "Log of the history of the operator carts used for this protocol.",
				Category -> "General",
				Headers -> {"Date","Cart"},
				Developer -> True
			},
			ActiveRacks -> {
				Format -> Multiple,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Alternatives[Object[Container, Rack],Model[Container, Rack]],
				Description -> "The racks that are currently located on the ActiveCart and into which containers can be placed immediately from resource picking.",
				Category -> "General",
				Developer -> True
			},
			HoldOrder -> {
				Format -> Single,
				Class -> Boolean,
				Pattern :> BooleanP,
				Description -> "Indicates if the queue position of this protocol should be strictly enforced, regardless of the available resources in the lab.",
				Category -> "General",
				Developer -> True
			},
			OptimizedPostProcessing -> {
				Format -> Single,
				Class -> Boolean,
				Pattern :> BooleanP,
				Description -> "Indicates if post-processing for this protocol is run in optimized batches outside of this protocol or if it is done in subprotocols within this protocol.",
				Category -> "General",
				Developer -> True
			},
			BatchedStorage -> {
				Format -> Single,
				Class -> Boolean,
				Pattern :> BooleanP,
				Description -> "Indicates if storage via StorageUpdate is available for this protocol. When True, items not requiring specialized storage conditions will be placed in a holding area during storage tasks.",
				Category -> "General",
				Developer -> True
			},
			(* -- PRIORITY FIELDS -- *)
			Priority -> {
				Format -> Single,
				Class -> Boolean,
				Pattern :> BooleanP,
				Description -> "Indicates if this protocol should be prioritized over other protocols in the queue to start at the given StartDate, have dedicated operation for its entirety, and not be interrupted by other protocols.",
				Category -> "General",
				Developer -> True
			},
			StartDate -> {
				Format -> Single,
				Class -> Date,
				Pattern :> _?DateObjectQ,
				Description -> "The date at which this protocol should be prioritized to start if Priority is set to True.",
				Category -> "General"
			},
			PriorityReturn -> {
				Format -> Single,
				Class -> Boolean,
				Pattern :> BooleanP,
				Description -> "Indicates if this protocol must interrupt a non-DangerZone protocol to be picked up at the indicated PickUpTime.",
				Category -> "General",
				Developer -> True
			},
			ScheduledOperator -> {
				Format -> Single,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Object[User, Emerald][PriorityProtocol],
				Description -> "The operator that is scheduled to be interrupted from their own protocol by this priority protocol.",
				Category -> "General",
				Developer -> True
			},
			ExplicitPriorityReturn -> {
				Format -> Single,
				Class -> Boolean,
				Pattern :> BooleanP,
				Description -> "Indicates if the priority return for this protocol was explicitly required by the developer. If the priority return was explicitly required, the DangerZoneCounter will be incremented when the protocol is returned to. If the priority return was not explicitly required, the DangerZoneCounter will not be incremented when returned to.",
				Category -> "General",
				Developer -> True
			},
			PickUpTime -> {
				Format -> Single,
				Class -> Date,
				Pattern :> _?DateObjectQ,
				Description -> "The date at which an operator should re-enter this protocol and pick it up from processing.",
				Category -> "General",
				Developer -> True
			},
			PriorityReturnEstimatedTime -> {
				Format -> Single,
				Class -> Real,
				Pattern :> TimeP,
				Units -> Hour,
				Description -> "The estimated time that the operator will spend in the DangerZone that follows the time critical interrupt.",
				Category -> "General",
				Developer -> True
			},
			PriorityReturnAlarm -> {
				Format -> Single,
				Class -> Real,
				Pattern :> TimeP,
				Units -> Hour,
				Description -> "The amount of time that is allowed to pass before an alarm is raised about a missed priority event.",
				Category -> "General",
				Developer -> True
			},
			PriorityReturnBuffer -> {
				Format -> Single,
				Class -> Real,
				Pattern :> TimeP,
				Units -> Hour,
				Description -> "The amount of time that an operator should be interrupted before the priority event.",
				Category -> "General",
				Developer -> True
			},
			ReturnToProtocol -> {
				Format -> Single,
				Class -> Boolean,
				Pattern :> BooleanP,
				Description -> "Indicates if operators should return to their original protocol if they have been interrupted to complete a time critical event for this protocol.",
				Category -> "General",
				Developer -> True
			},
			DangerZone -> {
				Format -> Single,
				Class -> Boolean,
				Pattern :> BooleanP,
				Description -> "Indicates if the current operator is forbidden from exiting until DangerZone is set to False. This field is set to True if DangerZoneCounter>0 and is set to False if DangerZoneCounter==0.",
				Category -> "General",
				Developer -> True
			},
			DangerZoneCounter -> {
				Format -> Single,
				Class -> Integer,
				Pattern :> _Integer,
				Description -> "The number of StartDangerZone tasks that this protocol has encountered. If this field is greater than zero, this protocol is currently in a DangerZone. This field is only tracked in the parent protocol object.",
				Category -> "General",
				Developer -> True
			},
			PriorityReturnLog -> {
				Format -> Multiple,
				Class -> {
					Date,
					Boolean,
					Link
				},
				Pattern :> {
					_?DateObjectQ,
					BooleanP,
					_Link
				},
				Relation -> {
					Null,
					Null,
					Object[User]
				},
				Headers -> {"Date","PriorityReturn","Responsible Party"},
				Description -> "The historical record of the PriorityReturn field.",
				Category -> "General",
				Developer -> True
			},
			PickUpTimeLog -> {
				Format -> Multiple,
				Class -> {
					Date,
					Date,
					Link
				},
				Pattern :> {
					_?DateObjectQ,
					_?DateObjectQ,
					_Link
				},
				Relation -> {
					Null,
					Null,
					Object[User]
				},
				Headers -> {"Date","PickUpTime","Responsible Party"},
				Description -> "The historical record of the PickUpTime field.",
				Category -> "General",
				Developer -> True
			},
			PriorityReturnEstimatedTimeLog -> {
				Format -> Multiple,
				Class -> {
					Date,
					Real,
					Link
				},
				Pattern :> {
					_?DateObjectQ,
					TimeP,
					_Link
				},
				Relation -> {
					Null,
					Null,
					Object[User]
				},
				Units :> {
					None,
					Hour,
					None
				},
				Headers -> {"Date","PriorityReturnEstimatedTime","Responsible Party"},
				Description -> "The historical record of the PriorityReturnEstimatedTime field.",
				Category -> "General",
				Developer -> True
			},
			PriorityReturnAlarmLog -> {
				Format -> Multiple,
				Class -> {
					Date,
					Real,
					Link
				},
				Pattern :> {
					_?DateObjectQ,
					TimeP,
					_Link
				},
				Relation -> {
					Null,
					Null,
					Object[User]
				},
				Units :> {
					None,
					Hour,
					None
				},
				Headers -> {"Date","PriorityReturnAlarm","Responsible Party"},
				Description -> "The historical record of the PriorityReturnAlarm field.",
				Category -> "General",
				Developer -> True
			},
			PriorityReturnBufferLog -> {
				Format -> Multiple,
				Class -> {
					Date,
					Real,
					Link
				},
				Pattern :> {
					_?DateObjectQ,
					TimeP,
					_Link
				},
				Relation -> {
					Null,
					Null,
					Object[User]
				},
				Units :> {
					None,
					Hour,
					None
				},
				Headers -> {"Date","PriorityReturnBuffer","Responsible Party"},
				Description -> "The historical record of the PriorityReturnBuffer field.",
				Category -> "General",
				Developer -> True
			},
			ReturnToProtocolLog -> {
				Format -> Multiple,
				Class -> {
					Date,
					Boolean,
					Link
				},
				Pattern :> {
					_?DateObjectQ,
					BooleanP,
					_Link
				},
				Relation -> {
					Null,
					Null,
					Object[User]
				},
				Headers -> {"Date","ReturnToProtocol","Responsible Party"},
				Description -> "The historical record of the ReturnToProtocol field.",
				Category -> "General",
				Developer -> True
			},
			Overclock -> {
				Format -> Single,
				Class -> Boolean,
				Pattern :> BooleanP,
				Description -> "Indicates if this protocol can be run or continued even if its author's team has exceeded its MaxNumberOfThreads (up to 2 * MaxNumberOfThreads).",
				Category -> "General",
				Developer -> True
			},
			HandsFreeOperation -> {
				Format -> Single,
				Class -> Boolean,
				Pattern :> BooleanP,
				Description -> "Indicates if this protocol is currently in a HandsFreeOperation procedure. This means the operator is controlling Engine through foot pedals and are currently working inside a biosafety cabinet.",
				Category -> "General",
				Developer -> True
			},
			HandsFreeOperationLog -> {
				Format -> Multiple,
				Class -> {
					Date,
					Expression,
					Link,
					Link
				},
				Pattern :> {
					_?DateObjectQ,
					BooleanP,
					_Link,
					_Link
				},
				Relation -> {
					Null,
					Null,
					Object[Instrument],
					Object[User]
				},
				Headers -> {"Date","Status","Instrument","Responsible Party"},
				Description -> "The historical record of a protocol entering and exiting HandsFreeOperation.",
				Category -> "General",
				Developer -> True
			},
			ResumeHandsFreeOperation -> {
				Format -> Single,
				Class -> Boolean,
				Pattern :> BooleanP,
				Description -> "Indicates if the operator of this protocol must re-enter a hands free operation to the most recently exited instrument in the HandsFreeOperationLog upon resuming from scientific support or processing.",
				Category -> "General",
				Developer -> True
			},
			Resources -> {
				Format -> Multiple,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Alternatives[
					Object[Sample][CurrentProtocol],
					Object[Container][CurrentProtocol],
					Object[Part][CurrentProtocol],
					Object[Plumbing][CurrentProtocol],
					Object[Item][CurrentProtocol],
					Object[Sensor][CurrentProtocol],
					Object[Wiring][CurrentProtocol]
				],
				Description -> "The items (e.g., samples, containers, parts, items) which are actively being used by this protocol.",
				Category -> "Resources",
				Developer -> True
			},
			RequiredResources -> {
				Format -> Multiple,
				Class -> {Link, Expression, Integer, Expression},
				Pattern :> {_Link, _Symbol, _Integer, _Integer|_Symbol},
				Relation -> {Object[Resource][Requestor], Null, Null, Null},
				Units -> {None, None, None, None},
				Description -> "Resources used by this protocol and a description of the field in which a resource's resolved object is stored. Position and index are Null when a resource's resolution is stored in a single field.",
				Category -> "General",
				Headers->{"Resource","Field Name","Field Position", "Field Index"},
				Developer -> True
			},
			SubprotocolRequiredResources -> {
				Format -> Multiple,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Object[Resource][RootProtocol],
				Description -> "The resource objects tied to this parent protocol, including all resources of the protocol itself and its subprotocols.",
				Category -> "Resources",
				Developer -> True
			},
			AwaitingResources -> {
				Format -> Single,
				Class -> Boolean,
				Pattern :> BooleanP,
				Description -> "Indicates if this protocol is awaiting the arrival of items before it can be begun or continued.",
				Category -> "Resources"
			},
			ShippingMaterials -> {
				Format -> Multiple,
				Class -> {Link, Link},
				Pattern :> {_Link, _Link},
				Relation -> {Alternatives[Object[Transaction, Order][DependentProtocols], Object[Transaction, ShipToECL][DependentProtocols], Object[Transaction, SiteToSite][DependentProtocols]], Alternatives[Object[Product], Object[Sample], Model[Sample], Model[Item], Object[Item]]},
				Description -> "Indicates the transactions, and the specific products or samples therein, that must be received before this protocol can be begun or continued.",
				Category -> "Resources",
				Headers -> {"Transaction", "Required Product"}
			},
			Checkpoints -> {
				Format -> Multiple,
				Class -> {String, Real, String, Link},
				Pattern :> {_String, GreaterEqualP[0*Second], _String, _Link},
				Units -> {None, Minute, None, None},
				Relation -> {Null, Null, Null, Model[User, Emerald]|Object[User, Emerald]},
				Description -> "A list of expected checkpoints and estimated time (including processing stages) for each checkpoint in the procedure of the protocol.",
				Category -> "Resources",
				Developer->True,
				Headers -> {"Name", "Duration", "Description", "Operator"}
			},
			HazardousWaste -> {
				Format -> Multiple,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Model[Sample] | Object[Sample],
				Description -> "The types of chemical or laboratory waste generated by this protocol.",
				Category -> "Resources"
			},
			DispenserContainers -> {
				Format -> Multiple,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Alternatives[
					Object[Container],
					Model[Container]
				],
				Description -> "Containers gathered as destinations for any resources obtained from a chemical dispenser.",
				Category -> "Resources"
			},
			GasSources -> {
				Format -> Multiple,
				Class-> {Expression, Link, Link},
				Pattern :> {GasP, _Link, _Link},
				Relation -> {
					Null,
					Object[Container],
					Object[Instrument]
				},
				Description -> "A list of containers that supply gas to instruments in this protocol through plumbing connections.",
				Headers -> {"Gas Type", "Source Container", "Supplied Instrument"},
				Category -> "Resources"
			},

			(* --- Waste Handling --- *)
			WasteWeightTare -> {
				Format -> Multiple,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Object[Data][Protocol],
				Description -> "The weight data of the waste carboy before the protocol is started.",
				Category -> "Sensor Information",
				Developer -> True,
				AdminWriteOnly->True
			},
			SecondaryWasteWeightTare -> {
				Format -> Multiple,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Object[Data][Protocol],
				Description -> "The weight data of the secondary waste carboy before the protocol is started.",
				Category -> "Sensor Information",
				Developer -> True,
				AdminWriteOnly->True
			},
			WasteWeight -> {
				Format -> Multiple,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Object[Data][Protocol],
				Description -> "The weight data of the waste carboy after the protocol is completed.",
				Category -> "Sensor Information",
				Developer -> True,
				AdminWriteOnly->True
			},
			SecondaryWasteWeight -> {
				Format -> Multiple,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Object[Data][Protocol],
				Description -> "The weight data of the secondary waste carboy after the protocol is completed.",
				Category -> "Sensor Information",
				Developer -> True,
				AdminWriteOnly->True
			},
			WasteGenerated -> {
				Format -> Multiple,
				Class -> {Waste -> Link, Weight -> Real},
				Pattern :> {Waste -> _Link, Weight -> GreaterEqualP[0*Gram]},
				Units -> {Waste -> None, Weight -> Gram},
				Relation -> {Waste -> Model[Sample], Weight -> None},
				Description -> "For each type of waste generated by this protocol, the total amount (in grams) generated during the course of the protocol.",
				Headers -> {Waste -> "Waste Type", Weight -> "Amount"},
				Category -> "Cleaning",
				AdminWriteOnly->True
			},

			(* --- Operator handling --- *)
			Operator -> {
				Format -> Single,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Object[User, Emerald] | Model[User, Emerald],
				Description -> "Indicates the operator allowed to run this protocol.  If not populated, then all operators are allowed.",
				Category -> "Operations Information",
				Developer -> True
			},
			RequiredCertifications->{
				Format->Multiple,
				Class->Link,
				Pattern:>_Link,
				Relation->Model[Certification],
				Description->"The list of skill sets needed for an operator to execute this protocol.",
				Category->"Operations Information",
				Developer -> True
			},
			Interruptible -> {
				Format -> Single,
				Class -> Boolean,
				Pattern :> BooleanP,
				Description -> "Indicates if this protocol can be interrupted and the current operator of this protocol can be assigned to another priority protocol.",
				Category -> "Operations Information",
				Developer -> True
			},
			ReadyCheckResult -> {
				Format -> Single,
				Class -> {
					ProtocolStatus -> Expression,
					Blocked -> Boolean,
					Blockers -> Expression,
					Suspended -> Boolean,
					Suspenders -> Expression,
					Checkpoint -> String,
					CheckpointProgress -> Expression,
					CheckpointEstimates -> Expression,
					CurrentOperator -> Expression,
					CurrentOperatorName -> String,
					InstrumentsAvailable->Boolean,
					Instruments->Expression,
					ItemsAvailable->Boolean,
					Items->Expression,
					SamplesAvailable->Boolean,
					Samples->Expression,
					ObjectsInUse->Expression,
					CurrentInstrument -> Expression,
					CurrentInstrumentName -> String,
					LastInstrument -> Expression,
					LastInstrumentName -> String,
					ActiveCart -> Expression,
					ActiveCartName -> String,
					LastCart -> Expression,
					LastCartName -> String,
					LastOperator -> Expression,
					LastOperatorName -> String,
					PickUpTime -> Date,
					DateEnqueued -> Date,
					Error -> Boolean,
					DangerZone -> Boolean,
					Priority -> Boolean,
					Resolved -> Expression,
					Unresolved -> Expression,
					CanaryBranch -> String,
					VerifiedSelectAgentFree -> Boolean
				},
				Pattern :> {
					ProtocolStatus -> ProtocolStatusP|OperationStatusP,
					Blocked -> BooleanP,
					Blockers -> {{ObjectP[{Object[SupportTicket,Operations],Object[SupportTicket,UserCommunication]}],_String|Null}...},
					Suspended -> BooleanP,
					Suspenders -> {{ObjectP[{Object[SupportTicket,Operations],Object[SupportTicket,UserCommunication]}],_String|Null}...},
					Checkpoint -> _String,
					CheckpointProgress -> {{_String, _?DateObjectQ, _?DateObjectQ | Null}...},
					CheckpointEstimates -> {{_String, GreaterEqualP[0*Second], _String}...},
					CurrentOperator -> ObjectP[],
					CurrentOperatorName -> _String,
					InstrumentsAvailable->BooleanP,
					Instruments->{_Association...},
					ItemsAvailable->BooleanP,
					Items->{_Association...},
					SamplesAvailable->BooleanP,
					Samples->{_Association...},
					ObjectsInUse->{ObjectP[]...},
					CurrentInstrument -> ObjectP[],
					CurrentInstrumentName -> _String,
					LastInstrument -> ObjectP[],
					LastInstrumentName -> _String,
					ActiveCart -> ObjectP[],
					ActiveCartName -> _String,
					LastCart -> ObjectP[],
					LastCartName -> _String,
					LastOperator -> ObjectP[],
					LastOperatorName -> _String,
					PickUpTime -> _?DateObjectQ,
					DateEnqueued -> _?DateObjectQ,
					Error -> BooleanP,
					DangerZone -> BooleanP,
					Priority -> BooleanP,
					Resolved -> {{ObjectP[{Object[SupportTicket,Operations],Object[SupportTicket,UserCommunication]}],_String|Null}...},
					Unresolved -> {{ObjectP[{Object[SupportTicket,Operations],Object[SupportTicket,UserCommunication]}],_String|Null}...},
					CanaryBranch -> _String | Null,
					VerifiedSelectAgentFree -> BooleanP
				},
				Units -> {
					ProtocolStatus -> None,
					Blocked -> None,
					Blockers -> None,
					Suspended -> None,
					Suspenders -> None,
					Checkpoint -> None,
					CheckpointProgress -> None,
					CheckpointEstimates -> None,
					CurrentOperator -> None,
					CurrentOperatorName -> None,
					InstrumentsAvailable->None,
					Instruments->None,
					ItemsAvailable->None,
					Items->None,
					SamplesAvailable->None,
					Samples->None,
					ObjectsInUse->None,
					CurrentInstrument -> None,
					CurrentInstrumentName -> None,
					LastInstrument -> None,
					LastInstrumentName -> None,
					ActiveCart -> None,
					ActiveCartName -> None,
					LastCart -> None,
					LastCartName -> None,
					LastOperator -> None,
					LastOperatorName -> None,
					PickUpTime -> None,
					DateEnqueued -> None,
					Error -> None,
					DangerZone -> None,
					Priority -> None,
					Resolved -> None,
					Unresolved -> None,
					CanaryBranch -> None,
					VerifiedSelectAgentFree -> None
				},
				Headers -> {
					ProtocolStatus -> "The current OperationStatus/ProtocolStatus for the given protocol.",
					Blocked -> "Indicates if the protocol object is currently blocked by an unresolved support ticket.",
					Blockers -> "Any tickets that are currently blocking the protocol.",
					Suspended -> "Indicates if the protocol type is currently suspended by a support ticket.",
					Suspenders -> "Any tickets that are currently suspending the protocol type.",
					Checkpoint -> "The current checkpoint for the given protocol.",
					CheckpointProgress -> "The current state of checkpoints for the given protocol.",
					CheckpointEstimates -> "The estimated checkpoints for the given protocol.",
					CurrentOperator -> "The operator currently executing the protocol (or Null if no-one).",
					CurrentOperatorName -> "The name of the operator currently executing the protocol (or Null if no-one).",
					InstrumentsAvailable -> "Indicates if all required instruments are available.",
					Instruments->"Stores a list of associations describing the availability of each required instrument.",
					ItemsAvailable->"Indicates if all required items/parts are available.",
					Items->"Stores a list of associations describing the availability of each required item/part.",
					SamplesAvailable->"Indicates if all required samples are available.",
					Samples->"Stores a list of associations describing the availability of each required sample.",
					ObjectsInUse->"Stores a list of the objects that are currently being used by this protocol.",
					CurrentInstrument -> "The instrument whose status is set to InUse by the protocol.",
					CurrentInstrumentName -> "The name of the CurrentInstrument.",
					LastInstrument -> "The instrument whose status was last set to InUse by the protocol.",
					LastInstrumentName -> "The name of the LastInstrument.",
					ActiveCart -> "The cart on which the protocol's procedure is running.",
					ActiveCartName -> "The name of the ActiveCart.",
					LastCart -> "The cart on which the protocol's procedure was previously running.",
					LastCartName -> "The name of the LastCart.",
					LastOperator -> "The operator previously executing the protocol (or Null if no-one).",
					LastOperatorName -> "The name of the LastOperator.",
					PickUpTime -> "The next date at which the protocol should be picked up from processing.",
					DateEnqueued -> "The date the protocol was Enqueued.",
					Error -> "Indicates if an error occurred while fetching information.",
					DangerZone -> "Indicates if the given protocol currently requires continuous operation.",
					Priority -> "Indicates if the given protocol can be interrupted by other protocols.",
					Resolved -> "Any tickets about the protocol that are resolved.",
					Unresolved -> "Any tickets about the protocol that are unresolved, but not blocking or suspending the protocol.",
					CanaryBranch -> "The user-defined Canary branch on which the given protocol is meant to be run.",
					VerifiedSelectAgentFree -> "Indicates that the strands in this protocol have been verified to not contain any harmful sequences as defined by the Select Agents and Toxins List issued by the Food & Drug Administration (FDA)."
				},
				Description -> "Cached information describing the current state of this protocol and its resource availability.",
				Category -> "Operations Information",
				Developer -> True
			},
			ReadyCheckDateLastUpdated -> {
				Format -> Single,
				Class -> Date,
				Pattern :> _?DateObjectQ,
				Description -> "Indicates if the ReadyCheckResult is out of date and is currently being recomputed in the lab. If this field is Null and ReadyCheckResult is populated, ReadyCheckResult is up to date.",
				Category -> "Operations Information",
				Developer->True
			},
			ReadyCheckLog -> {
				Format -> Multiple,
				Class -> {Date, Boolean, Expression},
				Pattern :> ReadyCheckLogP,
				Description -> "The historical record of the ReadyCheck field.",
				Category -> "Operations Information",
				Headers -> {"Date","ReadyCheck Result","State of Resources"},
				Developer -> True
			},
			(* --- Storage pricing --- *)
			StoragePrice -> {
				Format -> Single,
				Class -> Real,
				Pattern :> GreaterEqualP[0*USD/Month],
				Units -> USD/Month,
				Description -> "The total monthly price for warehousing all user owned items associated with this protocol in an ECL facility under the storage conditions specified by each item.",
				Category -> "Storage Information"
			},
			StoragePrices -> {
				Format -> Multiple,
				Class -> Real,
				Pattern :> UnitsP[0*USD/Month],
				Units -> USD/Month,
				Description -> "The running tally of the total monthly price for warehousing all user owned items associated with this protocol in an ECL facility under the storage conditions specified by each item.  To find the current price, sum all values of this field.",
				Category -> "Storage Information",
				Developer -> True
			},
			StoredObjects -> {
				Format -> Multiple,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Alternatives[
					Object[Sample],
					Object[Container],
					Object[Part],
					Object[Plumbing],
					Object[Item],
					Object[Wiring]
				],
				Description -> "List of all physical items associated with this protocol that are currently being warehoused in an ECL facility.",
				Category -> "Storage Information",
				Developer->True
			},
			DateLastUsed -> {
				Format -> Single,
				Class -> Date,
				Pattern :> _?DateObjectQ,
				Description -> "Date any physical items associated with this protocol were last handled in the lab.",
				Category -> "Storage Information",
				Developer->True
			},
			PurchasedItems -> {
				Format -> Multiple,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Alternatives[
					Object[Sample][Source],
					Object[Container][Source],
					Object[Part][Source],
					Object[Plumbing][Source],
					Object[Item][Source],
					Object[Sensor][Source],
					Object[Wiring][Source]
				],
				Description -> "List of any items that were purchased on behalf of the user in the course of running this protocol.",
				Category -> "Pricing Information",
				Developer->True
			},
			SamplesOutPrices -> {
				Format -> Multiple,
				Class -> Real,
				Pattern :> UnitsP[0*USD/Month],
				Units -> USD/Month,
				Description -> "The running tally of the total monthly price for warehousing all samples generated by this protocol in an ECL facility under the storage conditions specified by each item.  To find the current price, sum all values of this field.",
				Category -> "Storage Information",
				Developer -> True
			},
			AliquotSamplesPrices -> {
				Format -> Multiple,
				Class -> Real,
				Pattern :> UnitsP[0*USD/Month],
				Units -> USD/Month,
				Description -> "The running tally of the total monthly price for warehousing all aliquot samples associated with this protocol in an ECL facility under the storage conditions specified by each item.  To find the current price, sum all values of this field.",
				Category -> "Storage Information",
				Developer -> True
			},
			PurchasedItemsPrices -> {
				Format -> Multiple,
				Class -> Real,
				Pattern :> UnitsP[0*USD/Month],
				Units -> USD/Month,
				Description -> "The running tally of the total monthly price for warehousing all items purchased in the course of running this protocol in an ECL facility under the storage conditions specified by each item.  To find the current price, sum all values of this field.",
				Category -> "Storage Information",
				Developer -> True
			},

			(* --- Sample Storage --- *)
			SamplesInStorage -> {
				Format -> Multiple,
				Class -> Expression,
				Pattern :> SampleStorageTypeP|Disposal,
				IndexMatching -> SamplesIn,
				Description -> "For each member of SamplesIn, the storage conditions under which any input samples to this experiment should be stored after their usage in this experiment.",
				Category -> "Sample Storage"
			},
			AliquotStorage -> {
				Format -> Multiple,
				Class -> Expression,
				Pattern :> SampleStorageTypeP|Disposal,
				IndexMatching->AliquotSamples,
				Description -> "For each member of AliquotSamples, the storage conditions under which any aliquot samples generated by this experiment should be stored after the protocol is completed.",
				Category -> "Sample Storage"
			},
			SamplesOutStorage -> {
				Format -> Multiple,
				Class -> Expression,
				Pattern :> SampleStorageTypeP|Disposal,
				IndexMatching->SamplesOut,
				Description -> "For each member of SamplesOut, the storage conditions under which any output samples generated by this experiment should be stored after the protocol is completed.",
				Category -> "Sample Storage"
			},

			(* --- Option Handling --- *)
			ResolvedOptions -> {
				Format -> Single,
				Class -> Compressed,
				Pattern :> {_Rule...},
				Units -> None,
				Description -> "The final options used as parameters for this protocol, after automatic options are resolved.",
				Category -> "Option Handling"
			},
			UnresolvedOptions -> {
				Format -> Single,
				Class -> Compressed,
				Pattern :> {_Rule...},
				Units -> None,
				Description -> "The verbatim options originally input by the protocol author to generate this protocol, often with some options set to Automatic.",
				Category -> "Option Handling"
			},

			(* --- Migration Support --- *)
			LegacyID -> {
				Format -> Single,
				Class -> String,
				Pattern :> _String,
				Description -> "The SLL2 ID for this Object, if it was migrated from the old data store.",
				Category -> "Migration Support",
				Developer -> True
			},
			FilteredSamples -> {
				Format -> Multiple,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Object[Sample],
				Description -> "Samples corresponding to filtered eluents of SamplesIn generated during sample preparation and intended for use in this experiment.",
				Category -> "Sample Preparation"
			},
			Centrifuge -> {
				Format -> Single,
				Class -> Expression,
				Pattern :> BooleanP,
				Description -> "Indicates if the SamplesIn will be centrifuged prior to performing the experiment.",
				Category -> "Sample Preparation",
				Developer -> True
			},
			(* --- Aliquoting --- *)
			Aliquot -> {
				Format -> Single,
				Class -> Expression,
				Pattern :> BooleanP,
				Description -> "Indicates if aliquots are taken from the SamplesIn and transferred into new AliquotSamples which are prepared and used in lieu of the SamplesIn for the experiment.",
				Category -> "Aliquoting",
				Developer -> True
			},
			AliquotSamples -> {
				Format -> Multiple,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Object[Sample],
				Description -> "Samples corresponding to aliquots of SamplesIn generated during sample preparation and intended for use in this experiment.",
				Category -> "Aliquoting"
			},
			AliquotContainers -> {
				Format -> Multiple,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Alternatives[
					Object[Container],
					Model[Container]
				],
				Description -> "Containers that hold AliquotSamples generated during sample preparation and intended for use in this experiment.",
				Category -> "Aliquoting"
			},
			SaveAliquots -> {
				Format -> Single,
				Class -> Expression,
				Pattern :> BooleanP,
				Description -> "Indicates if the AliquotSamples should be stored after the experiment, rather than being discarded.",
				Category -> "Aliquoting"
			},
			ConsolidateAliquots -> {
				Format -> Single,
				Class -> Expression,
				Pattern :> BooleanP,
				Description -> "Indicates if identical aliquots should be consolidated in a single sample.",
				Category -> "Aliquoting"
			},
			AliquotPreparation -> {
				Format -> Single,
				Class -> Expression,
				Pattern :> PreparationMethodP,
				Description -> "Indicates if the aliquotting should occur manually or on a robotic liquid handler.",
				Category -> "Aliquoting"
			},
			(*MinimizeTransfers -> {
				Format -> Single,
				Class -> Expression,
				Pattern :> BooleanP,
				Description -> "Indicates if samples should be consolidated into an input container when possible if samples are requested to go to the same aliquot container and the whole sample is being transferred.",
				Category -> "Aliquoting"
			},*)
			AliquotVolumes -> {
				Format -> Multiple,
				Class -> Real,
				Pattern :> GreaterP[0*Micro*Liter],
				Units -> Liter Micro,
				Description -> "For each member of SamplesIn, the volume transferred from the sample into the aliquot sample which is used in lieu of the initial sample for the experiment.",
				Category -> "Aliquoting",
				IndexMatching->SamplesIn
			},
			AliquotMasses -> {
				Format -> Multiple,
				Class -> Real,
				Pattern :> GreaterP[0*Milligram],
				Units -> Milligram,
				Description -> "For each member of SamplesIn, the mass of a solid transferred from the sample into the aliquot sample which is used in lieu of the initial sample for the experiment.",
				Category -> "Aliquoting",
				IndexMatching->SamplesIn
			},
			AliquotAmounts -> {
				Format -> Multiple,
				Class -> VariableUnit,
				Pattern :> GreaterP[0*Milliliter] | GreaterP[0*Milligram] | GreaterP[0*Unit, 1*Unit],
				Units -> None,
				Description -> "For each member of SamplesIn, the amount transferred from the sample into the aliquot sample which is used in lieu of the initial sample for the experiment.",
				Category -> "Aliquoting",
				IndexMatching->SamplesIn
			},
			TargetConcentrations -> {
				Format -> Multiple,
				Class -> Expression,
				Pattern :> GreaterP[0*Micro*Molar] | GreaterP[0 (Milligram/Milliliter)],
				Description -> "For each member of SamplesIn, the final concentration of analyte in the aliquot sample which is used in lieu of the initial sample for the experiment.",
				Category -> "Aliquoting",
				IndexMatching->SamplesIn
			},
			AssayVolumes -> {
				Format -> Multiple,
				Class -> Real,
				Pattern :> GreaterEqualP[0*Micro*Liter],
				Units -> Liter Micro,
				Description -> "For each member of SamplesIn (or PooledSamplesIn), the total volume of the reaction mixture which is used in lieu of the initial sample for the experiment.",
				Category -> "Aliquoting"
			},
			AssayBuffers -> {
				Format -> Multiple,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Alternatives[
					Object[Sample],
					Model[Sample]
				],
				Description -> "For each member of SamplesIn (or PooledSamplesIn), the final buffers used to generate AliquotSamples by aliquoting SamplesIn.",
				Category -> "Aliquoting"
			},
			ConcentratedBuffers -> {
				Format -> Multiple,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Alternatives[
					Object[Sample],
					Model[Sample]
				],
				Description -> "For each member of SamplesIn (or PooledSamplesIn), the concentrated buffer source which is added to the AliquotSamples to obtain 1x buffer concentration after dilution of the AliquotSamples which are used in lieu of the SamplesIn for the experiment.",
				Category -> "Aliquoting"
			},
			BufferDilutionFactors -> {
				Format -> Multiple,
				Class -> Real,
				Pattern :> GreaterP[0],
				Units -> None,
				Description -> "For each member of SamplesIn (or PooledSamplesIn), he dilution factor by which the concentrated buffer is diluted in preparing the AliquotSamples to obtain a 1x buffer concentration after dilution of the AliquotSamples which are used in lieu of the SamplesIn for the experiment.",
				Category -> "Aliquoting"
			},
			BufferDiluents -> {
				Format -> Multiple,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Alternatives[
					Object[Sample],
					Model[Sample]
				],
				Description -> "For each member of SamplesIn (or PooledSamplesIn), the diluent used to dilute the concentration of the concentrated buffer in preparing the AliquotSamples which are used in lieu of the SamplesIn for the experiment.",
				Category -> "Aliquoting"
			},
			ConcentratedBuffer -> {
				Format -> Single,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Alternatives[
					Object[Sample],
					Model[Sample]
				],
				Description -> "The concentrated buffer source which is added to each of the AliquotSamples to obtain 1x buffer concentration after dilution of the AliquotSamples which are used in lieu of the SamplesIn for the experiment.",
				Category -> "Aliquoting"
			},
			BufferDilutionFactor -> {
				Format -> Single,
				Class -> Integer,
				Pattern :> GreaterP[0],
				Units -> None,
				Description -> "The dilution factor by which the concentrated buffer is diluted in preparing the AliquotSamples to obtain a 1x buffer concentration after dilution of the AliquotSamples which are used in lieu of the SamplesIn for the experiment.",
				Category -> "Aliquoting"
			},
			BufferDiluent -> {
				Format -> Single,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Alternatives[
					Object[Sample],
					Model[Sample]
				],
				Description -> "The diluent used to dilute the concentration of the concentrated buffer in preparing the AliquotSamples which are used in lieu of the SamplesIn for the experiment.",
				Category -> "Aliquoting"
			},
			AssayBuffer -> {
				Format -> Single,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Alternatives[
					Object[Sample],
					Model[Sample]
				],
				Description -> "The desired buffer for the AliquotSamples which are used in lieu of the SamplesIn for the experiment.",
				Category -> "Aliquoting"
			},
			MeasureVolume -> {
				Format -> Single,
				Class -> Expression,
				Pattern :> BooleanP,
				Description -> "Indicates if the volume of the liquid samples modified in the course of the experiment are measured after running the experiment.",
				Category -> "Sample Post-Processing"
			},
			MeasureWeight -> {
				Format -> Single,
				Class -> Expression,
				Pattern :> BooleanP,
				Description -> "Indicates if the weight of the solid samples modified in the course of the experiment are measured after running the experiment.",
				Category -> "Sample Post-Processing"
			},
			Measure -> {
				Format -> Single,
				Class -> Expression,
				Pattern :> BooleanP,
				Description -> "Indicates if the volume/weight of the samples modified in the course of the experiment are measured after running the experiment.",
				Category -> "Sample Post-Processing"
			},
			Storage -> {
				Format -> Single,
				Class -> Expression,
				Pattern :> SampleStorageTypeP|Disposal,
				Description -> "Indicates the conditions under which any samples generated by this experiment are stored after the protocol is completed.",
				Category -> "Sample Post-Processing"
			},
			Branch -> {
				Format -> Single,
				Class -> String,
				Pattern :> _String,
				Description -> "The git branch that this protocol should be run on.",
				Category -> "General"
			},

			ParallelComputations -> {
				Format -> Multiple,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Alternatives[
					Object[Notebook, Job],
					Object[Software, ManifoldKernelCommand]
				],
				Description -> "List of computational jobs generated and run in parallel to the execution of this protocol.",
				Category -> "Computations",
				Developer -> True
			},
			ComputationsOutstanding -> {
				Format -> Single,
				Class -> Boolean,
				Pattern :> BooleanP,
				Description -> "Indicates if any of the computation jobs in ParallelComputations have not yet completed.",
				Category -> "Computations",
				Developer -> True
			},
			ErroneousComputations -> {
				Format -> Multiple,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Alternatives[
					Object[Notebook, Job],
					Object[Software, ManifoldKernelCommand]
				],
				Description -> "List of computational jobs generated and run in parallel to the execution of this protocol in which a warning or error was thown, or that did not finish.",
				Category -> "Computations",
				Developer -> True
			},
			ReadyCheckComputations -> {
				Format -> Multiple,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Object[Notebook, Job],
				Description -> "The list of manifold job notebooks that was used to evaluate ReadyCheck for this protocol.",
				Category -> "Computations",
				Developer -> True
			},
			Streams -> {
				Format -> Multiple,
				Class -> Link,
				Pattern :> _Link,
				Relation -> Object[Stream][Protocol],
				Description -> "The list of video streams associated with this protocol.",
				Category -> "General"
			},
			StreamErrors -> {
				Format -> Multiple,
				Class -> String,
				Pattern :> _String,
				Description -> "The error operator encountered when trying to start stream for the protocol.",
				Category -> "General",
				Developer -> True
			},
			Movements -> {
				Format -> Multiple,
				Class -> {Link, Link, String, String, Integer, Integer},
				Pattern :> {
					_Link,
					_Link,
					LocationPositionP,
					_String,
					GreaterP[0, 1],
					GreaterP[0, 1]
				},
				Relation -> {
					Alternatives[
						Object[Sample],
						Object[Container],
						Object[Part],
						Object[Item],
						Object[Instrument],
						Object[Plumbing],
						Object[Wiring],
						Object[Sensor]
					],
					Alternatives[
						Object[Sample],
						Object[Container],
						Object[Part],
						Object[Item],
						Object[Instrument],
						Object[Plumbing],
						Object[Wiring],
						Object[Sensor]
					],
					Null,
					Null,
					Null,
					Null
				},
				Headers -> {"Source", "Destination Object", "Destination Position", "TaskID", "Iteration", "TotalIterations"},
				Description -> "Lists all movements from a non-aseptic source into a non-aspetic destination that the indicated task is currently performing.  This field is only populated during the process of any sort of movement task, and is emptied once it is complete.",
				Developer -> True,
				Category -> "Placements"
			},
			AsepticToNonAsepticMovements -> {
				Format -> Multiple,
				Class -> {Link, Link, String, String, Integer, Integer},
				Pattern :> {
					_Link,
					_Link,
					LocationPositionP,
					_String,
					GreaterP[0, 1],
					GreaterP[0, 1]
				},
				Relation -> {
					Alternatives[
						Object[Sample],
						Object[Container],
						Object[Part],
						Object[Item],
						Object[Instrument],
						Object[Plumbing],
						Object[Wiring],
						Object[Sensor]
					],
					Alternatives[
						Object[Sample],
						Object[Container],
						Object[Part],
						Object[Item],
						Object[Instrument],
						Object[Plumbing],
						Object[Wiring],
						Object[Sensor]
					],
					Null,
					Null,
					Null,
					Null
				},
				Headers -> {"Source", "Destination Object", "Destination Position", "TaskID", "Iteration", "TotalIterations"},
				Description -> "Lists all movements from an aseptic source into a non-aspetic destination that the indicated task is currently performing.  This field is only populated during the process of any sort of movement task, and is emptied once it is complete.",
				Developer -> True,
				Category -> "Placements"
			},
			NonAsepticToAsepticMovements -> {
				Format -> Multiple,
				Class -> {Link, Link, String, String, Integer, Integer},
				Pattern :> {
					_Link,
					_Link,
					LocationPositionP,
					_String,
					GreaterP[0, 1],
					GreaterP[0, 1]
				},
				Relation -> {
					Alternatives[
						Object[Sample],
						Object[Container],
						Object[Part],
						Object[Item],
						Object[Instrument],
						Object[Plumbing],
						Object[Wiring],
						Object[Sensor]
					],
					Alternatives[
						Object[Sample],
						Object[Container],
						Object[Part],
						Object[Item],
						Object[Instrument],
						Object[Plumbing],
						Object[Wiring],
						Object[Sensor]
					],
					Null,
					Null,
					Null,
					Null
				},
				Headers -> {"Source", "Destination Object", "Destination Position", "TaskID", "Iteration", "TotalIterations"},
				Description -> "Lists all movements from a non-aseptic source into an aspetic destination that the indicated task is currently performing.  This field is only populated during the process of any sort of movement task, and is emptied once it is complete.",
				Developer -> True,
				Category -> "Placements"
			},
			AsepticToAsepticMovements -> {
				Format -> Multiple,
				Class -> {Link, Link, String, String, Integer, Integer},
				Pattern :> {
					_Link,
					_Link,
					LocationPositionP,
					_String,
					GreaterP[0, 1],
					GreaterP[0, 1]
				},
				Relation -> {
					Alternatives[
						Object[Sample],
						Object[Container],
						Object[Part],
						Object[Item],
						Object[Instrument],
						Object[Plumbing],
						Object[Wiring],
						Object[Sensor]
					],
					Alternatives[
						Object[Sample],
						Object[Container],
						Object[Part],
						Object[Item],
						Object[Instrument],
						Object[Plumbing],
						Object[Wiring],
						Object[Sensor]
					],
					Null,
					Null,
					Null,
					Null
				},
				Headers -> {"Source", "Destination Object", "Destination Position", "TaskID", "Iteration", "TotalIterations"},
				Description -> "Lists all movements from an aseptic source into an aspetic destination that the indicated task is currently performing.  This field is only populated during the process of any sort of movement task, and is emptied once it is complete.",
				Developer -> True,
				Category -> "Placements"
			},
			DoubleGloveRequired -> {
				Format -> Single,
				Class -> Expression,
				Pattern :> BooleanP,
				Description -> "Indicates that when entering this protocol, the operator has to put on two pairs of gloves.",
				Category -> "Health & Safety",
				Developer -> True
			},
			GloveChangeLog -> {
				Format -> Multiple,
				Class -> {Date, Link, Link},
				Pattern :> {_?DateObjectQ, _Link, _Link},
				Relation -> {None, Object[Item, Consumable], Object[User]},
				Description -> "The history of glove replacements during this protocol in the form: {Date, Glove Box, Operator}. This field records when gloves were replaced, which gloves  were used, and who performed the replacement.",
				Headers -> {"Date", "Glove Box", "Operator"},
				Category -> "Health & Safety",
				Developer -> True
			},
			ErrorRecoveryLog -> {
				Format -> Multiple,
				Class -> {
					Date -> Date,
					Procedure -> String,
					TaskID -> String,
					Subprotocol -> Link,
					ResponsibleOperator -> Link
				},
				Pattern :> {
					Date -> _?DateObjectQ,
					Procedure -> _String,
					TaskID -> _String,
					Subprotocol -> _Link,
					ResponsibleOperator -> _Link
				},
				Relation -> {
					Date -> Null,
					Procedure -> Null,
					TaskID -> Null,
					Subprotocol -> Alternatives[Object[Protocol], Object[Maintenance], Object[Qualification]],
					ResponsibleOperator -> Object[User, Emerald][ErrorRecoveryEvents, RootProtocol]
				},
				Description -> "The error recovery procedures triggered during execution of this protocol.",
				Category -> "Organizational Information"
			},
			insertMe
		}
	}]
];
