(* ::Package:: *)

(* ::Text:: *)
(*\[Copyright] 2011-2023 Emerald Cloud Lab, Inc.*)


DefineObjectType[Object[Protocol], {
	Description->"A detailed set of parameters describing the execution of an experiment on the ECL.",
	CreatePrivileges->None,
	Cache->Session,
	Fields -> {
		DateConfirmed -> {
			Format -> Single,
			Class -> Date,
			Pattern :> _?DateObjectQ,
			Description -> "The date on which the protocol first entered processing or a backlog.",
			Category -> "General",
			Abstract -> True
		},
		DateEnqueued -> {
			Format -> Single,
			Class -> Date,
			Pattern :> _?DateObjectQ,
			Description -> "The date on which the protocol was accepted and added to the queue.",
			Category -> "General",
			Abstract -> True
		},
		DateStarted -> {
			Format -> Single,
			Class -> Date,
			Pattern :> _?DateObjectQ,
			Description -> "The date on which the protocol moved from the front of the queue to begin running in the lab.",
			Category -> "General"
		},
		DateCompleted -> {
			Format -> Single,
			Class -> Date,
			Pattern :> _?DateObjectQ,
			Description -> "The date on which the last step of this protocol's execution was finished.",
			Category -> "General",
			Abstract -> True
		},
		DateCanceled -> {
			Format -> Single,
			Class -> Date,
			Pattern :> _?DateObjectQ,
			Description -> "The date on which the protocol was canceled and removed from the queue.",
			Category -> "General"
		},
		Author -> {
			Format -> Single,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Object[User][ProtocolsAuthored],
			Description -> "The investigator who created this protocol.",
			Category -> "Organizational Information"
		},
		Script -> {
			Format -> Single,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Object[Notebook][Protocols],
			Description -> "The script that created this protocol.",
			Category -> "General",
			Abstract -> True
		},
		SubprotocolScripts -> {
			Format -> Multiple,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Object[Notebook, Script][ParentProtocol],
			Description -> "All scripts generated by this protocol as a list of subprotocols.",
			Category -> "General"
		},
		DeveloperObject -> {
			Format -> Single,
			Class -> Expression,
			Pattern :> BooleanP,
			Description -> "Indicates that this object is being used for test purposes only and is not supported by standard SLL features.",
			Category -> "General",
			Developer -> True,
			AdminWriteOnly->True
		},
		CanaryBranch -> {
			Format -> Single,
			Class -> String,
			Pattern :> _String,
			Description -> "The user-defined Canary branch on which the given protocol is meant to be run.",
			Category -> "General",
			Developer -> True,
			AdminWriteOnly->True
		},
		Distro-> {
			Format -> Single,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Object[Software,Distro],
			Description -> "The pre-built set of packages for a specific commit of SLL used to generate this protocol.",
			Category -> "General",
			Developer -> True
		},
		Commit -> {
			Format -> Single,
			Class -> String,
			Pattern :> _String,
			Description -> "The git SHA1 hash for the commit to load this protocol for specific distro with Engine.",
			Category -> "General",
			Developer -> True
		},
		Site -> {
			Format -> Single,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Object[Container,Site],
			Description -> "The ECL site at which this protocol was executed.",
			Category -> "General",
			Abstract -> True
		},
		SamplesIn -> {
			Format -> Multiple,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Alternatives[
				Object[Sample][Protocols],
				Model[Sample][Protocols],
				Model[Item][Protocols],
				Object[Item][Protocols]
			],
			Description -> "Input samples for this analytical or preparative experiment.",
			Category -> "General"
		},
		ContainersIn -> {
			Format -> Multiple,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Alternatives[
				Object[Container][Protocols],
				Model[Container]
			],
			Description -> "Any containers containing this protocols' SamplesIn.",
			Category -> "General"
		},
		NumberOfReplicates -> {
			Format -> Single,
			Class -> Integer,
			Pattern :> GreaterP[0, 1],
			Units -> None,
			Description -> "Indicates the number of times the experiment is repeated with identical parameters.",
			Category -> "General"
		},
		Status -> {
			Format -> Single,
			Class -> Expression,
			Pattern :> ProtocolStatusP,
			Description -> "The current status of the protocol.",
			Category -> "General",
			Abstract -> True
		},
		OperationStatus -> {
			Format -> Single,
			Class -> Expression,
			Pattern :> OperationStatusP,
			Description -> "A detailed status relevant during execution of the protocol that describes whether the protocol is actively being set up by an operator (OperatorProcessing), currently running on an instrument (InstrumentProcessing), or awaiting for further operator action (OperatorReady).",
			Category -> "General",
			Developer -> True
		},
		StatusLog -> {
			Format -> Multiple,
			Class -> {Expression, Expression, Link},
			Pattern :> {_?DateObjectQ, ProtocolStatusP | OperationStatusP, _Link},
			Relation -> {Null, Null, Object[User] | Object[Protocol] | Object[Qualification] | Object[Maintenance]},
			Description -> "Log of the status changes for this protocol.",
			Category -> "General",
			Headers -> {"Date","Status","Responsible Party"},
			Developer -> True
		},
		CheckpointProgress -> {
			Format -> Multiple,
			Class -> {String, Date, Date},
			Pattern :> {_String, _?DateObjectQ, _?DateObjectQ | Null},
			Units -> {None, None, None},
			Description -> "A listing of all the checkpoints passed in the execution of this protocol.",
			Category -> "General",
			Headers -> {"Name","Start Time","End Time"}
		},
		ProcedureLog -> {
			Format -> Multiple,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Object[Program][Protocol],
			Description -> "Log events tracking the progress of the current protocol.",
			Category -> "General",
			Developer -> True
		},
		RemainingTasks -> {
			Format -> Multiple,
			Class -> Expression,
			Pattern :> RosettaTaskP[],
			Description -> "A cached list of outstanding Rosetta tasks saved at the last procedure exit of this protocol. If Null, outstanding tasks will be determined from the protocol's ProcedureLog events when the procedure is next opened.",
			Category -> "General",
			Developer -> True
		},
		CompletedTasks -> {
			Format -> Multiple,
			Class -> {Date,Date,Link,Expression,Expression},
			Pattern :> {_?DateObjectQ,_?DateObjectQ,_Link,_String|Null,_String|Null},
			Relation -> {None, None, Object[User], None, None},
			Description -> "A cached list of completed Engine tasks saved at the last procedure exit of this protocol. If Null, completed tasks will be determined from the protocol's ProcedureLog events when the procedure is next opened.",
			Category -> "General",
			Units -> {None,None,None,None,None},
			Headers -> {"Date Started","Date Completed","Operator", "Task ID","Task HTML"},
			Developer -> True
		},
		ParentProtocol -> {
			Format -> Single,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Alternatives[
				Object[Protocol][Subprotocols],
				Object[Qualification][Subprotocols],
				Object[Maintenance][Subprotocols],
				Object[Protocol][IndexedSubprotocols,1],
				Object[Qualification][IndexedSubprotocols,1],
				Object[Maintenance][IndexedSubprotocols,1]
			],
			Description -> "The protocol that generated this sub-protocol during its execution.",
			Category -> "General",
			Developer -> True
		},
		Subprotocols -> {
			Format -> Multiple,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Alternatives[
				Object[Protocol][ParentProtocol],
				Object[Qualification][ParentProtocol],
				Object[Maintenance][ParentProtocol]
			],
			Description -> "Any specific-purpose protocols that were generated by this protocol during its execution.",
			Category -> "General",
			Developer -> True
		},
		IndexedSubprotocols -> {
			Format -> Multiple,
			Class -> {Link,String},
			Pattern :> {_Link,_String},
			Relation -> {
				Alternatives[
					Object[Protocol][ParentProtocol],
					Object[Qualification][ParentProtocol],
					Object[Maintenance][ParentProtocol]
				],
				Null
			},
			Description -> "Any specific-purpose protocols that were generated by this protocol during its execution.",
			Category -> "General",
			Headers -> {"Subprotocol","Purpose of the protocol"},
			Developer -> True
		},
		SubprotocolDescription -> {
			Format -> Single,
			Class -> String,
			Pattern :> _String,
			Description -> "A short title indicating what this subprotocol accomplishes.",
			Category -> "General",
			Abstract -> True
		},
		BatchedUnitOperations -> {
			Format -> Multiple,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Object[UnitOperation][Protocol],
			Description -> "The individual batches of the protocol, as they will be executed in the lab.",
			Category -> "General"
		},
		ReplacementProtocol -> {
			Format -> Single,
			Class -> Link,
			Pattern :> _Link,
			Relation ->  Alternatives[
				Object[Protocol],
				Object[Qualification],
				Object[Maintenance]
			],
			Description -> "If this protocol was aborted due to technical reasons, links to the replacement protocol run in its place.",
			Category -> "General"
		},
		CurrentInstruments -> {
			Format -> Multiple,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Object[Instrument][CurrentProtocol],
			Description -> "Any instruments which are actively being used by this protocol.",
			Category -> "General",
			Developer -> True
		},
		InstrumentLog -> {
			Format -> Multiple,
			Class -> {Date, Link},
			Pattern :> {_?DateObjectQ, _Link},
			Relation -> {Null, Object[Instrument]},
			Description -> "Log of the instruments used during execution of this protocol.",
			Category -> "General",
			Headers -> {"Date","Instrument"},
			Developer -> True
		},
		ReservedStorageAvailability -> {
			Format -> Multiple,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Object[StorageAvailability][CurrentProtocol],
			Description -> "The positions used for storage that are reserved for this protocol during a storage task.",
			Category -> "Storage Information",
			Developer -> True
		},
		Sterile -> {
			Format -> Single,
			Class -> Expression,
			Pattern :> BooleanP,
			Description -> "Indicates if the protocol is performed in a sterile environment.",
			Category -> "General"
		},
		WorkingSamples -> {
			Format -> Multiple,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Alternatives[
				Object[Sample],
				Model[Sample],
				Object[Item],
				Model[Item]
			],
			Description -> "For each member of SamplesIn, the derived sample on which the experiment acts. This list diverges from SamplesIn when input samples are transferred to new containers.",
			Category -> "Resources",
			Developer -> True
		},

		WorkingContainers -> {
			Format -> Multiple,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Alternatives[
				Object[Container],
				Model[Container]
			],
			Description ->"Containers of the samples corresponding to preparations of SamplesIn generated during sample preparation and intended for use in this experiment.",
			Category -> "Resources",
			Developer -> True
		},

		(* --- Replicate Experiments --- *)

		Template -> {
			Format -> Single,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Object[Protocol][ProtocolsTemplated],
			Description ->
				"The protocol whose option selections should be selected as the default options for this protocol.",
			Category -> "Replicate Experiments"
		},
		ProtocolsTemplated -> {
			Format -> Multiple,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Object[Protocol][Template],
			Description -> "Protocols which were generated using this protocol's options as a starting point for its option defaults.",
			Category -> "Replicate Experiments"
		},

		(* --- Troubleshooting --- *)
		CartResources -> {
			Format -> Multiple,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Alternatives[
				Object[Sample],
				Object[Container],
				Object[Part],
				Object[Plumbing],
				Object[Item],
				Object[Sensor],
				Object[Wiring]
			],
			Description -> "Any resources that must be re-picked for use in this protocol upon resumption from troubleshooting or processing.",
			Category -> "Troubleshooting",
			Developer -> True
		},
		CartInstruments -> {
			Format -> Multiple,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Object[Instrument],
			Description -> "Any instruments that must be re-selected for use in this protocol upon resumption from troubleshooting or processing.",
			Category -> "Troubleshooting",
			Developer -> True
		},
		CoveredCartResources -> {
			Format -> Multiple,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Alternatives[
				Object[Sample],
				Object[Container],
				Object[Part],
				Object[Plumbing],
				Object[Item],
				Object[Sensor],
				Object[Wiring]
			],
			Description -> "Any resources that must be re-covered after troubleshooting resource picking of CartResources for use in this protocol upon resumption from troubleshooting or processing.",
			Category -> "Troubleshooting",
			Developer -> True
		},

		(* --- Method Information --- *)
		ImagingSamples -> {
			Format -> Multiple,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Alternatives[
				Object[Sample],
				Object[Container]
			],
			Description -> "Any resources used during the course of this protocol that must be imaged.",
			Category -> "General",
			Developer -> True
		},
		VolumeMeasurementSamples -> {
			Format -> Multiple,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Alternatives[
				Object[Sample],
				Object[Container]
			],
			Description -> "Any resources used during the course of this protocol whose volumes must be updated.",
			Category -> "General",
			Developer -> True
		},
		WeightMeasurementSamples -> {
			Format -> Multiple,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Alternatives[
				Object[Sample],
				Object[Container]
			],
			Description -> "Any resources used during the course of this protocol whose weights must be updated.",
			Category -> "General",
			Developer -> True
		},
		LiquidHandlingLogs -> {
			Format -> Multiple,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Object[EmeraldCloudFile],
			Description -> "The instrumentation trace files that monitored and recorded the execution of this robotic liquid handling.",
			Category -> "General",
			AdminWriteOnly->True
		},
		LiquidHandlingLogPaths -> {
			Format -> Multiple,
			Class -> String,
			Pattern :> FilePathP,
			Description -> "The file paths of the instrumentation trace files that monitored and recorded the execution of this robotic liquid handling.",
			Category -> "General",
			Developer -> True,
			AdminWriteOnly->True
		},
		InSitu -> {
			Format -> Single,
			Class -> Boolean,
			Pattern :> BooleanP,
			Description -> "Indicates if the protocol should run the experiment on the SamplesIn leaving them in their current location and state rather than moving them back and forth from storage or their previous location in a parent protocol.",
			Category -> "General",
			Developer -> True
		},

		(* --- Sample Preparation --- *)
		PreparatoryUnitOperations -> {
			Format -> Multiple,
			Class -> Expression,
			Pattern :> _|_,
			Description -> "A list of transfers, consolidations, aliquots, mixes and dilutions that will be performed in the order listed to prepare samples for the experiment.",
			Category -> "Sample Preparation"
		},
		PreparatoryPrimitives -> {
			Format -> Multiple,
			Class -> Expression,
			Pattern :> _|_,
			Description -> "A list of transfers, consolidations, aliquots, mixes and dilutions that will be performed in the order listed to prepare samples for the experiment.",
			Category -> "Sample Preparation"
		},
		PreparedSamples -> {
			Format -> Multiple,
			Class -> {String, Expression, Integer, Expression, String},
			Pattern :> {_String, _Symbol, _Integer, _Integer|_Symbol,_String},
			Relation -> {Null, Null, Null, Null, Null},
			Units -> {None, None, None, None, None},
			Description -> "Prepared Samples that are used in this protocol and a description of the field in which a prepared sample's resolved object is stored. Position and index are Null when a prepared sample's resolution is stored in a single field.",
			Category -> "General",
			Headers->{"Define Name","Field Name","Field Position", "Field Index","Container Position"},
			Developer -> True
		},
		VolumeCheckSamplePrep -> {
			Format -> Single,
			Class -> Expression,
			Pattern :> BooleanP,
			Description -> "Indicates if any liquid samples prepared by using the PreparatoryUnitOperations option should have their volumes measured and updated before running the experiment.",
			Category -> "Sample Preparation"
		},
		InjectionSampleVolumeMeasurement-> {
			Format -> Single,
			Class -> Boolean,
			Pattern :> BooleanP,
			Description -> "Indicates if any liquid samples prepared by using the PreparatoryUnitOperations option in this chromatography protocol should have their volumes measured and updated before running the experiment.",
			Category -> "Sample Preparation",
			Developer -> True
		},
		IncubateSamplePreparation -> {
  			Format -> Multiple,
  			Class -> {
    				Incubate -> Boolean,
    				IncubationTemperature -> Real,
    				IncubationTime -> Real,
    				Mix -> Boolean,
    				MixType -> Expression,
    				MixUntilDissolved -> Boolean,
    				MaxIncubationTime -> Real,
    				IncubationInstrument -> Link,
    				AnnealingTime -> Real,
    				IncubateAliquotContainer -> Expression,
    				IncubateAliquot -> Real,
    				IncubateAliquotDestinationWell -> Expression
    			},
  			Pattern :> {
    				Incubate -> BooleanP,
    				IncubationTemperature -> GreaterEqualP[0 Kelvin],
    				IncubationTime -> GreaterEqualP[0 Second],
    				Mix -> BooleanP,
    				MixType -> MixTypeP,
    				MixUntilDissolved -> BooleanP,
    				MaxIncubationTime -> GreaterEqualP[0 Second],
    				IncubationInstrument -> ObjectP[{Object[Instrument], Model[Instrument]}],
    				AnnealingTime -> GreaterEqualP[0 Second],
    				IncubateAliquotContainer -> {_Integer|Null, ObjectP[Model[Container]]|Null},
    				IncubateAliquot -> GreaterEqualP[0 Liter],
    				IncubateAliquotDestinationWell -> Alternatives @@ Flatten[ECL`AllWells[NumberOfWells->384]]
    			},
  			Units -> {
    				Incubate -> None,
    				IncubationTemperature -> Celsius,
    				IncubationTime -> Second,
    				Mix -> None,
    				MixType -> None,
    				MixUntilDissolved -> None,
    				MaxIncubationTime -> Second,
    				IncubationInstrument -> None,
    				AnnealingTime -> Second,
    				IncubateAliquotContainer -> None,
    				IncubateAliquot -> Liter,
    				IncubateAliquotDestinationWell -> None
    			},
    		Relation -> {
    				Incubate -> Null,
    				IncubationTemperature -> Null,
    				IncubationTime -> Null,
    				Mix -> Null,
    				MixType -> Null,
    				MixUntilDissolved -> Null,
    				MaxIncubationTime -> Null,
    				IncubationInstrument -> Alternatives[Model[Instrument],Object[Instrument]],
    				AnnealingTime -> Null,
    				IncubateAliquotContainer -> Null,
    				IncubateAliquot -> Null,
    				IncubateAliquotDestinationWell -> Null
    			},
  			IndexMatching -> SamplesIn,
  			Description -> "For each member of SamplesIn, parameters describing how the input samples should be heated prior to any aliquoting or the start of the experiment.",
  			Category -> "Sample Preparation"
  		},
		CentrifugeSamplePreparation -> {
			Format -> Multiple,
			Class -> {
				Centrifuge -> Boolean,
				CentrifugeInstrument -> Link,
				CentrifugeIntensity -> VariableUnit,
				CentrifugeTime -> Real,
				CentrifugeTemperature -> Real,
				CentrifugeAliquotContainer -> Expression,
				CentrifugeAliquot -> Real,
				CentrifugeAliquotDestinationWell -> Expression
			},
			Pattern :> {
				Centrifuge -> BooleanP,
				CentrifugeInstrument -> ObjectP[{Object[Instrument, Centrifuge], Model[Instrument, Centrifuge]}],
				CentrifugeIntensity -> GreaterEqualP[0 RPM] | GreaterEqualP[0 GravitationalAcceleration],
				CentrifugeTime -> GreaterEqualP[0 Second],
				CentrifugeTemperature -> GreaterEqualP[0 Kelvin],
				CentrifugeAliquotContainer -> {_Integer|Null, ObjectP[Model[Container]]|Null},
				CentrifugeAliquot -> GreaterEqualP[0 Liter],
				CentrifugeAliquotDestinationWell -> Alternatives @@ Flatten[ECL`AllWells[NumberOfWells->384]]
			},
    		Relation -> {
				Centrifuge -> Null,
				CentrifugeInstrument -> Alternatives[Object[Instrument, Centrifuge], Model[Instrument, Centrifuge]],
				CentrifugeIntensity -> Null,
				CentrifugeTime -> Null,
				CentrifugeTemperature -> Null,
				CentrifugeAliquotContainer -> Null,
				CentrifugeAliquot -> Null,
				CentrifugeAliquotDestinationWell -> Null
			},
			Units -> {
				Centrifuge -> None,
				CentrifugeInstrument -> None,
				CentrifugeIntensity -> None,
				CentrifugeTime -> Minute,
				CentrifugeTemperature -> Celsius,
				CentrifugeAliquotContainer -> None,
				CentrifugeAliquot -> Liter,
				CentrifugeAliquotDestinationWell -> None
			},
			IndexMatching -> SamplesIn,
			Description -> "For each member of SamplesIn, parameters describing how the input samples should be spun down prior to any aliquoting or the start of the experiment.",
			Category -> "Sample Preparation"
  		},
		FilterSamplePreparation -> {
			Format -> Multiple,
			Class -> {
				Filtration -> Boolean,
				FiltrationType -> Expression,
				Filter -> Link,
				FilterMaterial -> Expression,
				FilterPoreSize -> Real,
				FilterContainerOut -> Expression,
				FilterInstrument -> Link,
				FilterSyringe -> Link,
				FilterHousing -> Link,
				FilterIntensity -> VariableUnit,
				FilterTime -> Real,
				FilterTemperature -> Real,
				FilterSterile -> Boolean,
				FilterAliquotContainer -> Expression,
				FilterAliquot -> Real,
				PrefilterMaterial -> Expression,
				PrefilterPoreSize -> Real,
				FilterAliquotDestinationWell -> Expression
			},
			Pattern :> {
				Filtration -> BooleanP,
				FiltrationType -> FiltrationTypeP,
				(* TODO: Remove after item migration *)
				(* Post migration should no longer need references to Model[Sample]/Object[Sample] *)
				Filter->ObjectP[{Object[Container], Model[Container], Object[Sample], Model[Sample], Object[Item], Model[Item]}],
				FilterMaterial -> FilterMembraneMaterialP,
				FilterPoreSize -> FilterSizeP,
				FilterContainerOut -> {_Integer,ObjectP[{Model[Container],Object[Container]}]},
				FilterInstrument -> ObjectP[{
					Model[Instrument,FilterBlock],
					Object[Instrument,FilterBlock],
					Model[Instrument,PeristalticPump],
					Object[Instrument,PeristalticPump],
					Model[Instrument,VacuumPump],
					Object[Instrument,VacuumPump],
					Model[Instrument,Centrifuge],
					Object[Instrument,Centrifuge],
					Model[Instrument,SyringePump],
					Object[Instrument,SyringePump]
				}],
				FilterSyringe -> ObjectP[{
					Model[Container,Syringe],
					Object[Container,Syringe]
				}],
				FilterHousing -> ObjectP[{
					Model[Instrument,FilterHousing],
					Object[Instrument,FilterHousing]
				}],
				FilterIntensity -> GreaterP[0 RPM] | GreaterP[0 GravitationalAcceleration],
				FilterTime -> GreaterEqualP[0 Minute],
				FilterTemperature -> GreaterEqualP[0 Kelvin],
				FilterSterile -> BooleanP,
				FilterAliquotContainer -> {_Integer|Null, ObjectP[Model[Container]]|Null},
				FilterAliquot -> GreaterEqualP[0 Liter],
				PrefilterMaterial -> FilterMembraneMaterialP,
				PrefilterPoreSize -> FilterSizeP,
				FilterAliquotDestinationWell -> Alternatives @@ Flatten[ECL`AllWells[NumberOfWells->384]]
			},
			Units -> {
				Filtration -> None,
				FiltrationType -> None,
				Filter -> None,
				FilterMaterial -> None,
				FilterPoreSize -> Micrometer,
				FilterContainerOut -> None,
				FilterInstrument -> None,
				FilterSyringe -> None,
				FilterHousing -> None,
				FilterIntensity -> None,
				FilterTime -> Minute,
				FilterTemperature -> Celsius,
				FilterSterile -> None,
				FilterAliquotContainer -> None,
				FilterAliquot -> Liter,
				PrefilterMaterial -> None,
				PrefilterPoreSize -> Micrometer,
				FilterAliquotDestinationWell -> None
			},
			Relation -> {
				Filtration -> Null,
				FiltrationType -> Null,
				(* TODO: Remove after item migration *)
				(* Post migration should no longer need references to Model[Sample]/Object[Sample] *)
				Filter ->Alternatives[Object[Container], Model[Container],Object[Sample],Model[Sample],Object[Item],Model[Item]],
				FilterMaterial -> Null,
				FilterPoreSize -> Null,
				FilterContainerOut -> Null,
				FilterInstrument -> Alternatives[
					Model[Instrument,FilterBlock],
					Object[Instrument,FilterBlock],
					Model[Instrument,PeristalticPump],
					Object[Instrument,PeristalticPump],
					Model[Instrument,VacuumPump],
					Object[Instrument,VacuumPump],
					Model[Instrument,Centrifuge],
					Object[Instrument,Centrifuge],
					Model[Instrument,SyringePump],
					Object[Instrument,SyringePump]
				],
				FilterSyringe -> Alternatives[
					Model[Container,Syringe],
					Object[Container,Syringe]
				],
				FilterHousing -> Alternatives[
					Model[Instrument,FilterHousing],
					Object[Instrument,FilterHousing]
				],
				FilterIntensity -> Null,
				FilterTime -> Null,
				FilterTemperature -> Null,
				FilterSterile -> Null,
				FilterAliquotContainer -> Null,
				FilterAliquot -> Null,
				PrefilterMaterial -> Null,
				PrefilterPoreSize -> Null,
				FilterAliquotDestinationWell -> Null
			},
			IndexMatching -> SamplesIn,
			Description -> "For each member of SamplesIn, parameters describing how particulates should be separated from the input samples prior to any aliquoting or the start of the experiment.",
			Category -> "Sample Preparation"
		},
		SamplePreparationProtocols -> {
			Format -> Multiple,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Alternatives[
				Object[Protocol],
				Object[Notebook, Script]
			],
			Description -> "Protocols used to mix, centrifuge, incubate, and filter the SamplesIn prior to starting the experiment.",
			Category -> "Sample Preparation"
		},

		AliquotSamplePreparation -> {
			Format -> Multiple,
			Class -> {
				Aliquot -> Boolean,
				AliquotAmount -> Expression,
				TargetConcentration -> Expression,
				AssayVolume -> Real,
				(* need this to be an expression; it's okay because we don't ever resource pick from this field; if we had multiple multiples this could be real links *)
				AliquotContainer -> Expression,
				AssayBuffer -> Link,
				BufferDiluent -> Link,
				BufferDilutionFactor -> Real,
				ConcentratedBuffer -> Link,
				DestinationWell -> Expression,
				TargetConcentrationAnalyte -> Expression,
				AliquotSampleLabel -> String
			},
			Pattern :> {
				Aliquot -> BooleanP,
				AliquotAmount -> ListableP[GreaterEqualP[0 Milliliter]|GreaterEqualP[0 Gram]|GreaterEqualP[0 Unit] |GreaterEqualP[0]|Null],
				TargetConcentration -> ListableP[GreaterEqualP[0*Micro*Molar] | GreaterEqualP[0 (Milligram/Milliliter)]|Null],
				AssayVolume -> GreaterP[0 Milliliter],
				AliquotContainer -> {_Integer, ObjectP[{Model[Container], Object[Container]}]},
				AssayBuffer -> ObjectP[{Object[Sample], Model[Sample]}],
				BufferDiluent -> ObjectP[{Object[Sample], Model[Sample]}],
				BufferDilutionFactor -> GreaterEqualP[1],
				ConcentratedBuffer -> ObjectP[{Object[Sample], Model[Sample]}],
				DestinationWell -> Alternatives @@ Flatten[ECL`AllWells[NumberOfWells->384]],
				TargetConcentrationAnalyte -> ListableP[ObjectP[Model[Molecule]]|Null],
				AliquotSampleLabel -> _String
			},
			Units -> {
				Aliquot -> None,
				AliquotAmount -> None,
				TargetConcentration -> None,
				AssayVolume -> Milliliter,
				AliquotContainer -> None,
				AssayBuffer -> None,
				BufferDiluent -> None,
				BufferDilutionFactor -> None,
				ConcentratedBuffer -> None,
				DestinationWell -> None,
				TargetConcentrationAnalyte -> None,
				AliquotSampleLabel -> None
			},
			Relation -> {
				Aliquot -> Null,
				AliquotAmount -> Null,
				TargetConcentration -> Null,
				AssayVolume -> Null,
				AliquotContainer -> Null,
				AssayBuffer -> Object[Sample] | Model[Sample],
				BufferDiluent -> Object[Sample] | Model[Sample],
				BufferDilutionFactor -> Null,
				ConcentratedBuffer -> Object[Sample] | Model[Sample],
				DestinationWell -> Null,
				TargetConcentrationAnalyte -> Null,
				AliquotSampleLabel -> Null
			},
			Description -> "For each member of AliquotSamples, parameters describing how aliquots should be drawn from the input samples after initial sample preparation in order to create new aliquot samples upon which aliquot preparation and the experiment should proceed.",
			Category -> "Aliquoting"
		},

		PooledSamplesIn -> {
			Format -> Multiple,
			Class -> Expression,
			Pattern :> {ObjectReferenceP[Object[Sample]]..},
			Units -> None,
			Description -> "The members of SamplesIn gathered into the pools that are mixed in each AliquotContainer.",
			Category -> "General"
		},

		NestedIndexMatchingSamplesIn -> {
			Format -> Multiple,
			Class -> Expression,
			Pattern :> {ObjectReferenceP[Object[Sample]]..},
			Units -> None,
			Description -> "The members of SamplesIn gathered into the pools that are mixed in each AliquotContainer.",
			Category -> "General"
		},

		PooledIncubateSamplePreparation -> {
			Format -> Multiple,
			Class -> {
				Incubate -> Boolean,
				IncubationTemperature -> Real,
				IncubationTime -> Real,
				Mix -> Boolean,
				MixType -> Expression,
				MixUntilDissolved -> Boolean,
				MaxIncubationTime -> Real,
				IncubationInstrument -> Link,
				AnnealingTime -> Real,
				IncubateAliquotContainer -> Expression,
				IncubateAliquot -> Real,
				IncubateAliquotDestinationWell -> Expression
			},
			Pattern :> {
				Incubate -> BooleanP,
				IncubationTemperature -> GreaterEqualP[0 Kelvin],
				IncubationTime -> GreaterEqualP[0 Second],
				Mix -> BooleanP,
				MixType -> MixTypeP,
				MixUntilDissolved -> BooleanP,
				MaxIncubationTime -> GreaterEqualP[0 Second],
				IncubationInstrument -> ObjectP[{Object[Instrument], Model[Instrument]}],
				AnnealingTime -> GreaterEqualP[0 Second],
				IncubateAliquotContainer -> {_Integer|Null, ObjectP[Model[Container]]|Null},
				IncubateAliquot -> GreaterEqualP[0 Liter],
				IncubateAliquotDestinationWell -> Alternatives @@ Flatten[ECL`AllWells[NumberOfWells->384]]
			},
			Units -> {
				Incubate -> None,
				IncubationTemperature -> Celsius,
				IncubationTime -> Second,
				Mix -> None,
				MixType -> None,
				MixUntilDissolved -> None,
				MaxIncubationTime -> Second,
				IncubationInstrument -> None,
				AnnealingTime -> Second,
				IncubateAliquotContainer -> None,
				IncubateAliquot -> Liter,
				IncubateAliquotDestinationWell -> None
			},
			Relation -> {
				Incubate -> Null,
				IncubationTemperature -> Null,
				IncubationTime -> Null,
				Mix -> Null,
				MixType -> Null,
				MixUntilDissolved -> Null,
				MaxIncubationTime -> Null,
				IncubationInstrument -> Alternatives[Model[Instrument],Object[Instrument]],
				AnnealingTime -> Null,
				IncubateAliquotContainer -> Null,
				IncubateAliquot -> Null,
				IncubateAliquotDestinationWell -> Null
			},
			IndexMatching -> PooledSamplesIn,
			Description -> "For each member of PooledSamplesIn, parameters describing how the pooled samples should be incubated after aliquoting but prior to the start of the experiment.",
			Category -> "Sample Preparation"
		},

		NestedIndexMatchingIncubateSamplePreparation -> {
			Format -> Multiple,
			Class -> {
				Incubate -> Boolean,
				IncubationTemperature -> Real,
				IncubationTime -> Real,
				Mix -> Boolean,
				MixType -> Expression,
				MixUntilDissolved -> Boolean,
				MaxIncubationTime -> Real,
				IncubationInstrument -> Link,
				AnnealingTime -> Real,
				IncubateAliquotContainer -> Expression,
				IncubateAliquot -> Real,
				IncubateAliquotDestinationWell -> Expression
			},
			Pattern :> {
				Incubate -> BooleanP,
				IncubationTemperature -> GreaterEqualP[0 Kelvin],
				IncubationTime -> GreaterEqualP[0 Second],
				Mix -> BooleanP,
				MixType -> MixTypeP,
				MixUntilDissolved -> BooleanP,
				MaxIncubationTime -> GreaterEqualP[0 Second],
				IncubationInstrument -> ObjectP[{Object[Instrument], Model[Instrument]}],
				AnnealingTime -> GreaterEqualP[0 Second],
				IncubateAliquotContainer -> {_Integer|Null, ObjectP[Model[Container]]|Null},
				IncubateAliquot -> GreaterEqualP[0 Liter],
				IncubateAliquotDestinationWell -> Alternatives @@ Flatten[ECL`AllWells[NumberOfWells->384]]
			},
			Units -> {
				Incubate -> None,
				IncubationTemperature -> Celsius,
				IncubationTime -> Second,
				Mix -> None,
				MixType -> None,
				MixUntilDissolved -> None,
				MaxIncubationTime -> Second,
				IncubationInstrument -> None,
				AnnealingTime -> Second,
				IncubateAliquotContainer -> None,
				IncubateAliquot -> Liter,
				IncubateAliquotDestinationWell -> None
			},
			Relation -> {
				Incubate -> Null,
				IncubationTemperature -> Null,
				IncubationTime -> Null,
				Mix -> Null,
				MixType -> Null,
				MixUntilDissolved -> Null,
				MaxIncubationTime -> Null,
				IncubationInstrument -> Alternatives[Model[Instrument],Object[Instrument]],
				AnnealingTime -> Null,
				IncubateAliquotContainer -> Null,
				IncubateAliquot -> Null,
				IncubateAliquotDestinationWell -> Null
			},
			IndexMatching -> NestedIndexMatchingSamplesIn,
			Description -> "For each member of NestedIndexMatchingSamplesIn, parameters describing how the pooled samples should be incubated after aliquoting but prior to the start of the experiment.",
			Category -> "Sample Preparation"
		},

		PooledCentrifugeSamplePreparation -> {
			Format -> Multiple,
			Class -> {
				Centrifuge -> Boolean,
				CentrifugeInstrument -> Link,
				CentrifugeIntensity -> VariableUnit,
				CentrifugeTime -> Real,
				CentrifugeTemperature -> Real,
				CentrifugeAliquotContainer -> Expression,
				CentrifugeAliquot -> Real,
				CentrifugeAliquotDestinationWell -> Expression
			},
			Pattern :> {
				Centrifuge -> BooleanP,
				CentrifugeInstrument -> ObjectP[{Object[Instrument, Centrifuge], Model[Instrument, Centrifuge]}],
				CentrifugeIntensity -> GreaterEqualP[0 RPM] | GreaterEqualP[0 GravitationalAcceleration],
				CentrifugeTime -> GreaterEqualP[0 Second],
				CentrifugeTemperature -> GreaterEqualP[0 Kelvin],
				CentrifugeAliquotContainer -> {_Integer|Null, ObjectP[Model[Container]]|Null},
				CentrifugeAliquot -> GreaterEqualP[0 Liter],
				CentrifugeAliquotDestinationWell -> Alternatives @@ Flatten[ECL`AllWells[NumberOfWells->384]]
			},
			Relation -> {
				Centrifuge -> Null,
				CentrifugeInstrument -> Alternatives[Object[Instrument, Centrifuge], Model[Instrument, Centrifuge]],
				CentrifugeIntensity -> Null,
				CentrifugeTime -> Null,
				CentrifugeTemperature -> Null,
				CentrifugeAliquotContainer -> Null,
				CentrifugeAliquot -> Null,
				CentrifugeAliquotDestinationWell -> Null
			},
			Units -> {
				Centrifuge -> None,
				CentrifugeInstrument -> None,
				CentrifugeIntensity -> None,
				CentrifugeTime -> Minute,
				CentrifugeTemperature -> Celsius,
				CentrifugeAliquotContainer -> None,
				CentrifugeAliquot -> Liter,
				CentrifugeAliquotDestinationWell -> None
			},
			IndexMatching -> PooledSamplesIn,
			Description -> "For each member of PooledSamplesIn, parameters describing how the pooled samples should be centrifuge after aliquoting and pooled mixing but prior to the start of the experiment.",
			Category -> "Sample Preparation"
		},

		NestedIndexMatchingCentrifugeSamplePreparation -> {
			Format -> Multiple,
			Class -> {
				Centrifuge -> Boolean,
				CentrifugeInstrument -> Link,
				CentrifugeIntensity -> VariableUnit,
				CentrifugeTime -> Real,
				CentrifugeTemperature -> Real,
				CentrifugeAliquotContainer -> Expression,
				CentrifugeAliquot -> Real,
				CentrifugeAliquotDestinationWell -> Expression
			},
			Pattern :> {
				Centrifuge -> BooleanP,
				CentrifugeInstrument -> ObjectP[{Object[Instrument, Centrifuge], Model[Instrument, Centrifuge]}],
				CentrifugeIntensity -> GreaterEqualP[0 RPM] | GreaterEqualP[0 GravitationalAcceleration],
				CentrifugeTime -> GreaterEqualP[0 Second],
				CentrifugeTemperature -> GreaterEqualP[0 Kelvin],
				CentrifugeAliquotContainer -> {_Integer|Null, ObjectP[Model[Container]]|Null},
				CentrifugeAliquot -> GreaterEqualP[0 Liter],
				CentrifugeAliquotDestinationWell -> Alternatives @@ Flatten[ECL`AllWells[NumberOfWells->384]]
			},
			Relation -> {
				Centrifuge -> Null,
				CentrifugeInstrument -> Alternatives[Object[Instrument, Centrifuge], Model[Instrument, Centrifuge]],
				CentrifugeIntensity -> Null,
				CentrifugeTime -> Null,
				CentrifugeTemperature -> Null,
				CentrifugeAliquotContainer -> Null,
				CentrifugeAliquot -> Null,
				CentrifugeAliquotDestinationWell -> Null
			},
			Units -> {
				Centrifuge -> None,
				CentrifugeInstrument -> None,
				CentrifugeIntensity -> None,
				CentrifugeTime -> Minute,
				CentrifugeTemperature -> Celsius,
				CentrifugeAliquotContainer -> None,
				CentrifugeAliquot -> Liter,
				CentrifugeAliquotDestinationWell -> None
			},
			IndexMatching -> PooledSamplesIn,
			Description -> "For each member of PooledSamplesIn, parameters describing how the pooled samples should be centrifuge after aliquoting and pooled mixing but prior to the start of the experiment.",
			Category -> "Sample Preparation"
		},


	(* --- Aliquoting --- *)
		AliquotProtocols -> {
			Format -> Multiple,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Object[Protocol],
			Description -> "Protocols used to create AliquotSamples prior to starting the experiment.",
			Category -> "Aliquoting"
		},
		(* ALIQUOT SAMPLE PREPARATION FIELDS ARE DEPRECATED AND THUS ARE MARKED AS DEVELOPER. *)
		AliquotIncubatePreparation->{
			Format->Multiple,
			Class->{
				Incubate->Boolean,
				Temperature->Real,
				Time->Real,
				AnnealingTime->Real
			},
			Pattern:>{
				Incubate->BooleanP,
				Temperature->GreaterP[0 Kelvin],
				Time->GreaterP[0 Second],
				AnnealingTime->GreaterP[0 Second]
			},
			Units->{
				Incubate->None,
				Temperature->Celsius,
				Time->Minute,
				AnnealingTime->Minute
			},
			IndexMatching->AliquotSamples,
			Description->"For each member of AliquotSamples, parameters describing how the aliquot samples should be heated prior to the start of the experiment.",
			Developer->True,
			Category->"Aliquoting"
		},
		AliquotMixPreparation->{
			Format->Multiple,
			Class->{
				Mix->Boolean,
				Type->Expression,
				Rate->Real,
				Time->Real,
				NumberOfMixes->Integer,
				MixVolume->Real
			},
			Pattern:>{
				Mix->BooleanP,
				Type->MixTypeP,
				Rate->GreaterP[0*RPM],
				Time->GreaterP[0 Second],
				NumberOfMixes->GreaterP[0,1],
				MixVolume->GreaterP[0 Microliter]
			},
			Units-> {
				Mix->None,
				Type->None,
				Rate->RPM,
				Time->Minute,
				NumberOfMixes->None,
				MixVolume->Microliter
			},
			IndexMatching->AliquotSamples,
			Description->"For each member of AliquotSamples, parameters describing how the aliquot samples should be agitated prior to the start of the experiment.",
			Developer->True,
			Category->"Aliquoting"
		},
		AliquotCentrifugePreparation->{
			Format->Multiple,
			Class->{
				Centrifuge->Boolean,
				Rate->Real,
				Force->Real,
				Time->Real,
				Temperature->Real
			},
			Pattern:>{
				Centrifuge->BooleanP,
				Rate->GreaterP[0*RPM],
				Force->GreaterP[0*GravitationalAcceleration],
				Time->GreaterP[0 Second],
				Temperature->GreaterP[0 Kelvin]
			},
			Units-> {
				Centrifuge->None,
				Rate->RPM,
				Force->GravitationalAcceleration,
				Time->Minute,
				Temperature->Celsius
			},
			IndexMatching->AliquotSamples,
			Description->"For each member of AliquotSamples, parameters describing how particulates should be separated from the aliquot samples prior to the start of the experiment.",
			Developer->True,
			Category->"Aliquoting"
		},
		AliquotFilterPreparation->{
			Format->Multiple,
			Class->{
				Filtration->Boolean,
				Type->Expression,
				Filter->Link,
				FilterMaterial->Expression,
				FilterPoreSize->Real
			},
			Pattern:>{
				Filtration->BooleanP,
				Type->FiltrationTypeP,
				Filter->ObjectP[{Object[Container],Model[Container],Object[Sample],Model[Sample]}],
				FilterMaterial->FilterMembraneMaterialP,
				FilterPoreSize->FilterSizeP
			},
			Units-> {
				Filtration->None,
				Type->None,
				Filter->None,
				FilterMaterial->None,
				FilterPoreSize->Micrometer
			},
			Relation->{
				Filtration->Null,
				Type->Null,
				Filter->Alternatives[Object[Container],Model[Container],Object[Sample],Model[Sample]],
				FilterMaterial->Null,
				FilterPoreSize->Null
			},
			IndexMatching->AliquotSamples,
			Description->"For each member of AliquotSamples, parameters how particulates should be separated from the aliquot samples prior to the start of the experiment.",
			Developer->True,
			Category->"Aliquoting"
		},
		AliquotPreparationProtocols->{
			Format->Multiple,
			Class->Link,
			Pattern:>_Link,
			Relation->Object[Protocol],
			Description->"Protocols used to mix, centrifuge, incubate, and filter the AliquotSamples prior to starting the experiment.",
			Category->"Aliquoting"
		},
		TargetContainer->{
			Format->Multiple,
			Class->Link,
			Pattern:>_Link,
			Relation->Alternatives[
				Object[Container],
				Model[Container]
			],
			Description->"For each member of SamplesIn, the model of container in which the sample should reside following sample preparation in order to ensure that the sample will be in a container compatible with the instrument(s) used in the experiment.",
			IndexMatching->SamplesIn,
			Category->"Aliquoting",
			Developer -> True
		},
		TargetSampleGroupings->{
			Format->Multiple,
			Class->Expression,
			Pattern:>{ObjectP[Object[Sample]] ..},
			Description->"A list of lists indicating which samples will be grouped together in each container after all sample preparation has completed.",
			Category->"Aliquoting",
			Developer->True
		},

		(* --- Sample Post-Processing --- *)
		PostProcessingProtocols -> {
			Format -> Multiple,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Object[Protocol],
			Description -> "Protocols used to perform post-processing such as sample imaging or volume measurement.",
			Category -> "Sample Post-Processing"
		},
		ImageSample -> {
			Format -> Single,
			Class -> Expression,
			Pattern :> BooleanP,
			Description -> "Indicates if the samples that are modified in the course of the experiment are imaged after running the experiment.",
			Category -> "Sample Post-Processing"
		},

		(* --- Experiment Results --- *)
		Data -> {
			Format -> Multiple,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Object[Data][Protocol],
			Description -> "Any primary data generated by this protocol.",
			Category -> "Experimental Results",
			AdminWriteOnly->True
		},
		NewSamples -> {
			Format -> Multiple,
			Class -> Expression,
			Pattern :> {{ObjectP[{Object[Sample],Object[Item],Object[Plumbing]}]..}..},
			Description -> "For each member of SamplesIn, the list of new samples generated	from each source sample.",
			Category -> "Experimental Results",
			IndexMatching->SamplesIn
		},
		SamplesOut -> {
			Format -> Multiple,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Object[Sample][Protocols]|Object[Item][Protocols]|Object[Plumbing][Protocols],
			Description -> "Any preparative samples generated by the protocol.",
			Category -> "Experimental Results",
			AdminWriteOnly->True
		},
		ContainersOut -> {
			Format -> Multiple,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Alternatives[
				Object[Container][Protocols],
				Model[Container]
			],
			Description -> "Any containers holding SamplesOut generated by this protocol.",
			Category -> "Experimental Results",
			AdminWriteOnly->True
		},
		EnvironmentalData -> {
			Format -> Multiple,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Object[Data][Protocol],
			Description -> "Measurements of environmental conditions (temperature and humidity) recorded during the execution of this protocol.",
			Category -> "Experimental Results",
			AdminWriteOnly->True
		},

		(* --- Sample Storage --- *)
		TransportChilledDevice -> {
			Format -> Multiple,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Object[Instrument, PortableCooler] | Model[Instrument, PortableCooler],
			Description -> "Indicates the instrument(s) used to transport chilled samples during this protocol.",
			Category -> "Sample Storage",
			Developer -> True
		},
		TransportChilledTemperature -> {
			Format -> Multiple,
			Class -> Real,
			Pattern :> GreaterP[0 Kelvin],
			Units -> Celsius,
			Description -> "The temperature(s) at which the TransportChilledDevice(s) were set during this protocol.",
			Category -> "Sample Storage",
			Developer -> True
		},
		TransportWarmedDevice -> {
			Format -> Multiple,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Object[Instrument, PortableHeater] | Model[Instrument, PortableHeater],
			Description -> "Indicates the instrument(s) used to transport warmed samples during this protocol.",
			Category -> "Sample Storage",
			Developer -> True
		},
		TransportWarmedTemperature -> {
			Format -> Multiple,
			Class -> Real,
			Pattern :> GreaterP[0 Kelvin],
			Units -> Celsius,
			Description -> "The temperature(s) at which the TransportWarmedDevice(s) were set during this protocol.",
			Category -> "Sample Storage",
			Developer -> True
		},

		InitialNitrogenPressure -> {
			Format -> Single,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Object[Data][Protocol],
			Description -> "The pressure data of the nitrogen gas source before starting the experiment.",
			Category -> "General",
			AdminWriteOnly->True
		},
		NitrogenPressureLog -> {
			Format -> Single,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Object[Data][Protocol],
			Description -> "The pressure log for the nitrogen gas source for the relevant section of the facility.",
			Category -> "General",
			AdminWriteOnly->True
		},
		InitialCO2Pressure -> {
			Format -> Single,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Object[Data][Protocol],
			Description -> "The pressure data of the CO2 gas source before starting the experiment.",
			Category -> "General",
			AdminWriteOnly->True
		},
		CO2PressureLog -> {
			Format -> Single,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Object[Data][Protocol],
			Description -> "The pressure log for the CO2 gas source for the relevant section of the facility.",
			Category -> "General",
			AdminWriteOnly->True
		},
		InitialArgonPressure -> {
			Format -> Single,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Object[Data][Protocol],
			Description -> "The pressure data of the argon gas source before starting the experiment.",
			Category -> "General",
			AdminWriteOnly->True
		},
		ArgonPressureLog -> {
			Format -> Single,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Object[Data][Protocol],
			Description -> "The pressure log for the argon gas source for the relevant section of the facility.",
			Category -> "General",
			Developer -> True,
			AdminWriteOnly->True
		},
		UserCommunications -> {
			Format -> Multiple,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Object[SupportTicket, UserCommunication][AffectedProtocol],
			Description -> "Discussions with users about the execution of this top-level protocol.",
			Category -> "Protocol Support"
		},
		OperationsSupportTickets -> {
			Format -> Multiple,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Object[SupportTicket, Operations][AffectedProtocol],
			Description -> "Support tickets associated with the execution of this top-level protocol.",
			Category -> "Protocol Support",
			Developer -> True
		},
		ProtocolSpecificTickets -> {
			Format -> Multiple,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Object[SupportTicket][SourceProtocol],
			Description -> "Support tickets that were encountered during execution of this particular protocol (parent or subprotocol as the case may be).",
			Category -> "Protocol Support",
			Developer -> True
		},

		(* == Fields to Be Replaced, should be removed April 2024 post migration to SupportTicket ==*)
		TroubleshootingReports -> {
			Format -> Multiple,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Object[Troubleshooting, Report][AffectedProtocol],
			Description -> "Reports for errors that require troubleshooting associated with the execution of this top-level protocol.",
			Category -> "Troubleshooting"
		},
		TroubleshootingTickets -> {
			Format -> Multiple,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Object[Troubleshooting, Ticket][AffectedProtocol],
			Description -> "Troubleshooting tickets associated with the execution of this top-level protocol.",
			Category -> "Troubleshooting",
			Developer -> True
		},
		TroubleshootingGenerated -> {
			Format -> Multiple,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Object[Troubleshooting][SourceProtocol],
			Description -> "Troubleshooting tickets that were encountered during execution of this specific protocol (parent or subprotocol as the case may be).",
			Category -> "Troubleshooting",
			Developer -> True
		},

		(* ===== *)

		ObjectReplacementLog -> {
			Format -> Multiple,
			Class -> {Expression, Expression, Expression, Link, Link, Link},
			Pattern:> {_?DateObjectQ, _Link, _Field, _Link, _Link, _Link},
			Relation -> {
				Null,
				Alternatives[Object[Qualification],Object[Protocol],Object[Maintenance], Object[Resource], Object[UnitOperation], Object[Program]],
				Null,
				Alternatives[
					Object[Container],Object[Sample],Object[Item],Object[Instrument],Object[Plumbing],Object[Wiring],Object[Part],Object[Sensor],
					Model[Container],Model[Sample],Model[Item],Model[Instrument],Model[Plumbing],Model[Wiring],Model[Part],Model[Sensor]
				],
				Alternatives[
					Object[Container],Object[Sample],Object[Item],Object[Instrument],Object[Plumbing],Object[Wiring],Object[Part],Object[Sensor],
					Model[Container],Model[Sample],Model[Item],Model[Instrument],Model[Plumbing],Model[Wiring],Model[Part],Model[Sensor]
				],
				Object[User]
			},
			Description -> "A list of labware replaced during the course of running this protocol.",
			Headers -> {"Date", "Object Updated", "Field Updated", "Original Labware", "New Labware", "UpdatedBy"},
			Developer -> True,
			Category->"Troubleshooting"
		},
		CurrentOperator -> {
			Format -> Single,
			Class -> Link,
			Pattern :> _Link,
			(* If we are operating this as our main protocol (not in a interrupting snapback), we upload the backlink. *)
			(* Otherwise, we upload this without a backlink because we want to allow the user to operator more than one protocol and the same time. *)
			(* Also because we can't backlink to the PriorityProtocol field since that field is set by the scheduler to tell the user about the interrupt (before they start operating). *)
			Relation -> Object[User,Emerald][CurrentProtocol]|Object[User,Emerald],
			Description -> "The operator that is currently assigned to oversee this protocol.",
			Category -> "General",
			Developer -> True
		},
		CurrentTablet -> {
			Format -> Single,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Object[Part,Computer],
			Description -> "The tablet that is currently running this protocol in engine.",
			Category -> "General",
			Developer -> True
		},
		ActiveCart -> {
			Format -> Single,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Object[Container],
			Description -> "The operator cart currently in use by an operator for this protocol.",
			Category -> "General",
			Developer -> True
		},
		CartLog -> {
			Format -> Multiple,
			Class -> {Date, Link},
			Pattern :> {_?DateObjectQ, _Link},
			Relation -> {Null, Object[Container,OperatorCart]},
			Description -> "Log of the status changes for this protocol.",
			Category -> "General",
			Headers -> {"Date","Cart"},
			Developer -> True
		},
		ActiveRacks -> {
			Format -> Multiple,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Alternatives[Object[Container, Rack],Model[Container, Rack]],
			Description -> "The racks that are currently located on the ActiveCart and can be resource picked into.",
			Category -> "General",
			Developer -> True
		},
		HoldOrder -> {
			Format -> Single,
			Class -> Boolean,
			Pattern :> BooleanP,
			Description -> "Indicates if the queue position of this protocol should be strictly enforced, regardless of the available resources in the lab.",
			Category -> "General"
		},
		OptimizedPostProcessing -> {
			Format -> Single,
			Class -> Boolean,
			Pattern :> BooleanP,
			Description -> "Indicates if post-processing for this protocol is run in optimized batches outside of this protocol or if it is done in subprotocols within this protocol.",
			Category -> "General",
			Developer -> True
		},
		(* -- PRIORITY FIELDS -- *)
		Priority -> {
			Format -> Single,
			Class -> Boolean,
			Pattern :> BooleanP,
			Description -> "Indicates if this protocol should be prioritized to start at the given StartDate, have dedicated operation for its entirety, and not be interrupted by other protocols.",
			Category -> "General"
		},
		StartDate -> {
			Format -> Single,
			Class -> Date,
			Pattern :> _?DateObjectQ,
			Description -> "The date at which this protocol should be prioritized to start.",
			Category -> "General"
		},
		PriorityReturn -> {
			Format -> Single,
			Class -> Boolean,
			Pattern :> BooleanP,
			Description -> "Indicates if this protocol must interrupt a non-DangerZone protocol to be picked up at the indicated PickUpTime.",
			Category -> "General",
			Developer -> True
		},
		ScheduledOperator -> {
			Format -> Single,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Object[User, Emerald][PriorityProtocol],
			Description -> "The operator that is scheduled to be interrupted by this priority protocol.",
			Category -> "General",
			Developer -> True
		},
		ExplicitPriorityReturn -> {
			Format -> Single,
			Class -> Boolean,
			Pattern :> BooleanP,
			Description -> "Indicates if the priority return for this protocol was explicitly required by the developer. If the priority return was explicitly required, the DangerZoneCounter will be incremented when the protocol is returned to. If the priority return was not explicitly required, the DangerZoneCounter will not be incremented when returned to.",
			Category -> "General",
			Developer -> True
		},
		PickUpTime -> {
			Format -> Single,
			Class -> Date,
			Pattern :> _?DateObjectQ,
			Description -> "The date at which this protocol should be picked up from processing by an operator.",
			Category -> "General",
			Developer -> True
		},
		PriorityReturnEstimatedTime -> {
			Format -> Single,
			Class -> Real,
			Pattern :> TimeP,
			Units -> Hour,
			Description -> "The estimated time that the operator will spend in the DangerZone that follows the time critical interrupt.",
			Category -> "General",
			Developer -> True
		},
		PriorityReturnAlarm -> {
			Format -> Single,
			Class -> Real,
			Pattern :> TimeP,
			Units -> Hour,
			Description -> "The amount of time that is allowed to pass before an alarm is raised about a missed priority event.",
			Category -> "General",
			Developer -> True
		},
		PriorityReturnBuffer -> {
			Format -> Single,
			Class -> Real,
			Pattern :> TimeP,
			Units -> Hour,
			Description -> "The amount of time that an operator should be interrupted before the priority event.",
			Category -> "General",
			Developer -> True
		},
		ReturnToProtocol -> {
			Format -> Single,
			Class -> Boolean,
			Pattern :> BooleanP,
			Description -> "Indicates if operators should return to their original protocol if they have been interrupted to complete a time critical event for this protocol.",
			Category -> "General",
			Developer -> True
		},
		DangerZone -> {
			Format -> Single,
			Class -> Boolean,
			Pattern :> BooleanP,
			Description -> "Indicates if this protocol is currently in the DangerZone. This field is set to True if DangerZoneCounter>0 and is set to False if DangerZoneCounter==0.",
			Category -> "General",
			Developer -> True
		},
		DangerZoneCounter -> {
			Format -> Single,
			Class -> Integer,
			Pattern :> _Integer,
			Description -> "The number of StartDangerZone tasks that this protocol has encountered. If this field is greater than zero, this protocol is currently in a DangerZone. This field is only tracked in the parent protocol object.",
			Category -> "General",
			Developer -> True
		},
		PriorityReturnLog -> {
			Format -> Multiple,
			Class -> {
				Date,
				Boolean,
				Link
			},
			Pattern :> {
				_?DateObjectQ,
				BooleanP,
				_Link
			},
			Relation -> {
				Null,
				Null,
				Object[User]
			},
			Headers -> {"Date","PriorityReturn","Responsible Party"},
			Description -> "The historical record of the PriorityReturn field.",
			Category -> "General",
			Developer -> True
		},
		PickUpTimeLog -> {
			Format -> Multiple,
			Class -> {
				Date,
				Date,
				Link
			},
			Pattern :> {
				_?DateObjectQ,
				_?DateObjectQ,
				_Link
			},
			Relation -> {
				Null,
				Null,
				Object[User]
			},
			Headers -> {"Date","PickUpTime","Responsible Party"},
			Description -> "The historical record of the PickUpTime field.",
			Category -> "General",
			Developer -> True
		},
		PriorityReturnEstimatedTimeLog -> {
			Format -> Multiple,
			Class -> {
				Date,
				Real,
				Link
			},
			Pattern :> {
				_?DateObjectQ,
				TimeP,
				_Link
			},
			Relation -> {
				Null,
				Null,
				Object[User]
			},
			Units :> {
				None,
				Hour,
				None
			},
			Headers -> {"Date","PriorityReturnEstimatedTime","Responsible Party"},
			Description -> "The historical record of the PriorityReturnEstimatedTime field.",
			Category -> "General",
			Developer -> True
		},
		PriorityReturnAlarmLog -> {
			Format -> Multiple,
			Class -> {
				Date,
				Real,
				Link
			},
			Pattern :> {
				_?DateObjectQ,
				TimeP,
				_Link
			},
			Relation -> {
				Null,
				Null,
				Object[User]
			},
			Units :> {
				None,
				Hour,
				None
			},
			Headers -> {"Date","PriorityReturnAlarm","Responsible Party"},
			Description -> "The historical record of the PriorityReturnAlarm field.",
			Category -> "General",
			Developer -> True
		},
		PriorityReturnBufferLog -> {
			Format -> Multiple,
			Class -> {
				Date,
				Real,
				Link
			},
			Pattern :> {
				_?DateObjectQ,
				TimeP,
				_Link
			},
			Relation -> {
				Null,
				Null,
				Object[User]
			},
			Units :> {
				None,
				Hour,
				None
			},
			Headers -> {"Date","PriorityReturnBuffer","Responsible Party"},
			Description -> "The historical record of the PriorityReturnBuffer field.",
			Category -> "General",
			Developer -> True
		},
		ReturnToProtocolLog -> {
			Format -> Multiple,
			Class -> {
				Date,
				Boolean,
				Link
			},
			Pattern :> {
				_?DateObjectQ,
				BooleanP,
				_Link
			},
			Relation -> {
				Null,
				Null,
				Object[User]
			},
			Headers -> {"Date","ReturnToProtocol","Responsible Party"},
			Description -> "The historical record of the ReturnToProtocol field.",
			Category -> "General",
			Developer -> True
		},
		Overclock -> {
			Format -> Single,
			Class -> Boolean,
			Pattern :> BooleanP,
			Description -> "Indicates if this protocol can be run or continued even if its author's team has exceeded its MaxNumberOfThreads (up to 2 * MaxNumberOfThreads).",
			Category -> "General",
			Developer -> True
		},

		Resources -> {
			Format -> Multiple,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Alternatives[
				Object[Sample][CurrentProtocol],
				Object[Container][CurrentProtocol],
				Object[Part][CurrentProtocol],
				Object[Plumbing][CurrentProtocol],
				Object[Item][CurrentProtocol],
				Object[Sensor][CurrentProtocol],
				Object[Wiring][CurrentProtocol]
			],
			Description -> "The resources which are actively being used by this protocol.",
			Category -> "Resources",
			Developer -> True
		},
		RequiredResources -> {
			Format -> Multiple,
			Class -> {Link, Expression, Integer, Expression},
			Pattern :> {_Link, _Symbol, _Integer, _Integer|_Symbol},
			Relation -> {Object[Resource][Requestor], Null, Null, Null},
			Units -> {None, None, None, None},
			Description -> "Resources used by this protocol and a description of the field in which a resource's resolved object is stored. Position and index are Null when a resource's resolution is stored in a single field.",
			Category -> "General",
			Headers->{"Resource","Field Name","Field Position", "Field Index"},
			Developer -> True
		},
		SubprotocolRequiredResources -> {
			Format -> Multiple,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Object[Resource][RootProtocol],
			Description -> "The resources tied to this parent protocol, including all resources of the protocol itself and its subprotocols.",
			Category -> "Resources",
			Developer -> True
		},
		AwaitingResources -> {
			Format -> Single,
			Class -> Boolean,
			Pattern :> BooleanP,
			Description -> "Indicates if this protocol is awaiting the arrival of items before it can be begun or continued.",
			Category -> "Resources"
		},
		ShippingMaterials -> {
			Format -> Multiple,
			Class -> {Link, Link},
			Pattern :> {_Link, _Link},
			Relation -> {Alternatives[Object[Transaction, Order][DependentProtocols], Object[Transaction, ShipToECL][DependentProtocols], Object[Transaction, SiteToSite][DependentProtocols]], Alternatives[Object[Product], Object[Sample], Model[Sample], Model[Item], Object[Item]]},
			Description -> "Indicates the transactions, and the specific products or samples therein, that must be received before this protocol can be begun or continued.",
			Category -> "Resources",
			Headers -> {"Transaction", "Required Product"}
		},
		Checkpoints -> {
			Format -> Multiple,
			Class -> {String, Real, String, Link},
			Pattern :> {_String, GreaterEqualP[0*Second], _String, _Link},
			Units -> {None, Minute, None, None},
			Relation -> {Null, Null, Null, Model[User, Emerald]|Object[User, Emerald]},
			Description -> "A list of expected checkpoints and estimated time (including processing stages) for each checkpoint in the procedure of the protocol.",
			Category -> "Resources",
			Developer->True,
			Headers -> {"Name", "Duration", "Description", "Operator"}
		},
		HazardousWaste -> {
			Format -> Multiple,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Model[Sample] | Object[Sample],
			Description -> "The types of waste generated by this protocol.",
			Category -> "Resources"
		},
		DispenserContainers -> {
			Format -> Multiple,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Alternatives[
				Object[Container],
				Model[Container]
			],
			Description -> "Containers gathered as destinations for any resources obtained from a chemical dispenser.",
			Category -> "Resources"
		},
		GasSources -> {
			Format -> Multiple,
			Class-> {Expression, Link, Link},
			Pattern :> {GasP, _Link, _Link},
			Relation -> {
				Null,
				Object[Container],
				Object[Instrument]
			},
			Description -> "A list of containers that supplied gas to instruments in this protocol through plumbing connections.",
			Headers -> {"Gas Type", "Source Container", "Supplied Instrument"},
			Category -> "Resources"
		},

		(* --- Waste Handling --- *)
		WasteWeightTare -> {
			Format -> Multiple,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Object[Data][Protocol],
			Description -> "The weight data of the waste carboy before the protocol is started.",
			Category -> "Sensor Information",
			Developer -> True,
			AdminWriteOnly->True
		},
		SecondaryWasteWeightTare -> {
			Format -> Multiple,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Object[Data][Protocol],
			Description -> "The weight data of the secondary waste carboy before the protocol is started.",
			Category -> "Sensor Information",
			Developer -> True,
			AdminWriteOnly->True
		},
		WasteWeight -> {
			Format -> Multiple,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Object[Data][Protocol],
			Description -> "The weight data of the waste carboy after the protocol is completed.",
			Category -> "Sensor Information",
			Developer -> True,
			AdminWriteOnly->True
		},
		SecondaryWasteWeight -> {
			Format -> Multiple,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Object[Data][Protocol],
			Description -> "The weight data of the secondary waste carboy after the protocol is completed.",
			Category -> "Sensor Information",
			Developer -> True,
			AdminWriteOnly->True
		},
		WasteGenerated -> {
			Format -> Multiple,
			Class -> {Waste -> Link, Weight -> Real},
			Pattern :> {Waste -> _Link, Weight -> GreaterEqualP[0*Gram]},
			Units -> {Waste -> None, Weight -> Gram},
			Relation -> {Waste -> Model[Sample], Weight -> None},
			Description -> "For each type of waste generated by this protocol, the total amount (in grams) generated during the conduct of the protocol.",
			Headers -> {Waste -> "Waste Type", Weight -> "Amount"},
			Category -> "Cleaning",
			AdminWriteOnly->True
		},

		(* --- Operator handling --- *)
		Operator -> {
			Format -> Single,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Object[User, Emerald] | Model[User, Emerald],
			Description -> "Indicates the operator allowed to run this protocol.  If not populated, then all operators are allowed.",
			Category -> "Operations Information",
			Developer -> True
		},
		RequiredCertifications->{
			Format->Multiple,
			Class->Link,
			Pattern:>_Link,
			Relation->Model[Certification],
			Description->"The list of skill sets needed for an operator to execute this protocol.",
			Category->"Operations Information",
			Developer -> True
		},
		Interruptible -> {
			Format -> Single,
			Class -> Boolean,
			Pattern :> BooleanP,
			Description -> "Indicates if this protocol can be interrupted and the current operator of this protocol can be assigned to another priority protocol.",
			Category -> "Operations Information",
			Developer -> True
		},
		ReadyCheckResult -> {
			Format -> Single,
			Class -> {
				ProtocolStatus -> Expression,
				Blocked -> Boolean,
				Blockers -> Expression,
				Suspended -> Boolean,
				Suspenders -> Expression,
				Checkpoint -> String,
				CheckpointProgress -> Expression,
				CheckpointEstimates -> Expression,
				CurrentOperator -> Expression,
				CurrentOperatorName -> String,
				InstrumentsAvailable->Boolean,
				Instruments->Expression,
				ItemsAvailable->Boolean,
				Items->Expression,
				SamplesAvailable->Boolean,
				Samples->Expression,
				ObjectsInUse->Expression,
				CurrentInstrument -> Expression,
				CurrentInstrumentName -> String,
				LastInstrument -> Expression,
				LastInstrumentName -> String,
				ActiveCart -> Expression,
				ActiveCartName -> String,
				LastCart -> Expression,
				LastCartName -> String,
				LastOperator -> Expression,
				LastOperatorName -> String,
				PickUpTime -> Date,
				DateEnqueued -> Date,
				Error -> Boolean,
				DangerZone -> Boolean,
				Priority -> Boolean,
				Resolved -> Expression,
				Unresolved -> Expression,
				CanaryBranch -> String,
				VerifiedSelectAgentFree -> Boolean
			},
			Pattern :> {
				ProtocolStatus -> ProtocolStatusP|OperationStatusP,
				Blocked -> BooleanP,
				Blockers -> {{ObjectP[{Object[SupportTicket,Operations],Object[SupportTicket,UserCommunication]}],_String|Null}...},
				Suspended -> BooleanP,
				Suspenders -> {{ObjectP[{Object[SupportTicket,Operations],Object[SupportTicket,UserCommunication]}],_String|Null}...},
				Checkpoint -> _String,
				CheckpointProgress -> {{_String, _?DateObjectQ, _?DateObjectQ | Null}...},
				CheckpointEstimates -> {{_String, GreaterEqualP[0*Second], _String}...},
				CurrentOperator -> ObjectP[],
				CurrentOperatorName -> _String,
				InstrumentsAvailable->BooleanP,
				Instruments->{_Association...},
				ItemsAvailable->BooleanP,
				Items->{_Association...},
				SamplesAvailable->BooleanP,
				Samples->{_Association...},
				ObjectsInUse->{ObjectP[]...},
				CurrentInstrument -> ObjectP[],
				CurrentInstrumentName -> _String,
				LastInstrument -> ObjectP[],
				LastInstrumentName -> _String,
				ActiveCart -> ObjectP[],
				ActiveCartName -> _String,
				LastCart -> ObjectP[],
				LastCartName -> _String,
				LastOperator -> ObjectP[],
				LastOperatorName -> _String,
				PickUpTime -> _?DateObjectQ,
				DateEnqueued -> _?DateObjectQ,
				Error -> BooleanP,
				DangerZone -> BooleanP,
				Priority -> BooleanP,
				Resolved -> {{ObjectP[{Object[SupportTicket,Operations],Object[SupportTicket,UserCommunication]}],_String|Null}...},
				Unresolved -> {{ObjectP[{Object[SupportTicket,Operations],Object[SupportTicket,UserCommunication]}],_String|Null}...},
				CanaryBranch -> _String | Null,
				VerifiedSelectAgentFree -> BooleanP
			},
			Units -> {
				ProtocolStatus -> None,
				Blocked -> None,
				Blockers -> None,
				Suspended -> None,
				Suspenders -> None,
				Checkpoint -> None,
				CheckpointProgress -> None,
				CheckpointEstimates -> None,
				CurrentOperator -> None,
				CurrentOperatorName -> None,
				InstrumentsAvailable->None,
				Instruments->None,
				ItemsAvailable->None,
				Items->None,
				SamplesAvailable->None,
				Samples->None,
				ObjectsInUse->None,
				CurrentInstrument -> None,
				CurrentInstrumentName -> None,
				LastInstrument -> None,
				LastInstrumentName -> None,
				ActiveCart -> None,
				ActiveCartName -> None,
				LastCart -> None,
				LastCartName -> None,
				LastOperator -> None,
				LastOperatorName -> None,
				PickUpTime -> None,
				DateEnqueued -> None,
				Error -> None,
				DangerZone -> None,
				Priority -> None,
				Resolved -> None,
				Unresolved -> None,
				CanaryBranch -> None,
				VerifiedSelectAgentFree -> None
			},
			Headers -> {
				ProtocolStatus -> "The current OperationStatus/ProtocolStatus for the given protocol.",
				Blocked -> "Indicates if the protocol object is currently blocked by an unresolved support ticket.",
				Blockers -> "Any tickets that are currently blocking the protocol.",
				Suspended -> "Indicates if the protocol type is currently suspended by a support ticket.",
				Suspenders -> "Any tickets that are currently suspending the protocol type.",
				Checkpoint -> "The current checkpoint for the given protocol.",
				CheckpointProgress -> "The current state of checkpoints for the given protocol.",
				CheckpointEstimates -> "The estimated checkpoints for the given protocol.",
				CurrentOperator -> "The operator currently executing the protocol (or Null if no-one).",
				CurrentOperatorName -> "The name of the operator currently executing the protocol (or Null if no-one).",
				InstrumentsAvailable -> "Indicates if all required instruments are available.",
				Instruments->"Stores a list of associations describing the availability of each required instrument.",
				ItemsAvailable->"Indicates if all required items/parts are available.",
				Items->"Stores a list of associations describing the availability of each required item/part.",
				SamplesAvailable->"Indicates if all required samples are available.",
				Samples->"Stores a list of associations describing the availability of each required sample.",
				ObjectsInUse->"Stores a list of the objects that are currently being used by this protocol.",
				CurrentInstrument -> "The instrument whose status is set to InUse by the protocol.",
				CurrentInstrumentName -> "The name of the CurrentInstrument.",
				LastInstrument -> "The instrument whose status was last set to InUse by the protocol.",
				LastInstrumentName -> "The name of the LastInstrument.",
				ActiveCart -> "The cart on which the protocol's procedure is running.",
				ActiveCartName -> "The name of the ActiveCart.",
				LastCart -> "The cart on which the protocol's procedure was previously running.",
				LastCartName -> "The name of the LastCart.",
				LastOperator -> "The operator previously executing the protocol (or Null if no-one).",
				LastOperatorName -> "The name of the LastOperator.",
				PickUpTime -> "The next date at which the protocol should be picked up from processing.",
				DateEnqueued -> "The date the protocol was Enqueued.",
				Error -> "Indicates if an error occurred while fetching information.",
				DangerZone -> "Indicates if the given protocol currently requires continuous operation.",
				Priority -> "Indicates if the given protocol can be interrupted by other protocols.",
				Resolved -> "Any tickets about the protocol that are resolved.",
				Unresolved -> "Any tickets about the protocol that are unresolved, but not blocking or suspending the protocol.",
				CanaryBranch -> "The user-defined Canary branch on which the given protocol is meant to be run.",
				VerifiedSelectAgentFree -> "Indicates that the strands in this protocol have been verified to not contain any harmful sequences as defined by the Select Agents and Toxins List issued by the Food & Drug Administration (FDA)."
			},
			Description -> "Cached information describing the current state of this protocol and its resource availability.",
			Category -> "Operations Information",
			Developer -> True
		},
		ReadyCheckDateLastUpdated -> {
			Format -> Single,
			Class -> Date,
			Pattern :> _?DateObjectQ,
			Description -> "Indicates if the ReadyCheckResult is out of date and is currently being recomputed in the lab. If this field is Null and ReadyCheckResult is populated, ReadyCheckResult is up to date.",
			Category -> "Operations Information",
			Developer->True
		},
		ReadyCheckLog -> {
			Format -> Multiple,
			Class -> {Date, Boolean, Expression},
			Pattern :> ReadyCheckLogP,
			Description -> "Log of the ReadyCheck result.",
			Category -> "Operations Information",
			Headers -> {"Date","ReadyCheck Result","State of Resources"},
			Developer -> True
		},
		(* --- Storage pricing --- *)
		StoragePrice -> {
			Format -> Single,
			Class -> Real,
			Pattern :> GreaterEqualP[0*USD/Month],
			Units -> USD/Month,
			Description -> "The total monthly price for warehousing all user owned items associated with this protocol in an ECL facility under the storage conditions specified by each item.",
			Category -> "Storage Information"
		},
		StoragePrices -> {
			Format -> Multiple,
			Class -> Real,
			Pattern :> UnitsP[0*USD/Month],
			Units -> USD/Month,
			Description -> "The running tally of the total monthly price for warehousing all user owned items associated with this protocol in an ECL facility under the storage conditions specified by each item.  To find the current price, sum all values of this field.",
			Category -> "Storage Information",
			Developer -> True
		},
		StoredObjects -> {
			Format -> Multiple,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Alternatives[
				Object[Sample],
				Object[Container],
				Object[Part],
				Object[Plumbing],
				Object[Item],
				Object[Wiring]
			],
			Description -> "List of all physical items associated with this protocol that are currently being warehoused in an ECL facility.",
			Category -> "Storage Information",
			Developer->True
		},
		DateLastUsed -> {
			Format -> Single,
			Class -> Date,
			Pattern :> _?DateObjectQ,
			Description -> "Date any physical items associated with this protocol were last handled in the lab.",
			Category -> "Storage Information",
			Developer->True
		},
		PurchasedItems -> {
			Format -> Multiple,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Alternatives[
				Object[Sample][Source],
				Object[Container][Source],
				Object[Part][Source],
				Object[Plumbing][Source],
				Object[Item][Source],
				Object[Sensor][Source],
				Object[Wiring][Source]
			],
			Description -> "List of any items that were purchased on behalf of the user in the course of running this protocol.",
			Category -> "Pricing Information",
			Developer->True
		},
		SamplesOutPrices -> {
			Format -> Multiple,
			Class -> Real,
			Pattern :> UnitsP[0*USD/Month],
			Units -> USD/Month,
			Description -> "The running tally of the total monthly price for warehousing all samples generated by this protocol in an ECL facility under the storage conditions specified by each item.  To find the current price, sum all values of this field.",
			Category -> "Storage Information",
			Developer -> True
		},
		AliquotSamplesPrices -> {
			Format -> Multiple,
			Class -> Real,
			Pattern :> UnitsP[0*USD/Month],
			Units -> USD/Month,
			Description -> "The running tally of the total monthly price for warehousing all aliquot samples associated with this protocol in an ECL facility under the storage conditions specified by each item.  To find the current price, sum all values of this field.",
			Category -> "Storage Information",
			Developer -> True
		},
		PurchasedItemsPrices -> {
			Format -> Multiple,
			Class -> Real,
			Pattern :> UnitsP[0*USD/Month],
			Units -> USD/Month,
			Description -> "The running tally of the total monthly price for warehousing all items purchased in the course of running this protocol in an ECL facility under the storage conditions specified by each item.  To find the current price, sum all values of this field.",
			Category -> "Storage Information",
			Developer -> True
		},

		(* --- Sample Storage --- *)
		SamplesInStorage -> {
			Format -> Multiple,
			Class -> Expression,
			Pattern :> SampleStorageTypeP|Disposal,
			IndexMatching -> SamplesIn,
			Description -> "For each member of SamplesIn, The storage conditions under which any input samples to this experiment should be stored after their usage in this experiment.",
			Category -> "Sample Storage"
		},
		AliquotStorage -> {
			Format -> Multiple,
			Class -> Expression,
			Pattern :> SampleStorageTypeP|Disposal,
			IndexMatching->AliquotSamples,
			Description -> "For each member of AliquotSamples, The storage conditions under which any aliquot samples generated by this experiment should be stored after the protocol is completed.",
			Category -> "Sample Storage"
		},
		SamplesOutStorage -> {
			Format -> Multiple,
			Class -> Expression,
			Pattern :> SampleStorageTypeP|Disposal,
			IndexMatching->SamplesOut,
			Description -> "For each member of SamplesOut, the storage conditions under which any output samples generated by this experiment should be stored after the protocol is completed.",
			Category -> "Sample Storage"
		},

		(* --- Option Handling --- *)
		ResolvedOptions -> {
			Format -> Single,
			Class -> Compressed,
			Pattern :> {_Rule...},
			Units -> None,
			Description -> "The final options used as parameters for this protocol, after automatic options are resolved.",
			Category -> "Option Handling"
		},
		UnresolvedOptions -> {
			Format -> Single,
			Class -> Compressed,
			Pattern :> {_Rule...},
			Units -> None,
			Description -> "The verbatim options originally input by the protocol author to generate this protocol, often with some options set to Automatic.",
			Category -> "Option Handling"
		},

		(* --- Migration Support --- *)
		LegacyID -> {
			Format -> Single,
			Class -> String,
			Pattern :> _String,
			Description -> "The SLL2 ID for this Object, if it was migrated from the old data store.",
			Category -> "Migration Support",
			Developer -> True
		},
		FilteredSamples -> {
			Format -> Multiple,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Object[Sample],
			Description -> "Samples corresponding to filtered eluents of SamplesIn generated during sample preparation and intended for use in this experiment.",
			Category -> "Sample Preparation"
		},
		Centrifuge -> {
			Format -> Single,
			Class -> Expression,
			Pattern :> BooleanP,
			Description -> "Indicates if the SamplesIn will be centrifuged prior to performing the experiment.",
			Category -> "Sample Preparation",
			Developer -> True
		},
		(* --- Aliquoting --- *)
		Aliquot -> {
			Format -> Single,
			Class -> Expression,
			Pattern :> BooleanP,
			Description -> "Indicates if aliquots are taken from the SamplesIn and transferred into new AliquotSamples which are prepared and used in lieu of the SamplesIn for the experiment.",
			Category -> "Aliquoting",
			Developer -> True
		},
		AliquotSamples -> {
			Format -> Multiple,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Object[Sample],
			Description -> "Samples corresponding to aliquots of SamplesIn generated during sample preparation and intended for use in this experiment.",
			Category -> "Aliquoting"
		},
		AliquotContainers -> {
			Format -> Multiple,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Alternatives[
				Object[Container],
				Model[Container]
			],
			Description -> "Containers that hold AliquotSamples generated during sample preparation and intended for use in this experiment.",
			Category -> "Aliquoting"
		},
		SaveAliquots -> {
			Format -> Single,
			Class -> Expression,
			Pattern :> BooleanP,
			Description -> "Indicates if the AliquotSamples should be stored after the experiment, rather than being discarded.",
			Category -> "Aliquoting"
		},
		ConsolidateAliquots -> {
			Format -> Single,
			Class -> Expression,
			Pattern :> BooleanP,
			Description -> "Indicates if identical aliquots should be consolidated in a single sample.",
			Category -> "Aliquoting"
		},
		AliquotPreparation -> {
			Format -> Single,
			Class -> Expression,
			Pattern :> PreparationMethodP,
			Description -> "Indicates if the aliquotting should occur manually or on a robotic liquid handler.",
			Category -> "Aliquoting"
		},
		(*MinimizeTransfers -> {
			Format -> Single,
			Class -> Expression,
			Pattern :> BooleanP,
			Description -> "Indicates if samples should be consolidated into an input container when possible if samples are requested to go to the same aliquot container and the whole sample is being transferred.",
			Category -> "Aliquoting"
		},*)
		AliquotVolumes -> {
			Format -> Multiple,
			Class -> Real,
			Pattern :> GreaterP[0*Micro*Liter],
			Units -> Liter Micro,
			Description -> "For each member of SamplesIn, the volume transferred from the sample into the aliquot sample which is used in lieu of the initial sample for the experiment.",
			Category -> "Aliquoting",
			IndexMatching->SamplesIn
		},
		AliquotMasses -> {
			Format -> Multiple,
			Class -> Real,
			Pattern :> GreaterP[0*Milligram],
			Units -> Milligram,
			Description -> "For each member of SamplesIn, the mass of a solid transferred from the sample into the aliquot sample which is used in lieu of the initial sample for the experiment.",
			Category -> "Aliquoting",
			IndexMatching->SamplesIn
		},
		AliquotAmounts -> {
			Format -> Multiple,
			Class -> VariableUnit,
			Pattern :> GreaterP[0*Milliliter] | GreaterP[0*Milligram] | GreaterP[0*Unit, 1*Unit],
			Units -> None,
			Description -> "For each member of SamplesIn, the amount transferred from the sample into the aliquot sample which is used in lieu of the initial sample for the experiment.",
			Category -> "Aliquoting",
			IndexMatching->SamplesIn
		},
		TargetConcentrations -> {
			Format -> Multiple,
			Class -> Expression,
			Pattern :> GreaterP[0*Micro*Molar] | GreaterP[0 (Milligram/Milliliter)],
			Description -> "For each member of SamplesIn, the final concentration of analyte in the aliquot sample which is used in lieu of the initial sample for the experiment.",
			Category -> "Aliquoting",
			IndexMatching->SamplesIn
		},
		AssayVolumes -> {
			Format -> Multiple,
			Class -> Real,
			Pattern :> GreaterEqualP[0*Micro*Liter],
			Units -> Liter Micro,
			Description -> "For each member of SamplesIn (or PooledSamplesIn), the total volume of the reaction mixture which is used in lieu of the initial sample for the experiment.",
			Category -> "Aliquoting"
		},
		AssayBuffers -> {
			Format -> Multiple,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Alternatives[
				Object[Sample],
				Model[Sample]
			],
			Description -> "For each member of SamplesIn (or PooledSamplesIn), the final buffers used to generate AliquotSamples by aliquoting SamplesIn.",
			Category -> "Aliquoting"
		},
		ConcentratedBuffers -> {
			Format -> Multiple,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Alternatives[
				Object[Sample],
				Model[Sample]
			],
			Description -> "For each member of SamplesIn (or PooledSamplesIn), the concentrated buffer source which is added to the AliquotSamples to obtain 1x buffer concentration after dilution of the AliquotSamples which are used in lieu of the SamplesIn for the experiment.",
			Category -> "Aliquoting"
		},
		BufferDilutionFactors -> {
			Format -> Multiple,
			Class -> Real,
			Pattern :> GreaterP[0],
			Units -> None,
			Description -> "For each member of SamplesIn (or PooledSamplesIn), he dilution factor by which the concentrated buffer is diluted in preparing the AliquotSamples to obtain a 1x buffer concentration after dilution of the AliquotSamples which are used in lieu of the SamplesIn for the experiment.",
			Category -> "Aliquoting"
		},
		BufferDiluents -> {
			Format -> Multiple,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Alternatives[
				Object[Sample],
				Model[Sample]
			],
			Description -> "For each member of SamplesIn (or PooledSamplesIn), the diluent used to dilute the concentration of the concentrated buffer in preparing the AliquotSamples which are used in lieu of the SamplesIn for the experiment.",
			Category -> "Aliquoting"
		},
		ConcentratedBuffer -> {
			Format -> Single,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Alternatives[
				Object[Sample],
				Model[Sample]
			],
			Description -> "The concentrated buffer source which is added to each of the AliquotSamples to obtain 1x buffer concentration after dilution of the AliquotSamples which are used in lieu of the SamplesIn for the experiment.",
			Category -> "Aliquoting"
		},
		BufferDilutionFactor -> {
			Format -> Single,
			Class -> Integer,
			Pattern :> GreaterP[0],
			Units -> None,
			Description -> "The dilution factor by which the concentrated buffer is diluted in preparing the AliquotSamples to obtain a 1x buffer concentration after dilution of the AliquotSamples which are used in lieu of the SamplesIn for the experiment.",
			Category -> "Aliquoting"
		},
		BufferDiluent -> {
			Format -> Single,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Alternatives[
				Object[Sample],
				Model[Sample]
			],
			Description -> "The diluent used to dilute the concentration of the concentrated buffer in preparing the AliquotSamples which are used in lieu of the SamplesIn for the experiment.",
			Category -> "Aliquoting"
		},
		AssayBuffer -> {
			Format -> Single,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Alternatives[
				Object[Sample],
				Model[Sample]
			],
			Description -> "The desired buffer for the AliquotSamples which are used in lieu of the SamplesIn for the experiment.",
			Category -> "Aliquoting"
		},
		MeasureVolume -> {
			Format -> Single,
			Class -> Expression,
			Pattern :> BooleanP,
			Description -> "Indicates if the volume of the liquid samples modified in the course of the experiment are measured after running the experiment.",
			Category -> "Sample Post-Processing"
		},
		MeasureWeight -> {
			Format -> Single,
			Class -> Expression,
			Pattern :> BooleanP,
			Description -> "Indicates if the weight of the solid samples modified in the course of the experiment are measured after running the experiment.",
			Category -> "Sample Post-Processing"
		},
		Measure -> {
			Format -> Single,
			Class -> Expression,
			Pattern :> BooleanP,
			Description -> "Indicates if the volume/weight of the samples modified in the course of the experiment are measured after running the experiment.",
			Category -> "Sample Post-Processing"
		},
		Storage -> {
			Format -> Single,
			Class -> Expression,
			Pattern :> SampleStorageTypeP|Disposal,
			Description -> "Indicates the conditions under which any samples generated by this experiment are stored after the protocol is completed.",
			Category -> "Sample Post-Processing"
		},
		Branch -> {
			Format -> Single,
			Class -> String,
			Pattern :> _String,
			Description -> "The git branch that this protocol should be run on.",
			Category -> "General"
		},

		ParallelComputations -> {
			Format -> Multiple,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Alternatives[
				Object[Notebook, Job],
				Object[Software, ManifoldKernelCommand]
			],
			Description -> "List of computational jobs generated and run in parallel to the execution of this protocol.",
			Category -> "Computations"
		},
		ComputationsOutstanding -> {
			Format -> Single,
			Class -> Boolean,
			Pattern :> BooleanP,
			Description -> "Indicates if any of the computation jobs in ParallelComputations have not yet completed.",
			Category -> "Computations"
		},
		ErroneousComputations -> {
			Format -> Multiple,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Alternatives[
				Object[Notebook, Job],
				Object[Software, ManifoldKernelCommand]
			],
			Description -> "List of computational jobs generated and run in parallel to the execution of this protocol in which a warning or error was thown, or that did not finish.",
			Category -> "Computations"
		},
		ReadyCheckComputations -> {
			Format -> Multiple,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Object[Notebook, Job],
			Description -> "The list of manifold job notebooks that was used to evaluate ReadyCheck for this protocol.",
			Category -> "Computations"
		},
		Streams -> {
			Format -> Multiple,
			Class -> Link,
			Pattern :> _Link,
			Relation -> Object[Stream][Protocol],
			Description -> "The list of video streams associated with this protocol.",
			Category -> "General"
		}
	}
}];
